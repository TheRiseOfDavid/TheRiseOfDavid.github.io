<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>惠特科技產學合作</title>
    <url>/2020/05/05/computer_image_teach/</url>
    <content><![CDATA[<h2 id="主要"><a href="#主要" class="headerlink" title="主要"></a>主要</h2><p>此網頁主要是在幫助大衛在 惠特科技專案一 期間中所遇到的 圖像演算法 問題。</p>
<p>並非教學用，但學習資源會在這並透過我加以整理。</p>
<ol>
<li>Laplace <ul>
<li><a href="https://blog.csdn.net/fengbingchun/article/details/79321200" target="_blank" rel="noopener">图像边缘检测之拉普拉斯(Laplacian)C++实现</a></li>
<li><a href="https://blog.csdn.net/qq_38131594/article/details/80776367" target="_blank" rel="noopener">拉普拉斯边缘检测</a></li>
<li><a href="https://blog.csdn.net/u013580497/article/details/46822121" target="_blank" rel="noopener">【数字图像处理之三】拉普拉斯边缘检测算法</a> </li>
<li><a href="https://medium.com/@sourabhjigjinni/install-opencv-4-0-0-for-c-windows-7-10-code-blocks-tdm-gcc-64-dff65addf162" target="_blank" rel="noopener">Install OpenCV 4.1.0 for C++, Windows 7/10, Code::Blocks</a></li>
<li><a href="https://stackoverflow.com/questions/38834729/cmake-libintl-8-dll-is-missing-from-your-computer/56814576?fbclid=IwAR1nQoYHNKFja-ZoX-QtfzP27IC5DVMTIDtQfW-TnBf3qi3mtPF2gSxBfIg" target="_blank" rel="noopener">CMAKE libintl-8.dll is missing from your computer</a></li>
<li><a href="https://debbiedbaby.pixnet.net/blog/post/426657881" target="_blank" rel="noopener">【c#】 emgucv 設定</a></li>
<li><a href="https://dotblogs.com.tw/april_notes/2019/05/14/cinque" target="_blank" rel="noopener">EMGU 與 Visual studio 的裝設方法 (範例為 x64 / Release )</a></li>
<li><a href="https://dotblogs.com.tw/v6610688/2013/12/25/emgucv_cvinvoke_typeinitailization_exception?fbclid=IwAR1f5XwXNiYp_CEC76fbU5y1NgStfWvcYIlzY-GFJatk_2DIKteiLWdxwFs" target="_blank" rel="noopener">[EmguCV]CvInvoke的型別初始化設定發生例外 (CvInvoke TypeInitialization Exception) 處理</a></li>
<li><a href="https://me1237guy.pixnet.net/blog/post/61614517" target="_blank" rel="noopener">Emgu CV: 基礎影像容器Mat</a></li>
<li><a href="http://dangerlover9403.pixnet.net/blog/post/213895974?fbclid=IwAR24_9mIqb5VJyXx2EAVd9fq2wcx1WpJW78pm1IdShUxSEQrSPhcagdphRo" target="_blank" rel="noopener">[教學]C# EmguCV教學-圖像輪廓處理方式-拉普拉斯(Laplace)</a></li>
<li><a href="http://dangerlover9403.pixnet.net/blog/post/213568605-%5B%E6%95%99%E5%AD%B8%5Dc%23-emgucv---%E5%BB%BA%E7%BD%AE%E7%92%B0%E5%A2%83" target="_blank" rel="noopener">[教學]C# EmguCV - 建置環境</a></li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>學習筆記</category>
      </categories>
      <tags>
        <tag>產學合作</tag>
      </tags>
  </entry>
  <entry>
    <title>PS 快速將底層顏色替換</title>
    <url>/2020/07/17/PS-replace-color/</url>
    <content><![CDATA[<blockquote>
<p>此文章記錄快速在 PS 將底層顏色替換方法 </p>
</blockquote>
<a id="more"></a>

<h2 id="問題描述"><a href="#問題描述" class="headerlink" title="問題描述"></a>問題描述</h2><p>這張圖片沒有圖層讓我去修改背景顏色！，那這時候我要怎麼做才能快速修改呢?</p>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>使用 PS 功能中的<strong>取代顏色</strong></p>
<p>步驟如下(粗體字代表為需要點擊)：</p>
<ol>
<li><strong>影像</strong></li>
<li><strong>調整</strong></li>
<li><strong>取代顏色</strong></li>
<li>接下來你一定會做！</li>
</ol>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>PhotoShop 是我最喜歡也是最擅長的編輯圖片軟體了，它的功能到現在我都還沒完全摸會，希望我能夠好好學會他、精熟他!</p>
]]></content>
      <categories>
        <category>學習筆記</category>
      </categories>
      <tags>
        <tag>PhotoShop</tag>
      </tags>
  </entry>
  <entry>
    <title>甚麼是 RESTAPI ?</title>
    <url>/2020/07/23/API/</url>
    <content><![CDATA[<h2 id="內容說明"><a href="#內容說明" class="headerlink" title="內容說明"></a>內容說明</h2><blockquote>
<p>此文章講述於 RESTAPI 的大概使用方法與使用時機，並沒有詳細解釋，詳細解釋還需讀閱他人優秀文章</p>
</blockquote>
<a id="more"></a>

<h2 id="甚麼是-API"><a href="#甚麼是-API" class="headerlink" title="甚麼是 API?"></a>甚麼是 API?</h2><p>就是別人把資料給你，你再把那些資料處理成資訊後再給別人，然後是透過 url 來進行交換的入口</p>
<h2 id="API-Method"><a href="#API-Method" class="headerlink" title="API Method"></a>API Method</h2><ul>
<li>POST：新增</li>
<li>GET：讀取</li>
<li>PUT：修改（修改整份文件）</li>
<li>PATCH：修改（修改其中幾個欄位）</li>
<li>DELETE：刪除</li>
</ul>
<h2 id="API-回傳資料"><a href="#API-回傳資料" class="headerlink" title="API 回傳資料"></a>API 回傳資料</h2><table>
<thead>
<tr>
<th>狀態</th>
<th>英文</th>
<th>中文</th>
<th>說明</th>
</tr>
</thead>
<tbody><tr>
<td>200</td>
<td>OK</td>
<td>完成</td>
<td>通常在 get 時使用</td>
</tr>
<tr>
<td>201</td>
<td>Created</td>
<td>資源新增成功</td>
<td>通常在 post 時使用</td>
</tr>
<tr>
<td>202</td>
<td>Accepted</td>
<td>請求接受，但在處理中</td>
<td>有可能會失敗</td>
</tr>
<tr>
<td>204</td>
<td>No Content</td>
<td>請求成功，但沒有返回內容</td>
<td>通常用在刪除或修改</td>
</tr>
<tr>
<td>400</td>
<td>Bad Request</td>
<td>錯誤請求</td>
<td>通常有欄位未填寫或填寫錯誤</td>
</tr>
<tr>
<td>401</td>
<td>Unauthorized</td>
<td>使用者沒有進行驗證</td>
<td></td>
</tr>
<tr>
<td>403</td>
<td>Forbidden</td>
<td>使用者已經登入，但沒有權限操作</td>
<td></td>
</tr>
<tr>
<td>410</td>
<td>Gone</td>
<td>資源已經過期</td>
<td></td>
</tr>
<tr>
<td>500</td>
<td>Internal Server Error</td>
<td>伺服器端錯誤</td>
<td></td>
</tr>
<tr>
<td>502</td>
<td>Bad Gateway</td>
<td>伺服器某個服務沒有被正確執行</td>
<td></td>
</tr>
<tr>
<td>503</td>
<td>Service Unavailable</td>
<td>伺服器臨時維護或即將死亡，暫時無法處理請求</td>
<td></td>
</tr>
<tr>
<td>504</td>
<td>Gateway Timeout</td>
<td>伺服器上服務回應</td>
<td></td>
</tr>
</tbody></table>
<h2 id="觀念釐清："><a href="#觀念釐清：" class="headerlink" title="觀念釐清："></a>觀念釐清：</h2><h3 id="POST-跟-GET-主要差在哪裡呢？"><a href="#POST-跟-GET-主要差在哪裡呢？" class="headerlink" title="POST 跟 GET 主要差在哪裡呢？"></a>POST 跟 GET 主要差在哪裡呢？</h3><p>根據我的經驗(對不起我經驗連一年都沒有滿 QQ)，我盡可能來進行解釋。</p>
<h4 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h4><ul>
<li>比較像是明信片，只能傳送簡單資訊。</li>
<li>通常會將你傳送的資訊放在 url 之後。</li>
<li>沒有 body，畢竟明信片也沒有 Body XD。</li>
<li>如果有壞蛋想要看你寫甚麼，只要抓到你傳送的 url 就好，安全性較低。<h4 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h4></li>
<li>比較像是信封，可以傳送複雜資訊。</li>
<li>通常是將你 post 的資訊放入 body 內。</li>
<li>比起 get 有保障些，你傳送的資訊較沒有那麼容易就能被他人得知。</li>
</ul>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結:"></a>參考連結:</h2><p><a href="https://medium.com/%E5%B0%8F%E5%B0%8F%E8%AA%AA%E6%9B%B8%E4%BA%BA/%E7%B6%B2%E9%A0%81get-%E8%88%87-post-%E5%B7%AE%E7%95%B0-%E7%A7%91%E6%99%AE%E5%A3%B9%E9%BB%9E%E9%80%9A-94cbaa666fdb" target="_blank" rel="noopener">網頁Get 與 Post 差異 (科普壹點通)</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>API 其實蠻好用，只是有點偏複雜。還需要多加磨練，我也要能夠讓自己變得更優秀，也謝謝各位前輩的努力。<br>也謝謝 台灣STEAM基礎教育聯盟給予我機會使我成長，對不起我有時候速度拖太慢。</p>
]]></content>
      <categories>
        <category>學習筆記</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>RESTAPI</tag>
      </tags>
  </entry>
  <entry>
    <title>透過 ngrok 來讓自己的電腦成為 server</title>
    <url>/2020/07/24/ngrok-experience/</url>
    <content><![CDATA[<h2 id="內容說明"><a href="#內容說明" class="headerlink" title="內容說明"></a>內容說明</h2><blockquote>
<p>如何讓自己的電腦變成 server，來方便自己測試或架設!<br>使用 ngrok 就對搂~</p>
</blockquote>
<a id="more"></a>

<h2 id="安裝教學"><a href="#安裝教學" class="headerlink" title="安裝教學"></a>安裝教學</h2><p>先去官網 <a href="https://ngrok.com/download" target="_blank" rel="noopener">下載ngrok</a>，安裝完成後將 exe，拉出來並執行。<br>接下來去官網登入，沒有就註冊。</p>
<p>註冊後有此詳細教學，跟隨教學即可。</p>
<p>在這邊提供我的頁面，方便使用者確認並且沒有走錯</p>
<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=19O15rqQ0fGcl-zDrfW9GWb6dTLMTzweK&export=download" alt=""></p>
</blockquote>
<p>記住 authtoken 一定要正確喔。</p>
<h2 id="使用教學"><a href="#使用教學" class="headerlink" title="使用教學"></a>使用教學</h2><p>這官網都教你且教導的一定比我還好，就交給官網。</p>
<p>之後打 terminal 先找到 ngrok，然後呼叫他並且在後面打上<code>協定+端口</code>，就可以成為伺服器了！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;ngrok http y</span><br></pre></td></tr></table></figure>

<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>真的要謝謝各位科技前輩讓我學會這些事物，也要謝謝基礎教育聯盟讓我有機會學習新事物，真的很謝謝陪我的各位！</p>
]]></content>
      <categories>
        <category>學習筆記</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>ngrok</tag>
        <tag>server</tag>
      </tags>
  </entry>
  <entry>
    <title>ProblemK Assigning Frequencies (暴力搜尋 Brute force)</title>
    <url>/2020/08/18/ICPC/2017-ICPC-Asia-Taipei-Hualien-Regional-Pk/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>給你一張圖，這圖不會超過 25 個 Node，試問能不能用 3 個顏色塗滿所有點但相鄰的點不能有相同顏色。<br>題目提示: 測資不會超過 85 筆。</p>
</blockquote>
<a id="more"></a>

<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>如果對暴力搜尋法有一定了解的人，應該看到題目就會馬上想到暴力搜尋法了吧！<br>可惜我不是，我用了一個奇怪的想法然後還沒解開…。(有興趣的可以往下滑)</p>
<h3 id="甚麼時機該用暴力搜尋法？"><a href="#甚麼時機該用暴力搜尋法？" class="headerlink" title="甚麼時機該用暴力搜尋法？"></a>甚麼時機該用暴力搜尋法？</h3><ol>
<li>題目有告訴你測資不超過幾筆，但那數字卻不大</li>
<li>圖也不大，相較於其他圖論的題目</li>
<li>明顯看到他的測資基本上不大於 100 or 1000，應題目而定</li>
</ol>
<p>由於是暴力搜尋法，也沒有甚麼好講，但他有一地方神奇就在於遞迴。讓我來稍微解說下:</p>
<h3 id="依序新增一點，然後塗色"><a href="#依序新增一點，然後塗色" class="headerlink" title="依序新增一點，然後塗色"></a>依序新增一點，然後塗色</h3><p>這是我認為最為有趣的地方，也是最困擾我的地方。一開始我認為這遞迴非常好寫，輕輕鬆鬆，開始寫以後才證明我錯了，在這邊呼籲各位不要精神 AC 阿，真的，魔鬼藏在細節裡。</p>
<p>由於他依序新增一點，所以她其實在過程中，並不是完整的圖而是分裂的，但沒關係。不影響我們作答，因為之後連起來時就會發現顏色一樣而再將點更改顏色。如果都不行就可以直接 FALSE。</p>
<p>塗色，你是要幫下一個點選色。這是遞迴裡面最有魅力的地方，明明是 a 的遞迴 time，但卻幫 b 做好顏色選擇。你可能會覺得很奇怪？<br>但你仔細想想，如果不這樣做的話，那你在 a 的遞迴才幫 a 做塗色，那複雜度雖然一樣，但程式碼就非常亂了，因為要考慮你是因為 3 個顏色都不行呢？還是這顏色可以通過。這兩種情況下，你可能還需要一個 flag 之類的東西來判斷，不好看。太醜了。<br>但這點我也是觀看別人程式碼，我才懂得。寫這份文件的人果真大神。</p>
<h3 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h3><p>我在解這題時，是閱讀觀看這位<a href="https://www.twblogs.net/a/5b8ee83f2b7177188348a611" target="_blank" rel="noopener">大神</a>才得以解出的，謝謝他。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 30</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> path[MAXN][MAXN] = &#123;&#125; ;</span><br><span class="line"><span class="keyword">int</span> node[MAXN] = &#123;&#125; ;</span><br><span class="line"><span class="keyword">int</span> n , p , N ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; v ; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(path[v][i] &amp;&amp; node[v] == node[i])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n == v<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; <span class="number">3</span> ; j++)&#123;</span><br><span class="line">        node[v+<span class="number">1</span>] = j ;</span><br><span class="line">        <span class="keyword">if</span>(DFS(v+<span class="number">1</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span> ;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">int</span> _i , _j ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N ;</span><br><span class="line">    <span class="keyword">while</span>(N--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; p ;</span><br><span class="line">        <span class="comment">//clear</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; n ; j++)</span><br><span class="line">                path[i][j] = <span class="number">0</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; p ; i++ )&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; _i &gt;&gt; _j ;</span><br><span class="line">            path[_i][_j] = <span class="number">1</span> ;</span><br><span class="line">            path[_j][_i] = <span class="number">1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(DFS(<span class="number">0</span>))</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Y"</span> ;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"N"</span> ;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="我再看到此題的想法"><a href="#我再看到此題的想法" class="headerlink" title="我再看到此題的想法:"></a>我再看到此題的想法:</h2><p>這裡是廢文。如果不想要了解我的想法可以直接略過，因為我的想法是錯誤的。但如果想看看我的思考邏輯就建議看看。</p>
<p>我一開始看到這題目時，就想到簡單 2 顏色塗色問題，想說直接用 BFS，搞定！但絕對沒有那麼簡單啊 XD，於是我就想出一方法關於我要怎麼解出這題目。<br>怎麼做呢，用有點類似於 DP 的方式，開一 struct，裡面放入一陣列代表有 3 顏色，只要他相鄰的點有被用過的顏色，那此點就不能用這顏色，只要附近的點都將 3 種顏色都用過就輸出 N，是不是覺得我的想法還不賴！當初的我也覺得我的想法很不錯，所以就用了這方式。</p>
<p>寫出來後，丟去 judge，卻發現是錯的！可是錯在哪裡我不知道…，非常討厭。於是我就去問了我的朋友們，但我的朋友們似乎也不太清楚，於是就問了奧林匹亞銅牌國手，他說出了一句令我震驚的話。<br><img src="./images/2017-ICPC-Asia-Taipei-Hualien-Regional-Pk/1.jpg" alt=""></p>
<p>原來剛剛的我試圖在嘗試不可能的任務阿，怕。差點我就能把 3 塗色問題的演算法名稱掛上大衛了www，沒，開玩笑的。於是我就也放棄了此題，使用暴力搜尋法 ಥ⌣ಥ。</p>
<p>下面是我寫的程式碼(我的想法)，有興趣的可以拿去研究看看www。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path[<span class="number">30</span>] ;</span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; nodes ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N , n , p  ;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> color[<span class="number">3</span>] = &#123;&#125; ;</span><br><span class="line">    <span class="keyword">int</span> use = <span class="number">0</span> ;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">        color[<span class="number">0</span>] = <span class="number">0</span> ;</span><br><span class="line">        color[<span class="number">1</span>] = <span class="number">0</span> ;</span><br><span class="line">        color[<span class="number">2</span>] = <span class="number">0</span> ;</span><br><span class="line">        use = <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;node[<span class="number">30</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">choose</span><span class="params">(<span class="keyword">int</span> i , <span class="keyword">int</span> k )</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; path[i].<span class="built_in">size</span>() ; j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!node[path[i][j]].use)&#123;</span><br><span class="line">            nodes.push_back(path[i][j]);</span><br><span class="line">            node[path[i][j]].use = <span class="number">1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(node[path[i][j]].color[k])</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> i )</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span> ; k &lt; <span class="number">3</span> ; k++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(node[i].color[k])</span><br><span class="line">            <span class="keyword">continue</span> ;</span><br><span class="line">        <span class="keyword">if</span>(choose(i,k))&#123;</span><br><span class="line">            node[i].color[k] = <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BFS</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//node[0].color[0] = 1 ;</span></span><br><span class="line">    nodes.push_back(<span class="number">0</span>) ;</span><br><span class="line">    node[<span class="number">0</span>].use = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span>(nodes.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">if</span>(!check(nodes.front()))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">        nodes.pop_front();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">int</span> i , j ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N ;</span><br><span class="line">    <span class="keyword">while</span>(N--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; p ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//clear</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i++)&#123;</span><br><span class="line">            path[i].<span class="built_in">clear</span>() ;</span><br><span class="line">            node[i].<span class="built_in">clear</span>() ;</span><br><span class="line">        &#125;</span><br><span class="line">        nodes.<span class="built_in">clear</span>() ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//bulid</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span> ; k &lt; p ; k++)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; i &gt;&gt; j ;</span><br><span class="line">            path[i].push_back(j) ;</span><br><span class="line">            path[j].push_back(i) ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(BFS())</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Y"</span> ;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"N"</span> ;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*//debug</span></span><br><span class="line"><span class="comment">        for(int i = 0 ; i &lt; n ; i++)&#123;</span></span><br><span class="line"><span class="comment">            cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; node[i].color[0] &lt;&lt; ' ' &lt;&lt; node[i].color[1] &lt;&lt; ' ' &lt;&lt; node[i].color[2] &lt;&lt; '\n' ;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ICPC</category>
      </categories>
      <tags>
        <tag>ICPC</tag>
        <tag>程式解題</tag>
        <tag>2017-ICPC-Asia-Taipei-Hualien-Regional</tag>
        <tag>暴力搜尋 Brute force</tag>
      </tags>
  </entry>
  <entry>
    <title>C#_大衛製作套件</title>
    <url>/2020/07/15/C_sharp/Csharp_gauss/</url>
    <content><![CDATA[<blockquote>
<p>此套件為大衞製作，方便未來的我可以直接套用套件。<br>若要使用，在 VS 上加入參考加入 gauss.dll 即可使用</p>
</blockquote>
<a id="more"></a>


<h2 id="C-套件"><a href="#C-套件" class="headerlink" title="C# 套件"></a>C# 套件</h2><p>此套可解決於多元一次方程式組解，快速且有效率解法<br>P.S. 技術僅限到更新日期</p>
<p><a href="https://drive.google.com/file/d/1GB_UtHQ0Ja1pWHgObjNUCXonvex5NknS/view?usp=sharing" target="_blank" rel="noopener">gauss 套件下載</a></p>
<p><strong>必須加入 using guass;</strong></p>
<h3 id="高斯消去法"><a href="#高斯消去法" class="headerlink" title="高斯消去法"></a>高斯消去法</h3><h4 id="宣告物件"><a href="#宣告物件" class="headerlink" title="宣告物件"></a>宣告物件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gauss test &#x3D; new gauss(int n ,doublue[,]  douGauss , double[] ans )</span><br></pre></td></tr></table></figure>

<p>n = 有多少階數<br>douGauss = 所有行係數的陣列<br>ans = 每元的係數</p>
<h4 id="prepare-測試用方法"><a href="#prepare-測試用方法" class="headerlink" title="prepare()  測試用方法"></a>prepare()  測試用方法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gauss.prepare() ;</span><br></pre></td></tr></table></figure>

<p>透過 console.wrire 來輸入 n , douGauss , ans<br>方便使用者加入 gauss 中的變數</p>
<h4 id="elimindation-高斯消元法"><a href="#elimindation-高斯消元法" class="headerlink" title="elimindation() 高斯消元法"></a>elimindation() 高斯消元法</h4><p><a href="https://zh.wikipedia.org/wiki/%E9%AB%98%E6%96%AF%E6%B6%88%E5%8E%BB%E6%B3%95" target="_blank" rel="noopener">高斯消元法</a>說明</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gauss.elimindation() ;</span><br></pre></td></tr></table></figure>

<h4 id="seidel-method-賽德爾疊代-and-SOR-超鬆弛迭代法"><a href="#seidel-method-賽德爾疊代-and-SOR-超鬆弛迭代法" class="headerlink" title="seidel_method() 賽德爾疊代 and SOR 超鬆弛迭代法"></a>seidel_method() 賽德爾疊代 and SOR 超鬆弛迭代法</h4><p><a href="https://www.maa.org/press/periodicals/loci/joma/iterative-methods-for-solving-iaxi-ibi-gauss-seidel-method" target="_blank" rel="noopener">賽德爾疊代</a>說明<br>在 2020/06/08 時將 seidel_method() 優化，現在已經在任何情況下比消元速度還快</p>
<p><a href="http://marta.certik.cz/NM/Asor.pdf" target="_blank" rel="noopener">超鬆弛迭代法</a>說明<br>在 2020/07/15 時由於 SOR 是找 omega 來進行鬆弛(P.S. seidel_method() 為 1)，由於 omega 在每個多元一次方成組解時 omega 量為不固定，要找出對應的 omega 計算十分複雜(且我尚未讀熟，如果有大佬懂可以教我嗎 QQ) ，於是我目前先將 omega 定為 1.1。</p>
<p>Q: 為甚麼 omega 是 1.1?<br>A: 我曾訂過 0.658 , 1.658 發現都不如預期，在大多數情況下多元一次方成組 omega 大多分布在 1.1 ~ 1.3 之間，於是我選擇 1.1，如果大家不喜歡的話可以在裡面帶自訂數值。</p>
<p>Q: it 是甚麼? <del>可以吃嗎</del><br>A: 不行啦， it 是自訂迭代次數，你可以自己設定想迭代幾層，預設 -1 為完美迭代，即答案必求到絕對正確。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gauss.Seidel_method(double omega &#x3D; 1.1 , int it &#x3D; -1);</span><br></pre></td></tr></table></figure>

<h3 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h3><p>在開發　gauss 套件時，其實花了很多時間在 Debug 與 效率優化，由於分手的關係，這真的是非常痛苦的過程阿…。工程師需要讓自己不被情緒給影響真的有些許的困難，我們也要能夠在 coding 過程中注意到女朋友，不可以讓女生感覺到自己已經不在意他，消耗愛的能量，導致愛情與悲劇收場。</p>
<p>然後再鑽寫程式的過程中，我發現出了一個極大的問題。使我的「賽德爾疊代」應該要能夠比「高斯消元法」速度還要快，但因為原先我的「賽德爾疊代」在陣列方式處理不佳，過程中浪費大量效率使我矩陣在 &gt; 500 時速度會比「高斯消元法」過慢。</p>
<p>因為在 seidel_method 中每次都需要 k+1 的迭代，於是原先我的程式寫法是準備一個巨大的迭代陣列，但我發現 二維陣列 當索引值太大時，查找速度會過慢，在大量迭代之下就會將此問題放大。於是後來將迭代陣列弄成 二維，類似於 array[2][n] (因為每次迭代只需要 k+1 , k )，相對來說查找速度就快很多。在 500*500的陣列中，原先使用 seidel_method 未優化需使用 578s，優化後只需要 2s，二維陣列查找速度。</p>
<h2 id="更新日誌"><a href="#更新日誌" class="headerlink" title="更新日誌"></a>更新日誌</h2><p>2020-05-18 14:30:21 - 完成 gauss 套件、 高斯消元法<br>2020-05-30 20:34:28 - 完成 seidel_method<br>2020-06-08 15:58:42 - 完成 seidel_method 優化<br>2020-07-15 00:23:42 - 將 Successive Over Relaxation 的 omega 鎖定為 1.1</p>
]]></content>
      <categories>
        <category>C_sharp</category>
      </categories>
      <tags>
        <tag>套件說明</tag>
        <tag>C_sharp</tag>
      </tags>
  </entry>
  <entry>
    <title>ProblemB Binary Tree (水題)</title>
    <url>/2020/06/15/ICPC/2019-2020-ICPC-Asia-Hong-Kong-Regional-Contest-Pb/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>給 ALICE and BOB 一個遊戲，這個遊戲是他們要不斷刪除樹的節點，但有規定，刪除的節點必定是完整二元樹。試問，誰一定必勝？</p>
<p>完整二元樹定義：</p>
<ol>
<li>root 必須要有 left node and right node</li>
<li>是樹的最後節點</li>
</ol>
</blockquote>
<a id="more"></a>

<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><blockquote>
<p>雖然叫水題，但是卻沒辦法解出來，假水題阿 QQ<br>然後香港的題目真的好難，第一題我用 20 min 都無法想出來，於是我觀察別人的 Blog 才能將此題解出。</p>
</blockquote>
<p>此題可以用奇偶數可以直接判斷 Alice and Bob 誰是贏家！很神奇吧</p>
<p>為甚麼呢？<br>因為 ALICE 與 BOB 都只能砍掉「完整二元樹」，而在這裏的完整二元樹節點都會是「奇數」，完整二元樹的樹節點必定是 1 , 3 , 5 , 7 …..。然後透過數學歸納我們可以歸納出兩個奇數 (ALICE and BOB 各畫一次 )相加必等於偶數。</p>
<p>於是當「節點」為奇數時必定是 ALICE 勝，因為接下來換 BOB，但如果 BOB 可以畫就必定是偶數。<br>反之，當「節點」為偶數時必定是 BOB 勝，由前句推出</p>
<p>P.S. <a href="https://www.cnblogs.com/st1vdy/p/12444426.html" target="_blank" rel="noopener">觀看此 Blog 才學習到的</a><br>小小的題外話，我可以在 cin &gt;&gt; n 時即可輸出答案，不一定要等到將這筆測資完整 cin 完全時在輸出。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t ;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">int</span> a , b , n ;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">        <span class="keyword">if</span>(n % <span class="number">2</span>)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Alice\n"</span> ;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Bob\n"</span> ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; n ; i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ICPC</category>
      </categories>
      <tags>
        <tag>水題</tag>
        <tag>2019_2020_ICPC_Asia_Hong_Kong_Regional_Contest</tag>
        <tag>ICPC</tag>
      </tags>
  </entry>
  <entry>
    <title>C# 開超大陣列解決方法</title>
    <url>/2020/06/16/C_sharp/C-sharp-big-array/</url>
    <content><![CDATA[<h2 id="C-在一個陣列裡最多可以有多少元素阿！"><a href="#C-在一個陣列裡最多可以有多少元素阿！" class="headerlink" title="C# 在一個陣列裡最多可以有多少元素阿！"></a>C# 在一個陣列裡最多可以有多少元素阿！</h2><blockquote>
<p>根據 MSDN 預設，陣列的最大大小只能夠有 2GB， 假設此陣列為 int 時，最大元素最多只能有 \( 2^{31} /4 \)</p>
</blockquote>
<a id="more"></a>

<h2 id="那我一定要開到比這更大的陣列呢！"><a href="#那我一定要開到比這更大的陣列呢！" class="headerlink" title="那我一定要開到比這更大的陣列呢！"></a>那我一定要開到比這更大的陣列呢！</h2><p>別擔心，還是會有些解決之道的，如果你在 64 位元的電腦就可以解決了！只需要下方兩步驟即可完成。<br>但還是有些限制，假設 RAM 夠大，將可以使陣列擁有 40 億 elements。如果 RAM 沒辦法負荷 40 億 elements，則只能到負荷最大值。</p>
<ol>
<li><p>將電腦預設 32bits 建置環境改成 64 bits<br> 建置 &gt; 組態管理員 &gt; 平台 &gt; 新增 &gt; 新平台 &gt; x64，剩下按確認就可以了。</p>
<img src="/images/C_sharp_math_2.jpg" alt="C_sharp_math_2.jpg">
</li>
<li><p>在 config 新增 gcAllowVeryLargeObjects 來新增<br> 在 packages.config 新增 gcAllowVeryLargeObjects 即可</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">runtime</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">gcAllowVeryLargeObjects</span> <span class="attr">enabled</span>=<span class="string">"true"</span> /&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;/<span class="name">runtime</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<img src="/images/C_sharp_math_1.png" alt="C_sharp_math_1.png">

</li>
</ol>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>即使，未來科技再進步，還是必須要有好的資料結構與演算法，若豪不在意的不斷增加記憶體與處理器只是對之前那些努力設計電腦的人不敬，也會對自家的電腦造成很大的負擔QQ<br>這是必殺技，請小心慎用，不要上癮。</p>
<h3 id="更新日誌"><a href="#更新日誌" class="headerlink" title="更新日誌"></a>更新日誌</h3><p>2020-06-22 14:45:24 - 錯誤資訊修改</p>
]]></content>
      <categories>
        <category>C_sharp</category>
      </categories>
      <tags>
        <tag>套件說明</tag>
        <tag>C_sharp</tag>
      </tags>
  </entry>
  <entry>
    <title>ProblemD Defining Labels (數論 Math theorm)</title>
    <url>/2020/07/03/ICPC/2019-2020-ICPC-Asia-Hong-Kong-Regional-Contest-Pd/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意:"></a>題目大意:</h2><blockquote>
<p>給你 x 進制 y 值且他是試算表模式，如:A,B,..,Z,AA,AB..，請嘗試將他轉回 10 進制</p>
</blockquote>
<a id="more"></a>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析:"></a>分析:</h2><p>是我太久不會寫演算法，還是我變爛了，這題我花了兩小時才解決問題。QQ </p>
<p>我們先來看十進制的試算表模式與正常十進位模式</p>
<blockquote>
<p>試算表模式: 0 1 2 3 4 5 6 7 8  9 00 01 02 …<br>十進位模式: 1 2 3 4 5 6 7 8 9 10 11 12 13 …</p>
</blockquote>
<p>在試算表 0 時十進位為 1 相差 1，在試算表 00 時十進位為 11 相差 11(這裡只兩個 1 )，這讓我們找出一邏輯，只要試算表的位數在多新增一位時，就會在每位數相差 1。於是我們在多計算一位數時就先 -1，以求正確答案。<br>要記住轉換進位的時候先出來的數值是尾數，因為是透過不斷迭代相除完成的。<br>其餘剩下就是進制轉換了，用遞迴式表達:</p>
<ul>
<li>\(f(x,y)\)<ul>
<li>\(\text{if( x = 0 ) return ;} \)</li>
<li>\(\text{ else { f(x%y,y) , 10 - y + x % y } } \)</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x , <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    x--;</span><br><span class="line">    dfs(x/k , k );</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="number">10</span> - k + x % k ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">int</span> t , x , k ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t ;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; k &gt;&gt; x ;</span><br><span class="line">        dfs(x,k);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ICPC</category>
      </categories>
      <tags>
        <tag>2019_2020_ICPC_Asia_Hong_Kong_Regional_Contest</tag>
        <tag>ICPC</tag>
        <tag>數論 Math theorm</tag>
      </tags>
  </entry>
  <entry>
    <title>ProblemD Tapioka (水題)</title>
    <url>/2020/05/14/ICPC/2019-ICPC-Asia-Taipei-Hsinchu-Regional-Pd/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>給你一行話，請不要輸出 “bubble” 、 “tapioka”<br>格式有特別要求，請注意。</p>
</blockquote>
<a id="more"></a>

<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>這題你要是不會，是不是應該要撞豆腐了?</p>
<p>字串透過陣列求出，然後加上空白即可</p>
<p>額外話: py 不用5行就能把他寫完吧?<br>        py 真的是程式設計師救星，所有簡單的東西都能變簡單，但是語法不習慣</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PB push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP make_pair</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> );</span><br><span class="line">    <span class="comment">//freopen("out.txt" , "w" , stdout );</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="built_in">string</span> strTemp , strAns[<span class="number">5</span>] ;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; strTemp)&#123;</span><br><span class="line">        <span class="keyword">if</span>(strTemp == <span class="string">"bubble"</span> || strTemp == <span class="string">"tapioka"</span>)</span><br><span class="line">            <span class="keyword">continue</span> ;</span><br><span class="line">        strAns[index] = strTemp ;</span><br><span class="line">        index++ ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(index == <span class="number">0</span> )&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"nothing"</span> ;</span><br><span class="line">        <span class="keyword">return</span>  <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; index <span class="number">-1</span> ; i++)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; strAns[i] &lt;&lt; <span class="string">' '</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; strAns[index<span class="number">-1</span>] ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ICPC</category>
      </categories>
      <tags>
        <tag>水題</tag>
        <tag>ICPC</tag>
        <tag>2019_ICPC_Asia_Taipei-Hsinchu_Regional_Contest</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>ProblemG Game Design</title>
    <url>/2020/07/26/ICPC/2019-2020-ICPC-Asia-Hong-Kong-Regional-Contest-Pg/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>請設計塔防遊戲的地圖，這個地圖為一棵樹但可以超過 2 個 leaf。怪物只會從 leaf 往 root 走(即走到樹的根節點就再也不會走動)，我們將他簡單設計化，我們假設每個塔都可以完美殺死怪物，但建造塔則需要花費，請設計一張地圖 (那張地圖需要有節點與節點上的成本)，給你一數值 k，請生成一張地圖總共有 k 種最少成本的建造塔的解法 (任意一種即可)。</p>
</blockquote>
<a id="more"></a>

<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><blockquote>
<p>這題的想法非常有趣，我原本快要想對，但最後還是想錯方向了…<br>P.S. 如果我的分析不好，可以看此 <a href="https://www.cnblogs.com/st1vdy/p/12444426.html#1865251979" target="_blank" rel="noopener">st1vdy的 BLOG</a>，我是從他那邊得到靈感的。<br>下方說明文的 root，為整棵樹的 root。<br>x 為任意變數<br>left node 為 x 的右邊節點<br>right node 為 x 的左邊節點</p>
</blockquote>
<p>由於我們要設計一張地圖(樹)，為了方便我們簡單設計地圖，我們就定義為他是一顆二元樹。那我們接下來就是要來找一個規律來設計 k！</p>
<h3 id="初步思考"><a href="#初步思考" class="headerlink" title="初步思考"></a>初步思考</h3><p>我們先來思考哪種方式設計是最棒的，由於我們簡單設計成二元樹，於是我們先設定一算法，只有 root 為 x，其餘 node 值都為 1，且 \(x \geq  2 \)，這樣子最好算法就會有 \(k = a \cdot b \)。</p>
<p>那如果是質數呢？質數沒辦法符合那方程式阿，那只要把 \( x = 2 \)，就會再多一種算法，即\(k + 1\)，因為最小成本都是 2，如果從 root 放塔，那最小成本也還會是 2(\(因為 x = 2\))，因而多一種算法。</p>
<p><img src="/images/2019-2020-ICPC-Asia-Hong-Kong-Regional-Contest-Pg/1.jpg" alt=""></p>
<h3 id="找出問題"><a href="#找出問題" class="headerlink" title="找出問題"></a>找出問題</h3><p>我們的初步思考有一個很致命的缺點，因為他是給予我們 k，但如果要從 k 還原 a , b，如果遇到質數還需要 +1，程式碼太複雜不好維護。於是我們想出新的方法，既然可以 \(a \cdot b \)，那一定也有道理 \( a \cdot a \cdot b \)，可以推導成 \(a^{c} * b \)，但由於我們將算法簡化成程式碼好解決，就是將 \(a = 2\)，由於二元樹的特性，可以省下很多程式碼的功夫。</p>
<h3 id="新的想法"><a href="#新的想法" class="headerlink" title="新的想法"></a>新的想法</h3><p>所以我們把它從原本只有樹的 root 分兩邊然後 \(a * b \)，那我們就把每一個只要是「有連接到 leaf 的 node 的右子樹」(引號內在之後簡稱為 LN )都加入兩顆為 1 的 node，就可以達到 \( \cdot a \)的功用，剩下我們就是考慮到底要有幾個 LN，就可以湊出 k 種解法，然後如果說數字為一質數時，我們就把那 LN 的成本變成 \(LN = \text{left node} + \text{right node} \)，那如果不是質數就是 \(LN \geq \text{left node} + \text{right node} \)。</p>
<p>然後則必須思考，當 \(k = 1 \) 時我們實際上不需要 \(*2\)，於是我們只需要將那兩個 node 其中 1 節點改為 1，另一點則 \( &gt; 1 \)。但當 \( k = 2 \)時，則兩節點必要為 1。</p>
<p>下方圖片為當 k = x 時所產生的地圖與有多少解方法及選擇的點<br><img src="/images/2019-2020-ICPC-Asia-Hong-Kong-Regional-Contest-Pg/2.jpg" alt=""></p>
<h3 id="設計想法"><a href="#設計想法" class="headerlink" title="設計想法"></a>設計想法</h3><p>因為這題是不斷的進行除以 2，來生成地圖，但我們並不確定他需要幾次才能將 \( k / 2 &lt; 1\)，所以用遞迴解決，當用遞迴解決時，這遞迴需要的條件如下:</p>
<p>也就是遞迴可以解決，方程式想法如下:</p>
<ul>
<li>\(f(K) = if k &gt; 2 , 呼叫 f(k/2) + f(2) \)</li>
<li>\(if(k \leq 2) , 在右子樹加入 2 個 node\)</li>
<li>\(LN = \text{left node} + \text{right node} \)</li>
<li>\(if (k \% 2 == 0), LN +1 \)</li>
</ul>
<p>下方則是說明，對應每個方程式的說明</p>
<ul>
<li>當 \(k &gt; 2 \) 時，我們需要做 \( /2\) 這動作，但因為我們是在尋找 \( /2\) 的最好長度，於是需要再後面加入 \(f(2)\)，才能滿足 k 的要求</li>
<li>由於 k 的值小於等於 2，我們要加入 2 個 node 以滿足 \( * 2\)的動作</li>
<li>LN 會等於左節點 + 右節點，這為 K = 質數時的情況</li>
<li>如果 k 是偶數，那我們將 LN + 1，才不會多出一種解</li>
</ul>
<h3 id="觀念小釐清"><a href="#觀念小釐清" class="headerlink" title="觀念小釐清"></a>觀念小釐清</h3><p>在新的想法中，圖片最後在最後的 LN 時，左子樹也是右子樹的一種，減少程式碼撰寫麻煩。</p>
<p>Q: 為甚麼在下方的程式碼 function dfs 中是 <code>return temp</code> 而不是 <code>return value[root]</code>?<br>A: 很簡單的一個邏輯， 5 / 2 = 2 ，但 (2+1) * (2) = 6 ，回推不符合。應該還是要 2 * 2 + 1 = 5。</p>
<p>Q: 這篇講得很爛，文章主人是不是國文不好?<br>A: 這種想法的東西真的很難用文字表述，我的表達能力不好抱歉…<br>P.S. 但你可以稍微嘗試將這些用文字表達，真的不太好表達。這需要你去嘗試才知道困難處。</p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>要感謝 Bill and Entroy 先思考這題，等他們想通後，我才根據他們說給予我的指導和想法，幫助我寫出此題，不然要是自己寫應該要花比有他人指導更多的時間吧！希望我跟他們能夠一輩子都是好朋友。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 100010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> pa[SIZE] , value[SIZE] , cnt=<span class="number">0</span> ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> root )</span></span>&#123;</span><br><span class="line">    cnt++ ;</span><br><span class="line">    <span class="keyword">int</span> temp ;</span><br><span class="line">    pa[cnt] = root++ ;</span><br><span class="line">    <span class="keyword">if</span>(k &lt;= <span class="number">2</span>)&#123;</span><br><span class="line">        value[cnt] = <span class="number">3</span> - k ;</span><br><span class="line">        pa[cnt+<span class="number">1</span>] = cnt ;</span><br><span class="line">        value[++cnt] = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    temp = dfs(k/<span class="number">2</span>,root) + dfs(<span class="number">2</span>,root)  ;</span><br><span class="line">    value[root] = temp + (k % <span class="number">2</span> == <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> temp ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; k ;</span><br><span class="line">    dfs(k , <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; cnt &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= cnt ; i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; pa[i] &lt;&lt; <span class="string">' '</span> ;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= cnt ; i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; value[i] &lt;&lt; <span class="string">' '</span> ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ICPC</category>
      </categories>
      <tags>
        <tag>ICPC_2019-2020_North-Western_Russia_Regional_Contest</tag>
        <tag>ICPC</tag>
        <tag>設計解題</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>ProblemC Are They All Integers? (水題)</title>
    <url>/2020/05/14/ICPC/2019-ICPC-Asia-Taipei-Hsinchu-Regional-Pc/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>給你一微陣列數字(a[])，試問此陣列中是否都符合此公式 (a[i]+a[j]) / a[k] % 1 == 0 </p>
<p>如果不是，輸出 “no”。是請輸出 “yes” 。</p>
</blockquote>
<a id="more"></a>

<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>沒啥好說的，純操作題。</p>
<p>這題全部參加這次比賽的都有解出來呢，所以你不可以沒解出來喔。</p>
<p>小心這題犯的錯誤</p>
<ol>
<li>陣列要用 double ，不然怎樣 mod 1 都會 == 0 喔~</li>
<li>可以類似用 bubble sort的方式加速，要記得加 abs ，想必大家都知道啦。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PB push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FB <span class="meta-keyword">if</span>(!flag) break</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> );</span><br><span class="line">    <span class="comment">//freopen("out.txt" , "w" , stdout );</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">int</span> num[<span class="number">60</span>] ;</span><br><span class="line">    <span class="keyword">int</span> n ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; num[i] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">1</span> , intMod ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i +<span class="number">1</span>  ; j &lt; n ; j++ )&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span> ; k &lt; n ; k++)&#123;</span><br><span class="line">                <span class="keyword">if</span>( i == k || j == k)</span><br><span class="line">                    <span class="keyword">continue</span> ;</span><br><span class="line">                intMod = <span class="built_in">abs</span>(num[i] - num[j]) % num[k] ;</span><br><span class="line">                <span class="keyword">if</span> (intMod != <span class="number">0</span> )&#123;</span><br><span class="line">                    flag = <span class="number">0</span> ;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//debug</span></span><br><span class="line">                    <span class="comment">//cout &lt;&lt; intMod &lt;&lt; ' ' &lt;&lt; num[i] &lt;&lt; ' ' &lt;&lt; num[j] &lt;&lt; ' ' &lt;&lt; num[k] &lt;&lt; '\n' ;</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            FB;</span><br><span class="line">        &#125;</span><br><span class="line">        FB;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"yes"</span> ;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"no"</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ICPC</category>
      </categories>
      <tags>
        <tag>水題</tag>
        <tag>ICPC</tag>
        <tag>2019_ICPC_Asia_Taipei-Hsinchu_Regional_Contest</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>ProblemE The League of Sequence Designers(數論 Math theorm)</title>
    <url>/2020/07/18/ICPC/2019-ICPC-Asia-Taipei-Hsinchu-Regional-Pe/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>有一公式\( \max(r - l + 1 ) \cdot  \sum_{l \leq i \leq n } a_{i} , 其中 1 \leq l \leq r \leq n \)<br>題目給予一貪心演算法，但此演算法並不正確。演算法如下:<br><img src="/images/2019-ICPC-Asia-Taipei-Hsinchu-Regional-Pe/1.png" alt=""></p>
<p>給你 k , l ， k 為貪心演算法與正確解答的差距， l 為最少要生成數列的長度，請您給出一組數列能夠在正確的演算法成功輸出正確答案，也能讓貪心演算法與正確演算法的差距等於 k，如果不行請輸出 -1</p>
</blockquote>
<a id="more"></a>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p><strong><font color="#dd0000">這種解題方式我還是第一次看到阿，只能說自己見識太淺還需要磨練</font></strong></p>
<p>這題我是直接去看別人 BLOG 分析的 CODE 才 AC 的，但是他沒有解析，我在這邊附註解析好讓未來的自己複習，會在後面附上連結。</p>
<p>這題分成幾個步驟:</p>
<p>由於題目有限制數列長度必小於 2000，於是我們直接把每一個生成的陣列都直接定義成 1999，就可以直接輕鬆跳過 l 的問題。</p>
<h3 id="長度必小於-2000"><a href="#長度必小於-2000" class="headerlink" title="長度必小於 2000"></a>長度必小於 2000</h3><p>根據貪心演算法的程式碼，當 \(curMAX &lt; 0 \) 時，我們就直接捨棄掉，只用後面的 \( left \)，於是我們可以用一個簡單方法直接找出貪心演算法的最大問題核心。</p>
<h3 id="舉例說明"><a href="#舉例說明" class="headerlink" title="舉例說明"></a>舉例說明</h3><p>EX: 舉例數列為 -1 1 1 3</p>
<table>
<thead>
<tr>
<th>演算法</th>
<th>數列總和</th>
<th>長度</th>
<th>總和*長度=答案</th>
</tr>
</thead>
<tbody><tr>
<td>貪心演算法</td>
<td>5</td>
<td>3</td>
<td>\( 5 \cdot 3 = 15\)</td>
</tr>
<tr>
<td>正確演算法</td>
<td>4</td>
<td>4</td>
<td>\( 4 \cdot 4 = 16 \)</td>
</tr>
</tbody></table>
<p>看出來了嗎?<br>問題在於如果一開始為 -1 時貪心演算法永遠都會捨棄那長度，於是我們只要設計出一個數列是可以破解他的貪心演算法就完成了。</p>
<h3 id="怎麼破解"><a href="#怎麼破解" class="headerlink" title="怎麼破解?"></a>怎麼破解?</h3><p>其實我們也不用那麼麻煩一定要讓自己想出一個絕對正確的演算法，我們只要將貪心演算法稍加改良在讓我們產生的數列可以產生出一個差額為 k 值，是不是非常聰明！教導我的 BLOG 就是這樣做的，真的優秀</p>
<h3 id="設計演算法"><a href="#設計演算法" class="headerlink" title="設計演算法"></a>設計演算法</h3><p>根據舉例，我們可以得出一結論</p>
<ol>
<li>貪心演算法的長度永遠會比正確演算法少 1</li>
<li>正確演算法的長度永遠會比貪心演算法多 1</li>
</ol>
<p>根據數學乘法公式，可找出適合的 k 值，這裡我們用舉例的方式來說明比較清楚:</p>
<h4 id="EX-1-前項為數列總和-定義為-A-後項為長度總和-定義為-B"><a href="#EX-1-前項為數列總和-定義為-A-後項為長度總和-定義為-B" class="headerlink" title="EX:1 前項為數列總和(定義為 A)  後項為長度總和(定義為 B)"></a>EX:1 前項為數列總和(定義為 A)  後項為長度總和(定義為 B)</h4><p>數列: -1 1 1 3<br>\(5 \cdot 3 = 15 \)<br>\(4 \cdot 4 = 16 \)<br>\(16 - 15 = 1 , k = 1 \)</p>
<h4 id="EX-2-前項為數列總和-定義為-A-後項為長度總和-定義為-B"><a href="#EX-2-前項為數列總和-定義為-A-後項為長度總和-定義為-B" class="headerlink" title="EX:2 前項為數列總和(定義為 A)  後項為長度總和(定義為 B)"></a>EX:2 前項為數列總和(定義為 A)  後項為長度總和(定義為 B)</h4><p>數列: -1 1 1 4<br>\(6 \cdot 3 = 18 \)<br>\(5 \cdot 4 = 20 \)<br>\(20 - 18 = 2 , k = 2 \)</p>
<h4 id="證明"><a href="#證明" class="headerlink" title="證明"></a>證明</h4><p>當 \(C \cdot D = E \) 時，如果  C 項 -1，則 E - D (定義為 F)</p>
<p>\(7 \cdot 2 = 14\)<br>\(6 \cdot 3 = 18\)<br>\(18 - 14 = 4 , k = 4 \)<br>經過轉變後<br>\(7 \cdot 3 = 21 \)<br>\(6 \cdot 3 = 18 \)<br>在將 \(7 \cdot 3 = 21 \) 的 <strong>3</strong> -1 ，於是 \(21 - 18 -7 = -4\)得此證明 k。</p>
<h4 id="證明好了，那我應該怎麼做"><a href="#證明好了，那我應該怎麼做" class="headerlink" title="證明好了，那我應該怎麼做?"></a>證明好了，那我應該怎麼做?</h4><p>由於數列中的數字的大小必小於 2000，理所當然的 k 最大只能到 1999，所以我們可以用透過放大中間的數列來讓 k 值加大</p>
<h4 id="EX-3"><a href="#EX-3" class="headerlink" title="EX:3"></a>EX:3</h4><p>數列: -1 2 2 3<br>\(7 \cdot 3 = 21 \)<br>\(6 \cdot 4 = 24 \)<br>\(24 - 21 = 3 , k = 3 \)<br>由於中間的數值從 1 被我放大到 2，所以 k 的值也隨之 +2，原因是因為中間的數列長度為 2 且原本的 1 都被我在 +1 ，於是 \(1 * 2 = 2\) </p>
<h3 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h3><p>當雙方 A 都增加 1，且雙方 B 一樣都不變時， k 的值會 +1，並且當 k 必須大於 2000 時我們必須放大中間數列，OK 我們找到公式了！</p>
<h3 id="找到公式了，但在等等題目很壞心眼"><a href="#找到公式了，但在等等題目很壞心眼" class="headerlink" title="找到公式了，但在等等題目很壞心眼"></a>找到公式了，但在等等題目很壞心眼</h3><p>由於題目很惡意，他 l 的範圍並不是在 \(0 \leq l &lt; 2000\)，是在 \(0 \leq &lt; 10^{9}\)，於是你必須多加行 if 判斷如果 \(l \geq 2000\) 就 cout -1 ，OK開始寫 code 吧</p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>這題對於不擅長數論的我來說非常痛苦阿，前面的證明我也並不覺得我證明得很好，如果我的文字敘述上有錯誤，拜託跟我講QQQQQQ，或是有更好的表達方式請告訴我，我會改進。<br>這題我光看懂大神的程式碼就花了 3hr，自己的領悟力還是不夠強還需要努力，也是第一次遇到這種需要設計題目的，學起來了！</p>
<p>附上<a href="https://www.cnblogs.com/st1vdy/p/12701920.html" target="_blank" rel="noopener">我從大神學來知識的 BLOG</a><br>打了篇文章也花了我 2hr 整，自己的表達能力需要加強，寫 BLOG 也不是一件簡單的事情啊…</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 2020</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="keyword">int</span> arr[MAXN] = &#123;&#125; ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">int</span> t , k , l ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t ;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; k &gt;&gt; l ;</span><br><span class="line">        arr[<span class="number">1</span>] = <span class="number">-1</span> ;</span><br><span class="line">        <span class="keyword">if</span>(l &gt;= <span class="number">2000</span>)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">            <span class="keyword">continue</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fill(arr+<span class="number">2</span> , arr+<span class="number">2000</span> , (<span class="number">1999</span> + k) / <span class="number">1998</span>) ;</span><br><span class="line">        arr[<span class="number">1999</span>] += (<span class="number">1999</span> + k ) % <span class="number">1998</span> ;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="number">1999</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= <span class="number">1999</span> ; i++)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">' '</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ICPC</category>
      </categories>
      <tags>
        <tag>ICPC</tag>
        <tag>2019_ICPC_Asia_Taipei-Hsinchu_Regional_Contest</tag>
        <tag>設計解題</tag>
        <tag>程式解題</tag>
        <tag>數論 Math theorm</tag>
      </tags>
  </entry>
  <entry>
    <title>ProblemB Bad Treap (數論 Math theorm)</title>
    <url>/2020/06/16/ICPC/ICPC-2019-2020-North-Western-Russia-Regional-Contest-Pb/</url>
    <content><![CDATA[<head>
  <script type="text/javascript"
    src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
<meta name="generator" content="Hexo 4.2.1"></head>

<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>給你一個數 n ，然後生成一顆樹，比 root 小的 node 在左邊，比 root 大的 node 在右邊，規則是 \(y = sin(x)\)</p>
<p>要求是可以生成出一個最高高度的樹，但只能用 n 個點。</p>
</blockquote>
<a id="more"></a>

<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><blockquote>
<p>這題跟鬼一樣難，是假程式題，真數學題阿！<br>我對於這題還是沒有辦法很了解，如果看不懂我的可以建議多看別人的 Blog。</p>
<p>P.S.  我也是看<a href="https://acm.uestc.edu.cn/blog/41/" target="_blank" rel="noopener">他的 Blog </a></p>
</blockquote>
<p>我們的目的就是 n = 最高長度，然後我們在簡化一點題目就是單調隊列最大化。即 root 都是 left or right 有 node。</p>
<p>由於 sin 的週期是 \( 2 \pi \)，但是 \(sin(0) = sin(\pi) \) 會造成一個現象就是有兩個 \(y = sin(x) \)，所以我們必須再將範圍縮小至 \( \dfrac{-2}{\pi} \sim \dfrac{2}{\pi}  \)。<br>但因為 sin 的週期很難控制，也抓不太到規律。<br>於是我們現在有了一個新的任務，找出最小點，透過倍數來完成這題。<br>但是 sin 的倍數不會調整嗎? 會，但是我們只要找出最小點，這個最小點再乘以 50000 倍也不超過 \( \dfrac{-2}{\pi} \sim \dfrac{2}{\pi} \)，這樣就可以了！<br>接下來要怎麼找呢? 這裡就很神奇瞜!</p>
<p>由於太神奇了，我特別拉出來講，我們要找出一個極小值，我們就先假設 0.0035 ，當 sin (0.0035 角度) = 0.00006，夠我們使用了。怎麼說呢? 因為我們 \( \pi = 3.14 \)，然後我們需要 50000 個數值，所以 \( \dfrac{-2}{\pi} = -25000 * 0.00006 \) and \( \dfrac{2}{\pi} = 0.00006 * 25000 \) 且因 \(25000 + 25000 = 50000 \)，就能搞定題目的 50000 個數值了！最後我們剩下一個任務就能把解題的必要元素都解出來。<br>P.S. 不一定要用 0.0035 ，只要能夠找出一個可以在 \( \dfrac{-2}{\pi} \sim \dfrac{2}{\pi}  \) 能放入 50000個等比級數即可，我有考慮使用過 sin(0.002 角度) = 0.00003，但我解不出下方公式 A , B</p>
<p>公式如下:<br>\(  sin(A * 360 + 0.0035)度數 = sin(B) 弧度\) and \( A , B \in Z \)<br>Z 則是我們需要的答案。</p>
<p>由於題目說過 B 必須為整數，A 則是由於 sin 週期而必須是整數。<br>這時候呢，這條公式我則是透過看解答解開的， A = 113 , B = 710，我想不出有甚麼公式或是可以寫一個簡單的程式可以順利找出來。如果知道還請聯絡我，拜託了QQ<br>P.S. 我覺得只能透過暴力解，才能解出。</p>
<p>接下來就是看他有幾個數列就直接乘以 B 即可，但還需要減去 25000 * B，因為我們是從 \( \dfrac{-2}{\pi} \) 開始。</p>
<h4 id="作者心得"><a href="#作者心得" class="headerlink" title="作者心得"></a>作者心得</h4><p>這題也太難了吧，俄羅斯人都跟鬼一樣強阿，此題考的不是寫出來的程式，而是你需要非常清晰的邏輯與能夠解出公式的 A 與 B，若是你能解出來，你的實力肯定在我之上，我佩服你！<br>(然後解出來，就告訴我你的想法吧！)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">    <span class="keyword">for</span>(ll i = <span class="number">0</span> ; i &lt; n ; i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i * <span class="number">710</span> - <span class="number">25000</span> * <span class="number">710</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ICPC</category>
      </categories>
      <tags>
        <tag>ICPC_2019-2020_North-Western_Russia_Regional_Contest</tag>
        <tag>ICPC</tag>
        <tag>設計解題</tag>
        <tag>程式解題</tag>
        <tag>數論 Math theorm</tag>
      </tags>
  </entry>
  <entry>
    <title>ProblemA Accurate Movement (數論 Math theorm)</title>
    <url>/2020/05/18/ICPC/ICPC-2019-2020-North-Western-Russia-Regional-Contest-Pa/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>有兩個 Box ，這兩個 Box 不可以互相拋棄對方，必須要相互連在一起</p>
<p>他們要走到 n 距離，試問走幾步才能走到?</p>
</blockquote>
<a id="more"></a>

<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>數學一直都不是我擅長的阿，好難過 ಥ_ಥ</p>
<p>還是我今年 ICPC 的好夥伴幫我想出的，然後我再理解，邏輯不好rrrrrr<br>Bill and Entroy 都是 math master </p>
<p>公式: ceiling( (n-b) / (b-a) ) * 2 + 1 ;</p>
<p>n-b 為大箱子到 n   的距離<br>b-a 為小箱子到大箱子的距離<br>+1  最後小箱子移動到終點的距離</p>
<p>我還有 n-b 的距離要移動 每次最多只能移動 (b-a) 每次移動的權重為 2 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span>) ;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">int</span> a , b , n ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; n ;</span><br><span class="line">    <span class="keyword">int</span> ans , temp ;</span><br><span class="line">    temp = (n-b) / (b-a) ;</span><br><span class="line">    <span class="keyword">if</span>( (n-b) % (b-a) != <span class="number">0</span> )</span><br><span class="line">        temp += <span class="number">1</span> ;</span><br><span class="line">    ans = temp * <span class="number">2</span> + <span class="number">1</span> ;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>ICPC</category>
      </categories>
      <tags>
        <tag>ICPC_2019-2020_North-Western_Russia_Regional_Contest</tag>
        <tag>ICPC</tag>
        <tag>程式解題</tag>
        <tag>數論 Math theorm</tag>
      </tags>
  </entry>
  <entry>
    <title>ProblemE Equidistant (DFS)</title>
    <url>/2020/05/20/ICPC/ICPC-2019-2020-North-Western-Russia-Regional-Contest-Pe/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>有一張地圖，有幾個需要參加 ICPC 的城市，我們需要設計一個程式，尋找一個城市可以讓每個要參加 ICPC 的城市都是花相同的距離到達?</p>
</blockquote>
<a id="more"></a>

<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>此題有很多種做法，但唯有時間複雜度最低才能 AC (我怎麼覺得我好像在說廢話 XD)</p>
<p>先透過 DFS 把參加 ICPC 中的城市兩個最遠距離給求出來。<br>再將兩個城市中的最長距離 /2 ，再找出那個路經的城市(<strong>定義為 A</strong>)。</p>
<p>再透過 DFS 從 A 開始到每一個需要參加 ICPC 的城市，如果他們的距離不等於我們在上個 DFS 找出的最長距離 /2，就輸出 “NO” ，如果都可以那就輸出 “YES”</p>
<p>P.S. 我好久沒有寫 DFS 了，居然都快忘記了。這邊就要感謝 BILL。<br>喚醒我那在史前時代的記憶用 vector 去做 DFS，真的優秀。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> m , n , flag=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> Maxn_city = <span class="number">0</span> , Maxn_path = <span class="number">0</span> ;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;tree[<span class="number">200020</span>] ;</span><br><span class="line"><span class="keyword">int</span> city[<span class="number">200020</span>] = &#123;&#125; ;</span><br><span class="line"><span class="keyword">int</span> visit[<span class="number">200020</span>] = &#123;&#125; ;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; travel ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS_to_large_path</span><span class="params">(<span class="keyword">int</span> root )</span></span>&#123;</span><br><span class="line">    visit[root] = <span class="number">1</span> ;</span><br><span class="line">    travel.push_back(root);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; tree[root].size() ; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> node = tree[root][i] ;</span><br><span class="line">        <span class="keyword">if</span>(!visit[node])&#123;</span><br><span class="line">            BFS_to_large_path(node);</span><br><span class="line">            travel.pop_back();</span><br><span class="line">            visit[root] = <span class="number">0</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//debug to check large path</span></span><br><span class="line">    <span class="comment">//if (root == 1)</span></span><br><span class="line">    <span class="comment">//    cout &lt;&lt; "1=" &lt;&lt; travel.size() &lt;&lt; ' ' &lt;&lt; Maxn_path &lt;&lt; ' ' &lt;&lt; city[root] &lt;&lt; '\n' ;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(city[root] &amp;&amp; travel.size() &gt; Maxn_path)&#123;</span><br><span class="line">        Maxn_city = travel[travel.size()/<span class="number">2</span>];</span><br><span class="line">        Maxn_path = travel.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS_to_other_path</span><span class="params">(<span class="keyword">int</span> root ,<span class="keyword">int</span> path)</span></span>&#123;</span><br><span class="line">    visit[root] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; tree[root].size() ; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> node = tree[root][i] ;</span><br><span class="line">        <span class="keyword">if</span>(!visit[node])&#123;</span><br><span class="line">            BFS_to_other_path(node , path+<span class="number">1</span>);</span><br><span class="line">            visit[root] = <span class="number">0</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//debug</span></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="number">1</span> )</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"city="</span> &lt;&lt; root &lt;&lt; <span class="string">" path= "</span> &lt;&lt; path &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(city[root] &amp;&amp; path != Maxn_path)</span><br><span class="line">        flag = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ;</span><br><span class="line">    <span class="keyword">int</span> a , b ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n<span class="number">-1</span> ; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b ;</span><br><span class="line">        tree[a].push_back(b) ;</span><br><span class="line">        tree[b].push_back(a) ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; m ; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a ;</span><br><span class="line">        city[a] = <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    BFS_to_large_path(a);</span><br><span class="line">    <span class="comment">//visit[a] = 0 ;</span></span><br><span class="line">    BFS_to_other_path(Maxn_city , <span class="number">1</span> );</span><br><span class="line">    <span class="keyword">if</span>(flag)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"YES\n"</span> &lt;&lt; Maxn_city ;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"NO"</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//debug</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Maxn_path= "</span> &lt;&lt; Maxn_path &lt;&lt; <span class="string">" Maxn_city= "</span> &lt;&lt; Maxn_city &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ICPC</category>
      </categories>
      <tags>
        <tag>ICPC_2019-2020_North-Western_Russia_Regional_Contest</tag>
        <tag>DFS</tag>
        <tag>圖論</tag>
        <tag>ICPC</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>ProblemH High Load Database (Complex Optimization)</title>
    <url>/2020/05/26/ICPC/ICPC-2019-2020-North-Western-Russia-Regional-Contest-Ph/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>給你兩組陣列 (定義為 A , B)，詢問 B 的每一個數字，能將 A 分割最大。<br>補述說明：　可將 A 想像成包裹 B 想像為箱子<br>要將 A 塞到 B 裡面並最佳化利用但必須按照順序，試問需要幾個箱子。</p>
</blockquote>
<a id="more"></a>

<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><blockquote>
<p>這題看起來很簡單對不對！<br><strong>但其實它是非常可怕的效率優化</strong><br>要是打得像文章一樣，沒人會理解吧！</p>
</blockquote>
<ol>
<li><p>使用前綴和 + 二分收尋<br> 在上一份包裹沒被收納前，下一份包裹就無法加入箱子。並且透過二分收尋的方式，就可以很方便的加入並且省掉撰寫更多程式碼的時間。</p>
<p> 舉例:<br> EX: 2 2 4 3 3 包裹 =&gt; 2 4 8 11 14 設定箱子為 4<br> 因此一開始收尋 4 是在 4 8 之間 (這裡使用 C++ upper_bound 直接抓 &gt; x 的值 index)，因為 4+4 = 8 ，因此我下次就收尋 8，8 在 8 13 之間，所以 8+4 = 12，以此類推。每做二分收尋一次就是多切一段，很聰明的想法吧！只是單單這樣還是不夠的，俄羅斯沒那麼友善QQ。</p>
</li>
<li><p>找出包裹之間的最大值並與箱子比較<br> 這想法其實一開始我的隊友跟我說時，我還無法想通邏輯。但多思考個幾分鐘就能懂了，我的邏輯敏感力還是不太好啊…。</p>
<p> 假設題型：<br> 如果 箱子是 5 ，包裹為 3 6 7 8 9，那箱子 5 是不是必定沒辦法包住 6 7 8 9? 因此我找出這些包裹的最大差額，要是箱子不能裝到裡面最大的包裹，就直接判斷 Impossible，省去 step1 的查找時間。<del>反正有找跟沒找還不是一樣</del></p>
</li>
</ol>
<ol start="3">
<li>他的查找資料是會重複的<br><font color="#dd0000"> <strong>最機車的地方</strong> </font><br>應該是我英文底子不太好，可能看不太懂他有說資料會重複查詢抑或是他沒有說。這邊我是去查看這邊我是去查看<a href="https://blog.csdn.net/m0_37809890/article/details/102946147?utm_medium=distribute.pc_relevant.none-task-blog-baidujs-1" target="_blank" rel="noopener">Little_Fall 天才</a>，不然我應該永遠都想不出來吧…。<br>好了，前面廢話那麼多，該講重點了。再新增一個陣列來記錄如果使用 t 箱子可以裝幾個包裹就可以完成了！</li>
</ol>
<p>這份解題記錄我打了一小時…好累阿。還有兩題要打，加油!</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">200020</span>] = &#123;&#125; ;</span><br><span class="line"><span class="keyword">int</span> save[<span class="number">1000200</span>] = &#123;&#125; ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n , sum =<span class="number">0</span> , Mv = <span class="number">0</span> ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i++)&#123; <span class="comment">//cin array</span></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; arr[i] ;</span><br><span class="line">        sum += arr[i] ;</span><br><span class="line">        arr[i] = sum ;</span><br><span class="line">        Mv = max(Mv, arr[i] - arr[i<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(save , <span class="number">-1</span> , <span class="keyword">sizeof</span>(save));</span><br><span class="line">    <span class="keyword">int</span> seaT , t , seaN , index ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; seaN ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; seaN ; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; t ;</span><br><span class="line">        seaT = t ;</span><br><span class="line">        sum = <span class="number">0</span> ;</span><br><span class="line">        index = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>; <span class="comment">//flag = 1 non-impossible flag2 = impossible</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(save[t] != <span class="number">-1</span>)</span><br><span class="line">            flag = <span class="number">1</span> ;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(Mv &gt; t)</span><br><span class="line">            flag = <span class="number">2</span> ;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(flag==<span class="number">0</span>)&#123;</span><br><span class="line">            index = upper_bound(arr+index , arr+n , seaT )-arr;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//debug</span></span><br><span class="line">            <span class="comment">//cout &lt;&lt; "seaT=" &lt;&lt; " " &lt;&lt; seaT &lt;&lt; " value=" &lt;&lt; arr[index-1] &lt;&lt; '\n' ;</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(index == n)&#123; </span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">                save[t] = ++sum ;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            seaT = arr[index<span class="number">-1</span>] + t ;</span><br><span class="line">            sum++ ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="number">2</span> || save[t] == <span class="number">0</span> )</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Impossible"</span> ;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; save[t] ;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ICPC</category>
      </categories>
      <tags>
        <tag>ICPC_2019-2020_North-Western_Russia_Regional_Contest</tag>
        <tag>效率優化</tag>
        <tag>ICPC</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>ProblemI Ideal Pyramid (Complex Optimization)</title>
    <url>/2020/05/26/ICPC/ICPC-2019-2020-North-Western-Russia-Regional-Contest-Pi/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>我需要一個蓋一個金字塔，中間要有許多柱子。請寫出一個程式告訴此金字塔的中心點與高。</p>
</blockquote>
<a id="more"></a>

<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><blockquote>
<p>非常的數論阿…</p>
</blockquote>
<p>先假設他給的每個點都需要蓋一個金字塔(因為必須要大於等於金字塔)，這很數學，我太笨，不好解釋。我只能跟你說金字塔是 45 度，所以從中點切面來說會是正三角形，接著 /2，就是等腰三角形，就可以找到解答了！</p>
<p>於是策略如下:</p>
<ol>
<li>找最大最小的 xy ，然後求對角線。</li>
<li>高則透過 (max(MaxX - MinX , MaxY - MinY)+1) /2算一半的對角線就能求出。</li>
</ol>
<h3 id="疑問"><a href="#疑問" class="headerlink" title="疑問"></a>疑問</h3><p><font color="#dd0000"><strong>這題有個很奇怪的點，就是因為如果是用 int 是會有 .5 的問題，於是我很貼心的加入四捨五入，但在 submit 時就吃 WA，氣死我了。</strong></font></p>
<p><del>以後不要想那麼多，我們寫演算法的。盡量把他想得簡單化，不要太貼心</del><br>題目有說只有 int，希望他可以說多一點…</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Maxn -100000020</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Minn 100000020</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> ) ;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    ll n ;</span><br><span class="line">    ll MaxX , MinX , MaxY , MinY ;</span><br><span class="line">    MaxX = Maxn ;</span><br><span class="line">    MinX = Minn ;</span><br><span class="line">    MaxY = Maxn ;</span><br><span class="line">    MinY = Minn ;</span><br><span class="line">    ll a , b , c ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c ;</span><br><span class="line">        MaxX = max(a + c , MaxX);</span><br><span class="line">        MinX = min(a - c , MinX);</span><br><span class="line">        MaxY = max(b + c , MaxY);</span><br><span class="line">        MinY = min(b - c , MinY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> x , y , h , dx , dy ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//debug</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; MaxX &lt;&lt; " " &lt;&lt; MinX &lt;&lt; " " &lt;&lt; MaxY &lt;&lt; " " &lt;&lt; MinY &lt;&lt; '\n' ;</span></span><br><span class="line">    x = (MaxX + MinX+<span class="number">1</span>) /<span class="number">2</span> ;</span><br><span class="line">    y = (MaxY + MinY+<span class="number">1</span>) /<span class="number">2</span> ;</span><br><span class="line">    h = (max(MaxX - MinX , MaxY - MinY)+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">' '</span> &lt;&lt; y &lt;&lt; <span class="string">' '</span> &lt;&lt; h ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ICPC</category>
      </categories>
      <tags>
        <tag>ICPC_2019-2020_North-Western_Russia_Regional_Contest</tag>
        <tag>效率優化</tag>
        <tag>ICPC</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>ProblemJ Just the Last Digit (Floyd)</title>
    <url>/2020/05/25/ICPC/ICPC-2019-2020-North-Western-Russia-Regional-Contest-Pj/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>有一張有向圖，有一人遍地此路徑，於是她得出每個點有幾種不一樣的路徑，並繪製地圖<br>你的任務就是將此圖還原成原始地圖，如 a -&gt; b , c -&gt; b </p>
</blockquote>
<a id="more"></a>

<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><blockquote>
<p>對我而言這有點類似於 Floyd 演算法，但我沒有十足把握。有描繪出其大概想法，但卻沒辦法將演算法建立完成，需查看 <a href="https://www.cnblogs.com/Dup4/p/11968817.html" target="_blank" rel="noopener">Dup4’Blog 大神</a>才有辦法解出。</p>
</blockquote>
<p>由於題目有說明 i &gt; j &gt; k 所以不會有 5 &gt; 3 &gt; 2 問題加上路徑數量不會超過 10 (last digit 代表只會有 1 位數)，使問題簡單很多壓力將低，<del>比起這年份的俄羅斯考卷只喜歡一值考時間優化好多了…</del>。</p>
<p>我將我的程式想法說明，希望大家與未來的我可以看懂，嗚嗚嗚</p>
<p>array before = 題目給的<br>array after  = 還原陣列</p>
<p>請先記住由於測試資料是 xxxxx 模式，所以透過 char 會來的比 int 陣列更方便輸入</p>
<p>下面的標題為 Line 行數<br>22. 由於路徑只會從小到大，於是從 i 開始遍地不斷嘗試<br>23. i -&gt; j 的路徑收尋<br>24. sum = 紀錄過去的路徑<br>25. i -&gt; k -&gt; j 先假設玩家透過 i -&gt; k ( Before 的路徑 )<br>26. after 要有才可以做 27. ，因為先前必須要有路徑才可以實行<br>27. 若是 after (必須要先確定有這個路徑，才可以用 sum 記錄才真實) 的路徑<br>30. 為甚麼是 sum +1? 例如說只有 2 個點 0 -&gt; 1 ，在前面的程式 sum = 0，因為前面程式邏輯 after[i][k] 要有值 sum 才會增加紀錄，所以 +1 表示為單純只從 a -&gt; b 次過程中並沒有其他的點。<br>31. 於是原始資料是有路徑的，所以透過 after 還原</p>
<p>對不起我解釋得很爛… 非常抱歉</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">char</span> before[<span class="number">520</span>][<span class="number">520</span>] = &#123;&#125; ;</span><br><span class="line"><span class="keyword">int</span> after[<span class="number">520</span>][<span class="number">520</span>] = &#123;&#125; ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; n ; j++)</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; before[i][j] ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面程式註解</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span> ; j &lt; n ; j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span> ;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = i + <span class="number">1</span> ; k &lt; j ; k++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(after[i][k])</span><br><span class="line">                    sum += before[k][j]-<span class="string">'0'</span> ;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>( (sum +<span class="number">1</span>) % <span class="number">10</span> == before[i][j] - <span class="string">'0'</span>)&#123;</span><br><span class="line">                after[i][j] = <span class="number">1</span> ;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n ; j++)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; after[i][j] ;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ICPC</category>
      </categories>
      <tags>
        <tag>ICPC_2019-2020_North-Western_Russia_Regional_Contest</tag>
        <tag>Floyd-Warshall algorithm</tag>
        <tag>ICPC</tag>
        <tag>程式解題</tag>
        <tag>動態規劃 Dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title>ProblemM Managing Difficulties (Complex Optimization)</title>
    <url>/2020/05/18/ICPC/ICPC-2019-2020-North-Western-Russia-Regional-Contest-Pm/</url>
    <content><![CDATA[<script type="text/javascript"
  src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>給你一斷數列<br>判斷裡面的值有幾個是可以符合公式 \(a_j−a_i=a_k−a_j\)</p>
</blockquote>
<a id="more"></a>


<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>這題很簡單，就是要著重在效率時顯得十分棘手。<br>我將分成 3 個部分說明。</p>
<ol>
<li><p>透過字典優化<br>可將公式移項成 \(2a_j = a_i + a_k \)，加上 i &gt; j &gt; k<br>透過字典的部分能夠將 \(a_k\) 點就可以省略掉 for k 的迴圈</p>
</li>
<li><p>j 從最後 n - 1 開始往前 for<br>如果只透過 1. 會發現一個問題，因為在每次 i 結束時，需要再將之前刪除的 dict[j] 值補回，會增加一個 for與是透過反向輸出，可省略掉須將刪除的 dict[j] 補回，於是減少一個 for了!</p>
</li>
<li><p>使用unorder_map<br>map 會造成效率增加  \( o (n \log \ n)\)，少量使用內存。<br><a href="https://blog.csdn.net/StephenZou14/article/details/69568620" target="_blank" rel="noopener">unordered_map</a> 則是效率減少 \(o(1)\)，大量使用內存。</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> num[<span class="number">2020</span>] = &#123;&#125; ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> t , n , ans, now  ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t ;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span> ,<span class="keyword">int</span> &gt; dict ;</span><br><span class="line">        ans = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; num[i] ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dict[num[n<span class="number">-1</span>]] += <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = n<span class="number">-2</span> ; j &gt; <span class="number">0</span> ; j--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; j ; i++ )&#123;</span><br><span class="line">                now = <span class="number">2</span> * num[j] - num[i] ;</span><br><span class="line">                ans += dict[now];</span><br><span class="line">            &#125;</span><br><span class="line">            dict[num[j]]+=<span class="number">1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>ICPC</category>
      </categories>
      <tags>
        <tag>ICPC_2019-2020_North-Western_Russia_Regional_Contest</tag>
        <tag>效率優化</tag>
        <tag>ICPC</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>債劵定價筆記</title>
    <url>/2020/07/02/NTUT_note/bond-pricing/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊與財金管理系大一下財務管理中債劵定價重點整理<br><font color="#dd0000">並非所有人都適用，部分對我而言稍加容易的內容並不會寫在此內。</font></p>
</blockquote>
<a id="more"></a>

<h5 id="名詞解釋"><a href="#名詞解釋" class="headerlink" title="名詞解釋"></a>名詞解釋</h5><ul>
<li>r = 利率</li>
<li>t = 期數</li>
</ul>
<h2 id="債劵定價"><a href="#債劵定價" class="headerlink" title="債劵定價"></a>債劵定價</h2><ul>
<li>殖利率 (YTM) <ul>
<li><strong>每年</strong>使用這筆資金平均每年應該要付給債權人的資金成本</li>
<li>會隨著其他因素改變，如:違約程度風險，債劵到期時間長短</li>
<li>\(公司債券 = \sum_{t=0}^{n} \frac{利息}{(1+殖利率)^{t}} +  \frac{本金}{(1+殖利率)^{n}} \)</li>
<li>\(YTM = 當期受益率 + 資本利得(損失)率 \)</li>
</ul>
</li>
</ul>
<h3 id="殖利率計算機按法"><a href="#殖利率計算機按法" class="headerlink" title="殖利率計算機按法"></a>殖利率計算機按法</h3><ol>
<li>set = end </li>
<li>PV 輸入發行價格並在前面加上負號，如: -123</li>
<li>PMT 輸入利息</li>
<li>FV 輸入票價 </li>
<li>到 i 點 solve</li>
</ol>
<ul>
<li>票價發行<ul>
<li><table>
<thead>
<tr>
<th>票面利率與殖利率比較</th>
<th>評價</th>
</tr>
</thead>
<tbody><tr>
<td>票面利率 = 殖利率</td>
<td>評價發行</td>
</tr>
<tr>
<td>票面利率 &gt; 殖利率</td>
<td>溢價發行</td>
</tr>
<tr>
<td>票面利率 &lt; 殖利率</td>
<td>折價發行</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li>債劵風險<ul>
<li>到期日越久的債劵風險越高</li>
<li>利率越高的債券風險越低</li>
</ul>
</li>
<li>當期收益率 \( current yield \)<ul>
<li>\(current yield = \frac{當年度利息收入}{債劵當年度期初價格} \)</li>
</ul>
</li>
<li>資本利得率<ul>
<li>\(資本利得率 = \frac{債券今年價格 - 債券去年價格}{債券去年價格} \)</li>
</ul>
</li>
</ul>
<h2 id="債券特性"><a href="#債券特性" class="headerlink" title="債券特性"></a>債券特性</h2><ul>
<li>債券的利息可以被當成費用，降低稅率</li>
<li>債券名稱依時間長短區分<ul>
<li>中期債券 -&gt; 一年以上，十年以下</li>
<li>長期債券 -&gt; 十年以上</li>
</ul>
</li>
<li>債劵名稱以擔保品區分<ul>
<li>擔保債券 -&gt; 用股票或其他有價債券擔保</li>
<li>抵押擔保債券 -&gt; 以固定資產或不動產擔保</li>
<li>信用債券 -&gt; 用信用擔保，通常信譽良好大公司才能發行<ul>
<li><font color="#dd0000"><strong>信用債券必須等到公司將其他債務清償完畢後才能求償</strong></font>，但能優於股東</li>
</ul>
</li>
</ul>
</li>
<li>贖回債券 (call provision)<ul>
<li>公司可以買回，但通常會比票面價格高</li>
</ul>
</li>
<li>償債基金 (sinking fund)<ul>
<li>透過特定信託公司，買回或贖回特定債券</li>
</ul>
</li>
</ul>
<h2 id="債券評價"><a href="#債券評價" class="headerlink" title="債券評價"></a>債券評價</h2><ul>
<li>債券平等<ul>
<li>評價越高，投資人要求報酬低</li>
<li>評價越低，投資人要求報酬高</li>
</ul>
</li>
<li>投資型債券<ul>
<li>評價等級高，以賺取本金與少許利息</li>
</ul>
</li>
<li>投機型債券<ul>
<li>評價等級低，以賺取本金與<strong>大量</strong>利息</li>
</ul>
</li>
</ul>
<h2 id="市場術語"><a href="#市場術語" class="headerlink" title="市場術語"></a>市場術語</h2><ul>
<li>交叉型債券<ul>
<li>被 n 種信評公司評初不同等級債券</li>
</ul>
</li>
<li>垃圾債券 (Jund Bond) <ul>
<li>信用較差公司，發行的高收益債券，通常都以高票面利率為主</li>
</ul>
</li>
<li>墮落天使 (fallen angel)<ul>
<li>從投資型債券轉變成垃圾債券</li>
</ul>
</li>
<li>NCAA<ul>
<li>No coupon at all -&gt; 無法支付任何利息的債券</li>
</ul>
</li>
</ul>
<h2 id="其他債券"><a href="#其他債券" class="headerlink" title="其他債券"></a>其他債券</h2><ul>
<li>金融債券<ul>
<li>還本期間不得低於兩年</li>
</ul>
</li>
<li>零息債券 (zero coupon bond)<ul>
<li>完全不支付利息，到期末時將一次性將面額償還，通常面額裡面內含利息</li>
<li>\(發行價格 = \frac{發行面額}{(1+r)^{t}}\)</li>
<li>發行必定為<strong>折價</strong>發行</li>
<li>\(利息(coupon) = 發行面額 - 發行價格 \)</li>
<li>到期前不付息，但必須提列利息費用</li>
</ul>
</li>
<li>浮動利率 (floating-rate bond)<ul>
<li>每 3 到 6 個月進行調整利率</li>
<li>仍有上下限，上下限區間為利率區間</li>
<li>通常為金融機構發行，時間約為 10 年</li>
</ul>
</li>
<li>可轉換債券 (convertible bond)<ul>
<li>在到期前，可以有<strong><font color="#dd0000">權利(非義務)</font>轉成<font color="#dd0000">原發行機構股票</font></strong></li>
</ul>
</li>
<li>可交換公司債 (exchangeable bond)<ul>
<li>在到期前，可以有<strong><font color="#dd0000">權利(非義務)</font>轉成<font color="#dd0000">其他發行機構股票</font></strong></li>
</ul>
</li>
<li>附認購權債證券 (warrant bond)<ul>
<li>在購買此債券時，可以用較低價格買該機構發行股票，以刺激投資債券</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>北科上課筆記</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>財務管理筆記</tag>
        <tag>北科大一下財務管理筆記</tag>
        <tag>北科上課筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>資本預算決策</title>
    <url>/2020/07/03/NTUT_note/capital-budget-decision/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊與財金管理系大一下財務管理中資本預算決策重點整理<br><font color="#dd0000">並非所有人都適用，部分對我而言稍加容易的內容並不會寫在此內。</font></p>
</blockquote>
<a id="more"></a>

<h5 id="名詞解釋"><a href="#名詞解釋" class="headerlink" title="名詞解釋"></a>名詞解釋</h5><ul>
<li>\(r_{s} = 股東要求報酬率\)</li>
<li>\(r_{d} = 債權人要求報酬率 \)</li>
<li>\(n = 年數 \)</li>
</ul>
<h4 id="基本觀念"><a href="#基本觀念" class="headerlink" title="基本觀念"></a>基本觀念</h4><ul>
<li>資本<ul>
<li>運用於長期投資方案資金為資本</li>
</ul>
</li>
<li>資本預算決策<ul>
<li>判斷資本應投資在哪項長期資產</li>
</ul>
</li>
<li>決策類別<ol>
<li>在某 1 時點利用各種評估技術判定<strong>某投資方案是否可行</strong></li>
<li>在某 1 時點利用各種評估技術判定<strong>多方案中何者最佳</strong></li>
</ol>
</li>
<li>投資方案<ul>
<li>獨立方案 (independent projects)<ul>
<li>此投資案不影響其他</li>
</ul>
</li>
<li>互斥方案 (mutually exclusive projects)<ul>
<li>選 A 則其餘方案不可選</li>
</ul>
</li>
<li>初次新投資案 (new venture projects)<ul>
<li>無投資經驗，評估成本難，風險高</li>
</ul>
</li>
<li>擴增方案 (expansion projects)<ul>
<li>以增加效能為目的，評估成本與風險次難</li>
</ul>
</li>
<li>重置方案 (replacement projects)<ul>
<li>更新設備，風險低，評估容易</li>
</ul>
</li>
</ul>
</li>
<li>投資產生的現金流入<ul>
<li>在未來發生<ul>
<li>考慮貨幣時間價值</li>
</ul>
</li>
<li>發生的年數與金額不確定性高<ul>
<li>無法完美預估，總有變數</li>
</ul>
</li>
<li>受市場景氣影響<ul>
<li>受限於景氣循環</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="淨現值法-NPV"><a href="#淨現值法-NPV" class="headerlink" title="淨現值法 NPV"></a>淨現值法 NPV</h2><p>未來收益折現後，判斷投資優劣標準<br>\( NPV = \frac{現金}{(1+資金成本)^{n}} - 期初投入金額 \)</p>
<ul>
<li>優點<ol>
<li>考量到投資案本身真實現金流量，而非會計數字</li>
<li>考量到投資案所有現金流量，結果精確</li>
<li>考量了貨幣時間價值，未來現金流入折現計算</li>
</ol>
</li>
</ul>
<h2 id="還本期法-Payback-period-method-與-折現還本期法-discounted-payback-period-method"><a href="#還本期法-Payback-period-method-與-折現還本期法-discounted-payback-period-method" class="headerlink" title="還本期法 (Payback period method) 與 折現還本期法 (discounted payback period method)"></a>還本期法 (Payback period method) 與 折現還本期法 (discounted payback period method)</h2><p>投資金額需 x 年才能完全回收，通常以年為單位。<br>不考慮折現為還本期法，考慮則為折現還本期法。</p>
<ul>
<li>優點<ol>
<li>方法簡單</li>
<li>方便衡量管理者決策能力</li>
<li>可大概了解一筆資金套牢致回收的時間 </li>
</ol>
</li>
<li>缺點<ol>
<li>未考慮時間價值</li>
</ol>
</li>
</ul>
<h2 id="內部報酬率法-IRR"><a href="#內部報酬率法-IRR" class="headerlink" title="內部報酬率法 IRR"></a>內部報酬率法 IRR</h2><p>考慮今年時間價值，計算出隱含報酬率，在將報酬率與資金成本比較並判定投資案可行性</p>
<ul>
<li>特性<ol>
<li>考慮所有現金流量</li>
<li>考慮現金流量時間價值</li>
<li>獨立方案與追求公司價值最大化目標一致</li>
<li>互斥方案與追求公司價值極大化目標不一致</li>
</ol>
</li>
</ul>
<h2 id="修正後內部報酬率法-MIRR"><a href="#修正後內部報酬率法-MIRR" class="headerlink" title="修正後內部報酬率法 MIRR"></a>修正後內部報酬率法 MIRR</h2><p>IRR 可能導致誤判，因而產生此法修正。<br>如有甲乙兩互斥方案，分別畫出 NPV 線，如有相交情況則該焦點資金成本稱為銜接率 (crossover rate)<br>當資金成本低於銜接率時，IRR會<font color="#dd0000"><strong>誤判</strong></font></p>
<ul>
<li>銜接率計算:<ul>
<li>類似於 NPV，需將兩方案每次獲得的收益量相減，所得數值為銜接率。一樣使用 NPV 計算</li>
</ul>
</li>
</ul>
<h2 id="計算機按法-IRR-and-NPV"><a href="#計算機按法-IRR-and-NPV" class="headerlink" title="計算機按法 IRR and NPV"></a>計算機按法 IRR and NPV</h2><ol>
<li>輸入利率 (若想詢問 IRR 可忽略此步驟)</li>
<li>csh 點擊執行</li>
<li>第一期輸入為負數，接下來都為正數</li>
<li>在按一次 CASH </li>
<li>選擇 IRR or NPV 按執行</li>
</ol>
<h2 id="計算機按法-MIRR"><a href="#計算機按法-MIRR" class="headerlink" title="計算機按法 MIRR"></a>計算機按法 MIRR</h2><ol>
<li>先使用 CPMD 計算複利</li>
<li>PMT 輸入每年報酬</li>
<li>n 為期數</li>
<li>i 為利率</li>
<li>FV 按執行</li>
<li>\((FV / 投資價格)^{1/年數} \)</li>
</ol>
<h2 id="獲利指數法-profitability-index-PI"><a href="#獲利指數法-profitability-index-PI" class="headerlink" title="獲利指數法 (profitability index , PI)"></a>獲利指數法 (profitability index , PI)</h2><ul>
<li>特性<ol>
<li>考慮全部現金流量</li>
<li>考慮現金流量時間價值</li>
<li>獨立方案與追求公司價值極大化目標一致</li>
<li>互斥方案與追求公司價值極大化目標不一致</li>
<li>若是獨立方案只要 PI &gt; 1全部採用</li>
</ol>
</li>
<li>公式<ul>
<li>\( PI = \frac{\frac{當年度收益}{(1+資金成本)^{年數}}}{期初投資}\)</li>
</ul>
</li>
</ul>
<h2 id="實務上的資本決策方法"><a href="#實務上的資本決策方法" class="headerlink" title="實務上的資本決策方法"></a>實務上的資本決策方法</h2><ul>
<li>IRR 與 NPV 最常被使用</li>
<li>還本期法應計算方便為第二長使用</li>
</ul>
]]></content>
      <categories>
        <category>北科上課筆記</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>財務管理筆記</tag>
        <tag>北科大一下財務管理筆記</tag>
        <tag>北科上課筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>股票定價筆記</title>
    <url>/2020/07/02/NTUT_note/stock_pricing/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊與財金管理系大一下財務管理中股票定價重點整理<br><font color="#dd0000">並非所有人都適用，部分對我而言稍加容易的內容並不會寫在此內。</font></p>
</blockquote>
<a id="more"></a>

<h2 id="普通股"><a href="#普通股" class="headerlink" title="普通股"></a>普通股</h2><ul>
<li><p>普通股介紹</p>
<ol>
<li>有稅後盈餘且提撥過資本公積與盈餘公積才可以發放股利   </li>
<li>股利不可以折稅或當成公司費用使用</li>
<li>有 \( 2 \% \) 健保補充費</li>
</ol>
</li>
<li><p>普通股評價 </p>
<ul>
<li><p>現金股利零成長</p>
<ol>
<li>\( \frac{現金股利}{必要報酬率}\)</li>
</ol>
</li>
<li><p>股利固定成長型</p>
<ol>
<li>\( \frac{現金股利 * (1+股利成長率) }{必要報酬率 - 股利成長率} \)</li>
<li>\(下一次股價 = 這次股價 * (1+股利成長率)\)</li>
</ol>
</li>
<li><p>非固定成長股利</p>
<ol>
<li>\( \frac{現金股利 * (1+前面股利成長率)}{(1+要求報酬率)} + 後來的股利固定成長型 \)</li>
</ol>
</li>
<li><p>股利成長率 \((g)\)</p>
<ul>
<li>\(股利成長率(g) = 保留比率 * 普通股權益報酬率 \)</li>
</ul>
</li>
<li><p>普通股權益報酬率 \((ROE)\)</p>
<ul>
<li>\(\frac{淨利}{平均普通股股東權益}\)</li>
</ul>
</li>
<li><p>必要報酬率 \((k)\)</p>
<ul>
<li>\( k = g + \frac{明年的現金股利}{股價} \)</li>
</ul>
</li>
<li><p>\((每股盈餘 = EPS)\)</p>
</li>
</ul>
</li>
<li><p>本益比還原法</p>
<ul>
<li>\( E(p) = 產業平均比 * 預期 EPS \)</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>北科上課筆記</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>財務管理筆記</tag>
        <tag>北科大一下財務管理筆記</tag>
        <tag>北科上課筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>資本結構筆記</title>
    <url>/2020/07/02/NTUT_note/capital-structure/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊與財金管理系大一下財務管理中資本結構重點整理<br><font color="#dd0000">並非所有人都適用，部分對我而言稍加容易的內容並不會寫在此內。</font></p>
</blockquote>
<a id="more"></a>

<h5 id="名詞解釋"><a href="#名詞解釋" class="headerlink" title="名詞解釋"></a>名詞解釋</h5><ul>
<li>\(k = 負債資本成本\)</li>
<li>\(R_{s} = 權益資本成本 \)</li>
<li>\(EBIT = 稅前息前利潤\)</li>
<li>\( A = 舉債後普通股資本成本 \)</li>
<li>\( B = 舉債前普通股資本成本 \)</li>
</ul>
<h2 id="資本結構"><a href="#資本結構" class="headerlink" title="資本結構"></a>資本結構</h2><ul>
<li>資本來源<ul>
<li>長期負債</li>
<li>股東權益</li>
</ul>
</li>
<li>資本結構以負債比例衡量<ul>
<li>\(長期負債 / (股東權益 + 長期負債) \)</li>
<li>\(長期負債 / (股東權益) \) 筆記採用此定義</li>
</ul>
</li>
<li>公司價值總和計算<ol>
<li>未來所有現金流入之折現值</li>
<li>流通在外有價證劵 (股票加負債)總市值</li>
<li>上述兩者必相同</li>
</ol>
</li>
<li>資本成本<ul>
<li>資金使用者: 使用每一元付出的代價</li>
<li>資金提供者: 使用每一元獲得的報酬</li>
<li>資本成本計算<ul>
<li>\( \frac{明年現金股利}{普通股價格} + 股票成長率 \)</li>
</ul>
</li>
</ul>
</li>
<li>債務資本成本<ul>
<li>通常都以 % 為單位</li>
<li>\(資金成本 = 名目利息 - 名目利息 * 稅率 \)</li>
</ul>
</li>
<li>加權平均資金成本 (WACC)<ul>
<li>無公司所得稅時，舉債增加，WACC<strong>不變</strong></li>
<li>有公司所得稅時，舉債增加，WACC<strong>減少</strong></li>
<li>\(WACC = \frac{權益}{負債+權益} * 權益資本成本 + \frac{負債}{負債+權益} * 債務資本成本 * (1 - 所得稅率) \)</li>
</ul>
</li>
<li>固定投資成長<ul>
<li>\( PV = \frac{每年獲益量}{WACC - 成長率}\)</li>
</ul>
</li>
<li>公司價值與股東財富最大化<ul>
<li>公司價值增加，股東財富增加</li>
<li>如果資本結構影響公司價值，則經理人應讓公司價值極大化才能讓股東財富極大化</li>
</ul>
</li>
</ul>
<h2 id="MM理論"><a href="#MM理論" class="headerlink" title="MM理論"></a>MM理論</h2><ul>
<li><font color="#dd0000"><strong>無所得稅</strong></font><ul>
<li>在<font color="#dd0000"><strong>無所得稅</strong></font>下，公司價值與資本結構無關</li>
<li>\(公司價值 = \frac{EBIT}{普通股資本成本} \)</li>
<li>舉債後會提高普通股的資金成本，因舉債後公司風險上升，股東勢必會要求更高報酬率。公式與定義如下:<br>\(A = B +  (B - 此債務資本成本) * (舉債 / (公司價值 - 舉債) )\)<br>且總和必定會跟原先計算 WACC 不變</li>
</ul>
</li>
<li><font color="#dd0000"><strong>有所得稅</strong></font><ul>
<li>在<font color="#dd0000"><strong>有所得稅</strong></font>下，公司價值與資本結構有關且提升   </li>
<li>\(公司價值 = \frac{EBIT * (1 - 稅率)}{普通股資本成本} + 舉債 * 稅率\)</li>
<li>\(A = B + (B - 此債務資本成本) * (1 - 稅率) * (舉債 / (公司價值 - 舉債))\)</li>
</ul>
</li>
</ul>
<h2 id="槓桿關聯成本"><a href="#槓桿關聯成本" class="headerlink" title="槓桿關聯成本"></a>槓桿關聯成本</h2><ul>
<li>財務危機成本 (financial distress cost)<ul>
<li>直接破產成本: 公司已破產，申請破產之行政費用。如:律師、會計師行政費用</li>
<li>間接破產成本: 處於財務危機，避免破產而產生的相關費用</li>
</ul>
</li>
<li>負債代理成本<ul>
<li>債權人避免經理人做出對股東有利而對債權人不利的相關費用。如:監督經理人相關費用</li>
<li>高風險投資<ul>
<li>如投資成功，債權人只能拿到一樣利息，但股東可拿更多。反之，失敗則債權人可能完全拿不回來，股東也只會失去先前投資金額</li>
</ul>
</li>
<li>不作該做投資<ul>
<li>若投資案可能影響到股東利益，而使股東要求經理人不投資</li>
</ul>
</li>
<li>舉債發放現金股利<ul>
<li>損害公司的償債能力</li>
</ul>
</li>
</ul>
</li>
<li>債權人減少監督股東的代理成本做法<ol>
<li>限制舉債投資項目</li>
<li>舊債之優先求償權</li>
<li>限制債務期間現金股利發放</li>
<li>限制舉新債</li>
</ol>
</li>
</ul>
<h2 id="訊號發射理論"><a href="#訊號發射理論" class="headerlink" title="訊號發射理論"></a>訊號發射理論</h2><p>公司管理人員與投資人員存在資訊不對稱 (information asymmetry)，當公司資本結構已給投資人知道時，公司經營狀況就已經改變，投資人可在這時重新評估公司價值</p>
<ul>
<li>舉債增加<ul>
<li>有高獲利投資機會時，公司會選擇舉債而避免發行新股而造成利益稀釋</li>
</ul>
</li>
<li>發行新股<ul>
<li>公司投資機會風險高或經營狀況不佳時，所需資金則會以發行股票來獲得，以避免無法還債風險</li>
</ul>
</li>
<li><strong>舉債是好消息而發行新股是壞消息</strong></li>
<li>公司應該將負債水準控制在較低水準，有好機會再使用負債融資</li>
</ul>
<h2 id="融資順利理論"><a href="#融資順利理論" class="headerlink" title="融資順利理論"></a>融資順利理論</h2><p>融資可分成三類，保留盈餘、舉債、發行新股。而企業優先採有的資訊來源順序如下:</p>
<ol>
<li>保留盈餘</li>
<li>舉債</li>
<li>發行新股</li>
</ol>
<ul>
<li>此理論並不認為公司存在最理想之負債水準，公司視資金需要時機不同，而決定是否採用負債融資</li>
<li>此理論認為足夠獲利公司會先採用保留盈餘，MM理論則認為會先使用負債，達到稅盾效果</li>
<li>此理論認為最先利用應為保留盈餘，而備投資案所用。但MM理論考慮權益代理成本認為過多的自由現金會導致管理階層浪費</li>
</ul>
]]></content>
      <categories>
        <category>北科上課筆記</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>財務管理筆記</tag>
        <tag>北科大一下財務管理筆記</tag>
        <tag>北科上課筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>QUESTION! R 如果要讓程式碼換行要怎麼辦?</title>
    <url>/2020/08/12/R/R-coding-new-line/</url>
    <content><![CDATA[<h2 id="內容說明"><a href="#內容說明" class="headerlink" title="內容說明"></a>內容說明</h2><blockquote>
<p>寫程式的時候是不可能沒遇到 bug 的，bug 紀錄整理</p>
</blockquote>
<a id="more"></a>


<h2 id="QUESTION-R-如果要讓程式碼換行要怎麼辦"><a href="#QUESTION-R-如果要讓程式碼換行要怎麼辦" class="headerlink" title="QUESTION: R 如果要讓程式碼換行要怎麼辦?"></a>QUESTION: R 如果要讓程式碼換行要怎麼辦?</h2><h3 id="answer"><a href="#answer" class="headerlink" title="answer:"></a>answer:</h3><p>如果是在 Rstudio 畫面時，就直接按 enter 即可，不須再加 \</p>
<h4 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h4><p><a href="https://bbs.pinggu.org/thread-2187964-1-1.html" target="_blank" rel="noopener">[问答] 在R程序脚本中如何换行</a></p>
<h2 id="QUESTION-R-的-if-要怎麼使用"><a href="#QUESTION-R-的-if-要怎麼使用" class="headerlink" title="QUESTION: R 的 if 要怎麼使用"></a>QUESTION: R 的 if 要怎麼使用</h2><h3 id="answer-1"><a href="#answer-1" class="headerlink" title="answer:"></a>answer:</h3><p>很簡單，但必須要注意 R 並不是用 <code>continue</code> 來當作下一個，而是使用 <code>next</code></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">x &lt;- <span class="number">1</span>:<span class="number">5</span></span><br><span class="line"><span class="keyword">for</span> (val <span class="keyword">in</span> x) &#123;</span><br><span class="line">    <span class="keyword">if</span> (val == <span class="number">3</span>)&#123;</span><br><span class="line">    <span class="keyword">next</span></span><br><span class="line">    &#125;</span><br><span class="line">print(val)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="參考連結-1"><a href="#參考連結-1" class="headerlink" title="參考連結:"></a>參考連結:</h2><p><a href="https://www.datamentor.io/r-programming/break-next/" target="_blank" rel="noopener">R break and next Statement</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>程式語言的世界博大精神，要是沒有他們的付出我能走上現在的路嗎?<br>肯定是沒辦法的，於是我也需要更努力地去為社會付出。</p>
]]></content>
      <categories>
        <category>R語言</category>
      </categories>
      <tags>
        <tag>R語言</tag>
        <tag>學習筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>貨幣時間價值筆記</title>
    <url>/2020/07/02/NTUT_note/time-value-of-money/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊與財金管理系大一下財務管理章節中貨幣時間價值筆記重點整理<br><font color="#dd0000">並非所有人都適用，部分對我而言稍加容易的內容並不會寫在此內。</font></p>
</blockquote>
<a id="more"></a>

<h5 id="名詞解釋"><a href="#名詞解釋" class="headerlink" title="名詞解釋"></a>名詞解釋</h5><ul>
<li>\(m = 月份\)</li>
<li>\(r = 利率 \)</li>
</ul>
<h2 id="複利與有效年利率"><a href="#複利與有效年利率" class="headerlink" title="複利與有效年利率"></a>複利與有效年利率</h2><ul>
<li>\(現值 = PV \)</li>
<li>問複利的利率，給期初、期末金額<ul>
<li>\( (期末/期初)^{\frac{1}{年數}}\)</li>
</ul>
</li>
<li>七二法則<ul>
<li>如果利率為 k 倍，期數為 n，則要使本金成長一倍的時間可由 \(k * n = 72 \)來求出近似值。</li>
</ul>
</li>
<li>複利<ul>
<li>\( FV = PV*(1+\frac{r}{m})^{m}\)   </li>
</ul>
</li>
<li>有效年利率 \( EAR \)<ul>
<li>\(EAR = (1+ \frac{r}{m})^{m} -1 \)</li>
</ul>
</li>
<li>連續複利下的 EAR <ul>
<li>\((1+ \frac{r}{m})^{m} -1 \)</li>
</ul>
</li>
</ul>
<h2 id="年金"><a href="#年金" class="headerlink" title="年金"></a>年金</h2><ul>
<li>普通年金<ul>
<li>每一期<strong>末</strong>領取或支付金額，直到期滿為止</li>
</ul>
</li>
<li>期初年金<ul>
<li>每一期<strong>初</strong>領取或支付金額，直到期滿為止</li>
</ul>
</li>
<li>永續年金<ul>
<li>普通年金或期初年金方式，但期數為無限多期</li>
</ul>
</li>
</ul>
<h3 id="普通、期初年金計算機按法"><a href="#普通、期初年金計算機按法" class="headerlink" title="普通、期初年金計算機按法"></a>普通、期初年金計算機按法</h3><ol>
<li>點 CMPD</li>
<li>PMT 為每年要付的金額</li>
<li>FV 未來要提領的金額</li>
<li>I 利率</li>
<li>n 期數</li>
<li>set 選擇普通年金還是期初年金</li>
<li>PV 現在所提領金額 (基本上不用到)</li>
<li><strong>未用到的數值都要歸零</strong></li>
</ol>
<h3 id="永續年金計算方式"><a href="#永續年金計算方式" class="headerlink" title="永續年金計算方式"></a>永續年金計算方式</h3><p>\(PV = \frac{PMT}{r}\)</p>
<h2 id="貸款形式與攤銷"><a href="#貸款形式與攤銷" class="headerlink" title="貸款形式與攤銷"></a>貸款形式與攤銷</h2><ul>
<li>純折價貸款 (pure discont loan)<ul>
<li>期初借入，期中<strong>不給錢</strong>，期末一次給清</li>
</ul>
</li>
<li>純付息貸款 (interest-only loan)<ul>
<li>期初借入，期中<strong>付利息</strong>，期末付最後一次利息與本金</li>
</ul>
</li>
<li>分期貸款 (amortized loan) 有下述兩種<ol>
<li>期初借入，期中<strong>付利息也支付固定金額償還本金欠款</strong>，期末償還完畢</li>
<li>期初借入，期中<strong>支付固定金額內包含部分本金與利息</strong>，期末償還完畢</li>
</ol>
</li>
</ul>
<h3 id="貸款題型"><a href="#貸款題型" class="headerlink" title="貸款題型"></a>貸款題型</h3><ul>
<li>氣球型貸款<ul>
<li>給你帶 x 年貸款，但在第 y 年時貸款就必須付清。其中 x &gt; y <ol>
<li>每月底償付固定本息的金額是多少?<br>A:  一樣用 x 算不必在算 y</li>
<li>y 年到期時時未償還金額為多少?<br>A:  將第一題算出的 PMT 帶入年金公式即可，因為它題目詢問為現值。</li>
</ol>
</li>
</ul>
</li>
<li>每 x 年支付一次的年金，利率應該怎麼算?<ul>
<li>\(利率 = (1+r)^{x}-1\)</li>
</ul>
</li>
<li>我每年付 x 年，但我最後 y 年都必須提取 z 元，則我每年該存入多少固定資金<ol>
<li>使用期初年金公式，先將 y 年存取 z 元折現回來，那就是我們要存錢時期的最後終值</li>
<li>再用最後終值帶入普通年金公式，PMT就是我們要的答案</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>北科上課筆記</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>財務管理筆記</tag>
        <tag>北科大一下財務管理筆記</tag>
        <tag>北科上課筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>透過 plumber 完成 RESTAPI 在 R 上的應用</title>
    <url>/2020/07/23/R/R-api/</url>
    <content><![CDATA[<h2 id="內容說明"><a href="#內容說明" class="headerlink" title="內容說明"></a>內容說明</h2><blockquote>
<p>RESTAPI 有點類似於打包程式碼成為 class 的概念，一開始再碰 RESTAPI 會較難懂。<del>我第一次學 API 就是現在，我花了快兩三個小時才懂RRR</del><br>plumber 可以應用在 RESTAPI<br>以下紀錄 plumber 在 R 上的應用與<strong><font color="#dd0000">需要注意的地方</font></strong></p>
</blockquote>
<a id="more"></a>

<h2 id="安裝-plumber"><a href="#安裝-plumber" class="headerlink" title="安裝 plumber"></a>安裝 plumber</h2><p>首先需要 plumber</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">install.packages(<span class="string">"plumber"</span>)</span><br></pre></td></tr></table></figure>

<h2 id="教學範例"><a href="#教學範例" class="headerlink" title="教學範例"></a>教學範例</h2><h3 id="使用-R-plumber-可以檢的使用-R-創建-RESTFUL-API，plumber-識別-，以下提供簡單範例"><a href="#使用-R-plumber-可以檢的使用-R-創建-RESTFUL-API，plumber-識別-，以下提供簡單範例" class="headerlink" title="使用 R plumber 可以檢的使用 R 創建 RESTFUL API，plumber 識別 #*，以下提供簡單範例"></a>使用 R <code>plumber</code> 可以檢的使用 R 創建 RESTFUL API，plumber 識別 <code>#*</code>，以下提供簡單範例</h3><figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="keyword">library</span>(plumber)</span><br><span class="line"></span><br><span class="line"><span class="comment">#* @method /url</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#* Echo provided text</span></span><br><span class="line"><span class="comment">#* @param text The text to be echoed in the response</span></span><br><span class="line"><span class="comment">#* @get /echo</span></span><br><span class="line"><span class="keyword">function</span>(text = <span class="string">""</span>) &#123;</span><br><span class="line">  list(</span><br><span class="line">    message_echo = paste(<span class="string">"The text is:"</span>, text)</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="在-R-上面啟動-api-指令"><a href="#在-R-上面啟動-api-指令" class="headerlink" title="在 R 上面啟動 api 指令"></a>在 R 上面啟動 api 指令</h3><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">plumber::plumb(file=<span class="string">'./plumber.R'</span>)$run(port = <span class="number">5762</span>)</span><br></pre></td></tr></table></figure>

<p>其中 port 可以忽略不打(則會隨機產生)，接下來用 curl 來試著呼叫</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl --data &quot;text&#x3D;hi_my_friend&quot; &quot;localhost:5762&#x2F;echo&quot;</span><br></pre></td></tr></table></figure>

<h3 id="如果要輸出-json-呢"><a href="#如果要輸出-json-呢" class="headerlink" title="如果要輸出 json 呢"></a>如果要輸出 json 呢</h3><p>這點 R 完全幫你做好，R 可以自動幫你轉成 json，但還是有少部分情況例外。<strong><font color="#dd0000">裡面完全不需要轉成 json，就放心地給他輸出吧！</font></strong><br><strong>只限定傳送一個參數並且是 json 檔案</strong></p>
<h3 id="我想要輸入-json，但我卻輸入不進去"><a href="#我想要輸入-json，但我卻輸入不進去" class="headerlink" title="我想要輸入 json，但我卻輸入不進去.."></a>我想要輸入 json，但我卻輸入不進去..</h3><p>這點就比較有趣了，看下面的程式碼就能了解箇中奧妙</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">#* parse JSON</span></span><br><span class="line"><span class="comment">#* @param req  the request object</span></span><br><span class="line"><span class="comment">#* @get /json</span></span><br><span class="line"><span class="comment">#* @post /json</span></span><br><span class="line">echo_json &lt;- <span class="keyword">function</span>(req)&#123;</span><br><span class="line">  print(req$postBody)</span><br><span class="line">  <span class="keyword">return</span>(req$postBody)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到了嘛!? 我們必須在物件後使用 <code>$postBody</code>，就可以成功輸入 json</p>
<h3 id="我遇到了一個問題，我不懂要怎麼把-json-post-給-api"><a href="#我遇到了一個問題，我不懂要怎麼把-json-post-給-api" class="headerlink" title="我遇到了一個問題，我不懂要怎麼把 json post 給 api"></a>我遇到了一個問題，我不懂要怎麼把 json post 給 api</h3><p>小問題，我已經試過了，早就狀況排除了~ <del>血與淚的過程</del></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl &quot;localhost:8551&#x2F;url&quot; --header &quot;Content-type:application&#x2F;json&quot; -X POST -d @path&#x2F;file</span><br></pre></td></tr></table></figure>

<h2 id="QUESTIONS-and-ERRORS-集合地"><a href="#QUESTIONS-and-ERRORS-集合地" class="headerlink" title="QUESTIONS and ERRORS 集合地"></a>QUESTIONS and ERRORS 集合地</h2><p>這裡有些作者已經經歷過的問題就放在這裡供大家參考怎麼解決或<del>放棄</del>。</p>
<h3 id="QUESTION-windows上傳遞參數的時候出現亂碼怎麼辦？"><a href="#QUESTION-windows上傳遞參數的時候出現亂碼怎麼辦？" class="headerlink" title="QUESTION: windows上傳遞參數的時候出現亂碼怎麼辦？"></a>QUESTION: windows上傳遞參數的時候出現亂碼怎麼辦？</h3><p>改用 LINUX 平台是目前作者最好的解法。由於 Window 似乎在傳遞進來時編碼會遇到問題例如 <code>‘</code> 透過字串傳輸在 windows 上是亂碼，但在 Linux 不會，於是建議遇到此問題一律都使用 linux server 來解決。</p>
<h2 id="寫一個-api-傳送許多參數"><a href="#寫一個-api-傳送許多參數" class="headerlink" title="寫一個 api 傳送許多參數"></a>寫一個 api 傳送許多參數</h2><p>有時候我們並不是只需要傳送一個參數，而是傳送多個參數時就必須這樣寫。</p>
<p>如果參數後面的等於配上空字串表示預設為空，只有被傳回來有；那後面如果有值則代表如果 api 沒有傳此參數就已預設為主。<br><strong>注意，參數後面一律都必須搭配字串，api 傳送的都是字串格式</strong></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">path_json &lt;- <span class="keyword">function</span>(data = <span class="string">""</span> , path_length = <span class="string">"20"</span> )&#123;</span><br><span class="line">  json_content &lt;- run_path(data , path_length )</span><br><span class="line">  <span class="keyword">return</span>(json_content)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>其實不得不說，要不是因為有上班的地方願意讓我磨練，不然我可能連 api 是甚麼都還需要等到未來 2,3 年後我才能夠熟悉並且知道這些事物，也很謝謝<strong>高鈺成學長</strong>在我有些遇到狀況時會給我些許提示，然後專案報告真的好趕阿QwQ，希望我能夠如期做完，那就是最完美的了！謝謝 <strong>Luft 學長</strong> 幫我很多忙，也謝謝 steam 基礎教育聯盟給我機會學習。</p>
<h2 id="連結"><a href="#連結" class="headerlink" title="連結"></a>連結</h2><p>我在翻找資料的過程中，閱讀到一些對我非常有意義的資料。如下:</p>
<p><a href="https://rviews.rstudio.com/2018/07/23/rest-apis-and-plumber/" target="_blank" rel="noopener">REST APIs and Plumber</a><br><a href="https://www.rplumber.io/articles/routing-and-input.html" target="_blank" rel="noopener">Routing &amp; Input</a><br><a href="https://stackoverflow.com/questions/51944328/sending-json-file-in-curl-and-receiving-it-in-r-using-plumber/51945300#51945300" target="_blank" rel="noopener">Sending json file in curl and receiving it in R using plumber</a><br><a href="https://stackoverflow.com/questions/7172784/how-do-i-post-json-data-with-curl" target="_blank" rel="noopener">How do I POST JSON data with cURL?</a></p>
]]></content>
      <categories>
        <category>R語言</category>
      </categories>
      <tags>
        <tag>R語言</tag>
        <tag>學習筆記</tag>
        <tag>RESTAPI</tag>
      </tags>
  </entry>
  <entry>
    <title>ERROR! source(path) 裡面有中文字體時會出現無效位元的輸出解析</title>
    <url>/2020/08/12/R/R-chinese-bug/</url>
    <content><![CDATA[<h2 id="內容說明"><a href="#內容說明" class="headerlink" title="內容說明"></a>內容說明</h2><blockquote>
<p>寫程式的時候是不可能沒遇到 bug 的，bug 紀錄整理</p>
</blockquote>
<a id="more"></a>

<h2 id="ERROR-source-path-裡面有中文字體時會出現無效位元的輸出解析"><a href="#ERROR-source-path-裡面有中文字體時會出現無效位元的輸出解析" class="headerlink" title="ERROR: source(path) 裡面有中文字體時會出現無效位元的輸出解析"></a>ERROR: source(path) 裡面有中文字體時會出現無效位元的輸出解析</h2><blockquote>
<p>由於 R 對於漢字的不友善，使華語系國家需要使用其他方式來解決漢字問題。</p>
</blockquote>
<h3 id="solution-1"><a href="#solution-1" class="headerlink" title="solution 1:"></a>solution 1:</h3><p>嘗試用著各位前輩完成的方法</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="keyword">source</span>(path,encoding = <span class="string">"UTF-8"</span> , local=<span class="literal">TRUE</span>)</span><br></pre></td></tr></table></figure>
<h3 id="solution-2"><a href="#solution-2" class="headerlink" title="solution 2:"></a>solution 2:</h3><p>須將 source 改寫，透過 <code>R eval()</code>進行改寫，eval() 可將字串變成表達式(即 R 的程式碼)使用。<br>R 是可以進行覆寫的語言，可用這招來解決問題。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="keyword">source</span> &lt;- <span class="keyword">function</span>(path, encoding = <span class="string">'UTF-8'</span>) &#123;</span><br><span class="line">    l &lt;- readLines(path, encoding=encoding)</span><br><span class="line">    eval(parse(text=l),envir=.GlobalEnv)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">source</span>(path)</span><br></pre></td></tr></table></figure>
<p>envir = 環境<br>.GlobalEnv = 全域環境</p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://stackoverflow.com/questions/5031630/how-to-source-r-file-saved-using-utf-8-encoding" target="_blank" rel="noopener">How to source() .R file saved using UTF-8 encoding?</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>程式語言的世界博大精神，要是沒有他們的付出我能走上現在的路嗎?<br>肯定是沒辦法的，於是我也需要更努力地去為社會付出。</p>
]]></content>
      <categories>
        <category>R語言</category>
      </categories>
      <tags>
        <tag>R語言</tag>
        <tag>學習筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>QUESTION! data.frame 如何 append 新 row，有沒有比較快的方法?</title>
    <url>/2020/08/12/R/R-data-frame-append-data/</url>
    <content><![CDATA[<h2 id="內容說明"><a href="#內容說明" class="headerlink" title="內容說明"></a>內容說明</h2><blockquote>
<p>寫程式的時候是不可能沒遇到 bug 的，bug 紀錄整理</p>
</blockquote>
<a id="more"></a>

<h2 id="QUESTION-data-frame-要-append-新-data-太麻煩，有沒有比較快的方法"><a href="#QUESTION-data-frame-要-append-新-data-太麻煩，有沒有比較快的方法" class="headerlink" title="QUESTION: data.frame 要 append 新 data 太麻煩，有沒有比較快的方法?"></a>QUESTION: data.frame 要 append 新 data 太麻煩，有沒有比較快的方法?</h2><h3 id="answer"><a href="#answer" class="headerlink" title="answer:"></a>answer:</h3><p>那肯定是有的，使用 tribble library，就可以搞定，使用方法與 dataframe 相同</p>
<p>如果沒有 tibble，那我們可以安裝 <code>install.packages(tibble)</code></p>
<p>但 tibble 支持產生無資料的 dataframe，但必須給予欄位的型態，如：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">t &lt;- tibble(x=character() , y=numeric())</span><br></pre></td></tr></table></figure>

<h3 id="之後每一次要-append-row-則使用此語法"><a href="#之後每一次要-append-row-則使用此語法" class="headerlink" title="之後每一次要 append row 則使用此語法"></a>之後每一次要 append row 則使用此語法</h3><figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="keyword">library</span>(tibble)</span><br><span class="line"><span class="keyword">library</span>(magrittr)</span><br><span class="line"></span><br><span class="line">t &lt;- t %&gt;% add_row(x=<span class="string">"a"</span> , y = <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p><strong><font color="#dd0000">必須特別注意: 他要求型態，於是你每次 add 的資料型態都絕對必須要對，可以從這裡進行檢查</font></strong></p>
<p>輸出結果如下：　</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># A tibble: 1 x 2</span><br><span class="line">  x         y</span><br><span class="line">  &lt;chr&gt; &lt;dbl&gt;</span><br><span class="line">1 a         1</span><br></pre></td></tr></table></figure>

<h4 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h4><p><a href="https://stackoverflow.com/questions/31458244/how-to-create-and-add-new-columns-to-a-dataframe-in-r-within-a-loop" target="_blank" rel="noopener">How to create and add new columns to a dataframe in R within a loop? by stackoverflow</a><br><a href="https://stackoverflow.com/questions/48833807/initialize-an-empty-tibble-with-column-names-and-0-rows" target="_blank" rel="noopener">Initialize an empty tibble with column names and 0 rows</a><br><a href="https://github.com/tidyverse/tibble/issues/215" target="_blank" rel="noopener">Allow tribble to create empty tibble with defined column type</a><br><a href="https://tibble.tidyverse.org/reference/add_row.html" target="_blank" rel="noopener">Add rows to a data frame</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>程式語言的世界博大精神，要是沒有他們的付出我能走上現在的路嗎?<br>肯定是沒辦法的，於是我也需要更努力地去為社會付出。</p>
]]></content>
      <categories>
        <category>R語言</category>
      </categories>
      <tags>
        <tag>R語言</tag>
        <tag>學習筆記</tag>
        <tag>R dataframe</tag>
      </tags>
  </entry>
  <entry>
    <title>透過 httr 來使用 API 完成在 R 上的應用</title>
    <url>/2020/08/13/R/R-httr/</url>
    <content><![CDATA[<h2 id="內容說明"><a href="#內容說明" class="headerlink" title="內容說明"></a>內容說明</h2><blockquote>
<p>透過 httr 來方便 R 的使用者 post , get …。<br>以下紀錄 httr 在 R 上的應用與</p>
</blockquote>
<a id="more"></a>

<h2 id="安裝-httr"><a href="#安裝-httr" class="headerlink" title="安裝 httr"></a>安裝 httr</h2><p>當然需要安裝 httr 呀</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">install.packages(<span class="string">"httr"</span>)</span><br></pre></td></tr></table></figure>

<h2 id="教學範例"><a href="#教學範例" class="headerlink" title="教學範例"></a>教學範例</h2><p>我會記錄關於我所有用到的相關語法，會不斷進行補充</p>
<h3 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h3><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">object &lt;- POST(url , body=list(data) , timeout(seconds) , encode = c(<span class="string">"multipart"</span>,<span class="string">"text"</span> , <span class="string">"json"</span>),  accept_json())</span><br></pre></td></tr></table></figure>
<p><strong>url</strong> = 網址<br><strong>body</strong> 則放入你需要傳送給他的資料，EX: 密碼…<br><strong>timeout()</strong> 最多等待幾秒後就退出<br>程式範例如下 <code>body = list(a=1 , b=2 , c=3)</code><br><strong>encode</strong> 編碼有分</p>
<ol>
<li>multipart 多重</li>
<li>text 文字</li>
<li>json </li>
</ol>
<h3 id="傳進來的資料竟然只是資料介紹"><a href="#傳進來的資料竟然只是資料介紹" class="headerlink" title="傳進來的資料竟然只是資料介紹!"></a>傳進來的資料竟然只是資料介紹!</h3><p>傳進來的資料其實都還並不算是資料，應該算是「資料介紹」，需要再加 </p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">content(object)</span><br></pre></td></tr></table></figure>
<p>就可以了。</p>
<h3 id="將傳進來的資料轉換成-json"><a href="#將傳進來的資料轉換成-json" class="headerlink" title="將傳進來的資料轉換成 json"></a>將傳進來的資料轉換成 json</h3><p>則需要些比較麻煩的方式，然後注意 <strong>encoding</strong> 必須正確。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="keyword">library</span>(jsonlite)</span><br><span class="line">data_json &lt;- jsonlite::fromJSON(content(data , type=<span class="string">"text"</span> , encoding=<span class="string">"UTF8"</span>))</span><br></pre></td></tr></table></figure>

<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://community.rstudio.com/t/get-timeout-error-httr-package-error-in-curl/21349" target="_blank" rel="noopener">GET Timeout Error - httr package - Error in Curl</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>httr 真的很好用，他是我在學 R 過程中最容易上手的 ಥ⌣ಥ。能夠將難的東西變成簡單，我真的敬佩那些人的能力。比起 igraph 真的好用太多..，不過應該是我不會用拉，我沒慧根。</p>
]]></content>
      <categories>
        <category>R語言</category>
      </categories>
      <tags>
        <tag>R語言</tag>
        <tag>學習筆記</tag>
        <tag>RESTAPI</tag>
      </tags>
  </entry>
  <entry>
    <title>ERROR! A 物件無法轉成 B 物件</title>
    <url>/2020/08/12/R/R-objectA-convert-to-objectB/</url>
    <content><![CDATA[<h2 id="內容說明"><a href="#內容說明" class="headerlink" title="內容說明"></a>內容說明</h2><blockquote>
<p>寫程式的時候是不可能沒遇到 bug 的，bug 紀錄整理</p>
</blockquote>
<a id="more"></a>

<h2 id="ERROR-A-物件無法轉成-B-物件"><a href="#ERROR-A-物件無法轉成-B-物件" class="headerlink" title="ERROR: A 物件無法轉成 B 物件"></a>ERROR: A 物件無法轉成 B 物件</h2><h3 id="solution-1"><a href="#solution-1" class="headerlink" title="solution 1:"></a>solution 1:</h3><p>上網查找其他替代語法或套件進行解決。</p>
<h3 id="solution-2"><a href="#solution-2" class="headerlink" title="solution 2:"></a>solution 2:</h3><p>也許有可能是你其他套件與此語法一樣，但並不支持 A 物件轉成 B 物件，嘗試考慮在前面加上 namespace，EX: 套件::語法()</p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>程式語言的世界博大精神，要是沒有他們的付出我能走上現在的路嗎?<br>肯定是沒辦法的，於是我也需要更努力地去為社會付出。</p>
]]></content>
      <categories>
        <category>R語言</category>
      </categories>
      <tags>
        <tag>R語言</tag>
        <tag>學習筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux R 在 install packages 遇到的問題集</title>
    <url>/2020/07/24/R/R-server-install-package/</url>
    <content><![CDATA[<h2 id="內容說明"><a href="#內容說明" class="headerlink" title="內容說明"></a>內容說明</h2><blockquote>
<p>以 <strong>CentOS 6</strong> 為例，在這會遇到非常多關於 R server 要安裝套件時遇到的問題，在這邊進行記錄。</p>
</blockquote>
<a id="more"></a>

<h2 id="Warning-關於-Install-Packages-的萬用解"><a href="#Warning-關於-Install-Packages-的萬用解" class="headerlink" title="Warning: 關於 Install Packages 的萬用解"></a>Warning: 關於 Install Packages 的萬用解</h2><p>可先嘗試用此方法，假如不行再根據下面錯誤改變</p>
<h3 id="solution-1"><a href="#solution-1" class="headerlink" title="solution 1"></a>solution 1</h3><p>嘗試用此方法</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">install.packages(<span class="string">"packages"</span>, dependencies = <span class="literal">TRUE</span>)</span><br></pre></td></tr></table></figure>
<h3 id="連結"><a href="#連結" class="headerlink" title="連結"></a>連結</h3><p><a href="https://stackoverflow.com/questions/20923209/problems-installing-the-devtools-package" target="_blank" rel="noopener">Problems installing the devtools package</a></p>
<h2 id="Warning-unable-to-access-index-for-repository-https-cran-csie-ntu-edu-tw-src-contrib"><a href="#Warning-unable-to-access-index-for-repository-https-cran-csie-ntu-edu-tw-src-contrib" class="headerlink" title="Warning: unable to access index for repository https://cran.csie.ntu.edu.tw/src/contrib"></a>Warning: unable to access index for repository <a href="https://cran.csie.ntu.edu.tw/src/contrib" target="_blank" rel="noopener">https://cran.csie.ntu.edu.tw/src/contrib</a></h2><h3 id="solution-1-1"><a href="#solution-1-1" class="headerlink" title="solution 1:"></a>solution 1:</h3><p>嘗試看看至 chooseCRANmirror() 然後再使用 http ， <strong><font color="#dd0000">注意，並不是 https</font></strong></p>
<h4 id="連結-1"><a href="#連結-1" class="headerlink" title="連結"></a>連結</h4><h2 id="Warning-message-package-‘magrittr’-is-not-available-for-R-version-3-2-0"><a href="#Warning-message-package-‘magrittr’-is-not-available-for-R-version-3-2-0" class="headerlink" title="Warning message: package ‘magrittr’ is not available (for R version 3.2.0)"></a>Warning message: package ‘magrittr’ is not available (for R version 3.2.0)</h2><h3 id="solution-1-2"><a href="#solution-1-2" class="headerlink" title="solution 1:"></a>solution 1:</h3><p>透過 Bioconductor ，嘗試並下載或更新套件包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source(&quot;http:&#x2F;&#x2F;bioconductor.org&#x2F;biocLite.R&quot;)</span><br><span class="line">biocLite(&quot;包名&quot;)</span><br></pre></td></tr></table></figure>
<h4 id="連結-2"><a href="#連結-2" class="headerlink" title="連結"></a>連結</h4><p><a href="https://blog.csdn.net/yepeng2007fei/article/details/78112557" target="_blank" rel="noopener">R语言 关于package’***’ is not available(for R version 3.4.1)</a></p>
<h2 id="Warning"><a href="#Warning" class="headerlink" title="Warning"></a>Warning</h2>]]></content>
      <categories>
        <category>R語言</category>
      </categories>
      <tags>
        <tag>R語言</tag>
        <tag>學習筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 shinyapps 建立網站</title>
    <url>/2020/07/28/R/R-shinyapps-experence/</url>
    <content><![CDATA[<h2 id="內容說明"><a href="#內容說明" class="headerlink" title="內容說明"></a>內容說明</h2><blockquote>
<p>shinyapps 也是一個說坑不坑，建立起來速度很快，但是又有很多小細節要處理。<br>以下紀錄 shinyapps 怎麼建立網站與<strong><font color="#dd0000">需要注意的地方</font></strong></p>
</blockquote>
<a id="more"></a>

<h2 id="前置作業"><a href="#前置作業" class="headerlink" title="前置作業"></a>前置作業</h2><ul>
<li>需要有 R </li>
<li>需要註冊 shinyapps 這<a href="https://ithelp.ithome.com.tw/articles/10197292" target="_blank" rel="noopener">網站</a>教學不錯，建議點擊</li>
<li>you need server.R and ui.R </li>
</ul>
<h2 id="安裝教學"><a href="#安裝教學" class="headerlink" title="安裝教學"></a>安裝教學</h2><ol>
<li><p>首先需要安裝 rsconnect</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">install.packages(&quot;rsconnect&quot;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>點擊<a href="https://ithelp.ithome.com.tw/articles/10197292" target="_blank" rel="noopener">網站</a>查看關於 shinyapps 的教學</p>
</li>
<li><p>執行!<br>很簡單吧，一下子就完成了。這時候直接按 R studio 右上角的 run 即可，如果測試成功後，可直接點擊發布</p>
</li>
<li><p>發布<br><img src="/images/R-shinyapps-experence/1.PNG" alt=""><br>先點擊右上角的紅色圈圈，跳出視窗後點擊 publish，稍等一刻就可以看到結果拉！</p>
</li>
</ol>
<h2 id="錯誤排除"><a href="#錯誤排除" class="headerlink" title="錯誤排除"></a>錯誤排除</h2><h3 id="等等，為甚麼我出來的是一段英文字母不是我的網頁阿"><a href="#等等，為甚麼我出來的是一段英文字母不是我的網頁阿" class="headerlink" title="等等，為甚麼我出來的是一段英文字母不是我的網頁阿"></a>等等，為甚麼我出來的是一段英文字母不是我的網頁阿</h3><p>漂亮，兄弟。你已進入到 shinyapps 深淵中的第一步，還有好多步在等著你喔 QwQ。<br><img src="/images/R-shinyapps-experence/2.PNG" alt=""></p>
<h3 id="所有程式碼都必須要用-utf-8-編碼"><a href="#所有程式碼都必須要用-utf-8-編碼" class="headerlink" title="所有程式碼都必須要用 utf-8 編碼"></a>所有程式碼都必須要用 utf-8 編碼</h3><p>只要是需要上傳至 shinyapps 的都必須需要使用 utf-8 編碼，否則無法上傳成功。並在 source 屬性內加入 local=TRUE</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="keyword">source</span>(path , local=<span class="literal">TRUE</span>)</span><br></pre></td></tr></table></figure>

<h3 id="有用到其他檔案，但是無法推送給-server-成功"><a href="#有用到其他檔案，但是無法推送給-server-成功" class="headerlink" title="有用到其他檔案，但是無法推送給 server 成功"></a>有用到其他檔案，但是無法推送給 server 成功</h3><p>這就需要特別注意了，這邊我也是花了約 1 小時才找出問題，如果你需要用到其他檔案<strong>一定要在 server.R and ui.R 的目錄層下</strong>，不然他沒辦法跑動。<br>P.S. 我猜測她是會直接把 server.R and ui.R 裡面的資料全部推送給 shinyapps。</p>
<h3 id="如果你真的很需要很需要用到中文，那怎麼辦"><a href="#如果你真的很需要很需要用到中文，那怎麼辦" class="headerlink" title="如果你真的很需要很需要用到中文，那怎麼辦?"></a>如果你真的很需要很需要用到中文，那怎麼辦?</h3><p>目前根據我的嘗試，你只要能夠將中文放在 server.R 或是 其他 source，是可以成功出現中文字體。其他方式我還沒嘗試需要各位的努力拉!</p>
<h4 id="連結說明"><a href="#連結說明" class="headerlink" title="連結說明"></a>連結說明</h4><p><a href="https://dotblogs.com.tw/Im_sqz777/2017/07/26/220713" target="_blank" rel="noopener">Web 基本觀念 - 相對路徑 和 絕對路徑</a><br><a href="https://support.rstudio.com/hc/en-us/articles/229848967-Why-does-my-app-work-locally-but-not-on-shinyapps-io-" target="_blank" rel="noopener">為什麼我的應用程序可以在本地運行，而不能在Shinyapps.io上運行？</a></p>
<h3 id="程式若有提到路徑則全必須使用相對路徑"><a href="#程式若有提到路徑則全必須使用相對路徑" class="headerlink" title="程式若有提到路徑則全必須使用相對路徑"></a>程式若有提到路徑則全必須使用相對路徑</h3><p>如果你是使用絕對路徑，非常高的機率會出錯，可以去 shinyapps 的 log 檔查看，應該會出現</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Warning: Error in file: 無法開啟連結</span><br></pre></td></tr></table></figure>
<p>這裡使用相對路徑則沒有問題</p>
<h3 id="如果有從外部加入檔案，但檔案編碼並非是-utf-8-則需要特別注意"><a href="#如果有從外部加入檔案，但檔案編碼並非是-utf-8-則需要特別注意" class="headerlink" title="如果有從外部加入檔案，但檔案編碼並非是 utf-8 則需要特別注意"></a>如果有從外部加入檔案，但檔案編碼並非是 utf-8 則需要特別注意</h3><p>我這次的經驗為 csv 編碼是用 big5，所以當我程式碼都有使用 utf-8 編碼時，他還是跟我說這裡出現問題，在我花了許多時間去除錯後，根據其他大佬得出如果外部檔案並非使用 utf-8，必須先在將檔案讀入程式時增加 fileEncoding = “編碼代號”，即可完成。</p>
<h4 id="連結說明-1"><a href="#連結說明-1" class="headerlink" title="連結說明"></a>連結說明</h4><p><a href="https://www.ptt.cc/bbs/R_Language/M.1421390552.A.D5C.html" target="_blank" rel="noopener">讀取csv檔的小問題</a><br><a href="https://stackoverflow.com/questions/14363085/invalid-multibyte-string-in-read-csv" target="_blank" rel="noopener">Invalid multibyte string in read.csv</a></p>
<h2 id="我覺得這應該會很有用，但是我現在還用不到"><a href="#我覺得這應該會很有用，但是我現在還用不到" class="headerlink" title="我覺得這應該會很有用，但是我現在還用不到"></a>我覺得這應該會很有用，但是我現在還用不到</h2><p>由於我在翻找資料的過程中，找到一篇文章。感覺會對未來有幫助，所以先留下來<br><a href="https://d.cosx.org/d/412685-shinyapps" target="_blank" rel="noopener">[已解决] shinyapps 的中文显示问题</a></p>
<h2 id="R-shiny-一些小技巧"><a href="#R-shiny-一些小技巧" class="headerlink" title="R shiny 一些小技巧"></a>R shiny 一些小技巧</h2><p>可以的話，盡量不要將資料寫在 mainpanel，寫在 tabPanel，可以少掉一些使用者如果來回點擊網頁時，先前網頁的畫面內容殘留。</p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>其實要很感謝寫 shiny 套件，還讓我們免費發佈在 shinyapps 的強大團隊，才有辦法讓我僅僅只使用 R，就可以讓我獨自一人建立網站，雖然有很多坑、很多雷點，但是其實只要修復好了，我對於雷點甚麼的就沒那麼怨恨XD，雖然當下還是會不開心拉，但是現在的我因為有 shiny 幫助我，反而更開心！也謝謝北市大教授 <strong>魏惠貞</strong> 給我機會讓我學習到，真的很謝謝老師。</p>
<h2 id="更新日誌"><a href="#更新日誌" class="headerlink" title="更新日誌"></a>更新日誌</h2><p>2020-07-20 14:45:16 - 建立文章<br>2020-07-28 20:42:25 - 增加錯誤排除</p>
<ol>
<li>有用到其他檔案，但是無法推送給 server 成功</li>
<li>如果你真的很需要很需要用到中文，那怎麼辦?</li>
<li>所有程式碼都必須要用 utf-8 編碼</li>
</ol>
]]></content>
      <categories>
        <category>R語言</category>
      </categories>
      <tags>
        <tag>R語言</tag>
        <tag>學習筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>R-teach</title>
    <url>/2020/05/01/R/R-teach/</url>
    <content><![CDATA[<h2 id="主要"><a href="#主要" class="headerlink" title="主要"></a>主要</h2><p>此網頁主要是在幫助大衛在 北市大幼保系研究助理期間中所遇到的 R 語言問題。</p>
<p>並非教學用，但學習資源會在這並透過我加以整理。</p>
<ol>
<li><a href="https://cran.r-project.org/bin/windows/base/" target="_blank" rel="noopener">R download</a></li>
<li><a href="https://rstudio.com/products/rstudio/download/" target="_blank" rel="noopener">Rstudio download</a></li>
<li><a href="https://joe11051105.gitbooks.io/r_basic/content/environment_settings/RStudio_introduction.html" target="_blank" rel="noopener">Rstudio introduction</a></li>
<li><a href="https://cosx.org/2009/07/studying-notes-on-oop-in-r/" target="_blank" rel="noopener">R_oop</a></li>
<li><a href="https://blog.gtwang.org/r/r-vectors-matrices-and-arrays/" target="_blank" rel="noopener">R_vector</a></li>
<li><a href="https://ithelp.ithome.com.tw/articles/10197004" target="_blank" rel="noopener">使用 R 與 C# 開發網站</a></li>
<li><a href="https://molecular-service-science.com/2015/08/01/r-shiny-business-intelligence-tutorial/" target="_blank" rel="noopener">R shiny 套件可運用在網頁上</a></li>
<li><a href="https://shiny.rstudio.com/reference/shiny/latest/" target="_blank" rel="noopener">shiny 語法大全</a></li>
<li><a href="https://shiny.rstudio.com/gallery/" target="_blank" rel="noopener">shiny 套版</a></li>
<li><a href="https://github.com/daattali/shinyjs/issues/16" target="_blank" rel="noopener">useShinyjs() in navbarPage()</a></li>
<li><a href="https://stackoverflow.com/questions/40621393/disabling-buttons-in-shiny" target="_blank" rel="noopener">Disabling buttons in Shiny</a></li>
<li><a href="https://statistics.berkeley.edu/computing/r-t-tests" target="_blank" rel="noopener">R test 圖表繪製</a></li>
<li><a href="http://yanping.me/shiny-tutorial" target="_blank" rel="noopener">中文教程：用R构建Shiny应用程序</a></li>
</ol>
]]></content>
      <categories>
        <category>R語言</category>
      </categories>
      <tags>
        <tag>R語言</tag>
        <tag>學習筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa10050 - Combination Lock (水題)</title>
    <url>/2020/03/30/UVa/UVa10050/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意:"></a>題目大意:</h2><blockquote>
<p>解保險箱鎖盤，透過他獨家的開鎖方式，試問你需要轉幾度，</p>
<ol>
<li>先轉順時鐘兩圈</li>
<li>順時鐘轉到第 1 個密碼</li>
<li>逆時鐘再轉一圈</li>
<li>逆時鐘轉第二個密碼</li>
<li>順時鐘轉第三個密碼</li>
</ol>
</blockquote>
<a id="more"></a>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析:"></a>分析:</h2><p>在開鎖時，必定要轉 3 圈，所以角度 必定是 360*3。</p>
<font color="#dd0000">
當順時鐘在轉時，但表其實是逆時鐘，我理解了很久才能理解 (作者理解力還需加強)

<p>Ex: 0度 轉至 30度<br>A:  你會覺得 應該是轉了 30度，但不是這樣的。<br>    對於表的指針來說，實際上只轉了 10度。 (酷吧)</p>
<p>逆時鐘則將 0 , 30 互換即可，意思大同小異。<br></font></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">int</span> a, b, c, d ;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d &amp;&amp; (a + b + c + d) != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> calibration = <span class="number">120</span>;</span><br><span class="line">        calibration += (<span class="number">40</span> + a - b ) % <span class="number">40</span> ;</span><br><span class="line">        calibration += (<span class="number">40</span> - b + c ) % <span class="number">40</span> ;</span><br><span class="line">        calibration += (<span class="number">40</span> + c - d ) % <span class="number">40</span> ;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; calibration * <span class="number">9</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>水題</tag>
        <tag>UVa</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa10036 - Divisibility (動態規劃)</title>
    <url>/2020/03/17/UVa/UVa10036/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意:"></a>題目大意:</h2><blockquote>
<p>給你 n 個數字 與 x ，在 n 個數字中加上 - or + ， 判斷組合後的總合是否可以被 x 整除?</p>
</blockquote>
<a id="more"></a>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析:"></a>分析:</h2><p>可能很多人會想排列組合，但會TLE</p>
<p><font color="#dd0000"><strong>但是，想法其實只要在稍微思考一下就能想通了 <del>(除非你太笨)</del></strong></font></p>
<p>每一次在幫數字做 加減法後餘數儲存至二維陣列，狀態轉移即可 (是不是不難阿)</p>
<p>可寫成 DP 遞迴式， Dp[y + 1 , intNum[i] % x  ]= DP[ y , intNum[i] ]</p>
<p>其中 y 為第 n 個數字， intNum 為 數字隊列。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> intMap[<span class="number">10010</span>][<span class="number">110</span>] = &#123;<span class="number">0</span>&#125; ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">non_negative</span><span class="params">(<span class="keyword">int</span> intNum , <span class="keyword">int</span> K , <span class="keyword">int</span> J)</span></span>&#123;</span><br><span class="line">    <span class="comment">//debug</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; intNum &lt;&lt; ' ' ;</span></span><br><span class="line"></span><br><span class="line">    intNum = (intNum + J ) % K ;</span><br><span class="line">    <span class="keyword">while</span>(intNum &lt; <span class="number">0</span>)</span><br><span class="line">        intNum += K ;</span><br><span class="line">    <span class="keyword">return</span> intNum % K ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_map</span><span class="params">(<span class="keyword">int</span> *intMap , <span class="keyword">int</span> N , <span class="keyword">int</span> K)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; N ; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; K ; j++)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; *(intMap + i + j) &lt;&lt; <span class="string">' '</span> ;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> );</span><br><span class="line">    freopen(<span class="string">"out.txt"</span> , <span class="string">"w"</span> , <span class="built_in">stdout</span> );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">int</span> intCase , N , K ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; intCase ;</span><br><span class="line">    <span class="keyword">while</span>(intCase--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; K ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//debug</span></span><br><span class="line">        <span class="comment">//cout &lt;&lt; N &lt;&lt; K ;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> intNum[N] ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**&lt; debug</span></span><br><span class="line"><span class="comment">        for(int i = 0 ; i &lt; N ; i++)&#123;</span></span><br><span class="line"><span class="comment">            for(int j = 0 ; j &lt; K ; j++)</span></span><br><span class="line"><span class="comment">                cout &lt;&lt; intMap[i][j] &lt;&lt; ' ' ;</span></span><br><span class="line"><span class="comment">            cout &lt;&lt; '\n' ;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//debug</span></span><br><span class="line">        <span class="comment">//print_map((int *)intMap , N , K ) ;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; N ; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; K ; j++)</span><br><span class="line">                intMap[i][j] = <span class="number">0</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; N ; i++)</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; intNum[i] ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**&lt;//debug</span></span><br><span class="line"><span class="comment">        for(int i = 0 ; i &lt; N ; i++)</span></span><br><span class="line"><span class="comment">            cout &lt;&lt; intNum[i] &lt;&lt; ' ' ;</span></span><br><span class="line"><span class="comment">        cout &lt;&lt; '\n' ;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        intMap[<span class="number">0</span>][non_negative(intNum[<span class="number">0</span>], K , <span class="number">0</span> )] = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; N ; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; K ; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(intMap[i<span class="number">-1</span>][j])&#123;</span><br><span class="line">                    intMap[i][ non_negative(intNum[i], K , j ) ] = <span class="number">1</span> ;</span><br><span class="line">                    intMap[i][ non_negative(-intNum[i], K , j ) ] = <span class="number">1</span> ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//debug</span></span><br><span class="line">        <span class="comment">//print_map((int *)intMap , N , K ) ;</span></span><br><span class="line">        <span class="comment">//cout &lt;&lt; intMap[N-1][0] &lt;&lt; '\n' ;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(intMap[N<span class="number">-1</span>][<span class="number">0</span>])</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Divisible"</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Not divisible"</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>動態規劃 Dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa10101 - Bangla Numbers (水題)</title>
    <url>/2020/04/09/UVa/UVa10101/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>給一數字，用題目獨家的單位詞做輸出</p>
</blockquote>
<a id="more"></a>

<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>透過遞迴 (recursive)，來幫助 x lakh y kuti。<br>數字要開 long long</p>
<p><del>本人覺得這題我寫得很好，但可能會被其他大神嫌棄</del></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recursive</span><span class="params">(<span class="built_in">string</span> strInt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len , intCout ;</span><br><span class="line">    <span class="comment">// hajar 10000000</span></span><br><span class="line">    len = strInt.length() - <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">if</span>(len &gt; <span class="number">0</span> )&#123;</span><br><span class="line">        recursive(strInt.substr(<span class="number">0</span>,len));</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">" kuti"</span> ;</span><br><span class="line">        strInt = strInt.substr(strInt.length()<span class="number">-7</span> , <span class="number">7</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// lakh 100000</span></span><br><span class="line">    len = strInt.length() - <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">if</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        intCout = stoi(strInt.substr(<span class="number">0</span>,len));</span><br><span class="line">        <span class="keyword">if</span>(intCout)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; intCout &lt;&lt; <span class="string">" lakh"</span>;</span><br><span class="line">        strInt = strInt.substr(strInt.length()<span class="number">-5</span> , <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// hajar 1000</span></span><br><span class="line">    len = strInt.length() - <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        intCout = stoi(strInt.substr(<span class="number">0</span>, len));</span><br><span class="line">        <span class="keyword">if</span>(intCout)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; intCout &lt;&lt; <span class="string">" hajar"</span>;</span><br><span class="line">        strInt = strInt.substr(strInt.length()<span class="number">-3</span> , <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// shata 100</span></span><br><span class="line">    len = strInt.length() - <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        intCout = stoi(strInt.substr(<span class="number">0</span>,len));</span><br><span class="line">        <span class="keyword">if</span>(intCout)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; intCout &lt;&lt; <span class="string">" shata"</span>;</span><br><span class="line">        strInt = strInt.substr(strInt.length()<span class="number">-2</span> , <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(stoi(strInt))</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; stoi(strInt) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"out.txt"</span> , <span class="string">"w"</span> , <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="built_in">string</span> strInt;</span><br><span class="line">    <span class="keyword">int</span> intCase=<span class="number">1</span> , len , intTemp;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; strInt)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">4</span>- to_string(intCase).length() ; i++ )</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> ;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; intCase++ &lt;&lt; <span class="string">"."</span> ;</span><br><span class="line">        recursive(strInt);</span><br><span class="line">        <span class="keyword">if</span>(strInt == <span class="string">"0"</span>)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">" 0"</span> ;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>水題</tag>
        <tag>UVa</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa10010 - Where&#39;s Waldorf? (動態規劃)</title>
    <url>/2020/03/16/UVa/UVa10010/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意:"></a>題目大意:</h2><blockquote>
<p>給你一張圖，再給你x個單字，這些單字必定會在圖中出現，請輸入單字的第一個字母再圖中的哪個位置? ( 如果有重複的，輸出最左上的 )</p>
</blockquote>
<a id="more"></a>


<h2 id="分析"><a href="#分析" class="headerlink" title="分析:"></a>分析:</h2><p><font color = "dd0000">  <del>麻煩的</del> DFS </font></p>
<p>逐行檢查每一個字元，與8個方向，邏輯夠好，就能很快解出</p>
<p>Hint: 但第一個字元確定好方向，之後就必須依照這個方向檢查</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> arrGraph[<span class="number">52</span>][<span class="number">52</span>] = &#123;&#125; ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//debug</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_map</span><span class="params">(<span class="keyword">int</span> n , <span class="keyword">int</span> m )</span></span>&#123;</span><br><span class="line">    <span class="comment">//debug print map</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; i++ )&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= m ; j++)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; arrGraph[i][j] ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">intact_letter</span><span class="params">(<span class="built_in">string</span> strLine , <span class="keyword">int</span> intLine_Index , <span class="keyword">int</span> intDirection , <span class="keyword">int</span> n , <span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(strLine.length()<span class="number">-1</span> == intLine_Index )&#123;</span><br><span class="line">        <span class="comment">//debug</span></span><br><span class="line">        <span class="comment">//cout &lt;&lt; strLine &lt;&lt; intLine_Index &lt;&lt; '\n' ;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( intDirection == <span class="number">1</span>  &amp;&amp; arrGraph[n<span class="number">-1</span>][m<span class="number">-1</span>] == strLine[intLine_Index +<span class="number">1</span> ])</span><br><span class="line">        <span class="keyword">return</span> intact_letter(strLine , intLine_Index +<span class="number">1</span> , <span class="number">1</span> , n<span class="number">-1</span>,m<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( intDirection == <span class="number">2</span>  &amp;&amp; arrGraph[n<span class="number">-1</span>][m] == strLine[intLine_Index +<span class="number">1</span> ])</span><br><span class="line">        <span class="keyword">return</span> intact_letter(strLine , intLine_Index +<span class="number">1</span> , <span class="number">2</span> , n<span class="number">-1</span>,m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( intDirection == <span class="number">3</span>  &amp;&amp; arrGraph[n<span class="number">-1</span>][m+<span class="number">1</span>] == strLine[intLine_Index +<span class="number">1</span> ])</span><br><span class="line">        <span class="keyword">return</span> intact_letter(strLine , intLine_Index +<span class="number">1</span> , <span class="number">3</span> , n<span class="number">-1</span>,m+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( intDirection == <span class="number">4</span> &amp;&amp; arrGraph[n][m<span class="number">-1</span>] == strLine[intLine_Index +<span class="number">1</span> ])</span><br><span class="line">        <span class="keyword">return</span> intact_letter(strLine , intLine_Index +<span class="number">1</span> , <span class="number">4</span> , n,m<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( intDirection == <span class="number">5</span>  &amp;&amp; arrGraph[n+<span class="number">1</span>][m<span class="number">-1</span>] == strLine[intLine_Index +<span class="number">1</span> ])</span><br><span class="line">        <span class="keyword">return</span> intact_letter(strLine , intLine_Index +<span class="number">1</span> , <span class="number">5</span> , n+<span class="number">1</span>,m<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( intDirection == <span class="number">6</span>  &amp;&amp; arrGraph[n+<span class="number">1</span>][m] == strLine[intLine_Index +<span class="number">1</span> ])</span><br><span class="line">        <span class="keyword">return</span> intact_letter(strLine , intLine_Index +<span class="number">1</span> , <span class="number">6</span> , n+<span class="number">1</span>,m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( intDirection == <span class="number">7</span>  &amp;&amp; arrGraph[n+<span class="number">1</span>][m+<span class="number">1</span>] == strLine[intLine_Index +<span class="number">1</span> ])</span><br><span class="line">        <span class="keyword">return</span> intact_letter(strLine , intLine_Index +<span class="number">1</span> , <span class="number">7</span> , n+<span class="number">1</span>,m+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( intDirection == <span class="number">8</span>  &amp;&amp; arrGraph[n][m+<span class="number">1</span>] == strLine[intLine_Index +<span class="number">1</span> ])</span><br><span class="line">        <span class="keyword">return</span> intact_letter(strLine , intLine_Index +<span class="number">1</span> , <span class="number">8</span> , n,m+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search_letter</span><span class="params">( <span class="built_in">string</span> strLine , <span class="keyword">int</span> n , <span class="keyword">int</span> m )</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; i++ )&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= m ; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arrGraph[i][j] == strLine[<span class="number">0</span>] )&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span> ; k &lt; <span class="number">9</span> ; k++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(intact_letter(strLine , <span class="number">0</span> , k , i , j))&#123;</span><br><span class="line">                        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">' '</span> &lt;&lt; j &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">                        <span class="keyword">return</span> ;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>,<span class="string">"r"</span> , <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">int</span> indicating , n , m , k , isInit= <span class="number">0</span> ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; indicating ;</span><br><span class="line">    <span class="built_in">string</span> strLine ;</span><br><span class="line">    <span class="keyword">while</span>(indicating--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(isInit)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">        isInit = <span class="number">1</span> ;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; strLine ;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= m ; j++)&#123;</span><br><span class="line">                arrGraph[i][j] = <span class="built_in">tolower</span>(strLine[j<span class="number">-1</span>]) ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//debug</span></span><br><span class="line">        <span class="comment">//print_map(n,m);</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; k ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; k ; i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; strLine ;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; k ; i++)</span><br><span class="line">                strLine[i] = <span class="built_in">tolower</span>(strLine[i]);</span><br><span class="line">            search_letter(strLine , n , m);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>圖論</tag>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>String Processing Problems</tag>
        <tag>Competitive Programming3</tag>
        <tag>動態規劃 Dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa10221 - Satellites (數論 Math theorm)</title>
    <url>/2020/03/17/UVa/UVa10221/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意:"></a>題目大意:</h2><blockquote>
<p>如圖，給你圓上兩點夾角，和點圓心的距離<br>求出兩點的弧長與弦長。</p>
</blockquote>
<a id="more"></a>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析:"></a>分析:</h2><p><font color = "#dd0000" >分水嶺，看出來你先學會數學在學會程式 還是 先學會程式在學會數學(我是後者 QQ ) </font></p>
<p>對於本人來說是，非常難的一題阿！！！！ (我真笨，想不到數學弦長，餘弦定理)</p>
<p>如果你也不知道餘弦定理，沒關係可以的，我幫你找到傳送門了 &rarr; <a href="https://zh.wikipedia.org/wiki/%E9%A4%98%E5%BC%A6%E5%AE%9A%E7%90%86" target="_blank" rel="noopener">餘弦定理</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> minutes = minute of angle not time minutes</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span>) ;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="built_in">string</span> strA ;</span><br><span class="line">    <span class="keyword">double</span> a , s , douArc , douChord ;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; s &gt;&gt; a &gt;&gt; strA )&#123;</span><br><span class="line">        <span class="keyword">if</span>(strA == <span class="string">"min"</span>)</span><br><span class="line">            a /= <span class="number">60</span> ;</span><br><span class="line">        s += <span class="number">6440</span> ;</span><br><span class="line">        <span class="keyword">if</span>(a &gt; <span class="number">180</span>)</span><br><span class="line">            a = <span class="number">360</span> - a ;</span><br><span class="line">        douArc = <span class="number">2</span> * s * <span class="number">2</span> * <span class="built_in">acos</span>(<span class="number">0</span>) * a / <span class="number">360</span> ;</span><br><span class="line">        douChord = <span class="built_in">sqrt</span>(s * s + s * s - <span class="number">2</span> * s * s * <span class="built_in">cos</span>(<span class="number">2</span>*<span class="built_in">acos</span>(<span class="number">0</span>) * a / <span class="number">180</span> ) ) ;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; fixed &lt;&lt; setprecision(<span class="number">6</span>) &lt;&lt; douArc &lt;&lt; <span class="string">' '</span> &lt;&lt; douChord &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>水題</tag>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>數論 Math theorm</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa10530 - Guessing Game (水題)</title>
    <url>/2020/03/17/UVa/UVa10530/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意:"></a>題目大意:</h2><blockquote>
<p><strong>玩猜數字</strong></p>
<p><font color = "#dd0000" > *<em>是得你沒看錯，這應該是我看過 UVa 最簡單的題目了 *</em> </font></p>
<p>不過要注意的是:<br>還要看這個小屁孩，要不要說謊www</p>
</blockquote>
<a id="more"></a> 

<h2 id="分析"><a href="#分析" class="headerlink" title="分析:"></a>分析:</h2><p>不斷更新上下界，如果她說謊了，就告訴他，他是 <font color="#dd0000">Lier </font></p>
<p>需要注意的是: 當我說 8 too high 的話， 8 也算是太高喔</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> ) ;</span><br><span class="line">    freopen(<span class="string">"out.txt"</span> , <span class="string">"w"</span> , <span class="built_in">stdout</span> );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">int</span> intMax= <span class="number">11</span> , intMin = <span class="number">0</span> , isRight = <span class="number">1</span> , n ;</span><br><span class="line">    <span class="built_in">string</span> strLine ;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d\n"</span> , &amp;n ) &amp;&amp; n )&#123;</span><br><span class="line">        getline(<span class="built_in">cin</span> , strLine ) ;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (strLine == <span class="string">"right on"</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(intMax &lt;= n || intMin &gt;= n)</span><br><span class="line">                isRight = <span class="number">0</span> ;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(isRight)</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"Stan may be honest"</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"Stan is dishonest"</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//debug</span></span><br><span class="line">            <span class="comment">//cout &lt;&lt; intMax &lt;&lt; ' ' &lt;&lt; intMin &lt;&lt; ' ' &lt;&lt; n &lt;&lt; '\n' ;</span></span><br><span class="line"></span><br><span class="line">            isRight = <span class="number">1</span> ;</span><br><span class="line">            intMax = <span class="number">11</span> ;</span><br><span class="line">            intMin = <span class="number">0</span> ;</span><br><span class="line">            <span class="keyword">continue</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(strLine == <span class="string">"too high"</span> &amp;&amp; intMax &gt; n )&#123;</span><br><span class="line">            intMax = n ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (strLine == <span class="string">"too low"</span> &amp;&amp; intMin &lt; n )&#123;</span><br><span class="line">            intMin = n ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>水題</tag>
        <tag>UVa</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa1056 - Degrees of Separation (Floyd)</title>
    <url>/2020/03/12/UVa/UVa1056/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意:"></a>題目大意:</h2><blockquote>
<p>有一個大型的人類組織社會，詢問人與人的最大距離為何? 如果沒有的話，輸出 “DISCONNECTED”。</p>
</blockquote>
<a id="more"></a> 

<h2 id="分析"><a href="#分析" class="headerlink" title="分析:"></a>分析:</h2><p><font color = "#dd0000"> 人名需要雜湊喔 ε٩(๑&gt; ₃ &lt;)۶з </font></p>
<p>由於是 All-Pairs Shortest Path 問題，所以這題使用 Floyd-Warshall algorithm 解題</p>
<p>甚麼!? 你不知道 Floyd! <a href="https://zh.wikipedia.org/wiki/Floyd-Warshall%E7%AE%97%E6%B3%95" target="_blank" rel="noopener"><del>那你先去看影片</del></a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 99999999</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span> , <span class="keyword">int</span>&gt; mapMember ;</span><br><span class="line"><span class="keyword">int</span> intPath[<span class="number">55</span>][<span class="number">55</span>] ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> );</span><br><span class="line">    freopen(<span class="string">"out.txt"</span> , <span class="string">"w"</span> , <span class="built_in">stdout</span> );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">int</span> P , R , intCase = <span class="number">1</span> , intHash ;</span><br><span class="line">    <span class="built_in">string</span> strNameA , strNameB ;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; P &gt;&gt; R)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!(P + R))</span><br><span class="line">            <span class="keyword">break</span> ;</span><br><span class="line">        mapMember.clear() ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= P ; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= P ; j++)</span><br><span class="line">                intPath[i][j] = INF ;</span><br><span class="line">        &#125;</span><br><span class="line">        intHash = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; R ; i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; strNameA &gt;&gt; strNameB ;</span><br><span class="line">            <span class="keyword">if</span>(!mapMember[strNameA])</span><br><span class="line">                mapMember[strNameA] = intHash++ ;</span><br><span class="line">            <span class="keyword">if</span>(!mapMember[strNameB])</span><br><span class="line">                mapMember[strNameB] = intHash++ ;</span><br><span class="line">            intPath[ mapMember[strNameA] ][ mapMember[strNameB] ] = <span class="number">1</span> ;</span><br><span class="line">            intPath[ mapMember[strNameA] ][ mapMember[strNameA] ] = <span class="number">0</span> ;</span><br><span class="line">            intPath[ mapMember[strNameB] ][ mapMember[strNameA] ] = <span class="number">1</span> ;</span><br><span class="line">            intPath[ mapMember[strNameB] ][ mapMember[strNameB] ] = <span class="number">0</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//floyd</span></span><br><span class="line">        <span class="keyword">int</span> intMax = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= P ; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j  = <span class="number">1</span> ; j &lt;= P ; j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span> ; k &lt;= P ; k++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(intPath[j][k] &gt; intPath[j][i] + intPath[i][k])&#123;</span><br><span class="line">                        intPath[j][k] = intPath[j][i] + intPath[i][k] ;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= P ; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= P ; j++)&#123;</span><br><span class="line">                intMax = max(intPath[i][j] , intMax);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(intMax == INF)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Network "</span> &lt;&lt; intCase++ &lt;&lt; <span class="string">": "</span> &lt;&lt; <span class="string">"DISCONNECTED"</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Network "</span> &lt;&lt; intCase++ &lt;&lt; <span class="string">": "</span> &lt;&lt; intMax &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>Floyd-Warshall algorithm</tag>
        <tag>UVa</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa10603 - Fill (Dijkstra)</title>
    <url>/2020/03/17/UVa/UVa10603/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意:"></a>題目大意:</h2><blockquote>
<p>有 3 個杯子， a , b , c ，以及目標水量 d ， 一開始只有 c 裝滿了水，其他為空，透過倒入杯子&gt;的方式，來讓其他的杯子加滿水，試問能否達到 d ，要是不行，給出最接近數。</p>
<p>輸出要求：輸出最符合 d 的水量與達到 d 的最小倒水量。</p>
</blockquote>
<a id="more"></a>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析:"></a>分析:</h2><p>膜拜 劉汝佳 大佬，邏輯分析師</p>
<img src="https://pic1.xuehuaimg.com/proxy/csdn/https://img-blog.csdn.net/20170804143214141?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzQ4NDUwODI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="UVa10603.jpg">

<p><font color= "#dd0000"> <del>要是你還是看不懂，我建議你跳過，這對現在的你太難了</del> </font></p>
<p>沒有拉，開玩笑地。 不過這題確實有點小難。</p>
<p>不過老實說，包裝得很好，這題由 Dijkstra’s 可以得出，不過要記得的是， Dijkstra’s 的缺點就是，容易造成效率的低落，權重很重要。 </p>
<p>所以善用 priority_queue ， priority_queue 寫得好，程式沒煩惱！</p>
<h3 id="備註"><a href="#備註" class="headerlink" title="備註:"></a>備註:</h3><p>這裡有兩個蠻推薦的網站，寫得不錯，有些我這裡沒有補充倒的，可以查看這裡的網頁</p>
<p><a href="https://theriseofdavid.github.io/2020/03/11/UVa929/" target="_blank" rel="noopener">大衛的筆記-UVa929 - Number Maze (圖論，Dijkstra’s，優先隊列)</a></p>
<p><a href="https://www.twblogs.net/a/5b87da1e2b71775d1cd945e5" target="_blank" rel="noopener">UVA 10603 Fill(狀態空間搜索，倒水問題)</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 220</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> visit[MAXN][MAXN] , ans[MAXN] , cap[<span class="number">5</span>] , d ;</span><br><span class="line"><span class="comment">// https://www.twblogs.net/a/5b87da1e2b71775d1cd945e5</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">status</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> jug[<span class="number">3</span>] , vol ;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> status&amp; rhs ) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> vol &gt; rhs.vol ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;status&gt; p ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update_ans</span><span class="params">(status s )</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">3</span> ; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> d = s.jug[i] ;</span><br><span class="line">        <span class="keyword">if</span>(ans[d] &lt; <span class="number">0</span> )</span><br><span class="line">            ans[d] = s.vol ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    status s , cs ; <span class="comment">// cs copy_s</span></span><br><span class="line">    s.jug[<span class="number">0</span>] = <span class="number">0</span> ; s.jug[<span class="number">1</span>] = <span class="number">0</span> ; s.jug[<span class="number">2</span>] = cap[<span class="number">2</span>] ; s.vol = <span class="number">0</span> ;</span><br><span class="line">    p.push(s) ;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">while</span>(!p.empty())&#123;</span><br><span class="line">        s = p.top() ;</span><br><span class="line">        p.pop() ;</span><br><span class="line">        update_ans(s);</span><br><span class="line">        visit[s.jug[<span class="number">0</span>]][s.jug[<span class="number">1</span>]] = <span class="number">1</span> ;</span><br><span class="line">        <span class="comment">//debug</span></span><br><span class="line">        <span class="comment">//cout &lt;&lt; "" &lt;&lt; s.jug[0] &lt;&lt; ' ' &lt;&lt; s.jug[1] &lt;&lt; ' ' &lt;&lt; s.jug[2] &lt;&lt; ' ' &lt;&lt; s.vol &lt;&lt; '\n' ;</span></span><br><span class="line">        <span class="keyword">if</span>(ans[d] &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span> ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">3</span> ; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; <span class="number">3</span> ; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i == j || s.jug[j] == cap[j] || s.jug[i] == <span class="number">0</span>) <span class="comment">// e.v[j] == cap[j] this cup water is full , so it doesn't have any water</span></span><br><span class="line">                    <span class="keyword">continue</span> ;</span><br><span class="line">                cs = s ;</span><br><span class="line">                temp = min(cap[j] , s.jug[i] + s.jug[j]) -s.jug[j] ;</span><br><span class="line">                cs.jug[i] -= temp ;</span><br><span class="line">                cs.jug[j] += temp ;</span><br><span class="line">                cs.vol += temp ;</span><br><span class="line">                <span class="keyword">if</span>(!visit[cs.jug[<span class="number">0</span>]][cs.jug[<span class="number">1</span>]])&#123;</span><br><span class="line">                    p.push(cs);</span><br><span class="line">                    <span class="comment">//debug</span></span><br><span class="line">                    <span class="comment">//cout &lt;&lt; cs.jug[0] &lt;&lt; ' ' &lt;&lt; cs.jug[1] &lt;&lt; ' ' &lt;&lt; cs.jug[2] &lt;&lt; ' ' &lt;&lt; cs.vol &lt;&lt; '\n' ;</span></span><br><span class="line">                    <span class="comment">//cout &lt;&lt; visit[cs.jug[0]][cs.jug[1]] &lt;&lt; '\n' ;</span></span><br><span class="line">                    <span class="comment">//cout &lt;&lt; &amp;s &lt;&lt; ' ' &lt;&lt; &amp;cs &lt;&lt; '\n' ;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(d&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ans[d] != <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; ans[d] &lt;&lt; <span class="string">' '</span> &lt;&lt; d &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">            <span class="keyword">break</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        d-- ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">int</span> n ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; cap[<span class="number">0</span>] &gt;&gt; cap[<span class="number">1</span>] &gt;&gt; cap[<span class="number">2</span>] &gt;&gt; d ;</span><br><span class="line">        <span class="built_in">memset</span>(visit , <span class="number">0</span> , <span class="keyword">sizeof</span>(visit)) ;</span><br><span class="line">        <span class="built_in">memset</span>(ans , <span class="number">-1</span> , <span class="keyword">sizeof</span>(ans)) ;</span><br><span class="line">        <span class="keyword">while</span>(!p.empty()) <span class="comment">// priority_queue doesn't have clear</span></span><br><span class="line">            p.pop() ;</span><br><span class="line">        bfs() ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>圖論</tag>
        <tag>UVa</tag>
        <tag>Dijkstra&#39;s</tag>
        <tag>優先隊列</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa10810 - Ultra-QuickSort</title>
    <url>/2020/03/18/UVa/UVa10810/</url>
    <content><![CDATA[<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意:"></a>題目大意:</h2><blockquote>
<p>排序一個數組，但只能左右交換，試問數組最少要交換幾次。</p>
</blockquote>
<a id="more"></a> 

<h2 id="分析"><a href="#分析" class="headerlink" title="分析:"></a>分析:</h2><p><font color = "#dd0000"> <del><strong>這題真的好賤，上面寫著 QuickSort 結果是 MergeSort， 這代表經驗真的還是只能相信，不能先入為主阿</strong></del> </font></p>
<p>QuickSort 是在每一次分治 (divide) 的時候，就已經分好大小邊，<br>但 MergeSort 是不斷分治，直到不能再做分治後，才開始進行排序，透過此優點，所以很容易推算出左右交換的次數，加上 MergeSort 的複雜度也跟 QuickSort 一樣，所以一樣可以完成此問題！</p>
<p>需要注意的點是: 由於他最大的是 500050 ， 最複雜的排序可能來到 O ( \({n^2}\) )， 所以要使用 long long 以防溢位(overflow) 。</p>
<p><a href="https://www.youtube.com/watch?v=mB5HXBb_HY8&t" target="_blank" rel="noopener">MergeSort - Abdul Bari</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long int</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> intNum[<span class="number">500050</span>] , intTemp[<span class="number">500050</span>] ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> l , <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="comment">//debug</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; l &lt;&lt; ' ' &lt;&lt; r &lt;&lt; '\n';</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    ll L , R ;</span><br><span class="line">    L = merge_sort(l , (r+l)/<span class="number">2</span>) ;</span><br><span class="line">    R = merge_sort( (r+l) /<span class="number">2</span> +<span class="number">1</span> , r );</span><br><span class="line">    <span class="keyword">int</span> intP_Start , intQ_Start , intP_End , intPosition ;</span><br><span class="line">    intP_Start = l ;</span><br><span class="line">    intP_End = (r+l) /<span class="number">2</span> ;</span><br><span class="line">    intQ_Start = intP_End +<span class="number">1</span> ;</span><br><span class="line">    intPosition = l ;</span><br><span class="line">    <span class="keyword">while</span>(intPosition &lt;= r )&#123;</span><br><span class="line">        <span class="keyword">if</span>(intQ_Start &lt;= r &amp;&amp; (intP_Start &gt; intP_End || intNum[intQ_Start] &lt; intNum[intP_Start] ) )&#123;</span><br><span class="line">            intTemp[intPosition++] = intNum[intQ_Start++] ;</span><br><span class="line">            L += intP_End - intP_Start + <span class="number">1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            intTemp[intPosition++] = intNum[intP_Start++] ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = l ; i &lt;= r ; i++)</span><br><span class="line">        intNum[i] = intTemp[i] ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//debug</span></span><br><span class="line">    <span class="comment">//for(int i = 0 ; i &lt; 10 ; i++)</span></span><br><span class="line">    <span class="comment">//    cout &lt;&lt; intNum[i] &lt;&lt; ' ' ;</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; '\n' ;</span></span><br><span class="line">    <span class="keyword">return</span> L + R ;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> );</span><br><span class="line">    freopen(<span class="string">"out.txt"</span> , <span class="string">"w"</span> , <span class="built_in">stdout</span> );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">int</span> n ;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n &amp;&amp; n )&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i++)</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; intNum[i] ;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; merge_sort(<span class="number">0</span> , n<span class="number">-1</span> ) &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>合併排序 merge sort</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa11220 - Decoding the message (水題)</title>
    <url>/2020/03/19/UVa/UVa11220/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意:"></a>題目大意:</h2><blockquote>
<p>會給很多英文單字，第 x 個的英文單字中找出第 x 的字元，之後再將它印出。</p>
</blockquote>
<a id="more"></a> 

<h2 id="分析"><a href="#分析" class="headerlink" title="分析:"></a>分析:</h2><p><font color = "dd0000"> <strong>這題要是不會，我建議你先去看初學者影片 (良心推薦)</strong> </font></p>
<p>我覺得這題不需要解釋，也沒人看我解釋，模擬操作就好了，對吧?</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"out.txt"</span> , <span class="string">"w"</span> , <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">int</span> intCase , n , intPosition ;</span><br><span class="line">    <span class="built_in">string</span> strWord , strAns , strLine ;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vecAns ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; intCase ;</span><br><span class="line">    n = <span class="number">1</span> ;</span><br><span class="line">    getline(<span class="built_in">cin</span> , strLine ) ;</span><br><span class="line">    getline(<span class="built_in">cin</span> , strLine ) ;</span><br><span class="line">    <span class="keyword">while</span>(getline(<span class="built_in">cin</span> , strLine ))&#123;</span><br><span class="line">        <span class="comment">//debug</span></span><br><span class="line">        <span class="comment">//cout &lt;&lt; strLine &lt;&lt; '\n' ;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(strLine != <span class="string">""</span>)&#123;</span><br><span class="line">            <span class="built_in">stringstream</span> ss ;</span><br><span class="line">            ss.str(<span class="string">""</span>);</span><br><span class="line">            ss.clear() ;</span><br><span class="line">            ss &lt;&lt; strLine ;</span><br><span class="line">            intPosition = <span class="number">0</span> ;</span><br><span class="line">            strAns = <span class="string">""</span> ;</span><br><span class="line">            <span class="keyword">while</span>(ss &gt;&gt; strWord)&#123;</span><br><span class="line">                <span class="comment">//debug-</span></span><br><span class="line">                <span class="comment">//cout &lt;&lt; strWord &lt;&lt; '\n' ;</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(strWord.length() &gt; intPosition)&#123;</span><br><span class="line">                    strAns += strWord[intPosition++] ;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//debug</span></span><br><span class="line">                    <span class="comment">//cout &lt;&lt; strAns &lt;&lt; '\n' ;</span></span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            vecAns.push_back(strAns) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Case #"</span> &lt;&lt; n++ &lt;&lt; <span class="string">":"</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; vecAns.size()<span class="number">-1</span> ; i++)</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; vecAns[i] &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; vecAns[vecAns.size()<span class="number">-1</span>] ;</span><br><span class="line">            <span class="keyword">if</span>(n<span class="number">-1</span> != intCase)</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">            vecAns.clear() ;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>水題</tag>
        <tag>UVa</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa11349 - Symmetric Matrix</title>
    <url>/2020/03/19/UVa/UVa11349/</url>
    <content><![CDATA[<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意:"></a>題目大意:</h2><blockquote>
<p>給你一個正方形矩陣 M ， 你必須判斷矩陣是否對稱 (symmetric)</p>
<p>矩陣定義: 矩陣內部元素不會有負數，且是對中間點對稱</p>
</blockquote>
<a id="more"></a>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析:"></a>分析:</h2><p>這題的包裝手法，個人覺得非常之妙阿，小弟我的能力太差了!</p>
<p>由於此題的定義是僅限對 「中心點」 對稱，你可以發現，但你將它變成一維陣列表示時，會發現它其實是一個迴文！ 太神奇了，高手中的高手阿</p>
<p>解開的方式就中間切一半，然後開始判斷是否迴文就可以了。</p>
<h3 id="陷阱"><a href="#陷阱" class="headerlink" title=" 陷阱 : "></a><font color="#dd0000"> 陷阱 : </font ></h3><p>有兩點需要特別注意，這題有骯髒的手法wwww</p>
<ol>
<li>cin 的值會有負數，但矩陣內禁止有負號需特別注意</li>
<li>元素的值為 \({-2^{32} }\) &lt;= \(M_{ij} \) &lt;= \({2^{32}}\)，超出int的範圍(\({-2^{31}}\) &lt;= int &lt;= <font color = "dd0000"> \({2^{31}-1}\) </font >)，所以必須使用 long long 處理。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">ll llnNum[<span class="number">12100</span>] ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>,<span class="string">"r"</span> , <span class="built_in">stdin</span>) ;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">int</span> intCase , n , t , intLen ;</span><br><span class="line">    <span class="built_in">string</span> strNon ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; intCase ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//debug</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; intCase &lt;&lt; '\n' ;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> t = <span class="number">1</span> ; t &lt;= intCase ; t++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; strNon &gt;&gt; strNon &gt;&gt; n ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//debug</span></span><br><span class="line">        <span class="comment">//cout &lt;&lt; n &lt;&lt; '\n' ;</span></span><br><span class="line"></span><br><span class="line">        intLen = n * n ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; intLen ; i++)</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; llnNum[i] ;</span><br><span class="line">        <span class="keyword">int</span> isFlag = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; intLen /<span class="number">2</span>+<span class="number">1</span> ; i++)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//debug</span></span><br><span class="line">            <span class="comment">//cout &lt;&lt; intNum[i] &lt;&lt; ' ' &lt;&lt; intNum[intLen-i-1] &lt;&lt; '\n' ;</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(llnNum[i] != llnNum[intLen-i<span class="number">-1</span>] || llnNum[i] &lt; <span class="number">0</span> || llnNum[intLen-i<span class="number">-1</span>] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                isFlag = <span class="number">0</span> ;</span><br><span class="line">                <span class="keyword">break</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//debug</span></span><br><span class="line">        <span class="comment">//cout &lt;&lt; isFlag &lt;&lt; '\n' ;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isFlag)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Test #"</span> &lt;&lt; t &lt;&lt; <span class="string">": Symmetric."</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Test #"</span> &lt;&lt; t &lt;&lt; <span class="string">": Non-symmetric."</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>創新題</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa11541 - Decoding (水題)</title>
    <url>/2020/03/20/UVa/UVa11541/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意:"></a>題目大意:</h2><blockquote>
<p>輸入是一串 (英文，數字) * n 的組合</p>
<p>輸出 英文字 * n</p>
</blockquote>
<a id="more"></a> 

<h2 id="分析"><a href="#分析" class="headerlink" title="分析:"></a>分析:</h2><p><font color = "#dd0000"> <strong>簡單到一個不行的題目 <del>，這題千萬不要問我解釋</del></strong> </font></p>
<p>使用 for 即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">decode</span><span class="params">(<span class="built_in">string</span> strLetter , <span class="keyword">int</span> intCount )</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; intCount ; i++ )</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; strLetter ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>,<span class="string">"r"</span> , <span class="built_in">stdin</span>) ;</span><br><span class="line">    freopen(<span class="string">"out.txt"</span> , <span class="string">"w"</span> , <span class="built_in">stdout</span> ) ;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">int</span> intCase ;</span><br><span class="line">    <span class="built_in">string</span> strLine , strLetter , strCount ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; intCase ; <span class="built_in">cin</span>.ignore() ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> t = <span class="number">1</span> ; t &lt;= intCase ; t++)&#123;</span><br><span class="line">        getline(<span class="built_in">cin</span> , strLine) ;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Case "</span> &lt;&lt; t &lt;&lt; <span class="string">": "</span> ;</span><br><span class="line">        strCount = <span class="string">"0"</span> ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; strLine.length() ; i++ )&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isalpha</span>(strLine[i]))&#123;</span><br><span class="line">               decode(strLetter , stol(strCount)) ;</span><br><span class="line">               strLetter = strLine[i] ;</span><br><span class="line">               strCount = <span class="string">""</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                strCount += strLine[i] ;</span><br><span class="line">        &#125;</span><br><span class="line">        decode(strLetter , stol(strCount));</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>水題</tag>
        <tag>UVa</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa11636 - Hello World! (水題)</title>
    <url>/2020/03/30/UVa/UVa11636/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意:"></a>題目大意:</h2><blockquote>
<p>一開始給你一段句子，你只能透過 「複製 (copy)」 方式，複製出 x 段句子</p>
<p>給你一數字 x ，試問在幾次後可以複製可達到 x 個句子？</p>
</blockquote>
<a id="more"></a>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析:"></a>分析:</h2><p>只需要不斷複製 *2 即可完成，每一次都可以全句複製已達到複製的兩倍量。</p>
<p>再透過陣列預先處理即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> num[<span class="number">10010</span>] ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"out.txt"</span> , <span class="string">"w"</span> , <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">1</span> , step = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; <span class="number">10010</span> ; i++)&#123;</span><br><span class="line">        num[i] = step ;</span><br><span class="line">        <span class="keyword">if</span>(i == n)&#123;</span><br><span class="line">            n = n &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            step++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    step = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n &amp;&amp; n &gt;= <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Case "</span> &lt;&lt; step &lt;&lt; <span class="string">": "</span> &lt;&lt; num[n] &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">        step++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>水題</tag>
        <tag>UVa</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa11678 - Cards&#39; Exchange (水題)</title>
    <url>/2020/03/20/UVa/UVa11678/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意:"></a>題目大意:</h2><blockquote>
<p>兩個非常可愛的小女孩，想要玩交換卡片的遊戲 (ﾉ&gt;ω&lt;)ﾉ</p>
<p>可是他們不想拿到的重複卡片，試問他們最多可以交換幾張卡片。 </p>
</blockquote>
<a id="more"></a> 

<h2 id="分析"><a href="#分析" class="headerlink" title="分析:"></a>分析:</h2><p><font color = "#dd0000"> 水到不行的水題 </font></p>
<p>Step</p>
<ol>
<li>使用集合 (排除重複 (muliple) )</li>
<li>差集 (set_difference) </li>
<li>求差集後的總元素</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; A , B , diff_A , diff_B ;</span><br><span class="line">    <span class="keyword">int</span> x , y , intTemp ;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y &amp;&amp; x &amp;&amp; y)&#123;</span><br><span class="line">        A.clear() ;</span><br><span class="line">        B.clear() ;</span><br><span class="line">        diff_A.clear() ;</span><br><span class="line">        diff_B.clear() ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; x ; i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; intTemp ;</span><br><span class="line">            A.insert(intTemp) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; y ; i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; intTemp ;</span><br><span class="line">            B.insert(intTemp) ;</span><br><span class="line">        &#125;</span><br><span class="line">        set_difference(A.begin() , A.end() , B.begin() , B.end() , inserter(diff_A, diff_A.begin()) ) ;</span><br><span class="line">        set_difference(B.begin() , B.end() , A.begin() , A.end() , inserter(diff_B, diff_B.begin()) ) ;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; min(diff_A.size() , diff_B.size()) &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>水題</tag>
        <tag>UVa</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa11747 - Heavy Cycle Edges (Kruskal)</title>
    <url>/2020/03/20/UVa/UVa11747/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意:"></a>題目大意:</h2><blockquote>
<p>無向圖，之後生成 Minimum Spanning Tree (最小生成樹)</p>
</blockquote>
<a id="more"></a>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析:"></a>分析:</h2><p>Kruskal 是你最好的朋友，暴力簡單又方便</p>
<p><del>~ Prim</del> 禁止，會搞死你的 ，我一開始還想用 Prim 來解呢~~</p>
<h2 id="備註"><a href="#備註" class="headerlink" title="備註:"></a>備註:</h2><p>要是不知道 Kruskal 就看 <a href="https://www.youtube.com/watch?v=4ZlRH0eK-qQ" target="_blank" rel="noopener">Abdul Bari</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> parent[<span class="number">1020</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    ll n1 , n2 , w ;</span><br><span class="line">&#125;node[<span class="number">25020</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(edge A , edge B )</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> A.w &lt; B.w ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_root</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a != parent[a] )</span><br><span class="line">        <span class="keyword">return</span> parent[a] = find_root(parent[a]) ;</span><br><span class="line">    <span class="keyword">return</span> a ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> );</span><br><span class="line">    freopen(<span class="string">"out.txt"</span> , <span class="string">"w"</span> , <span class="built_in">stdout</span> );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">int</span> n , m , p_n1 , p_n2 ; <span class="comment">// parent_n1 , parent_n2</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; hce ; <span class="comment">//heavy edge circle</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &amp;&amp; n + m != <span class="number">0</span> )&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; m ; i++ )&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; node[i].n1 &gt;&gt; node[i].n2 &gt;&gt; node[i].w ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i++)</span><br><span class="line">            parent[i] = i ;</span><br><span class="line">        sort(node , node + m , compare ) ;</span><br><span class="line">        hce.clear() ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//kruskal</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; m ; i++)&#123;</span><br><span class="line">            p_n1 = find_root(node[i].n1) ;</span><br><span class="line">            p_n2 = find_root(node[i].n2) ;</span><br><span class="line">            <span class="keyword">if</span>(p_n1 != p_n2 )</span><br><span class="line">                parent[p_n2] = p_n1 ;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                hce.push_back(node[i].w) ;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//debug</span></span><br><span class="line">            <span class="comment">/**&lt;</span></span><br><span class="line"><span class="comment">            for(int i = 0 ; i &lt; n ; i++)</span></span><br><span class="line"><span class="comment">                cout &lt;&lt; parent[i] &lt;&lt; ' ' ;</span></span><br><span class="line"><span class="comment">            cout &lt;&lt; '\n' ;</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        &#125;</span><br><span class="line">        sort(hce.begin() , hce.end()) ;</span><br><span class="line">        <span class="keyword">if</span>(hce.size())&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; hce.size()<span class="number">-1</span> ; i++)</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; hce[i] &lt;&lt; <span class="string">' '</span> ;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; hce[hce.size()<span class="number">-1</span>] ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"forest"</span> ;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>Kruskal&#39;s algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa1207 - AGTC (LCS)</title>
    <url>/2020/03/13/UVa/UVa1207/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意:"></a>題目大意:</h2><blockquote>
<p>有 a , b 兩個字串求他們的 LCS(最長公共子序列) 最短修改數?</p>
</blockquote>
<a id="more"></a>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析:"></a>分析:</h2><p>LCS 與 LCS-less modify</p>
<img src = "https://imgur.com/pwPRhyI.jpg" alt ="UVa1207.jpg">

<p><font color = "dd0000"> 透過此圖可以了解 DP 原理 </font ></p>
<p>LCS 遞迴公式:</p>
<ul>
<li>LCS(x, y) =<ul>
<li>max( LCS( x-1, y ), LCS( x , y-1 ) ) , when str[x] != str[y]</li>
<li>LCS( x-1 , y-1 ) + e1                , when str[x] == sty[y]</li>
</ul>
</li>
</ul>
<p>LCS-less modify(LCS-lm) 遞迴公式:</p>
<ul>
<li>LCS-lm( x, y ) =<ul>
<li>min( LCS-lm( x , y ), LCS-lm( x , y) , LCS-lm( x-1 , y-1) ) +1 , when str[x] != str[y]</li>
<li>LCS-lm( x -1 , y -1 ) +1                , when str[x] == str[y]</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LCS</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> step , max_len ;</span><br><span class="line">&#125;Dp[<span class="number">5000</span>][<span class="number">5000</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">int</span> intX , intY , Min_step , Max_len ;</span><br><span class="line">    <span class="built_in">string</span> strX , strY ;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; intX &gt;&gt; strX &gt;&gt; intY &gt;&gt; strY )&#123;</span><br><span class="line">        <span class="comment">//init</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= intY ; i++)&#123;</span><br><span class="line">            Dp[<span class="number">0</span>][i].max_len = <span class="number">0</span> ;</span><br><span class="line">            Dp[<span class="number">0</span>][i].step = i ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= intX ; i++)&#123;</span><br><span class="line">            Dp[i][<span class="number">0</span>].max_len = <span class="number">0</span> ;</span><br><span class="line">            Dp[i][<span class="number">0</span>].step = i ;</span><br><span class="line">        &#125;</span><br><span class="line">        Max_len = <span class="number">0</span> ;</span><br><span class="line">        Min_step = <span class="number">0</span> ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//lcs</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= intX ; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= intY ; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(strX[i<span class="number">-1</span>] == strY[j<span class="number">-1</span>])&#123;</span><br><span class="line">                    Dp[i][j].max_len = Dp[i<span class="number">-1</span>][j<span class="number">-1</span>].max_len +<span class="number">1</span> ;</span><br><span class="line">                    Dp[i][j].step = Dp[i<span class="number">-1</span>][j<span class="number">-1</span>].step ;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//debug</span></span><br><span class="line">                    <span class="comment">//cout &lt;&lt; strX[i-1] &lt;&lt; ' ' &lt;&lt; strY[j-1] &lt;&lt; ' ' &lt;&lt; Dp[i][j].max_len &lt;&lt; '\n' ;</span></span><br><span class="line">                    <span class="comment">//cout &lt;&lt; strX[i-1] &lt;&lt; ' ' &lt;&lt; strY[j-1] &lt;&lt; ' ' &lt;&lt; Dp[i][j].step &lt;&lt; '\n' ;</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    Dp[i][j].max_len = max(Dp[i<span class="number">-1</span>][j].max_len , Dp[i][j<span class="number">-1</span>].max_len ) ;</span><br><span class="line">                    Dp[i][j].step = min( min(Dp[i<span class="number">-1</span>][j<span class="number">-1</span>].step , Dp[i][j<span class="number">-1</span>].step ) , Dp[i<span class="number">-1</span>][j].step ) +<span class="number">1</span> ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; Dp[intX][intY].step &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>最長共同子序列 Longest Common Subsequence</tag>
        <tag>動態規劃 Dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa12096 - The SetStack Computer</title>
    <url>/2020/03/23/UVa/UVa12096/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>模擬一個集合的堆疊計算機。該計算機有5種指令</p>
<ol>
<li>PUSH：新增一個{}空集合到 Stack</li>
<li>DUP：複製 Stack 的 Top 集合，再Push到 Stack</li>
<li>ADD：將 Stack Pop 2個集合，最先 Pop 的集合 a 和第 2 個 Pop 的集合 b，將集合 a 加入至集合 b 後再 Push 到 Stack</li>
<li>UNION：將 Stack Pop 2 個集合做 Union 後，再 Push 到 Stack</li>
<li>INTERSECT：將Stack Pop 2個集合做Intersect後，再Push到Stack</li>
</ol>
<p>輸入有T筆測資，每筆測資會有 n 個前面 5 種的指令，每當一個指令完成後，要輸出目前 Stack Top  的集合的元素數量。當N個指令完成後，輸出 ***。</p>
</blockquote>
<a id="more"></a>

<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p><font color="#dd0000">這題我也是看其他優秀大神寫出來的，高手太多了，小弟我只是一個小孩子罷了。</font></p>
<p>STL 真的棒，省去底層的操作。</p>
<p>在操作 set 的過程中，請記住，不要就傻傻可愛的直接用 set ( set 裡面又有 set 的話，交、聯集的函式庫無法被使用的！)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; , <span class="keyword">int</span>&gt; mapSet ;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span> , <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; &gt; mapSetReverse ;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vecStack ;</span><br><span class="line"><span class="keyword">int</span> intHash ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">set_hash</span><span class="params">(<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; setTemp)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> &amp;intTemp = mapSet[setTemp] ;</span><br><span class="line">    <span class="keyword">if</span>(!intTemp)&#123;</span><br><span class="line">        mapSetReverse[intHash] = setTemp ;</span><br><span class="line">        intTemp = intHash++ ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> intTemp ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> );</span><br><span class="line">    freopen(<span class="string">"out.txt"</span> , <span class="string">"w"</span> , <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">int</span> t , n ;</span><br><span class="line">    <span class="built_in">string</span> strCommand  ;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; setA , setB , setC ;</span><br><span class="line">    <span class="keyword">int</span> intA , intB , intC ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t ;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">        intHash = <span class="number">1</span> ;</span><br><span class="line">        vecStack.clear() ;</span><br><span class="line">        mapSet.clear() ;</span><br><span class="line">        mapSetReverse.clear() ;</span><br><span class="line">        <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; strCommand ;</span><br><span class="line">            <span class="keyword">if</span>(strCommand == <span class="string">"PUSH"</span>)&#123;</span><br><span class="line">                setA = &#123;&#125; ;</span><br><span class="line">                vecStack.push_back(set_hash(setA)) ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(strCommand == <span class="string">"DUP"</span>)&#123;</span><br><span class="line">                vecStack.push_back(vecStack.back()) ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (strCommand == <span class="string">"UNION"</span>)&#123;</span><br><span class="line">                setA = mapSetReverse[vecStack.back()] ;</span><br><span class="line">                vecStack.pop_back() ;</span><br><span class="line">                setB = mapSetReverse[vecStack.back()] ;</span><br><span class="line">                vecStack.pop_back() ;</span><br><span class="line">                setC = &#123;&#125; ;</span><br><span class="line">                set_union(setA.begin() , setA.end() , setB.begin() , setB.end() , inserter(setC , setC.begin())) ;</span><br><span class="line">                vecStack.push_back(set_hash(setC)) ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (strCommand == <span class="string">"INTERSECT"</span>)&#123;</span><br><span class="line">                setA = mapSetReverse[vecStack.back()] ;</span><br><span class="line">                vecStack.pop_back() ;</span><br><span class="line">                setB = mapSetReverse[vecStack.back()] ;</span><br><span class="line">                vecStack.pop_back() ;</span><br><span class="line">                setC = &#123;&#125; ;</span><br><span class="line">                set_intersection(setA.begin() , setA.end() , setB.begin() , setB.end() , inserter(setC , setC.begin())) ;</span><br><span class="line">                vecStack.push_back(set_hash(setC)) ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(strCommand == <span class="string">"ADD"</span>)&#123;</span><br><span class="line">                intA = vecStack.back() ;</span><br><span class="line">                vecStack.pop_back() ;</span><br><span class="line">                setB = mapSetReverse[vecStack.back()] ;</span><br><span class="line">                vecStack.pop_back() ;</span><br><span class="line">                setB.insert(intA) ;</span><br><span class="line">                vecStack.push_back(set_hash(setB)) ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; mapSetReverse[vecStack.back()].size() &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"***"</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>創新題</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa12299 - RMQ with Shifts (Segment Tree)</title>
    <url>/2020/03/23/UVa/UVa12299/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>給予一個數組，有兩種操作</p>
<ol>
<li>query l r : 查詢 l 到 r 的最小值</li>
<li>shift x1 , x2 , x3 : 原本的值都往前循環一個位置</li>
</ol>
</blockquote>
<a id="more"></a>

<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>透過線段樹來維護最小值查詢，加上 shift 的數字最多只有 30 位，透過單點修改的方式即可完成。</p>
<h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><p>shift 給的是位置，並不是數值，也不一定給你的位置會是照順序，所以必須要進行 sort</p>
<h2 id="備註："><a href="#備註：" class="headerlink" title="備註："></a>備註：</h2><p>要是不知道 RMQ (Range Minimum/Maximum Query)) 就看 <a href="https://www.youtube.com/watch?v=c5O7E_PDO4U" target="_blank" rel="noopener">Tushar Roy - Coding Made Simple</a></p>
<p><del>印度人教程式真的強，不知道為甚麼感覺看中文的教學影片都比較沒辦法聽得懂阿，難道真的是語言的關係嗎QQ</del></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Lson(x) ((x &lt;&lt; 1) +1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Rson(x) ((x &lt;&lt; 1) +2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 99999999</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100005</span> ;</span><br><span class="line"><span class="keyword">int</span> shift[<span class="number">35</span>] , num[N] , len_shift ;</span><br><span class="line"><span class="built_in">string</span> strLine ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> left , right , Min_Value  ;</span><br><span class="line">&#125;node[<span class="number">4</span> * N ];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> left , <span class="keyword">int</span> right , <span class="keyword">int</span> x = <span class="number">0</span> )</span></span>&#123;</span><br><span class="line">    node[x].left = left ;</span><br><span class="line">    node[x].right = right ;</span><br><span class="line">    <span class="keyword">if</span>(left == right)&#123;</span><br><span class="line">        node[x].Min_Value = num[left] ;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (left + right ) / <span class="number">2</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//debug</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; mid &lt;&lt; '\n' ;</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; node[x].left &lt;&lt; ' ' &lt;&lt; node[x].right &lt;&lt; ' ' &lt;&lt; '\n' ;</span></span><br><span class="line"></span><br><span class="line">    build(left , mid , Lson(x)) ;</span><br><span class="line">    build(mid + <span class="number">1</span> , right , Rson(x)) ;</span><br><span class="line">    node[x].Min_Value = min(node[Lson(x)].Min_Value  , node[Rson(x)].Min_Value ) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handle</span><span class="params">()</span></span>&#123;</span><br><span class="line">    len_shift = <span class="number">0</span> ;</span><br><span class="line">    shift[len_shift] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">6</span> ; i &lt; strLine.length() ; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(strLine[i] &gt;= <span class="string">'0'</span> &amp;&amp; strLine[i] &lt;= <span class="string">'9'</span> )&#123;</span><br><span class="line">            shift[len_shift] = shift[len_shift] * <span class="number">10</span> + (<span class="keyword">int</span>) (strLine[i] - <span class="string">'0'</span> ) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            shift[++len_shift ] = <span class="number">0</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//finaly char is ')' , so len_shift is right</span></span><br><span class="line">    sort(shift , shift + len_shift ) ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//debug</span></span><br><span class="line">    <span class="comment">/**&lt;</span></span><br><span class="line"><span class="comment">    for(int i = 0 ; i &lt; len_shift ; i++)</span></span><br><span class="line"><span class="comment">        cout &lt;&lt; shift[i] &lt;&lt; ' ' ;</span></span><br><span class="line"><span class="comment">    cout &lt;&lt; '\n' ;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> left , <span class="keyword">int</span> right , <span class="keyword">int</span> x = <span class="number">0</span> )</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node[x].left &gt;= left &amp;&amp; node[x].right &lt;= right)</span><br><span class="line">        <span class="keyword">return</span> node[x].Min_Value ;</span><br><span class="line">    <span class="keyword">int</span> mid = (node[x].left + node[x].right ) / <span class="number">2</span> ;</span><br><span class="line">    <span class="keyword">int</span> ans = INF ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//debug</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; node[x].left &lt;&lt; ' ' &lt;&lt; node[x].right &lt;&lt; ' ' &lt;&lt; node[x].Min_Value &lt;&lt; '\n' ;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( left &lt;= mid )</span><br><span class="line">        ans = min(ans , query(left , right , Lson(x))) ;</span><br><span class="line">    <span class="keyword">if</span>(mid &lt; right )</span><br><span class="line">        ans = min(ans , query(left , right , Rson(x))) ;</span><br><span class="line">    <span class="keyword">return</span> ans ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_num</span><span class="params">(<span class="keyword">int</span> position , <span class="keyword">int</span> value , <span class="keyword">int</span> x = <span class="number">0</span> )</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node[x].left == position &amp;&amp; node[x].right == position )&#123;</span><br><span class="line">       node[x].Min_Value = value ;</span><br><span class="line">       <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (node[x].left + node[x].right ) / <span class="number">2</span> ;</span><br><span class="line">    <span class="keyword">if</span>(position &lt;= mid )</span><br><span class="line">        set_num(position , value , Lson(x) );</span><br><span class="line">    <span class="keyword">if</span>(mid &lt; position )</span><br><span class="line">        set_num(position , value , Rson(x)) ;</span><br><span class="line">    node[x].Min_Value = min(node[Lson(x)].Min_Value , node[Rson(x)].Min_Value );</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n , q , intTemp ;</span><br><span class="line">    ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"out.txt"</span> , <span class="string">"w"</span> , <span class="built_in">stdout</span> ) ;</span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> ) ;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; q ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; i++)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; num[i] ;</span><br><span class="line">    build(<span class="number">1</span>,n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//debug</span></span><br><span class="line">    <span class="comment">/**&lt;</span></span><br><span class="line"><span class="comment">    for(int i = 0 ; i &lt; 13 ; i++)&#123;</span></span><br><span class="line"><span class="comment">        cout &lt;&lt; node[i].left &lt;&lt; ' ' &lt;&lt; node[i].right &lt;&lt; ' ' &lt;&lt; node[i].Min_Value &lt;&lt; '\n' ;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    return 0 ;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; strLine ;</span><br><span class="line">        <span class="keyword">if</span>(strLine[<span class="number">0</span>] == <span class="string">'q'</span>)&#123;</span><br><span class="line">            handle();</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; query(shift[<span class="number">0</span>] , shift[<span class="number">1</span>] ) &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (strLine[<span class="number">0</span>] == <span class="string">'s'</span>)&#123;</span><br><span class="line">            handle();</span><br><span class="line">            intTemp = num[shift[<span class="number">0</span>]] ;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; len_shift ; i++)&#123;</span><br><span class="line">                set_num(shift[i<span class="number">-1</span>] , num[shift[i]]) ;</span><br><span class="line">                num[shift[i<span class="number">-1</span>]] = num[shift[i]] ;</span><br><span class="line">            &#125;</span><br><span class="line">            num[shift[len_shift<span class="number">-1</span>]] = intTemp ;</span><br><span class="line">            set_num(shift[len_shift<span class="number">-1</span>] , intTemp );</span><br><span class="line"></span><br><span class="line">            <span class="comment">//debug</span></span><br><span class="line">            <span class="comment">//cout &lt;&lt; intTemp &lt;&lt; ' ' &lt;&lt; shift[len_shift-1] &lt;&lt; '\n' ;</span></span><br><span class="line">            <span class="comment">//for(int i = 1 ; i &lt;= n ; i++)</span></span><br><span class="line">             <span class="comment">//   cout &lt;&lt; num[i] &lt;&lt; ' ' ;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>線段樹 Segment Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa12385 - Interesting Sequences (水題)</title>
    <url>/2020/04/28/UVa/UVa12385/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>給你一個數列，請找出 「Interesting Sequences」共有幾組。</p>
</blockquote>
<a id="more"></a>

<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>唉，看來我的英文能力需要增加。</p>
<p>「Interesting Sequences」 定義如下:</p>
<ol>
<li>在 Interesting Sequences 中頭尾數字一樣</li>
<li><del>不是每個 Interesting Sequences 的數字都要一樣</del></li>
</ol>
<p>ex1: 4 2 3 5 9 2 1 </p>
<ol>
<li>2 3 5 9 2 </li>
</ol>
<p>ex2: 3 2 3 1 3 2 3 2 2 2 2</p>
<ol>
<li>2 3 1 3 2</li>
<li>2 2  index: 8 9 </li>
<li>2 2  index: 9 10</li>
<li>2 2  index: 10 11</li>
</ol>
<p><font color="#ff0000"><strong>就這麼簡單，用「動態規劃」解決這題即可</strong></font></p>
<h4 id="DP規則如下-透過-greedy-優化-："><a href="#DP規則如下-透過-greedy-優化-：" class="headerlink" title="DP規則如下( 透過 greedy 優化 )："></a>DP規則如下( 透過 greedy 優化 )：</h4><ol>
<li>透過陣列記住每個數字最後的位置</li>
<li>last 做為上次 Interesting Sequences 的最後 index，因為 Interesting Sequences 不可以重疊。</li>
<li>如果 數字最後的位置 &gt;= last , ans +=1  </li>
</ol>
<h5 id="題外話"><a href="#題外話" class="headerlink" title="題外話:"></a>題外話:</h5><p>這題幾乎沒什麼人寫過，資源量好少，然後英文真的是不太好理解阿，花了 2、3 天才理解這題題意是甚麼</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"out.txt"</span> , <span class="string">"w"</span> , <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n ,t , last , ans , temp ;</span><br><span class="line">    <span class="keyword">int</span> num[<span class="number">100020</span>] = &#123;&#125; ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t ;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        last = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">100020</span> ; i++)</span><br><span class="line">            num[i] = <span class="number">-1</span> ;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; temp ;</span><br><span class="line">            <span class="keyword">if</span>( num[temp] &gt;= last)&#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//debug</span></span><br><span class="line">                <span class="comment">//cout &lt;&lt; "debug: " &lt;&lt;  i &lt;&lt; " last: " &lt;&lt; last &lt;&lt; '\n' ;</span></span><br><span class="line"></span><br><span class="line">                ans++ ;</span><br><span class="line">                last = i ;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            num[temp] = i ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>水題</tag>
        <tag>UVa</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa1262 - Password (水題)</title>
    <url>/2020/04/13/UVa/UVa1262/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>給你兩個 5*6 的表格，尋找這兩個表格的第 n 個 column 一樣的字母。<br>輸出第 x 個組合(透過字典序順序排列)</p>
</blockquote>
<a id="more"></a>

<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>明顯第一直覺就是排列組合，時間複雜度最多為 (6^4)，合理可接受範圍內。</p>
<p>我原本的做法是只記錄共同的字母，然後進行排列組合。 =&gt; <font color="#dd0000">程式碼不好維護</font></p>
<p><a href="https://geniustanley.github.io/2017/02/26/UVa-1262-Password/" target="_blank" rel="noopener">參考他的寫法後，覺得很棒。雖然時間複雜度比較高，但比較好維護</a></p>
<p>用二維陣列紀錄 Array[A-Z][column]，易讀易維護。</p>
<p><strong>看來我對於 C++ 還是不夠了解，沒辦法當機立下用最好、最易讀的解法</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> ax[<span class="number">30</span>][<span class="number">7</span>] = &#123;&#125; ;</span><br><span class="line"><span class="keyword">int</span> ay[<span class="number">30</span>][<span class="number">7</span>] = &#123;&#125; ;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; Ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> j , <span class="built_in">string</span> strAns)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(j == <span class="number">5</span>)&#123;</span><br><span class="line">        Ans.push_back(strAns);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">26</span> ; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ax[i][j] &amp;&amp; ay[i][j])</span><br><span class="line">            dfs(j+<span class="number">1</span> , strAns+ (<span class="keyword">char</span>)(<span class="string">'A'</span> + i));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span>) ;</span><br><span class="line">    freopen(<span class="string">"out.txt"</span> , <span class="string">"w"</span> , <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n , x ;</span><br><span class="line">    <span class="built_in">string</span> strLine ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        Ans.clear();</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">26</span> ; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; <span class="number">6</span> ; j++)&#123;</span><br><span class="line">                ax[i][j] = <span class="number">0</span>;</span><br><span class="line">                ay[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">6</span> ; i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; strLine;</span><br><span class="line">             <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; strLine.length() ; j++)&#123;</span><br><span class="line">                ax[strLine[j] - <span class="string">'A'</span>][j] = <span class="number">1</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">6</span> ; i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; strLine;</span><br><span class="line">             <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; strLine.length() ; j++)&#123;</span><br><span class="line">                ay[strLine[j] - <span class="string">'A'</span>][j] = <span class="number">1</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dfs(<span class="number">0</span>, <span class="string">""</span>);</span><br><span class="line">        <span class="keyword">if</span>(Ans.size() &lt; x)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"NO"</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; Ans[x<span class="number">-1</span>] &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>水題</tag>
        <tag>UVa</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa12918 - Lucky Thief (水題)</title>
    <url>/2020/06/09/UVa/UVa12918/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>小偷有 a 把 key 與 b 的房子，小偷想要找出 key 於房間的配對，每個 key 只能跟一個房間配對。</p>
<p>請告訴小偷，在有邏輯分析的情況下，小偷最少需要失敗幾次才能成功知道每個 key 要配每個房間。<br>P.S. a &lt;= b </p>
</blockquote>
<a id="more"></a>

<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p><strong>最非常簡單的題目，但是我竟然卡關了 20 分鐘…，老人家不給力阿。</strong></p>
<p>最後是向一個對數學敏感的朋友，才發現他只需要「嘗試失敗」，不需要計算成功次數。害我在那邊思考半天rrrrr</p>
<p>使用梯形公式 (上底 + 下底 ) * 高 /2 即可。(等差公式)</p>
<p>上底：(house -1 ) 因為最多只會失敗 house -1<br>下底：(house - key) 因為 key 數量就只有這麼多，後面的房子不需要常識。<br>高： (key) 乘以 key 數量</p>
<p>非常簡單，你一定也可以地啦！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll t ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t ;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        ll a , b;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b ;</span><br><span class="line">        ll sum ;</span><br><span class="line">        sum = ((b-a) + (b<span class="number">-1</span>))* a / <span class="number">2</span> ;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; sum &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>水題</tag>
        <tag>UVa</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa1583 - Digit Generator(暴力搜尋 Brute force )</title>
    <url>/2020/03/13/UVa/UVa1583/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意:"></a>題目大意:</h2><blockquote>
<p>給你一個數字，求出此數的原本 + 每個位數的 sum(總和)，假如有同時兩個數字符合需求時輸出最小值。<br>example: 216<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = (198 + 1 + 9 + 8 )<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = (207 + 2 + 0 + 7 )</p>
</blockquote>
<a id="more"></a>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析:"></a>分析:</h2><p><font color = "dd0000"> <strong>暴力、枚舉，唯一信仰</strong> </font></p>
<p>你覺得效率很差? 沒關係！ 電腦不在意。</p>
<p>先透過字典得方式建表，之後查表就好。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 99999999</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> intDict[<span class="number">200010</span>] = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> );</span><br><span class="line">    freopen(<span class="string">"out.txt"</span> , <span class="string">"w"</span> , <span class="built_in">stdout</span> );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">int</span> n , num , sum , intTemp ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">100000</span> ; i &gt; <span class="number">0</span> ; i-- )&#123;</span><br><span class="line">        intDict[i] = INF ;</span><br><span class="line">        sum = i ;</span><br><span class="line">        intTemp = i ;</span><br><span class="line">        <span class="keyword">while</span>(intTemp)&#123;</span><br><span class="line">            sum += intTemp % <span class="number">10</span> ;</span><br><span class="line">            intTemp /= <span class="number">10</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(intDict[sum] &gt; i  )</span><br><span class="line">        intDict[sum] = i ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(intDict[n] == INF)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; intDict[n] &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>水題</tag>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>暴力搜尋 Brute force</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa1594 - Ducci Sequence (暴力搜尋 Brute force)</title>
    <url>/2020/03/16/UVa/UVa1594/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意:"></a>題目大意:</h2><blockquote>
<p>給你一個隊列，每一次計算後生成新的隊列，隊列規則如下:</p>
</blockquote>
<center> [a1,a1, ...., an] </center>
更新為:
<center > [|a1-an|, |a1-a2|, ...., |an-1-an|] </center>

<p>最多不生成超過1000個隊列</p>
<a id="more"></a>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析:"></a>分析:</h2><p><font color = "dd0000"> <strong>暴力、枚舉，唯一信仰</strong> </font></p>
<p>每一次生成隊列後，總計它的序列，要是為 0 輸出 “ZERO” ，不是的話，輸出 “LOOP” </p>
<p>複雜度最多 o(1000) 很安全</p>
<h3 id="備註"><a href="#備註" class="headerlink" title="備註:"></a>備註:</h3><p>這位大神的網站寫得很棒，要是看不懂可以看她的</p>
<p><a href="http://glj8989332.blogspot.com/2019/12/uva-1594-ducci-sequence.html" target="_blank" rel="noopener">http://glj8989332.blogspot.com/2019/12/uva-1594-ducci-sequence.html</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> intCase , n , intTemp , intNum[<span class="number">25</span>] , isFlag , intSum  ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; intCase ;</span><br><span class="line">    <span class="keyword">while</span>(intCase--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i++)</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; intNum[i] ;</span><br><span class="line"></span><br><span class="line">        isFlag = <span class="number">0</span> ;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">1010</span> ; i++)&#123;</span><br><span class="line">            intSum = <span class="number">0</span> ;</span><br><span class="line">            intNum[n] = intNum[<span class="number">0</span>] ;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; n ; j++ )</span><br><span class="line">                intNum[j] = <span class="built_in">abs</span>(intNum[j] - intNum[j+<span class="number">1</span>]) ;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i++)&#123;</span><br><span class="line">                <span class="comment">//debug</span></span><br><span class="line">                <span class="comment">//cout &lt;&lt; intNum[i] &lt;&lt; ' ' ;</span></span><br><span class="line"></span><br><span class="line">                intSum += intNum[i] ;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//debug</span></span><br><span class="line">            <span class="comment">//cout &lt;&lt; '\n' ;</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(!intSum)&#123;</span><br><span class="line">                isFlag = <span class="number">1</span> ;</span><br><span class="line">                <span class="keyword">break</span> ;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(isFlag)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"ZERO"</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"LOOP"</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>水題</tag>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>暴力搜尋 Brute force</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa255 - Correct Move (水題)</title>
    <url>/2020/03/07/UVa/UVa255/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>給定 queen 與 king 的位置， queen 下一步移動，判斷狀態和移動的合法性。</p>
</blockquote>
<a id="more"></a> 

<h2 id="分析"><a href="#分析" class="headerlink" title="分析:"></a>分析:</h2><p>水題</p>
<p>枚舉每個位置，並嘗試各種狀態與移動的合法性</p>
<p>tip: 1. 可以將二維陣列壓縮成一維陣列<br>     2. 四個角直接用if寫死即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> k , q1 , q2 ;</span><br><span class="line"><span class="keyword">int</span> q1x , q1y , q2x , q2y , kx , ky ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_between</span><span class="params">(<span class="keyword">int</span> a , <span class="keyword">int</span> b , <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> intMax , intMin  ;</span><br><span class="line">    <span class="keyword">if</span>(b &gt; a)</span><br><span class="line">        swap(a , b);</span><br><span class="line">    <span class="keyword">if</span>(a &gt; c &amp;&amp; c &gt; b)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_illegal_move</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k == q2 || q1 == q2)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span>(q1 % <span class="number">8</span> != q2 % <span class="number">8</span> &amp;&amp; q1 / <span class="number">8</span> != q2 / <span class="number">8</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span>((is_between(q1x , q2x , kx) &amp;&amp; q1y == ky ) || (is_between(q1y , q2y , ky) &amp;&amp; q1x == kx))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_move_not_allow</span><span class="params">()</span></span>&#123; <span class="comment">//由於是一維，因此不可將最右邊的格式與最左邊的格子視為相同</span></span><br><span class="line">    <span class="keyword">if</span>((k+<span class="number">1</span> == q2 &amp;&amp; q2 % <span class="number">8</span> != <span class="number">0</span> ) || (k<span class="number">-1</span> == q2 &amp;&amp; q2 % <span class="number">8</span> != <span class="number">7</span>) || (k<span class="number">-8</span> == q2) || k+<span class="number">8</span> == q2)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_stop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( (k == <span class="number">0</span> &amp;&amp; q2 == <span class="number">9</span>) || (k == <span class="number">7</span> &amp;&amp; q2 == <span class="number">14</span>) || \</span><br><span class="line">        (k == <span class="number">56</span> &amp;&amp; q2 == <span class="number">49</span> ) || (k == <span class="number">63</span>) &amp;&amp; (q2 == <span class="number">54</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; k &gt;&gt; q1 &gt;&gt; q2)&#123;</span><br><span class="line">        q1x = q1 / <span class="number">8</span> ;</span><br><span class="line">        q1y = q1 % <span class="number">8</span> ;</span><br><span class="line">        q2x = q2 / <span class="number">8</span> ;</span><br><span class="line">        q2y = q2 % <span class="number">8</span> ;</span><br><span class="line">        kx = k / <span class="number">8</span> ;</span><br><span class="line">        ky = k % <span class="number">8</span> ;</span><br><span class="line">        <span class="keyword">if</span>(k == q1)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Illegal state"</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(is_illegal_move())</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Illegal move"</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(is_move_not_allow())</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Move not allowed"</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(is_stop())</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Stop"</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Continue"</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>水題</tag>
        <tag>UVa</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa294 - Divisors (數論 Math theorm)</title>
    <url>/2020/04/09/UVa/UVa294/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>給你一段數字，求出範圍數字內可以被最多數字整除於 0。(如果有一樣，輸出最小)<br><strong>並透過格式輸出</strong></p>
</blockquote>
<a id="more"></a>

<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>這裡有一個地方我覺得很酷，就是</p>
<p>6 的除數有 1 2 4 6 總共為 4<br>6 = 2^1 * 3^1<br>=&gt; 2 * 2 =&gt; 4</p>
<p>一開始覺得很神奇，但後來想通了也沒什麼，但想出方法的真的很強呢。</p>
<p>Hint:<br>x ^ 0 = 1，能明白固中道理，這題目就簡單了。</p>
<p><a href="http://celinechiu0809.blogspot.com/2015/04/uva294-divisors.html" target="_blank" rel="noopener">教會我的blog</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Maxn_Num 1000000000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">enum</span> &#123;Maxn = Maxn_Num , sqrt_max = (<span class="keyword">int</span>)<span class="built_in">sqrt</span>(Maxn_Num)&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; prime ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count_div</span><span class="params">(<span class="keyword">int</span> x )</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> total =<span class="number">1</span> , j ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; prime.size() &amp;&amp; x ; i++)&#123;</span><br><span class="line">        j = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">while</span>(x % prime[i] ==<span class="number">0</span> )&#123;</span><br><span class="line">            x /= prime[i];</span><br><span class="line">            j++ ;</span><br><span class="line">        &#125;</span><br><span class="line">        total *= j ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span>) ;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> flag ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= sqrt_max ; i++)&#123;</span><br><span class="line">        flag = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span> ; j &lt;= <span class="built_in">sqrt</span>(i) ; j++ )&#123;</span><br><span class="line">            <span class="keyword">if</span>(i % j == <span class="number">0</span> )&#123;</span><br><span class="line">                flag = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)</span><br><span class="line">            prime.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**&lt;      //debug</span></span><br><span class="line"><span class="comment">    for(auto it : prime)</span></span><br><span class="line"><span class="comment">        cout &lt;&lt; it &lt;&lt; '\n' ;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">int</span> n , l , u, temp;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; l &gt;&gt; u ;</span><br><span class="line">        pair&lt;<span class="keyword">int</span> , <span class="keyword">int</span>&gt; divMax = &#123;<span class="number">0</span>,<span class="number">0</span>&#125; ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = l ; i &lt;= u ; i++)&#123;</span><br><span class="line">            temp = count_div(i);</span><br><span class="line">            <span class="keyword">if</span> ( temp &gt; divMax.second)&#123;</span><br><span class="line">                divMax.first = i ;</span><br><span class="line">                divMax.second = temp ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Between "</span> &lt;&lt; l &lt;&lt; <span class="string">" and "</span> &lt;&lt; u &lt;&lt; <span class="string">", "</span> &lt;&lt; divMax.first &lt;&lt; <span class="string">" has a maximum of "</span> &lt;&lt; divMax.second &lt;&lt; <span class="string">" divisors.\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>數論 Math theorm</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa544 - Heavy Cargo (Kruskal)</title>
    <url>/2020/03/08/UVa/UVa544/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>有一個載重無限的卡車從 a 地到 b 地路徑可乘載的最大重量為何?</p>
</blockquote>
<a id="more"></a> 

<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>圖論，最短路徑問題，最大生成樹。</p>
<p>使用kruskal特性，將權重最大的邊加入，當起點與終點為同一樹時，輸出答案</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">string</span> strA , strB ;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; mapHash;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> intSegments = <span class="number">20000</span>;</span><br><span class="line"><span class="keyword">int</span> intParent[<span class="number">250</span>] ,intHash ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="built_in">string</span> strA )</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!mapHash.count(strA))&#123;</span><br><span class="line">       mapHash[strA] = intHash++ ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//debug</span></span><br><span class="line">        <span class="comment">//cout &lt;&lt; strA &lt;&lt; ' ' &lt;&lt; intHash &lt;&lt; '\n' ;</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mapHash[strA] ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u , v , val ;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; strA &gt;&gt; strB &gt;&gt; val ;</span><br><span class="line">        u = get(strA);</span><br><span class="line">        v = get(strB);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;nodEdge[intSegments];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_root</span><span class="params">(<span class="keyword">int</span> intA)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> intA == intParent[intA] ?  intA : intParent[intA] = find_root(intParent[intA]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=<span class="number">4</span> , m=<span class="number">4</span> , intValue , intCase = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m  &amp;&amp; n + m != <span class="number">0</span>)&#123;</span><br><span class="line">        intCase++ ;</span><br><span class="line">        mapHash.clear();</span><br><span class="line">        intHash = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i++) intParent[i] = i ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; m ; i++) nodEdge[i].read() ;</span><br><span class="line">        <span class="built_in">string</span> strStart , strDestination ;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; strStart &gt;&gt; strDestination ;</span><br><span class="line">        sort(nodEdge , nodEdge+m , [](node nodA , node nodB)&#123;</span><br><span class="line">             <span class="keyword">return</span>  nodA.val &gt; nodB.val ;</span><br><span class="line">              &#125;</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**&lt;debug</span></span><br><span class="line"><span class="comment">        for(int i = 0 ; i &lt; m ; i++)</span></span><br><span class="line"><span class="comment">            cout &lt;&lt; nodEdge[i].u &lt;&lt; ' ' &lt;&lt; nodEdge[i].v &lt;&lt; ' ' &lt;&lt; nodEdge[i].val &lt;&lt; '\n' ;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; m ; i++)&#123;</span><br><span class="line">            <span class="comment">/**&lt;debug</span></span><br><span class="line"><span class="comment">            for(int i = 0 ; i &lt; n ; i++)&#123;</span></span><br><span class="line"><span class="comment">                cout &lt;&lt; nodEdge[i].u &lt;&lt; ' ' &lt;&lt; intParent[nodEdge[i].u] &lt;&lt; '\n' ;</span></span><br><span class="line"><span class="comment">                cout &lt;&lt; nodEdge[i].v &lt;&lt; ' ' &lt;&lt; intParent[nodEdge[i].v] &lt;&lt; '\n' ;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            cout &lt;&lt; '\n' ;</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> intRootU , intRootV ;</span><br><span class="line">            intRootU = find_root(nodEdge[i].u);</span><br><span class="line">            intRootV = find_root(intParent[nodEdge[i].v]);</span><br><span class="line">            <span class="keyword">if</span>( intRootU != intRootV)&#123;</span><br><span class="line">                intParent[intRootU] = find_root(intRootV) ;</span><br><span class="line">                <span class="comment">/**&lt; debug</span></span><br><span class="line"><span class="comment">                cout &lt;&lt; "start" &lt;&lt; intParent[mapHash[strStart]] &lt;&lt; ' ' \</span></span><br><span class="line"><span class="comment">                     &lt;&lt; "Destination" &lt;&lt; intParent[mapHash[strDestination]] &lt;&lt; '\n' ;</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(find_root(intParent[mapHash[strStart]]) == find_root(intParent[mapHash[strDestination]]))&#123;</span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Scenario #"</span> &lt;&lt; intCase &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; nodEdge[i].val &lt;&lt; <span class="string">" tons"</span> &lt;&lt; <span class="string">"\n\n"</span>;</span><br><span class="line">                    <span class="keyword">break</span> ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**&lt;debug</span></span><br><span class="line"><span class="comment">        for(int i = 0 ; i &lt; m ; i++)&#123;</span></span><br><span class="line"><span class="comment">            cout &lt;&lt; nodEdge[i].u &lt;&lt; ' ' &lt;&lt; intParent[nodEdge[i].u] &lt;&lt; '\n' ;</span></span><br><span class="line"><span class="comment">            cout &lt;&lt; nodEdge[i].v &lt;&lt; ' ' &lt;&lt; intParent[nodEdge[i].v] &lt;&lt; '\n' ;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        cout &lt;&lt; '\n' ;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>最小生成樹 MST</tag>
        <tag>程式解題</tag>
        <tag>Kruskal&#39;s algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa846 - Steps (數論 Math theorm)</title>
    <url>/2020/03/11/UVa/UVa846/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>給你兩個數字，每次走的步伐必須為上一步的 +1 , -1 , 0 步伐，試問最短的步伐為?</p>
</blockquote>
<a id="more"></a> 

<h2 id="分析"><a href="#分析" class="headerlink" title="分析:"></a>分析:</h2><p><font color= "%dd0000"> <strong>數學題。</strong> </font></p>
<p>設第一個數字為 x ，第二個數字為 y<br>最好的情況為 x+1 , x+2 , …. , r , y-3 , y-2 , y-1<br>數列看起來相似於 <font color= "%dd0000"> 梯形公式 </font></p>
<p>以此得出策略為 &rarr; 每次將 n * 2 ( n 為上一步的 +1)</p>
<p>圖示如下:</p>
<ul>
<li><code>1 2 3 2 1</code> 轉變為 <code>2 3 2</code></li>
</ul>
<p>以此類推，透過這種方式每一次的 Step += 2</p>
<h3 id="額外注意"><a href="#額外注意" class="headerlink" title="額外注意:"></a>額外注意:</h3><ul>
<li><p><code>4 5 4</code><br>將 4 刪除掉後，剩下 5 ，程式在下一次操作時，則會刪除掉兩個 5 ，但實際題目並沒有兩個 5 ，需要加上額外判斷</p>
<p>如果 只有一個 5 時 則 step += 1 </p>
</li>
<li><p><code>4 4</code><br>將 4 刪除掉後，並沒有剩下任何東西，則下次會刪除兩個 5 ，但實際題目並沒有 5 ，所以不增加 Step 直接輸出</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> intCase , x , y , intStep , intDistance , intSum , intLength ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; intCase ;</span><br><span class="line">    <span class="keyword">while</span>(intCase--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y ; </span><br><span class="line">        intStep = <span class="number">0</span> ;</span><br><span class="line">        intDistance = y - x ;</span><br><span class="line">        intSum = <span class="number">0</span> ;</span><br><span class="line">        intLength = <span class="number">0</span> ;</span><br><span class="line">        <span class="comment">//debug</span></span><br><span class="line">        <span class="comment">//cout &lt;&lt; intDistance &lt;&lt; '\n' &lt;&lt; '\n' ;</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        if(intDistance == 1)&#123;</span></span><br><span class="line"><span class="comment">            cout &lt;&lt; 1 &lt;&lt; '\n' ;</span></span><br><span class="line"><span class="comment">            continue ;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       </span><br><span class="line">        <span class="keyword">while</span>(++intLength)&#123;</span><br><span class="line">            <span class="keyword">if</span>(intSum + intLength * <span class="number">2</span> &gt; intDistance)</span><br><span class="line">                <span class="keyword">break</span> ;</span><br><span class="line">            intSum += intLength * <span class="number">2</span> ;</span><br><span class="line">            intStep +=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//debug</span></span><br><span class="line">        <span class="comment">//cout &lt;&lt; "intLength: " &lt;&lt; intLength &lt;&lt; '\n' ;</span></span><br><span class="line">        <span class="comment">//cout &lt;&lt; "intSum: " &lt;&lt; intSum &lt;&lt; '\n' ;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(intSum + intLength &lt; intDistance)</span><br><span class="line">            intStep += <span class="number">2</span> ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (intSum != intDistance )</span><br><span class="line">            intStep ++ ;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; intStep &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>數論 Math theorm</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa679 - Dropping Balls (tree)</title>
    <url>/2020/03/08/UVa/UVa679/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>有一顆二元樹，每次走訪會經過走訪次數最小的 node直到leaf node<br>試問在經過 x 次走訪後將會走到哪個 leaf node ?</p>
</blockquote>
<a id="more"></a> 

<h2 id="分析"><a href="#分析" class="headerlink" title="分析:"></a>分析:</h2><ol>
<li>寫樹模擬 -&gt; TLE!</li>
<li>依循規則找出規律 -&gt; AC!</li>
</ol>
<p>舉例： 假設 D 為 3 , I 為 3</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">     1                 </span><br><span class="line">   &#x2F;   \               </span><br><span class="line">  2     3              </span><br><span class="line"> &#x2F; \  &#x2F;  \             </span><br><span class="line">4  5  6  7</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">node</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">6</th>
<th align="center">7</th>
</tr>
</thead>
<tbody><tr>
<td align="center">num of time 1</td>
<td align="center">T</td>
<td align="center">T</td>
<td align="center"></td>
<td align="center">T</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">num of time 2</td>
<td align="center">T</td>
<td align="center"></td>
<td align="center">T</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">T</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">num of time 3</td>
<td align="center">T</td>
<td align="center">T</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">T</td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<blockquote>
<p>看得出來嗎?</p>
<p>在深度為 2 時:<br>當 I 為奇數時， 必定會經過數字 2<br>當 I 為偶數時， 必定會經過數字 3</p>
<p>已此類推，找到它的規律了! </p>
</blockquote>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 奇數則往左邊<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  ↗  <br>             
我每次將 I /2 後商數為&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  ↘<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 偶數則往右邊 <br>
<br>                

<p>但要記住的是，當 I /2 = 奇數時，之後在實際走訪時 要變成 (I + 1) /2 以預防 ( I = 1 ) / 2 = 0 的冏境<br>(會導致每一次的走訪都會走至另一邊)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> intCase , D , I , intNow ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; intCase ;</span><br><span class="line">    <span class="keyword">while</span>(intCase--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; D &gt;&gt; I ;</span><br><span class="line">        intNow = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; D ; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(I % <span class="number">2</span> )&#123;</span><br><span class="line">                intNow = intNow * <span class="number">2</span> ;</span><br><span class="line">                I = (I+<span class="number">1</span>) /<span class="number">2</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                intNow = intNow * <span class="number">2</span> +<span class="number">1</span> ;</span><br><span class="line">                I /= <span class="number">2</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; intNow &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>binary tree</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>Uva10420 - List of Conquests (水題)</title>
    <url>/2020/03/17/UVa/Uva10420/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意:"></a>題目大意:</h2><blockquote>
<p>給你 n 行話，第一個空白前是國家名，之後則全是人名。</p>
<p>非常水題，考你 string 語法熟不熟 <font color = "dd0000"> (寫 py 的孩子們，一定會很討厭吧www) </font></p>
</blockquote>
<a id="more"></a> 

<h2 id="分析"><a href="#分析" class="headerlink" title="分析:"></a>分析:</h2><p>dict 解決一切，還可以靠著 dict 紅黑樹，自動把資料排序完。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> );</span><br><span class="line">    freopen(<span class="string">"out.txt"</span> , <span class="string">"w"</span> , <span class="built_in">stdout</span> );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">int</span> n , p ;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span> , <span class="keyword">int</span> &gt; MapCountry ;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span> , <span class="keyword">int</span>&gt; MapName ;</span><br><span class="line">    <span class="built_in">string</span> strLine , strCountry , strName ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">    <span class="built_in">cin</span>.ignore() ;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        getline(<span class="built_in">cin</span> , strLine) ;</span><br><span class="line">        p = strLine.find(<span class="string">' '</span>) ;</span><br><span class="line">        strCountry = strLine.substr(<span class="number">0</span> , p ) ;</span><br><span class="line">        strName = strLine.substr(p+<span class="number">1</span> , strLine.length() ) ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//debug</span></span><br><span class="line">        <span class="comment">//cout &lt;&lt; strName &lt;&lt; ' ' &lt;&lt; strCountry &lt;&lt; '\n' ;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(MapCountry[strCountry])</span><br><span class="line">            MapCountry[strCountry]++ ;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            MapCountry[strCountry] = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">if</span>(!MapName[strName])</span><br><span class="line">            MapName[strName] = <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it : MapCountry )</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; it.first &lt;&lt; <span class="string">' '</span> &lt;&lt; it.second &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>水題</tag>
        <tag>UVa</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa929 - Number Maze (Dijkstra)</title>
    <url>/2020/03/11/UVa/UVa929/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>從左上角開始走，走至右下角，最短路徑為多少?</p>
</blockquote>
<a id="more"></a> 

<h2 id="分析"><a href="#分析" class="headerlink" title="分析:"></a>分析:</h2><p><font color= "%dd0000"> <strong><del>傻孩子都看的出來是用 Dijkstra’s 吧?</del></strong> </font></p>
<p><a href="https://zh.wikipedia.org/wiki/%E6%88%B4%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">戴克斯特拉演算法( Dijkstra’s algorithm ) from wiki </a> 使用類似廣度優先搜尋的方法解決賦權圖的單源最短路徑問題</p>
<p>如果是初學者，可以看看 <a href="https://www.youtube.com/channel/UCZCFT11CWBi3MHNlGf019nw" target="_blank" rel="noopener">Abdul Bari</a> 大神的影片，他總是可以把很玄的演算法(algorithm)，講到連小孩子都聽得懂，常讓我覺得要是我也有這麼聰明的頭腦就好了(唉</p>
<h3 id="額外注意"><a href="#額外注意" class="headerlink" title="額外注意:"></a>額外注意:</h3><p>Dijkstra’s algorithm 的問題在於他會有機率性重複回到某點搜尋(在搜尋過程中找到比原先更好的權重)，會造成效率大幅下降，此題必須使用 <a href="http://alrightchiu.github.io/SecondRound/priority-queueintrojian-jie.html" target="_blank" rel="noopener">優先隊列( Priority Queue)</a> 透過最小堆積樹 (Min Heap) 加速(否則會吃 TLE ， 小弟我就被搞了很久，甚至還複習了一下 c++ priority_queue 怎麼寫www)</p>
<h3 id="影片教學"><a href="#影片教學" class="headerlink" title="影片教學:"></a>影片教學:</h3><p><a href="https://www.youtube.com/watch?v=XB4MIexjvY0&t=316s&ab_channel=AbdulBari" target="_blank" rel="noopener">戴克斯特拉演算法( Dijkstra’s algorithm ) from Abdul Bari </a></p>
<p><a href="https://www.youtube.com/watch?v=HqPJF2L5h9U" target="_blank" rel="noopener">Heap - Heap Sort - Heapify - Priority Queues from Abdul Bari </a></p>
<p>我私心很喜歡他，於是放一張大神的圖片</p>
<img src="https://i.udemycdn.com/user/200_H/27878376_ce40_3.jpg" alt="Abdul Bari.jpg" >

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 99999999</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> intMap[<span class="number">1010</span>][<span class="number">1010</span>] = &#123;&#125; , intValue[<span class="number">1010</span>][<span class="number">1010</span>] = &#123;&#125;;</span><br><span class="line"><span class="keyword">int</span> m , n ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x , y , v ;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">( <span class="keyword">int</span> _x , <span class="keyword">int</span> _y , <span class="keyword">int</span> _v)</span></span>&#123;</span><br><span class="line">        x = _x ; y = _y ; v = _v ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp;a) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v &gt; a.v ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;nodNode;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_map</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= m ; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(intValue[i][j] == <span class="number">99999999</span>)</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">'r'</span> &lt;&lt; <span class="string">' '</span> ;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; intValue[i][j] &lt;&lt; <span class="string">' '</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x , y , intDirection[<span class="number">4</span>][<span class="number">2</span>] = &#123;<span class="number">-1</span>,<span class="number">0</span> ,<span class="number">0</span>,<span class="number">1</span> ,<span class="number">1</span>,<span class="number">0</span> ,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> intDx , intDy ;</span><br><span class="line">    Node nodTemp ;</span><br><span class="line">    priority_queue&lt;Node&gt; deqNode ;</span><br><span class="line">    nodTemp.read(<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    deqNode.push(nodTemp);</span><br><span class="line">    <span class="keyword">while</span>(deqNode.size())&#123;</span><br><span class="line">        x = deqNode.top().x ;</span><br><span class="line">        y = deqNode.top().y ;</span><br><span class="line">        deqNode.pop() ;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">4</span> ; i++)&#123;</span><br><span class="line">            intDx = intDirection[i][<span class="number">0</span>] + x ;</span><br><span class="line">            intDy = intDirection[i][<span class="number">1</span>] + y ;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//debug</span></span><br><span class="line">            <span class="comment">//cout &lt;&lt; intDx &lt;&lt; ' ' &lt;&lt; intDy &lt;&lt; ' ' &lt;&lt; intValue[x][y] + intMap[intDx][intDy] &lt;&lt; ' ' &lt;&lt; i &lt;&lt;  '\n' ;</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(intValue[x][y] + intMap[intDx][intDy] &lt; intValue[intDx][intDy]  )&#123;</span><br><span class="line">                intValue[intDx][intDy] = intValue[x][y] + intMap[intDx][intDy] ;</span><br><span class="line">                nodTemp.read(intDx , intDy , intValue[intDx][intDy]);</span><br><span class="line">                deqNode.push(nodTemp) ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//print_map() ;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> );</span><br><span class="line">    freopen(<span class="string">"out.txt"</span> , <span class="string">"w"</span> , <span class="built_in">stdout</span>) ;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">int</span> intCase ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; intCase ;</span><br><span class="line">    <span class="keyword">while</span>(intCase --)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= m ; j++)&#123;</span><br><span class="line">                 <span class="built_in">cin</span> &gt;&gt; intMap[i][j] ;</span><br><span class="line">                intValue[i][j] = INF ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; i++)&#123;</span><br><span class="line">            intValue[i][<span class="number">0</span>] = <span class="number">0</span> ;</span><br><span class="line">            intValue[i][m+<span class="number">1</span>] = <span class="number">0</span> ;</span><br><span class="line">            intMap[i][<span class="number">0</span>] = INF +<span class="number">1</span> ;</span><br><span class="line">            intMap[i][m+<span class="number">1</span>] = INF +<span class="number">1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; i++)&#123;</span><br><span class="line">            intValue[<span class="number">0</span>][i] = <span class="number">0</span> ;</span><br><span class="line">            intValue[n+<span class="number">1</span>][i] = <span class="number">0</span> ;</span><br><span class="line">            intMap[<span class="number">0</span>][i] = INF +<span class="number">1</span> ;</span><br><span class="line">            intMap[n+<span class="number">1</span>][i] = INF +<span class="number">1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        intValue[<span class="number">1</span>][<span class="number">1</span>] = intMap[<span class="number">1</span>][<span class="number">1</span>] ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//debug</span></span><br><span class="line">        <span class="comment">//cout &lt;&lt; intValue[1][1] &lt;&lt; '\n' ;</span></span><br><span class="line"></span><br><span class="line">        bfs();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; intValue[n][m] &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>圖論</tag>
        <tag>UVa</tag>
        <tag>Dijkstra&#39;s</tag>
        <tag>優先隊列</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>Uva11456 - Trainsorting (LIS)</title>
    <url>/2020/03/19/UVa/Uva11456/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意:"></a>題目大意:</h2><blockquote>
<p>有一台火車， x 輛汽車，目的是要讓火車上載滿最多汽車 (可以選擇不要加入這台汽車)，且要排序。</p>
<p>值得注意的是我們只能從前面或後面新增，火車是沒辦法讓我們從中間插入的，試問最多可以載幾台汽車？</p>
</blockquote>
<a id="more"></a>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析:"></a>分析:</h2><p>naivered 大大跟天才一樣，我都沒有想到可以前後面都增加，由於數字不會重複的特性，可以這樣子使用！</p>
<h3 id="舉例"><a href="#舉例" class="headerlink" title="舉例:"></a>舉例:</h3><p>1 2 3 4 =&gt; 4 3 2 1 1 2 3 4</p>
<p>分解成最初狀態後則:</p>
<p>1 =&gt; 1<br>2 =&gt; 2 1 2 </p>
<p>2 這樣子可以假設到加入前面與後面 (由於數字不會重複)</p>
<p>接著就算 <a href="http://www.csie.ntnu.edu.tw/~u91029/LongestIncreasingSubsequence.html" target="_blank" rel="noopener">LIS (之前我很喜歡看的演算法教學文章)</a> 即可。</p>
<h2 id="備註"><a href="#備註" class="headerlink" title="備註:"></a>備註:</h2><p>要是我寫得不好，就去看這位 <a href="http://naivered.github.io/2018/03/04/Problem_Solving/UVa/UVa-11456-Trainsorting/" target="_blank" rel="noopener">naivered</a> 大神這題的教學文，十分好理解</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"out.txt"</span> , <span class="string">"w"</span> , <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">int</span> intCase , n , intPosition ;</span><br><span class="line">    <span class="built_in">string</span> strWord , strAns , strLine ;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vecAns ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; intCase ;</span><br><span class="line">    n = <span class="number">1</span> ;</span><br><span class="line">    getline(<span class="built_in">cin</span> , strLine ) ;</span><br><span class="line">    getline(<span class="built_in">cin</span> , strLine ) ;</span><br><span class="line">    <span class="keyword">while</span>(getline(<span class="built_in">cin</span> , strLine ))&#123;</span><br><span class="line">        <span class="comment">//debug</span></span><br><span class="line">        <span class="comment">//cout &lt;&lt; strLine &lt;&lt; '\n' ;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(strLine != <span class="string">""</span>)&#123;</span><br><span class="line">            <span class="built_in">stringstream</span> ss ;</span><br><span class="line">            ss.str(<span class="string">""</span>);</span><br><span class="line">            ss.<span class="built_in">clear</span>() ;</span><br><span class="line">            ss &lt;&lt; strLine ;</span><br><span class="line">            intPosition = <span class="number">0</span> ;</span><br><span class="line">            strAns = <span class="string">""</span> ;</span><br><span class="line">            <span class="keyword">while</span>(ss &gt;&gt; strWord)&#123;</span><br><span class="line">                <span class="comment">//debug-</span></span><br><span class="line">                <span class="comment">//cout &lt;&lt; strWord &lt;&lt; '\n' ;</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(strWord.length() &gt; intPosition)&#123;</span><br><span class="line">                    strAns += strWord[intPosition++] ;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//debug</span></span><br><span class="line">                    <span class="comment">//cout &lt;&lt; strAns &lt;&lt; '\n' ;</span></span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            vecAns.push_back(strAns) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Case #"</span> &lt;&lt; n++ &lt;&lt; <span class="string">":"</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; vecAns.<span class="built_in">size</span>()<span class="number">-1</span> ; i++)</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; vecAns[i] &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; vecAns[vecAns.<span class="built_in">size</span>()<span class="number">-1</span>] ;</span><br><span class="line">            <span class="keyword">if</span>(n<span class="number">-1</span> != intCase)</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">            vecAns.<span class="built_in">clear</span>() ;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>LIS 最長遞增子序列</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>Uva11987 - Almost Union-Find (Disjoint Set)</title>
    <url>/2020/03/23/UVa/Uva11987/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>並查集，有三種操作</p>
<ol>
<li>Union: 把 x , y 加入同一集合</li>
<li>Move:  將 x 移動到 y 集合</li>
<li>Return:將 x 的集合總和，與多少元素</li>
</ol>
</blockquote>
<a id="more"></a>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析:"></a>分析:</h2><p>老實講，其實沒有很難，第二點比較特殊，我直接進行改點。</p>
<p>有個地方比較麻煩，算總和跟多少元素，原本是想要每一次都掃描陣列，發現會 TLE (廢話，但是作者太爛不知道阿<del>~</del>)</p>
<p>所以開陣列並在做 Union , Move 操作時，順便紀錄集合總和與內部元素。</p>
<h2 id="備註："><a href="#備註：" class="headerlink" title="備註："></a>備註：</h2><p>如果還不懂 disjoint set 的可以看<a href="https://theriseofdavid.github.io/\2021/02/02/Explain_Algorithm/disjoint-set/" target="_blank" rel="noopener">演算法知識 - Disjoint Set 並查集</a>或<a href="https://www.youtube.com/watch?v=wU6udHRIkcc" target="_blank" rel="noopener">Abdul Bari</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> intSum[<span class="number">200080</span>] , intParent[<span class="number">200080</span>] , intSet[<span class="number">200080</span>] ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_root</span><span class="params">(<span class="keyword">int</span> intA)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(intParent[intA] == intA)</span><br><span class="line">        <span class="keyword">return</span> intA ;</span><br><span class="line">    intParent[intA] = find_root(intParent[intA]) ;</span><br><span class="line">    <span class="keyword">return</span> intParent[intA] ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">each_debug</span><span class="params">(<span class="keyword">int</span> n )</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; i++)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">' '</span> &lt;&lt; intParent[i] &lt;&lt; <span class="string">' '</span>  \</span><br><span class="line">            &lt;&lt; intSet[find_root(i)] &lt;&lt; <span class="string">' '</span> &lt;&lt; intSum[find_root(i)] &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    system(<span class="string">"Pause"</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>,<span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"out.txt"</span> ,<span class="string">"w"</span> , <span class="built_in">stdout</span>) ;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n, m , operation , p , q  ;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; i++)&#123;</span><br><span class="line">            intParent[i] = i+n ;</span><br><span class="line">            intParent[i+n] = i+n ;</span><br><span class="line">            intSum[i+n] = i;</span><br><span class="line">            intSet[i+n] = <span class="number">1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; operation ;</span><br><span class="line">            <span class="keyword">if</span>(operation == <span class="number">1</span> )&#123;</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; p &gt;&gt; q ;</span><br><span class="line">                <span class="keyword">int</span> intRoot_p , intRoot_q ;</span><br><span class="line">                intRoot_p = find_root(intParent[p]) ;</span><br><span class="line">                intRoot_q = find_root(intParent[q]) ;</span><br><span class="line">                <span class="keyword">if</span>(intRoot_p != intRoot_q)&#123;</span><br><span class="line">                    intParent[intRoot_q] = intRoot_p ;</span><br><span class="line">                    intSum[intRoot_p] += intSum[intRoot_q] ;</span><br><span class="line">                    intSet[intRoot_p] += intSet[intRoot_q] ;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//debug</span></span><br><span class="line">                <span class="comment">//each_debug(n) ;</span></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (operation == <span class="number">2</span> )&#123;</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; p &gt;&gt; q ;</span><br><span class="line">                <span class="keyword">int</span> intRoot_p , intRoot_q ;</span><br><span class="line">                intRoot_p = find_root(intParent[p]) ;</span><br><span class="line">                intRoot_q = find_root(intParent[q]) ;</span><br><span class="line">                <span class="keyword">if</span>(intRoot_p != intRoot_q)&#123;</span><br><span class="line">                    intParent[p] = intRoot_q ;</span><br><span class="line">                    intSum[intRoot_q] += p ;</span><br><span class="line">                    intSum[intRoot_p] -= p ;</span><br><span class="line">                    intSet[intRoot_q] ++ ;</span><br><span class="line">                    intSet[intRoot_p] -- ;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//debug</span></span><br><span class="line">                <span class="comment">//each_debug(n) ;</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (operation == <span class="number">3</span>)&#123;</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; p ;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; intSet[find_root(p)] &lt;&lt; <span class="string">' '</span> &lt;&lt; intSum[find_root(p)] &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>Disjoint Set 並查集</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>部落格編排格式</title>
    <url>/2020/07/20/blog/blog-format/</url>
    <content><![CDATA[<h2 id="主要內容"><a href="#主要內容" class="headerlink" title="主要內容"></a>主要內容</h2><blockquote>
<p>礙於我每次寫完文章後，過一個月後總會對自己過去編排不滿意，於是我現在特此寫一篇文章來規定自己的部落格編排模式</p>
</blockquote>
<a id="more"></a>

<h2 id="關於全-BLOG"><a href="#關於全-BLOG" class="headerlink" title="關於全 BLOG"></a>關於全 BLOG</h2><ul>
<li>大標題必定都是使用 兩個 tag(##)</li>
<li>要先觀看 blog 的 tag 內容有哪些選擇後並加入</li>
<li>如果清單並沒有要用數字清單，如 1. 2. 3.，請先使用 * 在使用 - </li>
<li>寫完文章後，通常在最底下用一標題來寫心得，如 ##心得</li>
<li>通常每個 分類 他也都是一個 tag，需要注意</li>
<li>必須記得加入 !– more – ，需要再 - 旁加入&lt;&gt;</li>
<li>只要是數字、中文、英文切換，必定都要先透過空白來增加排版觀看度，但如果遇到標點符號則不用</li>
<li>如果要本地新增圖片 使用 <img src="%E6%9C%AC%E5%9C%B0%E8%B7%AF%E5%BE%91" alt=""> </li>
</ul>
<h2 id="關於解題程式"><a href="#關於解題程式" class="headerlink" title="關於解題程式"></a>關於解題程式</h2><ul>
<li>必要兩個章節<ol>
<li>題目大意：</li>
<li>分析：</li>
</ol>
</li>
<li>需放入程式碼</li>
</ul>
<h2 id="將-blog-當作字典時"><a href="#將-blog-當作字典時" class="headerlink" title="將 blog 當作字典時"></a>將 blog 當作字典時</h2><ul>
<li>必要一個章節<ol>
<li>主要內容</li>
</ol>
</li>
</ul>
<h2 id="關於需要更新的文章時"><a href="#關於需要更新的文章時" class="headerlink" title="關於需要更新的文章時"></a>關於需要更新的文章時</h2><ul>
<li>需加入一章節<ol>
<li>更新日誌，格式為 yyyy-mm-dd hh:mm:ss - 內容</li>
</ol>
</li>
</ul>
<h2 id="關於自己的心得"><a href="#關於自己的心得" class="headerlink" title="關於自己的心得"></a>關於自己的心得</h2><ul>
<li>必須加入 TAG ，人生紀錄</li>
</ul>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>人生旅途</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo d -g 指令錯誤 Deployer not found</title>
    <url>/2020/07/11/blog/hexo-d-g-error-to-deployer-not-found/</url>
    <content><![CDATA[<blockquote>
<p>當你在使用 hexo 建置屬於你的 Blog 時，發生 Deploy not found : git 的解決方式</p>
</blockquote>
<a id="more"></a>

<h2 id="問題描述"><a href="#問題描述" class="headerlink" title="問題描述"></a>問題描述</h2><p>我有在外層的 config.yml 加入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: </span><br><span class="line">    github: https:&#x2F;&#x2F;github.com&#x2F;XXX&#x2F;XXX.github.io.git</span><br></pre></td></tr></table></figure>
<p>但是在執行 <code>hexo d -g</code>時發生錯誤</p>
<h2 id="解決方法"><a href="#解決方法" class="headerlink" title="解決方法"></a>解決方法</h2><p>由於缺少 <code>hexo-deployer-git</code> 套件，在當前目錄安裝套件即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<p>接下來再使用 <code>hexo d -g</code> 就可以成功推送了！<br>很簡單對巴~</p>
<p><a href="https://blog.csdn.net/qq_21808961/article/details/84476504" target="_blank" rel="noopener">參考來源</a></p>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>大學程式能力檢定 CPE 2020/06/09 心得</title>
    <url>/2020/06/15/contest_experence/CPE20200609/</url>
    <content><![CDATA[<blockquote>
<p>僅此記錄在 2020/06/09 CPE 程式設計心得</p>
</blockquote>
<a id="more"></a>

<h2 id="國北教，連走路都能感受到青春的氣息"><a href="#國北教，連走路都能感受到青春的氣息" class="headerlink" title="國北教，連走路都能感受到青春的氣息"></a>國北教，連走路都能感受到青春的氣息</h2><p>09 日的下午三點，我在北市大旁的燒肉便當店用餐，便當普通，接著我進入國北教準備進入 CPE 的場地，由於武漢疫情的關係，大學有了出入管制，當我一進去大門時，就向駐警致意我是要來參加 CPE ，駐警先讓我填了一張居家、身體健康調查表，我就順利的進入國北教。當我進入國北教時，在往視聽館 (即 CPE 考試場所)，沿途上我都沒有看到任何男生。對於我高職、大學都在工科環境下長大，這還是我第一次看到一間大學會有那麼多的女生阿…，現在轉學還來的及嗎XD!</p>
<h2 id="考場前的準備"><a href="#考場前的準備" class="headerlink" title="考場前的準備"></a>考場前的準備</h2><p>老實說，那天我的狀態是不好的。<br>我的眼睛只要看到螢幕就會變得模糊，應該是最近用眼過度了，因為之前接了太多專案使自己壓力太大，導致我那天的精神狀況並不好、稍加疲累，但不得不稱讚的是，國北教的電腦設備比起北科資財系好蠻多的，不管是教室明亮度、電腦設備都比起我們系上好很多，老實說蠻喜歡的。但有一個很大缺點，對於左撇子的人並不有善，我坐在靠牆的位置，他的距離給得並不好，我的左手非常容易撞到牆壁，並不舒服。</p>
<p>我旁邊的朋友是一位師大大三的學長，他考第二次了，感覺他的能力蠻強。但她比較內向，我曾向他搭話幾句但她都是給著類程式的回應句，但她 CPE 成績挺不錯的，寫了 6 題。</p>
<h2 id="考試題目"><a href="#考試題目" class="headerlink" title="考試題目"></a>考試題目</h2><h4 id="Problem-A-11498-Division-of-Nlogonia-失敗"><a href="#Problem-A-11498-Division-of-Nlogonia-失敗" class="headerlink" title="Problem A 11498 Division of Nlogonia　失敗"></a>Problem A 11498 Division of Nlogonia　失敗</h4><p>當時的我</p>
<ul>
<li>由於我不想看長長的英文，我直接看 Input and Output，猜測題目再講甚麼，就直接寫了，但後來好像發現他其實是向量的感覺? 我想應該是我理解錯題目了</li>
</ul>
<p>現在的我</p>
<ul>
<li>待述</li>
</ul>
<h4 id="Problem-B-10189-Minesweeper-AC"><a href="#Problem-B-10189-Minesweeper-AC" class="headerlink" title="Problem B 10189 Minesweeper AC"></a>Problem B 10189 Minesweeper AC</h4><p>當時的我</p>
<ul>
<li>踩地雷，把地雷的旁邊格數都 +1，這題花了半小時寫。</li>
</ul>
<h4 id="Problem-C-1368-DNA-Consensus-String-未提交、找出-Bug"><a href="#Problem-C-1368-DNA-Consensus-String-未提交、找出-Bug" class="headerlink" title="Problem C 1368 DNA Consensus String 未提交、找出 Bug"></a>Problem C 1368 DNA Consensus String 未提交、找出 Bug</h4><p>當時的我</p>
<ul>
<li>他給與我們 N 個長度一樣字串，然後在每個字串的第 X 字元找出哪個英文字母是最多，並輸出，且紀錄非最多英文字母的其他字母出現次數，然後輸出。這題有一個很大的坑，是讓我這次只有寫兩題的最大問題，<strong>瘋狂成社沒辦法將字串陣列放在全域！</strong>，下面進行補述。</li>
</ul>
<p>現在的我</p>
<ul>
<li>待述</li>
</ul>
<h4 id="Problem-D-855-Lunch-in-Grid-City-未嘗試撰寫"><a href="#Problem-D-855-Lunch-in-Grid-City-未嘗試撰寫" class="headerlink" title="Problem D 855 Lunch in Grid City 未嘗試撰寫"></a>Problem D 855 Lunch in Grid City 未嘗試撰寫</h4><p>當時的我</p>
<ul>
<li>給你很多點，請將其中的一個點設為中心點，讓其他點到中心點的距離為最短。當時看到沒有頭緒，選擇直接跳過。直覺是需將程式碼寫得十分攏長，於是直接略過。</li>
</ul>
<p>現在的我</p>
<ul>
<li>待述</li>
</ul>
<h4 id="Problem-E-10191-Longest-Nap-AC"><a href="#Problem-E-10191-Longest-Nap-AC" class="headerlink" title="Problem E 10191 Longest Nap AC"></a>Problem E 10191 Longest Nap AC</h4><p>當時的我</p>
<ul>
<li>教授有固定的上班時間，請您找出它可以在上班時間可以休息的最大時間。</li>
<li>想法：最長區間覆蓋長，輕輕鬆鬆，花了半小時寫。</li>
</ul>
<h4 id="Problem-F-10130-SuperSale-未嘗試撰寫"><a href="#Problem-F-10130-SuperSale-未嘗試撰寫" class="headerlink" title="Problem F 10130 SuperSale 未嘗試撰寫"></a>Problem F 10130 SuperSale 未嘗試撰寫</h4><p>當時的我</p>
<ul>
<li>背包問題再給一些變化</li>
</ul>
<p>現在的我</p>
<ul>
<li>待述</li>
</ul>
<h4 id="Problem-G-10583-Ubiquitous-Religions-未嘗試撰寫"><a href="#Problem-G-10583-Ubiquitous-Religions-未嘗試撰寫" class="headerlink" title="Problem G 10583 Ubiquitous Religions 未嘗試撰寫"></a>Problem G 10583 Ubiquitous Religions 未嘗試撰寫</h4><p>當時的我</p>
<ul>
<li>連題目都沒看，到時候在補</li>
</ul>
<p>現在的我</p>
<ul>
<li>待述</li>
</ul>
<h2 id="瘋狂成設，我一生的敵人"><a href="#瘋狂成設，我一生的敵人" class="headerlink" title="瘋狂成設，我一生的敵人"></a>瘋狂成設，我一生的敵人</h2><p>「瘋狂成設是最爛的 IDE」，考完後的我真心對他超級不爽。<br>原因如下：</p>
<ol>
<li><p>無法 Debug<br> 雖然我本來就已經對 Debug 無感，已經習慣 cout &gt;&gt; “Hello World!\n” ; ，但她在執行編譯再啟動後的語法錯誤提示十分不直觀，與 Code Block 比較下，我需要花很多時間去思考哪裡語法錯誤。</p>
</li>
<li><p>沒有提示<br>這點對我就特別重要了！因為我並不是天天寫 C++ 這門語言，我其他的專案用的是其他語言，沒辦法完全記的起 C++ 全部語法，時常會忘記一些單字。很需要提示來告訴我，我要用這個語法，我將舉例一個因為沒有提示而讓我花費許多時間去找出這個語法。 EX: string.subString (ERROR) =&gt; string.substr (RIGHT)</p>
</li>
<li><p>不方便 Debug<br>這我後來有逐漸克服與習慣，但前期我在印出來時，由於他的輸出區都在左側且排版不友善，需要花點時間習慣。</p>
</li>
<li><p><font color ="#dd0000"> ** String 陣列不能放在 global **</font><br>這點我就很納悶了，我在寫 1368 DNA Consensus String 時，在 cin 字串時，發現如果你將 String 陣列放在 global 且字串陣列 index 為 5 時，就再也沒辦法 cin 進去了！我原本認為這邊 cin 字串是最簡單並且我不可能錯的，所以我從來都不曾在這邊 Debug ，直到我在也想不出來我其他地方有 Bug 時，回頭檢查 cin 才找到 Bug !!!!! 這讓我當下十分生氣、十分無力且頭痛，一點都不想再碰瘋狂成設，因為他太難用、有地雷，再來她從來都沒跑出關於 ERROR 訊息!!!! 希望未來可以廢除瘋狂成設，非常感謝主辦方明智的選擇。也或許是只有我那台的電腦也說不定，還希望有其他人可以幫我認證。</p>
</li>
</ol>
<h2 id="檢討"><a href="#檢討" class="headerlink" title="檢討"></a>檢討</h2><p>如果你想要將 CPE 考好，我認為我需要再補強我對於英文的耐性與閱讀英文能力，我的英文能力還需要再加強，我旁邊的師大朋友看完一題的英文題目時，我才看到一半，再來，我認為我需要再將瘋狂成設熟練，畢竟我們是檢定的學生沒有權力可以請主辦方改變 CPE，只能希望主辦方意識到瘋狂成設的問題。那便是我最大的榮幸。</p>
<h2 id="更新日誌"><a href="#更新日誌" class="headerlink" title="更新日誌"></a>更新日誌</h2><p>2020-06-15 14:27:24 - 寫完 CPE 心得</p>
]]></content>
      <categories>
        <category>競賽心得</category>
      </categories>
      <tags>
        <tag>大學Life</tag>
        <tag>程式比賽</tag>
        <tag>競賽心得</tag>
        <tag>人生旅途</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 Hexo 搭建 Blog</title>
    <url>/2020/03/09/blog/hexo-install/</url>
    <content><![CDATA[<h2 id="使用Hexo-搭建-Blog"><a href="#使用Hexo-搭建-Blog" class="headerlink" title="使用Hexo 搭建 Blog :"></a>使用Hexo 搭建 Blog :</h2><blockquote>
<p>想怎麼用 Hexo 搭建 Blog 嗎? 那就觀看這篇文章就對喔~</p>
</blockquote>
<a id="more"></a> 

<p><a href="https://medium.com/@bebebobohaha/%E4%BD%BF%E7%94%A8-hexo-gitpage-%E6%90%AD%E5%BB%BA%E5%80%8B%E4%BA%BA-blog-5c6ed52f23db/" target="_blank" rel="noopener"> 如何搭建個人 Blog 使用 Hexo + Gitpage </a></p>
<h2 id="附註"><a href="#附註" class="headerlink" title="附註 :"></a>附註 :</h2><p>假如需要更換主題，且主題需要在透過 node.js 在下載其他套件時，須按照指示安裝。<br>若您將網頁放在 github 需要異地下載時，則需要先透過 git bash 輸入  <code>bash hexo init &lt;folder&gt;</code> ，否則無法成功將網頁呼叫成功。 </p>
<h2 id="此-Blog-使用主題"><a href="#此-Blog-使用主題" class="headerlink" title="此 Blog 使用主題 :"></a>此 Blog 使用主題 :</h2><p><a href="https://shen-yu.gitee.io/2019/ayer/" target="_blank" rel="noopener">Ayer Theme </a></p>
<img src="https://i.loli.net/2019/12/03/SHPinIAclMX1Gra.png" alt="ayer.jpg" >

<br>

<h3 id="tips"><a href="#tips" class="headerlink" title="tips :"></a>tips :</h3><p>這裡放上一些作者之前遇到的問題，且已被解決，感謝原文章的主人分享</p>
<p><font color ="dd0000" > <strong>警告: Node.js 如果沒有放在 C 槽時， Hexo 可能安裝不成功(玄學，小弟我猜是註冊表的原因)</strong></font></p>
<p><a href="https://yaoandy107.github.io/hexo-tutorial/" target="_blank" rel="noopener">Hexo+GitHub，新手也可以快速建立部落格</a>　<br><br><a href="https://wst24365888.github.io/hexo-tags/#%E5%B7%B2%E6%88%90%E5%8A%9F" target="_blank" rel="noopener">分類或標籤因為大小寫問題</a>　<br></p>
<h2 id="注意事項"><a href="#注意事項" class="headerlink" title="注意事項:"></a>注意事項:</h2><ol>
<li>此主題的分類<strong><font color="#dd0000">只能用一個</font></strong></li>
<li>如果 md 檔有空格再丟到外面網域時則無法連結成功</li>
</ol>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>第五屆全國科大程式競賽心得 - 金獎(5th)心得</title>
    <url>/2020/07/08/contest_experence/ncut2020-experience/</url>
    <content><![CDATA[<blockquote>
<p>僅此紀錄 2020/07/08 第五屆全國科大程式競賽心得。<br>「紀錄每個時刻，讓未來的自己不遺忘過去的自己」<br>只有自己才能體會自己的過去<br>獲得了第五屆全國科大程式競賽金獎 (5th)<br><strong>此心得並不包含解題，將額外再另外一篇特別說明</strong></p>
</blockquote>
<a id="more"></a>

<h4 id="名詞解釋"><a href="#名詞解釋" class="headerlink" title="名詞解釋"></a>名詞解釋</h4><ul>
<li>駕駛<br>Coding、上機寫程式</li>
<li>駕駛員<br>駕駛的人員，駕駛為上述意思</li>
</ul>
<h2 id="比賽前的規劃"><a href="#比賽前的規劃" class="headerlink" title="比賽前的規劃"></a>比賽前的規劃</h2><p>比賽前，其實我們每周的一、六晚上都會花 3 小時來學習或複習新的演算法，Bill and Entroy 負責思考題目，當他們將題目思考完畢後交予給我進行 Coding ，看到這裡？有些人可能會有疑惑，那這樣是不是因為我太爛才會讓我來負責寫程式呢？其實不然，主要負責上機寫程式勢必要能夠最快速理解題目與隊友的想法，並抓出隊友的思考盲點並給予想法討論，直到我們想法達成共識後，我在進行 Coding 。</p>
<p>這樣有兩個好處，第一，由於我會與負責思考題目者進行想法討論，有時可以注意到題目思考者沒有注意到的細節，而不導致題目思考者在寫程式寫到一半時或 debug 時才發現自己想法上的漏洞。第二，我們其實有思考過一策略為每個人各自解題，會的就上機撰寫的模式。但我認為每個人都獨自在進行一個解題週期過於浪費時間，也容易使隊友感到疲乏，為甚麼呢？我定義的解題週期如下：</p>
<ol>
<li>看懂題目 -&gt; 閱讀能力</li>
<li>提出想法 -&gt; 透過過去的演算法知識進行思考</li>
<li>思考可行性 -&gt; 程式會不會太難寫、我是不是沒有注意到一些細節</li>
<li>上機撰寫 -&gt; 開始進行撰寫、Debug</li>
<li>解題成功 -&gt; 上傳後 AC</li>
</ol>
<p>我個人在解題目的經驗中，要自己再不休息的情況中重複解題週期至 4 題其實就已經感到疲憊，而其中要是在第四點才發現到一些重大問題時往往需要再回到第三點再來思考到底可不可行，對於腦袋會感到相當的疲憊，於是第二好處則是可以減少每個人的疲憊感，由於每個人進行專業分工了，大家只要在自己所負責的那項做好自己的工作就好，就能完美的分工完成解題週期。但第四點的執行者通常抗壓性要是最大、撰寫程式的能力必須要是全隊最優秀的。</p>
<h2 id="到底要當天去呢？還是提前一天去呢"><a href="#到底要當天去呢？還是提前一天去呢" class="headerlink" title="到底要當天去呢？還是提前一天去呢"></a>到底要當天去呢？還是提前一天去呢</h2><p>先說結論好了，提前一天去。因為我沒去過雲林阿，當然會想要去雲林看看搂。不過其實路途費比我想像的便宜住宿費只要 1280 元(3人房)，高鐵來回票也只要 1160元，有種突然覺得國內旅遊好便宜(不過雲林好像也沒什麼好玩的？哈哈哈哈)，也能給自己一天休息的機會，不會因為比賽早上睡過頭而導致特別敢的狀況發生在<a href="https://theriseofdavid.github.io/2020/03/23/contest_experence/Skill-Contest/" target="_blank" rel="noopener">2018 (107) 學年金手獎技藝競賽程式設計 - 金手第六心得</a>那次印象真的很深刻阿QQ。</p>
<ul>
<li>出發至雲林高鐵站<br><img src="/images/ncut2020_experience/1.jpg" alt=""></li>
</ul>
<h2 id="比賽前一天，緊張的前夕"><a href="#比賽前一天，緊張的前夕" class="headerlink" title="比賽前一天，緊張的前夕"></a>比賽前一天，緊張的前夕</h2><h3 id="漂亮的高鐵-and-疑？-沒有公車嘛！？"><a href="#漂亮的高鐵-and-疑？-沒有公車嘛！？" class="headerlink" title="漂亮的高鐵 and 疑？　沒有公車嘛！？"></a>漂亮的高鐵 and 疑？　沒有公車嘛！？</h3><p>我與隊友們相約在台北車站的南3門，大家都不太會迷路花蠻快的時間就找到了，不愧都讀北科，哈哈哈哈。我們透過高鐵到雲林時已經是 11:39 ，不得不說的是雲林高鐵站真的很漂亮，頗有機場的感覺，雲林縣政府讚讚，但是外面好荒涼QQ，我原本以為會是很熱鬧的地方結果沒有阿，公車客運也不像台北一樣方便，他們的公車反而不太像是公車是路與路之間的距離就一站，比較像是鎮與鎮的距離一站，有夠遠的…。</p>
<h3 id="路途中的小插曲"><a href="#路途中的小插曲" class="headerlink" title="路途中的小插曲"></a>路途中的小插曲</h3><p>後來我們搭計程車從雲林高鐵站到民宿(近虎尾科技大學，布拉格民宿)，這裡有一點跟台北不太一樣，台北的計程車是 70 元開始跳表，但雲林是從 100 開始，一開始有種心痛感，不過因為司機態度蠻不錯的，所以其時多給 30 元我還是可以接受拉，然後搭計程車其實感覺很不錯跟在台北搭計程車的感覺不同，離開了水泥叢林，到了田野間的地方，看著一路上的風景心情也不自覺得好了起來。</p>
<p>抵達民宿大約為 200 元，司機也提醒我說以後可以直接說到家樂福(民宿對面)，司機們都比較好知道地點在倆，到達民宿後我才發現我們可以入房的時間為下午 4 點阿，可是現在的時間是下午 1 點阿，這中間 3 個小時我要怎麼辦阿阿阿阿，這<font color="#dd0000"><strong>提醒以後的我以後住民宿必須先問幾點可以入住</strong></font>，不然的話就會發生跟我一樣的窘境QQ。</p>
<h3 id="小女孩是全世界最可愛的了！"><a href="#小女孩是全世界最可愛的了！" class="headerlink" title="小女孩是全世界最可愛的了！"></a>小女孩是全世界最可愛的了！</h3><p>幸好客服人員願意先讓我們把行李先寄放在民宿那不然我們就要拖著行李箱到處流浪了 ಥ⌣ಥ，樓下有很多夾娃娃機店，其中竟然有一個是夾蓮蓬頭的！有夠酷的，竟然還被我花 10 元夾到我超開心的而且雲林的夾娃娃機店可以夾一堆東西！例如：泡麵、舒跑…等。</p>
<div class="video-container"><iframe src="https://www.youtube.com/embed/evHanigiKq4" frameborder="0" loading="lazy" allowfullscreen></iframe></div>

<p>但是雲林的夾娃娃機店比便利商店還多很多害我很意外，還是雲林人如果家裡沒東西都是跑去夾娃娃機夾而不是去便利商店買阿XD。然後雲林縣立仁國小校舍好漂亮阿，害我也好想進去裡面就讀，然後小女孩真的是世界上最可愛的生物了٩(^ᴗ^)۶，不管是哪裡的小女孩。</p>
<h3 id="看完虎尾反觀北科？"><a href="#看完虎尾反觀北科？" class="headerlink" title="看完虎尾反觀北科？"></a>看完虎尾反觀北科？</h3><p>之後我們走到虎尾科技大學去參訪，虎尾科大比起台北科大來說大了許多，北科看起來真的就像小學一樣，而且他們還可以把機車停到校園裡面去真的是太棒了！北科甚麼時候也要跟進阿，外面的停車位還有夠難找的，我的愛車都被刮了 n 遍了 ಠ︵ಠ。不過他們廁所我覺得就沒有比北科好了，我們北科的廁所真的是非常漂亮 and 非常乾淨阿！每間廁所還都會有衛生紙，要是希望自己的廁所 always 都是乾淨的就來讀北科大吧！(<del>業配</del>)，開玩笑這是我的 Blog 幹嘛還要業配阿。</p>
<h3 id="雲林的夜生活"><a href="#雲林的夜生活" class="headerlink" title="雲林的夜生活"></a>雲林的夜生活</h3><p>回來的路上我們還去 KTV 唱歌 and 喝酒，這在高中的我不可能會這樣做的，考前就是要完全的嚴肅和認真準備阿，不過我的兩個隊友似乎不這麼覺得，來比賽還是要來體驗一下雲林的生活阿。我這次竟然下來雲林都沒有看程式阿…，罪惡感好重，不過 Entroy 唱歌真的很好聽，找他唱歌真得棒。</p>
<p>我們住的套房似乎是愛情套房，一進來就有一隻粉紅大熊，好可愛，我一直抱著他好想就這樣把她帶回家喔，對於分手後的我算是很大的精神安慰了 ಠ︵ಠ，然後這次睡覺我還搶了 Bill 的棉被QQ，對不起，我下次會意識到我睡覺會搶棉被得我也會注意<font color="#dd0000"><strong>下次在外面住雙人房時先跟客房人員要兩件棉被</strong></font>，辛苦你了嗚嗚嗚嗚嗚嗚。</p>
<ul>
<li>可愛的粉紅大熊<br><img src="/images/ncut2020_experience/2.jpg" alt=""></li>
</ul>
<h2 id="比賽當天，想法與思考的碰撞"><a href="#比賽當天，想法與思考的碰撞" class="headerlink" title="比賽當天，想法與思考的碰撞"></a>比賽當天，想法與思考的碰撞</h2><h3 id="開幕式"><a href="#開幕式" class="headerlink" title="開幕式"></a>開幕式</h3><p>比賽當天，我們先在虎尾科大資訊大樓外進行報到，之後進到階梯教室等待開幕式，其中開幕式的主辦單位曾說我們這比賽能夠讓一些無法勝過台清交成的科大學校也有機會得名次，當下真得是超級感動的 ಥ⌣ಥ，然後中午的便當我覺得還不錯吃只是飯有點乾再用筷子時不太方便，我也喝了能量飲料，希望能夠將自己體力充足在考試期間不會因為疲累而寫不好，但是能量飲料 75 元真的太貴了拉。</p>
<ul>
<li>比賽隊伍<br><img src="/images/ncut2020_experience/3.jpg" alt=""><br><img src="/images/ncut2020_experience/4.jpg" alt=""></li>
</ul>
<h3 id="甚麼-notebook-只能10頁！"><a href="#甚麼-notebook-只能10頁！" class="headerlink" title="甚麼 notebook 只能10頁！"></a>甚麼 notebook 只能10頁！</h3><p>我們在開幕時，接受到一個訊息是我們的筆記只能夠有 10 頁，但是我們準備了 20 頁阿！所以我們直接在當場臨時進行刪除大法，有夠緊張的。還因為沒有 latex 導致沒辦法快速生成 pdf，幸好後來 Entroy 急中生智用 online linux 來解決此危機，不然就要出事啦！</p>
<h3 id="比賽前的緊張"><a href="#比賽前的緊張" class="headerlink" title="比賽前的緊張"></a>比賽前的緊張</h3><p>當我們進去比賽的電腦教室，我發現到我周遭的其他隊們都非常吵鬧，給予我一種非常緊張的感覺，有種覺得自己是不是因為準備不足才會這麼緊張？但其實我這麼緊張也是合理的，畢竟我連歷屆試題都只有寫 4 題，肯定會緊張的吧！當下的自己只希望能夠盡量讓自己發揮自己的本事就好，不過 scoreboard 就在我的面前壓力還真的是挺大的XD。</p>
<h3 id="考試時的小插曲"><a href="#考試時的小插曲" class="headerlink" title="考試時的小插曲"></a>考試時的小插曲</h3><p>時間到，每隊開始準備進入解題環境時卻沒辦法進入，每隊幾乎都出現一個狀況為「比賽已開始，你需要輸入特定指令才能進入比賽」之類的狀況，幸好很快就解決，不到 10 mins ，主辦單位就將每台電腦輸入指令讓大家都能繼續比賽，不得不說主辦單位還挺不賴的。</p>
<h3 id="比賽開始了，顯現自己實力的時候到了！"><a href="#比賽開始了，顯現自己實力的時候到了！" class="headerlink" title="比賽開始了，顯現自己實力的時候到了！"></a>比賽開始了，顯現自己實力的時候到了！</h3><p>比賽的過程中，我開始負責駕駛，其他隊友開始進行解決與思考題目，我們在解題的過程中，一開始順利地解開 4 題。其中一開始我對於讀取一行字串中所有的數字是想用 stringstream 但我卻對那語法忘記不熟，如果再查會太浪費時間，後來 Entroy 想到用 getchar() 來解決這個問題真的是聰明，度過了最一開始的危機。</p>
<p><strong>在最後的 90 分鐘，突然我腦袋異常清醒，告訴我自己現在正是你要發揮、拯救團隊的時候，將自己所學的知識都運用上、放手一搏吧！</strong></p>
<p>在剩下 1 hr 30 min，開始卡關，有兩題並不難的題目卡關，其中 ProblemB 關於遞迴因為解不開，導致隊友開始設想要使用暴力解法，直接建立答案表，就可以達到 \( O(1)\)，原本這想法我有嘗試著跟他們溝通這想法並不好，因為我們有看到其他隊在解此題都特別快，只有我們卡關，所以我一直覺得是我們缺少了哪部分的想法，才會使我們一直 WA。</p>
<p>但是隊友有點不太能夠聽進我的想法，一直以自己的角度去思考，認為我們只要能夠把題目解開就好，所花費的時間成本再多都沒關係。結果則是發現實現上具有根本上的問題，所以不可以使用，後來我在最後半小時急中生智想到有可能是因為題目說數字最大只會到 \(2^{32}\)，但並沒有說中間計算時不會超過，於是我就使用 long long 解決了這問題，在危險中找到出路。</p>
<p>另外一題卡關的部分，就是 Problem C 題目是想要對樹進行追蹤，我第一直覺就是樹壓縮成一維陣列，然後再將資料向下延伸找回，Bill 的想法似乎跟我一樣，但他的想法我覺得錯誤了，他寫成一個 struct ，有點類似於線段樹，但其實不用那麼麻煩，我們後來在實現此方法時發現非常不友善，程式會花費太多時間。</p>
<p>後來我的另外兩位隊友想用 struct + pointer 來解決問題，當下的我聽到時是十分震驚的，因為我覺得這是個瘋狂的舉動，在比賽的時候寫 pointer 不確定性太大、Debug 時不方便，在不容易知道自己問題會在哪部分的情況下，不應該要用 pointer，在他們後來發現不可行後。根據我的想法將樹壓縮一維陣列並透過遞迴實現，透過 Bill and Entroy 在我旁邊 Debug 與檢查錯誤讓我們在最後半小時內也對了這題，隊友也是很重要的！ </p>
<h3 id="比賽結束了，名次到底是第幾呢"><a href="#比賽結束了，名次到底是第幾呢" class="headerlink" title="比賽結束了，名次到底是第幾呢"></a>比賽結束了，名次到底是第幾呢</h3><p>由於最後一小時比賽會凍結排名，我們最後一次看到我們自己的成績是第 17 名，我非常緊張，感覺這樣有失自己的自尊，不過後來有在最後半小時解出兩題，應該名次會往前，當時的猜測是自己會是第五名 or 第六名，因為都是比較晚的時間送出應該會成績不會太漂亮，果不其然，跟我的預估一樣拿到第五名、金獎。而且金獎還是最後一個名額阿，運氣真的很好。也謝謝自己的隊友可以幫助我能夠拿到金獎，沒有他們我說不定連金獎也都沒有吧！</p>
<ul>
<li><p>頒獎拉，金獎的我們<br><img src="/images/ncut2020_experience/5.JPG" alt=""></p>
</li>
<li><p>很乖的 Entroy<br><img src="/images/ncut2020_experience/6.jpg" alt=""></p>
</li>
</ul>
<h2 id="賽後，回歸的旅途總是讓人疲憊"><a href="#賽後，回歸的旅途總是讓人疲憊" class="headerlink" title="賽後，回歸的旅途總是讓人疲憊"></a>賽後，回歸的旅途總是讓人疲憊</h2><p>我在比完賽後，認識到了一位就讀虎尾科大的工作人員，原因是因為我們在最後半小時成功解出兩題時太激動，才會不小心認識到的XD，對不起啦我下次不會那麼激動的QQ，而且他們個性也都很好願意可以讓我們將程式碼帶回來做檢討跟讓我放在 Blog 可以讓未來的我觀看，也讓她告訴我哪裡有好吃的，真的，認識新朋友的感覺真的很棒。<del>但是我們都在互嘴，哈哈哈哈</del></p>
<p>由於閉幕式後，我們的高鐵是晚上 9 點，但時間才 5 點，於是我們去虎尾附近逛逛，不得不說其實虎尾的路很大條、很好走，車流量也不多挺舒服的。但是我們在比賽的過程中卻收到空汙警報，讓我覺得這裡的人好可憐阿QQ，希望台灣的每個工廠與人們都能有良心，守護好台灣人的健康與生態環境。</p>
<p>最後回到高鐵站時，我與 Bill 在虎尾高鐵站外走走聊天，晚上的雲林其實空氣挺不錯的，而且讓我對雲林的印象很加分，東西好吃、便宜，人也都蠻熱情、計程車司機們也都很友善，讓我很喜歡這裡的人事物，突然有種不想回台北的感覺呢！</p>
<ul>
<li>晚間的雲林高鐵站<br><img src="/images/ncut2020_experience/7.jpg" alt=""></li>
<li>返程的高鐵車票<br><img src="/images/ncut2020_experience/8.jpg" alt=""></li>
</ul>
<h2 id="浪漫的情話"><a href="#浪漫的情話" class="headerlink" title="浪漫的情話"></a>浪漫的情話</h2><p>我在回程的過程中，突然想到一段話，如下：<br>A: 北港在嘉義，那南港在哪裡呢？<br>B: 台北嗎?<br>A: 而我現在就在中間當南港與北港的橋梁，把南北港的思念相互傳達到彼此。</p>
<p>天阿，自己真的好浪漫喔，哈哈哈哈。<del>神經病</del></p>
<h2 id="賽後檢討"><a href="#賽後檢討" class="headerlink" title="賽後檢討"></a>賽後檢討</h2><p>每次的比賽都需要檢討才能讓自己更完美，我個人在這次賽後有想要提出一些檢討，如下:</p>
<ol>
<li>相信駕駛員的判斷、信任駕駛員<br>為甚麼會這樣說呢？因為我覺得我在這次比賽時發現一個問題，如果想法者思考錯誤時他並不會發現錯誤，但當駕駛員無法在當下提出有力證據時，容易造成衝突，勢必要給想法者去實際駕駛一遍才能夠讓他理會，但是這樣可能會浪費多餘時間。但我也無法保證駕駛員是對的，所以駕駛員必須學會一件事情就是，要是自己沒有足夠的把握就不要否定他人想法。</li>
<li>練習時，盡量讓想法者也可以寫些題目<br>因為想法者在思考題目時，大多只有思考重點的想法，忽略掉一些小細節，而往往魔鬼藏在細節裡，常常都是因為細節而讓 Coding 變得窒礙難行，或是在原本完整的程式必須要加上現在才發現的細節但卻沒有空間讓程式修改，所造成的麻煩，於是建議隊友都能寫一些來了解題目，不需要很多。比例大約駕駛員 4 : 想法者 1 即可。</li>
<li>需要有副駕駛員<br>駕駛員思考的路上真的會累，需要有第二人來輪替會更好。</li>
<li>需要更多練習<br>我們練習的時間真的不夠多，科大程式競賽歷屆試題連完整的一年都沒有實際寫過。下次要把他寫完</li>
<li><del>不要看到太漂亮的女生就呆住</del><br><del>容易今天戀愛，今天失戀。真的好難過QQ，但是皮膚白白的女生真的好可愛 (◍•ᴗ•◍)❤️</del></li>
<li>團隊氣氛更好<br>這點 Bill 做得還不錯，很感謝他 ಥ⌣ಥ</li>
<li>必須先詢問民宿幾點可以入住</li>
<li>如果睡雙人床準備兩個棉被QQ</li>
</ol>
<p><strong>希望我的未來能夠變得更好，與我的夥伴朋友共同努力。</strong></p>
<h2 id="後記"><a href="#後記" class="headerlink" title="後記"></a>後記</h2><p>也感謝系主任願意補助我經費讓我去參加比賽，讓我無後顧之憂放心大膽一博。然後與我無關真的好好聽，我聽了 4 小時都不會膩，打這篇心得也花了我 4 小時跟打比賽一樣久呢！不說了要去睡覺了拉，下台一鞠躬。</p>
<h2 id="競賽結凍後的總成績"><a href="#競賽結凍後的總成績" class="headerlink" title="競賽結凍後的總成績"></a>競賽結凍後的總成績</h2><p><img src="/images/ncut2020_experience/9.jpg" alt=""></p>
<h2 id="金獎"><a href="#金獎" class="headerlink" title="金獎"></a>金獎</h2><img src="/images/ncut2020_experience/10.jpg" style="border:2px black solid ;box-shadow:12px 12px 12px gray;padding:5px;">

<h2 id="第五名"><a href="#第五名" class="headerlink" title="第五名"></a>第五名</h2><img src="/images/ncut2020_experience/11.jpg" style="border:2px black solid ;box-shadow:12px 12px 12px gray;padding:5px;">

<h2 id="北科資財官網恭賀得獎"><a href="#北科資財官網恭賀得獎" class="headerlink" title="北科資財官網恭賀得獎"></a>北科資財官網恭賀得獎</h2><p><img src="/images/ncut2020_experience/12.PNG" alt=""></p>
]]></content>
      <categories>
        <category>競賽心得</category>
      </categories>
      <tags>
        <tag>大學Life</tag>
        <tag>ICPC</tag>
        <tag>程式比賽</tag>
        <tag>競賽心得</tag>
        <tag>人生旅途</tag>
      </tags>
  </entry>
  <entry>
    <title>2018 (107) 學年金手獎技藝競賽程式設計 - 金手第六心得</title>
    <url>/2020/03/23/contest_experence/Skill-Contest/</url>
    <content><![CDATA[<h2 id="程式設計競賽心得："><a href="#程式設計競賽心得：" class="headerlink" title="程式設計競賽心得："></a>程式設計競賽心得：</h2><blockquote>
<p>這篇是打給未來、或是已經是程式設計技藝競賽選手的你。</p>
<p>我之前是 107 程式設計技藝競賽金手獎第六名的選手，我覺得過程中需要的是毅力與耐心，程式設計是很機車的技藝競賽，你只有兩種狀況，會與不會。</p>
<p>所以你必須要有一個覺悟，把不會的都學會，透過腦袋與紙筆將程式一一推導出來</p>
<p>學長那年是用 visual basic 撰寫，我個人偏希望改使用 C++ ，我認為對於未來學生的學習會有更好的體驗與幫助</p>
</blockquote>
<a id="more"></a>

<h2 id="對於程式的初學者："><a href="#對於程式的初學者：" class="headerlink" title="對於程式的初學者："></a>對於程式的初學者：</h2><p>建議先不要從歷屆試題開始寫，難度應該對你來說有點高(<strong>要是不會的話證明你太強了，跳下一 part 吧</strong>)，如果初期就不太能將 simple 程式寫出來的話，挫折感會很重，你不看網路、不看學長姐之前所留下的資料基本上你很難寫出來(除非你是愛因斯坦，那你也不會看到我這篇文章了，對吧！)，先試這閱讀學長姐的 code ，不會的就問學長姐，當年是怎麼構思的，熟悉學長姐的思路後，之後看學長姐的程式碼會如魚得水。</p>
<p>要是沒有學長的幫助話，建議可以將歷屆前 3 名的程式檔案都下載下來，仔細閱讀與品嘗(短可 10 秒鐘，長可 10 小時)，我在學習之路上有一句話對我獲益良多 <font color="#dd000">模仿是最好的學習</font> ，也希望大家能體驗到箇中滋味！</p>
<h2 id="程式路途中："><a href="#程式路途中：" class="headerlink" title="程式路途中："></a>程式路途中：</h2><h3 id="資料結構-Tree-："><a href="#資料結構-Tree-：" class="headerlink" title="資料結構(Tree)："></a>資料結構(Tree)：</h3><p>對於技藝競賽來說，她十分單純又十分好懂(天啊，我都想戀愛了)，熟悉結構、走訪一遍，對你來說就不會是一個難題。<br>真的不懂就找老師，千萬不要硬撐。如果覺得沒人問的話，可以來找作者(在關於我可以看到我的連絡資訊)</p>
<h3 id="演算法與動態規劃-Algorithm-and-Dynamic-programming-："><a href="#演算法與動態規劃-Algorithm-and-Dynamic-programming-：" class="headerlink" title="演算法與動態規劃(Algorithm and Dynamic programming )："></a>演算法與動態規劃(Algorithm and Dynamic programming )：</h3><p>我建議你可以先嘗試自己寫寫看或自己慢慢推導出來，這很有趣(如果是只為了拿獎找國立科大的人來說，這裡會是一個死穴，會對你們 so boring)，但<font color="#dd0000">前提是有足夠時間練習</font>，不然就放棄掉，反正技藝競賽演算法最多只有兩題。</p>
<h2 id="賽前建議："><a href="#賽前建議：" class="headerlink" title="賽前建議："></a>賽前建議：</h2><p>可以在重寫一遍全部的歷屆試題(學術科)，在重寫中，也許會讓你體驗到新領悟，這在當時的我給予了我很大幫助，不過建議你改成用原子筆開始作圖，因為我這屆限定只能用考場提供的原子筆來 做圖，不可私下帶文具。</p>
<p><font color = "#dd0000">健保卡、身分證一定要帶。</font>我當年就是忘記帶，還特地在板橋火車站請爸媽幫我送過來，到現在還是很謝謝母親願意放下手邊的事物照顧一個不成材的兒子，真的十分感謝。</p>
<h2 id="感謝的話："><a href="#感謝的話：" class="headerlink" title="感謝的話："></a>感謝的話：</h2><p>在這邊還是有些感謝的話要說，畢竟我不是只靠著我一個人努力上來的。</p>
<h3 id="吳勝雄老師："><a href="#吳勝雄老師：" class="headerlink" title="吳勝雄老師："></a>吳勝雄老師：</h3><p>幫助我排除很多關於程式設計的問題，也給予我許多在學習上的建議，就算在獨自一人的情況下也可以藉由網路排除些學習上的障礙，也陪伴我磨練。 <del>還會拿他的早餐給你吃</del><br>在技藝競賽後，我也跟著他學習了許多其他知識，受益良多。</p>
<h3 id="高鈺成學長："><a href="#高鈺成學長：" class="headerlink" title="高鈺成學長："></a>高鈺成學長：</h3><p>由於我上一屆是空缺，加上科上並沒有留下甚麼資料給我，我當年的環境十分刻苦且艱辛，學長(高鈺成學長比我大兩屆)願意回來提點我程式，並毫不客氣地將之前他寫得作品給予我，讓我在不懂時可以品嘗他的程式碼、了解思路、解惑我的疑問。</p>
<h3 id="孫龍生老師："><a href="#孫龍生老師：" class="headerlink" title="孫龍生老師："></a>孫龍生老師：</h3><p>我程式的啟蒙老師，他奠定了我寫程式的基礎，也是他在程式初期給予了我信心，度過前陣子的難關。</p>
<h3 id="勞裕安老師："><a href="#勞裕安老師：" class="headerlink" title="勞裕安老師："></a>勞裕安老師：</h3><p>勞裕安老師使我的不成熟與稚氣逐建消失，取代而之的是穩重與成長。要是沒有他對我的諄諄教誨，或許我沒有辦法成長到讓老師們放心讓我參加技藝競賽吧！</p>
<h3 id="陳建名："><a href="#陳建名：" class="headerlink" title="陳建名："></a>陳建名：</h3><p>陪伴我高 2,3 ，最重要的人呢，要是沒有你也許我甚麼都不是，生命中的貴人，比賽好戰友。<br>也謝謝你願意將選手的位置退讓給我，讓我有一個發展的舞台。</p>
<h3 id="在選手室中陪伴我的各位："><a href="#在選手室中陪伴我的各位：" class="headerlink" title="在選手室中陪伴我的各位："></a>在選手室中陪伴我的各位：</h3><p>我想，可能會有人不喜歡我將名字透露出來，於是就不透露了。</p>
<p>在選手室的練習中，我度過很愉快的時光，在難過時有陪伴，在開心時有玩伴。<br>大家互相支援、互相努力的感覺真的不錯，有時真的懷念起來。</p>
<h3 id="看這篇文章的朋友們："><a href="#看這篇文章的朋友們：" class="headerlink" title="看這篇文章的朋友們："></a>看這篇文章的朋友們：</h3><p>如果有看到這份文章，希望能夠記得我，我不求甚麼利益回饋，我只求當我看到新的程式大神曾看過我的文章並在我文章中獲得新知識，我就很滿足了。</p>
<h2 id="最後："><a href="#最後：" class="headerlink" title="最後："></a>最後：</h2><p>最後的最後，還是要放上一張照片來做總結吧。</p>
<img src="https://i.imgur.com/eAtInHR.jpg" alt="Skill-Contest me and teacher.jpg">

]]></content>
      <categories>
        <category>競賽心得</category>
      </categories>
      <tags>
        <tag>高中Life</tag>
        <tag>程式比賽</tag>
        <tag>競賽心得</tag>
        <tag>人生旅途</tag>
      </tags>
  </entry>
  <entry>
    <title>git 在使用其他電腦 remote 同網址時問題</title>
    <url>/2020/07/11/git/git-branch-problem/</url>
    <content><![CDATA[<h2 id="文章大意"><a href="#文章大意" class="headerlink" title="文章大意"></a>文章大意</h2><blockquote>
<p>當你在使用 git remote 一個曾被其他電腦 remote 的 Repositories 時，發生該 branch 已存在時的解決方式</p>
</blockquote>
<a id="more"></a>

<h2 id="問題概述"><a href="#問題概述" class="headerlink" title="問題概述"></a>問題概述</h2><p>使用者遇到先前有對一個網址進行 remote ，接下來在新電腦使用 remote 就不能 remote 時該怎麼辦?</p>
<h2 id="解決問題"><a href="#解決問題" class="headerlink" title="解決問題"></a>解決問題</h2><p>換新的分支，也就是原先可能是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote add A &lt;url&gt;</span><br></pre></td></tr></table></figure>
<p>變成</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote add B &lt;url&gt;</span><br></pre></td></tr></table></figure>
<p>就可以把此問題解決，沒想到我之前都沒遇過這問題，今天才遇到啊！</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>git 教學 - 與作者的金魚腦</title>
    <url>/2020/03/09/git/git-tutorial/</url>
    <content><![CDATA[<h2 id="git-教學"><a href="#git-教學" class="headerlink" title="git 教學 :"></a>git 教學 :</h2><blockquote>
<p>想怎麼學會使用 git 操作 github ? 那就觀看這篇文章就對喔~</p>
</blockquote>
<a id="more"></a> 

<p><a href="https://gitbook.tw/chapters/github/push-to-github.html" target="_blank" rel="noopener"> Git教學 </a></p>
<img src="https://coder.tw/wp-content/uploads/2017/02/github-825x510.png" alt="github.png" >

<p><a href="https://stackoverflow.com/questions/8044675/pull-is-not-possible-because-you-have-unmerged-files-git-stash-doesnt-work-do/25453407" target="_blank" rel="noopener">git pull</a> 遇到狀況時排解</p>
<h4 id="git-push-強制接案"><a href="#git-push-強制接案" class="headerlink" title="git push 強制接案"></a>git push 強制接案</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>


<h2 id="附註"><a href="#附註" class="headerlink" title="附註 :"></a>附註 :</h2><p>大神寫得太好，小弟我只能自嘆不如</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>手機探險記(大一)</title>
    <url>/2020/04/13/life_experence/Lost-Phone-In-20200413/</url>
    <content><![CDATA[<h2 id="一天一口氣丟掉兩次手機"><a href="#一天一口氣丟掉兩次手機" class="headerlink" title="一天一口氣丟掉兩次手機"></a>一天一口氣丟掉兩次手機</h2><p>今天早上騎車的時候手機跳海了，我去到北科才發現，我以為是我放在家裡面。結果不是！</p>
<p>後來我查了手機定位竟然定不到，在此奉獻各位台灣之星的網路真的沒事不要亂用，警察叔叔的保險櫃是沒辦法收到訊號的喔！</p>
<p>再來，感謝的話，<br>嗚嗚嗚嗚，幫我撿手機到警察局的人真的好感謝(◍•ᴗ•◍)❤️<br>我從現在開始實施有禮貌運動（不說髒話，說好話，行善事）<br>然後警察真的很友善。真的<br>然後謝謝realme, 跳海了之後還會回到主人身邊。<br>愛你啦♡(&gt; ਊ &lt;)♡</p>
<p>警局的部分:<br><img src="https://i.imgur.com/C5m5OSU.jpg"></p>
<h2 id="題外話的部分："><a href="#題外話的部分：" class="headerlink" title="題外話的部分："></a>題外話的部分：</h2><ol>
<li><p>意識到自己手機可能在警察局時，我打電話過去給了警察，警察叫我過去一趟時，我詢問下「不好意思，警察局大約什 麼時候會休息了？」，一群警察大笑，我們警察局不休息喔~<br>24小時都在營業。<br>我覺得我需要補充我的常識.</p>
</li>
<li><p>在警察局時，警察說我很幸運，在騎車的情況下，手機跳海還沒事，重點是尖峰時段，你的手機避開了其他人的車子沒被碾壓，看來你的手機求生慾很高很高，我跟警察說「對啊，因為他很愛我」，怕我沒了他就不行。</p>
</li>
<li><p>晚上回到家後，我又發現我的手機又不見了，於是我又在定位了一次，發現我的手機丟在了機車上，又忘記拿回來。看起來手機不太喜歡主人呢！一天跑走兩次。</p>
</li>
</ol>
<p>手機根本不愛我吧！他只是想要換主人而已ಥ‿ಥ</p>
<p>在這邊我像手機懺悔。對不起，我不應該讓你每個月都傳輸近500g。不應該讓你清明連假24小時都被操。<br>怕你以後又逃走。我以後會增強用量，目標一個月800G，讓你忙到沒辦法逃走的 ಥ╭╮ಥ, 不過我還是很愛你的(◍•ᴗ•◍)❤️(*＾3＾)/～♡</p>
]]></content>
      <categories>
        <category>人生旅途</category>
      </categories>
      <tags>
        <tag>大學Life</tag>
        <tag>人生旅途</tag>
        <tag>旅遊日記</tag>
      </tags>
  </entry>
  <entry>
    <title>BLOG 經驗分享</title>
    <url>/2020/07/20/life_experence/blog-experience/</url>
    <content><![CDATA[<h2 id="我為甚麼會寫-BLOG"><a href="#我為甚麼會寫-BLOG" class="headerlink" title="我為甚麼會寫 BLOG"></a>我為甚麼會寫 BLOG</h2><blockquote>
<p>因為我在高中的時候，練習科展、專題、演算法，大都是看網路上大神的 BLOG，學習他們的程式、邏輯概念、思考模式，這讓我在 2020/03/07 時有了動機，我應該幫助我自己建立一個 BLOG，來整理自己的思緒、也將自己遇到的一些狀況記錄下來，未來如果有用到也不會忘記，用俗話一點說就是不想要把知識再還給老師，知識還要是我的!</p>
</blockquote>
<a id="more"></a>

<h2 id="BLOG-一開始遇到的狀況"><a href="#BLOG-一開始遇到的狀況" class="headerlink" title="BLOG 一開始遇到的狀況"></a>BLOG 一開始遇到的狀況</h2><p>老實說，一開始在撰寫 BLOG 時，我的文字表達能力並不是很好，時常打出來的文字都不滿意，詞不達意，可能現在也是一樣XD。於是這讓我在一開始寫 BLOG 時遇到了些許障礙，有點沒有動力寫，因為我寫一個題目的時間比我打出一份我的解題心得還要久時我就有點卻步了。</p>
<h2 id="那為甚麼還有動力繼續寫"><a href="#那為甚麼還有動力繼續寫" class="headerlink" title="那為甚麼還有動力繼續寫?"></a>那為甚麼還有動力繼續寫?</h2><p>這就真的是件很神奇的事情了，通常大家都說人在做一件事情時 3個月就會把他的熱情降低至百分之 50%，可能就不再願意繼續做。但為甚麼我會繼續做呢?因為我用到了！在科大程式競賽時，我需要做一些快速複習演算法的時候，這 BLOG 就派上用場了！很神奇，因為我會對我打過的心得有印象，於是我只需要大概看一下就可以恢復很大的記憶，這在我之前沒有寫 BLOG 時是不一樣的，我常常忘記就要再上網翻資料，但上網的資料有時候營養成分又不高會很浪費時間，所以現在我就一樣繼續寫 BLOG 寫到現在~</p>
<h2 id="BLOG-伴隨著我成長的鏡子"><a href="#BLOG-伴隨著我成長的鏡子" class="headerlink" title="BLOG 伴隨著我成長的鏡子"></a>BLOG 伴隨著我成長的鏡子</h2><p>因為我會把我所學到的知識放入 BLOG 內，於是當我想跟別人說我會甚麼東西時，我可以直接快速的從 BLOG 翻閱給他看，讓他知道我是有這個實力，但要是這項事情是我沒有學過，而我將它學起來時，我則可以幫我的 BLOG 增加內容，也幫我記錄下許多資料，讓我又成長了些。或是朋友們想要跟我學些東西時，我就可以將我的 BLOG 給他看，減少溝通上的失誤，也避免掉浪費時間。畢竟時間一長很多事情是會忘記的，但記錄下來後可以快速瀏覽紀錄來喚起回憶。</p>
<h2 id="甚麼，大衛！你竟然還把你的-BLOG-丟掉-google-上！"><a href="#甚麼，大衛！你竟然還把你的-BLOG-丟掉-google-上！" class="headerlink" title="甚麼，大衛！你竟然還把你的 BLOG 丟掉 google 上！"></a>甚麼，大衛！你竟然還把你的 BLOG 丟掉 google 上！</h2><p>這…其實只是我想要拉XD，因為我在學習的過程中我都是看著大家的 BLOG 才使我成長、前進。於是我也希望我可以抱持著這種精神，充足這個世界的知識量，也許我的知識可能淺薄，沒有營養。但我相信有些文章還是具有一定的影響程度，希望大家在觀看我的 BLOG、瀏覽我的知識時不要罵我怎麼那麼爛 QQ。</p>
<h2 id="整理-BLOG-真的很難"><a href="#整理-BLOG-真的很難" class="headerlink" title="整理 BLOG 真的很難"></a>整理 BLOG 真的很難</h2><p>整理 BLOG 真的是一件難事情，我到現在都還沒有抓到整理的重點，常常都要把我的文章全部打開(大約有 70 篇，在編寫此文章這時間點)，將分類與標籤重新改過，重新分類。打造出好讓我也好讓使用者可以快速查閱到他想要的資料，到現在我還不太確定我的分類到底能不能友善的讓使用者快速抓到他想要的文章，但是我正努力朝著邁進。</p>
<h2 id="提供-BLOG-主題的大神，非常感謝"><a href="#提供-BLOG-主題的大神，非常感謝" class="headerlink" title="提供 BLOG 主題的大神，非常感謝"></a>提供 BLOG 主題的大神，非常感謝</h2><p>有了這些提供 BLOG 主題的大神，我才可以致力於編寫文章，而不用受限於其他技術之苦。 hexo 幫助了我可以快速將文章發布在 github，ayer 主題則幫助我打造出漂亮的網站，我都十分感謝。要是未來我有機會，我也想要回饋你們，謝謝。</p>
<h2 id="更新日誌"><a href="#更新日誌" class="headerlink" title="更新日誌"></a>更新日誌</h2><p>2020/07/20 00:50:23 - 完成 6 段落</p>
<ul>
<li>BLOG 一開始遇到的狀況</li>
<li>那為甚麼還有動力繼續寫?</li>
<li>BLOG 伴隨著我成長的鏡子</li>
<li>甚麼，大衛！你竟然還把你的 BLOG 丟掉 google 上！</li>
<li>整理 BLOG 真的很難</li>
<li>提供 BLOG 主題的大神，非常感謝</li>
</ul>
]]></content>
      <categories>
        <category>人生旅途</category>
      </categories>
      <tags>
        <tag>Blog</tag>
        <tag>人生旅途</tag>
      </tags>
  </entry>
  <entry>
    <title>不應該讓女朋友做的事情，男朋友應該要做的事</title>
    <url>/2020/05/20/life_experence/heart-break-with-girl-friend/</url>
    <content><![CDATA[<h2 id="致感情路上受傷的各位："><a href="#致感情路上受傷的各位：" class="headerlink" title="致感情路上受傷的各位："></a>致感情路上受傷的各位：</h2><blockquote>
<p>今天，我被分手了。<br>於是今天的我沒有什麼心情寫程式，就讓我來抒發我的情緒吧</p>
</blockquote>
<a id="more"></a>

<ol>
<li><p>絕對不可以玩交友軟體<br> 透過交友軟體上認識的男生，一定會讓你安全感很不足吧！我就是，我會時常懷疑我女朋友有沒有背著我偷腥，有沒有亂來，時常活在這種陰影下（加上我之前有被劈腿的經驗），一朝被蛇咬，十年怕草繩，這種事情千萬不准讓女朋友做。</p>
</li>
<li><p>相信女朋友<br>相信女朋友是件很重要的事，如果懷疑了，一發現，當下除了暴怒以外真的沒有什麼好說；雖然我做出了衝動的事，但是我覺得我沒錯；但是分手了，我很難過。至少相信會比不相信來的開心吧！</p>
</li>
<li><p>學會說話<br>也許可能看起來會很壞吧！但這就是我啊！不可否認的。我喜歡親親抱抱摸摸，但女朋友不一定喜歡，如果你真的很喜歡的話，請想進一切辦法哄他，讓女友願意陪你做，不要像這個笨蛋一樣，不會哄只會明白地說，搞的女朋友越來越不喜歡我….，也是因為我是寫演算法的吧，習慣性白話不會扭扭捏捏。</p>
</li>
</ol>
<h2 id="剩下就是想對自己說的話"><a href="#剩下就是想對自己說的話" class="headerlink" title="剩下就是想對自己說的話"></a>剩下就是想對自己說的話</h2><p>大衛，我覺得你已經很努力想把自己做的更完美了，也許只是自己真的不夠優秀吧。<br>其實，老實講，我生長在一個不是很健全的環境，雖然有兩個很努力要給予我好環境的父母，但是他們時常爭執，已經對我的心靈早就造成了很大的影響，如果你看過我應該就會知道我其實是個有點幽默感又有點正義感的人，但其實我的內心是很想要有一個人陪伴我，我想要有人可以保護我，在我努力時對我說辛苦了，在我難過時可以抱抱我，能對於我的直白不感到生氣，我喜歡把我當下的情緒訴說出來，我不擅長掩飾，我的難過就是難過。我也想要被人疼愛阿…。不是被分手、被說白目、因為其他男生而吃醋。</p>
<p>也許，我們在一起的時間不久。但是我真的很喜歡妳，還沒改變過。雖然我並不是、並不能擁有平淡幸福的人(我真的覺得我不配，我生長的環境，就是建立在別人的痛苦上。透過人的慾望來滋潤我成長)，曾經最好也是最棒的女朋友，謝謝你的陪伴。也許我還是沒辦法變的優秀，至少我還曾經被你相信過，我可能應該要感到非常慶幸…。</p>
<h2 id="也許痛苦才是愛情的本質"><a href="#也許痛苦才是愛情的本質" class="headerlink" title="也許痛苦才是愛情的本質"></a>也許痛苦才是愛情的本質</h2><p>由感而發的創作才會讓人感人肺腑吧。</p>
<p><strong>馬車總有一天會變回南瓜的，我們的愛情也總有一天會結束，期待下次的見面，我最愛也最想擁抱的人。</strong><br><strong>在下次見面之前，我會在夢中與現實長大，讓你不後悔我們的相遇。</strong></p>
<h2 id="題外話"><a href="#題外話" class="headerlink" title="題外話"></a>題外話</h2><p>雖然很不道德，但是我覺得我蠻支持婚後性行為的，我會害怕，我會想佔有我女朋友的全部。這樣會很自私嗎？會的話我很抱歉，但是要是沒有這樣的話，我會做惡夢，活在深淵之中阿…</p>
<h2 id="這是在痛苦與難過中，寫出來的。文筆絕對是不好的，但是這是我的內心世界，我必須要學會接納自己。"><a href="#這是在痛苦與難過中，寫出來的。文筆絕對是不好的，但是這是我的內心世界，我必須要學會接納自己。" class="headerlink" title="這是在痛苦與難過中，寫出來的。文筆絕對是不好的，但是這是我的內心世界，我必須要學會接納自己。"></a>這是在痛苦與難過中，寫出來的。文筆絕對是不好的，但是這是我的內心世界，我必須要學會接納自己。</h2>]]></content>
      <categories>
        <category>人生旅途</category>
      </categories>
      <tags>
        <tag>大學Life</tag>
        <tag>人生旅途</tag>
      </tags>
  </entry>
  <entry>
    <title>經驗談 - 備審資料 (高中升大學)</title>
    <url>/2020/03/24/life_experence/enrollment_to_university/</url>
    <content><![CDATA[<h2 id="人生，只是一張單程票，且選擇不會在你"><a href="#人生，只是一張單程票，且選擇不會在你" class="headerlink" title="人生，只是一張單程票，且選擇不會在你"></a>人生，只是一張單程票，且選擇不會在你</h2><p>製作備審資料，真的要求的不多，只要求作者願意做，讀者願意聽。足矣。</p>
<p>高三下時，我獲獎算還多的 (在高職生中應該有算到前 5 %，可能對於高中生來說，可能是前 10 % 的經歷吧，不清楚)，明明事實證明有了十足的把握一定有國立科大可以上，但做為人，對於人生大事還是會害怕的。於是我在做備審資料時，還是十分努力的。</p>
<h2 id="備審資料製作注意事項："><a href="#備審資料製作注意事項：" class="headerlink" title="備審資料製作注意事項："></a>備審資料製作注意事項：</h2><ol>
<li>字要清楚</li>
<li>重要的要讓讀者能閱讀到</li>
<li>將自己表達清楚</li>
<li><del>讀者願意觀看</del></li>
</ol>
<h2 id="作者的話："><a href="#作者的話：" class="headerlink" title="作者的話："></a>作者的話：</h2><p>看完我的備審資料，也許你會得到新的領悟，我認為，有些東西還是用作品才能表達出來。</p>
<p>作者曾經很努力的做過備審資料，但自認為回報給予得太少 (可能是我太貪心)，哈哈哈哈，當初為了想備審資料的排版、封面，那真的很難。對於一個會寫點程式設計的小孩卻沒有任美感的小孩，做出一份讓他人賞心悅目的作品非常困難。</p>
<p>最後這份備審資料的戰績公布給大家：</p>
<p>台科 不錄取  資訊管理系<br>北科 正取    資訊與財金管理系<br>北商 備5     資訊管理系<br>中科 備3     資訊管理系<br>高科 備7     資訊管理系</p>
<p>有時候這就是命運的安排，由不得自己，明明一心只想寫程式，卻只有一間學校正取，科系對於程式的比例又不高，也許這就是緣分吧</p>
<h2 id="警告："><a href="#警告：" class="headerlink" title="警告："></a>警告：</h2><p>此備審資料嚴禁抄襲，僅供使用者參考。</p>
<p><a href="https://drive.google.com/file/d/1hO9-citl3ywVZuq4Mea4a0nFHNLLIm7m/view?usp=sharing" target="_blank" rel="noopener">大衞的備審資料 - 台北科大</a></p>
]]></content>
      <categories>
        <category>人生旅途</category>
      </categories>
      <tags>
        <tag>高中Life</tag>
        <tag>人生旅途</tag>
      </tags>
  </entry>
  <entry>
    <title>2019 新北市薦送高中職學生赴日本技職研習參訪活動</title>
    <url>/2020/07/20/life_experence/japan-experience-for-skill-contest/</url>
    <content><![CDATA[<h2 id="主要內容"><a href="#主要內容" class="headerlink" title="主要內容"></a>主要內容</h2><blockquote>
<p>紀錄我在高三下時因為參加 2018（107）學年度全國高級中等學校商業類學生技藝競賽程式設計職種 金手獎［第六名］，而赴日本技職研習參訪活動，透過 Pdf 呈現。<br>花了5個小時的嘔心瀝血之作，十分漂亮</p>
</blockquote>
<a id="more"></a>

<h2 id="封面預覽"><a href="#封面預覽" class="headerlink" title="封面預覽"></a>封面預覽</h2><p><img src="/images/japan-experience-for-skill-contest/1.jpg" alt=""></p>
<h2 id="PDF-LINK"><a href="#PDF-LINK" class="headerlink" title="PDF LINK"></a>PDF LINK</h2><p><a href="https://drive.google.com/file/d/1WoWHRXa7AHoaa6X6kIyEKEe1-W6_x1ZA/view?usp=sharing" target="_blank" rel="noopener">2019 新北市薦送高中職學生赴日本技職研習參訪活動旅遊日誌</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>我很喜歡金手獎遇到的人事物，也跟他們都成為了好朋友，希望未來的我可以更加優秀，能夠和他們一起耀眼，也謝謝大雄老師不厭其煩地陪我、開導我的人生，您說的那份愛情與故事我銘記在心。</p>
]]></content>
      <categories>
        <category>人生旅途</category>
      </categories>
      <tags>
        <tag>高中Life</tag>
        <tag>日本</tag>
        <tag>人生旅途</tag>
        <tag>旅遊日記</tag>
      </tags>
  </entry>
  <entry>
    <title>與國小好朋友高雄屏東四天行</title>
    <url>/2020/08/18/life_experence/kaohsiung-playing20200804/</url>
    <content><![CDATA[<h2 id="說明"><a href="#說明" class="headerlink" title="說明"></a>說明</h2><blockquote>
<p>記錄我從台北到高雄與國小四位好朋友的遊玩紀錄<br>張智翔<br>郭人豪<br>劉威廷<br>謝謝你們的陪伴，沒有你們還真不行</p>
</blockquote>
<a id="more"></a>

<h2 id="8-月-4-日，用下雨來歡迎我的高雄"><a href="#8-月-4-日，用下雨來歡迎我的高雄" class="headerlink" title="8 月 4 日，用下雨來歡迎我的高雄"></a>8 月 4 日，用下雨來歡迎我的高雄</h2><p>哇哇哇，每站皆停的高鐵從台北一路坐到高雄真的屁股好痛啊…，不過其實很平穩的，高鐵讚讚。</p>
<p>我們感覺智翔老大，給我們可以住漢來大飯店，漢來真的高級，真的。至少我看那個大廳可以把我家的房子重蓋 10 遍都不是問題吧！我們住在 29 樓，視野真的不賴。</p>
<p>漢來大飯店視野<br><img src="/images/kaohsiung-playing20200804/1.jpg" alt=""></p>
<p>然後這也是我第一次操作咖啡機…，咖啡機好難操作，台北俗表示難過 ಥ⌣ಥ</p>
<p>之後我們去試試看漢來的三溫暖，跟日本的一樣要全裸，看來是我要比大小的時候了！沒拉，大家都差不多…，三溫暖的熱水真的好舒服、冷水我不敢碰，之後則是進去蒸氣室，蒸氣室裡面有鹽巴，可以抹在自己身上，我不小心抹太多，讓自己吃到鹽巴…，好鹹。</p>
<p>晚上是個下雨天，我們威廷老大也在這時候開始登場了，我們先去租借明天要去墾丁的汽車，之後去買消夜與酒來看著海景在一起吃飯蠻浪漫的，我很喜歡。</p>
<p>結束之前來一張合照。<br><img src="/images/kaohsiung-playing20200804/2.jpg" alt=""></p>
<h2 id="8-月-5-日，我的第一次墾丁"><a href="#8-月-5-日，我的第一次墾丁" class="headerlink" title="8 月 5 日，我的第一次墾丁"></a>8 月 5 日，我的第一次墾丁</h2><h3 id="白天的墾丁"><a href="#白天的墾丁" class="headerlink" title="白天的墾丁"></a>白天的墾丁</h3><p>起床梳洗後，我們則準備離開漢來要前往墾丁，其中我們智翔在當司機時，我們威廷哥哥倒是很想要當司機，兩個人不斷在講誰要開車，真的蠻有趣 XD。其中，他們在某一次紅綠燈有了這段對話，太有趣了！<br><img src="/images/kaohsiung-playing20200804/3.jpg" alt=""></p>
<p>再前往墾丁的路上先去吃了一間海產店，不得不說高雄的海產都很便宜。還有我們人豪哥哥願意幫忙剝蝦，這樣我就不用說我對蝦過敏了 XD。在墾丁的路上，我們劉董事長一直很期望可以住進夏都，但我們翔老大一句話解決，「靠我們威董 joe 一下了」。</p>
<p>剛到民宿後的張董<br><img src="/images/kaohsiung-playing20200804/4.jpg" alt=""></p>
<p>到了墾丁後，在民宿休息下後，我想要買泳衣，但是後面卻忘記買了，老人家事不記得的事情太多了。我們翔哥表示淺水灣太多人，要去白沙灣，那裏沒人玩起來才舒服(我有點忘記地名了，搞錯了抱歉Q)，我們似乎還遇到浩子，我還以為是阿翔XD，阿浩，我對不起你。</p>
<p>印象深刻的海景<br><img src="/images/kaohsiung-playing20200804/7.jpg" alt=""></p>
<p>那天是禁止游泳的，風浪太大了。所以我們只能踏踏水，親吻海浪。一開始我們都站在浪打不到我們大腿的地方，後來越來越想挑戰浪，之後坐下來，直接讓浪打過我們全身。好舒服阿，只是感覺自己的身體也快斷了，浪超大的，如果我原本斜率是 0，那可以把我的斜率變成 1。</p>
<p>在白沙灣的合照<br><img src="/images/kaohsiung-playing20200804/5.jpg" alt=""></p>
<h3 id="夜晚的墾丁"><a href="#夜晚的墾丁" class="headerlink" title="夜晚的墾丁"></a>夜晚的墾丁</h3><p>時候晚了，於是我們一夥人上來要把身上的沙粒洗乾淨，看到有一處可以清洗(需要付費)，蠻感動的，不然我們就要帶一堆沙粒回家了，嗚嗚嗚嗚。傍晚的蚊子真的很多，我在那邊一口氣被叮了 10 個包，蚊子的移動血庫，教官，我對蚊子捐血可以給我嘉獎嗎。</p>
<p>傍晚的墾丁，令人陶醉<br><img src="/images/kaohsiung-playing20200804/6.jpg" alt=""></p>
<p>夜晚，我們進入墾丁大街，準備消費，吃了一家好吃的泰式餐廳。之後大家就在墾丁逛街，我想買雙拖鞋，但發現墾丁賣的拖鞋都不太適合我，我腳太大了…。腳大錯了嗎 ಥ⌣ಥ</p>
<p>我們劉董事長對於墾丁大街的名言<br><img src="/images/kaohsiung-playing20200804/8.mp4" alt=""></p>
<p>我們逛完時，在街上想買一碳烤披薩，但卻臨時突然下大雨!!!!!我濕的跟下雨天沒人要的孩子一樣，過不久後，雨停了，在過不久後，雨下了。濕了又乾，乾了又濕，墾丁的天氣跟女孩子一樣讓人捉摸不定。</p>
<h3 id="人豪呢"><a href="#人豪呢" class="headerlink" title="人豪呢"></a>人豪呢</h3><p>你問我，人豪呢? 你們不是 3 個人出去玩嗎?<br>恩，對阿。<br>他在跟他女朋友聊天，OFFLINE。</p>
<p>✖️ 沒有照片可以放的人豪</p>
<h2 id="8-月-6-日，向屏東探險"><a href="#8-月-6-日，向屏東探險" class="headerlink" title="8 月 6 日，向屏東探險"></a>8 月 6 日，向屏東探險</h2><h3 id="國家公園-and-鵝鑾鼻"><a href="#國家公園-and-鵝鑾鼻" class="headerlink" title="國家公園 and 鵝鑾鼻"></a>國家公園 and 鵝鑾鼻</h3><p>整理好後，我們就再往南出發，途中看到很多人騎著腳踏車，勇士，都是勇士。我們先去一座國家公園拍照，終於像觀光客了orz，風景很漂亮。</p>
<p>人豪的照片，第一次<br><img src="/images/kaohsiung-playing20200804/9.jpg" alt=""></p>
<p>我們的合照，人豪照片的第二次<br><img src="/images/kaohsiung-playing20200804/10.jpg" alt=""></p>
<p>接著，前往鵝鑾鼻燈塔，鵝鑾鼻是需要收費的，但因為武漢肺炎。原本我們應該是不用收費的!結果他說滿 19 歲以上都要收費，可惡，我應該早點來的 ಥ⌣ಥ。因為是正中午，正熱的天氣我光走幾步路就滿身大汗了，好可怕…。之後到了鵝鑾鼻燈塔，其實他跟我想像的差有點多，沒想到她其實沒有很高，感覺只有 4、5 層樓，有點小可惜。</p>
<p>之後我們進行了觀光客必備，拍照！✧(&gt;o&lt;)ﾉ，接著就前往海生館拉。</p>
<p>智翔終於拍出一張像樣的成績單了<br><img src="/images/kaohsiung-playing20200804/11.jpg" alt=""></p>
<p>團隊大合照<br><img src="/images/kaohsiung-playing20200804/12.jpg" alt=""></p>
<h3 id="海生館與跟鹿鹿玩"><a href="#海生館與跟鹿鹿玩" class="headerlink" title="海生館與跟鹿鹿玩"></a>海生館與跟鹿鹿玩</h3><p>接著，我們順著路到了海生館，海生館也是需要門票的。但是，這次不一樣摟！只要你是 2001/07/01 後出生的小孩都不用收費，嘻嘻，兩位老人去旁邊買票吧。</p>
<p>成功進去海生館之後，我發現海生館有好多生魚片，每個看起來都好好吃，害我肚子馬上就餓了。(理組人思考方式 XD，魚魚，對不起啦)</p>
<p>附上我最想吃的生魚片XD<br><img src="/images/kaohsiung-playing20200804/13.jpg" alt=""></p>
<p>後來我們繼續逛逛，有個議題是在講關於海洋生態環保，而當中有一面牆是希望大家用便利貼來訴說怎麼樣可以對海洋更好。正當我因為很多人都在表示要怎麼環保時，對！就是這個 moment，我看到了一張便利貼，感覺是一個很善良的小孩寫的一張便利貼，我卻不自覺的開懷大笑。</p>
<p>可愛的小孩寫的 (◍•ᴗ•◍)❤️<br><img src="/images/kaohsiung-playing20200804/14.jpg" alt=""></p>
<p>之後逛到了禮品店，對，沒錯。是我執意要逛的XD，我想說我對我的前女友保有歉意，於是想要買一個可愛吊飾送給他，他們卻一直在講魚餌魚餌的，討厭死了。<br>這可是我發自內心的真誠道歉呀。</p>
<p>選購玩偶中..<br><img src="/images/kaohsiung-playing20200804/15.jpg" alt=""></p>
<p>中間，我們吃了一家海產店。生魚片只要 180 元 10 片，我只要省下兩杯麥香的錢就可以吃ㄟ，屏東的食物好讚好便宜好好吃。我還不把我體重弄到破百，對不起這些魚。ε٩(๑&gt; ₃ &lt;)۶з<br><del>希望我死掉以後，可以不要被魚魚們欺負…</del></p>
<p>接下來跑去看鹿鹿，鹿鹿很可愛，但是我手上拿著飼料的時候，他們就像喪屍般不斷的去找你，吞食你的生命(飼料)，我一開始的策略是選擇逃跑，但跑著發現我被逼到一個小角落…，那些凶狠的鹿絲毫感覺不到我的害怕，繼續用著他的鹿角戳我的肚子，幸好我肚子夠軟，不然我的內臟早就被鹿角戳的亂七八糟的吧 QQ。最終還是輸給了鹿鹿，把生命給了他…。然後<br>然後呢?<br>.<br>.<br>.<br>然後他就不理我了…，一群現實鬼呀。</p>
<p>對，然後情侶很多，要有被閃的風險。很多大便，你閃不過的。</p>
<h3 id="晚餐與尋找高中摯友"><a href="#晚餐與尋找高中摯友" class="headerlink" title="晚餐與尋找高中摯友"></a>晚餐與尋找高中摯友</h3><p>晚餐後我們去吃汕頭火鍋，就是我們國瑜寧可不要開記者會也要吃到的火鍋XD，雖然我對他並沒有太大興趣，因為我對於火鍋沒有到很喜歡。不過他真的是蠻好吃的，店長人不錯，難怪我們國瑜也要吃。<br>「高雄可以輸，火鍋必須吃」– 市長韓國瑜留<br>.<br>.<br>.<br>當然不可能啦，開玩笑的。國瑜你會原諒我的吧，我們家有投票給你的！♡(&gt; ਊ &lt;)♡</p>
<p>回家的過程中，我還把我的提袋忘在汕頭…，這可能就是開國瑜玩笑的後果吧qq，大家還是不要亂開玩笑喔</p>
<p>回到了智翔的家後，我去了一趟陪我高中成長 3 年，幫助我變強的那個男人，陳建名。畢竟他在高科讀書，不找他還是不行的，跟他閒話家常憶當年，當時的我還真神勇阿，不像現在只能退在這邊打 blog，嗚嗚，也只有科大金獎，我們一同在高雄的街道漫步，直到太陽再次升上天空。</p>
<h2 id="8-月-7-日，玩命關頭機車版"><a href="#8-月-7-日，玩命關頭機車版" class="headerlink" title="8 月 7 日，玩命關頭機車版"></a>8 月 7 日，玩命關頭機車版</h2><p>早起與建名道別後，搭著智翔的機車回到了智翔家，然後去吃了一間鍋燒意麵，好吃。真的好吃，但是憑甚麼只有高科有加麵的機會，生氣，哼！之後我們提議去打保齡球，再去草衙道，我原本以為我保齡球沒有變爛，結果我已經爛到連球都不會拿了…，下次還是不要說大話阿，說自己很會打。唉</p>
<p>再晚點，我們去了草衙道，這個時候呢！對，我們那位 OFFLINE 的人豪終於上線了，我們去逛 NET，正當我們威廷想要買自己所看重的衣服時，我們人豪跟祥哥直接否決掉他，之後我們的人豪帥氣地幫我們威廷智翔選配衣服，我也在人豪的推薦下買了一個帽子，幸好不是綠帽 XD</p>
<p>回程時，由於我們可能對高鐵來不及，我們智翔用迅雷不及掩耳的速度，把我載到了北科，這真的是讓我嚇了一伸冷汗阿，智翔你有幫我保保險，對吧，對吧！高雄騎車真的沒有交通規則的，都是生存規則的…。其中我們智翔曾說了一句名言。<br>「禁行機車道，盡情騎機車」– 飆仔張智翔</p>
<p>但幸好我們還是平安地來到高鐵站，原本 20 分鐘 -&gt; 變成了 10 分鐘，你真的是時間管理大師，智翔。</p>
<p>之後我們到了板橋車站，搭了計程車。度過了這段開心又愉快的時光，也謝謝各位都願意陪伴在我身邊。</p>
]]></content>
      <categories>
        <category>人生旅途</category>
      </categories>
      <tags>
        <tag>大學Life</tag>
        <tag>人生旅途</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa12538 - Version Controlled IDE (Rope)</title>
    <url>/2020/09/01/UVa/UVa12538/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>我們需要版本控制一份文件，類型如下：<br>type 1 ，插入字串在 p 位置<br>type 2 ，移除字串從 p 位置開始移除 c 個字元<br>type 3 ，查詢 v 版本從 p 位置開始輸出 c 個字元<br>每進行一次 type 1 or 2 的動作，就增加一版本。<br>我們順便進行加密混淆的動作，每一次只要 type 3 輸出的字元中擁有 ‘c’，則接下來 除了 type 以外的數字都會因為前面 type 3 輸出字元中有多少的 c，則會增加多少數字。</p>
</blockquote>
<a id="more"></a>

<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>通常大家看到這題直覺都會是用 string 來寫這題吧！但這題不是 QAQ。<br>這題要用 string 的另外一個好朋友 rope 來解決，rope 的結構為「可持久化平衡樹」，他在加入資料時不破壞舊有狀態，這樣使得每次在插入新增時效率來比 string 更優秀。</p>
<p>下圖為 <a href="https://en.wikipedia.org/wiki/Rope_(data_structure)" target="_blank" rel="noopener">wiki string 與 rope 的複雜度比較圖</a><br><img src="/images/UVa12538/1.PNG" alt=""></p>
<p>在這需要大量插入移除的題目中，rope 是再好不過的了！且他語法也跟 string 大同小異，上手起來也不至於太久。</p>
<h3 id="小提醒"><a href="#小提醒" class="headerlink" title="小提醒:"></a>小提醒:</h3><p>type 2 and type 3 的 p 都是從 1 開始，所以必須要 -1，因為電腦從 0 開始呀！</p>
<p>rope.insert()，裡面放的是字元陣列！所以如果是 string，需要變成 string.c_str()，才有辦法讀進去喔！</p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>查了下 string 中文是細繩，rope 是粗繩，嗯? 怎麼感覺好像特斯拉與愛迪生的感覺呢wwww，主流都是 string 沒有 rope 阿 ಥ⌣ಥ。不過被我學了一課，嗯! 我又多學了一些知識，開心。</p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="stl之rope大法好及可持久化并查集用法">rope大法好</a><br><a href="http://sunmoon-template.blogspot.com/2015/01/c-rope.html" target="_blank" rel="noopener">c++ rope 基本應用</a><br><a href="https://en.wikipedia.org/wiki/Rope_(data_structure)" target="_blank" rel="noopener">Rope (data structure)</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ext/rope&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 50020</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> __gnu_cxx ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">int</span> n , t , a , b , c , d=<span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">int</span> v = <span class="number">0</span> ;</span><br><span class="line">    <span class="built_in">string</span> strA ;</span><br><span class="line">    rope&lt;<span class="keyword">char</span>&gt; r[MAXN] , rtmp ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; t ;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(t==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a ;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; strA ;</span><br><span class="line">            a -= d ;</span><br><span class="line">            r[++v] = r[v] ;</span><br><span class="line">            r[v].insert(a,strA.c_str());</span><br><span class="line">            <span class="comment">//debug</span></span><br><span class="line">            <span class="comment">//cout &lt;&lt; r[v] &lt;&lt; '\n' ;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(t==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b ;</span><br><span class="line">            a -= d ; b -= d ;</span><br><span class="line">            r[++v] = r[v] ;</span><br><span class="line">            r[v].erase(a<span class="number">-1</span>,b);</span><br><span class="line">            <span class="comment">//debug</span></span><br><span class="line">            <span class="comment">//cout &lt;&lt; r[v] &lt;&lt; ' ' &lt;&lt; r[v-1] &lt;&lt; '\n' ;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(t==<span class="number">3</span>)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c ;</span><br><span class="line">            a -= d ; b -= d ; c -= d ;</span><br><span class="line">            rtmp = r[a].substr(b<span class="number">-1</span>,c) ;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; rtmp &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">            d += count(rtmp.begin() , rtmp.end() , <span class="string">'c'</span> );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>rope</tag>
        <tag>String Processing Problems</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces 1397A - Juggling Letters(水題)</title>
    <url>/2020/08/31/Codeforces/Codeforces%201397A/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>給你 x 組字串，試問能不能把這些字串進行重組後，能夠再重新分成 x 組字串，但字串內容則是全部一樣，可以輸出 YES，不行輸出 NO。</p>
</blockquote>
<a id="more"></a>

<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><blockquote>
<p>水題，這題真的水題，還是有點巧思的水題。喜歡這種水題</p>
</blockquote>
<p>由於他會給你一些字串，但這些字串的字母可以全部移動，而他詢問說要讓重組後的字串全部一樣，於是只要確認<strong>每個字母</strong>除以 x 剛好是整除時就可以輸出 YES，如果不行就輸出 NO。</p>
<h2 id="心得："><a href="#心得：" class="headerlink" title="心得："></a>心得：</h2><p>這題其實不難，但我在閱讀時也花了許多時間。以及我在思考題目時其實也不太能夠馬上很直觀了解，但進行假設與觀察後即可發現規律，我認為這題放在第一題是很不賴的設計。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">char</span> , <span class="keyword">int</span>&gt; dict ;</span><br><span class="line"><span class="built_in">string</span> strTemp ;</span><br><span class="line"><span class="keyword">int</span> t , n  ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ans</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it : dict)&#123;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; it.second &lt;&lt; '\n' ;</span></span><br><span class="line">        <span class="keyword">if</span>(it.second % n)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"NO"</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"YES"</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//#ifdef LOCAL</span></span><br><span class="line"><span class="comment">//    freopen("in1.txt" , "r" , stdin );</span></span><br><span class="line"><span class="comment">//#endif // LOCAL</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t ;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">        dict.clear();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; strTemp ;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; strTemp.length() ; j++)&#123;</span><br><span class="line">                dict[strTemp[j]] +=<span class="number">1</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>水題</tag>
        <tag>程式解題</tag>
        <tag>Codeforces Round .#666 (Div. 2)</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces 1397D - Stoned Game(暴力搜尋 Brute force)</title>
    <url>/2020/08/31/Codeforces/Codeforces%201397D/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>T、HL 在玩遊戲。遊戲規則如下，有 x 堆石頭，每堆石頭數量不定，每次都是 T 先從其中一堆拿石頭，H 再拿一顆石頭，每位玩家則不可以拿上位玩家拿石頭的石頭堆。<br><del>這到底是甚麼原始人遊戲 XD，好像舊石器時代的人會玩的遊戲</del></p>
</blockquote>
<a id="more"></a>

<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><blockquote>
<p>這題真的很難啊…，這題目與我之前碰過的經驗不同，讓我搞錯方向去思考，好題好題。<br>幸好有解開啦…，不然我就會很生氣了 XD。</p>
</blockquote>
<p>每次都選擇最大的兩堆石頭出來，然後兩堆石頭各減一。之後再放回去 priority_queue 內，假如 priority_queue size 只有一堆代表 T win，若剛好 0 堆則代表 HL win。</p>
<p>至於我為甚麼會這樣想呢？我建議讀者都先從我的初步想法慢慢讀起，我認為會比直接看我的正確想法來的更好理解些。</p>
<h3 id="初步想法"><a href="#初步想法" class="headerlink" title="初步想法"></a>初步想法</h3><h4 id="錯誤想法-奇偶數堆"><a href="#錯誤想法-奇偶數堆" class="headerlink" title="錯誤想法 - 奇偶數堆"></a>錯誤想法 - 奇偶數堆</h4><p>一開始，稍微推斷一下。<br>他可能是甚麼透過偶奇數來判斷的，個人在猜應該是用偶數堆與奇數堆來進行判斷。<br>後來自己在紙筆推導時，發現 2 2 2 這測資是 HL win。但 2 2 4 則是 T 贏。</p>
<h4 id="錯誤想法-T-從最小堆石頭拿取，HL-從最大堆石頭拿取"><a href="#錯誤想法-T-從最小堆石頭拿取，HL-從最大堆石頭拿取" class="headerlink" title="錯誤想法 - T 從最小堆石頭拿取，HL 從最大堆石頭拿取"></a>錯誤想法 - T 從最小堆石頭拿取，HL 從最大堆石頭拿取</h4><p>這是根據題目給的測資進行判斷，比較有點根據了XD<br>只要只剩一堆石頭必定會是 T 贏，HL 則是要盡量讓石頭堆數達到兩堆且兩堆數量一樣。(從題目測資進行判斷)，於是我寫了一程式關於 T 從小石頭開始拿，當 T 從小石頭堆的提取數量已經大於 HL 的最大堆時，則 HL 在往次大堆進行提取，看最後是 T 還是 HL 的石頭比較多，我在進行判斷。(此想法透過遞迴撰寫)。</p>
<p>由於是錯誤想法因此我用圖片來給大家看我的錯誤遞迴，以免誤導大家以為這也是正確的一部份。</p>
<p><img src="/images/Codeforces-Round-666-Div-2-pD/1.PNG" alt=""></p>
<p>但後來證明我是錯誤的，測資怎麼樣都沒過，卡在第二筆。我後來仔細想想，每次都只拿一顆，經驗告訴我，消去法不一定適用。在使用 2 2 2 測資時得到啟發。</p>
<h4 id="正確想法-T-只提取最大堆石頭，HL-則提取次大堆石頭"><a href="#正確想法-T-只提取最大堆石頭，HL-則提取次大堆石頭" class="headerlink" title="正確想法 - T 只提取最大堆石頭，HL 則提取次大堆石頭"></a>正確想法 - T 只提取最大堆石頭，HL 則提取次大堆石頭</h4><p>為甚麼會這樣想呢？ 是 1 5 1 這測資啟發我的，我只要 T 直接拿取最大堆，那 HL 要拿甚麼石頭我都不需要在意阿 XD，反正我只要拿我的最大堆，剩下的石頭隨 HL 拿就行。那如果最大堆沒有呢？那就拿次大堆吧，把問題丟給 HL 就可以了 XD。</p>
<p>那有人會好奇說，為甚麼 HL 怎麼會每次都拿最大堆石頭？這樣 HL 真的是聰明的嗎？其實阿，這場遊戲 HL 完全沒有優勢，她為了要把自己的優勢找回來，所以她要拿次大堆的石頭，來希望當最大堆的石頭用完時，次大堆的石頭還在，這樣他就會是贏家 XD。</p>
<h2 id="心得："><a href="#心得：" class="headerlink" title="心得："></a>心得：</h2><p>暴力解法，這題讓我很意外啊！我以為會是很優秀的解法，沒想到被我這個程式笨蛋給用暴力解法解出來，如果這並不是作者想的方法，作者會被我給氣死吧! XD</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 120</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> t , n ;</span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>&gt; num;</span><br><span class="line"><span class="keyword">int</span> a , b ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">judge</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a , b ;</span><br><span class="line">    <span class="keyword">while</span>(num.size())&#123;</span><br><span class="line">        a = num.top() ;</span><br><span class="line">        a-- ;</span><br><span class="line">        num.pop();</span><br><span class="line">        <span class="keyword">if</span>(!num.size())&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"T"</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        b = num.top() ;</span><br><span class="line">        b-- ;</span><br><span class="line">        num.pop();</span><br><span class="line">        <span class="keyword">if</span>(a &gt; <span class="number">0</span>)</span><br><span class="line">            num.push(a);</span><br><span class="line">        <span class="keyword">if</span>(b &gt; <span class="number">0</span>)</span><br><span class="line">            num.push(b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"HL"</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//#ifdef LOCAL</span></span><br><span class="line"><span class="comment">//    freopen("in1.txt" , "r" , stdin );</span></span><br><span class="line"><span class="comment">//#endif // LOCAL</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t ;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">        <span class="keyword">int</span> intTemp ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; intTemp ;</span><br><span class="line">            num.push(intTemp) ;</span><br><span class="line">        &#125;</span><br><span class="line">        judge();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>程式解題</tag>
        <tag>Codeforces Round .#666 (Div. 2)</tag>
        <tag>暴力搜尋 Brute force</tag>
      </tags>
  </entry>
  <entry>
    <title>R if else 的用法</title>
    <url>/2020/09/03/R/R-ifelse/</url>
    <content><![CDATA[<h2 id="內容說明"><a href="#內容說明" class="headerlink" title="內容說明"></a>內容說明</h2><blockquote>
<p>內容記錄關於 R if else 中的用法</p>
</blockquote>
<a id="more"></a>

<h2 id="正常，普通寫法"><a href="#正常，普通寫法" class="headerlink" title="正常，普通寫法"></a>正常，普通寫法</h2><p>相信大家都會，不用我在都說 XD</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="R-if-一行寫法，通常在-lambda-function-中使用"><a href="#R-if-一行寫法，通常在-lambda-function-中使用" class="headerlink" title="R if 一行寫法，通常在 lambda function 中使用"></a>R if 一行寫法，通常在 lambda function 中使用</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">ifelse( test_expression , <span class="literal">TRUE</span> , <span class="literal">FALSE</span> )</span><br></pre></td></tr></table></figure>
<p>test_expression =&gt; 判斷的式子<br>TRUE =&gt; 條件符合的執行<br>FALSE =&gt; 條件不符合的執行</p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://www.datamentor.io/r-programming/ifelse-function/" target="_blank" rel="noopener">R ifelse() Function</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>程式語言的世界博大精神，要是沒有他們的付出我能走上現在的路嗎?<br>肯定是沒辦法的，於是我也需要更努力地去為社會付出。</p>
]]></content>
      <categories>
        <category>R語言</category>
      </categories>
      <tags>
        <tag>R語言</tag>
        <tag>學習筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>QUESTION! data_frame 要怎麼搜尋欄位中的值</title>
    <url>/2020/09/03/R/R-data-frame-search/</url>
    <content><![CDATA[<h2 id="內容說明"><a href="#內容說明" class="headerlink" title="內容說明"></a>內容說明</h2><blockquote>
<p>寫程式的時候是不可能沒遇到 bug 的，bug 紀錄整理</p>
</blockquote>
<a id="more"></a>

<h2 id="QUESTION-data-frame-要怎麼搜尋欄位中的值"><a href="#QUESTION-data-frame-要怎麼搜尋欄位中的值" class="headerlink" title="QUESTION! data_frame 要怎麼搜尋欄位中的值"></a>QUESTION! data_frame 要怎麼搜尋欄位中的值</h2><p>假如有一 dataframe 長這樣 (變數命名為 df )</p>
<table>
<thead>
<tr>
<th>Quiz</th>
<th>Score</th>
</tr>
</thead>
<tbody><tr>
<td>math</td>
<td>60</td>
</tr>
<tr>
<td>chinese</td>
<td>70</td>
</tr>
<tr>
<td>english</td>
<td>80</td>
</tr>
</tbody></table>
<p>我要尋找 english 的分數，那我應該語法要怎麼打比較好？</p>
<h3 id="answer"><a href="#answer" class="headerlink" title="answer:"></a>answer:</h3><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">print(df[df[<span class="string">'Quiz'</span>==<span class="string">'english'</span>],<span class="number">2</span>])</span><br></pre></td></tr></table></figure>
<p>這樣就可以搞定了！我在查這語法時真的花很多時間查詢。而且網站還是寫 python 的 XD，但他啟發了我，很謝謝他。</p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://www.edureka.co/community/43215/how-to-find-the-index-of-a-particular-value-in-a-dataframe" target="_blank" rel="noopener">How to find the index of a particular value in a dataframe?</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>程式語言的世界博大精神，要是沒有他們的付出我能走上現在的路嗎?<br>肯定是沒辦法的，於是我也需要更努力地去為社會付出。</p>
]]></content>
      <categories>
        <category>R語言</category>
      </categories>
      <tags>
        <tag>R語言</tag>
        <tag>學習筆記</tag>
        <tag>R dataframe</tag>
      </tags>
  </entry>
  <entry>
    <title>unlist 用法說明</title>
    <url>/2020/09/03/R/R-unlist/</url>
    <content><![CDATA[<h2 id="內容說明"><a href="#內容說明" class="headerlink" title="內容說明"></a>內容說明</h2><blockquote>
<p>寫程式的時候是不可能沒遇到 bug 的，bug 紀錄整理</p>
</blockquote>
<a id="more"></a>

<h2 id="ERROR-將-list-gt-unlist-後元素變少"><a href="#ERROR-將-list-gt-unlist-後元素變少" class="headerlink" title="ERROR! 將 list %&gt;% unlist 後元素變少"></a>ERROR! 將 list %&gt;% unlist 後元素變少</h2><blockquote>
<p>有非常高機率是因為 unlist 他在將 list 解開時，會「自動」將 character(0) 等只要 型態(0) 之類的元素會直接移除掉</p>
</blockquote>
<h3 id="solution-1"><a href="#solution-1" class="headerlink" title="solution 1:"></a>solution 1:</h3><p>那我們應該要怎麼辦？要是每次都這樣我就不用寫程式拉！<br>還是有辦法的，unlist 之後在加 lapply 做判斷，例如</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">unlist(lapply( list_object , <span class="keyword">function</span>(x) ifelse(length(x) &gt; <span class="number">0</span> , x , <span class="literal">NA</span>)  ))</span><br></pre></td></tr></table></figure>
<p>這樣就不會有元素被移除的問題出現。</p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://stackoverflow.com/questions/44659559/unlist-a-column-while-retaining-character0-as-empty-strings-in-r?noredirect=1&lq=1" target="_blank" rel="noopener">Unlist a column while retaining character(0) as empty strings in R</a><br><a href="https://stackoverflow.com/questions/51518592/how-to-unlist-a-numeric-list-in-r-and-keep-all-the-empty-rows" target="_blank" rel="noopener">How to unlist a numeric list in R and keep all the empty rows?</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>程式語言的世界博大精神，要是沒有他們的付出我能走上現在的路嗎?<br>肯定是沒辦法的，於是我也需要更努力地去為社會付出。</p>
]]></content>
      <categories>
        <category>R語言</category>
      </categories>
      <tags>
        <tag>R語言</tag>
        <tag>學習筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>list 用法說明</title>
    <url>/2020/09/04/R/R-list/</url>
    <content><![CDATA[<h2 id="內容說明"><a href="#內容說明" class="headerlink" title="內容說明"></a>內容說明</h2><blockquote>
<p>寫程式的時候是不可能沒遇到 bug 的，bug 紀錄整理<br>這裡介紹的非一般 list 普通用法，而是來展現一些神奇的操作 XD</p>
</blockquote>
<a id="more"></a>

<h2 id="list-是甚麼"><a href="#list-是甚麼" class="headerlink" title="list 是甚麼?"></a>list 是甚麼?</h2><p>一個讓我非常訝異的 object，他可以變形成 array、dict…等，讓你驚奇的狀態</p>
<h2 id="用-list-實作-dict"><a href="#用-list-實作-dict" class="headerlink" title="用 list 實作 dict"></a>用 list 實作 dict</h2><p>很簡單，R 的 list 不只可以用數字當作索引，<strong>文字</strong>也可以！所以就像下方範例即可。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">#簡單物件，其中 a 只能是簡單物件，如 cha , num ,logic , list一層 </span></span><br><span class="line">list[<span class="string">'test'</span>] &lt;- a</span><br></pre></td></tr></table></figure>

<p>但需要注意的是，這時候的 list 裡面只能放入簡單物件，不能有複雜型態。如: list 裡面又有 list…。</p>
<h3 id="教練，可是我想要讓-list-更好用呀！他應該沒有像-C-Map-一樣那麼不方便吧！"><a href="#教練，可是我想要讓-list-更好用呀！他應該沒有像-C-Map-一樣那麼不方便吧！" class="headerlink" title="教練，可是我想要讓 list 更好用呀！他應該沒有像 C++ Map 一樣那麼不方便吧！"></a>教練，可是我想要讓 list 更好用呀！他應該沒有像 C++ Map 一樣那麼不方便吧！</h3><p>當然沒有。他是 R，你痛苦的時候會想要，RRRRRRR 的叫呀~</p>
<p>如果想要這時候的 list 可以放入複雜型態時，可看下方舉例：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">#複雜物件，其中裡面想要多複雜都可以完成</span></span><br><span class="line">list[[<span class="string">'test'</span>]] &lt;- list(a=<span class="number">4</span> , b=list())</span><br></pre></td></tr></table></figure>
<p>這樣子後 list 裡面就可以在放入 list，達到許多完美的操作！</p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>程式語言的世界博大精神，要是沒有他們的付出我能走上現在的路嗎?<br>肯定是沒辦法的，於是我也需要更努力地去為社會付出。</p>
<p>這裡也要感謝牛哥(牛維方) 給我看了許多神奇又酷的 R 操作，讓我在學習 R 的路上突飛猛進，非常謝謝他。省去了我在網路上翻找文章解決問題的時間。</p>
<p><del>R 語言跟 C 真的差太多…，當初寫 R 的人腦袋到底是吸了甚麼，可以讓 R 跟祖先語言(c) 差那麼多wwww ~</del></p>
]]></content>
      <categories>
        <category>R語言</category>
      </categories>
      <tags>
        <tag>R語言</tag>
        <tag>學習筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>centOS 基礎指令教學</title>
    <url>/2020/07/25/linux/centOS-command/</url>
    <content><![CDATA[<h2 id="內容說明"><a href="#內容說明" class="headerlink" title="內容說明"></a>內容說明</h2><blockquote>
<p>記錄我在 centOS 上遇到的指令困難，讓我以後不忘記XD<br>此版本為: centOS 6</p>
</blockquote>
<a id="more"></a>

<h2 id="成為-root-的使用者"><a href="#成為-root-的使用者" class="headerlink" title="成為 root 的使用者"></a>成為 root 的使用者</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">su</span><br></pre></td></tr></table></figure>
<p>接下來會輸入密碼，密碼在 ternimal 上不會顯示，但他還是有運作的，用力地按下 ENTER 吧!之後應該會看到自己的 ternimal 中會出現 <code>[user @ path] #</code> 就代表你成功了!</p>
<h2 id="查看底下資料夾"><a href="#查看底下資料夾" class="headerlink" title="查看底下資料夾"></a>查看底下資料夾</h2><p>因為是在 ternimal 所以沒有 gui 介面告訴你裡面有哪些資料夾，這時候輸入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls</span><br></pre></td></tr></table></figure>
<p>之後會出現許多子目錄接下來如果文字顯現是，<strong><font color="#0000FF">藍色，代表是資料夾</font></strong>、<strong><font color="#ff0000">紅色，代表是檔案</font></strong>。</p>
<h2 id="新增資料夾"><a href="#新增資料夾" class="headerlink" title="新增資料夾"></a>新增資料夾</h2><p>如果要在 centOS 底下新增資料夾輸入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir folder_name</span><br></pre></td></tr></table></figure>
<p>就會產生了</p>
<h2 id="查看電腦的-RAM"><a href="#查看電腦的-RAM" class="headerlink" title="查看電腦的 RAM"></a>查看電腦的 RAM</h2><p>以 MB 顯示記憶體</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">free -m</span><br></pre></td></tr></table></figure>
<p>以 GB 顯示記憶體</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">free -g</span><br></pre></td></tr></table></figure>
<h4 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h4><p><a href="https://www.opencli.com/linux/linux-check-ram-usage-spec" target="_blank" rel="noopener">Linux 查看記憶體 (RAM) 使用狀況及規格</a></p>
<h2 id="查看安裝歷史"><a href="#查看安裝歷史" class="headerlink" title="查看安裝歷史"></a>查看安裝歷史</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">history</span><br></pre></td></tr></table></figure>

<h2 id="移除套件"><a href="#移除套件" class="headerlink" title="移除套件"></a>移除套件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum remove vlc</span><br></pre></td></tr></table></figure>
<h4 id="參考連結-1"><a href="#參考連結-1" class="headerlink" title="參考連結"></a>參考連結</h4><p><a href="https://darkranger.no-ip.org/archives/v5/document/linux/yum.htm" target="_blank" rel="noopener">How-To：用 yum 進行軟體安裝移除與更新</a></p>
<h2 id="查看更新"><a href="#查看更新" class="headerlink" title="查看更新"></a>查看更新</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc --version</span><br></pre></td></tr></table></figure>

<h2 id="查看電腦-ip"><a href="#查看電腦-ip" class="headerlink" title="查看電腦 ip"></a>查看電腦 ip</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ip a</span><br></pre></td></tr></table></figure>
<h4 id="參考連結-2"><a href="#參考連結-2" class="headerlink" title="參考連結"></a>參考連結</h4><p><a href="https://www.opencli.com/linux/ip-command" target="_blank" rel="noopener">ip 指令 — 取代 ifconfig 的工具</a></p>
<h2 id="將程式放後台執行"><a href="#將程式放後台執行" class="headerlink" title="將程式放後台執行"></a>將程式放後台執行</h2><p>命令後 + &amp;<br>EX:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">R &amp;</span><br></pre></td></tr></table></figure>

<h2 id="查看現在有那些後台"><a href="#查看現在有那些後台" class="headerlink" title="查看現在有那些後台"></a>查看現在有那些後台</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jobs</span><br></pre></td></tr></table></figure>

<h2 id="將後台指令刪除"><a href="#將後台指令刪除" class="headerlink" title="將後台指令刪除"></a>將後台指令刪除</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kill -9 %i</span><br></pre></td></tr></table></figure>
<p>i = jobs上的數字</p>
<h4 id="參考連結-3"><a href="#參考連結-3" class="headerlink" title="參考連結"></a>參考連結</h4><p><a href="http://linux.vbird.org/linux_basic/0440processcontrol.php" target="_blank" rel="noopener">第十六章、程序管理與 SELinux 初探</a><br><a href="https://blog.csdn.net/YuZhiHui_No1/article/details/44564963" target="_blank" rel="noopener">Linux任务/进程前后台切换</a></p>
<h2 id="排成-使電腦在特定時段啟動此程式"><a href="#排成-使電腦在特定時段啟動此程式" class="headerlink" title="排成(使電腦在特定時段啟動此程式)"></a>排成(使電腦在特定時段啟動此程式)</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">crontab -e 編輯排成</span><br><span class="line"><span class="number">00</span> <span class="number">03</span> * * * Rscript /home/archcopilot/public_html/david53133/v2.0/main.R</span><br><span class="line">crontab -l 檢查</span><br></pre></td></tr></table></figure>
<h4 id="參考連結-4"><a href="#參考連結-4" class="headerlink" title="參考連結"></a>參考連結</h4><p><a href="https://stackoverflow.max-everyday.com/2017/08/centos-crontab/" target="_blank" rel="noopener">CentOS 的cron自動排程</a></p>
<h2 id="如何更改時間"><a href="#如何更改時間" class="headerlink" title="如何更改時間"></a>如何更改時間</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo date -s &quot;2020&#x2F;08&#x2F;20 17:37:32&quot;</span><br><span class="line">sudo date -s &quot;Thu, 20 Aug 2020 17:40:32 CST&quot;</span><br></pre></td></tr></table></figure>
<h4 id="參考連結-5"><a href="#參考連結-5" class="headerlink" title="參考連結"></a>參考連結</h4><p><a href="https://blog.gtwang.org/linux/howto-set-date-time-from-linux-command-prompt/" target="_blank" rel="noopener">Linux 手動更改系統時間：date、hwclock 與 timedatectl 指令用法教學</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>centOS我也是第一次摸過並不太認識他阿，現在慢慢熟悉希望可以把它變成自己的技能之一。</p>
<h2 id="更新日誌"><a href="#更新日誌" class="headerlink" title="更新日誌"></a>更新日誌</h2><p>2020-07-25 20:48:32 - 完成</p>
<ol>
<li>成為 root 的使用者</li>
<li>查看底下資料夾</li>
<li>新增資料夾</li>
</ol>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>linux</tag>
        <tag>centOS</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 刪除已被監聽的 port</title>
    <url>/2020/08/20/linux/linux-kill-port/</url>
    <content><![CDATA[<h2 id="內容說明"><a href="#內容說明" class="headerlink" title="內容說明"></a>內容說明</h2><blockquote>
<p>記錄我在 LINUX 上遇到的問題</p>
<p>會寫這篇的原因是因為我在寫 R 的 api 並且架在 godaddy 的 server 時，常常遇到自己想使用的 port 被監聽，但那 port 有沒有用。</p>
</blockquote>
<a id="more"></a>

<h2 id="解決方法"><a href="#解決方法" class="headerlink" title="解決方法"></a>解決方法</h2><h3 id="查詢自己的-port"><a href="#查詢自己的-port" class="headerlink" title="查詢自己的 port"></a>查詢自己的 port</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo netstat -lpn |grep 3000</span><br></pre></td></tr></table></figure>
<p>3000 為數字，可以自行更改，之後看他跳出的資訊最後面應該會有 5 數字，記住那五數字。</p>
<h3 id="把監聽-port-刪除"><a href="#把監聽-port-刪除" class="headerlink" title="把監聽 port 刪除"></a>把監聽 port 刪除</h3><p>知道自己的 port 後，就將那 5 數字記起來</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kill 12345</span><br></pre></td></tr></table></figure>
<p>這樣就完成了！</p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://andy6804tw.github.io/2018/02/09/kill-port/" target="_blank" rel="noopener">如何清除系統上被佔用的Port?</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>LINUX 好多事情真的需要我學，跟 WINDOWS 又是完全不一樣的東西，學起來我就又多一把刷子了 XD</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>在 centOS6 安裝 Python 3.6</title>
    <url>/2020/09/05/linux/centOS-install-python36/</url>
    <content><![CDATA[<h2 id="內容說明"><a href="#內容說明" class="headerlink" title="內容說明"></a>內容說明</h2><blockquote>
<p>如何在 centOS 上安裝 Python 教學</p>
</blockquote>
<a id="more"></a>

<h2 id="安裝教學"><a href="#安裝教學" class="headerlink" title="安裝教學"></a>安裝教學</h2><h3 id="第一步，安裝前置作業必要套件"><a href="#第一步，安裝前置作業必要套件" class="headerlink" title="第一步，安裝前置作業必要套件"></a>第一步，安裝前置作業必要套件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum install gcc bzip2-devel libffi-devel  </span><br><span class="line">sudo yum install pcre pcre-devel</span><br><span class="line">sudo yum install zlib zlib-devel</span><br><span class="line">sudo yum install openssl openssl-devel</span><br></pre></td></tr></table></figure>

<h3 id="第二步，去-python-官網下載-python，之後解壓縮"><a href="#第二步，去-python-官網下載-python，之後解壓縮" class="headerlink" title="第二步，去 python 官網下載 python，之後解壓縮"></a>第二步，去 python 官網下載 python，之後解壓縮</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;www.python.org&#x2F;ftp&#x2F;python&#x2F;3.6.1&#x2F;Python-3.6.1.tgz</span><br><span class="line">tar -zxvf Python-3.6.1.tgz</span><br></pre></td></tr></table></figure>

<h3 id="第三步，在-centOS-上編譯-python-source"><a href="#第三步，在-centOS-上編譯-python-source" class="headerlink" title="第三步，在 centOS 上編譯 python source"></a>第三步，在 centOS 上編譯 python source</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd Python-3.6.1</span><br><span class="line"> .&#x2F;configure --with-ssl</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<h3 id="第四步，建立-python3-路徑"><a href="#第四步，建立-python3-路徑" class="headerlink" title="第四步，建立 python3  路徑"></a>第四步，建立 python3  路徑</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ln -s &#x2F;usr&#x2F;local&#x2F;bin&#x2F;python3 &#x2F;usr&#x2F;bin&#x2F;python3</span><br></pre></td></tr></table></figure>

<h3 id="第五步，檢查-python-是否安裝成功"><a href="#第五步，檢查-python-是否安裝成功" class="headerlink" title="第五步，檢查 python 是否安裝成功"></a>第五步，檢查 python 是否安裝成功</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python3 -V</span><br></pre></td></tr></table></figure>
<p>以上全部都完成後，那在 centOS6 上就沒有問題了！</p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>可能由於有安裝過 R 的關係，這次 PY 沒有在像之前一樣難安裝。不過也是要謝謝這些願意把 Python 交付給大家的人們，沒有他們，我絕對沒辦法安裝的這麼快！</p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://medium.com/ianyc/python-%E5%9C%A8-centos7-%E4%B8%8A%E5%AE%89%E8%A3%9D-python3-6-f3c3a6f28e2f" target="_blank" rel="noopener">[CentOS][Python] 在 CentOS7 上安裝 python3.6</a></p>
]]></content>
      <categories>
        <category>linux</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>linux</tag>
        <tag>centOS</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>ERROR! Can&#39;t connect to HTTPS URL because the SSL module is not available</title>
    <url>/2020/09/05/linux/centOS-ERROR-openssl/</url>
    <content><![CDATA[<h2 id="內容說明"><a href="#內容說明" class="headerlink" title="內容說明"></a>內容說明</h2><blockquote>
<p>由於 python 3.6 中的 pip 套件要求 openssl 版本需要大於 1.0.2，但 centOS6 可更新的最高版本只能到 1.0.1，於是必須重新安裝。<br><del>centOS6，跟 python 都好麻煩…</del></p>
</blockquote>
<a id="more"></a>
<h2 id="ERROR-Can’t-connect-to-HTTPS-URL-because-the-SSL-module-is-not-available"><a href="#ERROR-Can’t-connect-to-HTTPS-URL-because-the-SSL-module-is-not-available" class="headerlink" title="ERROR: Can’t connect to HTTPS URL because the SSL module is not available"></a>ERROR: Can’t connect to HTTPS URL because the SSL module is not available</h2><p>我是在進行 <code>pip install requests</code>時發生，內容大意是指說 pip 不能夠用 SSL，所以找不到套件可以安裝。<del>其實是說沒有相對應的版本，但我覺得這樣講很爛</del></p>
<h2 id="solution-update-openssl-and-vim-file"><a href="#solution-update-openssl-and-vim-file" class="headerlink" title="solution: update openssl and vim file"></a>solution: update openssl and vim file</h2><p>由於此問題是 SSL，在我花了約 1 小時查找文件後找出是因為 openssl 版本需要大於 1.0.2，但 centOS6 可更新的最高版本只能到 1.0.1，所以需要進行更新。</p>
<p>如果是 os 為 centOS6 可參考此篇<br><a href="https://theriseofdavid.github.io/2020/09/05/linux/linux-openssl1.1.0-update/" target="_blank" rel="noopener">CentOS6 安裝與更新 openssl 1.1.0 教學</a></p>
<h3 id="更新完-openssl-後，怎麼做"><a href="#更新完-openssl-後，怎麼做" class="headerlink" title="更新完 openssl 後，怎麼做?"></a>更新完 openssl 後，怎麼做?</h3><p>重新編譯一次 python ，cd 回 python</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd Python-a.b.c</span><br><span class="line">.&#x2F;configure --with-ssl</span><br></pre></td></tr></table></figure>

<h3 id="修改文件，讓-pip-可以抓到-openssl-路徑"><a href="#修改文件，讓-pip-可以抓到-openssl-路徑" class="headerlink" title="修改文件，讓 pip 可以抓到 openssl 路徑"></a>修改文件，讓 pip 可以抓到 openssl 路徑</h3><p><strong>需要先找到自己的 openssl 資料夾，驗證可以看 openssl 資料夾內有沒有 include..等資料夾，記住此路徑，接下來會用到。</strong></p>
<p>先不要急著輸入 make 指令，先修改文件 Python-a.b.c/Modules/Setup</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim .&#x2F;Modules&#x2F;Setup</span><br></pre></td></tr></table></figure>
<p>應該會出現一堆開頭井字的程式碼，之後搜尋 SSL=，方法為 <code>/SSL=</code><br>如果正確的話視窗應顯示在這裡</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># Socket module helper for SSL support; you must comment out the other</span><br><span class="line"># socket line above, and possibly edit the SSL variable:</span><br><span class="line">SSL&#x3D;&#x2F;usr&#x2F;local&#x2F;lab&#x2F;openssl-1.0.2j&#x2F;    #將這行註解取消，並把 openssl 的路徑放入 SSL&#x3D; 之後</span><br><span class="line">_ssl _ssl.c \     #將這行註解取消</span><br><span class="line">-DUSE_SSL -I$(SSL)&#x2F;include -I$(SSL)&#x2F;include&#x2F;openssl \      #將這行註解取消</span><br><span class="line">-L$(SSL)&#x2F;lib -lssl -lcrypto      #將這行註解取消</span><br><span class="line"></span><br><span class="line"># The crypt module is now disabled by default because it breaks builds</span><br><span class="line"># on many systems (where -lcrypt is needed), e.g. Linux (I believe).</span><br><span class="line"></span><br><span class="line">#_crypt _cryptmodule.c # -lcrypt    # crypt(3); needs -lcrypt on some systems</span><br></pre></td></tr></table></figure>

<h3 id="修改完成後，編譯與安裝"><a href="#修改完成後，編譯與安裝" class="headerlink" title="修改完成後，編譯與安裝"></a>修改完成後，編譯與安裝</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make </span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<h3 id="驗證"><a href="#驗證" class="headerlink" title="驗證"></a>驗證</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip3 install requests</span><br></pre></td></tr></table></figure>

<p>以上全部都沒問題驗證也成功話，那在 centOS6 上就沒有問題了！太強了你，我花了兩小時才解決此問題..</p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://www.cnblogs.com/reblue520/p/11103311.html" target="_blank" rel="noopener">centos6.8安装python3.7.3报错Can’t connect to HTTPS URL because the SSL module is not available问题解决</a><br><a href="https://blog.csdn.net/rongDang/article/details/102871874" target="_blank" rel="noopener">Centos7安装uwsgi出现关于SSL错误的问题</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>環境的問題時常把新手搞得喘不過氣，幸好這次我能克服此困難。希望以後 python 的版本控制能夠更好，centOS6 提供的相容性也可以更棒！雖然他 2020/11 就要停止更新了…<br>不過還是謝謝能在網路上提供資源的大神們，沒有他們，我連解決都不能解決！</p>
<p>尤其是國人，技術資源國人比起台灣資源多很多。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>linux</tag>
        <tag>centOS</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>在 centOS6 安裝 Python 3.8</title>
    <url>/2020/08/28/linux/centOS-install-python38/</url>
    <content><![CDATA[<h2 id="內容說明"><a href="#內容說明" class="headerlink" title="內容說明"></a>內容說明</h2><blockquote>
<p>如何在 centOS 上安裝 Python 教學</p>
</blockquote>
<a id="more"></a>

<h2 id="安裝教學"><a href="#安裝教學" class="headerlink" title="安裝教學"></a>安裝教學</h2><h3 id="第一步，安裝前置作業必要套件"><a href="#第一步，安裝前置作業必要套件" class="headerlink" title="第一步，安裝前置作業必要套件"></a>第一步，安裝前置作業必要套件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum install gcc openssl-devel bzip2-devel libffi-devel</span><br></pre></td></tr></table></figure>

<h3 id="第二步，去-python-官網下載-python，之後解壓縮"><a href="#第二步，去-python-官網下載-python，之後解壓縮" class="headerlink" title="第二步，去 python 官網下載 python，之後解壓縮"></a>第二步，去 python 官網下載 python，之後解壓縮</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;www.python.org&#x2F;ftp&#x2F;python&#x2F;3.8.5&#x2F;Python-3.8.5.tgz</span><br><span class="line">tar xzf Python-3.8.5.tgz</span><br></pre></td></tr></table></figure>

<h3 id="第三步，在-centOS-上編譯-python-source"><a href="#第三步，在-centOS-上編譯-python-source" class="headerlink" title="第三步，在 centOS 上編譯 python source"></a>第三步，在 centOS 上編譯 python source</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd Python-3.8.5</span><br><span class="line">sudo .&#x2F;configure --enable-optimizations</span><br><span class="line">sudo make altinstall</span><br></pre></td></tr></table></figure>

<h3 id="第四步，解除安裝-python-壓縮檔"><a href="#第四步，解除安裝-python-壓縮檔" class="headerlink" title="第四步，解除安裝 python 壓縮檔"></a>第四步，解除安裝 python 壓縮檔</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo rm Python-3.8.5.tgz</span><br></pre></td></tr></table></figure>

<h3 id="第五步，檢查-python-是否安裝成功"><a href="#第五步，檢查-python-是否安裝成功" class="headerlink" title="第五步，檢查 python 是否安裝成功"></a>第五步，檢查 python 是否安裝成功</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python3.8 -V</span><br></pre></td></tr></table></figure>

<p>以上全部都完成後，那在 centOS6 上就沒有問題了！</p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>可能由於有安裝過 R 的關係，這次 PY 沒有在像之前一樣難安裝。不過也是要謝謝這些願意把 Python 交付給大家的人們，沒有他們，我絕對沒辦法安裝的這麼快！</p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://packaging.python.org/guides/installing-using-linux-tools/" target="_blank" rel="noopener">Installing pip/setuptools/wheel with Linux Package Managers</a></p>
]]></content>
      <categories>
        <category>linux</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>linux</tag>
        <tag>centOS</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>在 centOS 上安裝 R 3.2.0</title>
    <url>/2020/07/15/linux/install-R3.2.0-centOS6/</url>
    <content><![CDATA[<h2 id="內容說明"><a href="#內容說明" class="headerlink" title="內容說明"></a>內容說明</h2><blockquote>
<p>如何在 centOS 上安裝 R ，並記錄所有的坑與雷點<br>sudo apt-get install build-essential (OS: ubuntu) 與 yum install gcc gcc-c++ make (OS : centOS ) 不同需要特別注意<br>此版本為: centOS 6</p>
</blockquote>
<a id="more"></a>

<h2 id="安裝教學"><a href="#安裝教學" class="headerlink" title="安裝教學"></a>安裝教學</h2><ol>
<li><p>先卸載，怕有之前的遺毒存在</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo make uninstall</span><br></pre></td></tr></table></figure>
</li>
<li><p>刪除文件夾</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rm -rf 文件夾名</span><br></pre></td></tr></table></figure>
</li>
<li><p>安裝前置作業必要套件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install gcc-gfortran     </span><br><span class="line">yum install gcc gcc-c++ </span><br><span class="line">yum install readline-devel    </span><br><span class="line">yum install libXt-devel</span><br><span class="line">yum install libpng libpng-devel libtiff libtiff-devel libjpeg-turbo libjpeg-turbo-devel</span><br></pre></td></tr></table></figure>
</li>
<li><p>下載 R-3.5.0.tag.gz </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget http:&#x2F;&#x2F;cran.r-project.org&#x2F;src&#x2F;base&#x2F;R-3&#x2F;R-3.5.0.tar.gz</span><br></pre></td></tr></table></figure>
</li>
<li><p>解壓縮並且移動路徑至 R-3.5.0 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -zxvf R-3.5.0.tar.gz</span><br><span class="line">cd R-3.5.0</span><br></pre></td></tr></table></figure>
</li>
<li><p>編譯，如果前面動作並未絕對正確，有高機率出錯，必先檢查</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;configure --enable-R-shlib --with-libpng --with-jpeglib --with-libtiff --with-x</span><br></pre></td></tr></table></figure>
</li>
<li><p>安裝</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>輸入指令後須等一段時間</strong>，這裡其實已完成安裝，可執行檔在 /home/R/R-3.5.0/bin 底下，此時 /user/local/bin 還沒有可執行的 R </p>
<ol start="8">
<li><p>將 R 登錄</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make install</span><br></pre></td></tr></table></figure>
</li>
<li><p>退出並測試</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exit()</span><br><span class="line">R</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="錯誤排除"><a href="#錯誤排除" class="headerlink" title="錯誤排除"></a>錯誤排除</h2><h3 id="安裝套件問題"><a href="#安裝套件問題" class="headerlink" title="安裝套件問題"></a>安裝套件問題</h3><ol>
<li>嘗試重新安裝 gcc and g++ </li>
</ol>
<p>如果出現這樣，就代表正確了！<br><img src="/images/install-R-centOS/1.png" alt=""></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>我在上班時，試圖下載 R 3.4.2，但是因為電腦裡面缺少了 f77 complier 於是我再補足裡面缺少的套件，安裝時我才發現他的作業系統是centOS (要用 yum)，然後安裝完後發現為甚麼還是沒辦法執行R，剛剛才剛查到R3.4.2 在centOS上無法安裝，於是我現在安裝 R3.2.0 就成功了，真的很感動! ಥ⌣ಥ</p>
<p>查資料是件非常痛苦的方式，從 0 到 1 阿，嗚嗚。</p>
<h2 id="學習連結"><a href="#學習連結" class="headerlink" title="學習連結"></a>學習連結</h2><p>我在尋找的過程中，受到這幾個網站的幫助，如下:<br><a href="https://www.itdaan.com/tw/afce024b1d217e38d0c893a33e26908c" target="_blank" rel="noopener">centos 6.5下安裝R 3.2.0</a><br><a href="https://www.jianshu.com/p/08d90cb4ed8b" target="_blank" rel="noopener">安装R语言包的各种坑</a><br><a href="https://stackoverflow.com/questions/20752307/error-in-install-previous-versions-of-r-on-ubuntu/31036155" target="_blank" rel="noopener">error in Install previous versions of R on ubuntu</a><br><a href="https://uiop7890.pixnet.net/blog/post/29385923-%5B%E8%BD%89%E8%B2%BC%5D-xxx-is-not-in-the-sudoers-file%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95" target="_blank" rel="noopener">xxx-is-not-in-the-sudoers-file解决方法</a></p>
]]></content>
      <categories>
        <category>R語言</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>R語言</tag>
        <tag>學習筆記</tag>
        <tag>linux</tag>
        <tag>centOS</tag>
      </tags>
  </entry>
  <entry>
    <title>在 centOS6 上安裝 R 3.6.0</title>
    <url>/2020/08/12/linux/install-R3.6.0-centOS6/</url>
    <content><![CDATA[<h2 id="內容說明"><a href="#內容說明" class="headerlink" title="內容說明"></a>內容說明</h2><blockquote>
<p>如何在 centOS 上安裝 R ，並記錄所有的坑與雷點<br>sudo apt-get install build-essential (OS: ubuntu) 與 yum install gcc gcc-c++ make (OS : centOS ) 不同需要特別注意<br>此版本為: centOS 6<br>為甚麼會寫兩篇文章關於 R 的安裝呢，很簡單！因為之前 3.2.0 不支援太多套件了，只好來重新安裝 R 的新版本(P.S. 不歸路阿…都是坑)<br><strong>注意:如果不需要，建議還是<a href="https://theriseofdavid.github.io/2020/07/15/linux/install-R3.2.0-centOS6/" target="_blank" rel="noopener">安裝 3.2.0</a> 較為方便</strong><br>centOS6 在安裝 R新版本會有非常大問題出錯。<br><strong><font color="#dd0000">警告:這篇文章實用性不高，對於可信度請不要太過於相信，太多事情沒有紀錄確實。在此獻上歉意</font></strong><br>為甚麼實用性不高，還要放在網路上呢? 因為就算實用性不高這些錯誤我曾踩過，也許未來的我能從這邊啟發一些事情</p>
</blockquote>
<a id="more"></a>

<h2 id="安裝教學"><a href="#安裝教學" class="headerlink" title="安裝教學"></a>安裝教學</h2><ol>
<li><p>安裝前置作業必要套件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install gcc-gfortran     </span><br><span class="line">yum install gcc gcc-c++ </span><br><span class="line">yum install readline-devel    </span><br><span class="line">yum install libXt-devel</span><br><span class="line">yum install libpng libpng-devel libtiff libtiff-devel libjpeg-turbo libjpeg-turbo-devel</span><br><span class="line">yum install libgfortran4</span><br><span class="line">yum install libxml2-devel</span><br></pre></td></tr></table></figure>
</li>
<li><p>安裝使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum install epel-release</span><br><span class="line">sudo yum install R</span><br><span class="line">sudo .&#x2F;configure --prefix&#x3D;&#x2F;opt&#x2F;R&#x2F;3.6.0 --enable-R-shlib</span><br></pre></td></tr></table></figure>




</li>
</ol>
<h2 id="錯誤排除"><a href="#錯誤排除" class="headerlink" title="錯誤排除"></a>錯誤排除</h2><h3 id="R-如果-ERROR-並且你的-linux-系統-c-lt-11-or-nullptr-不可用-就必須要安裝-c-11"><a href="#R-如果-ERROR-並且你的-linux-系統-c-lt-11-or-nullptr-不可用-就必須要安裝-c-11" class="headerlink" title="R 如果 ERROR 並且你的 linux 系統 c++ &lt; 11 or nullptr 不可用 就必須要安裝 c++ 11"></a>R 如果 ERROR 並且你的 linux 系統 c++ &lt; 11 or nullptr 不可用 就必須要安裝 c++ 11</h3><p>如果你在安裝套件上遇到錯誤時，仔細閱讀可以發現似乎有 bug 關於說 nullptr 不可使用，這時候你可能知道了一件事，對！centOS6 的 complier 是 C99，不是 C11，生不生氣!所以我們就要來安裝 C11</p>
<h4 id="Answer"><a href="#Answer" class="headerlink" title="Answer:"></a>Answer:</h4><p><a href="https://forums.centos.org/viewtopic.php?t=68077" target="_blank" rel="noopener">run a c++ program with c++11 support in older CentOS machine</a> 參考此文章，這文章寫得很好。</p>
<h3 id="ERROR-C-11-standard-requested-but-CXX11-is-not-defined"><a href="#ERROR-C-11-standard-requested-but-CXX11-is-not-defined" class="headerlink" title="ERROR : C++11 standard requested but CXX11 is not defined"></a>ERROR : C++11 standard requested but CXX11 is not defined</h3><p>試圖加入這些命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CXX11 &#x3D; g++</span><br><span class="line">CXX11FLAGS &#x3D; -O2 -g $(LTO)</span><br><span class="line">CXX11PICFLAGS &#x3D; -fPIC</span><br><span class="line">CXX11STD &#x3D; -std&#x3D;c++11</span><br></pre></td></tr></table></figure>
<h4 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h4><p><a href="https://github.com/rstudio/httpuv/issues/82" target="_blank" rel="noopener">Installing hits ‘C++11 standard requested but CXX11 is not defined</a></p>
<h3 id="Error-Protected-multilib-versions"><a href="#Error-Protected-multilib-versions" class="headerlink" title="Error: Protected multilib versions"></a>Error: Protected multilib versions</h3><p>如果遇到有不同版本的問題，則將版本移除即可。下面是我遇到的錯誤訊息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Error: Protected multilib versions: libRmath-3.5.2-2.el6.i686 !&#x3D; libRmath-3.6.0-1.el6.x86_64</span><br><span class="line">Error: Protected multilib versions: R-java-devel-3.5.2-2.el6.i686 !&#x3D; R-java-devel-3.6.0-1.el6.x86_64</span><br></pre></td></tr></table></figure>
<p>解決方案</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum remove openssh</span><br><span class="line">sudo yum remove libRmath</span><br><span class="line">sudo yum remove R-java-devel</span><br></pre></td></tr></table></figure>

<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>老實說，這篇文章我並沒有打得很好，因為我花了太多時間在 debug，以及這是我第一次花時間去完整地找出 bug，然後各個擊破。我在 bug 的過程中沒有紀錄確實，導致紀錄的不好。有許多我知道我曾經有錯的地方我也有找出 solutation，但我卻沒有紀錄。我覺得這點不好，這樣我在以後如果有遇到類似問題時會遇到一樣久的時間。</p>
<p>但是有了這次經驗，我知道我應該要怎麼來做 debug 會更好。應該在邊學中碰到 Error 就做紀錄，這樣才是最好的。</p>
<h2 id="學習連結"><a href="#學習連結" class="headerlink" title="學習連結"></a>學習連結</h2><p>我在尋找的過程中，受到這幾個網站的幫助，如果我解釋得不好可以考慮從這些網站下尋求幫助，如下:<br><a href="https://centos.pkgs.org/6/centos-x86_64/libcurl-devel-7.19.7-53.el6_9.x86_64.rpm.html" target="_blank" rel="noopener">libcurl-devel-7.19.7-53.el6_9.x86_64.rpm</a><br><a href="https://blog.csdn.net/weixin_41929524/article/details/85008392" target="_blank" rel="noopener">在CentOS服务器上配置RStudio Server</a><br><a href="https://caozhilong.github.io/2019/06/12/install-R-language/" target="_blank" rel="noopener">linux下R 3.6.0的安装手册</a><br><a href="https://stackoverflow.com/questions/56325771/unable-to-install-r-3-6-0-on-centos" target="_blank" rel="noopener">Unable to install R 3.6.0 on centos</a><br><a href="http://hk.uwenku.com/question/p-pyanccch-bch.html" target="_blank" rel="noopener">本地安裝R-devel的Gfortran錯誤</a><br><a href="https://unix.stackexchange.com/questions/426161/updating-gfortran-on-scientific-linux-7" target="_blank" rel="noopener">Updating GFortran on Scientific Linux 7?</a><br><a href="https://centos.pkgs.org/6/epel-testing-x86_64/R-devel-3.6.0-1.el6.x86_64.rpm.html" target="_blank" rel="noopener">R-devel-3.6.0-1.el6.x86_64.rpm</a></p>
<h2 id="我在-debug-時做的簡單紀錄"><a href="#我在-debug-時做的簡單紀錄" class="headerlink" title="我在 debug 時做的簡單紀錄"></a>我在 debug 時做的簡單紀錄</h2><p>由於太簡單了，反而導致我很難做紀錄。需要改進</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">#install.packages("magrittr")</span></span><br><span class="line"><span class="comment">#install.packages("devtools") </span></span><br><span class="line">install.packages(<span class="string">"igraph"</span>)</span><br><span class="line"><span class="comment">#install.packages("RJSONIO")</span></span><br><span class="line">install.packages(<span class="string">"doBy"</span>)</span><br><span class="line"><span class="comment">#install.packages("ggplot2")</span></span><br><span class="line">install.packages(<span class="string">"jsonlite"</span>)</span><br><span class="line">install.packages(<span class="string">"plumber"</span>)</span><br><span class="line"></span><br><span class="line">sudo ./configure --prefix=/opt/R/<span class="number">3.5</span><span class="number">.0</span> --enable-R-shlib</span><br><span class="line">roxygen2</span><br><span class="line">BiocManager</span><br><span class="line">lintr</span><br><span class="line">rmarkdown</span><br><span class="line">spelling</span><br><span class="line">pkgdown</span><br><span class="line">devtools</span><br><span class="line">devtools::install_github(<span class="string">"gaborcsardi/pkgconfig"</span> , force=<span class="literal">TRUE</span>)</span><br><span class="line">devtools::install_github(<span class="string">"igraph/rigraph"</span>)</span><br><span class="line"></span><br><span class="line">yum remove libgfortran4</span><br><span class="line">yum install libgfortran4</span><br><span class="line">install_url(<span class="string">"http://igraph.googlecode.com/files/igraph_nightly_0.6-2689-20120412.tar.gz"</span>) </span><br><span class="line"><span class="keyword">library</span>(devtools)</span><br><span class="line"><span class="keyword">library</span>(remotes)</span><br><span class="line">install.packages(<span class="string">"igraph"</span>, dependencies = <span class="literal">TRUE</span>) <span class="comment"># R 版本必須大於 3.2.3</span></span><br><span class="line">install.packages(<span class="string">"devtools"</span>, repos = <span class="string">"http://cran.rstudio.com"</span>)</span><br><span class="line">remotes::install_version(<span class="string">'igraph'</span>, version = <span class="string">'1.1.1'</span> )</span><br><span class="line">install.packages(<span class="string">"remotes"</span>)</span><br><span class="line">install.packages(<span class="string">"readxl"</span>)</span><br><span class="line">install.packages(<span class="string">"igraph"</span>, repos = <span class="string">"http://cran.rstudio.com"</span>)</span><br><span class="line">install.packages(<span class="string">"RJSONIO"</span>, repos = <span class="string">"http://cran.rstudio.com"</span>)</span><br><span class="line">install.packages(<span class="string">"doBy"</span>, repos = <span class="string">"http://cran.rstudio.com"</span>)</span><br><span class="line">install.packages(<span class="string">"ggplot2"</span>, repos = <span class="string">"http://cran.rstudio.com"</span>)</span><br><span class="line">install.packages(<span class="string">"jsonlite"</span>, repos = <span class="string">"http://cran.rstudio.com"</span>)</span><br><span class="line">install.packages(<span class="string">"plumber"</span>, repos = <span class="string">"http://cran.rstudio.com"</span>)</span><br><span class="line"></span><br><span class="line">url &lt;- <span class="string">"https://cran.r-project.org/src/contrib/Archive/igraph/igraph_1.1.1.tar.gz"</span></span><br><span class="line">install.packages(url, repos=<span class="literal">NULL</span> , type=<span class="string">"source"</span>)</span><br><span class="line"></span><br><span class="line">install.packages(<span class="string">"devtools"</span>)</span><br><span class="line">install.packages(<span class="string">"later"</span>)</span><br><span class="line"></span><br><span class="line">install_version(“ggplot2”, version = “<span class="number">2.0</span><span class="number">.0</span>”, repos = “https://cran.r-project.org/src/contrib/Archive/ggplot2/”)</span><br><span class="line"></span><br><span class="line">install.versions(c(<span class="string">'checkpoint'</span>, <span class="string">'devtools'</span>), c(<span class="string">'0.3.3'</span>, <span class="string">'1.6.1'</span>))</span><br><span class="line">install.packages(<span class="string">"version"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">原文網址：https://kknews.cc/news/2q495g9.html</span><br><span class="line">wget http://cran.r-project.org/src/base/R-<span class="number">3</span>/R-<span class="number">3.5</span><span class="number">.0</span>.tar.gz</span><br><span class="line"></span><br><span class="line">tar -zxvf R-<span class="number">3.5</span><span class="number">.0</span>.tar.gz</span><br><span class="line">cd R-<span class="number">3.5</span><span class="number">.0</span></span><br><span class="line">原文網址：https://kknews.cc/news/2q495g9.html</span><br><span class="line"></span><br><span class="line">root密碼: +Z_F~Q!=mHch</span><br><span class="line">yum install libxml2-devel</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">In install.packages(<span class="string">"igraph"</span>, dependencies = <span class="literal">TRUE</span>) :</span><br><span class="line">  installation of package ‘later’ had non-zero exit status</span><br><span class="line"></span><br><span class="line">Warning messages:</span><br><span class="line"><span class="number">1</span>: In system2(cmd0, args, env = env, stdout = outfile, stderr = outfile) :</span><br><span class="line">  system call failed: Cannot allocate memory</span><br><span class="line"><span class="number">2</span>: In install.packages(<span class="string">"magrittr"</span>) :</span><br><span class="line">  installation of package ‘magrittr’ had non-zero exit status</span><br><span class="line"></span><br><span class="line">packageVersion(<span class="string">"magrittr"</span>)</span><br><span class="line"></span><br><span class="line">R -e <span class="string">'install.packages("magrittr")'</span></span><br><span class="line"></span><br><span class="line">http://<span class="number">192.168</span><span class="number">.10</span><span class="number">.39</span>:<span class="number">8551</span>/sum</span><br><span class="line"></span><br><span class="line"><span class="comment"># R 如果 ERROR 並且你的 linux 系統 c++ &lt; 11 or nullptr 不可用 就必須要安裝 c++ 11</span></span><br><span class="line">curl version <span class="number">7.70</span><span class="number">.0</span></span><br><span class="line"></span><br><span class="line">tar xzvf pcre-<span class="number">8.42</span>.tar.gz</span><br><span class="line">tar xzvf xz-<span class="number">5.2</span><span class="number">.5</span>.tar.gz </span><br><span class="line">tar xzvf zlib-<span class="number">1.2</span><span class="number">.11</span>.tar.gz</span><br><span class="line">tar xzvf R-<span class="number">3.5</span><span class="number">.0</span>.tar.gz</span><br><span class="line"></span><br><span class="line">delete /usr/lib64/pkgconfig/zlib.pc</span><br><span class="line"></span><br><span class="line">CXX11 = g++</span><br><span class="line">CXX11FLAGS = -O2 -g $(LTO)</span><br><span class="line">CXX11PICFLAGS = -fPIC</span><br><span class="line">CXX11STD = -std=c++<span class="number">11</span></span><br><span class="line"></span><br><span class="line">用一個指令就可以下載到最新版的，但可能有問題。要安裝一些指令</span><br><span class="line">Error <span class="keyword">in</span> .shlib_internal(args) : C++<span class="number">11</span> standard requested but CXX11 is not defined R 要 vim echo $(R RHOME)/etc/Makeconf 然後改其來</span><br><span class="line"></span><br><span class="line">yum remove gcc-gfortran</span><br><span class="line"></span><br><span class="line">igraph 下載 <span class="number">1.2</span><span class="number">.4</span><span class="number">.1</span> </span><br><span class="line"></span><br><span class="line">sudo find RConfig.h</span><br><span class="line"></span><br><span class="line">zU;7a%MXaH5Q</span><br><span class="line"></span><br><span class="line">plumber::plumb(file=<span class="string">'./plumber.R'</span>)$run()</span><br><span class="line"></span><br><span class="line">In file included from CHOLMOD/Supernodal/cholmod_super_numeric.c:<span class="number">80</span>:<span class="number">0</span>:</span><br><span class="line">CHOLMOD/Supernodal/t_cholmod_super_numeric.c:<span class="number">25</span>:<span class="number">21</span>: fatal error: Rconfig.h: No such file or directory</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">wget https://github.com/igraph/rigraph/archive/v1.1.0.tar.gz</span><br><span class="line">tar -zxvf v1.1.0.tar.gz</span><br><span class="line"></span><br><span class="line">rigraph-<span class="number">1.1</span><span class="number">.0</span></span><br><span class="line">install.packages(<span class="string">"./v1.1.0.tar.gz"</span>, repos = <span class="literal">NULL</span>, type = <span class="string">"source"</span>)</span><br><span class="line"></span><br><span class="line">install.packages(<span class="string">"https://cran.r-project.org/src/contrib/Archive/igraph/igraph_1.0.0.tar.gz"</span>, repo=<span class="literal">NULL</span>, type=<span class="string">"source"</span>)</span><br><span class="line">install.packages(u, type = <span class="string">"binary"</span>, repos = <span class="literal">NULL</span>)</span><br><span class="line">install.packages(<span class="string">"v1.1.0.tar.gz"</span>, repos = <span class="literal">NULL</span>, type=<span class="string">"source"</span>)</span><br><span class="line">R CMD INSTALL v1.1.0.tar.gz</span><br><span class="line"></span><br><span class="line">+Z_F~Q!=mHch</span><br><span class="line"></span><br><span class="line">/usr/include/R</span><br><span class="line"></span><br><span class="line">&gt; R.home(<span class="string">"lib"</span>)</span><br><span class="line">[<span class="number">1</span>] <span class="string">"/usr/lib64/R/lib"</span></span><br><span class="line"></span><br><span class="line">Error: Protected multilib versions</span><br><span class="line"></span><br><span class="line"><span class="comment">#yum install R-devel</span></span><br><span class="line"></span><br><span class="line">Error: Protected multilib versions: libRmath-<span class="number">3.5</span><span class="number">.2</span>-<span class="number">2.</span>el6.i686 != libRmath-<span class="number">3.6</span><span class="number">.0</span>-<span class="number">1.</span>el6.x86_64</span><br><span class="line">Error: Protected multilib versions: R-java-devel-<span class="number">3.5</span><span class="number">.2</span>-<span class="number">2.</span>el6.i686 != R-java-devel-<span class="number">3.6</span><span class="number">.0</span>-<span class="number">1.</span>el6.x86_64</span><br><span class="line"></span><br><span class="line">sudo yum remove openssh</span><br><span class="line">sudo yum remove libRmath</span><br><span class="line">sudo yum remove R-java-devel</span><br><span class="line"></span><br><span class="line">yum --enablerepo=epel-testing install R-devel</span><br><span class="line"></span><br><span class="line">install.packages(<span class="string">"igraph"</span>)</span><br><span class="line"></span><br><span class="line">yum remove  gcc-gfortran</span><br><span class="line">gfortran --version</span><br><span class="line">yum remove R-devel</span><br><span class="line"></span><br><span class="line">yum --enablerepo=epel-testing install gcc-gfortran</span><br><span class="line"></span><br><span class="line">yum remove devtoolset*</span><br><span class="line">gcc --version</span><br><span class="line"></span><br><span class="line"><span class="keyword">in</span> this c++ version is <span class="number">2010</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">../build_gcc_4.8.1/configure --enable-checking=release --enable-languages=c,c++ --disable-multilib</span><br><span class="line">./configure --enable-checking=release --enable-languages=c,c++ --disable-multilib </span><br><span class="line"></span><br><span class="line">tar -zxvf gcc-<span class="number">4.8</span><span class="number">.5</span>.tar.bz2 </span><br><span class="line">CentOS <span class="number">6</span>將於<span class="number">2020</span>年<span class="number">11</span>月死亡-遷移宜早不宜遲！ https://forums.centos.org/viewtopic.php?t=<span class="number">68077</span></span><br><span class="line"></span><br><span class="line">install.packages(<span class="string">"readxl"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">library</span>(plumber)</span><br><span class="line"><span class="keyword">library</span>(igraph)</span><br><span class="line">plumber::plumb(file=<span class="string">'./plumber.R'</span>)$run( port = <span class="number">442</span>,host=<span class="string">"0.0.0.0"</span>)</span><br><span class="line">plumber::plumb(file=<span class="string">'./test.R'</span>)$run( port = <span class="number">58903</span>,host=<span class="string">"0.0.0.0"</span>)</span><br><span class="line"></span><br><span class="line">install.packages(<span class="string">"plumber"</span>)</span><br><span class="line"></span><br><span class="line">```R  test.py</span><br><span class="line">library(plumber)</span><br><span class="line"></span><br><span class="line">#* @method /url</span><br><span class="line"></span><br><span class="line">#* Echo provided text</span><br><span class="line">#* @param text The text to be echoed in the response</span><br><span class="line">#* @get /echo</span><br><span class="line">function(text = "") &#123;</span><br><span class="line">  list(</span><br><span class="line">    message_echo = paste("The text is:", text)</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Starting server to listen on port 5762<br>Running the swagger UI at <a href="http://127.0.0.1:5762/__swagger__/" target="_blank" rel="noopener">http://127.0.0.1:5762/__swagger__/</a></p>
<p>curl “<a href="http://127.0.0.1:5762/echo&quot;" target="_blank" rel="noopener">http://127.0.0.1:5762/echo&quot;</a> –header “Content-type:application/json” -X POST -d @path/file</p>
<p>curl –data “text=hi_my_friend” “<a href="http://127.0.0.1:3000/echo&quot;" target="_blank" rel="noopener">http://127.0.0.1:3000/echo&quot;</a></p>
<p><a href="https://arch-backend.com:58903" target="_blank" rel="noopener">https://arch-backend.com:58903</a></p>
<p>人生真的好不公平，我好想自殺。</p>
<p>不是我的錯八.. 為甚麼我會有這種際遇</p>
<p>{standard input}:161003: Error: unknown pseudo-op: ‘.lbb’<br>{standard input}:161003: Error: open CFI at the end of file; missing .cfi_endproc directive</p>
<p>install.packages(“nloptr”)<br>ERROR: configuration failed for package ‘nloptr’</p>
<p>ERROR: no information for variable ‘AR’ cru .libs/libutil.a .libs/mt19937ar.o .libs/sobolseq.o .libs/timer.o .libs/stop.o .libs/redblack.o .libs/qsort_r.o .libs/rescale.o<br>../libtool: line 1102: ERROR:: command not found</p>
<p>library(remotes)<br>remotes::install_version(‘doBy’, version = ‘4.5-15’ )<br>library(doBy)</p>
<p><a href="http://132.148.26.6:58903/echo?text=123" target="_blank" rel="noopener">http://132.148.26.6:58903/echo?text=123</a></p>
<p>Rscript plumber::plumb(file=’./plumber.R’)$run( port = 58903,host=”0.0.0.0”)<br>Rscript demo.R &amp;<br>```</p>
]]></content>
      <categories>
        <category>R語言</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>R語言</tag>
        <tag>學習筆記</tag>
        <tag>linux</tag>
        <tag>centOS</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS6 安裝與更新 openssl 1.1.0 教學</title>
    <url>/2020/09/05/linux/linux-openssl1.1.0-update/</url>
    <content><![CDATA[<h2 id="內容說明"><a href="#內容說明" class="headerlink" title="內容說明"></a>內容說明</h2><blockquote>
<p>記錄我在 LINUX 上遇到的問題</p>
<p>會寫這篇的原因是因為公司的 Server，CentOS6 安裝 pthon3.6版本後，需要安裝套件，但 pip 要求 openssl version 必須大於 1.0.2，但 centOS6 內建只能到 1.0.1，於是上網查資料解決方案，因而在這邊紀錄</p>
</blockquote>
<a id="more"></a>

<h2 id="解決方法"><a href="#解決方法" class="headerlink" title="解決方法"></a>解決方法</h2><h3 id="第一步-檢查-openssl-的位置與移除舊版-openssl"><a href="#第一步-檢查-openssl-的位置與移除舊版-openssl" class="headerlink" title="第一步 檢查 openssl 的位置與移除舊版 openssl"></a>第一步 檢查 openssl 的位置與移除舊版 openssl</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yun remove openssl</span><br><span class="line">which openssl</span><br></pre></td></tr></table></figure>


<h3 id="第二步-下載-opensssl-1-1-0"><a href="#第二步-下載-opensssl-1-1-0" class="headerlink" title="第二步 下載 opensssl 1.1.0"></a>第二步 下載 opensssl 1.1.0</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;www.openssl.org&#x2F;source&#x2F;openssl-1.1.0f.tar.gz</span><br><span class="line">tar -xzf openssl-1.1.0f.tar.gz</span><br></pre></td></tr></table></figure>

<h3 id="第三步-編譯與安裝-openssl"><a href="#第三步-編譯與安裝-openssl" class="headerlink" title="第三步 編譯與安裝 openssl"></a>第三步 編譯與安裝 openssl</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd openssl-1.1.0f</span><br><span class="line">.&#x2F;config</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>

<h3 id="QUESTION-可能在過程中你在執行-openssl，可能會遇到此錯誤"><a href="#QUESTION-可能在過程中你在執行-openssl，可能會遇到此錯誤" class="headerlink" title="QUESTION: 可能在過程中你在執行 openssl，可能會遇到此錯誤"></a>QUESTION: 可能在過程中你在執行 openssl，可能會遇到此錯誤</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;usr&#x2F;local&#x2F;bin&#x2F;openssl version</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;bin&#x2F;openssl: error while loading shared libraries: libcrypto.so.1.1: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure>
<h3 id="SOLUTION-新增新的連結指向-libssl"><a href="#SOLUTION-新增新的連結指向-libssl" class="headerlink" title="SOLUTION: 新增新的連結指向 libssl"></a>SOLUTION: 新增新的連結指向 libssl</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo ln -s &#x2F;usr&#x2F;local&#x2F;lib64&#x2F;libssl.so.1.1 &#x2F;usr&#x2F;lib64&#x2F;</span><br><span class="line">sudo ln -s &#x2F;usr&#x2F;local&#x2F;lib64&#x2F;libcrypto.so.1.1 &#x2F;usr&#x2F;lib64&#x2F;</span><br></pre></td></tr></table></figure>

<h3 id="第四步-新增新連結指向-openssl"><a href="#第四步-新增新連結指向-openssl" class="headerlink" title="第四步 新增新連結指向 openssl"></a>第四步 新增新連結指向 openssl</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo ln -s &#x2F;usr&#x2F;local&#x2F;bin&#x2F;openssl &#x2F;usr&#x2F;bin&#x2F;openssl</span><br></pre></td></tr></table></figure>

<h3 id="第五步-檢查"><a href="#第五步-檢查" class="headerlink" title="第五步 檢查"></a>第五步 檢查</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">openssl version</span><br><span class="line">OpenSSL 1.1.0f 25 May 2017</span><br></pre></td></tr></table></figure>

<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://linuxscriptshub.com/update-openssl-1-1-0-centos-6-9-7-0/" target="_blank" rel="noopener">HOW TO UPDATE OPENSSL 1.1.0 IN CENTOS 6.9/7.0</a><br><a href="https://blog.csdn.net/rongDang/article/details/102871874" target="_blank" rel="noopener">Centos7安装uwsgi出现关于SSL错误的问题</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>我在找資料時其實花了非常多的時間，但其實只有參考連結中的此網站對我有所幫助，我很感謝這網頁。</p>
<p>LINUX 好多事情真的需要我學，跟 WINDOWS 又是完全不一樣的東西，學起來我就又多一把刷子了 XD</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>ERROR! bad interpreter No such file or directory</title>
    <url>/2020/09/05/linux/centOS-ERROR-bad_interpreter/</url>
    <content><![CDATA[<h2 id="內容說明"><a href="#內容說明" class="headerlink" title="內容說明"></a>內容說明</h2><blockquote>
<p>如果同時安裝 python3 兩種版本，那 pip 通常會選擇其中一種來進行安裝套件，但如果之後你移除了 pip 選擇的 python 版本，那以後 pip 沒辦法將套件安裝到剩下 python 版本。<br><del>centOS6，跟 python 都好麻煩…</del></p>
</blockquote>
<a id="more"></a>
<h2 id="ERROR-bad-interpreter-No-such-file-or-directory"><a href="#ERROR-bad-interpreter-No-such-file-or-directory" class="headerlink" title="ERROR! bad interpreter: No such file or directory"></a>ERROR! bad interpreter: No such file or directory</h2><p>如果同時安裝 python3 兩種版本，那 pip 通常會選擇其中一種來進行安裝套件，但如果之後你移除了 pip 選擇的 python 版本，那以後 pip 沒辦法將套件安裝到剩下 python 版本。</p>
<p>是不是覺得跟內容說明很像wwww，因為都是問題描述，如果描述不一樣我怕會造成讀者誤解。</p>
<h3 id="solution-尋找-python-位置，然後將-pip-指定到此位置"><a href="#solution-尋找-python-位置，然後將-pip-指定到此位置" class="headerlink" title="solution: 尋找 python 位置，然後將 pip 指定到此位置"></a>solution: 尋找 python 位置，然後將 pip 指定到此位置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">which python </span><br><span class="line">&#x2F;home&#x2F;path...</span><br></pre></td></tr></table></figure>
<p>之後複製 <code>/home/path...</code> 此路徑</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">which pip</span><br><span class="line">&#x2F;home&#x2F;path...</span><br></pre></td></tr></table></figure>
<p>之後 vim <code>which pip</code> 此指令下輸出的路徑</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;home&#x2F;path...</span><br></pre></td></tr></table></figure>
<p>接下來第一行應該會出現</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;home&#x2F;path....&#x2F;bin&#x2F;python3.8</span><br></pre></td></tr></table></figure>
<p>在將 <code>which python</code>輸出的路徑放在 #!，之後保存並退出就可以了！</p>
<p>以上全部都沒問題驗證也成功話，那在 centOS6 上就沒有問題了！太強了你，我花了一小時才解決此問題..</p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://blog.csdn.net/qq_38486203/article/details/100103434" target="_blank" rel="noopener">【python】使用pip出现/bin/python: bad interpreter: No such file or directory</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>環境的問題時常把新手搞得喘不過氣，幸好這次我能克服此困難。希望以後 python 的版本控制能夠更好，centOS6 提供的相容性也可以更棒！雖然他 2020/11 就要停止更新了…<br>不過還是謝謝能在網路上提供資源的大神們，沒有他們，我連解決都不能解決！</p>
<p>尤其是國人，技術資源國人比起台灣資源多很多。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>linux</tag>
        <tag>centOS</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>centOS 排成教學</title>
    <url>/2020/09/09/linux/centOS-crontab/</url>
    <content><![CDATA[<h2 id="內容說明"><a href="#內容說明" class="headerlink" title="內容說明"></a>內容說明</h2><blockquote>
<p>記錄我在 linux 上學習排成時遇到的困難，排成自學真的好麻煩呀 QQ<br>教學示範作業系統 centOS6</p>
</blockquote>
<a id="more"></a>

<h2 id="排成主要功能"><a href="#排成主要功能" class="headerlink" title="排成主要功能"></a>排成主要功能</h2><p>簡單來說就是有一個機器人幫你服務，在你設定的時間執行你想要的指令，通常限定一行。</p>
<h3 id="如何進入排成"><a href="#如何進入排成" class="headerlink" title="如何進入排成"></a>如何進入排成</h3><p>在  ternimal 輸入 <code>crontab -e</code> 即可。</p>
<h2 id="排成的語法規則"><a href="#排成的語法規則" class="headerlink" title="排成的語法規則"></a>排成的語法規則</h2><table>
<thead>
<tr>
<th>指令語法</th>
<th>分鐘</th>
<th>小時</th>
<th>日期</th>
<th>月份</th>
<th>周</th>
<th>命令</th>
</tr>
</thead>
<tbody><tr>
<td>可接受數字範圍</td>
<td>0~59</td>
<td>0~23</td>
<td>1~31</td>
<td>1~12</td>
<td>0~7</td>
<td>執行命令</td>
</tr>
</tbody></table>
<p><strong><font color="#dd0000">在周這欄時不管打 0 or 7 都是代表星期日的意思</font></strong></p>
<h3 id="排成特殊字元"><a href="#排成特殊字元" class="headerlink" title="排成特殊字元"></a>排成特殊字元</h3><p>有些字元有著特殊意義，如下表：</p>
<table>
<thead>
<tr>
<th>字元</th>
<th>中文解釋</th>
<th>意義</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>星號</td>
<td>代表任何時段，舉例: 排成如果 月、日、周都是 * ，則代表每月每日每周都會執行此命令，但<strong>注意:如果有大單位已經有數字時，則建議小單位不要用 * ，假設日期是 4，則小時、分鐘就建議不要用 * 號</strong></td>
</tr>
<tr>
<td>,</td>
<td>逗號</td>
<td>分隔時段，舉例:如果想要在 13:00 and 16:00 都執行命令，就輸入指令 0 13,16 * * * command，醬子(◍•ᴗ•◍)❤️</td>
</tr>
<tr>
<td>-</td>
<td>減號</td>
<td>在 A-B 段單位時間內，都會執行指令，舉例: 想要在 8 點到 12 點的 10 分之間都執行指令，則輸入指令 10 8-12 * * * command，比起逗號在跟方便一些的指令</td>
</tr>
<tr>
<td>/n</td>
<td>斜線</td>
<td>n = 數字，代表每隔 n 單位時間的意思，例如每 3 分鐘執行指令，則輸入指令 */3 * * * * command，也可以寫成 0-59/5，意思相同，但 0-30/5 意義就不相同XD，變成 0~30 分的每 5 分鐘執行指令</td>
</tr>
</tbody></table>
<h3 id="舉例"><a href="#舉例" class="headerlink" title="舉例:"></a>舉例:</h3><table>
<thead>
<tr>
<th>命令</th>
<th>解釋</th>
</tr>
</thead>
<tbody><tr>
<td>5 * * * *</td>
<td>每小時的第五分鐘執行命令</td>
</tr>
<tr>
<td>30 8 * * *</td>
<td>每天 8:30 執行命令</td>
</tr>
<tr>
<td>15 8-10 * * *</td>
<td>每天的 8 到 11 點的 15 分執行命令</td>
</tr>
<tr>
<td>*/5 * * * *</td>
<td>每 5 分鐘執行命令</td>
</tr>
<tr>
<td>30 6 /10 * *</td>
<td>每個月中，每 10 天的 6:30 執行命令，也就是每月的 1, 11, 21, 31 日的 6:30 執行命令</td>
</tr>
</tbody></table>
<h2 id="QUESTION-排成需要多行指令那要怎麼辦呢？"><a href="#QUESTION-排成需要多行指令那要怎麼辦呢？" class="headerlink" title="QUESTION: 排成需要多行指令那要怎麼辦呢？"></a>QUESTION: 排成需要多行指令那要怎麼辦呢？</h2><p>用括號 + 分號來解決這問題，括號來放入全部指令，分號則用來分隔命令。<br>舉例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*&#x2F;5 * * * *  (cd &#x2F;home&#x2F;archcopilot&#x2F;public_html&#x2F;david53133&#x2F;v1.0&#x2F; ; &#x2F;usr&#x2F;local&#x2F;bin&#x2F;python3.6 climb.py)</span><br></pre></td></tr></table></figure>

<h2 id="QUESTION-如果我想要透過執行檔執行文件該怎麼辦呢"><a href="#QUESTION-如果我想要透過執行檔執行文件該怎麼辦呢" class="headerlink" title="QUESTION: 如果我想要透過執行檔執行文件該怎麼辦呢?"></a>QUESTION: 如果我想要透過執行檔執行文件該怎麼辦呢?</h2><p>舉例，例如我想要執行 python 程式，那我是不是應該要 <code>python3 test.py</code>，在某些情況下是可以的。但如果你的 <code>python3</code> 並沒有放在系統預設的位置 <code>/usr/bin</code>就不行！<br>因此我建議的操作如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">which python3 # 先尋找執行檔的路徑</span><br><span class="line">&#x2F;home&#x2F;path&#x2F;... # 輸出的路徑</span><br><span class="line">&#x2F;home&#x2F;path&#x2F;..&#x2F;python3 test.py #執行命令</span><br></pre></td></tr></table></figure>

<h2 id="QUESTION-我想要看我的排成有沒有被執行？"><a href="#QUESTION-我想要看我的排成有沒有被執行？" class="headerlink" title="QUESTION: 我想要看我的排成有沒有被執行？"></a>QUESTION: 我想要看我的排成有沒有被執行？</h2><p>排成執行的紀錄在 <code>/var/log/cron</code>，再透過 <code>cat</code> 找出來即可。舉例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &#x2F;var&#x2F;log&#x2F;cron</span><br></pre></td></tr></table></figure>


<h2 id="QUESTION-為甚麼我排成的指令有被執行，但我看卻沒有？"><a href="#QUESTION-為甚麼我排成的指令有被執行，但我看卻沒有？" class="headerlink" title="QUESTION: 為甚麼我排成的指令有被執行，但我看卻沒有？"></a>QUESTION: 為甚麼我排成的指令有被執行，但我看卻沒有？</h2><h3 id="situation-1-你沒有-cd-路徑"><a href="#situation-1-你沒有-cd-路徑" class="headerlink" title="situation 1: 你沒有 cd 路徑"></a>situation 1: 你沒有 cd 路徑</h3><p>為甚麼會這樣說呢？因為其實你在執行路徑時，基本上都是從 <code>/user_name</code>出發，因此如果你的指令文件內有提到關於路徑，且路徑又是相對路徑是則極高機率遇到此問題。<br>建議使用 cd 到路徑後，在執行命令。舉例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*&#x2F;5 * * * *  (cd &#x2F;home&#x2F;archcopilot&#x2F;public_html&#x2F;david53133&#x2F;v1.0&#x2F; ; &#x2F;usr&#x2F;local&#x2F;bin&#x2F;python3.6 climb.py)</span><br></pre></td></tr></table></figure>
<h3 id="situation-2-指令本身有誤"><a href="#situation-2-指令本身有誤" class="headerlink" title="situation 2: 指令本身有誤"></a>situation 2: 指令本身有誤</h3><p>這也是一種可能，但我幫不了忙，對不起QQ。</p>
<h2 id="QUESTION-因為排成執行如果有問題是不會顯示，但我想要知道問題出在哪裡。排成可以提供日誌嗎？"><a href="#QUESTION-因為排成執行如果有問題是不會顯示，但我想要知道問題出在哪裡。排成可以提供日誌嗎？" class="headerlink" title="QUESTION: 因為排成執行如果有問題是不會顯示，但我想要知道問題出在哪裡。排成可以提供日誌嗎？"></a>QUESTION: 因為排成執行如果有問題是不會顯示，但我想要知道問題出在哪裡。排成可以提供日誌嗎？</h2><p>當然可以。我一開始研究還花很多時間XD，因為我一開始看不太懂，後面資料查久了才懂得wwww<br>透過 <code>&gt;&gt; test.log 2&amp;&gt;1</code>即可。舉例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 0 *&#x2F;1 * *  (cd &#x2F;home&#x2F;archcopilot&#x2F;public_html&#x2F;david53133&#x2F;v1.0&#x2F; ; &#x2F;usr&#x2F;local&#x2F;bin&#x2F;python3.6 climb.py)  &gt;&gt; &#x2F;home&#x2F;archcopilot&#x2F;public_html&#x2F;david53133&#x2F;v1.0&#x2F;crontab.log 2&gt;&amp;1</span><br></pre></td></tr></table></figure>

<h2 id="QUESITON-我要想排成好麻煩，有沒有比較簡單的排成方法"><a href="#QUESITON-我要想排成好麻煩，有沒有比較簡單的排成方法" class="headerlink" title="QUESITON: 我要想排成好麻煩，有沒有比較簡單的排成方法"></a>QUESITON: 我要想排成好麻煩，有沒有比較簡單的排成方法</h2><p>其實是有，但我個人覺得要記那些語法對我言太麻煩了。<br>這裡有一推薦的排成計算機，可以幫助你對你想要的時間點進行排成的指令計算出來。<br>連結就<a href="https://crontab.guru/" target="_blank" rel="noopener">請點這裡</a></p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://blog.csdn.net/liaoyanyunde/article/details/86572370" target="_blank" rel="noopener">查看crontab任务是否执行以及执行日志</a><br><a href="https://blog.gtwang.org/linux/linux-crontab-cron-job-tutorial-and-examples/" target="_blank" rel="noopener">Linux 設定 crontab 例行性工作排程教學與範例</a><br><a href="https://freesilo.com/?p=1083" target="_blank" rel="noopener">crontab的语法规则格式（每分钟、每小时、每天、每周、每月、每年定时执行 规则）</a><br><a href="https://crontab.guru/" target="_blank" rel="noopener">crontab calculator</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>排成真的有點難呀，不過我認為是我閱讀文章的能力不夠，還沒辦法閱讀一次就能看懂網路上大神的文章，於是我在這邊做些筆記紀錄，也希望幫助現在跟我一樣還不夠看懂大神的文章人可以透過我這篇文章而了解排成的用法。<br>希望能夠幫助到別人，這是我最大的心願。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>linux</tag>
        <tag>centOS</tag>
      </tags>
  </entry>
  <entry>
    <title>大衞愛用的表情符號</title>
    <url>/2020/07/20/blog/Emoticons/</url>
    <content><![CDATA[<h2 id="表情符號，為甚麼要記錄這個！"><a href="#表情符號，為甚麼要記錄這個！" class="headerlink" title="表情符號，為甚麼要記錄這個！"></a>表情符號，為甚麼要記錄這個！</h2><blockquote>
<p>因為這些表情符號是我愛用的，我也覺得很可愛。於是我想收集起來</p>
</blockquote>
<a id="more"></a>

<h2 id="以下就是大衛愛用的表情符號"><a href="#以下就是大衛愛用的表情符號" class="headerlink" title="以下就是大衛愛用的表情符號"></a>以下就是大衛愛用的表情符號</h2><table>
<thead>
<tr>
<th>表情符號</th>
</tr>
</thead>
<tbody><tr>
<td>QwQ</td>
</tr>
<tr>
<td>٩(^ᴗ^)۶</td>
</tr>
<tr>
<td>ಠ︵ಠ</td>
</tr>
<tr>
<td>✧(&gt;o&lt;)ﾉ</td>
</tr>
<tr>
<td>╰(⸝⸝⸝´꒳`⸝⸝⸝)╯</td>
</tr>
<tr>
<td>(◍•ᴗ•◍)❤️</td>
</tr>
<tr>
<td>♡(&gt; ਊ &lt;)♡</td>
</tr>
<tr>
<td>(*＾3＾)/～♡</td>
</tr>
<tr>
<td>ಥ⌣ಥ</td>
</tr>
<tr>
<td>ε٩(๑&gt; ₃ &lt;)۶з</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>表情符號</tag>
      </tags>
  </entry>
  <entry>
    <title>mathjax 用法紀錄</title>
    <url>/2020/07/20/blog/about-mathjax/</url>
    <content><![CDATA[<h2 id="主要內容"><a href="#主要內容" class="headerlink" title="主要內容"></a>主要內容</h2><blockquote>
<p>幫助大衛在 blog 中使用 mathjax 時忘記用法的時候直接快速使用，省去找文章的麻煩<br>雙斜線代表 mathjax 的用法，因為這裡我若完整照打會直接變成 mathjax 格式，於是我都只打內容<br>如下 &amp;&amp;(內容 &amp;&amp;) ，將 &amp;消除後放入內容即可使用</p>
</blockquote>
<a id="more"></a>

<h2 id="數學用法"><a href="#數學用法" class="headerlink" title="數學用法"></a>數學用法</h2><p><strong>普通英文字母若前面未加入反斜線則代表可隨意帶入數值</strong></p>
<table>
<thead>
<tr>
<th>數學用法</th>
<th>mathjax 打法</th>
<th>備註</th>
</tr>
</thead>
<tbody><tr>
<td>次方</td>
<td>a^{b}</td>
<td></td>
</tr>
<tr>
<td>x項</td>
<td>a_{b}</td>
<td></td>
</tr>
<tr>
<td>字與字的空格</td>
<td>a \ b</td>
<td></td>
</tr>
<tr>
<td>大括號</td>
<td>\&amp;{ , \&amp;}</td>
<td>&amp;需消除</td>
</tr>
<tr>
<td>分式寫法</td>
<td>\frac{分子}{分母}</td>
<td></td>
</tr>
<tr>
<td>套入文字</td>
<td>\text{文字}</td>
<td></td>
</tr>
<tr>
<td>總和</td>
<td>\sum_{i=1}^n a_n</td>
<td>如果不需要其他係數，只需要符號時使用 \Sigma</td>
</tr>
<tr>
<td>大於等於</td>
<td>\geq</td>
<td></td>
</tr>
<tr>
<td>小於等於</td>
<td>\leq</td>
<td></td>
</tr>
<tr>
<td>乘法</td>
<td>\cdot</td>
<td></td>
</tr>
<tr>
<td>百分比</td>
<td>\ \ %</td>
<td>須將斜線 與 % 中間的空白消去</td>
</tr>
<tr>
<td>註解</td>
<td>\ %</td>
<td>須將斜線 與 % 中間的空白消去</td>
</tr>
<tr>
<td>對數</td>
<td>\log_2 x</td>
<td></td>
</tr>
<tr>
<td>在文字上面加一橫線</td>
<td>\bar{x}</td>
<td></td>
</tr>
<tr>
<td>Union(聯集)</td>
<td>\cup</td>
<td></td>
</tr>
<tr>
<td>Intersection(交集)</td>
<td>\cap</td>
<td></td>
</tr>
<tr>
<td>+-(加減)</td>
<td>\pm</td>
<td></td>
</tr>
<tr>
<td>文字上面加一槓</td>
<td>\bar{}</td>
<td></td>
</tr>
<tr>
<td>大約</td>
<td>\approx</td>
<td></td>
</tr>
<tr>
<td>變異數符號</td>
<td>\sigma</td>
<td></td>
</tr>
<tr>
<td>根號</td>
<td>\sqrt[ n ]{}</td>
<td>裡面的 n 為開幾次跟號</td>
</tr>
<tr>
<td>換行</td>
<td>\ \ \ \</td>
<td>四個斜線，需要把中間空格消除</td>
</tr>
<tr>
<td>相關係數</td>
<td>\rho</td>
<td></td>
</tr>
<tr>
<td>beta</td>
<td>\beta</td>
<td></td>
</tr>
<tr>
<td>\(\mu \)</td>
<td>\mu</td>
<td></td>
</tr>
<tr>
<td>\(\lambda \)</td>
<td>\lambda</td>
<td></td>
</tr>
<tr>
<td>在字母上方有 ^</td>
<td>\hat{}</td>
<td></td>
</tr>
<tr>
<td>\(\theta\)</td>
<td>\theta</td>
<td></td>
</tr>
<tr>
<td>⇒</td>
<td>複製就好</td>
<td></td>
</tr>
</tbody></table>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="http://detexify.kirelabs.org/classify.html" target="_blank" rel="noopener">透過手寫來找出適合的 mathjax </a><br><a href="https://blog.csdn.net/mage_ee/article/details/75309174" target="_blank" rel="noopener">MathJax 基础 (1)：基础语法</a><br><a href="https://blog.csdn.net/yang_csdnForOBTS/article/details/81228365" target="_blank" rel="noopener">Latex：大于等于号和小于等于号</a><br><a href="https://math.meta.stackexchange.com/questions/22443/how-to-markup-expression-using-sigma-notation-for-sum-in-mathjax" target="_blank" rel="noopener">How to markup expression using sigma notation for sum in MathJax</a><br><a href="https://blog.csdn.net/bi_hu_man_wu/article/details/70207695" target="_blank" rel="noopener">Latex中点乘、叉乘、除以</a><br><a href="https://phabricator.wikimedia.org/T38855" target="_blank" rel="noopener">MathJax treats percent sign (%) as start of a comment</a><br><a href="https://blog.csdn.net/qq_17528659/article/details/82152530" target="_blank" rel="noopener">LaTeX 特殊符号、加帽子符号、横线和波浪线</a><br><a href="https://timmurphy.org/2010/05/22/union-and-intersection-symbols-in-latex/" target="_blank" rel="noopener">Union and Intersection symbols in LaTeX</a><br><a href="https://math.meta.stackexchange.com/questions/26403/how-to-write-plus-minus-sign-in-mathjax" target="_blank" rel="noopener">How to write plus-minus sign in MathJax? [duplicate]</a><br><a href="https://16sixteen.github.io/jekyll-study/mathjax" target="_blank" rel="noopener">常用的mathjax符号</a><br><a href="https://math.meta.stackexchange.com/questions/29609/how-to-type-sigma-and-other-symbols-in-mathjax" target="_blank" rel="noopener">How to type Sigma and other symbols in MathJax [duplicate]</a><br><a href="https://blog.csdn.net/xm_ovo/article/details/107536132" target="_blank" rel="noopener">解决mathjax公式不换行问题</a><br><a href="https://www.jianshu.com/p/ca46b67933ab" target="_blank" rel="noopener">Latex 字母上面加符号 波浪线 横线 角号</a><br>齊笎詳解</p>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>mathjax</tag>
      </tags>
  </entry>
  <entry>
    <title>tidytext ERROR! Input must be a character vector of any length or a list of character vectors, each of which has a length of 1.</title>
    <url>/2020/09/10/R/R-ERROR-tinytext-unnset-token/</url>
    <content><![CDATA[<h2 id="內容說明"><a href="#內容說明" class="headerlink" title="內容說明"></a>內容說明</h2><blockquote>
<p>寫程式的時候是不可能沒遇到 bug 的，bug 紀錄整理</p>
</blockquote>
<a id="more"></a>

<h2 id="ERROR-Input-must-be-a-character-vector-of-any-length-or-a-list-of-character-vectors-each-of-which-has-a-length-of-1"><a href="#ERROR-Input-must-be-a-character-vector-of-any-length-or-a-list-of-character-vectors-each-of-which-has-a-length-of-1" class="headerlink" title="ERROR! Input must be a character vector of any length or a list of character vectors, each of which has a length of 1."></a>ERROR! Input must be a character vector of any length or a list of character vectors, each of which has a length of 1.</h2><blockquote>
<p>當我們在使用 tidytest 此套件中的 unnest_tokens 時遇到此問題，要怎麼解決呢？</p>
</blockquote>
<h3 id="situation-1-input-的-data-裡面的字串型態並不是-character-而是-factor"><a href="#situation-1-input-的-data-裡面的字串型態並不是-character-而是-factor" class="headerlink" title="situation 1: input 的 data 裡面的字串型態並不是 character 而是 factor"></a>situation 1: input 的 data 裡面的字串型態並不是 character 而是 factor</h3><p>先看看你給予 unnest_tokens 的 data，然後透過 print 來查看型態，如果有查看到關於型態為 factor 而不是 character 且這是你需要使用 unnest_tokens 的 data，強烈建議先將他轉成 character，再重跑一次 unnest_tokens，這樣或許能夠解決問題。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xDomino.Title &lt;- tibble(line&#x3D;1:nrow(x.Domino),text &#x3D; as.character(x.Domino$Title) )</span><br><span class="line">xDomino.Title.word &lt;- xDomino.Title %&gt;% tidytext::unnest_tokens(word, text)</span><br></pre></td></tr></table></figure>

<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://stackoverflow.com/questions/46341840/how-do-i-solve-the-following-errorinput-must-be-a-character-vector-of-any-lengt" target="_blank" rel="noopener">How do I solve the following error?Input must be a character vector of any length or a list of character vectors, each of which has a length of 1.</a><br><a href="https://juliasilge.github.io/tidytext/reference/unnest_tokens.html" target="_blank" rel="noopener">Split a column into tokens using the tokenizers package</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>有時候文章看得不夠多，真的沒有安全感呀，有時候網路充斥著太多過時訊息會使人誤解正確資訊，於是我特地寫一篇文章來增加資訊的正確程度，我也希望我這篇文章可以幫助到別人且此文章沒有錯誤，謝系大家。<br>P.S. 我再找這 bug 也是花了很多時間…，大概一小時，找 bug 應該可以排行在世界十大麻煩之中了 QwQ。</p>
]]></content>
      <categories>
        <category>R語言</category>
      </categories>
      <tags>
        <tag>R語言</tag>
        <tag>學習筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>R character 與 factor 比較</title>
    <url>/2020/09/10/R/R-factor_vs_character/</url>
    <content><![CDATA[<h2 id="內容說明"><a href="#內容說明" class="headerlink" title="內容說明"></a>內容說明</h2><blockquote>
<p>說明 R 語言中 factor 跟 character 他們彼此有甚麼好處又有甚麼不一樣。</p>
</blockquote>
<a id="more"></a>

<h2 id="character-介紹"><a href="#character-介紹" class="headerlink" title="character 介紹"></a>character 介紹</h2><p>基本上它就是 string，並不是 C 語言的 char，如果他是 C 語言的 char 那就很難用了www。<br>是 R 語言中最好用也是最基礎的型態之一。</p>
<p>字串的用法，相信只要 google 就好，我來講的話或許有點太失字串面子了。</p>
<h2 id="factor-介紹"><a href="#factor-介紹" class="headerlink" title="factor 介紹"></a>factor 介紹</h2><p>我對於 factor 比較不熟，如果沒有介紹的很晚整抱歉 QQ。<br>factor 用一句話來表示就是專門給文字用的 vector，且他還帶有層級(Levels) 的 vector。</p>
<h3 id="factor-比起-vectior-多兩個要素"><a href="#factor-比起-vectior-多兩個要素" class="headerlink" title="factor 比起 vectior 多兩個要素:"></a>factor 比起 vectior 多兩個要素:</h3><p>ordered</p>
<ul>
<li>決定要不要有排序，如果沒有指定順序方式，則會使用字母順序來排序。<br>levels</li>
<li>決定排序的方式</li>
</ul>
<p>舉例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">temperatures &lt;- c(&quot;warm&quot;, &quot;hot&quot;, &quot;cold&quot;)</span><br><span class="line">temp_factors &lt;- factor(temperatures, ordered &#x3D; TRUE, levels &#x3D; c(&quot;cold&quot;, &quot;warm&quot;, &quot;hot&quot;))</span><br><span class="line">temp_factors</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">## [1] warm hot  cold</span><br><span class="line">## Levels: cold &lt; warm &lt; hot</span><br></pre></td></tr></table></figure>

<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://bookdown.org/tonykuoyj/eloquentr/vector-factor.html" target="_blank" rel="noopener">10 多樣的資料結構：向量與因素向量</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>為甚麼會突然寫一篇關於 factor 與 character 的差別呢，因為在 linux 上我遇到的<a href="https://theriseofdavid.github.io/2020/09/10/R/R-unexpected_error_to_Data_Transformation/" target="_blank" rel="noopener">第一個將程式移植到 linux 的錯誤</a>上就是關於這個，也讓我認識到 factor，雖然我想不懂為甚麼再將程式移植時會遇到此問題，但是有問題就是要解決，於是在這裡紀錄經驗，不讓我忘記也希望其他人可以盡快解決此 bug。</p>
]]></content>
      <categories>
        <category>R語言</category>
      </categories>
      <tags>
        <tag>R語言</tag>
        <tag>學習筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>BUG! Data_Transformation_to_OS</title>
    <url>/2020/09/10/R/R-unexpected_error_to_Data_Transformation/</url>
    <content><![CDATA[<h2 id="內容說明："><a href="#內容說明：" class="headerlink" title="內容說明："></a>內容說明：</h2><blockquote>
<p>R 語言將程式碼從 A os to B os 會出一些差錯，在這邊進行紀錄</p>
</blockquote>
<a id="more"></a>

<h2 id="BUG-Data-Transformation-to-OS"><a href="#BUG-Data-Transformation-to-OS" class="headerlink" title="BUG! Data_Transformation_to_OS"></a>BUG! Data_Transformation_to_OS</h2><p>當我再 windows10 上把寫好的 R 程式放到 centOS6 上時卻執行出 ERROR，但在 windows 不會出錯呀！為甚麼會這樣呢？</p>
<h3 id="solution-1-可能是型態不同"><a href="#solution-1-可能是型態不同" class="headerlink" title="solution 1: 可能是型態不同"></a>solution 1: 可能是型態不同</h3><p>在我的經驗中，R 的 tribble 的字串可能會在 windows 是 character 型態，但在 linux 上則是 factor，因此如果要讓程式可以繼續跑，就在 linux 上的程式特意再將 factor 再轉成 character 即可。</p>
<h4 id="補述"><a href="#補述" class="headerlink" title="補述:"></a>補述:</h4><p>在 2020/09/14 的 Debug 經驗中發現，只要是字串陣列在 linux 極高機率是 factor，如果不想要 factor，個人建議可以在每一個宣告字元陣列時加上 <code>as.character()</code>。</p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>老實講，這種問題我第一次遇到，這也讓我很頭疼。因為其實只有一份程式碼讓我遇到，於是我都沒有往這方向去思考，直到我不斷尋找問題時，腦袋靈光一閃才讓我找出此錯誤。</p>
<p>在這邊推薦一種除錯方式，雖然應該很多人都知道，但這除錯方式是我自己想的，可以將你每份程式碼都先複製 4、5 行進入 R console，這樣會相對好除錯很多。因為我在公司沒有人教我怎麼除錯，我當時也過有自信的說我會寫 R，導致變成讓我少從主管們學到一些經驗，讓我多踩一些坑，有時候這確實也不太好QQ。</p>
]]></content>
      <categories>
        <category>R語言</category>
      </categories>
      <tags>
        <tag>R語言</tag>
        <tag>學習筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>linux /usr/bin 與 /usr/local/bin 有甚麼差別?</title>
    <url>/2020/09/10/linux/linux-locan_bin_vs_bin/</url>
    <content><![CDATA[<h2 id="內容說明"><a href="#內容說明" class="headerlink" title="內容說明"></a>內容說明</h2><blockquote>
<p>記錄我在 linux 上關於執行檔路徑位置的觀念澄清。<br>作業系統為: centOS6</p>
</blockquote>
<h2 id="問題概述："><a href="#問題概述：" class="headerlink" title="問題概述："></a>問題概述：</h2><p>通常我們在將某份程式文件 <code>make &amp;&amp; make install</code> 之後，我們只要輸入執行檔的 key，就可以直接輸入指令。例如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python3 test.py</span><br><span class="line">yum install openssl</span><br></pre></td></tr></table></figure>

<p>這種感覺，而其中的 yum and python3，就是執行檔的 key，但神奇的是你 <code>which</code> 他們路徑時卻不一樣</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># yum 執行檔路徑</span><br><span class="line">which yum</span><br><span class="line">&#x2F;usr&#x2F;bin</span><br><span class="line"></span><br><span class="line"># 在 python 執行檔路徑</span><br><span class="line">which python3</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;bin</span><br></pre></td></tr></table></figure>
<p>他們的位置是不一樣的！這讓我覺得神奇也特別去查了下這兩個的用法。</p>
<h2 id="usr-bin-下通常是放甚麼呢"><a href="#usr-bin-下通常是放甚麼呢" class="headerlink" title="usr/bin 下通常是放甚麼呢?"></a>usr/bin 下通常是放甚麼呢?</h2><p>通常放置可執行程式，基本上 linux 內建的所有可執行程式都放置於此。</p>
<h2 id="usr-local-bin-下通常是放甚麼呢"><a href="#usr-local-bin-下通常是放甚麼呢" class="headerlink" title="usr/local/bin 下通常是放甚麼呢?"></a>usr/local/bin 下通常是放甚麼呢?</h2><p>由於軟體會隨著時間推移而可以進行更新，例如要升級 python，那通常軟體預設安裝的地方在 /usr/local (local 是表示本機) 之間，但同時由於電腦內有新舊版的程式可執行檔，所以通常會把升級後的程式放在 usr/local/bin 資料夾內。</p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>linux 在自學的過程中其實個人覺得有點難呀！可能是因為我比較不敢亂來 XD，都是先看很多文章直到看到了有安全感才會下手，導致我常常把一件事情學習很久 QQ。因為我會怕如果做錯要返回很麻煩 QwQ，疫點都沒有年輕人的幹勁呀，欸！</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>linux</tag>
        <tag>centOS</tag>
      </tags>
  </entry>
  <entry>
    <title>QUESTION! HEXO 可以多個 categories 嗎?</title>
    <url>/2020/07/20/blog/blog-categories/</url>
    <content><![CDATA[<h2 id="內容說明"><a href="#內容說明" class="headerlink" title="內容說明:"></a>內容說明:</h2><blockquote>
<p>關於我在撰寫 blog 時遇到的問題經驗，並留下紀錄來解決。</p>
</blockquote>
<a id="more"></a>

<h2 id="QUESTION-HEXO-可以多個-categories-嗎"><a href="#QUESTION-HEXO-可以多個-categories-嗎" class="headerlink" title="QUESTION: HEXO 可以多個 categories 嗎?"></a>QUESTION: HEXO 可以多個 categories 嗎?</h2><p>當然可以。<del>雖然我應該一開始還覺得不行，因為看到了其他文章說不行 QQ</del></p>
<h3 id="situation-1-子分類"><a href="#situation-1-子分類" class="headerlink" title="situation 1: 子分類"></a>situation 1: 子分類</h3><p>如果你想要有一種分類是在 a 分類底下還有 b 分類，那就要使用此寫法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">categories: [Language,Chinese]</span><br></pre></td></tr></table></figure>

<h3 id="situation-2-一篇文章放在多分類中"><a href="#situation-2-一篇文章放在多分類中" class="headerlink" title="situation 2: 一篇文章放在多分類中"></a>situation 2: 一篇文章放在多分類中</h3><p>如果你想要一篇文章可以再多種分類下，但並不是 situation 1 那種情況，而是要那些分類的 level 等級都是一樣時，可以使用這種寫法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">categories:</span><br><span class="line">  - [English]</span><br><span class="line">  - [Chinese]</span><br></pre></td></tr></table></figure>

<h3 id="situation-3-我想要上述兩種方法我同時都要使用怎麼辦？"><a href="#situation-3-我想要上述兩種方法我同時都要使用怎麼辦？" class="headerlink" title="situation 3: 我想要上述兩種方法我同時都要使用怎麼辦？"></a>situation 3: 我想要上述兩種方法我同時都要使用怎麼辦？</h3><p>那就將他們綜合起來運用就可以了！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">categories:</span><br><span class="line">  - [Language]</span><br><span class="line">  - [Sport]</span><br></pre></td></tr></table></figure>

<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://aiellochan.com/2018/02/13/hexo/Hexo-%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%A4%9A%E4%B8%AA-categories/" target="_blank" rel="noopener">Hexo 一篇文章多个 categories</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>老實講，因為我的英文能力不好，所以我大部分的學習都是仰賴國人的文章，我很感謝他們，如果沒有他們我或許學習的速度並沒有那麼快八，雖然可能少了學習英文的機會，但我本來主意就是要學習好程式技術，所以我對願意撰寫技術的每個人，只要是這個世界的人我都保持著謝意與尊敬。</p>
<p>我自己也希望可以變成這種人，但我技術還不強，目前邊寫邊紀錄，希望能讓自己成長蛻變。</p>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>人生旅途</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces 161D - Distance in Tree (點分治講解)</title>
    <url>/2020/09/11/Codeforces/Codeforces%20161D/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>給你一棵樹，保證他們不會形成迴路。詢問這棵樹中有多少 x 的距離。<br><strong>以下用到的都是使用<a href="https://www.luogu.com.cn/blog/user9012/dian-fen-zhi-lve-xie#blog-comments" target="_blank" rel="noopener">Dispwnl 博客的點分治講解</a>的圖片，如果 Dispwnl 大大不允許我使用我將會自行刪除，向 Dispwnl 道歉 QQ，也很謝謝他寫的詳細點分治教學讓我對點分治有了解</strong><br>此篇程式碼大多從 <a href="https://blog.csdn.net/The___Flash/article/details/101099955" target="_blank" rel="noopener">Distance in Tree （CodeForces - 161D，点分治）</a> 學習而來，謝謝作者釋放自己的程式碼，讓我可以完整學習到點分治。</p>
</blockquote>
<a id="more"></a>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>這要使用一種我從來沒有學過的演算法「點分治」，我們先來說說看點分治通常用於甚麼題目。</p>
<blockquote>
<p>他專門來解決給定一棵樹和一個整數 k，求此樹上兩點路徑等於小於 k 的有多少？<br>由於此題是點分治的模板題，只要能夠了解點分治就能解決此問題。<br>這題為教學題，我們將問題簡單化，只詢問「樹上兩點路徑等於 = k」</p>
</blockquote>
<h2 id="點分治介紹"><a href="#點分治介紹" class="headerlink" title="點分治介紹"></a>點分治介紹</h2><p><strong>點分治的精隨: 就是不斷把一顆樹拆成子樹來處理，並考慮路徑合併</strong><br><strong>分治點的選擇: 樹的重心</strong></p>
<h3 id="QUESTION-1-分治點是甚麼"><a href="#QUESTION-1-分治點是甚麼" class="headerlink" title="QUESTION 1: 分治點是甚麼?"></a>QUESTION 1: 分治點是甚麼?</h3><p>分治點就是可以把一顆樹拆成兩棵樹的點。</p>
<h3 id="QUESTION-2-樹的重心是甚麼"><a href="#QUESTION-2-樹的重心是甚麼" class="headerlink" title="QUESTION 2: 樹的重心是甚麼?"></a>QUESTION 2: 樹的重心是甚麼?</h3><p>樹重心的所有子樹大小不超過整個樹大小的一半。</p>
<h3 id="QEUSTION-3-此演算法的複雜度呢"><a href="#QEUSTION-3-此演算法的複雜度呢" class="headerlink" title="QEUSTION 3: 此演算法的複雜度呢?"></a>QEUSTION 3: 此演算法的複雜度呢?</h3><p>\(O(\log n)\)</p>
<h3 id="名詞解釋-公式"><a href="#名詞解釋-公式" class="headerlink" title="名詞解釋: 公式"></a>名詞解釋: 公式</h3><p>樹的重心到左子樹中的路徑 + 樹的重心到右子樹的路徑 = k </p>
<h2 id="點分治原理操作"><a href="#點分治原理操作" class="headerlink" title="點分治原理操作"></a>點分治原理操作</h2><p><img src="/images/Codeforces161D/1.png" alt=""><br>如圖，我們先找出樹的重心，在將從樹的重心到左子樹中的路徑 + 樹的重心到右子樹的路徑加起來如果等於 k 我們就加一條路徑，再透過分治的方式，再從子樹的重心在重複一樣動作。<del>可以寫出很玄的遞迴</del></p>
<h2 id="選樹的重心"><a href="#選樹的重心" class="headerlink" title="選樹的重心"></a>選樹的重心</h2><p><img src="/images/Codeforces161D/2.png" alt=""><br>樹的重心不可以亂選，如果沒有選好是很浪費效率的，如上圖。</p>
<h3 id="QUESTION-你想想看如果選到-y-會多浪費時間www。"><a href="#QUESTION-你想想看如果選到-y-會多浪費時間www。" class="headerlink" title="QUESTION : 你想想看如果選到 y 會多浪費時間www。"></a>QUESTION : 你想想看如果選到 y 會多浪費時間www。</h3><p>當讀者學會以後，可以自行回答此問題，也順便增加自己對點分治的能力 XD。</p>
<p>開玩笑的，這篇是要讓讀者能了解點分治的，選 y 的話找路徑需要遞迴 4 次，但選 x 只需要遞迴 2 次，可以得知要找的點要盡量讓遞迴的次數最少為最優，樹的重心是最好的。</p>
<h2 id="建構樹"><a href="#建構樹" class="headerlink" title="建構樹"></a>建構樹</h2><p>建構點分治的樹比較抽象，因此拉出來獨立討論：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span> </span><br><span class="line">    <span class="keyword">int</span> v , nx ;</span><br><span class="line">     <span class="comment">//v = x 可以到此點，路徑為一 , nx 為 x 可以到此點的另外一個 Edge index，一樣是路徑為一 </span></span><br><span class="line">&#125;Edge[MAXN*<span class="number">2</span>]; </span><br><span class="line"><span class="comment">// 由於無向邊，但此結構是有向所以必須 *2， u -&gt; v , v &lt;- u 各一條。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n )</span></span>&#123;</span><br><span class="line">    Max[<span class="number">0</span>] = n ; </span><br><span class="line">    <span class="comment">// Max 是此點最大子樹中的點加起來，0 我們不採用於是就將它設為題目初始長度</span></span><br><span class="line">    ans = cnt = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= n ; i++)&#123;</span><br><span class="line">        head[i] = <span class="number">-1</span> ; </span><br><span class="line">        <span class="comment">//head 為 i 可以到某個點，路徑為一的 Edge index </span></span><br><span class="line">        <span class="comment">// head = -1 是因為下面的遞迴停止關鍵為 ~i ， ~(-1) = 0  </span></span><br><span class="line">        vis[i] = <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="尋找樹的重心"><a href="#尋找樹的重心" class="headerlink" title="尋找樹的重心"></a>尋找樹的重心</h2><p>透過 DFS + BFS，DFS 來尋找路徑長，BFS 來檢索子樹即可寫出這份遞迴來得知樹的重心：<br>我相信各位應該看不太懂這程式碼在寫甚麼於是我逐行增加註解。<del>寫得不好，大神請無視</del></p>
<p>也提供看我之前用紙筆實作的筆記來方便讀者學習，如果還是看不太懂註解那就看看我的實作筆記希望能看懂QQ<br><a href="#寫作筆記-1-get-root-note-1"> 寫作筆記 1 get_root (note 1) </a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//rt = root </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_rt</span><span class="params">(<span class="keyword">int</span> u , <span class="keyword">int</span> fa )</span></span>&#123;</span><br><span class="line">    sz[u] = <span class="number">1</span> ; Max[u] = <span class="number">0</span> ; </span><br><span class="line">    <span class="comment">//sz 是此點子樹的大小 // Max 是此點最大子樹中的點加起來</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u] ; ~i ; i=Edge[i].nx)&#123; </span><br><span class="line">        <span class="comment">// 枚舉次點進行的兒子 = 進行長度為一的 BFS(玄學版)</span></span><br><span class="line">        <span class="comment">// 由於 i = Edge[i].nx 於是可以直接找到下一個 i to v 路徑為一的節點</span></span><br><span class="line">        <span class="keyword">int</span> v = Edge[i].v ; </span><br><span class="line">        <span class="keyword">if</span>(vis[v] || v == fa )  <span class="keyword">continue</span> ; </span><br><span class="line">        <span class="comment">// vis 表示此點用過了，在第一次找重心時無用。之後會用到。</span></span><br><span class="line">        get_rt(v,u); <span class="comment">// 向下延伸</span></span><br><span class="line">        Max[u] = max(Max[u] , sz[v]); </span><br><span class="line">        <span class="comment">// 判斷這顆子樹有沒有比此點最大的子樹還要大</span></span><br><span class="line">        sz[u] += sz[v] ; <span class="comment">//更新 sz</span></span><br><span class="line">    &#125;</span><br><span class="line">    Max[u] = max(Max[u] , n - sz[u]); </span><br><span class="line">    <span class="comment">//用此點將樹分割，分割的兩部分是從此點展開的子樹與另外一個從父節點延伸的子樹 (n - sz[u])</span></span><br><span class="line">    <span class="keyword">if</span>(Max[rt] &gt; Max[u]) </span><br><span class="line">    <span class="comment">// 如果現在的最大子樹比較小那就採用現在的點</span></span><br><span class="line">        rt =  u ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">## 尋找從此點到所有子樹中所有點的距離</span><br><span class="line">這遞迴將我們從 u 點到所有點的距離都會求出來。</span><br><span class="line">一樣會每行進行註解，但前面有講到則不再贅述。</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_dis</span><span class="params">(<span class="keyword">int</span> u , <span class="keyword">int</span> fa , <span class="keyword">int</span> d)</span></span>&#123; <span class="comment">// fa = father , d = distance</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u] ; ~i ; i= Edge[i].nx)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = Edge[i].v ;</span><br><span class="line">        <span class="keyword">if</span>(vis[v] || v == fa ) <span class="keyword">continue</span> ; </span><br><span class="line">        <span class="comment">//如果 v == fa ，代表這點已經沒辦法再向下延伸</span></span><br><span class="line">        <span class="comment">// vis 如果此點有被用到就返回</span></span><br><span class="line">        dis[++cnt] = d + <span class="number">1</span> ; </span><br><span class="line">        <span class="comment">// 由於這裡我們並不在意是哪個點到哪個點的路徑長，我們只在意此路徑長多少，於是我們就用 ++cnt，循序填滿。</span></span><br><span class="line">        get_dis(v,u,dis[cnt]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="求通過此點的子樹們相加起來的路徑長來求答案"><a href="#求通過此點的子樹們相加起來的路徑長來求答案" class="headerlink" title="求通過此點的子樹們相加起來的路徑長來求答案"></a>求通過此點的子樹們相加起來的路徑長來求答案</h2><p>透過樹的重心將一顆完整的樹在分割成子樹，詢問如果從 子樹 A 到樹重心 + 子樹 B 到樹重心 = k 的有多少。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_ans</span><span class="params">(<span class="keyword">int</span> u , <span class="keyword">int</span> d )</span></span>&#123;</span><br><span class="line">    dis[cnt=<span class="number">1</span>] = d ;</span><br><span class="line">    get_dis(u,<span class="number">0</span>,d) ;</span><br><span class="line">    sort(dis+<span class="number">1</span> , dis+cnt+<span class="number">1</span>) ; </span><br><span class="line">    <span class="comment">// 由於 dis 裡面每一個都是從任意一個點到樹重心，透過公式(子樹 A 到樹重心 + 子樹 B 到樹重心 = k)，</span></span><br><span class="line">    <span class="comment">// 我們並不需要在意哪個點只需要在意距離長</span></span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span> , ans = <span class="number">0</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(l &lt; cnt &amp;&amp; dis[l] + dis[cnt] &lt; k ) l++ ; </span><br><span class="line">    <span class="comment">// 這時候的 cnt 因為 get_dis 不斷增加數量於是當前的 cnt 也會等於 dis 的右邊界。</span></span><br><span class="line">    <span class="comment">// 我們假設我們先使用 dis[l] 也就是最小路徑去跟其他條進行配合看是否能夠等於 k</span></span><br><span class="line">    <span class="comment">//如果 dis[l] + dis[cnt] 都沒有大於 k 就代表，怎樣都不會大於 k，於是將 l 範圍縮小增進，優化效率。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(l &lt; cnt &amp;&amp; dis[l] &lt;= k - dis[l])&#123; </span><br><span class="line">        ans += upper_bound(dis + l + <span class="number">1</span> , dis + cnt + <span class="number">1</span> , k - dis[l]) -  \ </span><br><span class="line">                lower_bound(dis+l+<span class="number">1</span> , dis+cnt+<span class="number">1</span> , k-dis[l]);</span><br><span class="line">        <span class="comment">// 因為我們的 dis 右邊界是一，所以所有 dis +1</span></span><br><span class="line">        <span class="comment">// k - dis[l]，可以找出我們 k = dis[l] + x， x 為任意變數能夠滿足前述公式即可。</span></span><br><span class="line">        l++ ; <span class="comment">// 再換新的 dis[l] 來進行配合</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="扣掉重複算到的路徑，用-DFS-實現"><a href="#扣掉重複算到的路徑，用-DFS-實現" class="headerlink" title="扣掉重複算到的路徑，用 DFS 實現"></a>扣掉重複算到的路徑，用 DFS 實現</h2><p><img src="/images/Codeforces161D/3.png" alt=""><br>我們從 A 到 root + B 到 root，路徑為 4，但這樣是不正確的，因為 A , B 都在同一個子樹並沒有符合我們一直強調的公式。於是我們需要做一個 BFS + DFS，再將重心的點分割成子樹再進行 <code>get_dis</code> and <code>get_ans</code> 的動作，就可以避免掉圖片中的問題。</p>
<p>如果還有點疑問，看程式碼八，也許程式碼的註解可以幫助到你。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u )</span></span>&#123;</span><br><span class="line">    vis[u] = <span class="number">1</span> ; <span class="comment">// 被用過的點，也是我們用來分割子樹的標準</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; rt &lt;&lt; ' ' &lt;&lt; u &lt;&lt; '\n' ;</span></span><br><span class="line">    ans += get_ans(u , <span class="number">0</span>); <span class="comment">// 得到公式中的 k，裡面會有不合法狀態，圖片中的問題。 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u] ; ~i ; i = Edge[i].nx)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = Edge[i].v ;</span><br><span class="line">        <span class="keyword">if</span>(vis[v]) <span class="keyword">continue</span> ;</span><br><span class="line">        ans -= get_ans(v , <span class="number">1</span>) ; <span class="comment">// 移除掉不合法的狀態 </span></span><br><span class="line">        <span class="comment">// QUESTION: 為甚麼這行可以移除掉不合法狀態呢?</span></span><br><span class="line">        <span class="comment">/* 我們看看上面的圖，他們是不是共用了至少同一條路徑？，如果共用很多條也沒關係</span></span><br><span class="line"><span class="comment">        ，之後的 DFS 就會注意到他們並解決這些問題。</span></span><br><span class="line"><span class="comment">        於是我們就可以用 get_ans(v,1) 用子樹的下一個點來進行一次 DFS，</span></span><br><span class="line"><span class="comment">        我們在假設 x -&gt; v 這條路徑會被共用，所以先直接設定成 1，</span></span><br><span class="line"><span class="comment">        這樣只要是不合法的答案在這邊都會被發現，就可以直接減掉就剩下合法答案了！</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        讀者如果還是不懂，可以嘗試將途中橘色的線(共用路徑)進行 +1 後再用 son 去算 dis_ans(son,1)</span></span><br><span class="line"><span class="comment">         去算 a, b 看 k = 4 時是不是也會有一條 XD。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        n = sz[v] , rt = <span class="number">0</span> , get_rt(v,u); <span class="comment">//由於子樹被切割，所以 n 的 size 也必須減少成子樹的大小。</span></span><br><span class="line">        <span class="comment">//由於樹被切割，所以必須重新尋找被切割樹後重心。</span></span><br><span class="line">        dfs(rt); <span class="comment">//再將樹進行切割，來配合公式。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也提供看我之前用紙筆實作的筆記來方便讀者學習，如果還是看不太懂註解那就看看我的實作筆記希望能看懂QQ<br><a href="#寫作筆記-2-dfs-and-get-ans-and-get-dis-note-2"> 寫作筆記 2 dfs and get_ans and get_dis (note 2) </a></p>
<h3 id="小貼心-由於我認為會有讀者對於在程式碼裡面放-QUESTION，閱讀不太方便，所以拉出來再寫一遍"><a href="#小貼心-由於我認為會有讀者對於在程式碼裡面放-QUESTION，閱讀不太方便，所以拉出來再寫一遍" class="headerlink" title="小貼心:由於我認為會有讀者對於在程式碼裡面放 QUESTION，閱讀不太方便，所以拉出來再寫一遍"></a>小貼心:由於我認為會有讀者對於在程式碼裡面放 QUESTION，閱讀不太方便，所以拉出來再寫一遍</h3><h4 id="QUESTION-為甚麼這行可以移除掉不合法狀態呢"><a href="#QUESTION-為甚麼這行可以移除掉不合法狀態呢" class="headerlink" title="QUESTION: 為甚麼這行可以移除掉不合法狀態呢?"></a>QUESTION: 為甚麼這行可以移除掉不合法狀態呢?</h4><h5 id="SOLUTION"><a href="#SOLUTION" class="headerlink" title="SOLUTION :"></a>SOLUTION :</h5><p>我們看看上面的圖，他們是不是共用了至少同一條路徑？，如果共用很多條也沒關係，之後的 DFS 就會注意到他們並解決這些問題。<br>於是我們就可以用 get_ans(v,1) 用子樹的下一個點來進行一次 DFS，我們在假設 x -&gt; v 這條路徑會被共用，所以先直接設定成 1，這樣只要是不合法的答案在這邊都會被發現，就可以直接減掉就剩下合法答案了！</p>
<p>讀者如果還是不懂，可以嘗試將途中橘色的線(共用路徑)進行 +1 後再用 son 去算 dis_ans(son,1) 去算 a, b 看 k = 4 時是不是也會有一條 XD。</p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://www.luogu.com.cn/blog/user9012/dian-fen-zhi-lve-xie#blog-comments" target="_blank" rel="noopener">Dispwnl 的博客-点分治略解</a><br><a href="https://zhuanlan.zhihu.com/p/56692947" target="_blank" rel="noopener">点分治学习笔记</a><br><a href="https://blog.csdn.net/The___Flash/article/details/101099955" target="_blank" rel="noopener">Distance in Tree （CodeForces - 161D，点分治）</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>老實講，我其實學習起來是很吃力的。可能是因為我的基礎知識還不足以讓我可以閱讀我參考連結所放的文章，畢竟我的程式能力跟各位大神比還只是一個還在吃奶的小孩，很多大神可能都懂的東西，我都不懂，所以理解起來也會特別吃力，總是要先看一遍講解在自己用紙筆實作一遍程式碼才可以懂大神們的思維，但我真的很感謝大神，如果沒有他們，我連學習的機會都沒有。</p>
<p>雖然說用紙筆實作一遍程式碼很浪費時間，大概花了 5 小時理解吧，但它確實是最容易理解的，我只實作一遍我就能理解大神們的操作，如再 DFS 的遞迴中加入 BFS，使用那種 for 寫法www。</p>
<p>雖然每次在學習演算法總是會讓我覺得難過，因為是自學很容易遇到學習障礙，但我認為這是我應該要學會的基礎。我並不是幸運的孩子，我勢必要先做出一些成果，讓資源跟大神可以關注到我，在提拔我或幫助我成長。在還沒有大神們關注到我之前，我會默默耕耘，繼續努力的！</p>
<p>為了讓讀者與未來的我看到之前的我學習是怎麼學習的，我就在這邊放入我為了學習這份演算法而在紙上實作的紀錄吧！</p>
<h3 id="寫作筆記-1-get-root-note-1"><a href="#寫作筆記-1-get-root-note-1" class="headerlink" title="寫作筆記 1 get_root (note 1)"></a>寫作筆記 1 get_root (note 1)</h3><p><img src="/images/Codeforces161D/4.jpg" alt=""></p>
<h3 id="寫作筆記-2-dfs-and-get-ans-and-get-dis-note-2"><a href="#寫作筆記-2-dfs-and-get-ans-and-get-dis-note-2" class="headerlink" title="寫作筆記 2 dfs and get_ans and get_dis (note 2)"></a>寫作筆記 2 dfs and get_ans and get_dis (note 2)</h3><p><img src="/images/Codeforces161D/6.jpg" alt=""></p>
<h2 id="此題目程式碼"><a href="#此題目程式碼" class="headerlink" title="此題目程式碼"></a>此題目程式碼</h2><p>還真虧讀者可以讀到這邊，我也花了三個小時撰寫文章，如果是已經懂點分治的朋友們應該會覺得很煩吧！<del>雖然我覺得懂點分治的大神並不會對這題感到困難www，就不會來看我的文章了 XD</del></p>
<p>對，如題目大意所說，這題就只是個模板題，於是剩下的就是一些標頭檔跟題目給的資料範圍限制了 XD。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 50005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n , k , a , b ;</span><br><span class="line"><span class="keyword">int</span> ans , cnt ;</span><br><span class="line"><span class="keyword">int</span> Max[MAXN] , sz[MAXN] , rt ;</span><br><span class="line"><span class="keyword">int</span> head[MAXN], dis[MAXN];</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v , nx ;</span><br><span class="line">&#125;Edge[MAXN*<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n )</span></span>&#123;</span><br><span class="line">    Max[<span class="number">0</span>] = n ;</span><br><span class="line">    ans = cnt = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= n ; i++)&#123;</span><br><span class="line">        head[i] = <span class="number">-1</span> ;</span><br><span class="line">        vis[i] = <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u , <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    Edge[cnt].v = v ;</span><br><span class="line">    Edge[cnt].nx = head[u] ;</span><br><span class="line">    head[u] = cnt++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_rt</span><span class="params">(<span class="keyword">int</span> u , <span class="keyword">int</span> fa )</span></span>&#123;</span><br><span class="line">    sz[u] = <span class="number">1</span> ; Max[u] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u] ; ~i ; i=Edge[i].nx)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = Edge[i].v ;</span><br><span class="line">        <span class="keyword">if</span>(vis[v] || v == fa )  <span class="keyword">continue</span> ;</span><br><span class="line">        get_rt(v,u);</span><br><span class="line">        sz[u] += sz[v] ;</span><br><span class="line">        Max[u] = max(Max[u] , sz[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    Max[u] = max(Max[u] , n - sz[u]);</span><br><span class="line">    <span class="keyword">if</span>(Max[rt] &gt; Max[u])</span><br><span class="line">        rt =  u ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_dis</span><span class="params">(<span class="keyword">int</span> u , <span class="keyword">int</span> fa , <span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u] ; ~i ; i= Edge[i].nx)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = Edge[i].v ;</span><br><span class="line">        <span class="keyword">if</span>(vis[v] || v == fa ) <span class="keyword">continue</span> ;</span><br><span class="line">        dis[++cnt] = d + <span class="number">1</span> ;</span><br><span class="line">        get_dis(v,u,dis[cnt]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_ans</span><span class="params">(<span class="keyword">int</span> u , <span class="keyword">int</span> d )</span></span>&#123;</span><br><span class="line">    dis[cnt=<span class="number">1</span>] = d ;</span><br><span class="line">    get_dis(u,<span class="number">0</span>,d) ;</span><br><span class="line">    sort(dis+<span class="number">1</span> , dis+cnt+<span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span> , ans = <span class="number">0</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(l &lt; cnt &amp;&amp; dis[l] + dis[cnt] &lt; k ) l++ ;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; cnt &amp;&amp; dis[l] &lt;= k - dis[l])&#123;</span><br><span class="line">        ans += upper_bound(dis + l + <span class="number">1</span> , dis + cnt + <span class="number">1</span> , k - dis[l]) - lower_bound(dis+l+<span class="number">1</span> , dis+cnt+<span class="number">1</span> , k-dis[l]);</span><br><span class="line">        l++ ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u )</span></span>&#123;</span><br><span class="line">    vis[u] = <span class="number">1</span> ;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; rt &lt;&lt; ' ' &lt;&lt; u &lt;&lt; '\n' ;</span></span><br><span class="line">    ans += get_ans(u , <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u] ; ~i ; i = Edge[i].nx)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = Edge[i].v ;</span><br><span class="line">        <span class="keyword">if</span>(vis[v]) <span class="keyword">continue</span> ;</span><br><span class="line">        ans -= get_ans(v , <span class="number">1</span>) ;</span><br><span class="line">        n = sz[v] , rt = <span class="number">0</span>  , get_rt(v,u);</span><br><span class="line">        dfs(rt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//#ifdef LOCAL</span></span><br><span class="line"><span class="comment">//    freopen("in1.txt" , "r" , stdin);</span></span><br><span class="line"><span class="comment">//#endif // LOCAL</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k ;</span><br><span class="line">    init(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>; i &lt; n ; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b ;</span><br><span class="line">        add(a,b);</span><br><span class="line">        add(b,a);</span><br><span class="line">    &#125;</span><br><span class="line">    rt = <span class="number">0</span> ; get_rt(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    dfs(rt);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Codeforces</category>
        <category>演算法知識</category>
      </categories>
      <tags>
        <tag>程式解題</tag>
        <tag>點分治</tag>
        <tag>演算法知識</tag>
      </tags>
  </entry>
  <entry>
    <title>QUESTION! HEXO 可以使用錨點嗎？</title>
    <url>/2020/09/11/blog/markdown-anchor/</url>
    <content><![CDATA[<h2 id="內容說明"><a href="#內容說明" class="headerlink" title="內容說明:"></a>內容說明:</h2><blockquote>
<p>關於我在撰寫 blog 時遇到的問題經驗，並留下紀錄來解決。</p>
</blockquote>
<a id="more"></a>

<h2 id="QUESTION-HEXO-可以使用錨點嗎？"><a href="#QUESTION-HEXO-可以使用錨點嗎？" class="headerlink" title="QUESTION: HEXO 可以使用錨點嗎？"></a>QUESTION: HEXO 可以使用錨點嗎？</h2><p>我會寫的文章還會不行嗎 XD。</p>
<p>markdown 中常用 # 來建立段落標題，於是就利用段落標題來添加錨點</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">標題1</span>](<span class="link">#標題1</span>)</span><br><span class="line">[<span class="string">標題2</span>](<span class="link">#標題2</span>)</span><br><span class="line">[<span class="string">標題3</span>](<span class="link">#標題3</span>)</span><br><span class="line"></span><br><span class="line"><span class="section"># 標題一</span></span><br><span class="line"><span class="section">## 標題二</span></span><br><span class="line"><span class="section">### 標題三</span></span><br></pre></td></tr></table></figure>

<h3 id="需要注意的小細節"><a href="#需要注意的小細節" class="headerlink" title="需要注意的小細節:"></a>需要注意的小細節:</h3><p><strong>如果我們的標題有空白時則使用 - 號代替，如果標題有小括號則不須寫出。</strong></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">標題2 Test</span>](<span class="link">#標題2-test</span>)</span><br><span class="line"></span><br><span class="line"><span class="section">### 標題2 Test</span></span><br></pre></td></tr></table></figure>

<h3 id="快速找到錨點的小步驟"><a href="#快速找到錨點的小步驟" class="headerlink" title="快速找到錨點的小步驟"></a>快速找到錨點的小步驟</h3><p>如果你是用來寫 blog 文章，建議可以 localhost 後直接點標題(圖片中的 1)，就可以看到 url 上有錨點(圖片中的二)，就可以直接貼在 markdown 中，是不是很方便呢！<br><img src="/images/markdown-anchor/1.PNG" alt=""></p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://www.jishuwen.com/d/2uT8/zh-tw" target="_blank" rel="noopener">Github markdown 錨點</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>畢竟 markdown 要是沒有錨點，那 markdown 在寫那種比較長的文章就相對吃力拉，幸好有錨點，也謝謝 markdown 的發明團隊們可以讓我在寫文章時減少撰寫網頁的麻煩。</p>
<p>也謝謝 Clloz 大大在網路上分享此技術，讓英文不好的我也可以快速學習，非常謝謝他。</p>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>人生旅途</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces 1406A - Subset Mex (水題)</title>
    <url>/2020/09/14/Codeforces/Codeforces%201406A/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>定義 mex: 這集合裡面缺少的最小負整數。<br>如 \(mex(  \{ 1,4,0,2,2,1 \}  ) = 3\)，缺少 \(3\)<br>如 \(mex(\{3,2,3,1,3,0,0\}) = 4\)，缺少 \(4\)</p>
<p>給你一組數列，要把它拆成 A , B 兩個子集，如果此數列裡面有重複的數字時需要平均分配給 A , B。試問如何讓 \(mex(a) + mex(b) \) 最大？</p>
</blockquote>
<a id="more"></a>

<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>依序把數列讀入，之後排序，再透過 a , b 兩個變數紀錄這數列裡面缺少的最小與次小的負整數就是答案。</p>
<h3 id="為甚麼可以這樣做？"><a href="#為甚麼可以這樣做？" class="headerlink" title="為甚麼可以這樣做？"></a>為甚麼可以這樣做？</h3><p>由於 mex 的定義，是集合裡面缺少的最小負整數，而再根據題目拆子集的要求只要有重複的就要分配給 a,b 兩個集合。</p>
<p>然後我們來舉個例:</p>
<ul>
<li><p>\( \{ 0,1,2,3 \} \)</p>
<blockquote>
<p> \(A = \{1,2,3 \}  , mex(A)=4 \)<br> \(B = \{\} , mex(B)=0 \)</p>
</blockquote>
</li>
<li><p>\(\{0,0,1,1,2,4\}\)</p>
<blockquote>
<p>\(A = \{0,1,2,4\} , mex(A) = 3 \)<br>\(B = \{0,1\} , mex(B) = 2 \)<br>這裡的 4 放在 A 或 B 都沒關係，不影響</p>
</blockquote>
</li>
</ul>
<h3 id="得出結論"><a href="#得出結論" class="headerlink" title="得出結論"></a>得出結論</h3><p>數列中，如果此數列中沒有重複的最小整數，那最小整數就會是 \(mex(B)\)，A 則是排序中第一個缺失的最小整數。</p>
<p>於是我們排序好，直接用一個 for，只要根據數字順序判斷這數列哪裡數字缺失就是 A 的位置，而 B 就是沒有重複的最小整數。</p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://www.cnblogs.com/RioTian/p/13659464.html" target="_blank" rel="noopener">Codeforces Round #670 (Div. 2) 深夜掉分（A - C题补题）</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>其實這場比賽我一題都沒有解出來www，實力不好啊！也不太會分配時間，這點我還需要再學習。然後這題有個很大的重點讓當時的我沒有解出來，就是<font color="#dd0000"><strong>我看不懂他的英文</strong></font> ，導致我在讀懂題目就花了 30 分鐘卻還沒有讀懂題目，浪費掉了許多時間。英文能力真的很重要，一定要學好。</p>
<p>等我 ICPC 2020 taipei 比完後我一定要來好好惡補我的英文能力，<del>演算法也要好嗎= = ~</del>。我還有好多事情要努力要學習，好希望自己的學習能力能夠好點。</p>
<p>感謝 <strong>RioTian</strong> 大神分享程式碼讓我可以看到這種程式解法，我知道中文題目後我沒有想到這種解法，而且這種解法更有效率更好懂！讓我學習了一課，謝謝大神讓我能夠往前成長一步。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 110</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> t , n , num[MAXN] =&#123;&#125; ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//#ifdef LOCAL</span></span><br><span class="line"><span class="comment">//    freopen("in1.txt" ,"r" , stdin ) ;</span></span><br><span class="line"><span class="comment">//#endif // LOCAL</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t ;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i++)</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; num[i] ;</span><br><span class="line">        sort(num,num+n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> a=<span class="number">0</span> , b = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num[i] == a ) a++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (num[i] == b ) b++ ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a + b &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>水題</tag>
        <tag>程式解題</tag>
        <tag>Codeforces Round .#670 (Div. 2)</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces 1406B - Maximum Product (暴力搜尋 Brute force)</title>
    <url>/2020/09/14/Codeforces/Codeforces%201406B/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>給你一組數列裡面含有正、負整數，試問從中找出 5 個數字乘起來數字最大</p>
</blockquote>
<a id="more"></a>

<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>先排序讀進來的全部數列，之後進行窮舉。</p>
<h3 id="窮舉共有三種方法："><a href="#窮舉共有三種方法：" class="headerlink" title="窮舉共有三種方法："></a>窮舉共有三種方法：</h3><blockquote>
<p>全部 5 個數字選最大的正整數<br>選 3 個最大正整數 + 2 個最小負整數<br>選 1 個最大正整數 + 4 個最小負整數</p>
</blockquote>
<h3 id="Why-怎麼是這樣做呢"><a href="#Why-怎麼是這樣做呢" class="headerlink" title="Why? 怎麼是這樣做呢?"></a>Why? 怎麼是這樣做呢?</h3><p>由於我們負負得正，我們沒辦法確定說到底選誰比較好，但我們可以用窮舉的方式來找出最好的解法。<br>只要進行排序，最小的兩個負數相乘肯定會比其他的負數相乘來的更大，以此類推，最大的兩個正整數相乘肯定會比其他的正整數相乘更大。</p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://www.cnblogs.com/RioTian/p/13659464.html" target="_blank" rel="noopener">Codeforces Round #670 (Div. 2) 深夜掉分（A - C题补题）</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>這題其實很簡單的，但是我把它想得太複雜了。<del>這…這就是社會的歷練嗎</del>，明明小學生都可以解開的簡單題目，我花了一小時半都沒有解出來。這題出的好呀，直接打中的思考盲點，好過癮，讓我學起來了！</p>
<p>我原本是想要用遞迴解開但我一直錯呀，真的比賽思考很久都還是沒有解開，好討厭。結果我把她想得太困難了，用簡單的小技巧就能解開了。</p>
<p>遞迴解法是選出 9 個數字，其中 5 個為正整數最大，4 個為負整數最小，然後進行遞迴判斷，之後進行優化，但只能過題目的測資，之後就不行了XD，我的技術還是不夠承受呀XD</p>
<p>感謝 <strong>RioTian</strong> 大神分享程式碼讓我可以看到這種程式解法，讓我可以了解到這種窮舉解法，讓我學習了一課，謝謝大神讓我能夠往前成長一步。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 200010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">ll t , n , a[MAXN] = &#123;&#125; ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//#ifdef LOCAL</span></span><br><span class="line"><span class="comment">//    freopen("in1.txt" , "r" , stdin );</span></span><br><span class="line"><span class="comment">//#endif // LOCAL</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t ;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i++)</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a[i] ;</span><br><span class="line">        sort(a , a + n);</span><br><span class="line"></span><br><span class="line">        ll ans[<span class="number">5</span>] = &#123;&#125; ;</span><br><span class="line">        ans[<span class="number">0</span>] = a[n<span class="number">-1</span>] * a[n<span class="number">-2</span>] * a[n<span class="number">-3</span>] * a[n<span class="number">-4</span>] * a[n<span class="number">-5</span>] ;</span><br><span class="line">        ans[<span class="number">1</span>] = a[n<span class="number">-1</span>] * a[n<span class="number">-2</span>] * a[n<span class="number">-3</span>] * a[<span class="number">0</span>] * a[<span class="number">1</span>] ;</span><br><span class="line">        ans[<span class="number">2</span>] = a[n<span class="number">-1</span>] * a[<span class="number">0</span>] * a[<span class="number">1</span>] * a[<span class="number">2</span>] * a[<span class="number">3</span>] ;</span><br><span class="line">        sort(ans,ans+<span class="number">3</span>);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans[<span class="number">2</span>] &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="題外話"><a href="#題外話" class="headerlink" title="題外話"></a>題外話</h2><p>這裡是我的遞迴解法，有人要幫我修改這程式幫助我通過嗎？如果通過私訊我告訴我好嗎XD，謝謝你啦</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lln</span>&#123;</span></span><br><span class="line">    ll num , neg ;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">deque</span>&lt;lln&gt; dnum;</span><br><span class="line"><span class="keyword">int</span> t , n ;</span><br><span class="line">ll maxn = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(lln a , lln b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span>  a.num &lt; b.num ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">p</span><span class="params">(<span class="keyword">int</span> index , ll sum , <span class="keyword">int</span> i , ll intNeg )</span></span>&#123;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; index &lt;&lt; ' ' &lt;&lt; sum &lt;&lt; ' ' &lt;&lt; i &lt;&lt; ' ' &lt;&lt; intNeg &lt;&lt; '\n' ;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(index &gt;= <span class="number">5</span>)&#123;</span><br><span class="line">        maxn = max(sum,maxn) ;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; sum &lt;&lt; '\n' ;</span></span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">0</span> )</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    p(index +<span class="number">1</span> , sum * dnum[i].num * (dnum[i].neg? <span class="number">-1</span> : <span class="number">1</span>) , i<span class="number">-1</span> , intNeg+dnum[i].neg);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((intNeg+dnum[i].neg) % <span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">        p(index, sum , i<span class="number">-1</span> , intNeg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span> , <span class="built_in">stdin</span> );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line"></span><br><span class="line">    lln temp ;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t ;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">        dnum.clear();</span><br><span class="line">        maxn = <span class="number">-1e15</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; temp.num ;</span><br><span class="line">            <span class="keyword">if</span>(temp.num &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                temp.neg = <span class="number">1</span> ;</span><br><span class="line">                temp.num *= <span class="number">-1</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                temp.neg = <span class="number">0</span> ;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; temp.num &lt;&lt; ' ' &lt;&lt; temp.neg &lt;&lt; '\n';</span></span><br><span class="line">            dnum.push_back(temp) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; '\n' ;</span></span><br><span class="line">        sort(dnum.begin() , dnum.end(), compare ) ;</span><br><span class="line">        p(<span class="number">0</span>,<span class="number">1</span>,n<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; maxn &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>水題</tag>
        <tag>程式解題</tag>
        <tag>Codeforces Round .#670 (Div. 2)</tag>
        <tag>暴力搜尋 Brute force</tag>
      </tags>
  </entry>
  <entry>
    <title>R string 取代文字語法與教學</title>
    <url>/2020/09/14/R/R-string-replace/</url>
    <content><![CDATA[<h2 id="內容說明"><a href="#內容說明" class="headerlink" title="內容說明"></a>內容說明</h2><blockquote>
<p>說明 R 語言中 string 怎麼做到取代 (replace) 功能。</p>
</blockquote>
<a id="more"></a>

<h2 id="QUESTION-R-有沒有一種語法關於字串中取代文字呢？"><a href="#QUESTION-R-有沒有一種語法關於字串中取代文字呢？" class="headerlink" title="QUESTION! R 有沒有一種語法關於字串中取代文字呢？"></a>QUESTION! R 有沒有一種語法關於字串中取代文字呢？</h2><blockquote>
<p>有，但他有兩種方法，好麻煩wwww。<br>但我們這邊只介紹最簡單的方法，其中另外一方法必須要安裝額外套件因而略過。</p>
</blockquote>
<h3 id="soultion"><a href="#soultion" class="headerlink" title="soultion:"></a>soultion:</h3><p>使用 <code>gsub</code> 方法。</p>
<p>gsub 基本上與其他語言中的 replace 相同，只是換了一個名字..。<del>這些程式語言就不能再互相好好整理一下嗎..</del></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">strA &lt;- <span class="string">"I can to sleep"</span></span><br><span class="line">gsub(<span class="string">"cab"</span> , <span class="string">"want"</span> , strA)</span><br><span class="line"><span class="comment">#"I want to sleep"</span></span><br></pre></td></tr></table></figure>

<h3 id="tip"><a href="#tip" class="headerlink" title="tip:"></a>tip:</h3><p>基本上任何符號與空格、tab、換行都是可以被識別的，但還是有些例外。<br>這邊只附上一些常用的例外，還有些例外可以點此<a href="https://blog.csdn.net/lztttao/article/details/82086346" target="_blank" rel="noopener">連結</a></p>
<table>
<thead>
<tr>
<th>取代寫法</th>
<th>實際取代</th>
<th>說明</th>
</tr>
</thead>
<tbody><tr>
<td>//.</td>
<td>.</td>
<td>取代 , 必須先加//</td>
</tr>
<tr>
<td>//+</td>
<td>+</td>
<td>取代 + 必須先加//</td>
</tr>
<tr>
<td>[:blank:]</td>
<td>取代空白字元，如 space or tab</td>
<td>這真的很好用欸，超讚</td>
</tr>
<tr>
<td>[:digit:]</td>
<td>所有阿拉伯數字 1~9</td>
<td>這也是非常好用欸。<del>C 有沒有考慮跟進一下</del></td>
</tr>
</tbody></table>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://blog.csdn.net/lztttao/article/details/82086346" target="_blank" rel="noopener">R语言-gsub替换字符工具</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>原本都很喜歡寫 C，現在越來越喜歡寫 R，R 真的好好用一堆方便的寫法，<del>還有一堆堪稱是神奇的操作，給喜歡 C 的人看是玩壞www</del>，不過我也要好好努力學會更多的語言，造就自己的優勢！</p>
]]></content>
      <categories>
        <category>R語言</category>
      </categories>
      <tags>
        <tag>R語言</tag>
        <tag>學習筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces 126B - Password (Z-algorithm 講解)</title>
    <url>/2020/09/18/Codeforces/Codeforces%20126B/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>給你一字串 X，試問有沒有一個子字串 S，在 X 的頭、尾巴、中間都出現。<br>                                ，在 X 的 prefix , suffix and Beside prefix and suffix appear。</p>
</blockquote>
<a id="more"></a>

<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>這題是 Z algorithm 的模板題，先介紹 Z-algorithm。<br><strong>此題有多種解，這裡使用 Z-algorithm 解</strong></p>
<blockquote>
<p>專門解決在線性時間中在一段文字 (text) 中找到我們所需要的段落 (pattern)<br>與此類似的演算法: KMP algorithm<br>由於此題是 Z-algorithm 的模板題，只要能夠了解 Z-algorithm 就能解決此問題。<br>這題為教學題，但此問題還有一點點的小設計，需要稍加解釋才能完全理解。</p>
</blockquote>
<h2 id="Z-algorithm-介紹"><a href="#Z-algorithm-介紹" class="headerlink" title="Z-algorithm 介紹"></a>Z-algorithm 介紹</h2><blockquote>
<p><strong>Z-algorithm 精隨: 透過 x,y 兩變數與 「Z 陣列」找出此字串中「最長共同前綴總和 (Longest Common Prefix)」</strong></p>
</blockquote>
<h3 id="QUESTION-1-x-y-and-「Z-陣列」是甚麼"><a href="#QUESTION-1-x-y-and-「Z-陣列」是甚麼" class="headerlink" title="QUESTION 1: x,y and 「Z 陣列」是甚麼?"></a>QUESTION 1: x,y and 「Z 陣列」是甚麼?</h3><p>等下會解釋XD，很快，看不到 1 分鐘就能知道了。</p>
<h3 id="QUESTION-2-此演算法的複雜度呢"><a href="#QUESTION-2-此演算法的複雜度呢" class="headerlink" title="QUESTION 2: 此演算法的複雜度呢?"></a>QUESTION 2: 此演算法的複雜度呢?</h3><p>複雜度 \(O(text + pattern)\)</p>
<h2 id="Z-algorithm-原理"><a href="#Z-algorithm-原理" class="headerlink" title="Z-algorithm 原理"></a>Z-algorithm 原理</h2><h3 id="Z-Array"><a href="#Z-Array" class="headerlink" title="Z Array"></a>Z Array</h3><p>在實現 Z-algorithm 需要用到一陣列，「Z Array」。</p>
<p>我們查看字串的長度，並建立一陣列與字串長度相當，其就是 Z Array，Z 陣列中的 i 表示當前「最長共同前綴總和 (Longest Common Prefix)」</p>
<p>\(Z[0]\) 毫無幫助XD，由於 Z[0] 只有自己他沒辦法達到共同，<del>他們都是自己</del>，即為都是「同一個字串」，因而無意義。</p>
<h3 id="x-and-y"><a href="#x-and-y" class="headerlink" title="x and y"></a>x and y</h3><p>在實現 Z-algorithm <strong>還</strong>需要用到兩變數 \( x , y\)。</p>
<blockquote>
<p>x = 目前<strong>共同前綴</strong>的第一個字元<br>y = 目前<strong>共同前綴</strong>的最後一字元在字串中的 index</p>
</blockquote>
<h3 id="Z-algorithm-再除了此題目以外的應用"><a href="#Z-algorithm-再除了此題目以外的應用" class="headerlink" title="Z-algorithm 再除了此題目以外的應用"></a>Z-algorithm 再除了此題目以外的應用</h3><p>通常是應用在尋找段落 (pattern)，將文本字串 (text) 與段落連接起來，視段落為「P」、文字為「T」，並加上一個沒有在 P and T 出現過的字元，假設為「\$」，產生出「P\$T」，最後產生 Z array，如果 Z array 中的某個值等於 P 的長度，則段落出現在此處。</p>
<p>因為從未出現過的字元使得「最長共同前綴總和 (Longest Common Prefix)」最大只能到 P，從未出現的字元阻斷了增加的可能性，才能應用在此。</p>
<h3 id="Z-algorithm-實現與說明"><a href="#Z-algorithm-實現與說明" class="headerlink" title="Z-algorithm 實現與說明"></a>Z-algorithm 實現與說明</h3><p>由於我認為在程式碼中加上好懂得註解十分好懂，所以我就根據每一行程式碼進行說明，相信會讓讀者更好學會此演算法。<br>如果對下方說明還是不了解，可以點擊此<a href="https://personal.utdallas.edu/~besp/demo/John2010/z-algorithm.htm" target="_blank" rel="noopener">連結</a>觀看動畫，也許能夠讓你更了解 Z-algorithm 運作。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> s ;</span><br><span class="line"><span class="keyword">int</span> z[s.length()] = &#123;&#125; ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; s.length() ; i++ )&#123; </span><br><span class="line">    z[i] = max(<span class="number">0</span>,min(z[i-x] , y - i + <span class="number">1</span>));</span><br><span class="line">    <span class="comment">// z[i-x] 直接詢問 z[i-x] 共同前綴嘗是多少，</span></span><br><span class="line">    <span class="comment">// 如果當前是在目前的共同前綴中，那理所當然現在的 i 必會等於最初的共同前綴 i-x 值，</span></span><br><span class="line">    <span class="comment">// 如果不是，那必定會是 0。</span></span><br><span class="line">    <span class="comment">// y-i+1  此共同前綴理應只會有 y-i+1 個</span></span><br><span class="line">    <span class="comment">//如果 z[i-x] 比較小，代表沒有從 i 位置開始的前綴字串，否則 z[i-x] 應該要更大，所以</span></span><br><span class="line">    <span class="comment">//也就表示 z[i] == z[k]。</span></span><br><span class="line">    <span class="comment">// 如果 y-i+1 比較小，代表這次的共同前綴比較小，因為 z[i-x] 更大，也就代表應該有從這</span></span><br><span class="line">    <span class="comment">//裡開始的共同前綴</span></span><br><span class="line">    <span class="keyword">while</span>(i + z[i] &lt; s.length() &amp;&amp; s[z[i]] == s[i+z[i]] )&#123;</span><br><span class="line">        x = i ;</span><br><span class="line">        y = i + z[i] ;</span><br><span class="line">        z[i]++ ;</span><br><span class="line">        <span class="comment">//進行比對，查看 s[z[i]] 的位置是否等於 s[i+z[i]] 的位置是的話就比對下一個</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>這樣 Z-algorithm 就完成了！</p>
<h2 id="焦點回到題目上，解開題目的小設計"><a href="#焦點回到題目上，解開題目的小設計" class="headerlink" title="焦點回到題目上，解開題目的小設計"></a>焦點回到題目上，解開題目的小設計</h2><p>我們可以透過 Z-algorithm 找到「最長共同前綴總和 (Longest Common Prefix)」，但題目的要求字串後面也需要前綴呀，有可能共同最長前綴是 abcabcabc，但是這樣會是 6 呀，應該要是 abc、長度 3，才行的！</p>
<p>於是我們需要加一個 if 來找出 3，來防止我們的程式出現瑕疵，這裡用程式碼來解釋會更好解釋，逆向思考有時候會比普通的思考方式來的更好。我們一樣根據每一行程式碼進行說明。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; s.length() ; i++)</span><br><span class="line">    <span class="keyword">if</span>(z[i] == s.length() - i &amp;&amp; maxn &gt;= s.length()-i )&#123;</span><br><span class="line">    <span class="comment">// z[i] == s.length() - i -&gt; 如果 z[i] 等於字串剩下的長度那保證會有</span></span><br><span class="line">    <span class="comment">//後綴，通常 i 都會接近 s.length() 時才會符合</span></span><br><span class="line">    <span class="comment">// maxn &gt;= s.length()-i -&gt; 再從 0 to s.length() 時勢必會找到並經過</span></span><br><span class="line">    <span class="comment">//「最長共同前綴總和 (Longest Common Prefix)」，只要他比後綴還要長或相等 </span></span><br><span class="line">    <span class="comment">//(還需要先滿足第一個條件，才能判斷到此條件)，就肯定代表中間已經也有經</span></span><br><span class="line">    <span class="comment">//過「最長共同前綴總和 (Longest Common Prefix)」，尾巴這個並不會是第一次經過，</span></span><br><span class="line">    <span class="comment">//如果尾巴是那就代表他只有兩次的共同前綴。</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; s.substr(<span class="number">0</span>,z[i]); <span class="comment">// 輸出答案</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    maxn = max(maxn , z[i]);</span><br><span class="line">    <span class="comment">//經過時更新 「最長共同前綴總和 (Longest Common Prefix)」</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://wangwilly.github.io/willywangkaa/2018/03/19/Algorithm-Z-%E6%BC%94%E7%AE%97%E6%B3%95/" target="_blank" rel="noopener">Algorithm - Z 演算法</a><br><a href="https://personal.utdallas.edu/~besp/demo/John2010/z-algorithm.htm" target="_blank" rel="noopener">Z Algorithm</a><br><a href="https://codeforces.com/blog/entry/3107" target="_blank" rel="noopener">Z Algorithm_codeforces</a><br><a href="https://blog.csdn.net/weixin_30362801/article/details/101855543" target="_blank" rel="noopener">Codeforces 126B Password（Z算法）</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>老實講，這題學習很快www，<del>廢話，程式碼很少呀</del>，但撰寫文章倒是花了很多時間，補了許多學習時沒有注意到的漏洞。此演算法寫起來十分簡單，但它裡面蘊藏著許多小細節，我花了很多時間去整理。沒想到快要跟學「點分治」的時間快要一樣久了，看來我的學習能力還挺不好，還需要多加強了 QAQ</p>
<p>不過也要感謝網路上已經有許多優秀的人放了教學文章在上面可以讓我學習與思考，要是沒有他們我應該也沒辦法順利推出來這些想法，還是習慣用紙筆去理解一次演算法，雖然很花時間，但印象深刻。<del>RAM 太少常常忘記自己迴圈是做到第幾次，然後就一直鬼打牆</del></p>
<p>不過也對自己表示一點小失望，學習能力有點偏差呀！好希望自己的頭腦可以再清楚一點，能夠可以讀懂優秀大神寫的演算法，而不是每次都要花上 5,6 個小時來理解，在撞牆期中常常會覺得自己很沒用呀。</p>
<p><strong>那怕是一點點的進步也好，都可以給在學習路上的我很大的自信。</strong></p>
<p>雖然每次在學習演算法總是會讓我覺得難過，因為是自學很容易遇到學習障礙，但我認為這是我應該要學會的基礎。我並不是幸運的孩子，我勢必要先做出一些成果，讓資源跟大神可以關注到我，在提拔我或幫助我成長。在還沒有大神們關注到我之前，我會默默耕耘，繼續努力的！</p>
<p>為了讓讀者與未來的我看到之前的我學習是怎麼學習的，我就在這邊放入我為了學習這份演算法而在紙上實作的紀錄吧！</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>其實就是沒有附上說明的程式碼，我也花了三個小時撰寫文章，看得懂跟說得出來真的是兩回事，<del>也許還有人覺得我說的很差</del>，不過我已經盡力解釋拉。希望可以幫助到各位。</p>
<p>於是這裡就補述一些題目給的資料範圍限制與標頭檔了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1000020</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> z[MAXN] = &#123;&#125; ;</span><br><span class="line"><span class="keyword">int</span> x=<span class="number">0</span> , y=<span class="number">0</span> , maxn = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">string</span> s ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; s.length() ; i++ )&#123;</span><br><span class="line">        z[i] = max(<span class="number">0</span>,min(z[i-x] , y - i + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">while</span>(i + z[i] &lt; s.length() &amp;&amp; s[z[i]] == s[i+z[i]] )&#123;</span><br><span class="line">            x = i ;</span><br><span class="line">            y = i + z[i] ;</span><br><span class="line">            z[i]++ ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; s.length() ; i++)</span><br><span class="line">        <span class="keyword">if</span>(z[i] == s.length() - i &amp;&amp; maxn &gt;= s.length()-i )&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; s.substr(<span class="number">0</span>,z[i]);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        maxn = max(maxn , z[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Just a legend"</span> ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Codeforces</category>
        <category>演算法知識</category>
      </categories>
      <tags>
        <tag>程式解題</tag>
        <tag>Codeforces Round .#666 (Div. 2)</tag>
        <tag>Z-algorithm</tag>
        <tag>字串處理</tag>
        <tag>演算法知識</tag>
      </tags>
  </entry>
  <entry>
    <title>ERROR! Your local changes to the following files would be overwritten by merge</title>
    <url>/2020/09/25/git/git-error-local-changes-to-the-following-files-would-be-overwritten/</url>
    <content><![CDATA[<h2 id="文章大意："><a href="#文章大意：" class="headerlink" title="文章大意："></a>文章大意：</h2><blockquote>
<p>如果本地已經有修改資料，但遠端也同時也有修改過這份資料，我這邊要 <code>git pull</code> 則會遇到此問題的解決方式。</p>
</blockquote>
<a id="more"></a>

<h2 id="ERROR-Your-local-changes-to-the-following-files-would-be-overwritten-by-merge"><a href="#ERROR-Your-local-changes-to-the-following-files-would-be-overwritten-by-merge" class="headerlink" title="ERROR! Your local changes to the following files would be overwritten by merge"></a>ERROR! Your local changes to the following files would be overwritten by merge</h2><p>在 <code>git pull</code> 時遇到一個 ERROR 關於上方標題所述，要怎麼解決？</p>
<h3 id="situlation-A-放棄本地修改程式碼直接將伺服器程式碼抓下來"><a href="#situlation-A-放棄本地修改程式碼直接將伺服器程式碼抓下來" class="headerlink" title="situlation A - 放棄本地修改程式碼直接將伺服器程式碼抓下來:"></a>situlation A - 放棄本地修改程式碼直接將伺服器程式碼抓下來:</h3><p>那我們則是輸入指令直接退回到伺服器的版本，之後再重新 pull。我個人猜測當我們在修改的時候就已經脫離了伺服器的版本，git 會視為我們已經修改可能還會想要 <code>git push</code>，所以才不准我們 <code>git pull</code> 吧！</p>
<p>以下是所需要用到的指令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reset --hard</span><br><span class="line">git pull origin master</span><br><span class="line"></span><br><span class="line"># 其中 origin master 是 git 的分支</span><br></pre></td></tr></table></figure>

<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://www.itread01.com/content/1545046022.html" target="_blank" rel="noopener">git pull遇到錯誤：error: Your local changes to the following files would be overwritten by merge:解決方法</a></p>
<h2 id="心得："><a href="#心得：" class="headerlink" title="心得："></a>心得：</h2><p>git 真的好好用XD，但我是自學的基礎不穩，很多東西都是需要用到才會學，基礎不穩阿，要好好多讓自己嘗試找到缺失之處，然後補足。才可以讓自己獨當一面！</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>NCPC2020 109年度全國大專電腦軟體設計初賽 - 18th 心得</title>
    <url>/2020/09/27/contest_experence/ncpc2020_preliminary/</url>
    <content><![CDATA[<blockquote>
<p>僅此紀錄 2020/09/27 109年度全國大專電腦軟體設計初賽心得。<br>「紀錄每個時刻，讓未來的自己不遺忘過去的自己」<br>只有自己才能體會自己的過去<br>僅只有 18th，約 pr 40 ~ 50</p>
</blockquote>
<a id="more"></a>

<h2 id="賽前日誌"><a href="#賽前日誌" class="headerlink" title="賽前日誌"></a>賽前日誌</h2><p>當天我去我師大朋友(蘇子權) 的家吃消夜，突然想吃金鋒滷肉飯www，又想到好朋友家就在師大旁邊就想說過去那邊臨時聊天，敘敘舊聯幫感情升溫XD，互相加油打氣。順便改下 notebook。<del>結果還走錯地址，可惡。我到底還是不是台北人阿XD</del></p>
<blockquote>
<p>比賽前再等師大好朋友時拍的照片</p>
</blockquote>
<p><img src="/images/ncpc2020_preliminary/4.jpg" alt=""></p>
<p>這場比賽，我其實心情異常平靜。我也不太懂為甚麼會這樣..，開始對比賽麻痺了嗎？我想不是，而是因為一直都沒有好的成果，對自己沒有期待了嗎？</p>
<p>是個下雨天，我騎車前往師大，昨天在 109 模擬比賽把可不可紅茶弄倒在安全帽裡，果然今天帶安全帽很有可不可紅茶的味道呢wwww，將車停在古亭站準備前往與隊友會合，不過下雨天要整理那些雨具也是蠻麻煩的，好希望台北能夠少點下雨，或是在我出門的時候都不要下雨，可以嗎，天空(◍•ᴗ•◍)❤️ 。</p>
<p>之後在路上看到爭鮮想說還沒吃午餐，<del>抱歉，太晚起來了</del>，不然就簡單買兩個壽司來吃，恩..，玉子燒還不錯吃，但真的對冰冰的飯還是沒有那麼喜歡，之後就一路前往師大的路上，不過就算是下雨天，穿著雨衣走路還是蠻會流汗的，下次可以考慮脫掉放在機車上之類的。一個經驗，學起來了。</p>
<p>最後學長(陳風平) 願意給我機會吃飯，讓我買個便當。嗚嗚，好感謝，我不應該遲到的。</p>
<blockquote>
<p>比賽大樓的出口</p>
</blockquote>
<p><img src="/images/ncpc2020_preliminary/3.jpg" alt=""></p>
<h2 id="比賽當下"><a href="#比賽當下" class="headerlink" title="比賽當下"></a>比賽當下</h2><p>考試一開始時，我們將試題卷拿出來後，發現他竟然是雙面列印(差評，它讓我的迴紋針策略無法實現 QAQ，(迴紋針策略：把每題都用迴紋針收好，以防桌面雜亂要找題目不好找)，確實之後真的很常發生找不到題目試卷或是針對那題而做的筆記，希望下此主辦單位可以單面列印。<del>不要省紙，破壞我的策略</del></p>
<p>考試過程中想要透過印表機列印卻一直印不出來，詢問了主辦單位，主辦單位當下不太能夠解決。我們原本想選擇放棄，先不處理印表機的問題，但他們後來還「主動」詢問我們能不能夠使用印表機，好感動QQ。師大的人都好溫暖，北科這點可以再好點就更好了！之後好像換了「幾台印表機」後就成功可以用了，感謝師大，讚嘆師大。</p>
<p>解題的過程中，確實有一個策略還不賴，就是在封面寫每題的「標籤」，讓大家有興趣的人去選擇解題。我選擇的是我認為最簡單的 pF，但我的英文能力不好，當時為了解決格式問題，嘗試了 15 次的測試..，對不起我就爛。他的格式部分我搞很久…，拖到隊伍解題時間，真的蠻抱歉的，我個人認為在 11 月 ICPC 演算法台灣區決賽比完後，必須增加自己的英文能力。基礎不好真的很吃虧，希望我國高中當時能夠在努力點八。</p>
<p>後來 pF 格式的問題讓我的腦袋卡關，之後漢軒幫助我去解決格式上的問題，真的超級謝謝他的！要是沒有他我那個沒有用的小腦袋一定還想不出來，果然還是需要 #include&lt;別人的知識&gt;，會比自己一個人蠻幹還要更好。</p>
<p>學長則是選擇 pC 來解，一次就解對。佩服佩服，旁邊我師大朋友那隊還在賽後問我們學長怎麼解決的www，看來學長的策略跟想法還是略勝我一籌XD，還是是我英文能力太差導致我沒辦法發揮實力(?，不過我覺得我英文能力變好一定會幫助隊伍更多。不過看別人 Debug 心真的會緊張XD，好怕她抓不到 bug，為他捏把冷汗。</p>
<h2 id="比賽結果"><a href="#比賽結果" class="headerlink" title="比賽結果"></a>比賽結果</h2><p>其實比賽結果對我來說蠻意外的，竟然只有寫兩題還可以到 18 名(此比賽並沒有加入台清交)，雖然我覺得主要是我太浪費時間不然或許可以解到 3 題？假如學長對於 pE 的想法是正確的話，雖然有點爛拉，畢竟至少有一題正解的隊伍只有 34 隊，然後我們也只有解決兩題所以名次也相對沒有那麼好看。雖然覺得自己有點小沒價值，但我認為未來一定會有需要我的地方，只要在需要我的地方我能發揮能力並成功，那就是我的福氣了。</p>
<p>期望我未來可以有更好的表現，隊伍能夠發揮得更棒。</p>
<h2 id="賽後日誌"><a href="#賽後日誌" class="headerlink" title="賽後日誌"></a>賽後日誌</h2><p>賽後稍微去逛一下師大夜市，師大夜市還是跟以往一樣賣很多衣服www，可惡，我不太會穿搭。不然師大夜市就會是我的天堂了，我可能在那邊 1、2 個小時都不會走呢。不過比完賽後異常的累，回家就先睡了 3 個小時，看來我的體力不太好呢..。</p>
<p>不過在回來的路上，突然靈機一動想到一個點子，今天我到了這個學校，希望下次是這個學校要我。於是玩了一個鬼抓人，現在我抓到師大了！希望以後師大可以抓我回他們學校演講之類的嗎(?，我應該是沒有那麼優秀拉我，哈哈哈。</p>
<blockquote>
<p>抓！師大換你當鬼</p>
</blockquote>
<p><img src="/images/ncpc2020_preliminary/1.jpg" alt=""></p>
<h2 id="賽後檢討"><a href="#賽後檢討" class="headerlink" title="賽後檢討"></a>賽後檢討</h2><p>對於我參加這次比賽，我將針對幾點進行檢討：</p>
<ul>
<li>如果英文有問題，就直接問學長或學弟。不要浪費時間自己閱讀，會造成隊伍的時間損失。</li>
<li>別人在 Debug 不要一直緊張，不要想著要怎麼抓出他的 Bug，也許她被我看他 Debug 會緊張。</li>
<li>盡量可以做好比賽當下的文書處理工作，才不會時常導致自己想要某張紙卻找不到的狀況。</li>
</ul>
<h2 id="內心"><a href="#內心" class="headerlink" title="內心"></a>內心</h2><p><strong>希望我的未來能夠變得更好，與我的夥伴朋友共同努力。</strong></p>
<p>英文一定要學好，學長耳提面命的提醒我。我不能夠忘記，現在是大學了，你不會英文就算專業再優秀也有很高機率會被面試官心中減分，我為了要達到至少不再面試官心中扣分的機會，英文一定要學好。</p>
<p>　 </p>
]]></content>
      <categories>
        <category>競賽心得</category>
      </categories>
      <tags>
        <tag>大學Life</tag>
        <tag>ICPC</tag>
        <tag>程式比賽</tag>
        <tag>競賽心得</tag>
        <tag>人生旅途</tag>
      </tags>
  </entry>
  <entry>
    <title>與大學好朋友宜蘭三星三天行</title>
    <url>/2020/09/28/life_experence/Yilan_in_2020summer/</url>
    <content><![CDATA[<h2 id="說明"><a href="#說明" class="headerlink" title="說明"></a>說明</h2><blockquote>
<p>記錄我從 2020/08/24 ~ 2020/08/26 去宜蘭的旅行紀錄<br>謝謝在程式社團中認識的好朋友<br>它們在我的暑假增添了一段美好回憶</p>
</blockquote>
<a id="more"></a>

<h2 id="懺悔"><a href="#懺悔" class="headerlink" title="懺悔.."></a>懺悔..</h2><p>由於最近的事情太忙，上班與學習相提並重讓我時在沒有心情撰寫 Blog，回到家就想睡覺…，體力越來越不好了。</p>
<p>加上其實最近我的內心其實也不太穩定..，怎麼講呢，有點太喜歡一個女生，只要是那女生傳來的文字訊息我的神經都會放大 1000 倍，也因為這樣我常常會因為她的某封訊息開心或難過。這樣其實並不太好，我應該要能夠多關心自己而不是被情緒給操控。如果可以，我想寫一篇關於他的事。</p>
<p>如果有甚麼事情我忘記寫的，希望未來的我都能夠想起來，<strong>我不願意因為年紀的增長而失去了對於過去的記憶</strong>。</p>
<h2 id="出發前的準備"><a href="#出發前的準備" class="headerlink" title="出發前的準備"></a>出發前的準備</h2><p>其實這場宜蘭行籌畫了蠻久這裡蠻感謝胡紹宇的，他願意免費提供住宿(讚嘆他的爸媽)與行程規劃，讓我在忙碌的暑假中可以放心的學習工作與事業。</p>
<h2 id="8-月-24-日，大學第一次去宜蘭三星鄉玩"><a href="#8-月-24-日，大學第一次去宜蘭三星鄉玩" class="headerlink" title="8 月 24 日，大學第一次去宜蘭三星鄉玩"></a>8 月 24 日，大學第一次去宜蘭三星鄉玩</h2><h3 id="啟程"><a href="#啟程" class="headerlink" title="啟程"></a>啟程</h3><p>當天的 12 點我出發前往南港轉運站，原本是想要當捷運去的，但後來想想覺得捷運可能比火車還更浪費些時間。於是就想搭火車去南港火車站再轉車，確認好想法後我就從家中一路出發到萬華火車站，很不幸的是我找不到車位…，於是我把車停在離火車站稍遠的距離，特意拍了一張照片再去搭火車，以免我忘記我把我的機車放哪裡，把我的機車搞丟wwww。</p>
<blockquote>
<p>要去宜蘭前國小被朋友看到的我</p>
</blockquote>
<p><img src="/images/Yilan_in_2020summer/1.png" alt=""></p>
<p>到了南港火車站後，我前往南港轉運站。老實講蠻近的，但我覺得他的道路規劃路線沒有很好啊..，迷路了一陣子，甚至還走到了被封閉的出口..，如果因為新冠肺炎的關係而把路口封閉的話，至少也要在路標上面說路口被封閉呀！</p>
<blockquote>
<p>在南港轉運站等待時的照片</p>
</blockquote>
<p><img src="/images/Yilan_in_2020summer/2.jpg" alt=""></p>
<p>上了公車，朋友們跟我說從台北到宜蘭只需要約 1 小時的行程，一開始真的還挺不相信的，但經歷過後才知道原來台北到宜蘭真的這麼快！<del>怪不得被別人稱台北後花園</del>，但我在前往宜蘭的路上我卻還在忙工作的案子，工作的資料沒有用完阿阿阿阿，根本不敢放心玩，就在車上忙碌地進行我的工作，而朋友們大多都在睡覺或玩手機，讓我覺得自己好像社畜阿QwQ，不過工作能讓我學到東西，就不太會讓我對工作感到反感，也謝謝這份工作可以讓我學習到很多知識。</p>
<p>中午去了一趟寶雅買泳衣，這是我人生第一次去寶雅，寶雅有點類似於大潤發的感覺，不過主打女性市場，它讓我覺得一定會有很多小女生會在這裡逛至少兩、三個小時的錯覺阿，我在挑泳衣時一直被嫌棄胖QQQ，我很抱歉我說我要減肥到現在都還是沒有瘦下來，一定是我太幸福了才會一直都沒有瘦下來呢(內心:並沒有大衞，你每天晚上都在哭自己不好)</p>
<blockquote>
<p>在寶雅戴上奇怪帽子的我</p>
</blockquote>
<p><img src="/images/Yilan_in_2020summer/4.png" alt=""></p>
<p>到了宜蘭後去租了一輛機車(GP125)，還是沒想到租一輛機車非常便宜阿！很不賴呢，一台機車兩天只要 700 元，讓我對宜蘭的好感度大增(◍•ᴗ•◍)❤️，車況也還蠻不賴，基本上都沒什麼大問題，只是我對於股煞還是不太能諒解www，我已經習慣碟煞的感覺臨時操控股煞的車還真不習慣呢！對了，安全帽是西瓜皮ಥ⌣ಥ，不太行阿，當我騎車將近約 60km/h 時我只能聽得到風聲了，這點到可以再改進，可以的話給大家 3/4 安全帽可能會讓大家的頭部比較有安全感XD。</p>
<h3 id="夜晚"><a href="#夜晚" class="headerlink" title="夜晚"></a>夜晚</h3><p>晚餐我們去羅東夜市覓食，羅東夜市其實蠻多蠻好吃的。可惜胃只有一個不然好像都吃遍，大推羅東夜市門口前的花生捲冰淇淋，真的好好吃，<del>說不定只是我愛吃</del>。路上也蠻多好看的女生，好想認識(誤，要是這篇給我未來的女朋友看到應該會被討厭死吧XD，夜晚的羅東夜市人越多也越擁擠，其實不一定只有台北才會熱熱鬧鬧，很多地方也會。也算是讓我開開眼界吧！</p>
<p>把肚子填飽以後一行人就慢慢騎車前往了三星，不得不說朋友的民宿真的很棒呢，聽說內部裝潢都是他媽媽一手包辦，女…女中豪傑呀！由於那房間是 4 人房，我們一行人有 5 人，必須要有一人去睡沙發，在經過一翻廝殺(剪刀石頭布)後，我竟然是最輸的只能睡沙發ಥ⌣ಥ，好難過…。</p>
<blockquote>
<p>民宿內部裝潢在一二樓的樓梯轉角處</p>
</blockquote>
<p><img src="/images/Yilan_in_2020summer/2.jpg" alt=""></p>
<blockquote>
<p>可愛的貓貓湯匙</p>
</blockquote>
<p><img src="/images/Yilan_in_2020summer/5.jpg" alt=""></p>
<p>隨後進行洗澡環節，洗澡真的好舒服，我最喜歡洗澡了XD。朋友們出去買點消夜，另一朋友(張洸銘)則在房間裡面打LOL，喂不行啊，都來民宿了還來打LOL，太浪費了拉，就算你是宜蘭人也不能這樣子啦。隨後大家則在民宿裏面看 netflex，我也跟女生稍微打了通電話聯絡聯絡感情，配上宜蘭三星夜晚的民宿，真能夠使人放鬆。</p>
<blockquote>
<p>夜晚的民宿夜景</p>
</blockquote>
<p><img src="/images/Yilan_in_2020summer/6.jpg" alt=""></p>
<h2 id="8-月-25-日令人快樂的三星"><a href="#8-月-25-日令人快樂的三星" class="headerlink" title="8 月 25 日令人快樂的三星"></a>8 月 25 日令人快樂的三星</h2><h3 id="三星的早上讓人心曠神怡"><a href="#三星的早上讓人心曠神怡" class="headerlink" title="三星的早上讓人心曠神怡"></a>三星的早上讓人心曠神怡</h3><p>本前天晚上我想要去看日出的，但沒想到我卻睡過頭，天阿。太浪費了吧大衛，要去睡覺就回去台北睡阿(捏自己的臉頰，之後與紹宇騎著機車在三星的河邊跑動，三星的河邊很美，比起台北多了輕鬆慢活的步調，少了都市壅擠特意使河邊綠意盎然的感覺，可以感覺得出來那種幸福的美，在河邊稍微戲水，去了趟三星市場買個傳統甜點(草仔粿)，老闆人也很熱情挺不賴的。路上也看到專門給情侶掛愛情鎖的地方，我也好想掛的愛情鎖阿…。</p>
<h3 id="泛舟之旅"><a href="#泛舟之旅" class="headerlink" title="泛舟之旅"></a>泛舟之旅</h3><p>接近中午時紹宇叫大家起床準備前往泛舟，泛舟要先穿他們的救生衣與鞋子和安全帽，鞋子要避免大家被底下的石頭刮傷，一開始先給我們一些簡單的救生呼籲。似乎今天有一高中生們班游他們看起來好漂亮啊..，我明明才畢業一年為甚麼就覺得我自己老的跟甚麼一樣…，應該是自己的高中沒有像他們一樣青春吧XD，明明讀台北的高中卻沒有像苗栗的高中一樣青春阿，有點小可惜呢！</p>
<p>教練也蠻有趣的，不愧是有在運動的人，我都認為擅長運動的人看起來比較陽光也比較幽默，也許是我的錯覺吧，但我真的有這種感覺。可惜我好像沒辦法是這種人呢。我可能還是比較適合在這邊打打文章學些科技來讓自己混一口飯被社會滋潤再回去給社會付出的人。</p>
<p>聽完救生須知後，我們一行人搭著遊覽車前往高處，也是泛舟的起點，它讓我們走在河邊，老實講走在河邊真的挺舒服的，因為我喜歡水，只要能夠與水親近我都不會討厭，下雨的除外，水量太少。隨後我們走到了泛舟起點跳下水中享受被水推動的感覺好舒服呀，被水推動可以讓我的內心完全放鬆享受在自然生活之中即使明知道這些都是靠著工人們辛辛苦苦堆建而成我也能夠放鬆，我可能內心還有點不夠體貼別人呢XD。</p>
<p>隨著水推動也即將到了中繼點，要準備搭船泛舟了，我們與一小家庭一同泛舟，由於我最重被大家要求移到最前面QAQ，不要逼我喔，再這樣下去我真的會減肥喔..。泛舟的過程都配上一教練，那教練負責移動橡皮的方向，<del>負責去撞其他橡皮艇</del>，一路上我們「被」跌跌撞撞蠻刺激的，晃來晃去比起搭船的海浪又更刺激了些，加上可以拿船槳去潑別人蠻好玩的！雖然我一開始不太敢潑水，但隨著被別人潑後就慢慢地放開了！雖然之後被收走了QAQ。</p>
<blockquote>
<p>在中繼點拍照時的我們</p>
</blockquote>
<p><img src="/images/Yilan_in_2020summer/7.jpg" alt=""></p>
<p>因為當天的水量太少，到了下流時泛舟其實就很平穩沒有甚麼激烈的搖晃，甚至還卡在石頭上，嗚嗚，對於宜蘭三星來說，如果下的雨太少真的會讓很多人的工作不好做也容易失業阿..，之後到了第三個中繼點可以讓我們選擇要不要讓橡皮艇翻船，我一定是選擇要的啊！但其實跟我們同行的小家庭似乎沒有那麼想要，但在我的內心渴望下他們還是答應了XD，對不起啦。</p>
<p>翻船時教練告訴我們很多規則，也告訴我們突發狀況時我們應該要怎麼辦，好讓我們在遇到危險時，給予我們安全感，讓我們怎麼應對。他讓重的人都做一邊後就直接翻船了！我似乎有撞到一個人，頭有點小暈眩，然後我還被關在橡皮艇裏面QAQ，剛好翻船的時候，可能因為我太重所以水的衝擊力沒辦法把我衝遠，剛好橡皮艇翻船的距離足夠讓我在被翻船的裏面，我就被橡皮艇壓著根本出不來，我當時害怕極了ಥ⌣ಥ，一直想要站穩但卻一直被橡皮艇衝撞頭都快要暈眩了QQ，之後聽到教練說一聲可以起來了，讓我求生意志大增，直接把頭往水裏面縮，讓橡皮艇流過我，大衛智慧+1，開心！雖然起來的時候有點狼狽…。</p>
<blockquote>
<p>翻船前的遺照</p>
</blockquote>
<p><img src="/images/Yilan_in_2020summer/8.jpg" alt=""></p>
<p>但小家庭的爸爸可就沒有那麼幸運了，他似乎在翻船時被我撞到後因為是老人家，骨頭不太好，鼻子流了點鼻血，他的老婆似乎有些許緊張，幸好在包紮後有讓他的鼻子變好。不過當下我並不覺得是我撞到他，因為我沒有那個感覺，但後來根據邏輯與常理看看應該有百分之80% 是我撞到他，當時沒有跟他道歉還蠻感到抱歉的，希望下次可以有機會跟他道歉，請他吃點東西能夠當作補償那是再幸運不過的事了。</p>
<blockquote>
<p>翻船後 QwQ</p>
</blockquote>
<p><img src="/images/Yilan_in_2020summer/9.jpg" alt=""></p>
<p>翻船後上岸，跟著另外一個很幽默的教練走，那教練講話真的蠻好笑的，它讓我印象最深刻的話就是：「你踩石頭會痛，那你有想過石頭的感受嗎」，我覺得我講起來就沒有那麼好笑，我想應該是他的個人魅力使這句話好笑吧XD，抑或是那個當下講出這句話才讓人有開心的感覺吧，之後我們滑行約 100 公尺的滑水道，好好玩，還有一堆教練跟你擊掌XD，他讓我覺得泛舟的教練應該當下也是開心的吧！並不會覺得自己所做的只是「工作」。</p>
<p>由於水流不夠，我們沒辦法泛舟泛到終點，中途就必須給大卡車接送，被大卡車接送的感覺其實很不賴，涼涼的風吹過來，又有漂亮的風景可以觀看，讓我覺得活在宜蘭的孩子或許比台北在更幸福些。</p>
<p>回到終點後我們沖洗下身體，沖洗的時候有某些是只有冷水要特別小心！如果是冬天的話真的會冷死你喔..，不過也有可能冬天沖洗的水就會都是熱水了也說不定呢！在吃了我覺得超好吃的冰棒「蘭陽冰棒」，他應該是我覺得最美味的食物之一了吧，它讓我做好決定我一定還要買更多蘭陽冰棒來吃，超級大推。</p>
<h3 id="在三星的晚餐"><a href="#在三星的晚餐" class="headerlink" title="在三星的晚餐"></a>在三星的晚餐</h3><p>在三星時，我發現到他們的飲料全部都比北部的飲料少了「5元」！這讓我超級訝異也超級開心，這..這只能夠在 2年前的台北看到阿，好感動。我還不直接買爆XD，後來去了一間餐館吃飯，這是紹宇他很推薦的一家果真也沒有讓我失望，真的超級好吃。菜色我忘記了蠻多XD，對不起啦，時間過太久了菜名真的都忘了..，但他們的「阿嬤炒飯」可以嘗試，真的好吃，份量又多比起台北這邊貴貴的價格配上難民的份量，在宜蘭吃飯才真的有皇帝的感覺呢！</p>
<p>隨後買了些消夜，就準備打道回民宿，回民宿我向大家提議是不是該換床位了XD，這次大家願意包容我能夠讓我睡到高級床位真的好感動QQQ，我忘不了大家的，也對不起天佑，換你睡上了沙發..。當大家都洗澡完成後我們開始玩桌游，阿瓦隆好久沒有玩但還是沒什麼忘記呢，只是我原本想要把壞人的身分嫁禍給紹宇沒有嫁禍成功真的很可惜呢wwww，剛好因為她身分的特性而被識破。</p>
<p>晚點去了民宿的後院，後院很美、風景很漂亮。美到即使現在我還是沒辦法忘掉那景色，配上兩個鞦韆，真的很讚，佩服他爸媽的眼光，能夠選在此地蓋民宿，真的很不賴呢。</p>
<p>今晚，睡了一個好覺，很深很甜的美夢。</p>
<blockquote>
<p>當鞦韆的兩位朋友XD，共兩張</p>
</blockquote>
<p><img src="/images/Yilan_in_2020summer/15.jpg" alt=""><br><img src="/images/Yilan_in_2020summer/16.jpg" alt=""></p>
<blockquote>
<p>傍晚的民宿照片，太陽還在外面</p>
</blockquote>
<p><img src="/images/Yilan_in_2020summer/10.jpg" alt=""></p>
<blockquote>
<p>太陽剛下去的民宿照片</p>
</blockquote>
<p><img src="/images/Yilan_in_2020summer/11.jpg" alt=""></p>
<h2 id="8-月-26-日捨不得回去的宜蘭三星"><a href="#8-月-26-日捨不得回去的宜蘭三星" class="headerlink" title="8 月 26 日捨不得回去的宜蘭三星"></a>8 月 26 日捨不得回去的宜蘭三星</h2><p>由於昨天大家都累壞了一天，大家都睡到大約中午 12 點加上當天的天氣其實不太好一直有綿綿雨，不過我們其實蠻幸運的，幸好不是昨天下雨不然會讓我們的泛舟之旅增添一些陰影，由於我吵著要去吃蘭陽冰棒，於是我就特地騎車去探險，去蘭陽冰棒店買冰棒，我自己就吃了 6 隻，對不起過去的大衛，但是我真的需要那個很 cool 的東西..體重就先放一邊去吧XD，特別喜歡牛奶與米糕的味道，牛奶冰棒中牛奶的香氣配上葡萄乾，香氣與嚼勁都在而不容易使人吃膩，米糕冰棒中有許多米糕，<del>廢話</del>，嚼勁比起牛奶而更大推！重點價錢也很便宜，一隻才 15 元，它讓我越來越覺得我在台北的生活就是難民的感覺www，高物價少分量ಥ⌣ಥ。</p>
<blockquote>
<p>超級棒的蘭陽冰棒</p>
</blockquote>
<p><img src="/images/Yilan_in_2020summer/12.jpg" alt=""></p>
<p>下午則在民宿玩了些桌游，挺不賴的。而我則是吵著要去清水地熱谷探險XD，結果去的路上沒有去成(可惡，他們 5 點 30 就關門了，於是我就在附近繞一繞看看宜蘭的美景，其實宜蘭真的很漂亮不愧會被大家說是台北後花園，雖然很壞wwww。</p>
<blockquote>
<p>在騎車時隨手拍的照片，共兩張</p>
</blockquote>
<p><img src="/images/Yilan_in_2020summer/13.jpg" alt=""><br><img src="/images/Yilan_in_2020summer/14.jpg" alt=""></p>
<p>大約 7 點多，我們一行人陸續從民宿中出發到羅東車站的路上，騎車騎了蠻長一段距離，我都有點疲乏了，明明去三星的路上都沒有那麼累呀…。路上還遇到三寶！差點撞到我(哭，超級難過的，宜蘭的交通看起來還是跟台北差不多呢…，尤其我頭上戴西瓜皮，危機特別嚴重，廢話，西瓜皮安全帽被撞真的會死人欸，不適用交通規則都是生存規則。但一路上也是蠻克難的，兩台車塞四個行李www，還有一個笨蛋塞行李箱，抱歉拉就是我，哈哈哈。</p>
<p>搭上公車之後，稍微跟天佑聊了一下還蠻開心的，講講北科壞話XD，對不起啦北科，但我偶爾還是需要小抱怨一下，當客運抵達南港轉運站時卻沒有停下直接開走！我們一行人都驚訝，想說司機是不是忘記了QAQ，一群人都超緊張的！查了下原因才知道火車與客運不同，客運如果沒有按下車鈴的話他是會直接通過而不會留下，知道原因後的我們查這班客運的終點站是捷運圓山站，我們就乖乖坐著公車到捷運圓山站再從捷運圓山站搭捷運回家，但是因為捷運龍山寺站跟萬華火車站不在同個地方..，我走了大約快 15 分鐘才回到了停機車的地方，超累的QQ，拖著行李走路的累度比起一般走路還累 10 倍呀，幸好一路上有女生陪我加油打氣不然我可能真的會累倒在路上吧，之後也順利找到機車開開心心的回家了。</p>
<blockquote>
<p>台北俗，完全不知道有這種規則的我XD</p>
</blockquote>
<p><img src="/images/Yilan_in_2020summer/17.jpg" alt=""></p>
<blockquote>
<p>過站到已經可以看的到圓山大飯店了www</p>
</blockquote>
<p><img src="/images/Yilan_in_2020summer/18.jpg" alt=""></p>
<blockquote>
<p>順利看到車車的我，開心&gt;&lt;&gt;</p>
</blockquote>
<p><img src="/images/Yilan_in_2020summer/19.jpg" alt=""></p>
<h2 id="後來的我"><a href="#後來的我" class="headerlink" title="後來的我"></a>後來的我</h2><p>由於有了這份旅遊，它讓我的精神狀況比起過往好了許多，做事甚麼的也都很有效率！還蠻感謝紹宇願意帶我參加這份旅遊。回憶很美，但如果能夠透過文字紀錄讓未來的我在看到時能感到開心，就代表現在的我並沒有白活了！</p>
<p><strong>一路上經歷過的事情一變多，就常常會把許多回憶丟在路邊繼續往前走，當我走到這條路的終點時卻忘記自己到底過不過得開心快不快樂，自己活得這麼累的原因是甚麼。</strong></p>
]]></content>
      <categories>
        <category>人生旅途</category>
      </categories>
      <tags>
        <tag>大學Life</tag>
        <tag>人生旅途</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa11475 - Extend to Palindrome (KMP algorithm 詳解)</title>
    <url>/2020/10/03/UVa/UVa11475/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p><strong>給你一字串，請新增字元讓這字串變成迴文，但新增字元數量要最少。</strong><br>迴文：從左邊讀與從右邊讀意思都一樣<br>題目善意提示：這題不要給經驗不足的新手做 ^^</p>
</blockquote>
<a id="more"></a>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>這題是 KMP (Knuth-Morris-Pratt’s) Algorithm 的小變化題，先介紹 KMP algorithm。</p>
<blockquote>
<p>專門解決在線性時間中在一段文字 (text) 中找到我們所需要的段落 (pattern)<br>與此類似的演算法: <a href="https://theriseofdavid.github.io/2020/09/18/Codeforces/Codeforces%20126B/" target="_blank" rel="noopener">Z-algorithm</a><br>由於此題是 KMP algorithm 的模板題，只要能夠了解 KMP algorithm 就能解決此問題。<br>這題為教學題，但此問題還有一點點的小設計，需要稍加解釋才能完全理解。</p>
</blockquote>
<h2 id="KMP-algorithm-介紹"><a href="#KMP-algorithm-介紹" class="headerlink" title="KMP algorithm 介紹"></a>KMP algorithm 介紹</h2><blockquote>
<p>在線性時間內找出段落(Pattern) 在文字(text) 中哪裡出現過。<br>對 Pattern 找出<strong>次長相同前綴後綴</strong>，在使用 DP 將時間複雜度壓縮</p>
</blockquote>
<h3 id="QUESTION-1-Pattern-and-text-是甚麼意思"><a href="#QUESTION-1-Pattern-and-text-是甚麼意思" class="headerlink" title="QUESTION 1: Pattern and text 是甚麼意思"></a>QUESTION 1: Pattern and text 是甚麼意思</h3><p>如果用平常使用者較為了解的方式說明，就像是你在網頁搜尋(使用 <strong>ctrl + F</strong>) 某個特定文字時，某個特地文字就是 Pattern 而被搜尋的文字則是 text。</p>
<h3 id="QUESTION-2-此演算法的時間複雜度"><a href="#QUESTION-2-此演算法的時間複雜度" class="headerlink" title="QUESTION 2: 此演算法的時間複雜度"></a>QUESTION 2: 此演算法的時間複雜度</h3><p>複雜度 \(O(\text{text} + \text{pattern})\)</p>
<h2 id="KMP-algorithm-原理"><a href="#KMP-algorithm-原理" class="headerlink" title="KMP algorithm 原理"></a>KMP algorithm 原理</h2><p>在實現 KMP algorithm 前，必須要先對 Pattern 找出<strong>次長相同前綴</strong>，通常被稱為 KMP_process()，並透過一陣列紀錄，再根據文字去比對，如果在迴圈當下字元比對不正確時則回到 DP 當下 index 的 Value 去比對，確認現在的值是否為也是 Pattern 中的某部分。</p>
<h2 id="KMP-algorithm-實現與說明"><a href="#KMP-algorithm-實現與說明" class="headerlink" title="KMP algorithm 實現與說明"></a>KMP algorithm 實現與說明</h2><p>由於我認為在程式碼中加上好懂得註解十分好懂，所以我就根據每一行程式碼進行說明，相信會讓讀者更好學會此演算法。<br>如果對下方說明還是不了解，可以點擊此<a href="https://www.youtube.com/watch?v=V5-7GzOfADQ&ab_channel=AbdulBari" target="_blank" rel="noopener">Abdul Bari 所教導的 KMP algorithm </a>觀看影片，他會跟你說嗨喔！也許能夠讓你更了解 KMP algorithm 運作，<del>或許是我解釋不好</del>。</p>
<p>KMP 演算法主要由 kmp_process 與 kmp_search 這兩個 function 而成，讀者只要能看懂此兩 function 應該就能夠學會 KMP 的 80%。</p>
<h3 id="kmp-process"><a href="#kmp-process" class="headerlink" title="kmp_process"></a>kmp_process</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span>  strB ;</span><br><span class="line"><span class="keyword">int</span> b[MAXN] ;</span><br><span class="line"><span class="comment">// b[] value 表示 strB當下此字元上次前綴的 index，如果已經沒有前綴則設定 -1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kmp_process</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = strB.length() ,i = <span class="number">0</span> ,  j = <span class="number">-1</span> ;</span><br><span class="line">    <span class="comment">// j = 前綴的長度</span></span><br><span class="line">    <span class="comment">//strB 是 pattern , j = -1 時代表沒有辦法再回推到前一個次長相同前綴</span></span><br><span class="line">    b[<span class="number">0</span>] = <span class="number">-1</span> ;</span><br><span class="line">    <span class="comment">// 由於 strB[0] 絕對沒有前綴所以設定 -1 </span></span><br><span class="line">    <span class="keyword">while</span>(i &lt; n )&#123; <span class="comment">//對從 Pattern 的第 0 個字元到第 i 字元找出次長相同前綴</span></span><br><span class="line">        <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; strB[i] != strB[j]) j = b[j] ;</span><br><span class="line">        <span class="comment">// j &gt;= 0 代表還可以有機會找出 次長相同前綴</span></span><br><span class="line">        <span class="comment">// strB[i] != strB[j] 則代表他們字元不同，於是在這裡把 j 值設為 b[j]</span></span><br><span class="line">        <span class="comment">// 當 j 只要被設定成 -1 就代表完全沒有次長相同前綴</span></span><br><span class="line">        i++ ; j++ ;</span><br><span class="line">        b[i] = j ;</span><br><span class="line">        <span class="comment">// strB[i] 上次前綴的 index 值或是將 j 設定成 0 而不設定成 -1 是因為</span></span><br><span class="line">        <span class="comment">// 他有可能會是 strB[0] 長度只有 1 的前綴</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//debug 供應測試用</span></span><br><span class="line">    <span class="comment">//    for(int k = 0 ; k &lt;= n ; k++)</span></span><br><span class="line">    <span class="comment">//        cout &lt;&lt; b[k] &lt;&lt; ' ' ;</span></span><br><span class="line">    <span class="comment">//    cout &lt;&lt; '\n' ;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>這樣 kmp_process 就完成了！</p>
<h3 id="kmp"><a href="#kmp" class="headerlink" title="kmp"></a>kmp</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> strA ;</span><br><span class="line"><span class="comment">//strA 是 text</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kmp_search</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = strA.length() , m=strB.length() , i=<span class="number">0</span> , j=<span class="number">0</span>  ;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; n )&#123; <span class="comment">//對從 text 找出搜尋哪裡符合 Pattern </span></span><br><span class="line">        <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; strA[i] != strB[j]) j = b[j] ;</span><br><span class="line">        <span class="comment">// j &gt;= 0  代表還可以有機會是 pattern 的前綴</span></span><br><span class="line">        <span class="comment">// strA[i] != strB[j]  則代表他們字元不同，於是在這裡把 j 改為 b[j]</span></span><br><span class="line">        <span class="comment">// b[j] 說明請看 kmp_process 宣告 b[j] 時的解釋</span></span><br><span class="line">        i++ ; j++ ;</span><br><span class="line">        <span class="keyword">if</span> (j == m) &#123; <span class="comment">// j 已經跟 pattern 的長度相同了</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"P is found at index %d in T\n"</span>, i - j); </span><br><span class="line">            <span class="comment">// 告訴使用者在哪裡找出</span></span><br><span class="line">            j = b[j];</span><br><span class="line">            <span class="comment">// 將 j 設定成此字元上次前綴的 index</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="用紙筆去模擬-KMP"><a href="#用紙筆去模擬-KMP" class="headerlink" title="用紙筆去模擬 KMP"></a>用紙筆去模擬 KMP</h3><p>有時候用想或用看的可能不太能夠懂這演算法，那就用寫的吧！這裡有兩題，可以幫助你更好搞懂 KMP，如果你願意用紙筆去模擬。 </p>
<blockquote>
<p><strong>EXERCISE 2 Run kmp_preprocess() on P = ‘ABABA’ and show the b array !</strong><br><strong>EXERCISE 2 Run kmp_search() with P = ‘ABABA’ and T = ‘ACABAABABDABABA’. Explain how the KMP search looks like?</strong></p>
</blockquote>
<p>大衛我自己解這兩題練習的紀錄，不過後來因為有為了要讓自己在更釐清觀念而稍微改一下練習，所以不要認為我的是標準答案，可能只有近似於答案<br><img src="/images/UVa11475/1.jpg" alt=""></p>
<h2 id="焦點回到題目上，解開題目的小設計"><a href="#焦點回到題目上，解開題目的小設計" class="headerlink" title="焦點回到題目上，解開題目的小設計"></a>焦點回到題目上，解開題目的小設計</h2><p>題目是詢問迴文，那跟 KMP algorithm 有甚麼關係呢？這就是為甚麼題目有給一個善意題型的關係了，由於大部分讀者都會誤判這題為水題，所以才給這個提示以免花太多時間把程式碼寫的雜亂又不會 AC。如果將題目給的字串顛倒做為 pattern 則 KMP 最後的 j 就會是原本的字串已經有的迴文長度，我們只需要補足就好了！</p>
<p>是不是沒有一個舉例，會讓人很不好懂呢？那我們就來舉例吧！</p>
<h3 id="SITUATION-題目字串-xyz"><a href="#SITUATION-題目字串-xyz" class="headerlink" title="SITUATION : 題目字串 xyz :"></a>SITUATION : 題目字串 xyz :</h3><blockquote>
<p>正常字串 : xyz<br>顛倒字串 : zyx</p>
</blockquote>
<p>他們經過 KMP algorithm 後最後的 j 會是多少？答案是 1，所以我們只要將顛倒字元從 1 開始輸出顛倒字元就會是迴文了！(這裡字串的 index 一開始設定為 0，配合 C++)</p>
<blockquote>
<p>正確答案: xyzyx</p>
</blockquote>
<h2 id="參考連結："><a href="#參考連結：" class="headerlink" title="參考連結："></a>參考連結：</h2><p>Competitive Programming 3　(book)<br><a href="https://medium.com/nlp-tsupei/kmp%E7%AE%97%E6%B3%95%E8%A9%B3%E8%A7%A3-1b1050a45850" target="_blank" rel="noopener">KMP算法詳解</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>其實我在學習 KMP 的時候覺得我已經學會 Z-algorithm 拉，幹嘛還要在學其他的？但是我發現到如果只有學會其中一種演算法會使自己的思維能力受限，就像是井底之蛙一樣。那樣不好，所以我再花時間學習 KMP，KMP 我學習的時間也沒有很長大約花了 3 小時的時間，我想應該是<strong>風平</strong>學長介紹的書很好用的關係吧！讓我在學習此演算法時不需要自學，有一本書引導我可以讓我學習的更快！</p>
<p><strong>謝謝風平學長</strong></p>
<p>學習演算法的過程中通常都是無聊的，令人想睡的。大部分的人都認為學習演算法不如去學習網頁，因為學習網頁可以很快地得到回饋，不想演算法只能夠得到題目的「AC」罷了。但我不這麼認為，學習演算法可以讓自己獲得很多思維的想法，他們都可以應用在生活上，我不後悔學習演算法，不如說，我很高興可以學到演算法，可以讓自己在面對很多問題時之前過去的自己在學習演算法而擴展的思維可以幫助到自己，擁有比別人更傑出的想法。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>其實就是沒有附上說明的程式碼，我也花了兩個小時撰寫文章，看得懂跟說得出來真的是兩回事，也許還有人覺得我說的很差，不過我已經盡力解釋。希望可以幫助到各位。</p>
<p>也希望大家想要學習的知識都可以快速學習而成，不要因為自身的環境不足而學習不到。</p>
<p>於是這裡就補述一些題目給的資料範圍限制與標頭檔了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100020</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">string</span> strA , strB ;</span><br><span class="line"><span class="keyword">int</span> b[MAXN] , p[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kmp_process</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = strB.length() ,i = <span class="number">0</span> ,  j = <span class="number">-1</span> ;</span><br><span class="line">    b[<span class="number">0</span>] = <span class="number">-1</span> ;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; n )&#123;</span><br><span class="line">        <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; strB[i] != strB[j]) j = b[j] ;</span><br><span class="line">        i++ ; j++ ;</span><br><span class="line">        b[i] = j ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//debug</span></span><br><span class="line"><span class="comment">//    for(int k = 0 ; k &lt;= n ; k++)</span></span><br><span class="line"><span class="comment">//        cout &lt;&lt; b[k] &lt;&lt; ' ' ;</span></span><br><span class="line"><span class="comment">//    cout &lt;&lt; '\n' ;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kmp</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = strA.length() , m=strB.length() , i=<span class="number">0</span> , j=<span class="number">0</span>  ;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; n )&#123;</span><br><span class="line">        <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; strA[i] != strB[j]) j = b[j] ;</span><br><span class="line">        i++ ; j++ ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> j ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; strA)&#123;</span><br><span class="line">        strB = strA;</span><br><span class="line">        reverse(strB.begin() , strB.end());</span><br><span class="line">        kmp_process();</span><br><span class="line">        <span class="keyword">int</span> n = kmp() ;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; strA &lt;&lt; strB.substr(n) &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>UVa</category>
        <category>演算法知識</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>字串處理</tag>
        <tag>KMP Algorithm</tag>
        <tag>演算法知識</tag>
      </tags>
  </entry>
  <entry>
    <title>QUESTION! C++11 有沒有語法可以讓字串直接顛倒呢？</title>
    <url>/2020/10/03/C++/C++11_reverse/</url>
    <content><![CDATA[<h2 id="內容說明"><a href="#內容說明" class="headerlink" title="內容說明"></a>內容說明</h2><blockquote>
<p>說明我在寫 <a href="https://theriseofdavid.github.io/2020/10/03/UVa/UVa11475/" target="_blank" rel="noopener">UVa11475</a> 時想要透過語法怎麼讓字串顛倒</p>
</blockquote>
<a id="more"></a>

<h2 id="QUESTION-C-11-有沒有語法可以讓字串直接顛倒呢？"><a href="#QUESTION-C-11-有沒有語法可以讓字串直接顛倒呢？" class="headerlink" title="QUESTION! C++11 有沒有語法可以讓字串直接顛倒呢？"></a>QUESTION! C++11 有沒有語法可以讓字串直接顛倒呢？</h2><p>使用 <code>reverse</code> 即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::reverse(<span class="built_in">string</span>.begin() , <span class="built_in">string</span>.end());</span><br><span class="line"><span class="comment">// 不能這樣寫 string = std::reverse(string.begin() , string.end());</span></span><br><span class="line"><span class="comment">// 他本身就會改變了，不需要在前面放 string 多此一舉</span></span><br></pre></td></tr></table></figure>

<p>這樣就不需要自己手寫一個 for 輸出，太感動了 C++11，有這麼方便的函式，嗚嗚。</p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://shengyu7697.github.io/blog/2020/08/05/Cpp-string-reverse/" target="_blank" rel="noopener">C/C++ 字串反轉 reverse</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>有時候語言寫多常常會讓自己搞混很多語法，透過自己的 blog 紀錄這樣真的會讓自己學比較快阿！</p>
]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>Cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa526 - String Distance and Transform Process (Minimum Edit Distance 詳解)</title>
    <url>/2020/10/04/UVa/UVa526/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>給你兩個字串分別是 A,B 你可以用插入、刪除、替換，來將 A 字串轉換成為 B 字串，輸出需要幾次的轉換，也要將步驟輸出。</p>
<p>這題很毒瘤，A,B 都必須用 <code>getline</code> 實作，字串可以包括空白</p>
</blockquote>
<a id="more"></a>

<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><blockquote>
<p>這題為教學題，但此問題還有一點點的小設計，需要稍加解釋才能完全理解。<br>這題要用到<strong>最短修改距離 Minimum Edit Distance</strong>，這是一個動態規劃，遞迴式如下。</p>
</blockquote>
<p><img src="/images/UVa526/1.svg" alt=""></p>
<h2 id="Minimum-Edit-Distance-介紹"><a href="#Minimum-Edit-Distance-介紹" class="headerlink" title="Minimum Edit Distance 介紹"></a>Minimum Edit Distance 介紹</h2><blockquote>
<p>可以透過刪除、插入、替換字元來達到將 A 字串轉換到 B 字串，並且是最少編輯次數。<br>此演算法的時間複雜度 \(O(n^2)\)</p>
</blockquote>
<h2 id="最短修改距離-Minimum-Edit-Distance-應用"><a href="#最短修改距離-Minimum-Edit-Distance-應用" class="headerlink" title="最短修改距離 Minimum Edit Distance 應用"></a>最短修改距離 Minimum Edit Distance 應用</h2><ul>
<li>DNA 分析</li>
<li>拼寫檢查</li>
<li>語音辨識</li>
<li>抄襲偵測</li>
</ul>
<h2 id="MED-實現與說明"><a href="#MED-實現與說明" class="headerlink" title="MED 實現與說明"></a>MED 實現與說明</h2><p>由於 MED 此演算法是動態規劃原理的部分我個人認為沒有很難，因此沒有說明原理。<del>其實是作者很早以前就會了所以不想花時間寫XD</del></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> dis[MAXN][MAXN]; </span><br><span class="line"><span class="comment">//dis[A][B] 指在 strA 長度 0 to A 與 strB 長度 0 to B 的最短修改距離為多少</span></span><br><span class="line"><span class="comment">//這裡假設由 A 轉換 B</span></span><br><span class="line"><span class="built_in">string</span> strA , strB ;</span><br><span class="line"><span class="keyword">int</span> n , m ;</span><br><span class="line">n=strA.length() ;</span><br><span class="line">m=strB.length() ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">med</span><span class="params">()</span></span>&#123; <span class="comment">//Minimum Edit Distance</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= n ; i++) dis[i][<span class="number">0</span>] = i ;</span><br><span class="line">    <span class="comment">// 由於 B 是 0 ，所以 A 轉換成 B 時每個字元都要被進行刪除的動作</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt;= m ; j++) dis[<span class="number">0</span>][j] = j ;</span><br><span class="line">    <span class="comment">// 由於 A 是 0 ，所以 A 轉換成 B 時每個字元都需要進行插入的動作</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; i++)&#123; <span class="comment">// 對 strA 每個字元掃描</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= m ; j++)&#123; <span class="comment">// 對 strB 每個字元進行掃描</span></span><br><span class="line">            <span class="keyword">if</span>(strA[i<span class="number">-1</span>] == strB[j<span class="number">-1</span>]) dis[i][j] = dis[i<span class="number">-1</span>][j<span class="number">-1</span>] ;</span><br><span class="line">            <span class="comment">// 如果他們字元相同則代表不需要修改，因此修改距離直接延續先前</span></span><br><span class="line">            <span class="keyword">else</span> dis[i][j] = min(dis[i<span class="number">-1</span>][j<span class="number">-1</span>], min(dis[i<span class="number">-1</span>][j] , dis[i][j<span class="number">-1</span>]))+<span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 因為她們字元不相同，所以要詢問 replace , delete , insert 哪一個編輯距離</span></span><br><span class="line">            <span class="comment">// 最小，就選擇他 +1 來成為目前的最少編輯距離</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dis[n][m] ; <span class="comment">// 這就是最少編輯距離的答案</span></span><br></pre></td></tr></table></figure>

<h2 id="QUESTION-現在的我們知道最少編輯距離的答案，那我們可以回推有哪些字元被編輯嗎？"><a href="#QUESTION-現在的我們知道最少編輯距離的答案，那我們可以回推有哪些字元被編輯嗎？" class="headerlink" title="QUESTION: 現在的我們知道最少編輯距離的答案，那我們可以回推有哪些字元被編輯嗎？"></a>QUESTION: 現在的我們知道最少編輯距離的答案，那我們可以回推有哪些字元被編輯嗎？</h2><p>那當然是可以的阿XD，只是寫起來比較麻煩。通常這種答案會有很多種，依照題目的要求通常只需要你輸出一種方式即可。<del>除非是毒瘤</del></p>
<h3 id="實現方式如下："><a href="#實現方式如下：" class="headerlink" title="實現方式如下："></a>實現方式如下：</h3><p>由於這回推其實也就只是一個簡單的遞迴你能夠推得出 DP 就可以知道要怎麼回推哪些字元被編輯，於是我就在程式碼上旁寫下說明來幫助讀者閱讀。<del>希望能夠幫助到</del></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span> ;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span> i , <span class="keyword">int</span> j )</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">0</span> || j==<span class="number">0</span>)&#123;  <span class="comment">//表示 A or B 完全沒有字串</span></span><br><span class="line">        <span class="keyword">while</span>( i &gt; <span class="number">0</span> )&#123; </span><br><span class="line">            <span class="comment">// 由於 B 完全沒有字串，所以需要刪除 A 的所有字串</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; cnt++ &lt;&lt; <span class="string">" Delete "</span> &lt;&lt; i &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>( j &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 由於 A 完全沒有字串，所以需要增加 B 的所有字串</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; cnt++ &lt;&lt; <span class="string">" Insert "</span> &lt;&lt; i+<span class="number">1</span> &lt;&lt; <span class="string">","</span> &lt;&lt; strB[j<span class="number">-1</span>] &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">            j-- ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果字元相等代表這裡沒有增加修改距離</span></span><br><span class="line">    <span class="comment">// 特別注意：不可以使用　dis[i][j] == dis[i-1][j-1]</span></span><br><span class="line">    <span class="comment">// 有可能 dis[i-1][j]+1 = dis[i-1][j-1] 這樣就會導致 strB 的第 j 字元遺失</span></span><br><span class="line">    <span class="comment">// 而讓回推出錯</span></span><br><span class="line">    <span class="keyword">if</span>(strA[i<span class="number">-1</span>] == strB[j<span class="number">-1</span>])</span><br><span class="line">        backtracking(i<span class="number">-1</span>,j<span class="number">-1</span>); <span class="comment">// 往前推</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dis[i][j] == dis[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>)&#123; <span class="comment">// 這次是使用替換指令</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; cnt++ &lt;&lt; <span class="string">" Replace "</span> &lt;&lt; i &lt;&lt; <span class="string">","</span> &lt;&lt; strB[j<span class="number">-1</span>] &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">            backtracking(i<span class="number">-1</span>,j<span class="number">-1</span>); <span class="comment">// 回推替換</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 特別注意這裡要使用 else if ，不可以只有 if，這樣會讓回推變成 BFS 而不是 DFS</span></span><br><span class="line">        <span class="comment">// 答案就會變成輸出所有的替換可能而不是輸出一種「完整」的其中一種回推</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(dis[i][j] == dis[i<span class="number">-1</span>][j]+<span class="number">1</span>)&#123;  <span class="comment">// 這次是使用刪除指令</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; cnt++ &lt;&lt; <span class="string">" Delete "</span> &lt;&lt; i &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">            backtracking(i<span class="number">-1</span>,j) ; <span class="comment">// 回推刪除</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(dis[i][j] == dis[i][j<span class="number">-1</span>]+<span class="number">1</span>)&#123; <span class="comment">// 這次是使用插入指令</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; cnt++ &lt;&lt; <span class="string">" Insert "</span> &lt;&lt; i+<span class="number">1</span> &lt;&lt; <span class="string">","</span> &lt;&lt; strB[j<span class="number">-1</span>] &lt;&lt;<span class="string">'\n'</span>  ;</span><br><span class="line">            backtracking(i,j<span class="number">-1</span>); <span class="comment">// 回推插入</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="焦點回到題目上，解開題目的小設計"><a href="#焦點回到題目上，解開題目的小設計" class="headerlink" title="焦點回到題目上，解開題目的小設計"></a>焦點回到題目上，解開題目的小設計</h2><p>甚麼，這題好像沒有甚麼焦點！</p>
<p>還是有的，這題的輸入不一定要用字串，只要是那一行都可以，所以請記住要用<code>getline</code>，<del>不要像我這個大笨蛋一直用<code>cin &gt;&gt; strA &gt;&gt; strB</code>，然後一直找不出答案，還在想是不是自己 DP 寫不好</del></p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://blog.roy4801.tw/2019/06/14/uva/uva526/" target="_blank" rel="noopener">Uva 526 - String Distance and Transform Process</a><br><a href="https://zh.wikipedia.org/wiki/%E8%90%8A%E6%96%87%E6%96%AF%E5%9D%A6%E8%B7%9D%E9%9B%A2" target="_blank" rel="noopener">萊文斯坦距離</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>其實這演算法在我高中時就有學習過了，但是我高中的時候不懂得整理資料的重要性。讓我在高中學會的很多演算法一經過時間的摧殘就忘記這些演算法是甚麼了，可惡，應該高中就要學會整理資料的能力，這太重要了。</p>
<p>然後在此奉戒各位女朋友可以教，但是不要讓她影響到你的正業，我常常會因為女朋友而影響正業導致高三下的時候荒廢了我的程式，因為已經知道自己能保送上某間大學而每天跟女朋友打打鬧鬧，到最後跟女朋友分手還不是甚麼都沒有獲得。</p>
<p>不過如果你能跟她在一起到結婚的話，就當我沒說吧！這也是令我羨慕的結局，我也好想要。</p>
<p>謝謝新北市教育局能讓我在高三寒假時去板橋高中訓練程式設計，讓我可以增強我的演算法能力，也謝謝板橋高中的蝸牛老師，你的指導能力讓我在學習演算法的路上突飛猛進。老師您真的教得很好，高中沒有你真的沒辦法像現在這樣。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>其實就是沒有附上說明的程式碼，我也花了兩個小時撰寫文章，看得懂跟說得出來真的是兩回事，也許還有人覺得我說的很差，不過我已經盡力解釋。希望可以幫助到各位。</p>
<p>也希望大家想要學習的知識都可以快速學習而成，不要因為自身的環境不足而學習不到。</p>
<p>於是這裡就補述一些題目給的資料範圍限制與標頭檔了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">string</span> strA , strB ;</span><br><span class="line"><span class="keyword">int</span> dis[MAXN][MAXN] , back_table[MAXN][MAXN] ;</span><br><span class="line"><span class="keyword">int</span> cnt , m , n  ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span> i , <span class="keyword">int</span> j )</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">0</span> || j==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>( i &gt; <span class="number">0</span> )&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; cnt++ &lt;&lt; <span class="string">" Delete "</span> &lt;&lt; i &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>( j &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; cnt++ &lt;&lt; <span class="string">" Insert "</span> &lt;&lt; i+<span class="number">1</span> &lt;&lt; <span class="string">","</span> &lt;&lt; strB[j<span class="number">-1</span>] &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">            j-- ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(strA[i<span class="number">-1</span>] == strB[j<span class="number">-1</span>])</span><br><span class="line">        backtracking(i<span class="number">-1</span>,j<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dis[i][j] == dis[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; cnt++ &lt;&lt; <span class="string">" Replace "</span> &lt;&lt; i &lt;&lt; <span class="string">","</span> &lt;&lt; strB[j<span class="number">-1</span>] &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">            backtracking(i<span class="number">-1</span>,j<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(dis[i][j] == dis[i<span class="number">-1</span>][j]+<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; cnt++ &lt;&lt; <span class="string">" Delete "</span> &lt;&lt; i &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">            backtracking(i<span class="number">-1</span>,j) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(dis[i][j] == dis[i][j<span class="number">-1</span>]+<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; cnt++ &lt;&lt; <span class="string">" Insert "</span> &lt;&lt; i+<span class="number">1</span> &lt;&lt; <span class="string">","</span> &lt;&lt; strB[j<span class="number">-1</span>] &lt;&lt;<span class="string">'\n'</span>  ;</span><br><span class="line">            backtracking(i,j<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">med</span><span class="params">()</span></span>&#123; <span class="comment">//Minimum Edit Distance</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= n ; i++) dis[i][<span class="number">0</span>] = i ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt;= m ; j++) dis[<span class="number">0</span>][j] = j ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= m ; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(strA[i<span class="number">-1</span>] == strB[j<span class="number">-1</span>]) dis[i][j] = dis[i<span class="number">-1</span>][j<span class="number">-1</span>] ;</span><br><span class="line">            <span class="keyword">else</span> dis[i][j] = min(dis[i<span class="number">-1</span>][j<span class="number">-1</span>], min(dis[i<span class="number">-1</span>][j] , dis[i][j<span class="number">-1</span>]))+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> );</span><br><span class="line">    freopen(<span class="string">"out.txt"</span> , <span class="string">"w"</span> , <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">while</span>(getline(<span class="built_in">cin</span> ,strA) &amp;&amp; getline(<span class="built_in">cin</span> , strB))&#123;</span><br><span class="line">        n=strA.length() ;</span><br><span class="line">        m=strB.length() ;</span><br><span class="line">        cnt = <span class="number">1</span> ;</span><br><span class="line">        med();</span><br><span class="line">        <span class="keyword">if</span>(flag) <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">        flag = <span class="number">1</span> ;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; dis[n][m] &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">        backtracking(n,m);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>UVa</category>
        <category>演算法知識</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>最短修改距離 Minimum Edit Distance</tag>
        <tag>演算法知識</tag>
        <tag>動態規劃 Dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa11151 - Longest Palindrome (LCS)</title>
    <url>/2020/10/05/UVa/UVa11151/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>給你一個字串，詢問在這字串中能夠找到的最長迴文長度為多少。<br>迴文：從左邊讀與右邊讀相同</p>
</blockquote>
<a id="more"></a>

<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>這題可以使用兩種方式解，但我這裡只用其中一種方式解題，原因是解決速度較快，但缺點時間複雜度較高。</p>
<h3 id="QUESTION-1-哪兩種方式呢"><a href="#QUESTION-1-哪兩種方式呢" class="headerlink" title="QUESTION 1: 哪兩種方式呢"></a>QUESTION 1: 哪兩種方式呢</h3><ul>
<li><strong>最長共同子序列 Longest Common Subsequence</strong> (LCS)<br>時間複雜度為 \(O(n^2)\)</li>
<li><strong>馬拉車演算法 Manacher’s Algorithm</strong><br>時間複雜度為 \(O(n)\)</li>
</ul>
<blockquote>
<p>這裡我們使用時間複雜度比較高的演算法，最長共同子序列</p>
</blockquote>
<h3 id="QUESTION-2-那為甚麼我們會使用最長共同子序列，時間複雜度比較高呀！"><a href="#QUESTION-2-那為甚麼我們會使用最長共同子序列，時間複雜度比較高呀！" class="headerlink" title="QUESTION 2: 那為甚麼我們會使用最長共同子序列，時間複雜度比較高呀！"></a>QUESTION 2: 那為甚麼我們會使用最長共同子序列，時間複雜度比較高呀！</h3><p>因為這題的字串長度不超過 1000，且題目有說明 \(90 \% \) 的測試資料長度都小於 255。通常時間複雜度 \(O(n^2)\) 只要測試資料大小不大於 \(10^3\) 基本上都可以通過。加上如果只有 LCS 去寫這題目可以讓這題目簡單非常多。</p>
<p><del>也可以透過題目給的測試資料範圍大小來猜這題的時間複雜度</del></p>
<h3 id="QUESTION-3-通常-LCS-應該要有兩個字串來找出共同子序列但這題是迴文，哪裡有關係呢？"><a href="#QUESTION-3-通常-LCS-應該要有兩個字串來找出共同子序列但這題是迴文，哪裡有關係呢？" class="headerlink" title="QUESTION 3: 通常 LCS 應該要有兩個字串來找出共同子序列但這題是迴文，哪裡有關係呢？"></a>QUESTION 3: 通常 LCS 應該要有兩個字串來找出共同子序列但這題是迴文，哪裡有關係呢？</h3><p>嘿嘿，這個我其實一開始也想不到但後來我在 google 翻找文章時看到了一個超級優秀的想法！顛覆了我的想像。</p>
<p>必須要有兩個子串，第一個為題目給的字串，第二為題目反轉字串，並將他們進行 LCS 就可以把找到他們的共同子序列，那也就是迴文啦!</p>
<blockquote>
<p>Why?</p>
</blockquote>
<p>由於迴文的特性，你如果顛倒反著念也會一樣，剛好符合共同子序列，因為迴文就算顛倒還是一樣呀www。</p>
<h3 id="EXERCISE-A"><a href="#EXERCISE-A" class="headerlink" title="EXERCISE A:"></a>EXERCISE A:</h3><blockquote>
<p>求 ADAM 與 MADA 的 LCS</p>
</blockquote>
<p>答案是不是會是 3 呢！很神奇吧，國人的演算法思維真的大於大於我，我好爛嗚嗚ಥ⌣ಥ。</p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://blog.csdn.net/llx523113241/article/details/45536793" target="_blank" rel="noopener">uva 11151 Longest Palindrome （最长公共子序列）</a><br><a href="https://hackmd.io/@sa072686/SJCdfKC0M/https%3A%2F%2Fhackmd.io%2Fs%2FS1jJaysvQ" target="_blank" rel="noopener">APCS - 2018台南一中選修</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>其實我還沒有學好 Manacher’s Algorithm，有點怠惰阿我！還需要更努力，明明有一個中秋廉價我的努力卻沒有變多有點討厭啊！我需要讓我自己變得能夠專心，有時候我在打 blog 文章時，我都會有種腦袋已經想好要打甚麼，但手指卻沒有跟上QAQ，難道是老了嗎…，不會吧！</p>
<p>不過打心得的時候是快樂的，因為可以把自己想講的話抒發出來，認識的人不太會看到不會尷尬，也不會被他們覺得虛偽XD，我好希望我能夠把生活中的每件事情都記錄在 blog 上，但感覺還是有點難，有時候遇到一些討厭的事情通常都是會選擇跟朋友分享，有點少打在 Blog 上，我也希望我可以打打我的愛情故事在 Blog 上，但我又很怕之後被朋友們 judge。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1010</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> dp[MAXN][MAXN] = &#123;&#125; ;</span><br><span class="line"><span class="built_in">string</span> strA , strB ;</span><br><span class="line"><span class="keyword">int</span> n , m ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lcs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n = strA.length();</span><br><span class="line">    m = strB.length();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= n ; i++) dp[i][<span class="number">0</span>] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt;= m ; j++) dp[j][<span class="number">0</span>] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= m ; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(strA[i<span class="number">-1</span>] == strB[j<span class="number">-1</span>]) dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">else</span> dp[i][j] = max(dp[i<span class="number">-1</span>][j] , dp[i][j<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][m] ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">int</span> t ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t ;</span><br><span class="line">    <span class="built_in">cin</span>.ignore();</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        getline(<span class="built_in">cin</span>,strA);</span><br><span class="line">        strB = strA ;</span><br><span class="line">        reverse(strB.begin() , strB.end());</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; lcs() &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>最長共同子序列 Longest Common Subsequence</tag>
        <tag>最長迴文子字串 Longest Palindromic Substrings</tag>
        <tag>動態規劃 Dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa11362 - Phone List (字典樹 詳解)</title>
    <url>/2020/10/09/UVa/UVa11362/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>給你一組電話號碼，不超過 10 位數，如果這一組的電話號碼內只要有一個電話號碼是另外一個電話號碼的前綴就輸出 “NO”，否則就輸出 “YES”</p>
</blockquote>
<a id="more"></a>

<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>這題用 <strong>字典樹 trie</strong> 解決是再好不過的了，我們先來介紹 trie！</p>
<blockquote>
<p>trie 是一種有序樹，常用於搜尋提示，最好的比喻就是 google 的搜尋提示。<del>就是你打幾個 key word 上去下面就跑出一堆你不想要的那個</del><br>這題為教學題，但此問題並沒有把 trie 的全部能力都展現出來，若以後我有其他題目可以將 trie 展現，我會再寫一篇做為說明，但此問題還有一點點的小設計，需要稍加解釋才能完全理解。<br>由於是寫給初學者看於是這題不使用任何 <strong>指標 pointer</strong> 來幫助這份程式碼，希望可以讓其他沒學過 C++ 的使用者都能學會。</p>
</blockquote>
<h2 id="TRIE-字典樹-原理"><a href="#TRIE-字典樹-原理" class="headerlink" title="TRIE 字典樹 原理"></a>TRIE 字典樹 原理</h2><p>先看看圖片吧！這樣應該會比較有點概念</p>
<blockquote>
<p><img src="/images/UVa11362/1.jpg" alt=""></p>
</blockquote>
<p>TRIE 本身也是一種樹，可以試著把它當作有規則的樹理解。<del>畢竟他的發音跟 tree 根本沒有不一樣吧！</del><br>字串根據 TRIE 判斷，如果字串中的字元已經在 TRIE 擁有，則就在往 TRIE 的下一層判斷，假如沒有那我們就新增一個節點給予這個字元。</p>
<p>達到最後一層時則必須要有一個判斷表示這是某個單字的結尾。</p>
<h3 id="QUESTION-TRIE-的時間複雜度呢？"><a href="#QUESTION-TRIE-的時間複雜度呢？" class="headerlink" title="QUESTION: TRIE 的時間複雜度呢？"></a>QUESTION: TRIE 的時間複雜度呢？</h3><blockquote>
<p>新增字串的時間複雜度為 \(O(n)\)<br>搜尋的時間複雜度為 \(O(n)\)<br>搜尋關鍵字首的時間複雜度為 \(O(n)\)<br><del>算是還不錯用的資料結構之一，感覺學起來可以在很多地方用到，小弟我菜鳥還沒有實際用過</del></p>
</blockquote>
<h2 id="TRIE-字典樹的實現與說明"><a href="#TRIE-字典樹的實現與說明" class="headerlink" title="TRIE 字典樹的實現與說明"></a>TRIE 字典樹的實現與說明</h2><h3 id="資料結構"><a href="#資料結構" class="headerlink" title="資料結構"></a>資料結構</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">bool</span> isWord = <span class="literal">false</span> ; <span class="comment">// 判斷是否為單字結尾</span></span><br><span class="line">    <span class="keyword">int</span> next[alp_MAXN]; <span class="comment">// 到下個單字的索引，假如有 26 英文字母就設定 26</span></span><br><span class="line">    <span class="comment">// alp_MAXN = alphabet MAXN</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span></span>&#123; <span class="comment">//重新設定</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; alp_MAXN ; i++)</span><br><span class="line">            next[i] = <span class="number">-1</span> ; </span><br><span class="line">        isWord = <span class="literal">false</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;trie[arr_MAXN];</span><br></pre></td></tr></table></figure>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insrt</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c , cur = <span class="number">0</span>; <span class="comment">// c=字元的索引 cur = trie 現在這層，可以想像成樹的 root</span></span><br><span class="line">    <span class="comment">// cur =0，表示現在在 trie 的最一開始處</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; strA.length() ; i++)&#123; <span class="comment">//將字串加入 trie</span></span><br><span class="line">        c = strA[i] - <span class="string">'0'</span> ;</span><br><span class="line">        <span class="keyword">if</span>(trie[cur].next[c] == <span class="number">-1</span> )&#123; <span class="comment">//代表節點沒有被新增</span></span><br><span class="line">            trie[cnt].reset(); <span class="comment">//先重新設定節點，以免舊資料也加入</span></span><br><span class="line">            trie[cur].next[c] = cnt ; <span class="comment">//連接到下一層的 node</span></span><br><span class="line">            cur = cnt++ ; <span class="comment">//增加陣列長度</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cur = trie[cur].next[c]; <span class="comment">//因為已經有節點，可以直接往下層走就好</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    trie[cur].isWord = <span class="literal">true</span> ; <span class="comment">//由於已讀到字尾於是給他是字尾的標記</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="搜尋"><a href="#搜尋" class="headerlink" title="搜尋"></a>搜尋</h3><p>跟插入的算法差不多，只是不需要新增節點的 if，只需要 else 跟最後判斷當已經讀到字尾時有沒有被標記成是字尾。</p>
<h3 id="關鍵字查詢"><a href="#關鍵字查詢" class="headerlink" title="關鍵字查詢"></a>關鍵字查詢</h3><p>跟搜尋一樣，但只要搜到此字串最底層後就可以 return 了，不需要檢查是否到字尾，如果是在寫題目通常是用 return true or false。</p>
<h3 id="刪除"><a href="#刪除" class="headerlink" title="刪除"></a>刪除</h3><p>目前還沒有學到，隨後補上。打算要用遞迴嘗試創作看看，畢竟沒有用指標的 trie，在網路上的自學資源還很少見呢！XD</p>
<h2 id="焦點回到題目上，解開題目的小設計"><a href="#焦點回到題目上，解開題目的小設計" class="headerlink" title="焦點回到題目上，解開題目的小設計"></a>焦點回到題目上，解開題目的小設計</h2><p>由於這題是問「前綴」，且只要一個就好，於是我們就用一個 flag 與一個 if 來進行判斷，只要當現在的電話號碼再依序插入 trie 中如果剛好字尾有被標記就表示已經有一個電話號碼已經是這個電話的前綴了就 <code>return</code>；另一個則是假如這個電話號碼字元已經全部被插入 trie 中表示，這組電話號碼是先前某個電話的前綴，所以也需要 <code>return</code>。 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> flag = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">if</span>(trie[cur].isWord || i == strA.length()<span class="number">-1</span> ) &#123;flag = <span class="number">1</span> ;<span class="keyword">return</span> ;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://epmahfuz.blogspot.com/2016/10/solution-of-uva-11362-phonebook.html" target="_blank" rel="noopener">Solution of UVa 11362-Phone List</a><br><a href="https://www.mdeditor.tw/pl/2iwz/zh-tw" target="_blank" rel="noopener">[翻譯]資料結構——trie樹介紹</a><br><a href="https://zh.wikipedia.org/wiki/Trie" target="_blank" rel="noopener">Trie</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>應該是我這題選得不好，我原本是想要完整地把 trie 都學起來的，結果這題只需要用到 trie 的插入就好，刪除、搜尋都不需要用到，害我的心情很差：(，有種覺得沒有把全部資料都學起來的感覺，以後在挑選題目時需要謹慎挑選，要是挑到這種題目會覺得一個演算法沒有完整學習，有點小難過。</p>
<p>不過 trie 算是簡單易學的演算法，以自學來說。我就讀的大學演算法資源基本上是零，我都覺得我在這種環境下自學演算法可能也算是個抖 M 了吧XD，希望我在學習的路上能夠填補些自學的資源讓接下來想學習的人不要想我一樣這麼辛苦，我到現在才學有點太慢了呢，等我最近忙完後我再補上刪除的程式碼，補足自己的知識與空白之處。等學習完後看自己有沒有更多心得再補上。<del>希望是有</del></p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>其實就是沒有附上說明的程式碼，我也花了兩個小時撰寫文章，看得懂跟說得出來真的是兩回事，也許還有人覺得我說的很差，不過我已經盡力解釋。希望可以幫助到各位。</p>
<p>也希望大家想要學習的知識都可以快速學習而成，不要因為自身的環境不足而學習不到。</p>
<p>於是這裡就補述一些題目給的資料範圍限制與標頭檔了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> alp_MAXN 15</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> arr_MAXN 1000009</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span> , flag = <span class="number">0</span> ;</span><br><span class="line"><span class="built_in">string</span> strA ;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">bool</span> isWord = <span class="literal">false</span> ;</span><br><span class="line">    <span class="keyword">int</span> next[alp_MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; alp_MAXN ; i++)</span><br><span class="line">            next[i] = <span class="number">-1</span> ;</span><br><span class="line">        isWord = <span class="literal">false</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;trie[arr_MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insrt</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c , cur = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; strA.length() ; i++)&#123;</span><br><span class="line">        c = strA[i] - <span class="string">'0'</span> ;</span><br><span class="line">        <span class="keyword">if</span>(trie[cur].next[c] == <span class="number">-1</span> )&#123;</span><br><span class="line">            trie[cnt].reset();</span><br><span class="line">            trie[cur].next[c] = cnt ;</span><br><span class="line">            cur = cnt++ ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cur = trie[cur].next[c];</span><br><span class="line">            <span class="keyword">if</span>(trie[cur].isWord || i == strA.length()<span class="number">-1</span> ) &#123;flag = <span class="number">1</span> ;<span class="keyword">return</span> ;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag) <span class="keyword">break</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    trie[cur].isWord = <span class="literal">true</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> );</span><br><span class="line">    <span class="comment">//freopen("out.txt" , "w" , stdout );</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> t , n ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">        cnt = <span class="number">1</span> ;</span><br><span class="line">        flag = <span class="number">0</span> ;</span><br><span class="line">        trie[<span class="number">0</span>].reset();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; strA ;</span><br><span class="line">            insrt();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; (flag? <span class="string">"NO"</span> : <span class="string">"YES"</span>) &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//debug</span></span><br><span class="line"><span class="comment">//        for(int i = 0 ; i &lt; 20 ; i++)&#123;</span></span><br><span class="line"><span class="comment">//            for(int j = 0 ; j &lt; 10 ; j++)</span></span><br><span class="line"><span class="comment">//                cout &lt;&lt; trie[i].next[j] &lt;&lt; ' ' ;</span></span><br><span class="line"><span class="comment">//            cout &lt;&lt; trie[i].isWord ;</span></span><br><span class="line"><span class="comment">//            cout &lt;&lt; '\n' ;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>UVa</category>
        <category>演算法知識</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>字典樹 trie</tag>
        <tag>演算法知識</tag>
      </tags>
  </entry>
  <entry>
    <title>NCPC2020 109年度全國大專電腦軟體設計決賽 - 34th(佳作) 心得</title>
    <url>/2020/10/09/contest_experence/ncpc2020_final/</url>
    <content><![CDATA[<blockquote>
<p>僅此紀錄 2020/10/09 109年度全國大專電腦軟體設計決賽心得。<br>「紀錄每個時刻，讓未來的自己不遺忘過去的自己」<br>只有自己才能體會自己的過去<br>僅只有 34th，還需要努力</p>
</blockquote>
<a id="more"></a>

<h2 id="出發拉"><a href="#出發拉" class="headerlink" title="出發拉"></a>出發拉</h2><p>通過了初賽之後，決賽的場地直到 10/07 才公佈，有點小慢，嗚嗚嗚，希望下次師大可以在更早公布些XD，不過也有可能是我們第一次參加這比賽可能不知道比賽地點都會在台灣師範大學，下次可以直接猜是在台灣師範大學比了，對！然後看到比賽的報到時間是早上 9 點整到 9 點 45 分，對一個貓頭鷹來說有點痛苦阿ಥ⌣ಥ，我早上醒來的時候雖然是 7 點 30 分，但依照我那愛賴床的爛個性硬是拖倒了 9 點整才出門XD，不過這個性要改拉，不要遲到，這真的很重要，遲到會讓自己緊張然後就忘記一些重要的事情了QQ，或是錯過一些資訊。</p>
<blockquote>
<p>賽前資訊 </p>
</blockquote>
<p><img src="/images/ncpc2020_final/1.jpg" alt=""></p>
<p>出門騎到台師大之後，路途中就在下雨，阿阿阿阿好煩阿，怎麼初賽跟決賽都要下雨拉QQ，我好討厭我騎車的時候下雨，其他的時候真的沒關係喔，管控天氣的神聽到了嗎XD。由於今天是假日的關係師大的停車位蠻多的，隨後停好車就直接前往比賽出發地點了。</p>
<blockquote>
<p><a href="https://www.youtube.com/watch?v=HQDDlgGy2hg&ab_channel=SKRpresents%E9%99%B6%E5%B1%B1%E9%9F%B3%E6%A8%82" target="_blank" rel="noopener">nothing change 還是討厭下雨天</a></p>
</blockquote>
<p><img src="/images/ncpc2020_final/2.jpg" alt=""></p>
<h2 id="進場報到"><a href="#進場報到" class="headerlink" title="進場報到"></a>進場報到</h2><p>進場之後順利報到，聽主持人一段漂亮的演講後就去四樓測試電腦，沒想到電腦有點小差QQ，他的編輯器只有 Esclipe 與另外一個文字編輯器，等等 CodeBlock 呢？去哪裡了？於是我們(學長-風平)對就舉手發問，沒想到主辦單位拿出賽事規則規則上面確實沒有 CodeBlock，只有電腦上所擁有的兩個軟體，等等等等等等，不對欸！我怎麼記得 CodeBlock 應該是這種比賽的<strong>必備</strong>阿！這點讓我很討厭拉，希望主辦單位下次可以給參加者更友善的環境。</p>
<blockquote>
<p>主辦單位提供的資料夾</p>
</blockquote>
<p><img src="/images/ncpc2020_final/3.jpg" alt=""></p>
<blockquote>
<p>主辦單位提供的考生辨識證</p>
</blockquote>
<p><img src="/images/ncpc2020_final/4.jpg" alt=""></p>
<p>後來學弟(漢軒)與他們的好朋友發現出一個 BUG XD，它們發現考生辨識證的中的吊帶英文有錯XD，程式的英文應該要是「programming」，但吊帶上面打的是「progrmming」，笑爛，考生還沒比賽就已經在幫這比賽 debug。師大下次可以注意一下，不然你們的英文程度要跟我一樣了拉 QwQ，不過辦比賽真的很辛苦，也謝謝你們可以讓我們比賽。</p>
<blockquote>
<p>考生辨識證吊帶中有錯誤的英文</p>
</blockquote>
<p><img src="/images/ncpc2020_final/5.jpg" alt=""></p>
<p>這裡有個小小的插曲，我們在座坐位的時候隔壁師大的學生座錯座位，我好心提醒他們如果這樣的話會有另外一隊少一個位置可以座，所以師大隊伍應該要座回自己隊伍，但沒想到師大隊伍說如果座回正確的位置會影響到他們比賽！HELLO？那你怎麼不想想你這樣就不會影響到別人嗎？我們是來比賽的，比賽要求的是公平，你讓其他隊伍不公平這樣還能叫做比賽嘛。那隻師大隊伍真的很自私，後來我朋友請工作人員來解決，他們才座回正確的位置，這讓我更生氣，硬要請階層更大的人講才會聽話，我們解釋道理給他不願意相信，我厭惡這種人，自私的人。</p>
<p><strong>當一個比賽不公平時，那早就失去了比賽的意義，那怕只是一個小小的權益受損</strong></p>
<p>準備完畢後，現場的走廊也掛上五彩繽紛的氣球，頓時超漂亮的！我們也在那時候想要拍幾張照片留為紀念，當我們這支隊伍正想著要如何自拍時有為很熱心的師大工作人員主動來幫我們拍照，超讓我感動的！師大的工作人員真的好好QQ，爛的是賽事規則不是那些友善的 NCPC 工作人員，給 NCPC 工作人員一個讚(◍•ᴗ•◍)❤️。</p>
<blockquote>
<p>與師大 NCPC 氣球牆留念</p>
</blockquote>
<p><img src="/images/ncpc2020_final/6.jpg" alt=""></p>
<h2 id="比賽當下"><a href="#比賽當下" class="headerlink" title="比賽當下"></a>比賽當下</h2><p>比賽入場後，突然走道上多了很多氣球飛在天花板上，超級酷的欸！有種走入了童話故事的感覺讓自己的心情都好上許多XD，於是我就想要在這氣氛下留下一張照片，內心決定了後，請學長(風平)幫我拍了一張，不得不說他拍照技術真的蠻不賴的，看來他的女生朋友 or 女朋友對於拍照技術指導的很不錯呢XD，幫我拍出了一張很漂亮得照片，謝拉學長！</p>
<blockquote>
<p>盡我可能，發揮最好 - 照片註解</p>
</blockquote>
<p><img src="/images/ncpc2020_final/7.jpg" alt=""></p>
<p>開始比賽後，我們打開題本，發現題本竟然還是雙面列印！！！天啊…，這樣太痛苦了吧，沒改進阿師大QQ，於是我們直接打開題本的 PDF 直接 print 出來，這樣就有單面題本拉XD，天啊，我們是生活智慧王吧(自己說)，後來主辦單位就可以幫我們印好單面題本 ♡(&gt; ਊ &lt;)♡，不過這樣不是更浪費紙吧..，下次真的要改進拉師大，不要讓我在說第三邊呦。不然我會大爆哭喔QQQQQQQQQ。</p>
<p>在開始比賽後，我們找不到 Esclipe！當下的我們真的傻眼，怎麼原本在測試的時候有結果到考試的時候沒有呢？我們項工作人員反應，隨後工作人員不知道對我們電腦下了甚麼指令，Esclipe 就跑出來了，只是他跟其他檔案重疊，於是我們直接刪掉其他檔案把 Esclipe 呼叫出來，開始進行比賽。</p>
<p>遇到一個很有趣的事情是原本 pJ 學長上傳一次程式碼回傳的答案是 WA，學長就開始不斷思考哪裡有錯，過了一陣子之後，漢軒重新整理了一次頁面就變成了 AC，So Excited，非常的酷啊，原來是官方測試資料有誤，之後修正後我們就變成 AC 了，既上次 TOPC 後我們又成功 Checker 一個題目，我們隊伍是 ICPC Check Hacker 吧www，連續兩次找到測資上的漏洞。</p>
<p>再來有一題是水題 pD，我們一直都沒有辦法搞定他，想了很多種方式去檢查卻都一直檢查失敗，由於我們一直不斷的在一開始的程式碼修補漏洞導致閱讀性極低，到最後反而是已經找到哪裡有漏洞，但在程式中卻看不出來哪裡有漏洞，後來直接砍掉重寫就 AC。下次可以考慮這方法，只要開始知道是錯在哪裡但程式卻想不太出來是哪個部份出問題時，當這環節重複到第三次就可以直接砍掉重寫一份，保持可讀性也好幫助自己接下來的 debug，如果能 AC 是最好啦。</p>
<p>在比賽中途由於紙張過多，當我們要找題目或是找出我們的題目 menu 時都異常困難，到最後甚至直接放棄，都是直接重新印一份，我覺得這樣非常不妥。經常浪費時間在查找紙張，我認為一定有方法可以幫助我們在整理印出來的紙張跟題目卷，這樣才可以有效的在考試當中找到自己所需要的資料也不容易遺失(被其他不相關資料隱藏)。目前想法是準備一個資料夾來放題目嗎？不知道行不行得通。</p>
<p>比賽比到第三小時左右，我與隊友的體力已經越來越差了，我甚至看電腦螢幕會模糊，這點我還需要訓練一下我的體力，太久沒有寫 3hr 以上的程式設計競賽從超過 3hr 以後我的 Coding 能力越來越差思緒也越來越不清楚，最後還需要先趴下來休息一陣子才可以能夠讓體力稍加恢復，但狀況還不是很優，看來運動對我來說也是很重要的一件事之一。</p>
<p>pG 的部分是一份水題，但由於溝通的問題，導致我對於題意理解錯誤而讓我的程式碼寫出來不會是標準答案，學長跟漢軒都在幫我 debug，後來學長直接上去重寫一份之就直接 AC，我覺得這是一個不錯的選擇，當她在重寫一份程式碼時有再重看一次題目就發現學長跟我在溝通上有瑕疵，抓到錯誤後，學長再重新寫一份程式碼上傳就成功 AC，我覺得這是一個很好的成功經驗、也很幸運能夠抓到。我想要複製這次的成功經驗，<strong>我想應該是當你在看寫程式的人想法是錯誤時可以考慮直接用自己的方法重新寫一次，但必須要對自己的想法很有把握，不然就只是在浪費時間寫兩次題目。</strong></p>
<p>如果累了可以去外面適當地走動可以讓自己放鬆或許也可以能夠讓隊友也稍稍放鬆XD。</p>
<p>剩下的題目說難不難，說簡單不簡單，但都有一次 AC，隊友太棒了✧(&gt;o&lt;)ﾉ</p>
<h2 id="比賽結果"><a href="#比賽結果" class="headerlink" title="比賽結果"></a>比賽結果</h2><p>這次比賽的名次其實沒有說到很好，但也沒有到太差。我覺得算是在我們隊伍的水準之間，34 就差不多是我們的區間，我們沒有表現沒有失常已經算是蠻幸運的事情，現在的狀況慢慢的在穩定當中，期望 11 月的 ICPC Region 比賽表現不失常也可以發揮得更好。也謝謝隊友們願意陪我參加演算法比賽，我們都知道這條路上不一定會成功還願意一起努力，真的謝謝各位。</p>
<blockquote>
<p>比賽名次</p>
</blockquote>
<p><img src="/images/ncpc2020_final/8.PNG" alt=""></p>
<h2 id="在-ICPC-2020-時進行頒獎典禮"><a href="#在-ICPC-2020-時進行頒獎典禮" class="headerlink" title="在 ICPC 2020 時進行頒獎典禮"></a>在 ICPC 2020 時進行頒獎典禮</h2><p>在頒獎時，我們的教練也過來一同拍合照，慶祝我們拿到此獎，拿到這獎項非常開心，代表我們又進步了一些，且這次是有加入普通大學的比賽，還有機會拿到 34th，代表我們實力被認可了吧！雖然 ICPC 2020 發揮失常，但還是可以的吧！還需要在加油，真的。</p>
<blockquote>
<p>比賽獎狀</p>
</blockquote>
<p><img src="/images/ncpc2020_final/10.jpg" alt=""></p>
<blockquote>
<p>頒獎典禮照片-A</p>
</blockquote>
<p><img src="/images/ncpc2020_final/12.JPG" alt=""></p>
<blockquote>
<p>頒獎典禮照片-B</p>
</blockquote>
<p><img src="/images/ncpc2020_final/13.JPG" alt=""></p>
<blockquote>
<p>頒獎典禮照片-C</p>
</blockquote>
<p><img src="/images/ncpc2020_final/11.jpg" alt=""></p>
<h2 id="賽後日誌"><a href="#賽後日誌" class="headerlink" title="賽後日誌"></a>賽後日誌</h2><p>比賽完畢後，主辦單位讓我們如果想要帶氣球回家就可以帶氣球回家，於是我就拿了一顆氣球回家綁在機車上，很像馬力歐賽車XD，我都好怕後面的機車騎士看了會覺得我超像智障的XD，但不幸的是她在我騎車的路上因為車速過快就爆炸了ಥ⌣ಥ，在這邊跟大家宣導一下，如果你有綁氣球在機車上需要盡量將低你的車速在約 40km/hr，不然很容易因為車速過快拉扯力道太強而讓氣球破掉…。</p>
<blockquote>
<p>馬力歐賽車</p>
</blockquote>
<div class="video-container"><iframe src="https://www.youtube.com/embed/MFJDjKzm3hI" frameborder="0" loading="lazy" allowfullscreen></iframe></div>

<p>後來學長去查看我們有沒有得獎，沒想到竟然還有！我們有佳作，好開心呀，這樣代表我們可以跟北科領取獎學金了，希望可以領取到拉，每次都覺得學校的行政效率很慢不知道獎學金到底能不能拿到，不過至少現在的我們狀況越來越好了，要繼續保持到 11 月呀，只剩下最後一場大戰 <strong>2020 ICPC TAIWAN　 REIGON</strong></p>
<h2 id="賽後檢討"><a href="#賽後檢討" class="headerlink" title="賽後檢討"></a>賽後檢討</h2><p>對於我參加這次比賽，我將針對幾點進行檢討：</p>
<ul>
<li>檔案整理很重要，我覺得今天檔案管理有點太亂，可以嘗試買一個資料夾管理。</li>
<li>針對每個比賽，要稍微看一下題目規章可以用的 IDE。</li>
<li>5個小時會讓自己的體力明顯不足，比賽的時候需要喝咖啡</li>
<li>滴眼藥水，不然眼睛會模糊</li>
<li>程式碼如果髒了評估後考量，給其他人評估會不會比較適當</li>
<li>適當的在中途進行debug，以免遇到問題</li>
</ul>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>這一次的比賽我並不是主力在負責解題，有點無用武之地，我負責 String，但那題 String 是難題只有一組解開，於是我不敢去嘗試。所以大部分都是在做 Support 的工作，幫助大家手邊的一些雜事，感覺這一次我在做雜事的時候效率並沒有到太好，沒有把雜事分工處理的很優秀，還需要改進。</p>
<p><strong>如果沒辦法成為主力上台打 Code 去 AC 題目，那就要做好 Support 的工作讓前方的主力在需要資源的時候可以最快速的給他不會讓他在思考的過程中還需要翻找答案讓他更加忙碌。我是他的隊友，不是他的敵人。</strong></p>
<p>最後要謝謝家人可以支持我參加演算法這條不歸路，雖然在讀書的過程中家庭沒有辦法讓我完全的去努力準備演算法，總還是有一些事情要溝通，不過還是很感謝自己跟父母可以讓我走到現在，雖然沒有很好的成就但也不是輸的那麼徹底。</p>
]]></content>
      <categories>
        <category>競賽心得</category>
      </categories>
      <tags>
        <tag>大學Life</tag>
        <tag>ICPC</tag>
        <tag>程式比賽</tag>
        <tag>競賽心得</tag>
        <tag>人生旅途</tag>
      </tags>
  </entry>
  <entry>
    <title>QUESTION! 如何在 Hexo or Markdown 插入 youtube 影片呢？</title>
    <url>/2020/10/10/blog/hexo-insert-movie/</url>
    <content><![CDATA[<h2 id="使用-Hexo-or-Markdown-插入影片："><a href="#使用-Hexo-or-Markdown-插入影片：" class="headerlink" title="使用 Hexo or Markdown 插入影片："></a>使用 Hexo or Markdown 插入影片：</h2><blockquote>
<p>此文章教學如何用 Hexo or Markdown 中放入 youtube 影片</p>
</blockquote>
<a id="more"></a>

<h2 id="QUESTION-如何在-Hexo-or-Markdown-插入-youtube-影片呢？"><a href="#QUESTION-如何在-Hexo-or-Markdown-插入-youtube-影片呢？" class="headerlink" title="QUESTION:　如何在 Hexo or Markdown 插入 youtube 影片呢？"></a>QUESTION:　如何在 Hexo or Markdown 插入 youtube 影片呢？</h2><p>把　youtube 的 video id 放入即可，舉例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% youtube video_id %&#125;</span><br></pre></td></tr></table></figure>

<p>video_id 就可以替代成這串 ID， X85DcsKHaUo<br>只要這樣給他就可以搂！</p>
<h2 id="參考連結："><a href="#參考連結：" class="headerlink" title="參考連結："></a>參考連結：</h2><p><a href="https://blog.liaosankai.com/2017/03/21/Hexo%20%E5%82%99%E5%BF%98%E9%8C%84/" target="_blank" rel="noopener">Hexo 備忘錄</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>有了 google 與 hexo 後我可以在 google 搜尋知識並在 hexo 紀錄，謝謝願意再網路上分享知識的各位，沒有你們，我一定沒有辦法讓自己變成現在一樣，肯定比現在還差。我也要努力分享知識，讓其他人可以對於知識更好取得，學得更快。</p>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>TOPC2020 ICPC Asia Taiwan Online Programming Contest - 30th 心得</title>
    <url>/2020/10/11/contest_experence/topc2020/</url>
    <content><![CDATA[<blockquote>
<p>僅此紀錄 2020/10/07 2020 ICPC Asia Taiwan Online Programming Contest 心得<br>「紀錄每個時刻，讓未來的自己不遺忘過去的自己」<br>只有自己才能體會自己的過去<br>僅只有 30th，還需要努力</p>
</blockquote>
<a id="more"></a>

<h2 id="賽前準備"><a href="#賽前準備" class="headerlink" title="賽前準備"></a>賽前準備</h2><p><del>其實根本沒有準備，只是前情概要XD</del><br>統計學下課後，稍微再台北科大第三教學大樓 109 教室準備一下，學長(風平)也過來準備與我一起去買晚餐來吃，不得不說北科往安東街的路上旁邊的公園與大樓真的超漂亮的，途中我們往我最喜歡吃的店<a href="https://www.google.com/search?q=%E5%96%AB%E4%B8%8A%E9%A3%B2&oq=%E5%96%AB%E4%B8%8A%E7%99%AE&aqs=chrome.1.69i57j0i10.11864j0j7&sourceid=chrome&ie=UTF-8" target="_blank" rel="noopener"><strong>喫上飲</strong></a>出發，沒想到她竟然沒開，嗚嗚。不過不能怪他拉，老闆娘在懷孕中不開也是合理的，只能說我沒有福氣可以吃到超級好吃的雞排咖哩飯，真的好想再吃一次！超級好吃的。</p>
<p>建議大家可以去吃，真的棒。但不要在我想吃的時候去吃，這樣讓我要排隊QQ。</p>
<p>由於<a href="https://www.google.com/search?q=%E5%96%AB%E4%B8%8A%E9%A3%B2&oq=%E5%96%AB%E4%B8%8A%E7%99%AE&aqs=chrome.1.69i57j0i10.11864j0j7&sourceid=chrome&ie=UTF-8" target="_blank" rel="noopener"><strong>喫上飲</strong></a>沒開，後來的我跟學長就繼續往安東街在想要吃甚麼，後來就想到好久沒吃的<a href="https://www.google.com/search?sxsrf=ALeKk00Uo0jqi-ozL2j87Hgk6sMkvuHyTg:1602349161886&ei=IueBX6LUDb3FmAWw_IroCQ&q=%E4%BD%90%E8%97%A4%E5%92%96%E5%93%A9&oq=%E4%BD%90%E8%97%A4%E5%92%96%E5%93%A9&gs_lcp=CgZwc3ktYWIQAzIHCCMQ6gIQJzIHCCMQ6gIQJzIHCCMQ6gIQJzIHCCMQ6gIQJzIHCCMQ6gIQJzIHCCMQ6gIQJzIHCCMQ6gIQJzIHCCMQ6gIQJzIHCCMQ6gIQJzIHCCMQ6gIQJzoECAAQRzoFCAAQzQI6BAgjECc6CAgAELEDEIMBOgIIADoECAAQQzoFCAAQsQM6BwgAELEDEEM6CggAELEDEIMBEENQ7-UTWLP0E2Cc9RNoAXACeACAAeADiAG_BZIBBTMuNC0xmAEAoAECoAEBqgEHZ3dzLXdperABCsgBBcABAQ&sclient=psy-ab&ved=2ahUKEwjOo-bkv6rsAhUoyosBHWrQC-4QvS4wAXoECAIQOA&uact=5&npsic=0&rflfq=1&rlha=0&rllag=25032725,121530641,2671&tbm=lcl&rldimm=13616574762961852372&lqi=CgzkvZDol6Tlkpblk6laHgoN5L2Q6JekIOWSluWTqSIN5L2Q6JekIOWSluWTqQ&phdesc=er6MAL0SvX0&rldoc=1&tbs=lrf:!1m4!1u3!2m2!3m1!1e1!1m4!1u2!2m2!2m1!1e1!2m1!1e2!2m1!1e3!3sIAE,lf:1,lf_ui:9&rlst=f#rlfi=hd:;si:6865186108294082278,l,CgzkvZDol6Tlkpblk6laHgoN5L2Q6JekIOWSluWTqSIN5L2Q6JekIOWSluWTqQ,y,Pw2SIZ3QwiA;mv:[[25.044765100000003,121.557935],[25.020686299999998,121.4913793]]" target="_blank" rel="noopener"><strong>佐藤咖哩</strong></a>，這家咖哩我也超喜歡的，超級推。不過由於我們步程較快，他下午 5 點 30 分才開始營業，於是我跟學長稍微聊一下天，等咖哩店營業，看到旁邊有一個肉圓店很有人在排隊，也許下次可以去吃看看呦，我也蠻喜歡吃肉圓的。</p>
<h2 id="比賽開始"><a href="#比賽開始" class="headerlink" title="比賽開始"></a>比賽開始</h2><p>我們還在回來的路上時，學弟(漢軒)就已經吃完晚餐等我們了，我們加緊腳步趕快帶晚餐回 109，當我們回到 109 時已經是比賽前 10 分鐘(17:50)，於是我們就邊吃晚餐邊準備比賽了XD，由於這次比賽是線上比賽所以我們就可以使用 109 的白版來做好我們的題目 MENU 與講解給隊員聽，有一個黑板真的很方便呀。</p>
<p>比賽開始後，漢軒先解決部分題目，漢軒真的好強QQ，他是我們隊伍的中堅呀！學長後來也送出幾題，比賽中非常的順利，我也在解決題目，途中看到一題是屬於我的題目，類型是關於字串的，我就嘗試要把這題給解開，這時候我運用我的演算法知識來解決這題，也順利被我解開了！</p>
<p>但微妙的是，這題只有我被解開，讓我覺得很有成就感XD，連參加過 ICPC world final 的台大都解不開嗎！難道終於可以讓台北科大再度驕傲了嗎(誤，一直到比賽的最後還是只有我把她解開，我的隊友們也都因為這樣而感到興奮，他們讓我講解這題為甚麼我能夠解開，我就告訴他們我怎麼解的，結果學長發現怪怪的，我寫的程式格式跟題目要求的格式不符合但卻可以 AC，我也突然感到意外，我跟隊友們再回去檢查題目卻發現我的程式真的沒有按照題目要求卻被我解開了！</p>
<p>抓到這個錯誤後，我頓時恍然大悟，不是我比其他隊伍優秀，是我比其他隊伍更看不懂英文阿XDDDD，題目說不可以輸出重複的答案，但因為我看不懂英文所以我重複輸出答案可是測資資料的疏忽讓我可以通過這題XD，再根據 TOPC 的規則只要是被送出 AC 的題目就不可以再收回 AC，於是我們還是有算是 AC，沒想到看不懂英文才能看懂題意阿XD，看來英文不好也是個福氣✧(&gt;o&lt;)ﾉ，沒有拉，開玩笑地。英文還是真的很重要，沒有學好英文真的很吃虧，只有這次意外讓我幸運。</p>
<p>比賽結束後，我們的成績是 30th，老實講，這成績對於我們而言是非常好的水準，我們其實從沒想過我們可以到這麼高的名次，希望我們可以好好維持住，讓我們的知識水平繼續維持在這，不要在掉下去，我覺得維持一件事情是非常困難的，因為維持需要耐心與時間，並不是你今天努力就好的。跟我的 blog 一樣，我有耐心維持到現在，也很感謝現在的自己可以為自己付出，也希望未來的自己也可以這麼努力。</p>
<blockquote>
<p>TOPC 比賽名次 30th </p>
</blockquote>
<p><img src="/images/topc2020/1.PNG" alt=""></p>
<h2 id="賽後日誌"><a href="#賽後日誌" class="headerlink" title="賽後日誌"></a>賽後日誌</h2><p>比完賽後，我跟隊員們一起笑我的那題假解，其中不乏出現了許多有趣的名言，例如：「北科英文 &gt; 台大英文」、「小孩子才須要讀好英文，大人都直接通靈題目」之類的有趣玩笑，賽後異常歡樂。真的很開心，好久沒有這麼快樂過了，也好久沒有在演算法這條路上笑得這麼開心了。也許，寫演算法不是為了要讓自己顯得更優秀，而是要從寫演算法的過程中獲得開心與更多創意思維，但由於「比賽」、「學校資源差距」讓我在學習演算法的過程中越來越不開心，今天的意外假解，讓我找回了我為甚麼會這麼努力地在學習演算法的原因。</p>
<p>希望我的演算法能夠越來越強，也能照顧到隊友。讓我的人際、學業、家庭、愛情都可以兼顧好，那應該就是我活著幸福的指標了！</p>
<p>希望我後天的 NCPC2020 final 可以打得漂亮，獲得好成績。</p>
]]></content>
      <categories>
        <category>競賽心得</category>
      </categories>
      <tags>
        <tag>大學Life</tag>
        <tag>ICPC</tag>
        <tag>程式比賽</tag>
        <tag>競賽心得</tag>
        <tag>人生旅途</tag>
      </tags>
  </entry>
  <entry>
    <title>NTUT_Kn1ghts 點點心聚餐</title>
    <url>/2020/10/11/life_experence/Dimdimsum20200920/</url>
    <content><![CDATA[<h2 id="說明"><a href="#說明" class="headerlink" title="說明"></a>說明</h2><blockquote>
<p>記錄我在 2020/09/20 跟參加ICPC 競賽的隊友去餐廳吃飯紀錄<br>謝謝學長(風平) and 學弟(漢軒) 陪我參加這場比賽<br>沒有它們我根本甚麼都沒辦法完成，有他們我才有機會去嘗試夢想</p>
</blockquote>
<a id="more"></a>

<h2 id="出發"><a href="#出發" class="headerlink" title="出發"></a>出發</h2><p>由於學長希望我們隊伍向心力可以更佳凝聚於是請我們去吃頓高級餐廳聊天來增加隊伍的向心力，我們這次吃飯的地點是<a href="https://www.google.com/search?biw=1920&bih=937&sxsrf=ALeKk00uIcLDIAcPQLVWV5rxxC5druh9EQ:1602351132391&ei=IOSBX_ygFvyXr7wPwIOs6AE&q=%E9%BB%9E%E9%BB%9E%E5%BF%83&oq=%E9%BB%9E%E9%BB%9E%E5%BF%83&gs_lcp=CgZwc3ktYWIQAzIECCMQJzICCAAyCAgAELEDEIMBMggIABCxAxCDATIICAAQsQMQgwEyCAgAELEDEIMBMggIABCxAxCDATICCAAyAggAMgIIADoHCCMQ6gIQJzoFCAAQsQM6BAgAEEM6CggAELEDEIMBEENQ4Iu7AVj8l7sBYPKbuwFoAXAAeACAAeUCiAGTCZIBCDEwLjEuMC4xmAEAoAEBqgEHZ3dzLXdperABCsABAQ&sclient=psy-ab&ved=2ahUKEwiisrSQx6rsAhWvxYsBHUzXA1UQvS4wAXoECAMQGg&uact=5&npsic=0&rflfq=1&rlha=0&rllag=25044050,121541722,2564&tbm=lcl&rldimm=1970465232929884137&lqi=Cgnpu57pu57lv4MiA4gBAVoYCgrpu54g6bue5b-DIgrpu54g6bue5b-D&rldoc=1&tbs=lrf:!1m4!1u3!2m2!3m1!1e1!2m1!1e3!3sIAE,lf:1,lf_ui:4&rlst=f#rlfi=hd:;si:13387368021916162519,l,Cgnpu57pu57lv4MiA4gBAVoYCgrpu54g6bue5b-DIgrpu54g6bue5b-D;mv:[[25.0488623,121.571217],[25.0252292,121.49056639999999]]" target="_blank" rel="noopener"><strong>點點心</strong></a>，在網路上評價還蠻不賴的中式料理店，由於信義店可以讓我們訂晚上 7 點的位置但中正店的點點心則不行，於是我們就選擇了信義店用餐，途中我們搭捷運前往點點心信義店。</p>
<p>由於吃飯地點離捷運市政府上最近，於是我們在市政府下車，下車後一往上走就是繁華熱鬧的東區，即使到了晚上也還是燈火通明，不愧是台北的市中心呢！與雖然也是台北的西區就有著些許差別，西區就有點稍微小落後，不過西區的文化與宗教就大於東區了呢。但東區真的好漂亮，蠻令人嚮往的。</p>
<blockquote>
<p>點點心餐廳附近街景</p>
</blockquote>
<p><img src="/images/Dimdimsum20200920/1.jpg" alt=""></p>
<p>途中我們看到一家看似是高級的家具店，裡面的家具與我家簡直是天壤之別阿！我不禁幻想要是我的房間內如果都是這些家具，我一定每天都很期待回家，只要一回家就能夠有好心情。雖然我現在每天也很期待回家，上學好累，讀書更累。ಥ⌣ಥ</p>
<blockquote>
<p>精緻的家具店</p>
</blockquote>
<p><img src="/images/Dimdimsum20200920/2.jpg" alt=""></p>
<h2 id="用餐拉"><a href="#用餐拉" class="headerlink" title="用餐拉"></a>用餐拉</h2><p>我們點了蠻多道菜的XD，詳細菜名已經有點忘記了，但有一道我印象非常深刻叫做龜兔賽跑，他是用兩個不同的包子組成，但價錢卻比單點那兩個不同的包子還貴XDDD，商人手法欸wwww，我把這兩個不同包子組合在一起，再多一個裝飾品就可以增加價錢了，YA。可惡，一定是我太窮了，才會注意到這種小細節，畢竟他們差額只差 30 元，有錢人應該不在意拉XD。</p>
<blockquote>
<p>龜兔賽跑的烏龜</p>
</blockquote>
<p><img src="/images/Dimdimsum20200920/3.jpg" alt=""></p>
<blockquote>
<p>龜兔賽跑的兔兔</p>
</blockquote>
<p><img src="/images/Dimdimsum20200920/5.jpg" alt=""></p>
<blockquote>
<p>只剩下一半的烏龜</p>
</blockquote>
<p><img src="/images/Dimdimsum20200920/4.jpg" alt=""></p>
<p>然後點點心只要是關於蝦子的菜色都點，點爆，超級好吃的、超級讚。點點心的蝦類我超喜歡，然後有一道飯對我而言有點貴而且沒有很好吃QQ，有點小雷。大家可以考慮避開他XD，如果你的口味偏好跟我差不多的話。</p>
<blockquote>
<p>我覺得不好吃的飯與超好吃的蝦蝦</p>
</blockquote>
<p><img src="/images/Dimdimsum20200920/6.jpg" alt=""></p>
<p>豆花很嫩，很好吃，那是我吃過的最棒的豆花之一了，可惜是我覺得分量有點太小一個大男生可能會覺得只是塞牙縫而已，好想用放大燈把豆花變大呀！吃飽喝足後沒想到這一餐價錢要 $2000，對不起學長，讓你破費了，希望我 ICPC 可以好好努力不讓你失望。</p>
<h2 id="飯後漫步"><a href="#飯後漫步" class="headerlink" title="飯後漫步"></a>飯後漫步</h2><p>吃飽後，由於很久沒有來東區逛逛了就在東區的街道上漫步，東區很多高級名牌貨，對於一個沒什麼錢的大學生來說每個包包都像是天價一樣，或許比我的價值還高呢！嗚嗚，我好廉價，我要努力讓我自己的價值提升，怎麼可以比一個包包還要便宜呢，不行啦。</p>
<blockquote>
<p>高級的包包 </p>
</blockquote>
<p><img src="/images/Dimdimsum20200920/7.jpg" alt=""></p>
<p>再往前走已經快要到 101 大樓了，在東區漫步是件很享受的事情，入秋的東區有著微微涼風吹拂，即使漫步也不會流汗，還看到一個很帥的男生在廣告牆上，可惡，他竟然可以讓我走在路上的時候內心直接冒出好帥的想法，難道..難道我比他不好看嗎ಥ⌣ಥ，途中看到某一棟大樓與 101 大樓快要一樣高了，他們兩個大樓是不是在互相較勁，比誰還要高呢XD，哈哈哈，一個工程師的奇怪幻想拉，也許我太小孩子了，才會有這種可愛想法吧！</p>
<blockquote>
<p>廣告牆上很帥的男生</p>
</blockquote>
<p><img src="/images/Dimdimsum20200920/8.jpg" alt=""></p>
<blockquote>
<p>兩棟互相比誰高的大樓</p>
</blockquote>
<p><img src="/images/Dimdimsum20200920/9.jpg" alt=""></p>
<h2 id="返程"><a href="#返程" class="headerlink" title="返程"></a>返程</h2><p>漫步結束後，我們再次回到捷運市政府站準備回家休息，在等車的過程中看到一個很嚇人的廣告呀，現在的廣告不是很嚇人就是很帥，不能來點溫馨的嗎QQ，何況這隻狗很逼真又很嚇人，他知道這對一個怕狗的男生來說可能會讓他連捷運都不敢搭呢ಥ⌣ಥ，明明只是一個狗糧廣告，不要這樣啦…</p>
<blockquote>
<p>很逼真的狗與狗糧廣告</p>
</blockquote>
<p><img src="/images/Dimdimsum20200920/10.jpg" alt=""></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>我很謝謝學長願意為了團隊這樣付出，我覺得學長絕對是支撐起這團隊的最大功臣，願意破費也願意花時間再行政付出，即使這對他可能不會有太多好處他也願意幫助我們這支團隊，我很感謝他。希望我在比賽時不會讓他失望讓他對這團隊的付出是有回報的，那就是我對他的責任。</p>
]]></content>
      <categories>
        <category>人生旅途</category>
      </categories>
      <tags>
        <tag>大學Life</tag>
        <tag>人生旅途</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa10163 - Storage Keepers (Knapsack Problem)</title>
    <url>/2020/10/12/UVa/UVa10163/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>有 X 的倉庫需要有人看守，每個人可以看守多個倉庫，但一個倉庫只能被一人看守，看守的規定如下：<br>每位看守人員的能力值與報酬相同<br>如果要讓一看守人員看多個倉庫則其能力值會依照此公式下降 <strong>\( \text{倉庫安全值} = \text{看守人員能力值} / \text{倉庫數量} \)</strong>，有小數點時取整數。<br>目標是要讓我們花費在看守人員的<strong>報酬最低</strong>並讓倉庫的<strong>安全值最高</strong>。</p>
</blockquote>
<a id="more"></a>

<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>這題是變化背包問題，不懂背包問題的觀眾可以看一下此<a href="https://www.csie.ntu.edu.tw/~sprout/algo2019/ppt_pdf/week09/DP-2-inclass.pdf" target="_blank" rel="noopener">連結</a>，不愧是台大的教學材料，質量好到一個極致阿。要是我高中有找點翻到這個資料我一定可以學得更快！，可惜現在的我已經學會了QAQ，想到過去學動態規劃就覺得好辛苦呀..orz。</p>
<p>不過這題必須要用兩個 DP 來解決…，太棒了！這還是我第一次遇到要用兩個 DP 問題去解決題目，我原本一開始以為用一個背包問題去記錄現在的最大安全就好，但沒有考慮到有可能相同的最大安全可能會有不同種的成本，老了，真的老人。已經不是那個刷題大師了。ಥ⌣ಥ</p>
<p>這題要用到兩個 DP，分別是尋找<strong>報酬最低</strong>與<strong>安全值最高</strong>。</p>
<h2 id="背包問題：安全值最高"><a href="#背包問題：安全值最高" class="headerlink" title="背包問題：安全值最高"></a>背包問題：安全值最高</h2><p>這裡其實應該是一個普通的背包問題，但有一個重點要考慮的是公式 \( \text{倉庫安全值} = \text{看守人員能力值} \ \text{倉庫數量} \)，所以這裡需要用到 <code>min(dp[j-k] , val[i] / k )</code>來確保有符合公式的條件。</p>
<p>而這段 min 程式碼是怎麼意思呢？分析一下吧！</p>
<ul>
<li><code>dp[j-k]</code><br>如果前面沒有的倉庫還沒有還沒有被人看守(沒有被看守設值為 0)，於是用這個去判定倉庫有沒有被人看守，如果沒有會因為 min 的關係把現在這個倉庫也先設定成無人看守。</li>
<li><code>val[i] / k</code><br>配合公式讓一個看守人員去管理多個倉庫</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max_safe</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; N ; i++) <span class="comment">//init</span></span><br><span class="line">        dp[i] = <span class="number">0</span> ;</span><br><span class="line">    dp[<span class="number">0</span>] = INF ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; m ; i++)&#123; <span class="comment">//worker</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = n ; j &gt; <span class="number">0</span> ; j--)&#123; <span class="comment">//storage</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span> ; k &lt;= j &amp;&amp; val[i] &gt;= k ; k++)&#123; <span class="comment">//看守幾個倉庫</span></span><br><span class="line">            <span class="comment">// val[i] &gt;= k 不讓公式的值小於 1</span></span><br><span class="line">                dp[j] = max(dp[j] , min(dp[j-k] , val[i] / k ));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n] ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="背包問題：01-PROBLEM、報酬最低"><a href="#背包問題：01-PROBLEM、報酬最低" class="headerlink" title="背包問題：01 PROBLEM、報酬最低"></a>背包問題：01 PROBLEM、報酬最低</h2><p>當我們已經有了安全值最高後接下來就要找出報酬最低的數值是多少了，這就是標準的 01 背包問題，我們要怎麼樣選擇工人才能達到報酬率最低。配合上一維陣列壓縮即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min_cost</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cost==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span> ; <span class="comment">//由於安全性為 0、題目說明工人成本等於安全性，於是安全性為 0 成本也為 0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= n ; i++) <span class="comment">//init</span></span><br><span class="line">        dp[i] = INF ;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; m ; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = n ; j &gt; <span class="number">0</span> ; j--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = min(j , val[i] / cost ) ; k &gt; <span class="number">0</span> ; k--)&#123;</span><br><span class="line">                dp[j] = min(dp[j] , dp[j-k] + val[i]);</span><br><span class="line">                <span class="comment">//debug</span></span><br><span class="line">                <span class="comment">//cout &lt;&lt; j &lt;&lt; ' ' &lt;&lt; dp[j] &lt;&lt; ' ' &lt;&lt; dp[j-k] + val[i] &lt;&lt; '\n' ;</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n] ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://blog.csdn.net/keshuai19940722/article/details/11861717" target="_blank" rel="noopener">uva 10163 - Storage Keepers(01背包）</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>這題背包問題其實難倒了我了qqq，我一開始寫真的沒有把它想得太深，誤把它當作背包問題的水題帶過(害自己花了 20 min 在思考我怎麼沒有寫對)，下次要能夠多想一點啊！剛好今天也刷了一個經驗值可以讓我在變更優秀些，知道更多知識。也謝謝網路上的大神們分享程式碼讓我可以學習，今天也從<strong>JeraKrs</strong>學習到了一些比我更棒的命名規則，讓我的腦袋瓜有了更多知識，也謝謝學弟(承恩)給我這題讓我磨練，讓我可以把我的動態規劃知識複習一下，已經好久沒有練習動態規劃，都在寫字串演算法，嗚嗚。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>其實就是沒有附上說明的程式碼，我也花了兩個小時撰寫文章，看得懂跟說得出來真的是兩回事，也許還有人覺得我說的很差，不過我已經盡力解釋。希望可以幫助到各位。</p>
<p>也希望大家想要學習的知識都可以快速學習而成，不要因為自身的環境不足而學習不到。</p>
<p>於是這裡就補述一些題目給的資料範圍限制與標頭檔了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 110</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 40</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 1 &lt;&lt; 30</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n , m , dp[N] , val[N] , cost ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max_safe</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; N ; i++)</span><br><span class="line">        dp[i] = <span class="number">0</span> ;</span><br><span class="line">    dp[<span class="number">0</span>] = INF ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; m ; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = n ; j &gt; <span class="number">0</span> ; j--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span> ; k &lt;= j &amp;&amp; val[i] &gt;= k ; k++)&#123;</span><br><span class="line">                dp[j] = max(dp[j] , min(dp[j-k] , val[i] / k ));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n] ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min_cost</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cost==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= n ; i++)</span><br><span class="line">        dp[i] = INF ;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; m ; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = n ; j &gt; <span class="number">0</span> ; j--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = min(j , val[i] / cost ) ; k &gt; <span class="number">0</span> ; k--)&#123;</span><br><span class="line">                dp[j] = min(dp[j] , dp[j-k] + val[i]);</span><br><span class="line">                <span class="comment">//debug</span></span><br><span class="line">                <span class="comment">//cout &lt;&lt; j &lt;&lt; ' ' &lt;&lt; dp[j] &lt;&lt; ' ' &lt;&lt; dp[j-k] + val[i] &lt;&lt; '\n' ;</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n] ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &amp;&amp; (n || m) )&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; m ; i++)</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; val[i] ;</span><br><span class="line">        cost = max_safe() ;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; cost &lt;&lt; <span class="string">' '</span> &lt;&lt; min_cost() &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="用紙筆去模擬-Knapsack-Problem"><a href="#用紙筆去模擬-Knapsack-Problem" class="headerlink" title="用紙筆去模擬 Knapsack Problem"></a>用紙筆去模擬 Knapsack Problem</h2><p>因為只是自己在思考過程中隨手做的筆記，覺得不是對讀者這麼有幫助，因此放在文章最下面。</p>
<p>有時候用想或用看的可能不太能夠懂這演算法，那就用寫的吧！這是大衛我自己解這題動態規劃的手稿，如果我文字沒有幫助的話可以考慮看看我的手稿來釐清觀念XD，希望可以幫助到你。</p>
<p><img src="/images/UVa10163/2.jpg" alt=""><br><img src="/images/UVa10163/1.jpg" alt=""></p>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>背包問題 Knapsack Problem</tag>
        <tag>動態規劃 Dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title>演算法知識 - Suffix Array 後綴陣列</title>
    <url>/2020/10/19/Explain_Algorithm/Suffix-Array/</url>
    <content><![CDATA[<h2 id="Suffix-Array-介紹"><a href="#Suffix-Array-介紹" class="headerlink" title="Suffix Array 介紹"></a>Suffix Array 介紹</h2><blockquote>
<p>對某一字串的所有後綴進行字典排序，常用於全文索引、數據壓縮算法與生物資訊學。<br>這裡介紹的演算法寫法時間複雜度為 \(O(n \log n)\)</p>
</blockquote>
<h2 id="Suffix-Array-原理"><a href="#Suffix-Array-原理" class="headerlink" title="Suffix Array 原理"></a>Suffix Array 原理</h2><p>Suffix Array 主要是用 \(sa\) and \(rk\) 這兩個陣列組合而成。<br>且滿足此性質 \(sa[rk[i]] = rk[sa[i]] = i \)</p>
<p>Suffix Array 圖示說明：<br><img src="/images/Suffix-Array/1.png" alt=""></p>
<h3 id="QUESTION-1-sa-suffix-array-用途是甚麼呢？"><a href="#QUESTION-1-sa-suffix-array-用途是甚麼呢？" class="headerlink" title="QUESTION 1: sa (suffix array) 用途是甚麼呢？"></a>QUESTION 1: sa (suffix array) 用途是甚麼呢？</h3><p>\(sa[i]\) 表示此字串所有後綴排序後第 i 大的 index。</p>
<h3 id="QUESTION-2-rk-rank-array-用途是甚麼呢？"><a href="#QUESTION-2-rk-rank-array-用途是甚麼呢？" class="headerlink" title="QUESTION 2: rk (rank array) 用途是甚麼呢？"></a>QUESTION 2: rk (rank array) 用途是甚麼呢？</h3><p>\(rk[i]\) 表示此字串所有後綴排序後，字串中 index 後綴的排名。</p>
<h3 id="QUESTION-3-甚麼是所有後綴？"><a href="#QUESTION-3-甚麼是所有後綴？" class="headerlink" title="QUESTION 3: 甚麼是所有後綴？"></a>QUESTION 3: 甚麼是所有後綴？</h3><blockquote>
<p>從第 i 個字元開始到最後一個字元的字串，i 的範圍是 string[0] ~ string.length()<br>所有後綴舉例如下，舉例單字為 <strong>apple</strong>：</p>
</blockquote>
<ul>
<li>apple</li>
<li>pple </li>
<li>ple</li>
<li>le</li>
<li>e</li>
</ul>
<a id="more"></a>

<h2 id="Suffix-Array-實現與說明"><a href="#Suffix-Array-實現與說明" class="headerlink" title="Suffix Array 實現與說明"></a>Suffix Array 實現與說明</h2><p>在實現這個做法時需要用到倍增思想。</p>
<h3 id="QUESTION-倍增是甚麼？"><a href="#QUESTION-倍增是甚麼？" class="headerlink" title="QUESTION: 倍增是甚麼？"></a>QUESTION: 倍增是甚麼？</h3><p>倍增是寫程式中經常用到的一種加速程式執行效率的想法之一，通常是把一個問題拆成兩個子問題且這兩個子問題的問題邏輯相同，於是就使用一次寫法來加速效率。</p>
<p>倍增經典範例：<a href="https://oi-wiki.org/math/quick-pow/" target="_blank" rel="noopener">快速冪 OI wiki</a></p>
<h3 id="回歸焦點"><a href="#回歸焦點" class="headerlink" title="回歸焦點"></a>回歸焦點</h3><p>OK，解釋完倍增的想法後就要繼續探討 Suffix Array，我們先對字串中每個字元(長度為\(1\))進行排序，再來我們對字串中以每個字元開始長度為 2 的倍數開始進行排序，這裡我們假設字串除了原先的字元之外，之後的 index 全部都是空字元，方便我們對演算法的編寫。<del>記憶體很大，我們從沒在怕的，科技真讚</del></p>
<p><strong>我們這裡字串的第一個 index 由 1 開始，方便我們程式編寫，建議使用者也這樣做</strong>，只需要在 string A 前面加一空格。</p>
<p>倍增排序圖示說明：<br><img src="/images/Suffix-Array/2.png" alt=""></p>
<p>其中如果黑線只有一條而沒有類似於勾勾的黑線(通常都在字串右方)，可以直接把她想像成此字串後面其實還有字元，但都是「空白字元」，如果這樣假設那讀者勢必會更快理解XD。我自己把她這樣解釋後才能理解，我腦袋真笨QQQQ，雜牌軍日常呀。</p>
<h3 id="基數排序"><a href="#基數排序" class="headerlink" title="基數排序"></a>基數排序</h3><p>如果不懂基數排序可以先看<a href="https://theriseofdavid.github.io/2020/10/20/Explain_Algorithm/radix-sort/" target="_blank" rel="noopener">演算法知識 - Radix Sort 基數排序</a></p>
<p>由於字串比較的時間複雜度是 \(O(n)\)，跟一般數字比較不一樣，因此如果這裡直接使用 STL 函數庫中的 std::sort 會讓此演算法時間複雜度來到 \(O(n \log^2 n)\)，於是這裡推薦使用非比較型排序，<strong>基數排序</strong>，透過這種排序方式來躲開字串的時間比較複雜度才可以讓 Suffix Array 的時間複雜度降到 \(O(n \log n)\)</p>
<p>是不是已經被冗長的文字敘述搞到頭暈了？沒關係，這裡準備了程式碼已經逐行註解，希望可以讓各位讀者都能比我更快速的讀懂 Suffix Array</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> sa[N] , rk[N&lt;&lt;<span class="number">1</span>] , oldrk[N&lt;&lt;<span class="number">1</span>] , id[N] , cnt[N] ;</span><br><span class="line"><span class="comment">// id = 舊的 sa 排名 , cnt 在 radix sort 時幫助</span></span><br><span class="line"><span class="keyword">int</span> n , m , maxn , lenA , lenB , flag =<span class="number">0</span> ;</span><br><span class="line"><span class="comment">// n 字串長度 , m 文字的最大長度</span></span><br><span class="line"><span class="built_in">string</span> strA ;</span><br><span class="line"><span class="comment">// 要進行 suffix array 的字串，請記住這裡的字串第一個 index 為 1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_sa</span><span class="params">()</span></span>&#123; <span class="comment">//build suffix array</span></span><br><span class="line">    <span class="keyword">int</span> i , m , p , w ; </span><br><span class="line">    <span class="comment">// 在這邊把常在迴圈使用的變數名稱拉出來宣告，以避免不斷宣告造成的效率浪費</span></span><br><span class="line">    n = strA.length()<span class="number">-1</span> ; <span class="comment">//減去 string[0] 的空格</span></span><br><span class="line">    m = max(n , <span class="number">300</span> ); <span class="comment">// 由於 ascii 上限是 255，我們這邊直接開 300</span></span><br><span class="line">    <span class="comment">// 也省去把字元 hash 的麻煩</span></span><br><span class="line">    <span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="keyword">sizeof</span>(cnt)); <span class="comment">//重設 cnt 陣列以免多次使用時與上次使用的值混亂在其中</span></span><br><span class="line">    <span class="built_in">memset</span>(rk,<span class="number">0</span>,<span class="keyword">sizeof</span>(rk)); <span class="comment">//重設 rk 陣列以免多次使用時與上次使用的值混亂在其中</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// **** radix sort 排序開始 ****</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span> ; i &lt;= n ; i++) ++cnt[rk[i] = (<span class="keyword">int</span>)strA[i]] ;</span><br><span class="line">    <span class="comment">// rk[i] = (int) strA[i] 每一個字元在字串中排名</span></span><br><span class="line">    <span class="comment">//++cnt[rk[i] = (int)strA[i]] radix sort 分類</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span> ; i &lt;= m ; i++) cnt[i] += cnt[i<span class="number">-1</span>] ; </span><br><span class="line">    <span class="comment">//將 cnt 遞增排序方便之後找出數值排在第幾位</span></span><br><span class="line">    <span class="keyword">for</span>(i = n ; i &gt;= <span class="number">1</span> ; i--) sa[cnt[rk[i]]--] = i ;</span><br><span class="line">    <span class="comment">// cnt[rk[i]] 先找出字元在字串中排名再透過 cnt 找出他應該排在第幾位</span></span><br><span class="line">    <span class="comment">// 隨後進行 cnt[rk[i]]--，方便下一個值得排序位置。</span></span><br><span class="line">    <span class="comment">// **** radix sort 排序結束 ****</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(w = <span class="number">1</span> ; w &lt; n ; w &lt;&lt;= <span class="number">1</span>)&#123; <span class="comment">// 倍增思想開始</span></span><br><span class="line">        <span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="keyword">sizeof</span>(cnt)); <span class="comment">//第一次 radix sort 開始，排序關鍵為後者</span></span><br><span class="line">        <span class="comment">// 最好範例：倍增排序圖中黑色粗線類似於勾勾的斜線，下方解釋 A 圖中</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span> ; i &lt;= n ; i++) id[i] = sa[i] ;</span><br><span class="line">        <span class="comment">// id 用來記錄現在排序的順序，配合這次的 radix sort 再進行更動</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span> ; i &lt;= n ; i++) ++cnt[rk[id[i]+w]] ;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span> ; i &lt;= m ; i++) cnt[i] += cnt[i<span class="number">-1</span>] ;</span><br><span class="line">        <span class="keyword">for</span>(i = n ; i &gt;= <span class="number">1</span> ; i--) sa[cnt[rk[id[i]+w]]--] = id[i] ;</span><br><span class="line">        <span class="comment">// radix sort 與一開始相同，只是多增加 w，因為排序關鍵為後者</span></span><br><span class="line">        <span class="comment">// 第一次 radix sort 結束</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二次 radix sort 開始，排序關鍵為前者</span></span><br><span class="line">        <span class="built_in">memset</span>(cnt, <span class="number">0</span> , <span class="keyword">sizeof</span>(cnt));</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span> ; i &lt;= n ; i++) id[i] = sa[i] ;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span> ; i &lt;= n ; i++) ++cnt[rk[id[i]]] ;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span> ; i &lt;= m ; i++) cnt[i] += cnt[i<span class="number">-1</span>] ;</span><br><span class="line">        <span class="keyword">for</span>(i = n ; i &gt;= <span class="number">1</span> ; i--) sa[cnt[rk[id[i]]]--] = id[i] ;</span><br><span class="line">        <span class="comment">// 第二次 radix sort 結束</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根據 radix sort 在排列一次 rank </span></span><br><span class="line">        <span class="built_in">memcpy</span>(oldrk , rk , <span class="keyword">sizeof</span>(rk)); <span class="comment">//複製 rank 來幫助 rank 間的交換</span></span><br><span class="line">        <span class="keyword">for</span>(p = <span class="number">0</span> , i = <span class="number">1</span> ; i &lt;= n ; i++)&#123; <span class="comment">// p 為 rank 的等級，i 則是資料</span></span><br><span class="line">            <span class="keyword">if</span>(oldrk[sa[i]] == oldrk[sa[i<span class="number">-1</span>]] &amp;&amp; </span><br><span class="line">               oldrk[sa[i] + w] == oldrk[sa[i<span class="number">-1</span>] + w])</span><br><span class="line">               <span class="comment">//如果與前一個 rank 值是相同則理應現在應該也要相同</span></span><br><span class="line">               <span class="comment">//最好範例：倍增排序圖示說明第一次排序的 rank[4~7], index 從 1 開始，</span></span><br><span class="line">               <span class="comment">//下方解釋 B 圖中</span></span><br><span class="line">                rk[sa[i]] = p ; <span class="comment">//rank 字典排序不變</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                rk[sa[i]] = ++p ; <span class="comment">//rank 字典排序增加</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//debug 輸出測試，以驗證是否正確</span></span><br><span class="line"><span class="comment">//    cout &lt;&lt; "Suffix Array is:\n" ;</span></span><br><span class="line"><span class="comment">//    for(int i = 1 ; i &lt;= n ; i++)&#123;</span></span><br><span class="line"><span class="comment">//        cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; strA.substr(sa[i]) &lt;&lt; ' ' &lt;&lt;sa[i] &lt;&lt; '\n' ;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>解釋 A 圖<br><img src="/images/Suffix-Array/3.PNG" alt=""></li>
<li>解釋 B 圖<br><img src="/images/Suffix-Array/4.PNG" alt=""></li>
</ul>
<h2 id="最長共同前綴-Longest-Common-Prefix-Array-LCP"><a href="#最長共同前綴-Longest-Common-Prefix-Array-LCP" class="headerlink" title="最長共同前綴 Longest Common Prefix Array (LCP)"></a>最長共同前綴 Longest Common Prefix Array (LCP)</h2><p>定義 height = Longest Common Prefix Array<br>道理其實相當簡單，我們的 Suffix Array 是字典排序，於是我們可以推出一公式 \(height[i] = lcp(sa[i],sa[i-1]\)，也就是讓第 i 名的後綴去跟前一名後綴算出最長共同前綴。</p>
<p>\(height[1] = 0\)，由於我們的 string index 是從 1 開始，所以 1 只能夠跟 0 比無意義因而設成 0。</p>
<p>因為 height 他每個 index 都是獨立並沒有相關性，我們的比較方式是根據字串中的每個後綴由字串 index 順序，去找出他的 sa -1 位置去找出 lcp 長度，下一次則是找 index +1 的後綴與他的 sa-1 位置去找出 lcp 長度，由於比較的字串只是刪除上一個前綴的第一個字元，於是 lcp 長度最差則是 lcp -1(前提為 lcp &gt; 0)，所以可以直接從 index + lcp 的長度直接比較，可以減少重複比較，以達到降低時間複雜度。</p>
<p>時間複雜度是 \(O(n)\)。</p>
<p>如果還是聽不太懂，感覺有點紙上談兵，就讓我用程式碼來解釋吧！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_lcp</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lcp[N] = &#123;&#125; ;</span><br><span class="line">    <span class="keyword">int</span> max_lcp = <span class="number">0</span> ; <span class="comment">// max_lcp 最大長度</span></span><br><span class="line">    <span class="comment">//k 為現在 i 名的後綴與前一名後綴長度算出的最長共同前綴</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> , k = <span class="number">0</span> ; i &lt;= n ; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(k) k-- ; </span><br><span class="line">        <span class="comment">// 由於我們下次是把字串 index 在往後一個 index，所以 lcp 最差的情況則會是 x-1</span></span><br><span class="line">        <span class="comment">// 因為其實要比較的字串只是刪除上一個後綴的第一個字元</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(strA[i+k] == strA[sa[rk[i]<span class="number">-1</span>]+k]) ++k ;</span><br><span class="line">        <span class="comment">//比較順序較為特殊，因為他每個陣列都可以分開進行討論，</span></span><br><span class="line">        <span class="comment">//於是我們比較字串的 index 開始的後綴與他的 sa 前一項找出 lcp</span></span><br><span class="line">        <span class="comment">// strA[i] = 字串的 index 開始的後綴</span></span><br><span class="line">        <span class="comment">// strA[sa[rk[i]-1]] = 字串的 index 開始的後綴的 sa 前一項</span></span><br><span class="line">        <span class="comment">// while 裡面的 +k 則是減少重複比較，如果上次的 lcp 已經找出長度為 x 的 lcp</span></span><br><span class="line"></span><br><span class="line">        lcp[rk[i]] = k ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>((sa[i] &lt; lenA &amp;&amp; sa[i<span class="number">-1</span>] &lt; n+<span class="number">1</span> &amp;&amp; sa[i<span class="number">-1</span>] &gt; lenA ) ||</span><br><span class="line">            (sa[i] &gt; lenA &amp;&amp; sa[i<span class="number">-1</span>] &lt; n+<span class="number">1</span> &amp;&amp; sa[i<span class="number">-1</span>] &lt; lenA))</span><br><span class="line">            max_lcp = max(max_lcp , lcp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上，Suffix Array 與 LCP 到此介紹結束，謝謝各位不嫌棄我的文筆閱讀到此。</p>
<h2 id="Suffix-Array-應用"><a href="#Suffix-Array-應用" class="headerlink" title="Suffix Array 應用"></a>Suffix Array 應用</h2><p>我在學習此演算法的過程中如果有題目讓我應用到此演算法我則收錄在此，連結則是我的詳解如果想要去看題目的就搜尋一下吧！</p>
<h3 id="最長共同前綴-Longest-Common-Prefix-Array"><a href="#最長共同前綴-Longest-Common-Prefix-Array" class="headerlink" title="最長共同前綴 Longest Common Prefix Array"></a>最長共同前綴 Longest Common Prefix Array</h3><ul>
<li><a href="https://theriseofdavid.github.io/2020/10/19/UVa/UVa760/" target="_blank" rel="noopener">UVa 760</a></li>
</ul>
<h2 id="參考連結："><a href="#參考連結：" class="headerlink" title="參考連結："></a>參考連結：</h2><p><a href="https://oi-wiki.org/math/quick-pow/" target="_blank" rel="noopener">快速冪 OI wiki</a><br><a href="https://turing13.com/2017/06/03/uva-760-dna-sequencing/" target="_blank" rel="noopener">UVa 760 – DNA Sequencing</a><br><a href="https://blog.csdn.net/ld_lin/article/details/52344384" target="_blank" rel="noopener">常用ASCII码详细对照表 （0—255）</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>學習演算法真的是 CP 值不高又很浪費時間的東西呢(無誤XD)，除了 ACM ICPC 之外，你很難知道甚麼時候可以用到，又或者當你想用時卻已經忘記怎麼用了，也有可能到時已經有現成套件可以用，那你為甚麼還要學習演算法呢？</p>
<p>因為有趣，可以增加思維，我自認我從演算法學習到了許多不同新事物，透過演算法來認識這個世界，這些演算法都是優秀的電腦科學家研究出來，透過他們的思維來引道我來看待事物，我相信，會讓我變得更加優秀。</p>
<p>也希望我在學習演算法的路上可以更加優秀，不被打倒，學習速度更快更容易讓我獲得新知識擴展自己腦袋的世界觀，也同時保持著舊有知識不遺忘。</p>
<p>最後要感謝 OI WIKI，他讓對於英文不好的我可以有更多機會去接觸演算法，將各個演算法收錄在此且無私的開放給大家學習，讓我有機會可以學習到此演算法。</p>
<p>也謝謝我自己的努力付出，即使我沒有機會成為一個優秀的人但或許可以成為他人的基礎吧XD。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>其實就是沒有附上說明的程式碼，我也花了三個小時撰寫文章，看得懂跟說得出來真的是兩回事，也許還有人覺得我說的很差，不過我已經盡力解釋。希望可以幫助到各位。</p>
<p>也希望大家想要學習的知識都可以快速學習而成，不要因為自身的環境不足而學習不到。</p>
<p>於是這裡就補述一些變數宣告與資料範圍限制與標頭檔了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 2000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sa[N] , rk[N&lt;&lt;<span class="number">1</span>] , oldrk[N&lt;&lt;<span class="number">1</span>] , id[N] , cnt[N] ;</span><br><span class="line"><span class="keyword">int</span> n , m  ;</span><br><span class="line"><span class="built_in">string</span> strA ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_sa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i , m , p , w ;</span><br><span class="line">    n = strA.length()<span class="number">-1</span> ;</span><br><span class="line">    m = max(n , <span class="number">300</span> );</span><br><span class="line">    <span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="keyword">sizeof</span>(cnt));</span><br><span class="line">    <span class="built_in">memset</span>(rk,<span class="number">0</span>,<span class="keyword">sizeof</span>(rk));</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span> ; i &lt;= n ; i++) ++cnt[rk[i] = (<span class="keyword">int</span>)strA[i]] ;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span> ; i &lt;= m ; i++) cnt[i] += cnt[i<span class="number">-1</span>] ;</span><br><span class="line">    <span class="keyword">for</span>(i = n ; i &gt;= <span class="number">1</span> ; i--) sa[cnt[rk[i]]--] = i ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(w = <span class="number">1</span> ; w &lt; n ; w &lt;&lt;= <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="keyword">sizeof</span>(cnt));</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span> ; i &lt;= n ; i++) id[i] = sa[i] ;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span> ; i &lt;= n ; i++) ++cnt[rk[id[i]+w]] ;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span> ; i &lt;= m ; i++) cnt[i] += cnt[i<span class="number">-1</span>] ;</span><br><span class="line">        <span class="keyword">for</span>(i = n ; i &gt;= <span class="number">1</span> ; i--) sa[cnt[rk[id[i]+w]]--] = id[i] ;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(cnt, <span class="number">0</span> , <span class="keyword">sizeof</span>(cnt));</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span> ; i &lt;= n ; i++) id[i] = sa[i] ;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span> ; i &lt;= n ; i++) ++cnt[rk[id[i]]] ;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span> ; i &lt;= m ; i++) cnt[i] += cnt[i<span class="number">-1</span>] ;</span><br><span class="line">        <span class="keyword">for</span>(i = n ; i &gt;= <span class="number">1</span> ; i--) sa[cnt[rk[id[i]]]--] = id[i] ;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memcpy</span>(oldrk , rk , <span class="keyword">sizeof</span>(rk));</span><br><span class="line">        <span class="keyword">for</span>(p = <span class="number">0</span> , i = <span class="number">1</span> ; i &lt;= n ; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(oldrk[sa[i]] == oldrk[sa[i<span class="number">-1</span>]] &amp;&amp;</span><br><span class="line">               oldrk[sa[i] + w] == oldrk[sa[i<span class="number">-1</span>] + w])</span><br><span class="line">                rk[sa[i]] = p ;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                rk[sa[i]] = ++p ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//debug</span></span><br><span class="line"><span class="comment">//    cout &lt;&lt; "Suffix Array is:\n" ;</span></span><br><span class="line"><span class="comment">//    for(int i = 1 ; i &lt;= n ; i++)&#123;</span></span><br><span class="line"><span class="comment">//        cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; strA.substr(sa[i]) &lt;&lt; ' ' &lt;&lt;sa[i] &lt;&lt; '\n' ;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_lcp</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lcp[N] = &#123;&#125; ;</span><br><span class="line">    <span class="keyword">int</span> max_lcp = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> , k = <span class="number">0</span> ; i &lt;= n ; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(k) k-- ;</span><br><span class="line">        <span class="keyword">while</span>(strA[i+k] == strA[sa[rk[i]<span class="number">-1</span>]+k]) ++k ;</span><br><span class="line">        lcp[rk[i]] = k ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="用紙筆去模擬-Suffix-Array-and-LCP"><a href="#用紙筆去模擬-Suffix-Array-and-LCP" class="headerlink" title="用紙筆去模擬 Suffix Array and LCP"></a>用紙筆去模擬 Suffix Array and LCP</h2><p>因為只是自己在思考過程中隨手做的筆記，覺得不是對讀者這麼有幫助，因此放在文章最下面。</p>
<p>有時候用想或用看的可能不太能夠懂這演算法，那就用寫的吧！這是大衛我自己學習的手稿，紀錄者我的學習過程。</p>
<p><img src="/images/Suffix-Array/5.jpg" alt=""><br><img src="/images/Suffix-Array/6.jpg" alt=""></p>
]]></content>
      <categories>
        <category>演算法知識</category>
      </categories>
      <tags>
        <tag>程式解題</tag>
        <tag>字串處理</tag>
        <tag>演算法知識</tag>
        <tag>最長共同前綴 Longest Common Prefix Array</tag>
        <tag>Suffix Array</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa760 - DNA Sequencing (最長共同前綴 Longest Common Prefix)</title>
    <url>/2020/10/19/UVa/UVa760/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>給你兩組字串，想請你找出裡面其中最長的共同子字串，如果有複數最長的子字串則透過字典序輸出。</p>
<p>注意：這題的輸出格式有特別要求</p>
</blockquote>
<a id="more"></a>

<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>這題使用 Suffix Array 來找出最長共同前綴 Longest Common Prefix 是我認為最理想的解法，將兩組字串結合後透過 Suffix Array 的後綴排序來找出最長共同前序可以有效的把此問題給解決。</p>
<p>如果不懂 Suffix Array or Longest Common Prefix 可以參考此<a href="https://theriseofdavid.github.io/2020/10/19/Explain_Algorithm/Suffix-Array/" target="_blank" rel="noopener">演算法說明</a>，因為我的這演算法說明基本上是用此題進行範例，我想會加速你再學習的腳步，如果我的寫作可以讓你好理解的話XD。</p>
<p>學會了 Suffix Array 與理解 LCP 原理後就可以把這題解決掉了！</p>
<h2 id="焦點回到題目上，解開題目的小設計"><a href="#焦點回到題目上，解開題目的小設計" class="headerlink" title="焦點回到題目上，解開題目的小設計"></a>焦點回到題目上，解開題目的小設計</h2><h3 id="QUESTION-題目是要找出兩組字串中最長的共同子字串，跟-LCP-有甚麼關係呢？"><a href="#QUESTION-題目是要找出兩組字串中最長的共同子字串，跟-LCP-有甚麼關係呢？" class="headerlink" title="QUESTION : 題目是要找出兩組字串中最長的共同子字串，跟 LCP 有甚麼關係呢？"></a>QUESTION : 題目是要找出兩組字串中最長的共同子字串，跟 LCP 有甚麼關係呢？</h3><p>當你把兩組字串結合成一組字串後透過 Suffix Array + LCP 的特性就可以找出相似前綴，舉個例子好了：<br>有兩組字串 atgc , tga，我們用兩個比英文小寫字母還小的符號去連接他們則 Suffix Array 看起來會像這樣：<br>merge string : <strong>atgc$tga#</strong><br>Suffix Array is:</p>
<table>
<thead>
<tr>
<th>index</th>
<th>string</th>
<th>sa[i]</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>#</td>
<td>9</td>
</tr>
<tr>
<td>2</td>
<td>$tga#</td>
<td>5</td>
</tr>
<tr>
<td>3</td>
<td>a#</td>
<td>8</td>
</tr>
<tr>
<td>4</td>
<td>atgc$tga#</td>
<td>1</td>
</tr>
<tr>
<td>5</td>
<td>$tga#</td>
<td>4</td>
</tr>
<tr>
<td>6</td>
<td>ga#</td>
<td>7</td>
</tr>
<tr>
<td>7</td>
<td>gc$tga#</td>
<td>3</td>
</tr>
<tr>
<td>8</td>
<td>tga#</td>
<td>6</td>
</tr>
<tr>
<td>9</td>
<td>tgc$tga#</td>
<td>2</td>
</tr>
</tbody></table>
<p>是不是知道 LCP 怎麼用了，對吧！<del>不知道該打</del></p>
<p>之後透過 sa[i] 的值查詢他們分布在哪個位置，如果兩個都分布在 \($\) 字號前面則代表他們其實都是第一組字串的子字串，並不是我們要的答案，反之如果都分布在 \($\) 字號後面亦是如此。但如果其中一個在 \($\) 字號前面而另一個在 \($\) 和 # 字號的中間就代表這兩組字串都有此子字串這就是我們要的答案！P.S. # 字號似乎沒辦法給他 mathjax</p>
<p>於是第一次迴圈先找出 max_lcp，第二次迴圈找出長度等於 max_lcp 的子字串輸出。 </p>
<p>值得需要小注意的就是題目有要求我們要用字典序輸出，但由於 Suffix Array 特性已經幫我們做好所以我們就不需要特別在留意，但還是需要注意到有可能會是重複輸出，即此子字串可能在兩個字串中都重複兩次，所以需要用 map 來檢查。</p>
<p>如果還是不懂就讓我用程式碼來輔助吧！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 找出 max_lcp 的長度</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>((sa[i] &lt; lenA &amp;&amp; sa[i<span class="number">-1</span>] &lt; n+<span class="number">1</span> &amp;&amp; sa[i<span class="number">-1</span>] &gt; lenA ) ||</span><br><span class="line">        (sa[i] &gt; lenA &amp;&amp; sa[i<span class="number">-1</span>] &lt; n+<span class="number">1</span> &amp;&amp; sa[i<span class="number">-1</span>] &lt; lenA))</span><br><span class="line">        <span class="comment">// 檢查結合的 string 共同前綴是不是都是同一個題目字串的</span></span><br><span class="line">        max_lcp = max(max_lcp , lcp[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 輸出長度等於 max_lcp 的子字串</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; mp ;</span><br><span class="line"><span class="keyword">if</span>(max_lcp == <span class="number">0</span>) <span class="comment">//如果是 0 就輸出題目要求格式</span></span><br><span class="line">    &#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"No common sequence.\n"</span> ; <span class="keyword">return</span> ;&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>((sa[i] &lt; lenA &amp;&amp; sa[i<span class="number">-1</span>] &lt; n+<span class="number">1</span> &amp;&amp; sa[i<span class="number">-1</span>] &gt; lenA ) ||</span><br><span class="line">       (sa[i] &gt; lenA &amp;&amp; sa[i<span class="number">-1</span>] &lt; n+<span class="number">1</span> &amp;&amp; sa[i<span class="number">-1</span>] &lt; lenA))</span><br><span class="line">       <span class="comment">// 檢查結合的 string 共同前綴是不是都是同一個題目字串的</span></span><br><span class="line">       <span class="keyword">if</span>(lcp[i] == max_lcp)&#123;</span><br><span class="line">            <span class="built_in">string</span> temp = strA.substr(sa[i] , max_lcp);</span><br><span class="line">            <span class="keyword">if</span>(mp[temp]) <span class="keyword">continue</span> ; <span class="comment">//檢查有沒有重複輸出</span></span><br><span class="line">            <span class="keyword">else</span> mp[temp] = <span class="number">1</span> ; <span class="comment">//紀錄已經被輸出過</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; temp &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>強烈建議搭配<a href="https://theriseofdavid.github.io/2020/10/19/Explain_Algorithm/Suffix-Array/" target="_blank" rel="noopener">演算法知識 - Suffix Array 後綴陣列</a>，裡面的程式碼基本上都是配合這題而寫的非常建議讀者學會。</p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://oi-wiki.org/math/quick-pow/" target="_blank" rel="noopener">快速冪 OI wiki</a><br><a href="https://turing13.com/2017/06/03/uva-760-dna-sequencing/" target="_blank" rel="noopener">UVa 760 – DNA Sequencing</a><br><a href="https://blog.csdn.net/ld_lin/article/details/52344384" target="_blank" rel="noopener">常用ASCII码详细对照表 （0—255）</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>這題的學習難度好高阿…，這題我應該總讀書時間應該有高達 8 小時了吧ಥ⌣ಥ！嗚嗚，我真笨，希望我未來在學習演算法的路上狀況可以越來越好，也可以磨練好我自學的能力，這很重要，讀書基本上只需要百分之 20% 與老師溝通剩下的都是需要學生自己去摸索探討，希望我未來可以找到好老師讓我成長，在我自學學到盲點時可以幫助我一把。</p>
<p>題外話，CSDN 與大陸資源真的是我學習的主要材料呀，大陸在於資訊的知識比起台灣多蠻多的，這樣也讓我在自學演算法的路上輕鬆了些很謝謝大家都願意把技術下放給我們這些菜鳥。</p>
<p>補足我身心的缺陷，讓我更加優秀、生活更加快樂應該是我人生中的其中一個目的吧！XD</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>其實就是沒有附上說明的程式碼，我也花了兩個小時撰寫文章，看得懂跟說得出來真的是兩回事，也許還有人覺得我說的很差，不過我已經盡力解釋。希望可以幫助到各位。</p>
<p>也希望大家想要學習的知識都可以快速學習而成，不要因為自身的環境不足而學習不到。</p>
<p>於是這裡就補述一些題目給的資料範圍限制與標頭檔了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 2000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">string</span> strA=<span class="string">""</span> , strB=<span class="string">""</span> , strC=<span class="string">""</span> ;</span><br><span class="line"><span class="keyword">int</span> sa[N] , rk[N&lt;&lt;<span class="number">1</span>] , oldrk[N&lt;&lt;<span class="number">1</span>] , id[N] , cnt[N] ;</span><br><span class="line"><span class="keyword">int</span> n , m , maxn , lenA , lenB , flag =<span class="number">0</span> ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_sa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i , m , p , w ;</span><br><span class="line">    n = strA.length()<span class="number">-1</span> ;</span><br><span class="line">    m = max(n , <span class="number">300</span> );</span><br><span class="line">    <span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="keyword">sizeof</span>(cnt));</span><br><span class="line">    <span class="built_in">memset</span>(rk,<span class="number">0</span>,<span class="keyword">sizeof</span>(rk));</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span> ; i &lt;= n ; i++) ++cnt[rk[i] = (<span class="keyword">int</span>)strA[i]] ;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span> ; i &lt;= m ; i++) cnt[i] += cnt[i<span class="number">-1</span>] ;</span><br><span class="line">    <span class="keyword">for</span>(i = n ; i &gt;= <span class="number">1</span> ; i--) sa[cnt[rk[i]]--] = i ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(w = <span class="number">1</span> ; w &lt; n ; w &lt;&lt;= <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="keyword">sizeof</span>(cnt));</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span> ; i &lt;= n ; i++) id[i] = sa[i] ;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span> ; i &lt;= n ; i++) ++cnt[rk[id[i]+w]] ;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span> ; i &lt;= m ; i++) cnt[i] += cnt[i<span class="number">-1</span>] ;</span><br><span class="line">        <span class="keyword">for</span>(i = n ; i &gt;= <span class="number">1</span> ; i--) sa[cnt[rk[id[i]+w]]--] = id[i] ;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(cnt, <span class="number">0</span> , <span class="keyword">sizeof</span>(cnt));</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span> ; i &lt;= n ; i++) id[i] = sa[i] ;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span> ; i &lt;= n ; i++) ++cnt[rk[id[i]]] ;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span> ; i &lt;= m ; i++) cnt[i] += cnt[i<span class="number">-1</span>] ;</span><br><span class="line">        <span class="keyword">for</span>(i = n ; i &gt;= <span class="number">1</span> ; i--) sa[cnt[rk[id[i]]]--] = id[i] ;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memcpy</span>(oldrk , rk , <span class="keyword">sizeof</span>(rk));</span><br><span class="line">        <span class="keyword">for</span>(p = <span class="number">0</span> , i = <span class="number">1</span> ; i &lt;= n ; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(oldrk[sa[i]] == oldrk[sa[i<span class="number">-1</span>]] &amp;&amp;</span><br><span class="line">               oldrk[sa[i] + w] == oldrk[sa[i<span class="number">-1</span>] + w])</span><br><span class="line">                rk[sa[i]] = p ;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                rk[sa[i]] = ++p ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//debug</span></span><br><span class="line"><span class="comment">//    cout &lt;&lt; "Suffix Array is:\n" ;</span></span><br><span class="line"><span class="comment">//    for(int i = 1 ; i &lt;= n ; i++)&#123;</span></span><br><span class="line"><span class="comment">//        cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; strA.substr(sa[i]) &lt;&lt; ' ' &lt;&lt;sa[i] &lt;&lt; '\n' ;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_lcp</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lcp[N] = &#123;&#125; ;</span><br><span class="line">    <span class="keyword">int</span> max_lcp = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> , k = <span class="number">0</span> ; i &lt;= n ; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(k) k-- ;</span><br><span class="line">        <span class="keyword">while</span>(strA[i+k] == strA[sa[rk[i]<span class="number">-1</span>]+k]) ++k ;</span><br><span class="line">        lcp[rk[i]] = k ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>((sa[i] &lt; lenA &amp;&amp; sa[i<span class="number">-1</span>] &lt; n+<span class="number">1</span> &amp;&amp; sa[i<span class="number">-1</span>] &gt; lenA ) ||</span><br><span class="line">            (sa[i] &gt; lenA &amp;&amp; sa[i<span class="number">-1</span>] &lt; n+<span class="number">1</span> &amp;&amp; sa[i<span class="number">-1</span>] &lt; lenA))</span><br><span class="line">            max_lcp = max(max_lcp , lcp[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//debug</span></span><br><span class="line"><span class="comment">//    cout &lt;&lt; "max_lcp is " &lt;&lt; max_lcp &lt;&lt; '\n' ;</span></span><br><span class="line"><span class="comment">//    for(int i = 0 ; i &lt;= n ; i++)</span></span><br><span class="line"><span class="comment">//        cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; lcp[i] &lt;&lt; '\n' ;</span></span><br><span class="line"><span class="comment">//    cout &lt;&lt; "lenA =" &lt;&lt; lenA &lt;&lt; "\nn is" &lt;&lt; n &lt;&lt; '\n' ;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(flag)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    flag = <span class="number">1</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; mp ;</span><br><span class="line">    <span class="keyword">if</span>(max_lcp == <span class="number">0</span>)</span><br><span class="line">        &#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"No common sequence.\n"</span> ; <span class="keyword">return</span> ;&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>((sa[i] &lt; lenA &amp;&amp; sa[i<span class="number">-1</span>] &lt; n+<span class="number">1</span> &amp;&amp; sa[i<span class="number">-1</span>] &gt; lenA ) ||</span><br><span class="line">           (sa[i] &gt; lenA &amp;&amp; sa[i<span class="number">-1</span>] &lt; n+<span class="number">1</span> &amp;&amp; sa[i<span class="number">-1</span>] &lt; lenA))</span><br><span class="line">           <span class="keyword">if</span>(lcp[i] == max_lcp)&#123;</span><br><span class="line">                <span class="built_in">string</span> temp = strA.substr(sa[i] , max_lcp);</span><br><span class="line">                <span class="keyword">if</span>(mp[temp]) <span class="keyword">continue</span> ;</span><br><span class="line">                <span class="keyword">else</span> mp[temp] = <span class="number">1</span> ;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; temp &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">           &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> );</span><br><span class="line">    <span class="comment">//freopen("out.txt" , "w" , stdout );</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; strA &gt;&gt; strB)&#123;</span><br><span class="line">        lenA = strA.length()+<span class="number">1</span>;</span><br><span class="line">        lenB = strB.length();</span><br><span class="line">        strA = <span class="string">' '</span> + strA + <span class="string">'$'</span> + strB + <span class="string">'#'</span> ;</span><br><span class="line">        <span class="comment">//debug</span></span><br><span class="line">        <span class="comment">//cout &lt;&lt; "strA is " &lt;&lt;strA &lt;&lt; "\nstrA.length() is " &lt;&lt; strA.length() &lt;&lt; '\n' ;</span></span><br><span class="line"></span><br><span class="line">        build_sa();</span><br><span class="line">        build_lcp();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>字串處理</tag>
        <tag>Suffix Array</tag>
        <tag>最長共同前綴 Longest Common Prefix</tag>
      </tags>
  </entry>
  <entry>
    <title>由於語言隔閡造成我被外國人怒罵</title>
    <url>/2020/04/11/life_experence/language-barrier-by-foreigner/</url>
    <content><![CDATA[<h2 id="說明"><a href="#說明" class="headerlink" title="說明"></a>說明</h2><blockquote>
<p>記錄我在 2020/10/18 與外籍學生(越南)由於語言隔閡造成我被怒罵<br>透過了這次事件讓我成長了許多<br>深刻的經驗會讓我學習到更多知識也會補足我的缺點<br>由於目前在風頭上，我期望大約在兩個月後再將此日期改回正確日期，現在先不讓人這麼容易找到免得吵架</p>
</blockquote>
<a id="more"></a>

<h2 id="事件描述"><a href="#事件描述" class="headerlink" title="事件描述"></a>事件描述</h2><p>2020/10/18 (六) 我跟一同陪與我參加 ICPC 演算法的外籍學生一同讀書練習演算法，事件大概可以分成兩部分描述。</p>
<h2 id="scold-怒罵-1-金錢分配事件"><a href="#scold-怒罵-1-金錢分配事件" class="headerlink" title="scold(怒罵) 1 金錢分配事件 :"></a>scold(怒罵) 1 金錢分配事件 :</h2><p>晚上我們在北科學餐吃飯，我像學長分享我們資財系對於比賽經費較充裕肯願意將經費花費在學生身上，但資工系則沒有，以及資財系主任跟我分享再開學校大會時電資學院院長則直接說出他們在<a href="https://theriseofdavid.github.io/2020/07/08/contest_experence/ncut2020-experience/" target="_blank" rel="noopener">科大競賽2020</a>中獲得金獎時，然後說到資工經費並沒有下放給學生，我認為這是一個非常可怕的問題是，外籍學生直接對我進行怒罵，怒罵內容如下：「這是資工系主任給我的經費(1000)，我為甚麼要分給 3 個人，你(資財)拿到的錢(1600)也沒有分阿，你如果分給 3 個人那我也就分給 3 個人阿」。</p>
<h3 id="My-Thoughts-我的想法-："><a href="#My-Thoughts-我的想法-：" class="headerlink" title="My Thoughts(我的想法)："></a>My Thoughts(我的想法)：</h3><p>莫名其妙。</p>
<p>我不懂為甚麼當我在跟他講 A 時他竟然拿 B 事情跟我吵，莫名其妙，我本來的個性就很注重公平這件事情，外籍學生並不是不知道我的個性可是他竟然拿這件事情跟我吵架，這讓我非常傻眼，當下的反應是：「??? 我是在跟你講這件事情嗎」，我想可能是我的遣詞用句讓他誤會了吧？</p>
<p>不過從另外一個角度來想，當時的我的語氣是沒有具有惡意的，就算他誤會了但他理應要從我的語氣中判斷現在的我是具有惡意還是善意，竟然直接怒罵，讓我百思不得其解，莫名其妙的被罵，到現在我竟然還沒有一點悔意，這還是我第一次感覺沒做錯事的罵得這麼莫名其妙。</p>
<h3 id="self-criticize-自我檢討-："><a href="#self-criticize-自我檢討-：" class="headerlink" title="self-criticize(自我檢討)："></a>self-criticize(自我檢討)：</h3><p>語言是很重要的，外國人學習語言固然辛苦，但我認為語氣則大致上是相同的，兩個互相不懂彼此的語言但一定可以透過語氣得知對話是開心還是難過或是痛苦，外籍學生直接怒罵我，讓我得知一件重要性，如果我認為外國人踩到我的底線，我必須先判斷是不是語言所造成的誤會，在看他是不是開我玩笑，從他的語氣去判斷，在考慮我是否要不要生氣。</p>
<p>不過這讓我覺得外籍學生的內心素質教育其實並沒有台灣的好，遇到衝突是先選擇暴力解決，雖然沒有選擇打架但是選擇了言語暴力個人還是覺得不太好的，要是每個人都這樣社會怎麼進步，這世界只剩下衝突沒有包容。</p>
<h2 id="scold-怒罵-2-語言的請教："><a href="#scold-怒罵-2-語言的請教：" class="headerlink" title="scold(怒罵) 2 語言的請教："></a>scold(怒罵) 2 語言的請教：</h2><p>晚上我們在北科的教室讀書，途中我向他聊到韓國有韓文、英國有英文、日本有日文、中國有中文、越南是用羅馬拼音，那越南之前用的文字是甚麼？而外籍學生則說：「你現在是不是瞧不起越南，越南人戰勝敵人美國多強，你們台灣人打敗仗，台灣是國家嗎？你們台灣人現在能這樣還不是國民黨帶黃金才發展起來的，你懂歷史嗎？你讀的歷史有比我多嗎，你英文好嗎，你奧林匹亞有打得比我優秀嗎？」(用一張非常瞧不起的臉看著我)</p>
<h3 id="y-Thoughts-我的想法-："><a href="#y-Thoughts-我的想法-：" class="headerlink" title="y Thoughts(我的想法)："></a>y Thoughts(我的想法)：</h3><p>在一次莫名其妙。</p>
<p>不過這個可能我能體會？這種感覺讓我覺得有點像是中國某些特定愛國極端人士會說的話，由於自卑所以需要去怒罵別人講別人缺點才能讓自己在當下獲得優越感以保持自我尊嚴，這種感覺八。</p>
<p>我在日本讀書時我個人沒有發生過這種情況，我覺得在日本雖然我覺得我在某些情況下我會被受到歧視，但我認為那是事實沒必要去爭辯，只要好好努力去做好當下我應該要去做的事情即可。畢竟這是國家的事，我能改變甚麼？我只不過是一個學生，連自己生存的意義都還沒找到，就為了國家的事情再跟其他國家人爭論，就算爭贏了能夠贏的對方內心的想法嗎？我想不會，我被他怒罵後我只覺得他這個人好暴力、好沒素質，如果要用一句話形容就是希特勒的感覺吧，只看的到自己想看的視角。</p>
<p>不過透過他的怒罵後，我似乎可以得知有時候這種人的禮貌都是表面禮貌，講的話都很官腔對我而言有點太虛偽了，這種人必須跟他保持適當距離並且爬得比他還高，在他想要傷害別人時先阻止他，不然這個世界只會越來越暴力，我想有可能變成南越跟北越一樣吧。</p>
<p>我不想從他的怒罵中反駁，這沒意義。生氣改變不了事實，那何必生氣？大方承認有很難嗎？更何況我根本就不是在嘲笑你，你就自己突然破口大罵，蠻可憐的愛國思想吧。這種人就是炸彈，你不知道他甚麼時候會爆炸，具傷害性。如果他是我的敵人我會非常喜歡。</p>
<h3 id="self-criticize-自我檢討-：-1"><a href="#self-criticize-自我檢討-：-1" class="headerlink" title="self-criticize(自我檢討)："></a>self-criticize(自我檢討)：</h3><p>英文很重要，不然會被別人怒罵說自己英文不好呦，恩當下的結論。</p>
<p>沒有拉，開玩笑地。避免跟外國人講他們國家的事情，特別是越南，當他們如果講他們國家怎樣你就隨便應付就好在搞得好像自己很喜歡他們國家之後適當保持距離，除非你能保證他的文化素質夠高，不會因為別人的某個舉動就直接破口大罵、降低自己的國格，連一個不是國的台灣人都可以比他有素質，真為我自己慶幸我不是生存在那個環境下長大，不然我真的會瘋掉。</p>
<p>如果喜歡越南那就適著把越南改變得更好而不是對一個學生怒罵，這樣很像 1980 時的作風，如果再 2020 但人民素質卻還在 1980 時只能顯現出自己的無知吧。</p>
<p>不過我還是有學到東西的，對於極端政權的國家盡量不談政治、不講他們不好，以免他們生氣，為達到表面上的和平以及減少自己的麻煩這樣做我想應該是最好的，雖然說他們會自我肥大起來，不過這不會是我去解決的事情，有更多的學生現在正在學習這樣的知識，我只要做好我的螺絲釘，找尋自己的生存意義較為實際些。</p>
<h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><ul>
<li>對於外國人友善、包容，拿出人的氣度</li>
<li>當外國人讓你不舒服時，先看他是有意還是無意的</li>
<li>盡量對極端政權的人民只說好話，並跟他們保持距離，除非你能認為他們的文化素養夠高</li>
<li>讓自己優秀，以免當世界被極端政權征服時自己沒辦法出來抗爭，只剩服從的義務，連權利都不算。</li>
</ul>
<p>以上四點，要好好記住呀大衛！對你來說應該是很重要的。</p>
<p>然後我等等就先去跟那外籍學生說抱歉吧，只是還要想要怎麼抱歉，真的好麻煩，明明不是我的錯卻還要道歉，後來想想當個極端政權的人民好可憐，要因為一件他改變不了的事情而生氣，那我就勉為其難地為了我能改變的了得事情去改變吧！加油，大衛！</p>
]]></content>
      <categories>
        <category>人生旅途</category>
      </categories>
      <tags>
        <tag>大學Life</tag>
        <tag>人生旅途</tag>
      </tags>
  </entry>
  <entry>
    <title>演算法知識 - 基數排序 Radix Sort</title>
    <url>/2020/10/20/Explain_Algorithm/radix-sort/</url>
    <content><![CDATA[<h2 id="Radix-Sort-介紹與應用"><a href="#Radix-Sort-介紹與應用" class="headerlink" title="Radix Sort 介紹與應用"></a>Radix Sort 介紹與應用</h2><blockquote>
<p>Radix Sort 與我們一般常見的比較排序不同，採用分配式排序法(透過特定方式將值分別放入不同的  array)，Radix Sort 是特殊的整數排序法，Radix Sort 是根據每一位的數值放入相對應的 index。</p>
<p>時間複雜度為 \(O(dn)\)</p>
</blockquote>
<a id="more"></a>

<h2 id="Radix-Array-原理"><a href="#Radix-Array-原理" class="headerlink" title="Radix Array 原理"></a>Radix Array 原理</h2><p>這裡用數字來舉範例，假設要排序的數值有：(1, 254 ,6932 ,24 )</p>
<ul>
<li>先創建 10 個 queue，因為數字主要是透過 0~9 組合</li>
<li>從個位數開始進行排序，假設個位數是 1，則放入 queue[1] </li>
<li>從 queue[0] ~ queue[9] 開始依序將數值取出來並依序存入陣列</li>
<li>再來從十、百、千…位數開始進行排序，重複第二點及以下動作，直到沒有數值大於的位數。</li>
</ul>
<h3 id="名詞解釋："><a href="#名詞解釋：" class="headerlink" title="名詞解釋："></a>名詞解釋：</h3><ul>
<li>位數<br>指數字中某一特定數字字元(一個數字)所在的位置。EX:個位數、百分位</li>
</ul>
<h3 id="QUESTION-為甚麼是從個位數開始進行排序？"><a href="#QUESTION-為甚麼是從個位數開始進行排序？" class="headerlink" title="QUESTION: 為甚麼是從個位數開始進行排序？"></a>QUESTION: 為甚麼是從個位數開始進行排序？</h3><p>如果從最大位數開始進行排序，會出現 8 &gt; 126，變成了字典排序而不是順序排序，在百分位與十分位時都沒有問題，但到個分位時會變成 8 在比較後面的 queue，導致排序不正確。排序成 (126,8)</p>
<p><strong>從最小位數開始依序排序，因為數學排序的邏輯是先根據位數進行排序才根據個數進行排序，</strong><br>而 Radix Sort 排序則是權重越不高先排序，如果從最大位數排序則會變成字典順序。</p>
<h2 id="Radix-Sort-實作與說明"><a href="#Radix-Sort-實作與說明" class="headerlink" title="Radix Sort 實作與說明"></a>Radix Sort 實作與說明</h2><p>找出數列中最大的數，只要位數比他還小就直接跳出迴圈，剩下就與原理相同，直接在程式碼進行說明。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num[<span class="number">10</span>] = &#123;<span class="number">24</span>,<span class="number">6239</span> ,<span class="number">249</span> , <span class="number">465935</span> , <span class="number">4353</span> ,<span class="number">543</span> , <span class="number">9352</span> ,<span class="number">2154</span> , <span class="number">953</span> , <span class="number">3952</span>&#125; ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">radix_sort</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; buckets[<span class="number">10</span>] ; <span class="comment">// 創建存放位置</span></span><br><span class="line">    <span class="comment">// 如果是 0-9 就創建 10，A-Z(特別指大寫)就創建 26</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span> ,j = <span class="number">1</span> ; <span class="comment">// j 用來找出現在的位數</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++) k = max(num[i] , k );</span><br><span class="line">    <span class="comment">// k = 找出數列最大值 </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(k/j)&#123; <span class="comment">//檢測還有沒有數值大於我們現在當下要檢測的位數</span></span><br><span class="line">        <span class="comment">// 如果沒有就代表已經檢測、排序完畢</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++) <span class="comment">//將位數的值依序放入不同的 queue</span></span><br><span class="line">            buckets[(num[i] /j)%<span class="number">10</span>].push(num[i]); </span><br><span class="line">            <span class="comment">//(num[i] /j)%10 找出當下位數的數值(一個數字)</span></span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span> ; <span class="comment">//p 排序位數的標準</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!buckets[i].empty())&#123; <span class="comment">//直到這個 queue 沒有任何數字</span></span><br><span class="line">                num[p++] =buckets[i].front(); <span class="comment">// 將根據此位數排序的值放回 num 中</span></span><br><span class="line">                <span class="comment">// p++ 準備讓下一個值放入下一個位置</span></span><br><span class="line">                buckets[i].pop(); <span class="comment">//已經被放入 num 所以退出</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        j *= <span class="number">10</span>; <span class="comment">// 找下一個位數</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span> ;i++) <span class="comment">// 輸出答案，檢測是否正確</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">' '</span> &lt;&lt; num[i] &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="放一份乾淨無註解的程式碼在此，方便讀者直接拿來使用"><a href="#放一份乾淨無註解的程式碼在此，方便讀者直接拿來使用" class="headerlink" title="放一份乾淨無註解的程式碼在此，方便讀者直接拿來使用"></a>放一份乾淨無註解的程式碼在此，方便讀者直接拿來使用</h2><p>程式碼如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num[<span class="number">10</span>] = &#123;<span class="number">24</span>,<span class="number">6239</span> ,<span class="number">249</span> , <span class="number">465935</span> , <span class="number">4353</span> ,<span class="number">543</span> , <span class="number">9352</span> ,<span class="number">2154</span> , <span class="number">953</span> , <span class="number">3952</span>&#125; ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">radix_sort</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; buckets[<span class="number">10</span>] ; </span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span> ,j = <span class="number">1</span> ; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++) k = max(num[i] , k );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(k/j)&#123; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++) </span><br><span class="line">            buckets[(num[i] /j)%<span class="number">10</span>].push(num[i]); </span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span> ; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!buckets[i].empty())&#123; </span><br><span class="line">                num[p++] =buckets[i].front();</span><br><span class="line">                buckets[i].pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        j *= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span> ;i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">' '</span> &lt;&lt; num[i] &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://rust-algo.club/sorting/radix_sort/" target="_blank" rel="noopener">基數排序 Radix sort</a><br><a href="https://dreamisadream97.pixnet.net/blog/post/168570825-radix-sort-%28%E5%9F%BA%E5%BA%95%E6%8E%92%E5%BA%8F%E6%B3%95%29" target="_blank" rel="noopener">radix sort (基底排序法)</a><br><a href="https://magiclen.org/radix-sort/" target="_blank" rel="noopener">基數排序法</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>老實講我排序學的沒有很多呀XD，那時候在比賽只練過幾個最有名氣的排序法後就直接去學習其他演算法，但當我學到 <a href="(https://theriseofdavid.github.io/2020/10/19/Explain_Algorithm/Suffix-Array/)">Suffix Array</a>，卻發現自己不懂這個演算法阿阿阿阿阿，<del>自己真爛</del>。幸好有 Suffix Array 幫我補足過去的知識，由於我的演算法並不是透過專業的老師訓練而成，80% 都是透過我的自學而成，但自學有個很大的問題就是，容易基礎不紮實，很有可能在學到進階演算法時還要再回來補過去基礎。</p>
<p>不過沒關係，我會努力完成演算法的知識，我覺得學習演算法是一件很有趣的事情，它可以增加我的很多思維在我人生中都有稍微用到的時候，不敢說幫助很大，但至少學習的過程是不會後悔的。也希望我可以在參加 ICPC 時可以獲得好的名次，給予自己更大的信心與動力。</p>
]]></content>
      <categories>
        <category>演算法知識</category>
      </categories>
      <tags>
        <tag>程式解題</tag>
        <tag>演算法知識</tag>
        <tag>基數排序 Radix Sort</tag>
      </tags>
  </entry>
  <entry>
    <title>惠特產學合作心得與紀錄</title>
    <url>/2020/10/30/life_experence/fittech_experence/</url>
    <content><![CDATA[<blockquote>
<p>僅此紀錄大衛大一下至大二上參加惠特科技產學合作心得。<br>「紀錄每個時刻，讓未來的自己不遺忘過去的自己」<br>只有自己才能體會自己的過去<br>謝謝惠特副總經理與洪揮霖老師與官齊笎陪伴我成長。</p>
</blockquote>
<a id="more"></a>

<h2 id="自我反省"><a href="#自我反省" class="headerlink" title="自我反省"></a>自我反省</h2><p>老實講，在我做產學合作時其實我並沒有想要做 Blog 紀錄所以有很多部分可能已經在我的印象中遺失，蠻對不起未來的大衞的…，那就讓現在當下的我把僅剩的印象記錄下來吧，不然這份回憶可能就被我丟失在成長的路上了。</p>
<h2 id="惠特的初次見面"><a href="#惠特的初次見面" class="headerlink" title="惠特的初次見面"></a>惠特的初次見面</h2><p>在大一上時，我滿腔熱血但我卻不知道要怎麼樣發展，台北科大的老師們可能不太擅長去找出幾個比較有想法的學生來幫助他成長，<del>對不起，我又黑北科</del>，可是我真的覺得北科的老師有些真的很混，以後可以多一篇文章來描述此事情。講太多了，回歸正題，那時候我的系上學長(方宇)問我要不要來參加專案，再有內推的關係之下果不其然我就進入了這次的產學合作XD。</p>
<p>人脈真的要打好，但能力一定要有。沒有能力只有人脈就像人力仲介一樣，我不想當那樣的人。</p>
<p>之後惠特公司副總就來到北科與我們說明這次的產學合作有 3 個專案，分別來讓北科的學習去嘗試與實習，我選擇的是專題一，聽起來我較有把握去解決此題目，對我而言我對這題的方向感也比起其他兩題的方向感更為踏實些。</p>
<h2 id="專案實踐-初期"><a href="#專案實踐-初期" class="headerlink" title="專案實踐 - 初期"></a>專案實踐 - 初期</h2><p>專案一(資料內插)，主要是給我們一個已經遺失的圖片(其實不是圖片是LED，但這樣講可能不太好懂，以下我就用圖片來講)，遺失率可能達到 80%，我們試著用 Laplace Interpolation (資料內插) 的方式來解決此問題。</p>
<p>一開始我們知道要用 Laplace Interpolation 來解決問題，聽起來很專業對不對？但其實還好主要就是有 15 個方程式去解決此問題。</p>
<blockquote>
<p>Laplace Interpolation 介紹</p>
</blockquote>
<p><img src="/images/fittech_experence/1.jpg" alt=""></p>
<p>但我們就算知道了題目的要求與需求我們還是不知道要怎麼去解決它，<del>對不起我就爛</del>，主要是因為我們的背景知識不足，線性代數、理論與證明…等，導致我們初期是一直在想要用自己的方式去把這題給完成，但實在是沒辦法完成，一個孩子哪有辦法蓋好一棟大房子，在我們百思不得其解時，就慢慢進入惠特第二次來北科督察的時候…。</p>
<p>第二次來北科督察後，惠特副總人很好他並沒有因為我們不會這些背後的理論而給予我們壓力，他給了我們一些解決的想法，讓我們去從中想出如何解出這題，也在這次的會議中提點我們當自己無法解決此能力時，先去外面爬一些相關資料，再根據一些相關資料找出其相關的論文。於是一開始她告訴我們像解決此問題時我們可以使用<strong>高斯消去法</strong>來解決相關問題。</p>
<h2 id="專案實踐-中期"><a href="#專案實踐-中期" class="headerlink" title="專案實踐 - 中期"></a>專案實踐 - 中期</h2><p>既然已經被別人提點了，那我理應要透過別人提點的方法去嘗試，於是我就先試寫了一遍高斯消去法並自行測試，測試成功後，在詢問惠特公司的數據最大量是多少，多少我已經有點記不得了(當時沒有紀錄，可惡)，當最普通的高斯消去法是一定沒有辦法解決的，必須要再去找出更好的方法。</p>
<p>既然我已經知道要去找出更好的方法，那就是先去 google 一些比起高斯消去法效率更好的解法，在 google 中得知 Gauss-Seidel 方法比起高斯消去法效率更好，高斯消去法是 \(O(n^5)\)， Gauss-Seidel 方法則是 \(O(n^3)\)。</p>
<p>我知道方法後，我就要去實踐它，但這時候遇到一些麻煩點，我不知道怎麼實踐QQ，我雖然知道這方法也懂這方法在做甚麼，理論跟證明也都大概了解，但當我要把它寫成程式時我卻卡關，只好再問問 google 有沒有 Gauss-Seidel 的舉例，讓我可以更好了解。我有一個壞毛病，光看理論與證明通常我的腦袋還不太會有想法去怎麼實踐他，但只要給我範例我就有辦法去實踐它，很奇怪吧！但我透過舉例的學習能力真的比看證明的學習能力還強許多，可能我應該要讀台北工專吧XD。</p>
<blockquote>
<p>數值線性方程式演算法介紹       </p>
</blockquote>
<p><img src="/images/fittech_experence/2.jpg" alt=""></p>
<p>後來在 Google 那個衣櫃翻資料時找到一個非常棒的網站，此網站縮寫是<strong>MAA(美國數學協會)</strong>，他們有著非常詳細的說明與講解來增加大家對於數學的知識，他們超棒、超讚，我一看完他們的教學在配上我自己動手寫一遍，我馬上就完全理解 Gauss-Seidel 幸好有他們這個網站加速我學習的速度，不然我可能還要再 Google 這個雜亂衣櫃找到有用的資訊可能還要再花一段時間XD，不過 Google 真的很棒，沒他我連沒有用的資訊都找不到呢！</p>
<p>我原本是要在這邊放上我自己手寫 Gauss-Seidel 的圖片，但是那時候自己還沒有意識到紀錄的重要性，我很難過。</p>
<p>其實專題二原本是另一位學長製作但他可能太忙了就沒有來接手此問題，於是我希望齊笎來幫助我們解決這次的大問題，齊笎直接肯定與願意幫助我的問題讓我超級感動的 ಥ⌣ಥ，齊笎真的是我的最佳幫手，從高中如果還沒有在中途就遺失的朋友真的都是真心的，幸好我身邊還有一堆好朋友願意幫助我。齊笎願意來扛下第二題的重責大任並且也負責第一題的介面，再跟他討論第一題的介面時我是快樂的、相處起來也是，加上他的 UI 介面設計功能算蠻不錯用，真的是辛苦她了，沒有他我一定要做得更辛苦甚至有可能做不好。</p>
<blockquote>
<p> 齊笎的背影照</p>
</blockquote>
<p><img src="/images/fittech_experence/12.jpg" alt=""></p>
<p>原本這裡應該是要放下跟他一起的合照的，但我發現我竟然沒有跟他合照，看來我太不喜歡拍照了之後要好好補足這個能力，拜科技之賜社會在進步我的思想卻沒有進步，自己也太差了吧XD。</p>
<h2 id="專案實踐-後期"><a href="#專案實踐-後期" class="headerlink" title="專案實踐 - 後期"></a>專案實踐 - 後期</h2><p>其實中間遇到兩個大麻煩，一個是陣列沒辦法開那麼大，這裡我們假設陣列應該要開到 8000*8000 但是 C# 裡面其實是沒有辦法開到這麼大的，所以翻找了許多技術文章來解決此問題，這裡就不贅述翻找資料的痛苦了，如果也有夥伴們像我一樣遇到問題可以查看此文章 <a href="https://theriseofdavid.github.io/2020/06/16/C_sharp/C-sharp-big-array/" target="_blank" rel="noopener">C# 開超大陣列解決方法</a>。</p>
<p>另一個問題則是個人認為 Gauss-Seidel 方法可能還是有些許的慢，還想要更加增進自己，於是我自己就上網再去問問 Google 有沒有更好的解答，答案是有，要用 <strong>SOR(逐次超鬆馳法)</strong>，以下就簡稱 SOR，它可以幫助我們效率在更加提升，加速收斂，但有要特別注意的點就是 \(\omega \) 必須要找好不然就可能沒辦法有很好的收斂效果。</p>
<blockquote>
<p>SOR(逐次超鬆馳法) 方法介紹</p>
</blockquote>
<p><img src="/images/fittech_experence/3.jpg" alt=""></p>
<p>隨後我們就去實踐它，發現真的有更好的效果，當下真的是充滿喜悅，透過自己的雙手去完成一件事情，不敢說自己做的是很優秀的事，但總感覺自己完成了一件原本自己並不太懂的東西真的是很令人振奮呢！學會每一件事情都會讓自己的視野更加遼闊，但就像我 Blog 說的 <strong>After climbing a great hill, one only finds that there are many more hills to climb.</strong>，看來還有很多的 hills 等待我去攀爬。</p>
<blockquote>
<p>Gauss-Seidel 在此專題中的時間複雜度，請注意，這裡的陣列遺失率並不一定等於 50%</p>
</blockquote>
<p><img src="/images/fittech_experence/4.jpg" alt=""></p>
<blockquote>
<p>SOR(逐次超鬆馳法) 在此專題中的時間複雜度，請注意，這裡的陣列遺失率並不一定等於 50%</p>
</blockquote>
<p><img src="/images/fittech_experence/5.jpg" alt=""></p>
<p>有些比較細心的讀者應該有看到為甚麼 PPT 的陣列遺失率並不一定等於 50 % 呢，其實很簡單，因為我是對陣列每一個元素隨機 1~100 ，只要是偶數就遺失奇數就表示存在，所以在<strong>最理想</strong>情況遺失機率應該是 50%。</p>
<h2 id="參觀台中公司"><a href="#參觀台中公司" class="headerlink" title="參觀台中公司"></a>參觀台中公司</h2><p>過程中我們要去台中惠特公司參訪，老師讓我先去訂車，我打了好多通電話都沒有預約到車，好難過…，幸好最後還是有預約到車，不然我就尷尬呢我XD，於是我們預約到車後就等待參訪時間來臨，前往台中其實並不算塞，但屁股還是有點坐到痛痛的，沒想到台中工業區與台中高鐵站有相當長的一段時間，原本還想說先到台中高鐵站在搭計程車就好，老師決定租車直接前往惠特公司果然是正確的選擇，我還是有點太年輕了QQ，用台北的思維看台灣呀，不過過程中有跟老師聊天也是相當開心的一件事情。</p>
<p>惠特公司貼著一排關於業務以及認真表現員工的嘉許，總覺得那看起來就是用自己的辛苦堆疊起來的，很偉大呀！</p>
<p>我們有點太早到惠特科技，我們先坐在會議室裏面吃午餐，隨後等待惠特工作人員來像我們介紹公司，他們有分研發部門與生產部門，研發部門我蠻有興趣的，有種讓我眼睛突然亮起來，而到他們的生產部門時則看到許多機台正在努力運作一點都不會累，<del>機器怎麼會累</del>，看著那些高精密儀器又聽到他們的價錢時，心裡想著：「天啊，我這輩子能不能賺到這麼多錢呢？」，希望我自己有能力可以變成優秀的人，幫助別人也可以養活自己，不然連自己都養不活有點沒用呀！</p>
<p>回來的過程到新竹時則有點塞，原因是新竹的工程師都正準備下班，恩，我聞到整條高速公路都是台灣生產著的味道呢XD，開玩笑的，大家都為了自己的夢想或現實在努力的工作吧！我以後應該也會成為這樣的人度過一生吧，希望我能做出些幫助到大家的事情，不管是認識或是不認識的那是再好不過的！</p>
<blockquote>
<p>在參訪回程時隨意拍的一張照片</p>
</blockquote>
<p><img src="/images/fittech_experence/6.jpg" alt=""></p>
<p>由於我們租車的時間過長，為甚麼會過長呢？因為我誤算來回時間導致我們要離開惠特公司時是 15:30，但我們租車結束的時間是 21:00，這點我還需要再<strong>改進</strong>，不然就會像這次一樣浪費經費，讓我很對不起大家，為了拖長租車時間於是我們就讓老師和每位學生都可以在自己的住所附近直接下車，有楊梅、鶯歌與北科，沒想到楊梅－鶯歌這一段特別塞車，有點討厭呀！</p>
<h2 id="專案後期-報告"><a href="#專案後期-報告" class="headerlink" title="專案後期 - 報告"></a>專案後期 - 報告</h2><p>在昨天，也就是 2020/10/29，即將接近專案結案，於是我們要報告目前進度，專題一的進度目前接近於成熟，但專案二礙於技術問題不斷遇到障礙還需要克服就比較麻煩了，專題二就花了蠻多的時間在講解理論與探討，而專案一則就是 PPT 報告與實際 demo，由於我對此專案有很深的了解，<del>畢竟是我做的XD</del>，我就把我的心得與技術全部都說出，當我講出 C# 如何開出超大陣列時副總有說出一句「我這一趟沒有白來」時，我的內心是非常開心與擁有成就感的，能夠被大公司的副總經理給認同這對一個大學生來說是有多大的榮幸呀！</p>
<blockquote>
<p>專題二老師與副總正在講解與理論與探討 (第一張，共二張)</p>
</blockquote>
<p><img src="/images/fittech_experence/10.jpg" alt=""></p>
<blockquote>
<p>專題二老師與副總正在講解與理論與探討 (第二張，共二張)</p>
</blockquote>
<p><img src="/images/fittech_experence/11.jpg" alt=""></p>
<blockquote>
<p>應用程式介紹 - 輸入資料</p>
</blockquote>
<p><img src="/images/fittech_experence/8.jpg" alt=""></p>
<blockquote>
<p>應用程式介紹 - 輸入完成</p>
</blockquote>
<p><img src="/images/fittech_experence/9.jpg" alt=""></p>
<p>在過程中副總也與我們閒聊了一些，關於我們學習的觀念，有些部分與我的經驗相同有些則我還需要去磨練可能才能理解，最有共鳴的應該就是<strong>做中學</strong>，只要去實踐一次就肯定能懂那些高深的理論在講甚麼，理解之後就能存在自己的記憶中在需要時被提出，但我報告也有部分缺失，例如 Gauss-Seidel 的 inverse 我並沒有講的很好，這點我還需要特別注意，下次再報告時不要對自己太有信心，還是要把所有的理論仔細地都檢查一次才不會讓<strong>自己之前看得懂，現在看不懂的窘境</strong>。</p>
<p>不知為何，被副總稱讚是一件令人開心的事情，可能是我的努力被肯定了吧XD。</p>
<blockquote>
<p>我沒有講好的部分，紅色圈圈的部分</p>
</blockquote>
<p><img src="/images/fittech_experence/7.PNG" alt=""></p>
<p>而我還需要在做一些專案一的驗證與調整，例如我們的矩陣要改成可以掃描圓形，並不要只能掃描正方形，以及驗證，但我相信應該是沒有問題的。</p>
<p>其中也要謝謝胡小姐過程中可以幫我許多忙，這一路上要是沒有他，我在行政上的問題會非常棘手，真的要謝謝他幫助我許多事情，我原本還怕因為我是大學生可能還會被瞧不起QQ，但其實不會的！他人最好，YA。</p>
<h2 id="對自己說的話"><a href="#對自己說的話" class="headerlink" title="對自己說的話"></a>對自己說的話</h2><p>原本是想寫些心得的，但其實這整篇都是我的心得也都是我的心路歷程，硬是要在心得裡面再寫些心得似乎有點太多於了，不如就寫點加油的話來對自己增加信心吧！</p>
<p>在這路上有學到蠻多知識的，但我發現我的知識都是破碎不完全，我可能會是知道這個概念，但我不知道這個專有名詞是甚麼，這是我的一個大問題，我需要去改進。也謝謝自己的努力可以讓我一路堅持到這裡，也希望我自己可以繼續努力，現在放棄就輸了，只要我對我的未來好，那現在就會好！</p>
<p>感謝在此產學合作中幫助過我的每一個人，沒有你們就沒有現在的我，謝謝你們幫助我更好，謝謝！</p>
<h2 id="附加檔案"><a href="#附加檔案" class="headerlink" title="附加檔案"></a>附加檔案</h2><p><a href="https://drive.google.com/file/d/177h1DF0Zc4YsdLKJEPb5uWLHF0dvMD1g/view?usp=sharing" target="_blank" rel="noopener">專案一期末報告</a><br><a href="https://drive.google.com/file/d/1Trv-hVrCShLBD_nhSaQORkx1B3pEqX8r/view?usp=sharing" target="_blank" rel="noopener">專案一期中報告</a></p>
]]></content>
      <categories>
        <category>人生旅途</category>
      </categories>
      <tags>
        <tag>大學Life</tag>
        <tag>產學合作</tag>
        <tag>人生旅途</tag>
      </tags>
  </entry>
  <entry>
    <title>QUESTION! 如何回到之前的 commit 版本呢？</title>
    <url>/2020/10/31/git/git-reset-to-commit/</url>
    <content><![CDATA[<h2 id="文章大意："><a href="#文章大意：" class="headerlink" title="文章大意："></a>文章大意：</h2><blockquote>
<p>如果發現最後一次的 commit 並不是最好的版本，想要回去之前的版本要如何做比較好？</p>
</blockquote>
<a id="more"></a>


<h2 id="QUESTION-如何回到之前的-commit-版本呢？"><a href="#QUESTION-如何回到之前的-commit-版本呢？" class="headerlink" title="QUESTION! 如何回到之前的 commit 版本呢？"></a>QUESTION! 如何回到之前的 commit 版本呢？</h2><p>先用 <code>git log --oneline</code> 在找出自己想要復原的版本輸入 <code>git reset --soft XXXXXX</code> 就可以成功復原了，其中<code>XXXXXX</code> 是 <code>git log --oneline</code> 所出來前面的數字則是我們想要復原哪個版本的要求之一。</p>
<p>這裡是應該指令的集中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git log --oneline</span><br><span class="line">git reset --soft XXXXXX</span><br></pre></td></tr></table></figure>

<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://blog.poychang.net/git-how-to-remove-file-and-commit-from-history/" target="_blank" rel="noopener">移除 Git 歷史紀錄</a><br><a href="https://gitbook.tw/chapters/branch/how-git-know-what-current-branch-is.html" target="_blank" rel="noopener">【冷知識】Git 怎麼知道現在是在哪一個分支？</a></p>
<h2 id="心得："><a href="#心得：" class="headerlink" title="心得："></a>心得：</h2><p>git 真的好好用XD，但我是自學的基礎不穩，很多東西都是需要用到才會學，基礎不穩阿，要好好多讓自己嘗試找到缺失之處，然後補足。才可以讓自己獨當一面！</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>演算法知識 - Suffix Automaton 後綴自動機</title>
    <url>/2020/10/31/Explain_Algorithm/suffix-automaton/</url>
    <content><![CDATA[<h2 id="Suffix-Automaton-介紹"><a href="#Suffix-Automaton-介紹" class="headerlink" title="Suffix Automaton 介紹"></a>Suffix Automaton 介紹</h2><blockquote>
<p>Suffix Automaton，簡稱 SAM，(以下內文都簡稱 SAM)，是一個能解決許多字串特定問題的資料結構。</p>
<p>只要關於這兩個字串問題都可以使用 \(O(n)\) 時間複雜度解決：</p>
<ul>
<li>在另一個字串中查詢另一個字串的所有出現位置</li>
<li>計算此字串中裡面有多少不同的子字串</li>
</ul>
<p>簡單來說 SAM 可以理解成字串壓縮，一個 SAM 最多只會有 \(2n-1\) 個節點與 \(3n-4\) 個轉移邊。</p>
<p><strong>建立 SAM 的時間複雜度為 \(O(n)\)</strong></p>
<p>此文章跳開蠻多理論與證明，如果想要知道可再從下方參考連結點選即可</p>
</blockquote>
<a id="more"></a>

<h2 id="Suffix-Automaton-原理"><a href="#Suffix-Automaton-原理" class="headerlink" title="Suffix Automaton 原理"></a>Suffix Automaton 原理</h2><p>需要用到 struct，此 struct 需要 len , link , next，這些的意義為：</p>
<ul>
<li>len 目前的最長長度</li>
<li>link 為當前子字串中第一個<strong>最長</strong>後綴結束位置 </li>
<li>next 連結其他的點的邊，方向是 -&gt;</li>
</ul>
<h3 id="Suffix-Automaton-圖示說明："><a href="#Suffix-Automaton-圖示說明：" class="headerlink" title="Suffix Automaton 圖示說明："></a>Suffix Automaton 圖示說明：</h3><p>我們假設此字串為 “aabbabd”，下方圖片的線為：</p>
<ul>
<li>link 為綠色線</li>
<li>next 為藍色線</li>
<li>len 從起點到終點的最長長度</li>
</ul>
<blockquote>
<p>我們感謝一下畫這張圖的大神，不得不說話的超棒</p>
</blockquote>
<img src="/images/suffix-automaton/1.png" style="border:2px black solid;">

<h3 id="重大的三個特性"><a href="#重大的三個特性" class="headerlink" title="重大的三個特性"></a>重大的三個特性</h3><ul>
<li>跟著<font color="#0000FF">藍色線</font>走到終點時會是必定是 “aabbabd” 的後綴</li>
<li>跟著<font color="#0000FF">藍色線</font>走到任意點必定會是此字串的子字串</li>
<li>發明這個的演算法大師太強了，跟神一般的存在</li>
</ul>
<p><del>好啦，其實是兩個，但是沒有第三個前面兩個都不會成立XD</del><br>根據這張圖大概就能夠理解後綴自動機在說甚麼了<del>，</del>不懂別打我~~。</p>
<h2 id="程式碼實現與說明"><a href="#程式碼實現與說明" class="headerlink" title="程式碼實現與說明"></a>程式碼實現與說明</h2><p>程式碼實現與說明分成三大部分，建構、初始化、SAM 擴增長度。</p>
<h3 id="建構"><a href="#建構" class="headerlink" title="建構"></a>建構</h3><p>一個 SAM 必須要有從出發點到此的最長長度，離起點最近的位置、與連結其他點的邊。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SAMN N*10 </span></span><br><span class="line"><span class="comment">// N 為字串最長長度</span></span><br><span class="line"><span class="keyword">int</span> sz , last ; <span class="comment">// 到 SAM 初始化說明</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">state</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> len , link ; <span class="comment">// len = 最長長度 , link = 當前子字串中第一個最長後綴結束位置 </span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; next ;</span><br><span class="line">&#125;st[SAMN];</span><br></pre></td></tr></table></figure>

<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>先給予一開始的起點，由於起點(當前狀態為空字串)並不會有後綴於是我們 link 直接設為 -1，且長度(len)為 0。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sam_init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    sz = <span class="number">0</span> ;</span><br><span class="line">    st[<span class="number">0</span>].len = <span class="number">0</span> ;</span><br><span class="line">    st[<span class="number">0</span>].link = <span class="number">-1</span> ;</span><br><span class="line">    st[<span class="number">0</span>].next.clear();</span><br><span class="line">    sz++ ;</span><br><span class="line">    last = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SAM-增加長度"><a href="#SAM-增加長度" class="headerlink" title="SAM 增加長度"></a>SAM 增加長度</h3><p>這裡就比較複雜了，應該是說超級複雜，我在程式中一行一行註解相信會更容易許多。</p>
<p><strong>請讀者特別注意，「子字串」跟「字串」要仔細分別，不要忽略會很嚴重</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sam_extend</span><span class="params">(<span class="keyword">char</span> c )</span></span>&#123; <span class="comment">//char c 要擴增的字元</span></span><br><span class="line">    <span class="keyword">int</span> cur = sz++ ; <span class="comment">//sz++ 增加 sam array 長度 , cur 為當前的 sam 節點</span></span><br><span class="line">    st[cur].next.clear() ; <span class="comment">//先把當前的 sam 連接點狀態移除</span></span><br><span class="line">    st[cur].len = st[last].len+<span class="number">1</span> ; <span class="comment">//為前一個 sam 節點 len +1 表示其長度</span></span><br><span class="line">    <span class="keyword">int</span> p = last ; <span class="comment">// p = 查詢當前字串的「所有子字串」與新增加 c 後的字串是否有共同後綴，</span></span><br><span class="line">    <span class="comment">//將跑到他們有共同後綴的「前一個位置」</span></span><br><span class="line">    <span class="comment">//注意：這裡的共同後綴只要有一個字元是就可以是共同後綴</span></span><br><span class="line">    <span class="comment">//舉例："abca" and "abcab" 中的 'b' 就是共同後綴</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(p != <span class="number">-1</span> &amp;&amp; !st[p].next.count(c))&#123; <span class="comment">// p = -1 表示已經到起點，</span></span><br><span class="line">        <span class="comment">// !st[p].next.count(c) 則是詢問增加此字元後是否會有共同後綴的情形，</span></span><br><span class="line">        <span class="comment">// 如果有則需要額外處理</span></span><br><span class="line">        st[p].next[c] = cur ; <span class="comment">// 將前面的點與現在的 sam 節點做連結</span></span><br><span class="line">        p = st[p].link ; <span class="comment">// 由於現在的字元並沒有和前面的子字串有共同後綴，</span></span><br><span class="line">        <span class="comment">// 於是他們的 link 就向上追蹤</span></span><br><span class="line">        <span class="comment">// 如果有則 st[p].next.count(c) == TRUE 不符合迴圈要求</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="number">-1</span>)&#123; </span><br><span class="line">        <span class="comment">// p = -1 表示沒有共同後綴且此字元在當前字串中從沒出現過，</span></span><br><span class="line">        <span class="comment">//才回到了起始點，所以將 link 設置為 0 </span></span><br><span class="line">        st[cur].link = <span class="number">0</span> ; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> q = st[p].next[c] ; <span class="comment">// q 為他們共同後綴的位置</span></span><br><span class="line">        <span class="keyword">if</span>(st[p].len + <span class="number">1</span> == st[q].len)&#123; </span><br><span class="line">            <span class="comment">//如果 st[p].len + 1 == st[q].len 表示「不同位置但相同字元」的共同後綴長度大於一</span></span><br><span class="line">            <span class="comment">//只需要直接將當前的 sam[cur].link 設定成 q 也就是共同後綴的位置 </span></span><br><span class="line">            st[cur].link = q ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123; <span class="comment">// 如果不同位置但相同字元的共同後綴如果等於一，則需要連創建新的 sam 節點，</span></span><br><span class="line">            <span class="comment">// 建立以 c + 字串前一個字元的後綴(前一個並不包括我們現在新增的 c)，</span></span><br><span class="line">            <span class="comment">// 並同時放棄另一個不同位置但也是 c 字元的後綴，但要持續存在以保護先前做好的 sam</span></span><br><span class="line">            <span class="keyword">int</span> clone = sz++ ; <span class="comment">// 創建新節點</span></span><br><span class="line">            st[clone].len = st[p].len + <span class="number">1</span> ; <span class="comment">// 表示從共同後綴的前一個位置 +1，</span></span><br><span class="line">            <span class="comment">//用來建立以 c + 字串前一個字元的後綴</span></span><br><span class="line">            st[clone].next = st[q].next ; <span class="comment">//複製 q 的 next，因為前面已經設定好連接的點，</span></span><br><span class="line">            <span class="comment">//但是因為共同後綴不同，後面還需要一個 while 迴圈進行調整</span></span><br><span class="line">            st[clone].link = st[q].link ; <span class="comment">//將他們 link 先設置相同，</span></span><br><span class="line">            <span class="comment">//之後用 while 迴圈再移動到正確的 link</span></span><br><span class="line">            <span class="keyword">while</span>(p != <span class="number">-1</span> &amp;&amp; st[p].next[c] == q)&#123; </span><br><span class="line">                <span class="comment">//p != -1 是不可以讓她更改起始點的位置</span></span><br><span class="line">                <span class="comment">//st[p].next[c] == q 接下來的點是從 clone 繼續擴展而不是原先的 q，</span></span><br><span class="line">                <span class="comment">//所以要將原先連接到 q 的點全部改連接至 clone</span></span><br><span class="line">                st[p].next[c] = clone ; <span class="comment">//更改連接點至 clone</span></span><br><span class="line">                p = st[p].link ; <span class="comment">// 繼續往上層追蹤</span></span><br><span class="line">            &#125;</span><br><span class="line">            st[q].link = st[cur].link = clone ;</span><br><span class="line">            <span class="comment">// 最後則是也要把 q and cur 的 link 改到 clone，</span></span><br><span class="line">            <span class="comment">// 原因則是因為接下來的點是從 clone 繼續擴展而不是原先的 q</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    last = cur ; <span class="comment">//準備下一次的擴展</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>想必蠻多讀者看完還是不知道這到底是甚麼鬼對不對？<del>沒關係，我自己在寫這個註解花了三小時，我自己都不太知道怎麼說明比較好，這有點太抽象了</del></p>
<p>我在這邊<strong>強烈希望讀者</strong>可以根據我的 Exercise 練習，就可以知道不容易寫以及其抽象的原因。</p>
<h4 id="EXERCISE-A-劃出-SAM-的圖，字串是-“abccba”"><a href="#EXERCISE-A-劃出-SAM-的圖，字串是-“abccba”" class="headerlink" title="EXERCISE A: 劃出 SAM 的圖，字串是 “abccba”"></a>EXERCISE A: 劃出 SAM 的圖，字串是 “abccba”</h4><h4 id="EXERCISE-B-根據-Exercise-A-甚麼時後會用到-if-st-p-len-1-st-q-len-的-else-情況？"><a href="#EXERCISE-B-根據-Exercise-A-甚麼時後會用到-if-st-p-len-1-st-q-len-的-else-情況？" class="headerlink" title="EXERCISE B: 根據 Exercise A 甚麼時後會用到 if(st[p].len + 1 == st[q].len) 的 else 情況？"></a>EXERCISE B: 根據 Exercise A 甚麼時後會用到 <code>if(st[p].len + 1 == st[q].len)</code> 的 <code>else</code> 情況？</h4><p>在現在新增字元與現在的 SAM 圖中字元一樣但後綴不大於一時，新增 clone 點，並放棄原本的 q 點，但必須保留以保證先前的 SAM 狀態正確。</p>
<h2 id="SAM-應用"><a href="#SAM-應用" class="headerlink" title="SAM 應用"></a>SAM 應用</h2><p>我在學習此演算法的過程中如果有題目讓我應用到此演算法我則收錄在此，連結則是我的詳解如果想要去看題目的就搜尋一下吧！</p>
<h3 id="最小循環移位"><a href="#最小循環移位" class="headerlink" title="最小循環移位"></a>最小循環移位</h3><ul>
<li><a href="https://theriseofdavid.github.io/2020/11/01/UVa/UVa719/" target="_blank" rel="noopener">UVa719 - Glass Beads (Suffix Automaton 後綴自動機 - 最小循環移位 Lexicographically minimum string rotation)</a></li>
</ul>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://oi-wiki.org/string/sam/#_17" target="_blank" rel="noopener">后缀自动机 (SAM)</a><br><a href="https://blog.csdn.net/stevensonson/article/details/81748438?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param" target="_blank" rel="noopener">后缀自动机学习笔记</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>感覺 SAM 沒有學得很好啊 ಥ⌣ಥ，沒辦法把一個抽象的事物說明的很清楚是我的問題呀，嗚嗚嗚嗚，這次就算有手寫程式碼以後還是有很多的學習盲點沒有意識到，慢慢再看其他教導 SAM 的文章才搞懂了些，SAM 是一個很酷、很強大的資料結構，發明 SAM 的人是一個大神吧。</p>
<p>這一次我不會說學習 SAM 會增加我的思維，因為我在寫完 blog 的感覺並沒有幫助我擴展我的思維，我想是我理解的不夠深或是依我當前的背景知識學習 SAM，會讓我自己不懂優秀的人們背後的學習理論，而導致我可能是用<strong>死背</strong>的方式得出結論。</p>
<p>雖然我有可能是用死背的方式得出結論，但我也花了一個禮拜在嘗試與思考此問題，我的腦袋沒有辦法好好描述 SAM 的程式碼，但我的腦袋卻告訴我她已經熟悉這個算法，但我無法肯定是不是用背的還是理解的，希望我自己是有理解到但只是我的腦袋還沒辦法用口語述說。</p>
<p>自學很好，但自學常常會遇到很多思考盲點；因為自學比較難有系統地去學習，學習方式是用跳躍的，常常是自己在學習其他觀念時才會想到，對欸！我之前學的哪個演算法就是用這個基礎去延伸的，這樣其實不太好，有點討厭，但我一路以來的學習方法也都是如此，可能也沒有辦法再去讓自己習慣另一種模式，就繼續堅持下去吧！我相信只要我堅持，美好的成果我一定也能品嘗到的！</p>
<p>也謝謝 OI WIKI 與 stevensonson 一個用證明與理論來讓我學習 SAM、優質的 SAM 程式碼讓我對此演算法學習速度更快，另一個則是使用圖加速了我對 SAM 的理解，謝謝二位大神，也還希望 stevensonson 願意讓我用此圖來對未來可能會忘記這演算法的我、其他想學的人進行說明，謝謝！</p>
<p>我也花了七個小時撰寫文章，看得懂跟說得出來真的是兩回事，也許還有人覺得我說的很差，不過我已經盡力解釋。希望可以幫助到各位。</p>
<p>也希望大家想要學習的知識都可以快速學習而成，不要因為自身的環境不足而學習不到。</p>
<h2 id="SAM-無註解程式碼"><a href="#SAM-無註解程式碼" class="headerlink" title="SAM 無註解程式碼"></a>SAM 無註解程式碼</h2><p>這裡則放置沒有註解的程式碼，如果讀者想要複製就從這裡進行複製吧！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">state</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> len, link;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXLEN = <span class="number">100000</span>;</span><br><span class="line">state st[MAXLEN * <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> sz, last;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sam_init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  st[<span class="number">0</span>].len = <span class="number">0</span>;</span><br><span class="line">  st[<span class="number">0</span>].link = <span class="number">-1</span>;</span><br><span class="line">  sz++;</span><br><span class="line">  last = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sam_extend</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> cur = sz++;</span><br><span class="line">  st[cur].len = st[last].len + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> p = last;</span><br><span class="line">  <span class="keyword">while</span> (p != <span class="number">-1</span> &amp;&amp; !st[p].next.count(c)) &#123;</span><br><span class="line">    st[p].next[c] = cur;</span><br><span class="line">    p = st[p].link;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (p == <span class="number">-1</span>) &#123;</span><br><span class="line">    st[cur].link = <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> q = st[p].next[c];</span><br><span class="line">    <span class="keyword">if</span> (st[p].len + <span class="number">1</span> == st[q].len) &#123;</span><br><span class="line">      st[cur].link = q;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">int</span> clone = sz++;</span><br><span class="line">      st[clone].len = st[p].len + <span class="number">1</span>;</span><br><span class="line">      st[clone].next = st[q].next;</span><br><span class="line">      st[clone].link = st[q].link;</span><br><span class="line">      <span class="keyword">while</span> (p != <span class="number">-1</span> &amp;&amp; st[p].next[c] == q) &#123;</span><br><span class="line">        st[p].next[c] = clone;</span><br><span class="line">        p = st[p].link;</span><br><span class="line">      &#125;</span><br><span class="line">      st[q].link = st[cur].link = clone;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  last = cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="用紙筆去模擬-SAM"><a href="#用紙筆去模擬-SAM" class="headerlink" title="用紙筆去模擬 SAM"></a>用紙筆去模擬 SAM</h2><p>因為只是自己在思考過程中隨手做的筆記，覺得不是對讀者這麼有幫助，因此放在文章最下面。</p>
<p>有時候用想或用看的可能不太能夠懂這演算法，那就用寫的吧！這是大衛我自己學習的手稿，紀錄者我的學習過程。</p>
<blockquote>
<p>這裡的舉例是用 “daviddavid”</p>
</blockquote>
<p><img src="/images/suffix-automaton/2.jpg" alt=""><br><img src="/images/suffix-automaton/3.jpg" alt=""></p>
<blockquote>
<p>最後一張則是我自己其他幫助我自己內心釐清的手稿，非常沒用，不要看，我純紀念用</p>
</blockquote>
<p><img src="/images/suffix-automaton/4.jpg" alt=""></p>
]]></content>
      <categories>
        <category>演算法知識</category>
      </categories>
      <tags>
        <tag>程式解題</tag>
        <tag>字串處理</tag>
        <tag>演算法知識</tag>
        <tag>最小循環移位 Lexicographically minimum string rotation</tag>
        <tag>Suffix Automation 後綴自動機</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa719 - Glass Beads (Suffix Automation 後綴自動機 - 最小循環移位 Lexicographically minimum string rotation)</title>
    <url>/2020/11/01/UVa/UVa719/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>有一串項鍊由於線繩脆弱，可能會在最重與最輕的珠子的中間因為重力關係而導致繩線裂開，這些珠子的權重分別用英文字母表示，由於這些英文字母是循環的，給你一組字串試問怎麼樣找出此字串<strong>字典序</strong>最小的循環字串。</p>
<p>循環字串：假如字串有 “abc”，那則會 abcabcabc… 不斷循環下去，但總長度必定為原本字串長度，類似於項鍊。</p>
</blockquote>
<a id="more"></a>

<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>這題使用 Suffix Automation 做<strong>最小循環移位(Lexicographically minimum string rotation)</strong>是不錯的選擇，Suffix Automation 是甚麼？那你可以看看<a href="https://theriseofdavid.github.io/2020/10/31/Explain_Algorithm/suffix-automaton/" target="_blank" rel="noopener">演算法知識 - Suffix Automaton 後綴自動機</a>，裡面有對於 Suffix Automation 做出還不賴的說明，也可以利用他的參考連結去找到更適合你的說明方式。</p>
<h3 id="QUESTION-最小循環移位-Lexicographically-minimum-string-rotation-是甚麼？"><a href="#QUESTION-最小循環移位-Lexicographically-minimum-string-rotation-是甚麼？" class="headerlink" title="QUESTION: 最小循環移位(Lexicographically minimum string rotation) 是甚麼？"></a>QUESTION: 最小循環移位(Lexicographically minimum string rotation) 是甚麼？</h3><p>給你一組字串，找出字典序最小的循環字串，<del>沒錯，就是這題的題目，非常純粹的模板題</del>。</p>
<h4 id="要怎麼解開呢？"><a href="#要怎麼解開呢？" class="headerlink" title="要怎麼解開呢？"></a>要怎麼解開呢？</h4><p>其實容易想到，只需要將原本的字串複製一次給原本的字串，即<code>string += string</code>，透過從起始點一路跟著當下可以走的最小字典序節點走，走到原先字串的長度，在<code>k-string.length()+1</code>，就是最小循環移位了。</p>
<h4 id="QUESTION-A-為甚麼只要原本的字串複製一次給原本的字串呢？"><a href="#QUESTION-A-為甚麼只要原本的字串複製一次給原本的字串呢？" class="headerlink" title="QUESTION A: 為甚麼只要原本的字串複製一次給原本的字串呢？"></a>QUESTION A: 為甚麼只要原本的字串複製一次給原本的字串呢？</h4><p>由於第一次的字串長度結束位置 + 字串長度(即第二次循環) &lt; 連續三次循環長度，就算從最後一個字元開始循環也不會大於三次循環，即可證明我們不需要第三次循環，只要循環一次就好。 </p>
<h4 id="簡單的程式碼說明"><a href="#簡單的程式碼說明" class="headerlink" title="簡單的程式碼說明"></a>簡單的程式碼說明</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//st 是 sam、now 是還要再找幾次，一開始為原本字串長度</span></span><br><span class="line"><span class="keyword">while</span>(now--)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it : st[u].next)&#123; <span class="comment">//跟著字典續追蹤</span></span><br><span class="line">        u = it.second ;</span><br><span class="line">        <span class="keyword">break</span> ; <span class="comment">//找到了就往下個節點移動，類似於 DFS</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; st[u].len - len + <span class="number">1</span> &lt;&lt; <span class="string">'\n'</span> ; </span><br><span class="line"><span class="comment">//找到當下的節點後，找出它的長度並且扣掉原始長度並加一即是答案</span></span><br></pre></td></tr></table></figure>

<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://blog.csdn.net/keshuai19940722/article/details/39062669" target="_blank" rel="noopener">uva 719 - Glass Beads(最小表示法 | 后缀自动机)</a><br><a href="https://oi-wiki.org/string/sam/#_17" target="_blank" rel="noopener">后缀自动机 (SAM)</a><br><a href="https://theriseofdavid.github.io/2020/10/31/Explain_Algorithm/suffix-automaton/" target="_blank" rel="noopener">演算法知識 - Suffix Automaton 後綴自動機</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>其實學會了 SAM 之後，發現這個應用沒有難度欸XD，SAM 太讚了，SAM 不知道是哪個優秀的演算法大神發明的，真的非常棒，只是我不爭氣了解的不夠透徹、不夠多，我要繼續努力學習演算法，使我變強也能夠獨當一面！也還要複習英文，不然題目可能都看不懂，嗚嗚。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>其實就是沒有附上說明的程式碼，我也花了兩個小時撰寫文章，看得懂跟說得出來真的是兩回事，也許還有人覺得我說的很差，不過我已經盡力解釋。希望可以幫助到各位。</p>
<p>也希望大家想要學習的知識都可以快速學習而成，不要因為自身的環境不足而學習不到。</p>
<p>於是這裡就補述一些題目給的資料範圍限制與標頭檔了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SAMN N*10</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> sz , last ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">state</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> len , link ;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; next ;</span><br><span class="line">&#125;st[SAMN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sam_init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    sz = <span class="number">0</span> ;</span><br><span class="line">    st[<span class="number">0</span>].len = <span class="number">0</span> ;</span><br><span class="line">    st[<span class="number">0</span>].link = <span class="number">-1</span> ;</span><br><span class="line">    st[<span class="number">0</span>].next.clear();</span><br><span class="line">    sz++ ;</span><br><span class="line">    last = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sam_extend</span><span class="params">(<span class="keyword">char</span> c )</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cur = sz++ ;</span><br><span class="line">    st[cur].next.clear() ;</span><br><span class="line">    st[cur].len = st[last].len+<span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">int</span> p = last ;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="number">-1</span> &amp;&amp; !st[p].next.count(c))&#123;</span><br><span class="line">        st[p].next[c] = cur ;</span><br><span class="line">        p = st[p].link ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="number">-1</span>)&#123;</span><br><span class="line">        st[cur].link = <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> q = st[p].next[c] ;</span><br><span class="line">        <span class="keyword">if</span>(st[p].len + <span class="number">1</span> == st[q].len)&#123;</span><br><span class="line">            st[cur].link = q ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> clone = sz++ ;</span><br><span class="line">            st[clone].len = st[p].len + <span class="number">1</span> ;</span><br><span class="line">            st[clone].next = st[q].next ;</span><br><span class="line">            st[clone].link = st[q].link ;</span><br><span class="line">            <span class="keyword">while</span>(p != <span class="number">-1</span> &amp;&amp; st[p].next[c] == q)&#123;</span><br><span class="line">                st[p].next[c] = clone ;</span><br><span class="line">                p = st[p].link ;</span><br><span class="line">            &#125;</span><br><span class="line">            st[q].link = st[cur].link = clone ;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    last = cur ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAl</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAl</span></span></span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n , len;</span><br><span class="line">    <span class="built_in">string</span> strA ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; strA ;</span><br><span class="line">        len = strA.length() ;</span><br><span class="line">        strA += strA ;</span><br><span class="line">        sam_init() ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; strA.length() ; i++) sam_extend(strA[i]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> u = <span class="number">0</span> , now = len  ;</span><br><span class="line">        <span class="keyword">while</span>(now--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> it : st[u].next)&#123;</span><br><span class="line">                u = it.second ;</span><br><span class="line">                <span class="keyword">break</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; st[u].len - len + <span class="number">1</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>程式解題</tag>
        <tag>字串處理</tag>
        <tag>演算法知識</tag>
        <tag>最小循環移位 Lexicographically minimum string rotation</tag>
        <tag>Suffix Automation 後綴自動機</tag>
      </tags>
  </entry>
  <entry>
    <title>演算法知識 - Suffix Tree 後綴樹 (Using Ukkonen Algorithm)</title>
    <url>/2020/11/03/Explain_Algorithm/suffix-tree/</url>
    <content><![CDATA[<h2 id="Suffix-Tree-介紹"><a href="#Suffix-Tree-介紹" class="headerlink" title="Suffix Tree 介紹"></a>Suffix Tree 介紹</h2><blockquote>
<p>Suffix Tree 是字典樹(Trie) 的延伸，透過對一字串的所有後綴去建構樹，是一個能解決許多字串特定問題的資料結構。</p>
<p>以下是 Suffix Tree 能解決的問題：</p>
<ul>
<li>尋找 A 字串是否在字串 B 中</li>
<li>找出 B 在 A 字串重複的次數</li>
<li>最長共同子字串</li>
</ul>
<p>簡單來說 Suffix Tree 是將字串的所有後綴建構成 Trie，再將其壓縮(沒有分支的節點都放在同個節點)。</p>
<p><strong>建立 Suffix Tree 的時間複雜度為 \(O(n)\)，使用 Ukkonen Algorithm</strong><br>通常建構 Suffix Tree 有兩種方法，一種時間複雜度為 \(O(n)\)，另一種為 \(O(n^2)\)，這裡只介紹普遍比賽會經用的演算法(Ukkonen Algorithm)</p>
<p>此文章跳開蠻多證明與理論，如果想要知道可再從下方參考連結點選即可</p>
</blockquote>
<a id="more"></a>

<h2 id="Suffix-Tree-原理-正確來說應該是Ukkonen-Algorithm-原理"><a href="#Suffix-Tree-原理-正確來說應該是Ukkonen-Algorithm-原理" class="headerlink" title="Suffix Tree 原理 (正確來說應該是Ukkonen Algorithm 原理)"></a>Suffix Tree 原理 (正確來說應該是Ukkonen Algorithm 原理)</h2><p>這裡我們借助 Tushar Roy 的 Youtube 影片教學，此教學影片非常棒，連結將放在下方標題的參考連結<br><strong>這裡我們將透過一字串 “xyzxyaxyz$” 來進行解說，有些地方會跟影片不一樣，因為我個人認為這樣寫對學習更有幫助，請不要理會右邊的變數</strong>，EX: remaining , active_Node…。 </p>
<h3 id="名詞介紹"><a href="#名詞介紹" class="headerlink" title="名詞介紹"></a>名詞介紹</h3><p>先來介紹一些我們會用到的名詞</p>
<ul>
<li>remaining 隱藏在 Suffix Tree 中的後綴節點</li>
<li>root = Suffix Tree 的最主要根節點</li>
<li>active_node 活動節點，主要是用來生長葉節點 (leaf)</li>
<li>active_e 隱藏節點的第一個字元</li>
<li>active_len 隱藏在 Suffix Tree 中節點的長度</li>
<li>node 一個 struct 用來存入 Suffix Tree 節點<ul>
<li>start 此節點開始的位置(index)</li>
<li>end 此節點結束的位置(end)<br>舉例： node.start = 3 and node.end = 5，則 string 的長度是 <code>string.substr(3,2)</code>，用數學表示則是 \((start , end ]\)</li>
<li>next 用來指出下一個節點的位置，個人習慣用 map</li>
<li>slink 指出此節點的最長後綴節點，EX: XYZ 則指出 YZ。</li>
<li>edge_length() 公式為 \(min(end,pos+1) - start \)<br>用來找出此節點的字串長度</li>
</ul>
</li>
</ul>
<h3 id="原理說明-初始建構"><a href="#原理說明-初始建構" class="headerlink" title="原理說明 - 初始建構"></a>原理說明 - 初始建構</h3><p>我們必須先建構 Suffix Tree Root，才可以讓 Suffix Tree 慢慢變長，Suffix Tree Root 的 start and end 都是 -1，Root 是起始點且並不包含任何資料。</p>
<ul>
<li>remaining = 0<br>一開始不會有隱藏在 Suffix Tree 中的後綴節點於是設定成 0</li>
<li>root = 1<br>我們捨棄從 0 開始，從 1 開始會更好建構，於是起始點是 1 </li>
<li>active_node = 1<br>由於一開始生長葉節點只能先從 root 開始，所以設定 active_node = root </li>
<li>active_e = 0<br>一開始沒有隱藏節點於是設定成 0</li>
<li>active_len = 0<br>一開始沒有隱藏在 Suffix Tree 中節點的長度，所以設定 0 </li>
</ul>
<h3 id="原理說明-“x”"><a href="#原理說明-“x”" class="headerlink" title="原理說明 - “x”"></a>原理說明 - “x”</h3><p>由於一開始樹中並沒有 x 此字元，直接產生新節點(葉節點)，由於有產生節點，沒有隱藏節點所以 remaining = 0</p>
<ul>
<li>葉節點(node) 建構設定<ul>
<li>start 等於此<strong>字元</strong>位置</li>
<li>end 等於<strong>字串</strong>長度</li>
<li>slink 設定為 0</li>
<li>next.clear()</li>
</ul>
</li>
</ul>
<blockquote>
<p>原理說明 - “x”</p>
</blockquote>
<p><img src="/images/suffix-tree/1.PNG" alt=""></p>
<h3 id="原理說明-“xy”"><a href="#原理說明-“xy”" class="headerlink" title="原理說明 - “xy”"></a>原理說明 - “xy”</h3><p>樹中沒有 y 字元，也直接產生新節點，跟上個步驟一樣。</p>
<blockquote>
<p>原理說明 - “xy”，這裡無法截圖到 remaining 為 0 的狀態，於是自己寫 </p>
</blockquote>
<p><img src="/images/suffix-tree/2.PNG" alt=""></p>
<h3 id="原理說明-“xyz”"><a href="#原理說明-“xyz”" class="headerlink" title="原理說明 - “xyz”"></a>原理說明 - “xyz”</h3><p>樹中沒有 z 字元，也直接產生新節點，跟上個步驟一樣。</p>
<blockquote>
<p>原理說明 - “xyz”，這裡無法截圖到 remaining 為 0 的狀態，於是自己寫 </p>
</blockquote>
<p><img src="/images/suffix-tree/3.PNG" alt=""></p>
<h3 id="原理說明-“xyzx”"><a href="#原理說明-“xyzx”" class="headerlink" title="原理說明 - “xyzx”"></a>原理說明 - “xyzx”</h3><p>樹中已經有 x 字元，且是在 active_node 底下，於是我們不新增節點，以符合壓縮原理，而我們多了一個隱藏節點並將隱藏節點長度則 +1，因為增加 x，且 remaining 也要 +1 表示增加一個隱藏節點。</p>
<blockquote>
<p>原理說明 - “xyzx”</p>
</blockquote>
<p><img src="/images/suffix-tree/4.PNG" alt=""></p>
<h3 id="原理說明-“xyzxy”"><a href="#原理說明-“xyzxy”" class="headerlink" title="原理說明 - “xyzxy”"></a>原理說明 - “xyzxy”</h3><p>樹中已經有 y 字元，且是在 active_node 底下，於是我們不新增節點，以符合壓縮原理，而我們多了一個隱藏節點並將隱藏節點長度則 +1，因為增加 y，且 remaining 也要 +1 表示增加一個隱藏節點。</p>
<p>這時隱藏節點長度(active_len)則變成 2<br>remainging = 2<br>隱藏字元有 “xy”</p>
<blockquote>
<p>原理說明 - “xyzxy”</p>
</blockquote>
<p><img src="/images/suffix-tree/5.PNG" alt=""></p>
<h3 id="原理說明-“xyzxya”"><a href="#原理說明-“xyzxya”" class="headerlink" title="原理說明 - “xyzxya”"></a>原理說明 - “xyzxya”</h3><p>這裡需要比較長的說明，共三個步驟。</p>
<h4 id="step-1"><a href="#step-1" class="headerlink" title="step 1:"></a>step 1:</h4><p>此時的隱藏長度為 2，我們無法因為字元 a 而增加隱藏長度，因為前面是 “xy<strong>z</strong>“(先從隱藏字元方向 “xy” )，而不是 “xy<strong>a</strong>“，所以我們這邊要做出一個切割節點，切割方式為 root 往 x 的邊且長度為 2；來保持 “xyzxya” 後綴與 “xya” 後綴，分裂完成後 remaining 必須 -1，因為 x 此隱藏節點已經產生，隱藏長度(active_len)也需 -1。</p>
<p>這時隱藏節點長度(active_len)則變成 1<br>remainging = 1<br>隱藏字元有 “y”</p>
<blockquote>
<p>原理說明 - “xyzxya” 切割點為 xy </p>
</blockquote>
<p><img src="/images/suffix-tree/6.PNG" alt=""></p>
<h4 id="step-2"><a href="#step-2" class="headerlink" title="step 2:"></a>step 2:</h4><p>此時的隱藏長度為 1，我們無法因為字元 a 而增加隱藏長度，因為前面是 “y<strong>z</strong>“，而不是 “y<strong>a</strong>“，所以我們這邊要做出一個切割節點，切割方式為 root 往 y 的邊且長度為 2；來保持 “yzxya” 後綴與 “ya” 後綴，分裂完成後 remaining 必須 -1，因為 y 此隱藏節點已經產生，隱藏長度(active_len)也需 -1。</p>
<p>此時的 slink 則派上用場，需要指回在隱藏字元 “xy” 時所切割的節點，表示如果 xy 的葉節點們如果也需要更改時則表示隱藏字元 “y” 時所切割的葉節點也需要更改。</p>
<p>這時隱藏節點長度(active_len)則變成 0<br>remainging = 0<br>隱藏字元無</p>
<blockquote>
<p>原理說明 - “xyzxya” 切割點為 y </p>
</blockquote>
<p><img src="/images/suffix-tree/7.PNG" alt=""></p>
<h4 id="step-3"><a href="#step-3" class="headerlink" title="step 3:"></a>step 3:</h4><p>由於一開始樹中並沒有 a 此字元，直接產生新節點(葉節點)，由於有產生節點，沒有隱藏節點所以 remaining = 0</p>
<blockquote>
<p>原理說明 - 新增 a 節點</p>
</blockquote>
<p><img src="/images/suffix-tree/7.PNG" alt=""></p>
<h3 id="原理說明-“xyzxyax”"><a href="#原理說明-“xyzxyax”" class="headerlink" title="原理說明 - “xyzxyax”"></a>原理說明 - “xyzxyax”</h3><p>樹中已經有 x 字元，且是在 active_node 底下，於是我們不新增節點，以符合壓縮原理，而我們多了一個隱藏節點並將隱藏節點長度則 +1，因為增加 x，且 remaining 也要 +1 表示增加一個隱藏節點。</p>
<p>與第一個步驟相似</p>
<p>這時隱藏節點長度(active_len)則變成 1<br>remainging = 1<br>隱藏字元有 “x”</p>
<blockquote>
<p>原理說明 - “xyzxyax”</p>
</blockquote>
<p><img src="/images/suffix-tree/8.PNG" alt=""></p>
<h3 id="原理說明-“xyzxyaxy”"><a href="#原理說明-“xyzxyaxy”" class="headerlink" title="原理說明 - “xyzxyaxy”"></a>原理說明 - “xyzxyaxy”</h3><p>樹中已經有 y 字元，且是在 active_node 底下，於是我們不新增節點，以符合壓縮原理，而我們多了一個隱藏節點並將隱藏節點長度則 +1，因為增加 y，且 remaining 也要 +1 表示增加一個隱藏節點。</p>
<p>這時隱藏節點長度(active_len)則變成 2<br>remainging = 2<br>隱藏字元有 “xy”</p>
<blockquote>
<p>原理說明 - “xyzxyaxy”</p>
</blockquote>
<p><img src="/images/suffix-tree/9.PNG" alt=""></p>
<h3 id="原理說明-“xyzxyaxyz”"><a href="#原理說明-“xyzxyaxyz”" class="headerlink" title="原理說明 - “xyzxyaxyz”"></a>原理說明 - “xyzxyaxyz”</h3><p>樹中已經有 z 字元，且是在 active_node 底下，於是我們不新增節點，以符合壓縮原理，而我們多了一個隱藏節點並將隱藏節點長度則 +1，因為增加 z，且 remaining 也要 +1 表示增加一個隱藏節點。</p>
<p>這時隱藏節點長度(active_len)則變成 3<br>remainging = 3<br>隱藏字元有 “xyz”</p>
<blockquote>
<p>原理說明 - “xyzxyaxyz”</p>
</blockquote>
<p><img src="/images/suffix-tree/10.PNG" alt=""></p>
<h3 id="原理說明-“xyzxyaxyz-”"><a href="#原理說明-“xyzxyaxyz-”" class="headerlink" title="原理說明 - “xyzxyaxyz$”"></a>原理說明 - “xyzxyaxyz$”</h3><p>由於我們希望只要是後綴樹的後綴都可以有一個節點而不被隱藏，於是我們增加一個從未出現的符號，來把這些隱藏節點全部都拉出來新增節點，有點類似於新增 a 的步驟，但在複雜一些，共有四步 。</p>
<h4 id="step-1-1"><a href="#step-1-1" class="headerlink" title="step 1"></a>step 1</h4><p>此時的隱藏長度為 3，我們無法因為字元 $ 而增加隱藏長度，因為前面是 “xyz<strong>x</strong>“，而不是 “xyz<strong>$</strong>“，所以我們這邊要做出一個切割節點，切割方式為 root 往 z 的邊且長度為 1，這是因為前面 xy 已經是一個節點，所以我們就必須先將 active_len 先減 2 的節點在往 z 的方向切割；來保持 “<font color="    #ADADAD" >xy</font>zxyaxyz$” 後綴與 “<font color="    #ADADAD" >xy</font>z$” 後綴，分裂完成後 remaining 必須 -1，因為 z 此隱藏節點已經產生，隱藏長度(active_len)也需 -1。</p>
<p>這時隱藏節點長度(active_len)則變成 2<br>remainging = 2<br>隱藏字元有 “yz”</p>
<blockquote>
<p>原理說明 - “xyzxyaxyz$” 切割點為 <font color="#ADADAD" >xy</font>z，這裡 remainding 應該為 2</p>
</blockquote>
<p><img src="/images/suffix-tree/11.PNG" alt=""></p>
<h4 id="step-2-1"><a href="#step-2-1" class="headerlink" title="step 2"></a>step 2</h4><p>此時的隱藏長度為 2，我們無法因為字元 $ 而增加隱藏長度，因為前面是 “yz<strong>x</strong>“，而不是 “yz<strong>$</strong>“，所以我們這邊要做出一個切割節點，切割方式為 root 往 z 的邊且長度為 1，這是因為前面 y 已經是一個節點，所以我們就必須先將 active_len 先減 1 的節點在往 z 的方向切割；來保持 “<font color="    #ADADAD" >yz</font>xyaxyz$” 後綴與 “<font color="#ADADAD" >yz</font>$” 後綴，分裂完成後 remaining 必須 -1，因為 z 此隱藏節點已經產生，隱藏長度(active_len)也需 -1。</p>
<p>此時的 slink 則派上用場，需要指回在隱藏字元 “xyz” 時所切割的節點，表示如果 xyz 的葉節點們如果也需要更改時則表示隱藏字元 “yz” 時所切割的葉節點也需要更改。</p>
<p>這時隱藏節點長度(active_len)則變成 1<br>remainging = 1<br>隱藏字元有 “z”</p>
<blockquote>
<p>原理說明 - “yzxyaxyz$” 切割點為 <font color="#ADADAD" >y</font>z，這裡 remainding 應該為 1，沒辦法擷取到完整畫面，只好犧牲</p>
</blockquote>
<p><img src="/images/suffix-tree/12.PNG" alt=""></p>
<h4 id="step-3-1"><a href="#step-3-1" class="headerlink" title="step 3"></a>step 3</h4><p>此時的隱藏長度為 1，我們無法因為字元 $ 而增加隱藏長度，因為前面是 “z<strong>x</strong>“，而不是 “z<strong>$</strong>“，所以我們這邊要做出一個切割節點，切割方式為 root 往 z 的邊且長度為 1；來保持 “<font color="    #ADADAD" >z</font>xyaxyz$” 後綴與 “<font color="#ADADAD" >z</font>$” 後綴，分裂完成後 remaining 必須 -1，因為 z 此隱藏節點已經產生，隱藏長度(active_len)也需 -1。</p>
<p>此時的 slink 則派上用場，需要指回在隱藏字元 “yz” 時所切割的節點，表示如果 yz 的葉節點們如果也需要更改時則表示隱藏字元 “z” 時所切割的葉節點也需要更改。</p>
<p>這時隱藏節點長度(active_len)則變成 0<br>remainging = 0<br>隱藏字元無</p>
<blockquote>
<p>原理說明 - “zxyaxyz$” 切割點為 z，這裡 remainding 應該為 0，沒辦法擷取到完整畫面，只好犧牲</p>
</blockquote>
<p><img src="/images/suffix-tree/13.PNG" alt=""></p>
<h4 id="step-4"><a href="#step-4" class="headerlink" title="step 4"></a>step 4</h4><p>由於一開始樹中並沒有 $ 此字元，直接產生新節點(葉節點)，由於有產生節點，沒有隱藏節點所以 remaining = 0</p>
<blockquote>
<p>原理說明 - “xyzxyaxyz$” 切割點為 $</p>
</blockquote>
<p><img src="/images/suffix-tree/14.PNG" alt=""></p>
<h3 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h3><p>以上，就是 Suffix Tree 原理，謝謝各位觀看，如果還是看不太懂可以看Tushar Roy - Coding Made Simple 大神的影片教學，一定比我講得更棒。</p>
<div class="video-container"><iframe src="https://www.youtube.com/embed/aPRqocoBsFQ" frameborder="0" loading="lazy" allowfullscreen></iframe></div>

<h2 id="程式碼實現與說明"><a href="#程式碼實現與說明" class="headerlink" title="程式碼實現與說明"></a>程式碼實現與說明</h2><p>程式碼實現與說明分成三大部分，建構、初始化、SAM 擴增長度。</p>
<h3 id="建構"><a href="#建構" class="headerlink" title="建構"></a>建構</h3><p>這裡比較簡單，於是請直接看此就沒問題的XD。<br><a href="#原理說明-初始建構">原理說明 - 初始建構</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> start , end ,slink ; </span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; next ;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">edge_length</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> min(end , pos+<span class="number">1</span>) - start ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> st , <span class="keyword">int</span> ed = oo)</span></span>&#123;</span><br><span class="line">        start = st ;</span><br><span class="line">        end = ed ;</span><br><span class="line">        slink = <span class="number">0</span> ;</span><br><span class="line">        next.clear() ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;tree[<span class="number">2</span>*N];</span><br></pre></td></tr></table></figure>

<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>建議搭配 <a href="#名詞介紹">名詞介紹</a> 會更好理解。<br>cnt 為我們 Suffix Tree 的總長度</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">st_init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//tree root is 1 not zero</span></span><br><span class="line">    needSL = remainder_ = <span class="number">0</span> ;</span><br><span class="line">    active_node = active_e = active_len = <span class="number">0</span> ;</span><br><span class="line">    pos = <span class="number">-1</span> ;</span><br><span class="line"></span><br><span class="line">    cnt = root = <span class="number">1</span> ;</span><br><span class="line">    active_node = <span class="number">1</span> ;</span><br><span class="line">    tree[cnt++].init(<span class="number">-1</span>,<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Suffix-Tree-擴增長度"><a href="#Suffix-Tree-擴增長度" class="headerlink" title="Suffix Tree 擴增長度"></a>Suffix Tree 擴增長度</h3><p>建議搭配 <a href="#原理說明-“x”">原理說明-“x”</a> 以下全部的<strong>原理說明</strong>會更好理解。<br>這份程式碼與影片教學方式有些許差別，原因是因為這份程式碼我是用簡潔的方式寫，而影片則是用好理解的方式去教導。</p>
<p><strong>請注意 remainder 進入迴圈後是從 1 開始，之後再到迴圈的最後做 -1 的動作，上述原理說明有省略此步</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">active_edge</span><span class="params">()</span></span>&#123; <span class="comment">//隱藏字元的第一個</span></span><br><span class="line">    <span class="keyword">return</span> text[active_e] ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_SL</span><span class="params">(<span class="keyword">int</span> node)</span></span>&#123; <span class="comment">// slink 指回上一個隱藏節點的位置，如果上一個後綴節點的葉節點需要被更改時，</span></span><br><span class="line"><span class="comment">// 這裡的下方葉節點也能被迅速被更改，達到 O(1) 效果</span></span><br><span class="line">    <span class="keyword">if</span>(needSL &gt; <span class="number">0</span> ) tree[needSL].slink = node ;</span><br><span class="line">    needSL = node ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">walkdown</span><span class="params">(<span class="keyword">int</span> node)</span></span>&#123; <span class="comment">//即 原理說明 - "xyzxyaxyz$" 的 step 1， xyz 但 xy 是一個節點，</span></span><br><span class="line"><span class="comment">// 需要在往下一個子節點前進</span></span><br><span class="line">    <span class="keyword">if</span>(active_len &gt;= tree[node].edge_length())&#123;</span><br><span class="line">        active_e += tree[node].edge_length() ; <span class="comment">//找到此長度後的第一個隱藏字元 </span></span><br><span class="line">        active_len -= tree[node].edge_length() ; <span class="comment">//減少長度</span></span><br><span class="line">        active_node = node ; <span class="comment">//往後方前進</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">st_extend</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123; <span class="comment">//擴增 suffix tree </span></span><br><span class="line">    pos++; <span class="comment">// 往下個字串前進</span></span><br><span class="line">    needSL = <span class="number">0</span> ; <span class="comment">// 紀錄上一個切割點的位置，用來 slink 的前一個點</span></span><br><span class="line">    remainder_++ ; <span class="comment">// 先 +1，如果這個點有被增加之後做 -1 的動作</span></span><br><span class="line">    <span class="keyword">while</span>(remainder_ &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(active_len == <span class="number">0</span> ) active_e = pos ; </span><br><span class="line">        <span class="comment">// 如果 active len 等於 0，就表示沒有隱藏長度，所以我們要判斷的就是當前字元</span></span><br><span class="line">        <span class="comment">// 是否存在此 active_node 節點中</span></span><br><span class="line">        <span class="keyword">if</span>(tree[active_node].next[active_edge()] == <span class="number">0</span>)&#123; </span><br><span class="line">            <span class="comment">// active_node 沒有此字元的節點，新增節點</span></span><br><span class="line">            <span class="keyword">int</span> leaf = cnt ;</span><br><span class="line">            tree[cnt++].init(pos) ;</span><br><span class="line">            tree[active_node].next[active_edge()] = leaf ;</span><br><span class="line">            add_SL(active_node) ;　<span class="comment">// 紀錄 slink 的位置，以防下次用到</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123; <span class="comment">// active_node 有此字元的節點</span></span><br><span class="line">            <span class="keyword">int</span> nxt = tree[active_node].next[active_edge()] ;</span><br><span class="line">            <span class="keyword">if</span>(walkdown(nxt)) <span class="keyword">continue</span> ; <span class="comment">// 如果還需要在往下一個節點走，就減少隱藏長度，</span></span><br><span class="line">            <span class="comment">//然後回去重新查詢</span></span><br><span class="line">            <span class="keyword">if</span>(text[tree[nxt].start + active_len] == c)&#123; </span><br><span class="line">                <span class="comment">// 如果此節點有包含到此字元，代表隱藏長度可以+1，因為後綴還是在節點長裡面</span></span><br><span class="line">                active_len++ ; <span class="comment">// 隱藏長度可以 +1</span></span><br><span class="line">                add_SL(active_node) ; <span class="comment">// 紀錄 slink 的位置，以防下次用到</span></span><br><span class="line">                <span class="keyword">break</span> ; <span class="comment">//由於隱藏節點是 +1，所以我們沒必要減</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 需要做切割點</span></span><br><span class="line">            <span class="keyword">int</span> split = cnt ; </span><br><span class="line">            tree[cnt++].init(tree[nxt].start , tree[nxt].start + active_len) ;</span><br><span class="line">            <span class="comment">//製作切割點中...，結束位置就是當前節點的 start + 隱藏長度</span></span><br><span class="line">            tree[active_node].next[active_edge()] = split ;</span><br><span class="line">            <span class="comment">// 需要將 active_node 指向我們的切割點，而不是原來的點</span></span><br><span class="line">            <span class="keyword">int</span> leaf = cnt ; <span class="comment">// 需要葉節點</span></span><br><span class="line">            tree[cnt++].init(pos) ;</span><br><span class="line">            <span class="comment">// 製作葉節點</span></span><br><span class="line">            tree[split].next[c] = leaf ; <span class="comment">// 把葉節點指向我們的切割點</span></span><br><span class="line">            tree[nxt].start += active_len ; <span class="comment">//原本的節點 start 往後到切割點的 end</span></span><br><span class="line">            tree[split].next[text[tree[nxt].start]] = nxt ; <span class="comment">//將原本節點指向我們的切割點</span></span><br><span class="line">            add_SL(split) ; <span class="comment">// 紀錄 slink 的位置，以防下次用到</span></span><br><span class="line">        &#125;</span><br><span class="line">        remainder_-- ; <span class="comment">// 由於有增加節點，所以 -1</span></span><br><span class="line">        <span class="keyword">if</span>(active_node == root &amp;&amp; active_len &gt; <span class="number">0</span> )&#123; </span><br><span class="line">            <span class="comment">//active_len &gt; 0 表示我們現在做的是把隱藏節點新增，所以要減掉</span></span><br><span class="line">            <span class="comment">//active_node == root 確保有回到根節點才做隱藏節點減掉，否則 </span></span><br><span class="line">            <span class="comment">//text[node.start + active_len ] 就會亂掉</span></span><br><span class="line">            active_len-- ;</span><br><span class="line">            <span class="comment">//由於我們減少了一個隱藏長度，所以 -1 </span></span><br><span class="line">            active_e = pos - remainder_ + <span class="number">1</span> ;</span><br><span class="line">            <span class="comment">//找到減少後隱藏長度的第一個隱藏字元，此時如果 active_len == 0，</span></span><br><span class="line">            <span class="comment">// 則下次迴圈則在 active_e 會被重新定義成 pos</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 跟著 slink 走去改動其他的後綴在 tree[active_node].slink &gt; 0 時，</span></span><br><span class="line">            <span class="comment">// 否則則回到 root，繼續建立後綴樹</span></span><br><span class="line">            active_node = tree[active_node].slink &gt; <span class="number">0</span> ? tree[active_node].slink : root ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Suffix-Array-應用"><a href="#Suffix-Array-應用" class="headerlink" title="Suffix Array 應用"></a>Suffix Array 應用</h2><p>我在學習此演算法的過程中如果有題目讓我應用到此演算法我則收錄在此，連結則是我的詳解如果想要去看題目的就搜尋一下吧！</p>
<h3 id="最長重複子字串-longest-repeated-substring"><a href="#最長重複子字串-longest-repeated-substring" class="headerlink" title="最長重複子字串 longest repeated substring"></a>最長重複子字串 longest repeated substring</h3><ul>
<li><a href="https://theriseofdavid.github.io//2020/11/04/UVa/UVa11512/" target="_blank" rel="noopener">UVa11512 - GATTACA </a></li>
<li><a href="https://theriseofdavid.github.io/2020/11/05/UVa/UVa1223/" target="_blank" rel="noopener">UVa1223 - Editor </a></li>
</ul>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://www.youtube.com/watch?v=aPRqocoBsFQ&ab_channel=TusharRoy-CodingMadeSimple" target="_blank" rel="noopener">Suffix Tree using Ukkonen’s algorithm</a><br><a href="https://www.tracholar.top/2018/02/22/ukkonens-suffix-tree-algorithm-in-plain-english/" target="_blank" rel="noopener">简单的英语中的Ukkonen后缀树算法</a><br>上述兩個為我學習此演算法的學習重點<br><a href="https://gist.github.com/makagonov/f7ed8ce729da72621b321f0ab547debb" target="_blank" rel="noopener">github makagonov/ST.cpp Secret</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>學習這演算法花了我很多時間還耗盡了很多腦細胞呢…嗚嗚，太笨了，看網路上的資源都還看不太懂，其實在網路上找資料是一件很花時間的事情，有些 blog 的資訊是錯誤亦或是寫得過於簡單，於是希望我這篇是可以不誤導他人，<del>我想應該很難，不過我的 blog 不太容易被找到吧XD，應該不會禍害大家</del>，學習 Suffix Tree 可能是我方法不對，讓我這次的學習演算法之路非常痛苦，我不會說這一次的學習是快樂的，但確實是在困難中的演算法學習最快的，因為我有壓力，壓力大到連睡覺都睡不著，身體一直記著要趕快學好此演算法。</p>
<p>我想聊一些關於寫演算法的事情，寫演算法是快樂的，但在<strong>學習</strong>演算法的過程中其實是非常痛苦的，因為你想不透可又不想認輸是件非常痛苦的事情，你會懷疑自己，在這時候我突然認為許多書上講得符合在我的經驗中，「比賽，最大的敵人是你自己」，你在學習演算法時常會遇到新的困境，當你突破時又有可能遇到新的問題，過程中你會不斷詢問自己，自己是對的嗎？我是不是對演算法沒有天賦，到現在就算我學習了這個演算法還是覺得自己很沒有天賦，需要花很多時間學習與準備。</p>
<p>老實講，我很羨慕台灣頂大的學生，有很好的機會可以遇到好老師發展，在台北科大，會演算法的老師其實並不多，這是一個非常可怕的問題，他導致整間學校的演算法水準都停擺在會 Sort 的情況，這樣寫出來的程式品質怎麼會是好的，然後老師們也不熱心於去學習新的演算法，不在意學生的程式知識水準這樣怎麼可以培養出優秀的人才，當我向老師詢問比較進階的演算法時老師都保持消極的態度導致我只能在網路上自學，不斷遇到錯誤、遇到挫折，懷疑自己。</p>
<p><strong>如果可以，有誰會想要遇到挫折，我只想要快樂的活著</strong></p>
<p>總之，我希望台灣頂大的學生都可以好好把握住自己的機會，不然困在北科的我會很難過QQ，之後有空再讓我說說我認為台灣教育制度的不公平。</p>
<h2 id="Suffix-Tree-無註解程式碼"><a href="#Suffix-Tree-無註解程式碼" class="headerlink" title="Suffix Tree 無註解程式碼"></a>Suffix Tree 無註解程式碼</h2><p>這裡則放置沒有註解的程式碼，如果讀者想要複製就從這裡進行複製吧！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> T 110</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100100</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> root , cnt , pos , needSL , remainder_ , <span class="comment">// note:remainder is cmath function</span></span><br><span class="line">    active_node , active_e , active_len ;</span><br><span class="line"><span class="built_in">string</span> text ;</span><br><span class="line"><span class="keyword">int</span> oo ;</span><br><span class="line"><span class="keyword">int</span> max_lrs = <span class="number">0</span> , lrs_index = <span class="number">0</span> , lrs_repeat = <span class="number">0</span> ;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> start , end ,slink ;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; next ;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">edge_length</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> min(end , pos+<span class="number">1</span>) - start ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> st , <span class="keyword">int</span> ed = oo)</span></span>&#123;</span><br><span class="line">        start = st ;</span><br><span class="line">        end = ed ;</span><br><span class="line">        slink = <span class="number">0</span> ;</span><br><span class="line">        next.clear() ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;tree[<span class="number">2</span>*N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">active_edge</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> text[active_e] ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_SL</span><span class="params">(<span class="keyword">int</span> node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(needSL &gt; <span class="number">0</span> ) tree[needSL].slink = node ;</span><br><span class="line">    needSL = node ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">walkdown</span><span class="params">(<span class="keyword">int</span> node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(active_len &gt;= tree[node].edge_length())&#123;</span><br><span class="line">        active_e += tree[node].edge_length() ;</span><br><span class="line">        active_len -= tree[node].edge_length() ;</span><br><span class="line">        active_node = node ;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">st_init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//tree root is 1 not zero</span></span><br><span class="line">    needSL = remainder_ = <span class="number">0</span> ;</span><br><span class="line">    active_node = active_e = active_len = <span class="number">0</span> ;</span><br><span class="line">    pos = <span class="number">-1</span> ;</span><br><span class="line"></span><br><span class="line">    cnt = root = <span class="number">1</span> ;</span><br><span class="line">    active_node = <span class="number">1</span> ;</span><br><span class="line">    tree[cnt++].init(<span class="number">-1</span>,<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">st_extend</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">    pos++;</span><br><span class="line">    needSL = <span class="number">0</span> ;</span><br><span class="line">    remainder_++ ;</span><br><span class="line">    <span class="keyword">while</span>(remainder_ &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(active_len == <span class="number">0</span> ) active_e = pos ;</span><br><span class="line">        <span class="keyword">if</span>(tree[active_node].next[active_edge()] == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> leaf = cnt ;</span><br><span class="line">            tree[cnt++].init(pos) ;</span><br><span class="line">            tree[active_node].next[active_edge()] = leaf ;</span><br><span class="line">            add_SL(active_node) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> nxt = tree[active_node].next[active_edge()] ;</span><br><span class="line">            <span class="keyword">if</span>(walkdown(nxt)) <span class="keyword">continue</span> ;</span><br><span class="line">            <span class="keyword">if</span>(text[tree[nxt].start + active_len] == c)&#123;</span><br><span class="line">                active_len++ ;</span><br><span class="line">                add_SL(active_node) ;</span><br><span class="line">                <span class="keyword">break</span> ;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> split = cnt ;</span><br><span class="line">            tree[cnt++].init(tree[nxt].start , tree[nxt].start + active_len) ;</span><br><span class="line">            tree[active_node].next[active_edge()] = split ;</span><br><span class="line">            <span class="keyword">int</span> leaf = cnt ;</span><br><span class="line">            tree[cnt++].init(pos) ;</span><br><span class="line">            tree[split].next[c] = leaf ;</span><br><span class="line">            tree[nxt].start += active_len ;</span><br><span class="line">            tree[split].next[text[tree[nxt].start]] = nxt ;</span><br><span class="line">            add_SL(split) ;</span><br><span class="line">        &#125;</span><br><span class="line">        remainder_-- ;</span><br><span class="line">        <span class="keyword">if</span>(active_node == root &amp;&amp; active_len &gt; <span class="number">0</span> )&#123;</span><br><span class="line">            active_len -- ;</span><br><span class="line">            active_e = pos - remainder_ + <span class="number">1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            active_node = tree[active_node].slink &gt; <span class="number">0</span> ? tree[active_node].slink : root ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; cnt ; i++)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">' '</span> &lt;&lt; tree[i].start &lt;&lt; <span class="string">' '</span> &lt;&lt; tree[i].end &lt;&lt; <span class="string">' '</span> &lt;&lt; tree[i].slink &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it : tree[i].next)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; it.first &lt;&lt; <span class="string">' '</span> &lt;&lt; it.second &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="用紙筆去模擬-Suffix-Tree"><a href="#用紙筆去模擬-Suffix-Tree" class="headerlink" title="用紙筆去模擬 Suffix Tree"></a>用紙筆去模擬 Suffix Tree</h2><p>因為只是自己在思考過程中隨手做的筆記，覺得不是對讀者這麼有幫助，因此放在文章最下面。</p>
<p>有時候用想或用看的可能不太能夠懂這演算法，那就用寫的吧！這是大衛我自己學習的手稿，紀錄者我的學習過程。</p>
<blockquote>
<p>“xyzxyaxyz$” 圖解步驟表，不含最後一步</p>
</blockquote>
<p><img src="/images/suffix-tree/17.jpg" alt=""></p>
<blockquote>
<p>“xyzxyaxyz$” 程式實際跑一遍圖表 A</p>
</blockquote>
<p><img src="/images/suffix-tree/16.jpg" alt=""></p>
<blockquote>
<p>“xyzxyaxyz$” 程式實際跑一遍圖表 B，加上 Suffix Tree 最後一步圖表</p>
</blockquote>
<p><img src="/images/suffix-tree/15.jpg" alt=""></p>
]]></content>
      <categories>
        <category>演算法知識</category>
      </categories>
      <tags>
        <tag>程式解題</tag>
        <tag>字串處理</tag>
        <tag>演算法知識</tag>
        <tag>最長重複子字串 Longest Repeated Substring</tag>
        <tag>後綴樹 Suffix Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa1223 - Editor (Suffix Tree 後綴樹 - 最長重複子字串 Longest Repeated Substring)</title>
    <url>/2020/11/05/UVa/UVa1223/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>有一位優秀的程式設計師想要寫出一個 Editor，他希望你幫他寫出一個功能關於在一個字串中找出最長重複子字串，並輸出總共出現幾次。</p>
</blockquote>
<a id="more"></a>

<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>標準的<strong>最長重複子字串 Longest Repeated Substring</strong>問題，使用 Suffix Tree 是不錯的選擇，如果你不知道 Suffix Tree 是甚麼？那你可以去看看<a href="https://theriseofdavid.github.io/2020/11/03/Explain_Algorithm/suffix-tree/" target="_blank" rel="noopener">演算法知識 - Suffix Tree 後綴樹 (Using Ukkonen Algorithm)</a>，裡面有對於 Suffix Tree 做出還不賴的說明，也可以利用他的參考連結去找到更適合你的說明方式。</p>
<h3 id="QUESTION-A-最長重複子字串-Longest-Repeated-Substring-是甚麼？"><a href="#QUESTION-A-最長重複子字串-Longest-Repeated-Substring-是甚麼？" class="headerlink" title="QUESTION A: 最長重複子字串 (Longest Repeated Substring) 是甚麼？"></a>QUESTION A: 最長重複子字串 (Longest Repeated Substring) 是甚麼？</h3><p>給你一組字串，找出最長的重複子字串，<del>就跟字面上的意思一樣</del>，這題可以算是一個模板題。</p>
<h3 id="那要怎麼解題呢？"><a href="#那要怎麼解題呢？" class="headerlink" title="那要怎麼解題呢？"></a>那要怎麼解題呢？</h3><p>其實容易想到，做一次 DFS，由於 Suffix Tree 的特性是只要不是 leaf(葉節點)就表示至少此節點下面有兩個 leaf，透過此特性可以知道<strong>重複的特性</strong>，再透過 DFS 向下追蹤的特性可以找出 <strong>最長重複子字串</strong>，再利用此節點下有多少個 leaf，就可以知道重複幾次了！</p>
<h3 id="QUESTION-B-那要怎麼找到最長重複子字串-Longest-Repeated-Substring-開的-index-呢？"><a href="#QUESTION-B-那要怎麼找到最長重複子字串-Longest-Repeated-Substring-開的-index-呢？" class="headerlink" title="QUESTION B: 那要怎麼找到最長重複子字串 (Longest Repeated Substring) 開的 index 呢？"></a>QUESTION B: 那要怎麼找到最長重複子字串 (Longest Repeated Substring) 開的 index 呢？</h3><p>簡單，只需要用葉節點的 start 減掉 <strong>LRS(最長重複子字串) 長度</strong>就可以知道是從哪個 index 開始了！</p>
<h3 id="簡單的程式碼說明"><a href="#簡單的程式碼說明" class="headerlink" title="簡單的程式碼說明"></a>簡單的程式碼說明</h3><p>請注意，這題只需要輸出 max_lrs 即可，但我為了 debug 方便因此全部都先寫出來方便除錯。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lrs_dfs</span><span class="params">(<span class="keyword">int</span> r , <span class="keyword">int</span> len , <span class="keyword">int</span> repeats )</span></span>&#123; <span class="comment">//dfs for suffix tree</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it : tree[r].next)&#123; <span class="comment">// 向下追蹤節點</span></span><br><span class="line">        lrs_dfs(it.second , len + tree[r].edge_length() , tree[r].next.size());</span><br><span class="line">        <span class="comment">// len + tree[r].edge_length()  當前最長重複長度</span></span><br><span class="line">        <span class="comment">//  tree[r].next.size() 下面有幾個節點表示至少重複幾次 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tree[r].slink == <span class="number">0</span> &amp;&amp; len &gt; max_lrs)&#123; </span><br><span class="line">        <span class="comment">//走訪到根節點且當前最長重複長度 &gt; 最長重複子字串 則將當前的資料都換成 LRS 表示</span></span><br><span class="line">        lrs_repeat = repeats ; <span class="comment">// 重複次數</span></span><br><span class="line">        max_lrs = len ; <span class="comment">// 長度</span></span><br><span class="line">        lrs_index = tree[r].start - len ; <span class="comment">// 初始的 index</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://theriseofdavid.github.io/2020/11/03/Explain_Algorithm/suffix-tree/" target="_blank" rel="noopener">演算法知識 - Suffix Tree 後綴樹 (Using Ukkonen Algorithm)</a><br><a href="https://theriseofdavid.github.io/2020/11/04/UVa/UVa11512/" target="_blank" rel="noopener">UVa11512 - GATTACA (Suffix Tree 後綴樹 - 最長重複子字串 Longest Repeated Substring)</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>老實講學完了 Suffix Tree 感覺真的很不賴，這題可以馬上解開讓我自己有滿滿的成就感呢XD，希望以後遇到我有學過的題目都可以這樣迅速解開那是最棒的了！也希望我所學的演算法知識都能應用在實務上，這樣一定會讓我更肯定學習演算法是正確也是必要的事情！</p>
<p>總感覺自己把成功視為理所當然，失敗視為禁忌，失敗的心得總是在檢討自己，成功時都在為自己感到自信，感覺有點不太好呢！不過如果這樣可以讓自己進步的話，似乎也不錯嗎？讓我慢慢長大慢慢檢視我自己吧！<del>好像有點用太多驚嘆號了</del></p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>其實就是沒有附上說明的程式碼，希望可以幫助到各位，也期望大家想要學習的知識都可以快速學習而成，不要因為自身的環境不足而學習不到。</p>
<p>於是這裡就補述一些題目給的資料範圍限制與標頭檔了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5020</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> root , cnt , pos , needSL ,remainder_ ,</span><br><span class="line">    active_node , active_e , active_len ;</span><br><span class="line"><span class="built_in">string</span> text ;</span><br><span class="line"><span class="keyword">int</span> oo ;</span><br><span class="line"><span class="keyword">int</span> max_lrs = <span class="number">0</span> , lrs_index = <span class="number">0</span> , lrs_repeat = <span class="number">0</span> ;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> start , end , slink ;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; next ;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">edge_length</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> min(end,pos+<span class="number">1</span>) - start ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> st , <span class="keyword">int</span> ed = oo)</span></span>&#123;</span><br><span class="line">        start = st ;</span><br><span class="line">        end = ed ;</span><br><span class="line">        slink = <span class="number">0</span> ;</span><br><span class="line">        next.clear() ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;tree[<span class="number">2</span>*N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">active_edge</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> text[active_e] ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_SL</span><span class="params">(<span class="keyword">int</span> node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(needSL &gt; <span class="number">0</span> ) tree[needSL].slink = node;</span><br><span class="line">    needSL = node ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">walkdown</span><span class="params">(<span class="keyword">int</span> node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(active_len &gt;= tree[node].edge_length())&#123;</span><br><span class="line">        active_e += tree[node].edge_length() ;</span><br><span class="line">        active_len -= tree[node].edge_length();</span><br><span class="line">        active_node = node ;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">st_init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    needSL = remainder_ = <span class="number">0</span> ;</span><br><span class="line">    active_node = active_e = active_len = <span class="number">0</span> ;</span><br><span class="line">    pos = <span class="number">-1</span> ;</span><br><span class="line"></span><br><span class="line">    cnt = root = <span class="number">1</span> ;</span><br><span class="line">    active_node = <span class="number">1</span> ;</span><br><span class="line">    tree[cnt++].init(<span class="number">-1</span>,<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">st_extend</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">    pos++ ;</span><br><span class="line">    needSL = <span class="number">0</span> ;</span><br><span class="line">    remainder_++ ;</span><br><span class="line">    <span class="keyword">while</span>(remainder_ &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(active_len == <span class="number">0</span> ) active_e = pos ;</span><br><span class="line">        <span class="keyword">if</span>(tree[active_node].next[active_edge()] == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> leaf = cnt ;</span><br><span class="line">            tree[cnt++].init(pos) ;</span><br><span class="line">            tree[active_node].next[active_edge()] = leaf ;</span><br><span class="line">            add_SL(active_node) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> nxt = tree[active_node].next[active_edge()] ;</span><br><span class="line">            <span class="keyword">if</span>(walkdown(nxt)) <span class="keyword">continue</span> ;</span><br><span class="line">            <span class="keyword">if</span>(text[tree[nxt].start + active_len] == c)&#123;</span><br><span class="line">                active_len++ ;</span><br><span class="line">                add_SL(active_node) ;</span><br><span class="line">                <span class="keyword">break</span> ;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> split = cnt;</span><br><span class="line">            tree[cnt++].init(tree[nxt].start , tree[nxt].start + active_len) ;</span><br><span class="line">            tree[active_node].next[active_edge()] = split ;</span><br><span class="line">            <span class="keyword">int</span> leaf = cnt;</span><br><span class="line">            tree[cnt++].init(pos) ;</span><br><span class="line">            tree[split].next[c] = leaf ;</span><br><span class="line">            tree[nxt].start += active_len ;</span><br><span class="line">            tree[split].next[text[tree[nxt].start]] = nxt ;</span><br><span class="line">            add_SL(split) ;</span><br><span class="line">        &#125;</span><br><span class="line">        remainder_-- ;</span><br><span class="line">        <span class="keyword">if</span>(active_node == root &amp;&amp; active_len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            active_len--;</span><br><span class="line">            active_e = pos - remainder_ + <span class="number">1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            active_node = tree[active_node].slink &gt; <span class="number">0</span> ? tree[active_node].slink : root ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; cnt ; i++)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">' '</span> &lt;&lt; tree[i].start &lt;&lt; <span class="string">' '</span> &lt;&lt; tree[i].end &lt;&lt; <span class="string">' '</span> &lt;&lt; tree[i].slink &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it : tree[i].next)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; it.first &lt;&lt; <span class="string">' '</span> &lt;&lt; it.second &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lrs_dfs</span><span class="params">(<span class="keyword">int</span> r , <span class="keyword">int</span> len , <span class="keyword">int</span> repeats)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it : tree[r].next)&#123;</span><br><span class="line">        lrs_dfs(it.second , len + tree[r].edge_length() , tree[r].next.size()) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tree[r].slink == <span class="number">0</span> &amp;&amp; len &gt; max_lrs)&#123;</span><br><span class="line">        lrs_repeat = repeats ;</span><br><span class="line">        max_lrs = len ;</span><br><span class="line">        lrs_index = tree[r].start - len ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">int</span> n ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; text ;</span><br><span class="line">        st_init() ;</span><br><span class="line">        text += <span class="string">"$"</span> ;</span><br><span class="line">        oo = text.length() ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; text.length() ; i++) st_extend(text[i]);</span><br><span class="line"></span><br><span class="line">        max_lrs = lrs_index = lrs_repeat = <span class="number">0</span> ;</span><br><span class="line">        lrs_dfs(root,<span class="number">0</span>,<span class="number">0</span>) ;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; max_lrs &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>程式解題</tag>
        <tag>字串處理</tag>
        <tag>演算法知識</tag>
        <tag>最長重複子字串 Longest Repeated Substring</tag>
        <tag>Suffix Tree 後綴樹</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa11512 - GATTACA (Suffix Tree 後綴樹 - 最長重複子字串 Longest Repeated Substring)</title>
    <url>/2020/11/04/UVa/UVa11512/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>生物學家們要透過 DNA bases(A,C,G,T) 在人類的 DNA 片段中找出最長重複的子字串並且告訴生物學家出現幾遍。</p>
</blockquote>
<a id="more"></a>

<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>這題使用 Suffix Tree 做<strong>最長重複子字串 Longest Repeated Substring</strong>是不錯的選擇，Suffix Tree 是甚麼？那你可以去看看<a href="https://theriseofdavid.github.io/2020/11/03/Explain_Algorithm/suffix-tree/" target="_blank" rel="noopener">演算法知識 - Suffix Tree 後綴樹 (Using Ukkonen Algorithm)</a>，裡面有對於 Suffix Tree 做出還不賴的說明，也可以利用他的參考連結去找到更適合你的說明方式。</p>
<h3 id="QUESTION-A-最長重複子字串-Longest-Repeated-Substring-是甚麼？"><a href="#QUESTION-A-最長重複子字串-Longest-Repeated-Substring-是甚麼？" class="headerlink" title="QUESTION A: 最長重複子字串 (Longest Repeated Substring) 是甚麼？"></a>QUESTION A: 最長重複子字串 (Longest Repeated Substring) 是甚麼？</h3><p>給你一組字串，找出最長的重複子字串，<del>就跟字面上的意思一樣</del>，這題可以算是一個模板題。</p>
<h3 id="那要怎麼解題呢？"><a href="#那要怎麼解題呢？" class="headerlink" title="那要怎麼解題呢？"></a>那要怎麼解題呢？</h3><p>其實容易想到，做一次 DFS，由於 Suffix Tree 的特性是只要不是 leaf(葉節點)就表示至少此節點下面有兩個 leaf，透過此特性可以知道<strong>重複的特性</strong>，再透過 DFS 向下追蹤的特性可以找出 <strong>最長重複子字串</strong>，再利用此節點下有多少個 leaf，就可以知道重複幾次了！</p>
<h3 id="QUESTION-B-那要怎麼找到最長重複子字串-Longest-Repeated-Substring-開的-index-呢？"><a href="#QUESTION-B-那要怎麼找到最長重複子字串-Longest-Repeated-Substring-開的-index-呢？" class="headerlink" title="QUESTION B: 那要怎麼找到最長重複子字串 (Longest Repeated Substring) 開的 index 呢？"></a>QUESTION B: 那要怎麼找到最長重複子字串 (Longest Repeated Substring) 開的 index 呢？</h3><p>簡單，只需要用葉節點的 start 減掉 <strong>LRS(最長重複子字串) 長度</strong>就可以知道是從哪個 index 開始了！</p>
<h3 id="簡單的程式碼說明"><a href="#簡單的程式碼說明" class="headerlink" title="簡單的程式碼說明"></a>簡單的程式碼說明</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lrs_dfs</span><span class="params">(<span class="keyword">int</span> r , <span class="keyword">int</span> len , <span class="keyword">int</span> repeats )</span></span>&#123; <span class="comment">//dfs for suffix tree</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it : tree[r].next)&#123; <span class="comment">// 向下追蹤節點</span></span><br><span class="line">        lrs_dfs(it.second , len + tree[r].edge_length() , tree[r].next.size());</span><br><span class="line">        <span class="comment">// len + tree[r].edge_length()  當前最長重複長度</span></span><br><span class="line">        <span class="comment">//  tree[r].next.size() 下面有幾個節點表示至少重複幾次 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tree[r].slink == <span class="number">0</span> &amp;&amp; len &gt; max_lrs)&#123; </span><br><span class="line">        <span class="comment">//走訪到根節點且當前最長重複長度 &gt; 最長重複子字串 則將當前的資料都換成 LRS 表示</span></span><br><span class="line">        lrs_repeat = repeats ; <span class="comment">// 重複次數</span></span><br><span class="line">        max_lrs = len ; <span class="comment">// 長度</span></span><br><span class="line">        lrs_index = tree[r].start - len ; <span class="comment">// 初始的 index</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://theriseofdavid.github.io/2020/11/03/Explain_Algorithm/suffix-tree/" target="_blank" rel="noopener">演算法知識 - Suffix Tree 後綴樹 (Using Ukkonen Algorithm)</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>其實學會了 Suffix Tree 後此 最長重複子字串 Longest Repeated Substring 是我自己看著網路上的說明文章就學會的，內心其實還是有一點點小成就感的，能夠靠著自己的雙手把它解決不依賴他人，雖然這是需要花上時間大量學習才能夠達到這樣的成就，但怎麼講，能夠靠著自己的雙手解決真的很不賴押！</p>
<p>雖然還是希望自己可以加速迎頭趕上他人，我不想再輸。</p>
<p>雖然我在抓這題的 bug 花了大量時間，這題其實我想一小時就解出來，自己領悟出 LRS，但錯在一個自己從來沒有錯的點才讓我自己在抓 bug 花了大量時間，請大家記住一件事情，在 C++11 中 <code>struct</code> 內的 function 如果沒有要回傳值要記得打 <code>void</code> 而不是 <code>int</code>，在 Uva Online Judge 是會出現 <strong>runtime error</strong>，UVa Online Judge 是不通情理的押，不像我家 Windows 人很好，如果你在裡面寫 int 沒有 return 照樣可以跑，還一樣快的QQ。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>其實就是沒有附上說明的程式碼，我也花了七個小時撰寫文章(Suffix Tree + 此題題解)，看得懂跟說得出來真的是兩回事，也許還有人覺得我說的很差，不過我已經盡力解釋。希望可以幫助到各位。</p>
<p>也希望大家想要學習的知識都可以快速學習而成，不要因為自身的環境不足而學習不到。</p>
<p>於是這裡就補述一些題目給的資料範圍限制與標頭檔了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> T 110</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100100</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> root , cnt , pos , needSL , remainder_ , <span class="comment">// note:remainder is cmath function</span></span><br><span class="line">    active_node , active_e , active_len ;</span><br><span class="line"><span class="built_in">string</span> text ;</span><br><span class="line"><span class="keyword">int</span> oo ;</span><br><span class="line"><span class="keyword">int</span> max_lrs = <span class="number">0</span> , lrs_index = <span class="number">0</span> , lrs_repeat = <span class="number">0</span> ;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> start , end ,slink ;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; next ;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">edge_length</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> min(end , pos+<span class="number">1</span>) - start ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> st , <span class="keyword">int</span> ed = oo)</span></span>&#123;</span><br><span class="line">        start = st ;</span><br><span class="line">        end = ed ;</span><br><span class="line">        slink = <span class="number">0</span> ;</span><br><span class="line">        next.clear() ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;tree[<span class="number">2</span>*N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">active_edge</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> text[active_e] ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_SL</span><span class="params">(<span class="keyword">int</span> node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(needSL &gt; <span class="number">0</span> ) tree[needSL].slink = node ;</span><br><span class="line">    needSL = node ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">walkdown</span><span class="params">(<span class="keyword">int</span> node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(active_len &gt;= tree[node].edge_length())&#123;</span><br><span class="line">        active_e += tree[node].edge_length() ;</span><br><span class="line">        active_len -= tree[node].edge_length() ;</span><br><span class="line">        active_node = node ;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">st_init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//tree root is 1 not zero</span></span><br><span class="line">    needSL = remainder_ = <span class="number">0</span> ;</span><br><span class="line">    active_node = active_e = active_len = <span class="number">0</span> ;</span><br><span class="line">    pos = <span class="number">-1</span> ;</span><br><span class="line"></span><br><span class="line">    cnt = root = <span class="number">1</span> ;</span><br><span class="line">    active_node = <span class="number">1</span> ;</span><br><span class="line">    tree[cnt++].init(<span class="number">-1</span>,<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">st_extend</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">    pos++;</span><br><span class="line">    needSL = <span class="number">0</span> ;</span><br><span class="line">    remainder_++ ;</span><br><span class="line">    <span class="keyword">while</span>(remainder_ &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(active_len == <span class="number">0</span> ) active_e = pos ;</span><br><span class="line">        <span class="keyword">if</span>(tree[active_node].next[active_edge()] == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> leaf = cnt ;</span><br><span class="line">            tree[cnt++].init(pos) ;</span><br><span class="line">            tree[active_node].next[active_edge()] = leaf ;</span><br><span class="line">            add_SL(active_node) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> nxt = tree[active_node].next[active_edge()] ;</span><br><span class="line">            <span class="keyword">if</span>(walkdown(nxt)) <span class="keyword">continue</span> ;</span><br><span class="line">            <span class="keyword">if</span>(text[tree[nxt].start + active_len] == c)&#123;</span><br><span class="line">                active_len++ ;</span><br><span class="line">                add_SL(active_node) ;</span><br><span class="line">                <span class="keyword">break</span> ;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> split = cnt ;</span><br><span class="line">            tree[cnt++].init(tree[nxt].start , tree[nxt].start + active_len) ;</span><br><span class="line">            tree[active_node].next[active_edge()] = split ;</span><br><span class="line">            <span class="keyword">int</span> leaf = cnt ;</span><br><span class="line">            tree[cnt++].init(pos) ;</span><br><span class="line">            tree[split].next[c] = leaf ;</span><br><span class="line">            tree[nxt].start += active_len ;</span><br><span class="line">            tree[split].next[text[tree[nxt].start]] = nxt ;</span><br><span class="line">            add_SL(split) ;</span><br><span class="line">        &#125;</span><br><span class="line">        remainder_-- ;</span><br><span class="line">        <span class="keyword">if</span>(active_node == root &amp;&amp; active_len &gt; <span class="number">0</span> )&#123;</span><br><span class="line">            active_len -- ;</span><br><span class="line">            active_e = pos - remainder_ + <span class="number">1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            active_node = tree[active_node].slink &gt; <span class="number">0</span> ? tree[active_node].slink : root ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; cnt ; i++)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">' '</span> &lt;&lt; tree[i].start &lt;&lt; <span class="string">' '</span> &lt;&lt; tree[i].end &lt;&lt; <span class="string">' '</span> &lt;&lt; tree[i].slink &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it : tree[i].next)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; it.first &lt;&lt; <span class="string">' '</span> &lt;&lt; it.second &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lrs_dfs</span><span class="params">(<span class="keyword">int</span> r , <span class="keyword">int</span> len , <span class="keyword">int</span> repeats )</span></span>&#123; <span class="comment">//dfs for suffix tree</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it : tree[r].next)&#123;</span><br><span class="line">        lrs_dfs(it.second , len + tree[r].edge_length() , tree[r].next.size());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tree[r].slink == <span class="number">0</span> &amp;&amp; len &gt; max_lrs)&#123;</span><br><span class="line">        lrs_repeat = repeats ;</span><br><span class="line">        max_lrs = len ;</span><br><span class="line">        lrs_index = tree[r].start - len ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> );</span><br><span class="line">    <span class="comment">//freopen("out.txt" , "w" , stdout );</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">int</span> n ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; text ;</span><br><span class="line"></span><br><span class="line">        st_init() ;</span><br><span class="line">        text += <span class="string">"$"</span> ;</span><br><span class="line">        oo = text.length() ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; text.length() ; i++) st_extend(text[i]);</span><br><span class="line"></span><br><span class="line">        max_lrs = <span class="number">0</span> , lrs_index = <span class="number">0</span> , lrs_repeat = <span class="number">0</span> ;</span><br><span class="line">        lrs_dfs(root , <span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(max_lrs)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; text.substr(lrs_index , max_lrs) &lt;&lt; <span class="string">' '</span> &lt;&lt; lrs_repeat &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"No repetitions found!\n"</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>程式解題</tag>
        <tag>字串處理</tag>
        <tag>演算法知識</tag>
        <tag>最長重複子字串 Longest Repeated Substring</tag>
        <tag>Suffix Tree 後綴樹</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa10192 - Vacation (LCS)</title>
    <url>/2020/11/07/UVa/UVa10192/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>爸媽想要出國出去玩，<del>可是今年有疫情欸，拔麻</del>，反正爸媽不管且還要求出國的遊玩順序一定要按照他們想法，這讓我非常煩惱，但他們願意略過一些他們想去的地方，但順序必須一樣，試問如果爸媽都有自己的出國遊玩順序再不影響他們順序時他們可以去的最大長度？</p>
<p>注意：這題輸入字串會有 space , uppercase letters , lowercase letters<br>所以要使用 <code>getline(string,cin)</code> 會是最好的方法</p>
</blockquote>
<a id="more"></a>

<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>這題是標準的 LCS 問題，可以用 \(O(n^2\) and \(O(n \log n) \) 解開，這裡使用 \(O(n \log n)\) 來解決此問題。</p>
<p>如果還不太懂 LCS 是甚麼問題，建議看看 <a href="https://theriseofdavid.github.io/2020/11/11/Explain_Algorithm/LCS/" target="_blank" rel="noopener">演算法知識 - Longest Common Subsequence 最長共同子序列(時間複雜度 O(nlogn))</a>，這裡有對於此演算法有完整的介紹</p>
<h2 id="焦點回到題目上，解開題目的小設計"><a href="#焦點回到題目上，解開題目的小設計" class="headerlink" title="焦點回到題目上，解開題目的小設計"></a>焦點回到題目上，解開題目的小設計</h2><p>記住他的輸出還要輸出一些文字，不是只直接輸出 LCS 的長度即可。</p>
<p>P.S. 下方題目程式碼的 string index 由 1 開始方便編寫程式碼，主要方便用來 LIS 如果要更改 cur 成 0 時會造成 <code>t[-1]</code> ，只需要在 <code>string = &quot;$&quot; + string</code>，即可達到此功效</p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>這題其實沒有很難，但是我搞了很久因為 udebug 壞掉了，嗚嗚嗚，沒有 Udebug 我就超像一個白癡一樣甚麼都不會，不可以阿大衛，這樣你打 ICPC 怎麼會進步呢QQ，讓我發現我對 Udebug 就像是小孩子依賴麻麻一般，要是沒有了她我則甚麼都不會。</p>
<p>盡量不要這樣，可能需要增進自己去 hack 測試資料的能力並想出自己程式碼的漏洞，不過明明寫出自己覺得沒有錯的程式碼然後想錯誤，其實也是一件蠻痛苦的事情呢XD。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>其實就是沒有附上說明的程式碼，看得懂跟說得出來真的是兩回事，也許還有人覺得我說的很差，不過我已經盡力解釋。希望可以幫助到各位。</p>
<p>也希望大家想要學習的知識都可以快速學習而成，不要因為自身的環境不足而學習不到。</p>
<p>於是這裡就補述一些題目給的資料範圍限制與標頭檔了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 120</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n ;</span><br><span class="line"><span class="built_in">string</span> strA , strB ;</span><br><span class="line"><span class="keyword">int</span> t[N*N] , d[N*N] , num[N*N] ; <span class="comment">//determine</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dict ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bs</span><span class="params">(<span class="keyword">int</span> l , <span class="keyword">int</span> r , <span class="keyword">int</span> v )</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m ;</span><br><span class="line">    <span class="keyword">while</span>(r&gt;l)&#123;</span><br><span class="line">        m = (l+r) /<span class="number">2</span> ;</span><br><span class="line">        <span class="keyword">if</span>(num[v] &gt; num[t[m]]) l = m+<span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (num[v] &lt; num[t[m]]) r = m ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> m ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lcs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    dict.clear() ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = strA.length()<span class="number">-1</span> ; i &gt; <span class="number">0</span> ; i--) dict[strA[i]].push_back(i) ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; strB.length() ; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; dict[strB[i]].size() ; j++)</span><br><span class="line">            num[++k] = dict[strB[i]][j] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    <span class="comment">//memset(t ,-1 , sizeof(t));</span></span><br><span class="line">    d[<span class="number">1</span>] = <span class="number">0</span> , t[<span class="number">1</span>] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">1</span>, cur ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= k ; i++ )&#123;</span><br><span class="line">        <span class="keyword">if</span>(num[i] &gt; num[t[len]]) t[++len] = i , d[i] = t[len<span class="number">-1</span>] ;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cur = bs(<span class="number">1</span>,len,i);</span><br><span class="line">            t[cur] = i ;</span><br><span class="line">            d[i] = t[cur<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//debug</span></span><br><span class="line"><span class="comment">//        for(int i = 1 ; i &lt;= k ; i++)</span></span><br><span class="line"><span class="comment">//            cout &lt;&lt; num[t[i]] &lt;&lt; ' ' ;</span></span><br><span class="line"><span class="comment">//        cout &lt;&lt; '\n' ;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len ;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> ) ;</span><br><span class="line">    freopen(<span class="string">"out.txt"</span> , <span class="string">"w"</span> , <span class="built_in">stdout</span>) ;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    n = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span>(getline(<span class="built_in">cin</span>,strA) &amp;&amp; strA != <span class="string">"#"</span>)&#123;</span><br><span class="line">        getline(<span class="built_in">cin</span>,strB);</span><br><span class="line">        strA = <span class="string">"$"</span> + strA;</span><br><span class="line">        strB = <span class="string">"$"</span> + strB;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; lcs() &lt;&lt; '\n' ;</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Case #"</span> &lt;&lt; n++ &lt;&lt; <span class="string">": you can visit at most "</span> &lt;&lt; lcs() &lt;&lt; <span class="string">" cities.\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>字串處理</tag>
        <tag>最長共同子序列 Longest Common Subsequence</tag>
        <tag>演算法知識</tag>
        <tag>動態規劃 Dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title>演算法知識 - Longest Common Subsequence 最長共同子序列(時間複雜度 O(nlogn))</title>
    <url>/2020/11/11/Explain_Algorithm/LCS/</url>
    <content><![CDATA[<h2 id="Longest-Common-Subsequence-介紹"><a href="#Longest-Common-Subsequence-介紹" class="headerlink" title="Longest Common Subsequence 介紹"></a>Longest Common Subsequence 介紹</h2><blockquote>
<p>以下簡稱 LCS，在兩個序列中找出最長子序列的問題，序列是甚麼？只要順序一致即可，舉例：</p>
<ul>
<li>people</li>
<li>apple</li>
</ul>
<ul>
<li>這兩個的 LCS 就是 pple，長度為 4，子序列為 pple。</li>
</ul>
<p>看懂了嗎？ pple 在前面兩個字串中順序都是保持一致的。<br>被廣泛應用於生物資訊學與版本控制。</p>
<p>這裡我們是教導時間複雜度為 \(O(n \log n)\) 的寫法，而非 \(O(n^2)\) 的寫法</p>
<p>Longest Increasing Subsequence 最長遞增子序列，以下簡稱 LIS</p>
</blockquote>
<a id="more"></a>

<h2 id="Longest-Common-Subsequence-原理"><a href="#Longest-Common-Subsequence-原理" class="headerlink" title="Longest Common Subsequence 原理"></a>Longest Common Subsequence 原理</h2><p>先將 A 字串的值逆向輸入到一個 <code>map&lt;char,vector&lt;int&gt;&gt;</code>裡面，再根據 B 字串的字元依序將 <code>map&lt;char,vector&lt;int&gt;&gt;</code> 取出，之後做 LIS 遞增。</p>
<p>如果不懂 LIS 是甚麼可以先看<a href=""></a></p>
<h3 id="QUESTION-太驚人了！-為甚麼可以用-O-n-log-n-去解？"><a href="#QUESTION-太驚人了！-為甚麼可以用-O-n-log-n-去解？" class="headerlink" title="QUESTION: 太驚人了！ 為甚麼可以用 \(O(n \log n )\) 去解？"></a>QUESTION: 太驚人了！ 為甚麼可以用 \(O(n \log n )\) 去解？</h3><p>因為這世界天才太多了。<del>正解</del></p>
<p>開玩笑的，還記得 (\ O(n^2))\ 的解法怎麼解嗎？是用動態規劃，可是他是不是有點浪費效率，因為她只有在 <code>A[i] == B[i]</code>，才會增加長度，剩下時間都是在延續之前的狀態，我們從這裡進行補強。</p>
<p>我們只要把 A 字串的每個字元的 index 做紀錄，並將同個字元出現的多個位置放入 <code>vector</code>，放入的順序是大到小，再根據 B 字串的每個字元對應同字元的 <code>vector</code>，在做 LIS 即可，這樣我們就減少了此情況 <code>A[i] != B[i]</code>。</p>
<h2 id="Longest-Common-Subsequence-說明與舉例"><a href="#Longest-Common-Subsequence-說明與舉例" class="headerlink" title="Longest Common Subsequence 說明與舉例"></a>Longest Common Subsequence 說明與舉例</h2><h3 id="舉例"><a href="#舉例" class="headerlink" title="舉例"></a>舉例</h3><p>先舉個例子，以免被說是騙人XD。</p>
<p>String A = “abdba”<br>String B = “dbaaba” </p>
<p>對應 A 字串的每個字元的 index 做紀錄，並將同個字元出現的多個位置放入 <code>vector</code>，字串  index 從 0 開始，<strong>記住是逆序</strong>，如下：</p>
<p>a(4,0) b(3,1) d(2)</p>
<p>再來，我們根據根據 B 字串的每個字元對應同字元的 <code>vector</code>，產生序列，於是就變成</p>
<table>
<thead>
<tr>
<th>index</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
</tr>
</thead>
<tbody><tr>
<td>value</td>
<td>2</td>
<td>3</td>
<td>1</td>
<td>4</td>
<td>0</td>
<td>4</td>
<td>0</td>
<td>3</td>
<td>1</td>
<td>4</td>
<td>0</td>
</tr>
<tr>
<td>char</td>
<td>d</td>
<td>b</td>
<td></td>
<td>a</td>
<td></td>
<td>a</td>
<td></td>
<td>b</td>
<td></td>
<td>a</td>
<td></td>
</tr>
</tbody></table>
<p>看懂了？對吧！</p>
<p>而此時，這裡的 LIS 最大長度為 3，其中一種方式為 2 3 4，但這裡也只有這種XD，記住，在其他情況下 LCS 不只有一種表達方式。</p>
<p>且 d 的 vector 有 2、b 的 vector 有 3、a 的 vector 有 4，剛好能夠組成 dba，符合答案。</p>
<h3 id="QUESTION-那為甚麼要是逆序？"><a href="#QUESTION-那為甚麼要是逆序？" class="headerlink" title="QUESTION: 那為甚麼要是逆序？"></a>QUESTION: 那為甚麼要是逆序？</h3><p>很簡單，為了要避免重複判斷，一樣用剛剛的例子如下，那 <code>vector</code>會變成。</p>
<p>a(0,4) b(1,3) d(2)</p>
<table>
<thead>
<tr>
<th>index</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
</tr>
</thead>
<tbody><tr>
<td>value</td>
<td>2</td>
<td>1</td>
<td>3</td>
<td>0</td>
<td>4</td>
<td>0</td>
<td>4</td>
<td>1</td>
<td>3</td>
<td>0</td>
<td>4</td>
</tr>
<tr>
<td>char</td>
<td>d</td>
<td>b</td>
<td></td>
<td>a</td>
<td></td>
<td>a</td>
<td></td>
<td>b</td>
<td></td>
<td>a</td>
<td></td>
</tr>
</tbody></table>
<p>這樣出來的最長長度為 4，其中一種方式為 0 1 3 4，但這裡組成的字串會變成 dbba，是不是中間的 b 被重複算到了，因為 LIS 是遞增，如果我們的 <code>vector</code> 也是遞增排序時，則中間的每一個 <code>vector</code> 的 element 都會被我們選中長度會被無限放大，因此在 <code>vector</code> 時要是逆序的元素。</p>
<h3 id="OK-現在問題被我們解決成是-LIS-了，那我們就來做吧！"><a href="#OK-現在問題被我們解決成是-LIS-了，那我們就來做吧！" class="headerlink" title="OK, 現在問題被我們解決成是 LIS 了，那我們就來做吧！"></a>OK, 現在問題被我們解決成是 LIS 了，那我們就來做吧！</h3><p><a href="https://theriseofdavid.github.io/2020/11/13/Explain_Algorithm/LIS/" target="_blank" rel="noopener">關於 LIS 的部分就先去看大衞的筆記即可</a>。</p>
<h2 id="LCS-實作與說明"><a href="#LCS-實作與說明" class="headerlink" title="LCS 實作與說明"></a>LCS 實作與說明</h2><p>P.S. 這裡的 string index 由 1 開始方便編寫程式碼，主要方便用來 LIS 如果要更改 cur 成 0 時會造成 <code>t[-1]</code> ，只需要在 <code>string = &quot;$&quot; + string</code>，即可達到此功效</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 120</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n ;</span><br><span class="line"><span class="built_in">string</span> strA , strB ;</span><br><span class="line"><span class="keyword">int</span> t[N*N] , d[N*N] , num[N*N] ; <span class="comment">//t and d 是 LIS 要用到 </span></span><br><span class="line"><span class="comment">// d 用來記住 LIS 中此數字的前一個數字</span></span><br><span class="line"><span class="comment">// t 當前 LIS 的數列位置</span></span><br><span class="line"><span class="comment">// num 則是我們根據 strB 的字元生成數列，用來找出最長 LIS 長度 </span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dict ; <span class="comment">//記住每個字串出現的 index 位置</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bs</span><span class="params">(<span class="keyword">int</span> l , <span class="keyword">int</span> r , <span class="keyword">int</span> v )</span></span>&#123; <span class="comment">//binary search </span></span><br><span class="line">    <span class="keyword">int</span> m ;</span><br><span class="line">    <span class="keyword">while</span>(r&gt;l)&#123;</span><br><span class="line">        m = (l+r) /<span class="number">2</span> ;</span><br><span class="line">        <span class="keyword">if</span>(num[v] &gt; num[t[m]]) l = m+<span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (num[v] &lt; num[t[m]]) r = m ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> m ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lcs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    dict.clear() ; <span class="comment">//先將 dict 先清空</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = strA.length()<span class="number">-1</span> ; i &gt; <span class="number">0</span> ; i--) dict[strA[i]].push_back(i) ;</span><br><span class="line">    <span class="comment">// 將每個字串的位置紀錄並放入 vector 中，請記住 i = strA.length() -1 才可以達到逆續效果</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span> ; <span class="comment">//紀錄生成數列的長度的最長長度</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; strB.length() ; i++)&#123; <span class="comment">// 依據 strB 的每個字元來生成數列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; dict[strB[i]].size() ; j++) </span><br><span class="line">        <span class="comment">//將此字元在 strA 出現的位置放入數列</span></span><br><span class="line">            num[++k] = dict[strB[i]][j] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span> ; <span class="comment">//如果 k = 0 就表示他們沒有共同字元都沒有於是就直接輸出 0</span></span><br><span class="line"></span><br><span class="line">    d[<span class="number">1</span>] = <span class="number">-1</span> , t[<span class="number">1</span>] = <span class="number">1</span> ; <span class="comment">//LIS init</span></span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">1</span>, cur ; <span class="comment">// len 由於前面已經把 LCS = 0 的機會排除，於是這裡則從 1 開始</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 標準的 LIS 作法，不斷嘗試將 LCS 生長</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= k ; i++ )&#123;</span><br><span class="line">        <span class="keyword">if</span>(num[i] &gt; num[t[len]]) t[++len] = i , d[i] = t[len<span class="number">-1</span>] ;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cur = bs(<span class="number">1</span>,len,i);</span><br><span class="line">            t[cur] = i ;</span><br><span class="line">            d[i] = t[cur<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//debug</span></span><br><span class="line"><span class="comment">//        for(int i = 1 ; i &lt;= k ; i++)</span></span><br><span class="line"><span class="comment">//            cout &lt;&lt; num[t[i]] &lt;&lt; ' ' ;</span></span><br><span class="line"><span class="comment">//        cout &lt;&lt; '\n' ;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len ;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LCS-應用"><a href="#LCS-應用" class="headerlink" title="LCS 應用"></a>LCS 應用</h2><p>我在學習此演算法的過程中如果有題目讓我應用到此演算法我則收錄在此，連結則是我的詳解如果想要去看題目的就搜尋一下吧！</p>
<ul>
<li><a href="https://theriseofdavid.github.io/2020/11/07/UVa/UVa10192/" target="_blank" rel="noopener">UVa10192 - Vacation (LCS)</a></li>
<li><a href="https://theriseofdavid.github.io/2020/03/13/UVa/UVa1207/" target="_blank" rel="noopener">UVa1207 - AGTC (LCS)</a> - 這裡採用的是 \(O(n^2)\) 做法。</li>
</ul>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://blog.51cto.com/karsbin/966387" target="_blank" rel="noopener">lcs 最长公共子序列 O(nlogn)算法</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>Binary Search 好難，嗚嗚，太過於依賴 C++ STL 函數，原本心血來潮想說要來寫一遍 Binary Search 沒想到花了 6 小時都還沒寫出來(完全是透過心想)，原本想說這麼簡單的演算法我應該連紙筆都不用吧！沒想到還是需要，嗚嗚，我腦袋的 RAM 是不是連 1 KB 都沒有呀，好討厭喔。</p>
<p>不過又學了一個新演算法，用於改進 LCS 的時間複雜度其實感覺蠻開心的呢！</p>
<h2 id="LCS-無註解程式碼"><a href="#LCS-無註解程式碼" class="headerlink" title="LCS 無註解程式碼"></a>LCS 無註解程式碼</h2><p>這裡則放置沒有註解的程式碼，如果讀者想要複製就從這裡進行複製吧！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 120</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n ;</span><br><span class="line"><span class="built_in">string</span> strA , strB ;</span><br><span class="line"><span class="keyword">int</span> t[N*N] , d[N*N] , num[N*N] ; </span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dict ; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bs</span><span class="params">(<span class="keyword">int</span> l , <span class="keyword">int</span> r , <span class="keyword">int</span> v )</span></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> m ;</span><br><span class="line">    <span class="keyword">while</span>(r&gt;l)&#123;</span><br><span class="line">        m = (l+r) /<span class="number">2</span> ;</span><br><span class="line">        <span class="keyword">if</span>(num[v] &gt; num[t[m]]) l = m+<span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (num[v] &lt; num[t[m]]) r = m ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> m ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lcs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    dict.clear() ; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = strA.length()<span class="number">-1</span> ; i &gt; <span class="number">0</span> ; i--) dict[strA[i]].push_back(i) ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; strB.length() ; i++)&#123; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; dict[strB[i]].size() ; j++) </span><br><span class="line"></span><br><span class="line">            num[++k] = dict[strB[i]][j] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line"></span><br><span class="line">    d[<span class="number">1</span>] = <span class="number">0</span> , t[<span class="number">1</span>] = <span class="number">1</span> ; </span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">1</span>, cur ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= k ; i++ )&#123;</span><br><span class="line">        <span class="keyword">if</span>(num[i] &gt; num[t[len]]) t[++len] = i , d[i] = t[len<span class="number">-1</span>] ;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cur = bs(<span class="number">1</span>,len,i);</span><br><span class="line">            t[cur] = i ;</span><br><span class="line">            d[i] = t[cur<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len ;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>演算法知識</category>
      </categories>
      <tags>
        <tag>程式解題</tag>
        <tag>字串處理</tag>
        <tag>最長共同子序列 Longest Common Subsequence</tag>
        <tag>演算法知識</tag>
        <tag>動態規劃 Dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title>2020 International Collegiate Programming Contest Asia Taipei-Hsinchu Site (ICPC2020) - 65th 心得</title>
    <url>/2020/11/10/contest_experence/ICPC2020/</url>
    <content><![CDATA[<blockquote>
<p>僅此紀錄 2020/11/08 2020 ICPC 心得。<br>「紀錄每個時刻，讓未來的自己不遺忘過去的自己」<br>只有自己才能體會自己的過去<br>沒有得獎拉，只是很可惜自己還不夠好吧。</p>
<p><strong>明天要保持笑容，面對每個挑戰，因為不優秀的人是沒有資格哭泣的。</strong></p>
</blockquote>
<a id="more"></a>

<h2 id="第一天的報到"><a href="#第一天的報到" class="headerlink" title="第一天的報到"></a>第一天的報到</h2><h3 id="報到"><a href="#報到" class="headerlink" title="報到"></a>報到</h3><p>由於 ICPC 是非常正式的國際賽事，比賽前必須將自己明天要比賽的資料都<strong>事先</strong>放入考試會場內，才可以進行比賽，於是比賽的前一天 2020/11/07 就要先去報到。</p>
<p>早上大約 10:00 起床，寫了一下 UVa 的題目，一直 WA 但卻找不出問題所在，嗚嗚，我真沒用。一路寫到 12 點則從家裡出發前往北商，這是我第二次比 ICPC，這次的比賽地點也還是台北商大(北商)，與學長和漢軒在北商的司令台會合後就前往報到。</p>
<blockquote>
<p>報到時拍的北商畫面 - A</p>
</blockquote>
<p><img src="/images/ICPC2020/1.jpg" alt=""></p>
<blockquote>
<p>報到時拍的北商畫面 - B</p>
</blockquote>
<p><img src="/images/ICPC2020/2.jpg" alt=""></p>
<blockquote>
<p>隊伍留念拍照</p>
</blockquote>
<p><img src="/images/ICPC2020/11.JPG" alt=""></p>
<h3 id="進場與開幕典禮"><a href="#進場與開幕典禮" class="headerlink" title="進場與開幕典禮"></a>進場與開幕典禮</h3><p>報到時先給工作人員查看自己的學生證，確認身分無誤後給予我們參賽資料，內容有：比賽手冊、背包、衣服，這次的背包與上次不同，上次的是束口袋，這此則是布背包，讓我感覺到這次的比賽的高級感阿，好開心！之後換上今年的選手衣服後，到這次 ICPC2020 的 logo 前合照，完成了報告的全部事宜。</p>
<blockquote>
<p>進場時拍下的比賽場地照片 (Please Do Not Touch Anything)</p>
</blockquote>
<p><img src="/images/ICPC2020/2.jpg" alt=""></p>
<p>接下來上樓後學長放上我們的 NoteBook 與資料夾，整理一下環境隨後就準備要進行開幕典禮，由於今年的開幕典禮沒有國際隊伍，而沒有國際隊伍的原因是因為今年新冠肺炎疫情，因此這次的開幕典禮是用<strong>中文</strong>來開幕，蠻驚奇的，下次應該不會這樣吧www，看來我今年聽到了限量場次的 ICPC 中文演講XD。</p>
<p>這次的主辦單位總喜歡威脅隊伍www，時常聽到主辦單位說，「只要你XXXXX，我們就取消你的參賽資格。」，就像是國中老師恐嚇學生要記警告一樣XD，讓我想起了國中的恐懼www，沒，我好像到國三就沒有再害怕警告了，太屁孩了。當時不愛讀書，才導致現在只能讀北科，老實講，心情還是有點難過吧，後悔當時沒有再讀點書，想跟未來的自己說對不起，是過去的自己不努力。</p>
<blockquote>
<p>選手證</p>
</blockquote>
<p><img src="/images/ICPC2020/4.jpg" alt=""></p>
<h3 id="電腦測試"><a href="#電腦測試" class="headerlink" title="電腦測試"></a>電腦測試</h3><p>開幕典禮結束後，就準備要來寫程式啦！主要是 Demo 電腦有沒有壞掉或是出現異常的情況發生，很幸運地這次沒有，主辦單位這次有提醒我們說由於電腦是<strong>最新的 Ubuntu and CodeBlock</strong>，如果電腦當掉的話我們不負責任，嗚嗚嗚，這樣不好啦，用穩定的版本不是很好嗎，我覺得可以在稍稍改進，臨時突然用新的 IDE 真的不太習慣，不過這次同時我們也注意到這場比賽的椅子有軟墊！鍵盤也不再是那種買桌電會贈送的鍵盤，而是聯想的普通鍵盤，這讓我感到更開心，這場的硬體水準大幅提升，太開心啦，經濟回升了，對吧！</p>
<p>這一次測試電腦我們有抓出比較有趣的地方，例如我們在 C++ 中寫出 index -1 或是大於陣列的最大 index，都是沒有問題的！且送上去主辦單位的 Judge (Dom Judge) 也都可以順利編譯！這讓我超開心的拉，因為 UVa 是不會通過的，所以有些小地方都還需要注意一下，如果 C++ 會幫我注意那就太好啦，不過會導致我寫程式時越來越不小心XD，我很抱歉，不過話說 C++ 是不是要逐漸 Python 化拉。<del>越來越軟</del></p>
<p>由於中午太趕都沒有吃午餐，到大概下午 2:00 時肚子就咕嚕咕嚕地叫了，那時候我的肚子感到難過，幸好學長有說後面有一些簡單的小餅乾，我趕快去把那些餅乾吃一些，恩，好吃，好好吃，有我愛吃的，好讚！吃飽了以後就回到比賽位置坐下等待下一個程序。</p>
<h3 id="小插曲"><a href="#小插曲" class="headerlink" title="小插曲"></a>小插曲</h3><p>由於我們測試完電腦也覺得沒有問題後，我們就在等待測試的時間結束，這一次的比賽有點冷，不對，是每次的比賽都很冷XDDD，這也讓我下定決心明天一定要帶北科資財系的外套，他超級保暖，保暖到我以為這是下雪才可以穿出來的，沒有，只要是 ICPC 都可以穿，因為冷氣都會很冷，北極雄們，我對不起你們QQQ。</p>
<p>這一次比賽有提到可以帶英漢字典，但我們一開始不知道這些資訊於是沒有事先準備，但這對於英文不好的我是一大福音，於是我就臨時想到家裡小時後把我送去何嘉仁美語補習班補英文時所用的英漢字典，我就趕緊回家再把他帶過來，當我送來後則發現剛好比賽測試時間也剛好結束，時間算得剛剛好，運氣不錯XD。</p>
<h3 id="回家休息"><a href="#回家休息" class="headerlink" title="回家休息"></a>回家休息</h3><p>大約在下午 4:50 主辦單位則說我們可以準備回去，並回答一些 Q&amp;A 問題，我們稍微聆聽一下問題的回答後就回家進行休息，準備明天比賽。</p>
<p>但其實我那天睡不太著，凌晨樓下的音樂一直震動使我翻來覆去無法入眠，晚上其實也都在練習 UVa 題目希望可以把他解開，但還是解不太開，我的程式能力真的好弱，好希望可以變強，我可能需要從這一次的經驗中找出最適合我的學習成長方法。</p>
<h2 id="比賽當天"><a href="#比賽當天" class="headerlink" title="比賽當天"></a>比賽當天</h2><h3 id="報到-1"><a href="#報到-1" class="headerlink" title="報到"></a>報到</h3><p>早上起床後，我稍稍得有點賴床，起床後我則準備出門去吃我的麥當勞早餐，這應該是我人生不到五次的麥當勞早餐吧XD，麥當勞早餐其實蠻好吃的，以後可以多吃一點，而且還看到早上 8:30 竟然有大人在教小孩寫數學，這些小孩真是優秀呀，也感動大人可以從小就引導他們長大。</p>
<p>吃完了之後則順利地前往北商，由於今天是禮拜日，沒有甚麼塞車，很順利的就抵達拉。</p>
<h3 id="比賽過程"><a href="#比賽過程" class="headerlink" title="比賽過程"></a>比賽過程</h3><p>比賽時我們透過策略用資料夾來放置我們的題目，我覺得還蠻有效的，真的沒有資料亂掉，讚讚。當發現這一次的題目本都是 1/2 都是圖論題的時候心有涼了一半，不是說圖論題不好，而是我們的策略是以數學、圖論、字串這樣區分，如果這次都是以圖論為重心時則會發現那這次對其中一位隊友的負擔量特別高，如果他遇到難題或是掉進思考深淵時就非常容易讓整個隊伍進入停擺狀態。</p>
<p>比賽前期我們順利解完 3 題，雖然時間稍微輸別人一些但並不差，我先拿了一題 game 題來解，但是因為英文問題導致我在閱讀題目時有了些許浪費時間 Coding 錯方向，後來漢軒有幫我引導到對的方向真的要感謝他，嗚嗚。但其實只有小方向不對我很快就修正回來，但是遇到一個難題就是他還是 WA，我們百思不得其解為甚麼會 WA，到現在還是沒有想出來，只能趁比賽結束後去找答案了，過程中也有點對題目分配感到不公平，這一次圖論的比例非常高，讓我們隊伍原本是平均分配的重心失衡，但反過來也有可能是我們的策略有些許的問題還需要再修正，因為這樣就表示我們的 model 並沒有符合這次 ICPC 的題目本。</p>
<p>寫到後面時，學長也不斷的在 Coding Problem H 但那題一直不斷的 TLE，學長陷入的思考深淵想不出這題為甚麼會超時也不斷在賽程中優化但還是沒有成功 AC，到賽後結束時向其他隊伍詢問卻發現明明方法卻是相同的！但只有我們的 TLE，真的有點可惜，如果我的題目或是學長的題目有成功解出一題那我們一定會有銅獎的，但是這一出的 String 題過難也讓我相當難過，我沒辦法在自己的能力範圍內做出貢獻，而是當場直接測試自己的想法卻無法驗證。</p>
<p>這場比賽五小時過得飛快，腦力激盪相當過癮但也讓比賽結束後的我相當難過。</p>
<blockquote>
<p>比賽過程時，主辦單位拍下的照片</p>
</blockquote>
<p><img src="/images/ICPC2020/12.JPG" alt=""></p>
<h3 id="賽後結束-晚宴時間"><a href="#賽後結束-晚宴時間" class="headerlink" title="賽後結束 - 晚宴時間"></a>賽後結束 - 晚宴時間</h3><p>今年的晚宴相當不賴，雖然隊員們都提早離開，但我還是想留在台北商大沉思，一邊想著自己哪裡還有地方可以改進一邊吃著食物，雖然非常的不甘心，但是我知道比賽本來就是贏者全拿，我只要能夠當上贏者我也可以贏者全拿，一邊吃著食物邊默默想著未來要怎麼拿到銀獎。</p>
<blockquote>
<p>晚宴的甜點</p>
</blockquote>
<p><img src="/images/ICPC2020/5.jpg" alt=""></p>
<h2 id="比賽心得"><a href="#比賽心得" class="headerlink" title="比賽心得"></a>比賽心得</h2><p>老實說，我很難過，真的非常非常難過，難過到話都說不出來。</p>
<p>不是氣隊友，是氣自己沒有用處，這一次的題目中 String 只有一題且那題並沒有人解開，使我無用武之地，只能想 Game 題，讓我今天真的很難過，沒有派上用場，也讓我大嘆不公平，我明明是一個想要變得優秀的人卻礙於學校限制而沒辦法變的優秀，今天領悟最深的是，<strong>不是我不努力，是我連努力的資格都沒有</strong>，你說你想要考好 ICPC，那你要怎麼考好？我不知道，台北科大知道嗎？他不知道，我們有資源可以扭轉困境嗎，我感覺不到，已經努力了一年去改變這個困境但這過程很痛苦，至現在又還沒找到方法，你覺得是我們爛嗎？或許是吧，我們不是優秀的人物，可以去更那些已經有學長傳承下來的人競爭、抗戰。</p>
<p>當然，我不否認，你可以說在網路上真的可以找到很多資料自學，那換我問你？</p>
<ul>
<li>你知道怎麼抓資料嗎？</li>
<li>你有辦法在你對這個演算法都不了解時可以找到一篇沒有錯誤完全正確的資訊網頁嗎？</li>
<li>你能夠只看資訊網頁就能理解那些演算法的奧妙嗎？</li>
<li>資訊網頁所述說的邏輯你都能夠看懂嗎？</li>
<li>資訊網頁的程式碼你不需要解釋就能夠完全理解嗎？</li>
<li>你能透過上網查到上面這些問題，而不透過別人的教導嗎？</li>
</ul>
<p>就算你完成了以上所有問題，你也已經輸了那些有學長有老師的學生們，他們資質比你強、又有學長、老師指導幫你快速解決你的思考盲點，當你學完時發現別人已經學完兩個演算法時，你不會氣餒、你不會難過嗎？</p>
<p>不是台北科大不好，只是我怨恨我自己在我不懂事的年代沒有多懂事一點，如果真的有讀者願意讀到這裡，我用我那潰不成氣的聲音說，<strong>這過程有多少的痛苦，是永遠沒辦法用比賽成績去衡量的</strong>，比賽永遠不是比你的努力，比賽就像出生一樣，是有貧富差距的，<strong>你是窮人你只能夠比別人懂事，才能贏過那些比你好的人</strong>，憑甚麼沒資源的人一定要用痛苦才能換來有錢人習以為常的事物，我也是人，我也想要資源、我也想要尊嚴。</p>
<p>管理、NoteBook、練習等，全部都需要一個隊伍包辦，我們都靠著 3 人隊伍硬撐著，沒有人看到我們的辛勞，我們也看不到別人的辛勞，不覺得這很不公平嗎？明明都有最佳女隊伍獎，就不能對於這些沒有資源的隊伍作出一些讚美嗎？我們是不是沒有出名、沒有成就就永遠沒有人看見我們？</p>
<p>說太多了，但我真的好難過，我好想哭，我不怨恨別人比我強，我只是對我自己的弱小感到難過，憑甚麼我是一個這麼沒有能力的人，沒有辦法與他人競爭，只能打這 BLOG 難過，而不是找到強者與強者一同讀書、成功。</p>
<p>也許是資源不均，讓我的學習之路已經成為偏差了吧？現在的我真的不知道我還有沒有辦法聽著講師上課來讓我快速學習知識？如果有，我一定要好好把握，<strong>他人習以為常的事物，在我眼中卻像黃金一樣珍貴</strong>。</p>
<p>很感謝隊伍願意陪我一起練習，包容著這麼沒用的我，即使比賽結束也沒有對隊員做出負面行為，也都將情緒留在自身消化，特別是學長，這一路以來應該最辛苦的就是他了吧，他也都不曾抱怨，願意付出一切，沒有他真的沒辦法，補足了我的缺陷，教導了我許多應該要在未來才能學到的觀念，他提前教倒了我，這一路以來真的很謝謝他，如果可以，我也想為他做些甚麼。</p>
<p>總而言之，這是一篇負面文，我很抱歉讓大家接受我現在的負面情緒，但是我也不知道我該怎麼辦…，像個走失的小男孩因為找不到媽媽而不安心的四處盼望媽媽身影卻還是不到，那著急著、眼框放紅，強忍著哭意的男孩。</p>
<p><strong>明天要保持笑容，面對每個挑戰，因為不優秀的人是沒有資格哭泣的。</strong></p>
<p>今天最有感觸的話了吧，從自己內心中那最真實的聲音。</p>
<blockquote>
<p>激勵自己的話 - 成功不是憑夢想和希望而是憑努力和實踐</p>
</blockquote>
<p><img src="/images/ICPC2020/6.jpg" alt=""></p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://drive.google.com/drive/folders/1fJutJ9MN6THv0MeKBPWvk8Jy2TJsWzSF" target="_blank" rel="noopener">ICPC2020 照片</a></p>
]]></content>
      <categories>
        <category>競賽心得</category>
      </categories>
      <tags>
        <tag>大學Life</tag>
        <tag>ICPC</tag>
        <tag>程式比賽</tag>
        <tag>競賽心得</tag>
        <tag>人生旅途</tag>
      </tags>
  </entry>
  <entry>
    <title>演算法知識 - Longest Increasing Subsequence 最長遞增子序列(時間複雜度 O(nlogn) 與 時間複雜度 O(n^2))</title>
    <url>/2020/11/13/Explain_Algorithm/LIS/</url>
    <content><![CDATA[<h2 id="Longest-Increasing-Subsequence-介紹"><a href="#Longest-Increasing-Subsequence-介紹" class="headerlink" title="Longest Increasing Subsequence 介紹"></a>Longest Increasing Subsequence 介紹</h2><blockquote>
<p>以下簡稱 LIS，在一個陣列中找出最長遞增的序列，序列是甚麼？舉例：</p>
<ul>
<li>1 3 4 2 5<br>則此 LIS 的長度為 3，符合最長長度的有三種：</li>
</ul>
<ul>
<li>1,3,4</li>
<li>1,2,5</li>
<li>1,4,5</li>
</ul>
<p>只要相對位置有達到遞增，且數值也有遞增則符合<strong>遞增序列</strong>的意思。</p>
<p>在一些數學研究會涉及此演算法，且此演算法有兩種不一樣的時間複雜度，一種為 \(O(N^2)\) 另一種則為 \(O(n /log n)\)</p>
<p><strong>這裡我們則是介紹比較快的方法，\(O(n \log n) \)</strong></p>
</blockquote>
<a id="more"></a>

<h2 id="Longest-Increasing-Subsequence-原理"><a href="#Longest-Increasing-Subsequence-原理" class="headerlink" title="Longest Increasing Subsequence 原理"></a>Longest Increasing Subsequence 原理</h2><p>二分搜尋 + 陣列 = LIS，這是最好的解釋了XD。</p>
<p>產生兩個陣列 t , d ， t 用來記錄當前最長序列，d 則用來記錄當前 LIS 有包括此數值的前一個數值位置。</p>
<p>針對不同的題型，必須使用不同的 LIS</p>
<ul>
<li>時間複雜度 \(O(n log n\)，當每個數值權重<strong>相等</strong>時使用</li>
<li>時間複雜度 \(O(n log n\)，當每個數值權重<strong>不一定相等或相等</strong>都可以使用，但效率不好</li>
</ul>
<h3 id="QUESTION-你在解釋甚麼，太爛了吧XD。"><a href="#QUESTION-你在解釋甚麼，太爛了吧XD。" class="headerlink" title="QUESTION: 你在解釋甚麼，太爛了吧XD。"></a>QUESTION: 你在解釋甚麼，太爛了吧XD。</h3><p><del>我也覺得</del>，所以我們用舉例的。</p>
<p>假設我們要在 10 30 20 40 50 找出 LIS，那透過我們的原理要怎麼做呢？</p>
<h4 id="Step1-初始化-t-d-並-i-1-放入-10"><a href="#Step1-初始化-t-d-並-i-1-放入-10" class="headerlink" title="Step1: 初始化 t , d 並 i = 1 , 放入 10"></a>Step1: 初始化 t , d 並 i = 1 , 放入 10</h4><p>由於 t 是紀錄最長陣列，且我們一定能夠保證 LIS 最長長度一定有 1，則是因為隨機在數列中拿出一個元素都可以是 LIS 長度為 1 而得證。</p>
<p>所以我們就在 t[1] 直接放入<strong>第一個數值的 index</strong>，<strong>這裡很重要，t and d 都是紀錄數值的 index</strong>。</p>
<p>由於 d[1] 是數列中的第一個 LIS 長度一定只有 1，所以設定成 0，表示他沒有前一個數值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">t[<span class="number">1</span>] = <span class="number">1</span> ; </span><br><span class="line">d[<span class="number">1</span>] = <span class="number">0</span> ;</span><br></pre></td></tr></table></figure>

<h3 id="Step-2-i-2-放入-30"><a href="#Step-2-i-2-放入-30" class="headerlink" title="Step 2 : i = 2 , 放入 30"></a>Step 2 : i = 2 , 放入 30</h3><p>因為 30 有比 10 大，因此只需要在 LIS 增加長度即可，因此 LIS 的第二個長度放入數值的 index。</p>
<p>d[2] 則記錄當前最長的 LIS 此數值的前一個值，表示 d[2] 如果要往前回朔就是找此值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">t[<span class="number">2</span>] = <span class="number">2</span> ; </span><br><span class="line">d[<span class="number">2</span>] = t[<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h3 id="Step-3-i-3-放入-20"><a href="#Step-3-i-3-放入-20" class="headerlink" title="Step 3 : i = 3 , 放入 20"></a>Step 3 : i = 3 , 放入 20</h3><p>由於 20 沒有比 30 大，於是我們必須要使用<strong>二分搜尋</strong>法，找出 2 在 t 這個陣列中適合放入哪個位置，由於二分搜尋的時間複雜度是 \(O(\log n)\)，因此再根據此陣列的長度 \(* n \)，就會符合此演算法的時間複雜度 \(O(n \log \ n)\)。</p>
<p>我們找到 t[2] = 3，所以我們把 t[2] 的值改成 2，為甚麼要這樣做呢？很簡單，因為如果 t[] 的數值越小代表之後可以放進去的數值會<strong>有可能</strong>比現在的數值還更多機會擴增 LIS，假如下一個是 25，那如果這邊沒有先將數值改成 20，25 就沒辦法擴增 LIS 了，因此才要做改值。</p>
<p>這裡為甚麼 <code>d[3] = t[1]</code> 呢？因為我們將 t[2] 放入當前的值，因此在現在的 t[1] 則是我們現在 d[3] 要記錄的前一個 LIS 數值，之後從 d[3] 不斷回推時可以發現只要回推 2 次就會回到 d[0]。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">t[<span class="number">2</span>] = <span class="number">3</span> ;</span><br><span class="line">d[<span class="number">3</span>] = t[<span class="number">1</span>] ;</span><br></pre></td></tr></table></figure>

<h3 id="Step-4-i-4-放入-40"><a href="#Step-4-i-4-放入-40" class="headerlink" title="Step 4: i = 4 , 放入 40"></a>Step 4: i = 4 , 放入 40</h3><p>因為 40 有比 20 大，因此只需要在 LIS 增加長度即可，因此 LIS 的第三個長度放入數值的 index。</p>
<p>d[4] 則記錄當前最長的 LIS 此數值的前一個值，表示 d[4] 如果要往前回朔就是找此值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">t[<span class="number">3</span>] = <span class="number">4</span> ; </span><br><span class="line">d[<span class="number">4</span>] = t[<span class="number">2</span>] ;</span><br></pre></td></tr></table></figure>

<h3 id="Step-5-i-5-放入-50"><a href="#Step-5-i-5-放入-50" class="headerlink" title="Step 5: i = 5 , 放入 50"></a>Step 5: i = 5 , 放入 50</h3><p>道理與 Step4 相同<br>因為 50 有比 40 大，因此只需要在 LIS 增加長度即可，因此 LIS 的第四個長度放入數值的 index。</p>
<p>d[5] 則記錄當前最長的 LIS 此數值的前一個值，表示 d[5] 如果要往前回朔就是找此值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">t[<span class="number">4</span>] = <span class="number">5</span> ;</span><br><span class="line">d[<span class="number">5</span>] = t[<span class="number">3</span>] ;</span><br></pre></td></tr></table></figure>

<h3 id="Step-6-完成了！此時我們簡單檢查一下，t-陣列裡的數值是不是最長-LIS"><a href="#Step-6-完成了！此時我們簡單檢查一下，t-陣列裡的數值是不是最長-LIS" class="headerlink" title="Step 6: 完成了！此時我們簡單檢查一下，t 陣列裡的數值是不是最長 LIS"></a>Step 6: 完成了！此時我們簡單檢查一下，t 陣列裡的數值是不是最長 LIS</h3><table>
<thead>
<tr>
<th>array</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody><tr>
<td>t</td>
<td>0</td>
<td>1</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>-</td>
</tr>
<tr>
<td>value</td>
<td>0</td>
<td>10</td>
<td>20</td>
<td>40</td>
<td>50</td>
<td>-</td>
</tr>
</tbody></table>
<p>OK，沒錯，LIS 正確無誤。</p>
<h3 id="OK-現在問題被我們解決成是-Binary-Search-了，那我們就來做吧！"><a href="#OK-現在問題被我們解決成是-Binary-Search-了，那我們就來做吧！" class="headerlink" title="OK, 現在問題被我們解決成是 Binary Search 了，那我們就來做吧！"></a>OK, 現在問題被我們解決成是 Binary Search 了，那我們就來做吧！</h3><p>關於 <a href="https://theriseofdavid.github.io/2020/11/15/Explain_Algorithm/binary_search/" target="_blank" rel="noopener">Binary Search 的部分就先去看大衞的筆記</a>即可。</p>
<h2 id="LIS-實作與說明，時間複雜度-O-n-log-n"><a href="#LIS-實作與說明，時間複雜度-O-n-log-n" class="headerlink" title="LIS 實作與說明，時間複雜度 \(O(n log n)\)"></a>LIS 實作與說明，時間複雜度 \(O(n log n)\)</h2><h3 id="版本一-學習版"><a href="#版本一-學習版" class="headerlink" title="版本一 學習版"></a>版本一 學習版</h3><p>在程式碼進行說明，相信會比較好理解些。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N </span></span><br><span class="line"><span class="keyword">int</span> b[N] , t[N] , d[N] , n ; </span><br><span class="line"><span class="comment">// b 是原本的數列</span></span><br><span class="line"><span class="comment">// t 則是當前 LIS 的數列</span></span><br><span class="line"><span class="comment">// d 則是在 LIS 中此數值的前一個數值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bs</span><span class="params">(<span class="keyword">int</span> l , <span class="keyword">int</span> r , <span class="keyword">int</span> v)</span></span>&#123; <span class="comment">//二分搜尋法</span></span><br><span class="line">    <span class="keyword">int</span> m ;</span><br><span class="line">    <span class="keyword">while</span>(r&gt;l)&#123;</span><br><span class="line">        m = (r+l) / <span class="number">2</span> ;</span><br><span class="line">        <span class="keyword">if</span>(b[v] &gt; b[t[m]] ) l = m+<span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">else</span> r = m ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lis</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">1</span> , cur ; <span class="comment">//LIS 最小長度為 1，因此 len = 1</span></span><br><span class="line">    <span class="comment">//cur 則是二分搜尋中找到的位置</span></span><br><span class="line">    d[<span class="number">1</span>] = <span class="number">0</span> , t[<span class="number">1</span>] = <span class="number">1</span> ; <span class="comment">//初始化 LIS 需要用到的兩個陣列</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= n ; i++)&#123; <span class="comment">//</span></span><br><span class="line">        <span class="keyword">if</span>(b[i] &gt; b[t[len]] )&#123; <span class="comment">//如果此數值比 LIS 中最長的數值還大時就直接增長</span></span><br><span class="line">            d[i] = t[len] ; <span class="comment">//d[i] 就則是在 LIS 中此數值的前一個數值</span></span><br><span class="line">            t[++len] = i ; <span class="comment">//增長 t 的長度</span></span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span>&#123; <span class="comment">// 表示目前的數值可以替換此 LIS 中某個數值</span></span><br><span class="line">            cur = bs(<span class="number">1</span>,len,i);  <span class="comment">// 二分搜尋找出此位置</span></span><br><span class="line">            t[cur] = i ; <span class="comment">//將原本 LIS 的 cur 值替換成 i </span></span><br><span class="line">            d[i] = t[cur<span class="number">-1</span>] ; <span class="comment">// 由於我們將 i 放入 t[cur]，所以我們的 d 就是找 t[cur-1]</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len ; <span class="comment">//回傳最長 LIS</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="版本二-實踐版"><a href="#版本二-實踐版" class="headerlink" title="版本二 實踐版"></a>版本二 實踐版</h3><p>此版比較好實踐，但並沒有辦法了解深刻意思，建議大家先學習舊版的再看新版的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 5020</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[MAXN];</span><br><span class="line"><span class="keyword">int</span> T, n, len = <span class="number">0</span>, cur;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lis</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; b; <span class="comment">//用來產生 LIS 長度</span></span><br><span class="line">    b.push_back(a[<span class="number">0</span>]); <span class="comment">//先放入一個數值，以避免 b.back() 找不到值</span></span><br><span class="line">    <span class="keyword">int</span> temp; <span class="comment">//紀錄二分搜尋後找到的位置</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] &gt; b.back())&#123; <span class="comment">//如果現在這個數字大於此數列中最大的數字</span></span><br><span class="line">            b.push_back(a[i]); <span class="comment">//LIS push back</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            temp = upper_bound(b.begin(), b.end(), a[i]) - b.begin(); </span><br><span class="line">            <span class="comment">//二分搜尋，找到他適合的位置，前面數字比她小或相等，後面數字大</span></span><br><span class="line">            b.insert(b.begin()+temp , a[i]); <span class="comment">//插入數值在此位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b.size(); <span class="comment">//輸出最長 LIS 長度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="LCS-無註解程式碼"><a href="#LCS-無註解程式碼" class="headerlink" title="LCS 無註解程式碼"></a>LCS 無註解程式碼</h3><p>這裡則放置沒有註解的程式碼，如果讀者想要複製就從這裡進行複製吧！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N </span></span><br><span class="line"><span class="keyword">int</span> b[N] , t[N] , d[N] , n ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bs</span><span class="params">(<span class="keyword">int</span> l , <span class="keyword">int</span> r , <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m ;</span><br><span class="line">    <span class="keyword">while</span>(r&gt;l)&#123;</span><br><span class="line">        m = (r+l) / <span class="number">2</span> ;</span><br><span class="line">        <span class="keyword">if</span>(b[v] &gt; b[t[m]] ) l = m+<span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">else</span> r = m ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lis</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">1</span> , cur ;</span><br><span class="line">    d[<span class="number">1</span>] = <span class="number">0</span> , t[<span class="number">1</span>] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= n ; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b[i] &gt; b[t[len]] )&#123;</span><br><span class="line">            d[i] = t[len] ;</span><br><span class="line">            t[++len] = i ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cur = bs(<span class="number">1</span>,len,i);</span><br><span class="line">            t[cur] = i ;</span><br><span class="line">            d[i] = t[cur<span class="number">-1</span>] ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LIS-實作與說明，時間複雜度-O-n-2"><a href="#LIS-實作與說明，時間複雜度-O-n-2" class="headerlink" title="LIS 實作與說明，時間複雜度 \(O(n^2)\)"></a>LIS 實作與說明，時間複雜度 \(O(n^2)\)</h2><ul>
<li>基本上概念類似於選擇排序</li>
<li>我們是判斷以 i 為中心時，符合 \(num[i] &gt; num[j]\)，並找出前面最大的 LIS，找到後 \(num[i] = num[j] + \text{index i 的權重}\)</li>
</ul>
<h3 id="程式碼說明"><a href="#程式碼說明" class="headerlink" title="程式碼說明"></a>程式碼說明</h3><p>透過程式碼來進行說明，會很好理解。<br>我們將每一個數列數值 \(num[i]\) 的權重都使用 i 來表示</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1000020</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, kase = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> lis[MAXN], num[MAX];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        lis[i] = i; <span class="comment">//每一個 LIS 都一定有自己，因此先設定 lis[i] = i;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123; <span class="comment">//以 i 為中心，往前找哪個 lis[j] 最大</span></span><br><span class="line">            <span class="comment">//如果 num[j] &lt; num[i] 符合 LIS 特性，那就看當前的 lis[i] 與 lis[j] + 權重，</span></span><br><span class="line">            <span class="comment">//誰比較大</span></span><br><span class="line">            <span class="keyword">if</span>(num[i] &gt; num[j]) lis[i] = max(lis[i], lis[j] + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="LIS-應用"><a href="#LIS-應用" class="headerlink" title="LIS 應用"></a>LIS 應用</h2><p>我在學習此演算法的過程中如果有題目讓我應用到此演算法我則收錄在此，連結則是我的詳解如果想要去看題目的就搜尋一下吧！</p>
<ul>
<li><a href="https://theriseofdavid.github.io/2020/11/14/UVa/UVa111/" target="_blank" rel="noopener">UVa 111 - History Grading (LIS)</a></li>
</ul>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://www.youtube.com/watch?v=S9oUiVYEq7E&t=0s" target="_blank" rel="noopener">Longest Increasing Subsequence in nlogn time - Tushar Roy - Coding Made Simple </a><br><a href="https://forgoal.gitbooks.io/-/content/longest_increasing_subsequence.html" target="_blank" rel="noopener">Longest Increasing Subsequence (LIS)</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>複習一些之前所學習的演算法並加入我的 blog 中感覺其實還真不賴呢！感覺以後如果有些忘記就可以直接拿過來用了XD，而且又是變相地複習我的演算法知識，只是在打演算法解釋有點麻煩QQ，語言障礙不太行阿，希望之後可以把自己的文字表達能力練強，才不會讓別人都聽不懂我在說甚麼…。</p>
<p>總感覺自學就像盲人摸象一般，有時候別人跟你說專業的你反而聽不懂呢。因為你學習並不是一個完整的系統導致有些部分會 miss，但教授都會假設你是完整的學過，所以要盡量補起來這些坑呢！</p>
]]></content>
      <categories>
        <category>演算法知識</category>
      </categories>
      <tags>
        <tag>程式解題</tag>
        <tag>演算法知識</tag>
        <tag>最長遞增子序列 Longest Increasing Subsequence</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa 111 - History Grading (LIS)</title>
    <url>/2020/11/14/UVa/UVa111/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>老師要改考卷關於歷史的事件排序，我們要寫程式幫老師解決其中一道題目，簡單來說，歷史有很多事件，只要學生們排序歷史事件順序有對，就給予相對應的分數，我們將歷史事件定義成數字，順序則就是數學的遞增。</p>
<p>1,2,3,4 得四分 因為遞增的數列最長可以來到 4<br>2,1,3,4 得三分，因為 1,3,4 or 2,3,4 這樣的順序都有正確，但順序長度只有 3，所以就輸出 3 分<br>4,3,2,1 得一分，有這四種 1 or 2 or 3 or 4，而他們遞增長度最高都只能來到 1，因此只有一分。</p>
<p>我們就是要找出，最長的數值遞增長度。</p>
<p>這題的格式： 1 3 2 4 ，其中 1 是表示歷史事件 1 是在第 1 個位置、 3 則是表示歷史事件 <strong>2</strong> 是在第三個位置，全部的數值都是用此表達方式表達。</p>
</blockquote>
<a id="more"></a>

<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>看得出來嗎XD，這題其實就是詢問你最長的 LIS 長度。</p>
<p>這題就是標準的最長遞增子序列 Longest Increasing Subsequence (以下簡稱 LIS) 問題，這裡使用 \(O(n \log n)\) 來解決此問題。</p>
<p>如果還不太懂 LIS 是甚麼問題，建議看看 <a href="https://theriseofdavid.github.io/2020/11/13/Explain_Algorithm/LIS/" target="_blank" rel="noopener">演算法知識 - Longest Increasing Subsequence 最長遞增子序列(時間複雜度 O(nlogn))</a>，這裡有對於此演算法有完整的介紹 </p>
<h2 id="焦點回到題目上，解開題目的小設計"><a href="#焦點回到題目上，解開題目的小設計" class="headerlink" title="焦點回到題目上，解開題目的小設計"></a>焦點回到題目上，解開題目的小設計</h2><p>這題有個巨大的坑，他並不是一開始就排好順序的，他有一個特殊格式，還有在題目卷下寫一個 <strong>warning</strong>，要你好好看懂。<del>那時候我還以為我自己有看懂了，英文差的人就是這麼爛嘛 ಥ⌣ಥ</del></p>
<p>重點是我還花了兩小時！完全沒有找出錯誤…，看別人的解答才知道…，我好爛QQ。</p>
<p>於是我們要怎麼解決這個問題呢，index 上的值是 rank(他們的順序)，其實這裡有點腦筋急轉彎，我還以為出題者可能就是要考這個呢XD。</p>
<p>先直接將老師的答案直接存到陣列中，我們舉例一下：</p>
<p>正確解答： 3 2 1 4 ，我們定義正確解答為 a[]<br>你的答案： 2 1 3 4 ，我們定義你的答案為 b[]</p>
<p>於是我們先這樣做</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">a[<span class="number">1</span>] = <span class="number">3</span> <span class="comment">//因為 1 應該要排在第 3 個位置，我們先透過 a 進行記錄</span></span><br><span class="line">a[<span class="number">2</span>] = <span class="number">2</span></span><br><span class="line">a[<span class="number">3</span>] = <span class="number">1</span></span><br><span class="line">a[<span class="number">4</span>] = <span class="number">4</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">// 透過此方式可以直接產生符合題目要求且方便 LIS 撰寫的陣列</span></span><br><span class="line">b[<span class="number">2</span>] = a[<span class="number">1</span>] = <span class="number">3</span>  <span class="comment">// 由於你的答案歷史事件 1 的 rank 是 2，表示他應該是要在生成數列中的第二個位置，因此設定成 b[2]</span></span><br><span class="line"><span class="comment">// a[1] 則是 1 事件的 rank 位置，也就是他其實是第 3 個發生的事情，所以 b[2] = 3</span></span><br><span class="line">b[<span class="number">1</span>] = a[<span class="number">2</span>] = <span class="number">2</span> </span><br><span class="line">b[<span class="number">3</span>] = a[<span class="number">3</span>] = <span class="number">1</span></span><br><span class="line">b[<span class="number">4</span>] = a[<span class="number">4</span>] = <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>透過此方式可以得知，b[] 按照 index 順序並從 1 開始應該是這樣的 2 3 1 4，肉眼不難找出最長的 LIS 有 3，且為 2 1 4，我們再來驗證看是否正確，對的，沒錯正確解答與你的解答確實 2 1 4 有符合順序，因此得證。</p>
<p>OK，解開題目得小設計後，其他就與 LIS 沒有不同拉XD，記住要用迴圈寫就好，不可以手寫喔，會累死你的。</p>
<h2 id="參考連結："><a href="#參考連結：" class="headerlink" title="參考連結："></a>參考連結：</h2><p><a href="https://www.itdaan.com/tw/ff7a789caa729620e32dffbb7eed755c" target="_blank" rel="noopener">UVa 111 History Grading （簡單DP，LIS或LCS）</a></p>
<h2 id="心得："><a href="#心得：" class="headerlink" title="心得："></a>心得：</h2><p>老話一句，英文很重要QQ，我到底因為英文不好吃了幾次虧啦…，好討厭。這麼簡單的一個題目我也可以拖 3 個小時都沒辦法解開而且還是錯在這種腦筋急轉彎的部分，是欺負我英文不好跟嫌我腦袋太笨嘛ಥ⌣ಥ，不行，我要讀好英文、增加自己的思維，成為一個優秀的人不會被再被這種問題給打倒，如果我沒辦法當一位聰明的人，至少我要當一個很有經驗的人！</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>其實就是沒有附上說明的程式碼，看得懂跟說得出來真的是兩回事，也許還有人覺得我說的很差，不過我已經盡力解釋。希望可以幫助到各位。</p>
<p>也希望大家想要學習的知識都可以快速學習而成，不要因為自身的環境不足而學習不到。</p>
<p>於是這裡就補述一些題目給的資料範圍限制與標頭檔了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 25</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[N] , b[N] , t[N] , d[N] , n ;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; dict ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bs</span><span class="params">(<span class="keyword">int</span> l , <span class="keyword">int</span> r , <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m ;</span><br><span class="line">    <span class="keyword">while</span>(r&gt;l)&#123;</span><br><span class="line">        m = (r+l) / <span class="number">2</span> ;</span><br><span class="line">        <span class="keyword">if</span>(b[v] &gt; b[t[m]] ) l = m+<span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">else</span> r = m ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lis</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">1</span> , cur ;</span><br><span class="line">    d[<span class="number">1</span>] = <span class="number">0</span> , t[<span class="number">1</span>] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= n ; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b[i] &gt; b[t[len]] )&#123;</span><br><span class="line">            d[i] = t[len] ;</span><br><span class="line">            t[++len] = i ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cur = bs(<span class="number">1</span>,len,i);</span><br><span class="line">            t[cur] = i ;</span><br><span class="line">            d[i] = t[cur<span class="number">-1</span>] ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="comment">//freopen("out.txt" , "w" , stdout);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">    <span class="keyword">int</span> j , temp ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; temp ;</span><br><span class="line">        a[i] = temp ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; j )&#123;</span><br><span class="line">        b[j] = a[<span class="number">1</span>]  ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= n ; i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; temp ;</span><br><span class="line">            b[temp] = a[i] ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//debug</span></span><br><span class="line">        <span class="comment">//for(int i = 1 ; i &lt;= n ; i++) cout &lt;&lt; b[i] &lt;&lt; ' ' ;</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; lis() &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>演算法知識</category>
      </categories>
      <tags>
        <tag>程式解題</tag>
        <tag>演算法知識</tag>
        <tag>最長遞增子序列 Longest Increasing Subsequence</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa245 - Uncompress (String Process)</title>
    <url>/2020/09/25/UVa/UVa245/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>給你一個經過壓縮的文本，文本中的數字則是代表是前面第幾個單字並輸出，但如果前面那些單字有重複到則只算一次並且是由後往前看的第一次遇到為準，請解壓縮此文本。</p>
<p>註:單字中間只要遇到非英文字母就全部都視為不一樣的單字。</p>
</blockquote>
<a id="more"></a>

<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>這題要用 Linked-List 由於每個單字的上一個單字與下一個單字都會隨著壓縮而變不同，剛好符合 Linked-List 的特色。再加上一些優秀的讀取字串技術，就可以輕鬆解決掉這題了XD。</p>
<p>如果不懂的話，下方程式碼有做解說。相信你會很快理解 Linked-List 的，我很努力想讓讀者都能懂啦。但是我個人不太喜歡在解題時使用指標，所以下面並不是指標實作。<del>對不起我就爛，debug 指標的技術很爛</del></p>
<h2 id="參考連結："><a href="#參考連結：" class="headerlink" title="參考連結："></a>參考連結：</h2><p><a href="https://www.codeleading.com/article/5927815599/" target="_blank" rel="noopener">UVA245 WF5184 POJ1885 Uncompress【文本】</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>這題應該看的出來他是用 Linked-List 拉XD，我一開始是想要用 vector 但是我卻卡關QQ，可惡腦袋不給力呀！之後就用 Linked-List 解決掉這題，不過太久沒有寫字串題目，讀取字串的能力特別差啊讀取字串的能力特別差啊，腦袋整個完全沒想法。後來看到參考連結中的那篇優秀程式碼文章，才讓我對於讀取字串又有了更新的領悟，好讚。非常感謝作者願意將他的程式碼技術公布出來！</p>
<p>也希望我自己也能成為獨當一面的演算法程式設計師，不要甚麼都不太會，未來只能領低薪，我要努力，直到看到夢想為止之前！也希望大家可以幫助我。</p>
<p>不過指標的 Linked-List 我還是覺得寫起來很麻煩阿，常常 Debug 都找不出錯誤，好討厭。我可能之後會變成愛用 C++，但不喜歡指標的怪人吧www。<del>C++ 的優勢根本沒有發揮出來</del></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> ch ;</span><br><span class="line"><span class="built_in">string</span> strTemp = <span class="string">""</span> ;</span><br><span class="line"><span class="keyword">int</span> wcnt = <span class="number">0</span> , head = <span class="number">0</span> , num =<span class="number">0</span>   ;</span><br><span class="line"><span class="comment">//wcnt linklist 的總量</span></span><br><span class="line"><span class="comment">//head 上一個單字的 index</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu_words</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> next ;</span><br><span class="line">    <span class="built_in">string</span> word ;</span><br><span class="line">&#125;word[MAXN] ;</span><br><span class="line"><span class="comment">// next 上一個單字的 index</span></span><br><span class="line"><span class="comment">// word 此單字</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> );</span><br><span class="line">    <span class="comment">//freopen("out.txt" , "w" , stdout );</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        ch = getchar() ;</span><br><span class="line">        <span class="keyword">if</span>(ch == <span class="string">'0'</span>)</span><br><span class="line">            <span class="keyword">break</span> ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">isalpha</span>(ch))&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">isalpha</span>(ch))&#123; <span class="comment">//不斷讀取單字，直到遇到其他</span></span><br><span class="line">                strTemp += ch ;</span><br><span class="line">                ch = getchar() ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; strTemp ;</span><br><span class="line">            word[wcnt].word = strTemp ; <span class="comment">//添加新單字</span></span><br><span class="line">            word[wcnt].next = head ; <span class="comment">//上一個單字 index</span></span><br><span class="line">            head = wcnt++ ; <span class="comment">//長度增加</span></span><br><span class="line">            strTemp = <span class="string">""</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">isdigit</span>(ch))&#123; </span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch))&#123; <span class="comment">//不斷讀取數字，直到遇到其他</span></span><br><span class="line">                num = num * <span class="number">10</span> + (ch - <span class="string">'0'</span>) ;</span><br><span class="line">                ch = getchar() ;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> cur = head , prev  ; </span><br><span class="line">            <span class="comment">//cur = 數字的那個單字</span></span><br><span class="line">            <span class="comment">//prev = 數字的下一個單字</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; num ; i++)&#123; <span class="comment">// 向上追蹤單字</span></span><br><span class="line">                prev = cur ;</span><br><span class="line">                cur = word[cur].next ;</span><br><span class="line">            &#125;</span><br><span class="line">            num = <span class="number">0</span> ;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; word[cur].word ;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(head != cur )&#123; <span class="comment">// 要將當前的單字搬到後面，所以單字的上一個 index 也需要更新</span></span><br><span class="line">                word[prev].next = word[cur].next ; </span><br><span class="line">                <span class="comment">// 因為要移動當前單字所以必須要將當前單字的下一個單字的 next，往前到現在這單字的 next</span></span><br><span class="line">                word[cur].next = head ;</span><br><span class="line">                <span class="comment">// 當前的單字 next 改為現在讀取中的上一個單字</span></span><br><span class="line">                head = cur ; <span class="comment">// 現在這個單字變成結尾</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">putchar</span>(ch) ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>String Processing Problems</tag>
        <tag>Competitive Programming3</tag>
      </tags>
  </entry>
  <entry>
    <title>演算法知識 - Binary Search 二分搜尋</title>
    <url>/2020/11/15/Explain_Algorithm/binary_search/</url>
    <content><![CDATA[<h2 id="Binary-Search-介紹與應用"><a href="#Binary-Search-介紹與應用" class="headerlink" title="Binary Search 介紹與應用"></a>Binary Search 介紹與應用</h2><blockquote>
<p>Binary Search 是我們常見的搜尋方式，相對簡單但也非常使用的演算法，其使用方式需要先在一個經過排序的陣列中找出我們想找出的值。</p>
<p>時間複雜度是 \(O(\log n)\)</p>
<p>應用類型相當廣泛，在常見的資料型態中都可以見到</p>
</blockquote>
<a id="more"></a>

<h2 id="Binary-Search-原理"><a href="#Binary-Search-原理" class="headerlink" title="Binary Search 原理"></a>Binary Search 原理</h2><p>在一個有排序的陣列中，假設我們要找出的是 x，找出最中間的值，與 x 進行比較，如果比中間的值大，那我們只需要再從此陣列中區間範圍 [ Mid , Right ] 即可，為甚麼可以這樣子呢？</p>
<p>因為是經過排序的，所以表示我們只要再往右邊的那些數值再去查詢，同樣地，如果比中間的值小那我們就只需要在從 [ Left , Mid] 去找即可。</p>
<p>其中 \( mid = (Left + Right ) / 2 \)</p>
<p>舉例一下，我們要在數列中 10 20 30 40 50，找出 1，要怎麼做呢？<br>P.S. 這裡的 index 從 1 開始</p>
<h3 id="Step1-這時-Left-1-Right-5-，找出此數列的中間值-30，並跟-10-比較"><a href="#Step1-這時-Left-1-Right-5-，找出此數列的中間值-30，並跟-10-比較" class="headerlink" title="Step1 : 這時 Left = 1 , Right = 5 ，找出此數列的中間值 30，並跟 10 比較"></a>Step1 : 這時 Left = 1 , Right = 5 ，找出此數列的中間值 30，並跟 10 比較</h3><p>\( Mid = (Left + Right ) / 2 = 3 \)<br>由於 10 &lt; 30，所以我們接下來要搜尋的範圍就是 \( [left=1 , Right=3 ] \)</p>
<h3 id="Step2-這時-Left-1-Right-3-，找出此數列的中間值-20，並跟-10-比較"><a href="#Step2-這時-Left-1-Right-3-，找出此數列的中間值-20，並跟-10-比較" class="headerlink" title="Step2 : 這時 Left = 1 , Right = 3 ，找出此數列的中間值 20，並跟 10 比較"></a>Step2 : 這時 Left = 1 , Right = 3 ，找出此數列的中間值 20，並跟 10 比較</h3><p>\( Mid = (Left + Right ) / 2 = 2 \)<br>由於 10 &lt; 20，所以我們接下來要搜尋的範圍就是 \( [left=1 , Right=2 ] \)</p>
<h3 id="Step3-這時-Left-1-Right-2-，找出此數列的中間值-10，並跟-10-比較"><a href="#Step3-這時-Left-1-Right-2-，找出此數列的中間值-10，並跟-10-比較" class="headerlink" title="Step3 : 這時 Left = 1 , Right = 2 ，找出此數列的中間值 10，並跟 10 比較"></a>Step3 : 這時 Left = 1 , Right = 2 ，找出此數列的中間值 10，並跟 10 比較</h3><p>\( Mid = (Left + Right ) / 2 = 1 \)，這裡是採用 C++，C++ 在整數除法時會無條件捨去。<br>由於 10 == 10，我們就可以知道我們想找的值在此數列中的 1 號位置。</p>
<h3 id="Situation-在寫二分搜尋時一些小注意"><a href="#Situation-在寫二分搜尋時一些小注意" class="headerlink" title="Situation: 在寫二分搜尋時一些小注意"></a>Situation: 在寫二分搜尋時一些小注意</h3><p>值得提醒的是，二分搜尋法固然簡單，但常常會有一些小問題自己沒有注意到，因此如果是系統已經有內建好的函數盡量使用系統內建函數會相對輕鬆一些。<del>簡單來說就是套件保證沒有 bug，但我不敢保證自己沒有 bug</del></p>
<p>容易出現的問題：數列中有重複的值，我想要的是找出此數列中大於 or 小於此數字的值</p>
<h2 id="C-語法介紹"><a href="#C-語法介紹" class="headerlink" title="C++ 語法介紹"></a>C++ 語法介紹</h2><p>在 C++ 中已經有函數可以方便我們直接套用分別是：</p>
<ul>
<li><code>lower_bound</code> 找出此數列中第一個數值是大於等於想查詢的值</li>
<li><code>upper_bound</code> 找出此數列中最後一個數值是大於等於想查詢的值<br>詳細用法請看 <a href="http://www.cplusplus.com/reference/algorithm/lower_bound/" target="_blank" rel="noopener">C++ Refence</a> 或是 <a href="https://www.cnblogs.com/cobbliu/archive/2012/05/21/2512249.html" target="_blank" rel="noopener">STL源码学习—-lower_bound和upper_bound算法</a></li>
</ul>
<p>如果看不太懂文字說明，可以看看這張圖，我想就了解了：</p>
<p><img src="/images/Binary_Search/1.png" alt=""></p>
<h2 id="Binary-Search-實作與說明"><a href="#Binary-Search-實作與說明" class="headerlink" title="Binary Search 實作與說明"></a>Binary Search 實作與說明</h2><p>在程式碼進行說明，相信會比較好理解些。</p>
<h3 id="找出此數列中第一個數值是大於等於想查詢的值，類似於-C-的-lower-bound"><a href="#找出此數列中第一個數值是大於等於想查詢的值，類似於-C-的-lower-bound" class="headerlink" title="找出此數列中第一個數值是大於等於想查詢的值，類似於 C++ 的 lower_bound"></a>找出此數列中第一個數值是大於等於想查詢的值，類似於 C++ 的 <code>lower_bound</code></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N </span></span><br><span class="line"><span class="keyword">int</span> num[n] <span class="comment">//以排序過且要進行查詢的數列</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bs</span><span class="params">(<span class="keyword">int</span> l , <span class="keyword">int</span> r , <span class="keyword">int</span> v)</span></span>&#123; <span class="comment">//bs binary search , l =left , r= right , v = value</span></span><br><span class="line">    <span class="keyword">int</span> m ; <span class="comment">// m = mid </span></span><br><span class="line">    <span class="keyword">while</span>(r&gt;l)&#123; <span class="comment">// 假如 r &gt; 1 表示尚未二分搜尋完畢</span></span><br><span class="line">        m = (r+l) / <span class="number">2</span> ; <span class="comment">// m 找出中間值 </span></span><br><span class="line">        <span class="keyword">if</span>(num[v] &gt; num[t[m]] ) l = m+<span class="number">1</span> ; <span class="comment">//如果要查詢的值大於中間值，那範圍將被改成[M id , Right]</span></span><br><span class="line">        <span class="comment">//但因為 mid 已經有被查詢過因此 mid +1</span></span><br><span class="line">        <span class="keyword">else</span> r = m ;</span><br><span class="line">        <span class="comment">//如果沒有那範圍則被改成 [Left , Mid]，沒有做 mid -1 是因為有可能是要查詢的值與 mid 值相同</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r ; <span class="comment">//回傳被查詢到的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="找出此數列中最後一個數值是大於等於想查詢的值，類似於-C-的-upper-bound"><a href="#找出此數列中最後一個數值是大於等於想查詢的值，類似於-C-的-upper-bound" class="headerlink" title="找出此數列中最後一個數值是大於等於想查詢的值，類似於 C++ 的 upper_bound"></a>找出此數列中最後一個數值是大於等於想查詢的值，類似於 C++ 的 <code>upper_bound</code></h3><p>讀者在觀看此程式碼前，必須先將前一個程式碼熟悉。</p>
<p>稍微要記住的是，這裡的區間範圍是 \( [ left , Right) \)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N </span></span><br><span class="line"><span class="keyword">int</span> num[n] <span class="comment">//以排序過且要進行查詢的數列</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bs</span><span class="params">(<span class="keyword">int</span> l , <span class="keyword">int</span> r , <span class="keyword">int</span> v)</span></span>&#123; <span class="comment">//bs binary search , l =left , r= right , v = value</span></span><br><span class="line">    <span class="keyword">int</span> m ;  <span class="comment">// m = mid </span></span><br><span class="line">    <span class="keyword">while</span>(r &gt; l)&#123; <span class="comment">// 假如 r &gt; 1 表示尚未二分搜尋完畢</span></span><br><span class="line">        m = (l+r) / <span class="number">2</span> ; <span class="comment">// m 找出中間值 </span></span><br><span class="line">        <span class="keyword">if</span>(num[m] &lt;= v) l = ++m; <span class="comment">//與上份程式碼章節相同</span></span><br><span class="line">        <span class="comment">//值得注意的是，因為區間範圍是 [ Mid , Right )，我們要防範 Right = mid 時，</span></span><br><span class="line">        <span class="comment">//會造成錯亂，於是我們先幫 mid+1，之後再減回來</span></span><br><span class="line">        <span class="keyword">else</span> r = m; <span class="comment">//與上份程式碼章節相同 </span></span><br><span class="line">        <span class="comment">//值得注意的是，因為區間範圍是 [ Left , Mid )，但因為 C++ 在計算 mid 時小數會捨取，</span></span><br><span class="line">        <span class="comment">//因此如果我們只要讓 else 只處理 中間值 &gt; 查詢值，就不會造成錯亂</span></span><br><span class="line">        <span class="comment">//我們在下方將會進行舉例，代號為 Q-A</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m<span class="number">-1</span> ; <span class="comment">//為甚麼要 m-1？</span></span><br><span class="line">    <span class="comment">//因為</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Q-A"><a href="#Q-A" class="headerlink" title="Q-A"></a>Q-A</h4><p>舉例：<br>L = 1 , R = 2 , M = 1 ，進入 if statement ， L = 2 , M = 2，此時區間是向 R 靠近，但 R 是 <strong>)</strong> 會超出查詢範圍，因此必須要 -1。<br>L = 1 , R = 2 , M = 1 ，進入 else statement ， R = 1 , M = 1，此時區間是向 L 靠近，L 本身範圍是 <strong>[</strong>，因此沒有問題。</p>
<p>主要就是這個樣子，希望讀者都能看懂XD。</p>
<h3 id="未來如果我還有寫更多版本，我將會放上"><a href="#未來如果我還有寫更多版本，我將會放上" class="headerlink" title="未來如果我還有寫更多版本，我將會放上"></a>未來如果我還有寫更多版本，我將會放上</h3><h2 id="Binary-Search-應用"><a href="#Binary-Search-應用" class="headerlink" title="Binary Search 應用"></a>Binary Search 應用</h2><ul>
<li><a href="https://theriseofdavid.github.io/2020/11/15/UVa/UVa957/" target="_blank" rel="noopener">UVa957 - Popes (Binary Search)</a></li>
</ul>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://www.cnblogs.com/cobbliu/archive/2012/05/21/2512249.html" target="_blank" rel="noopener">STL源码学习—-lower_bound和upper_bound算法</a><br><a href="http://www.cplusplus.com/reference/algorithm/lower_bound/" target="_blank" rel="noopener">std::lower_bound</a><br><a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%88%86%E6%90%9C%E5%B0%8B%E6%BC%94%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">二分搜尋演算法</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>二分搜尋好多毛病要解決，真麻煩，好想用套件XD，其實此演算法在我高中時就已經學會了，為甚麼會想打這一篇呢？主要是因為想要幫自己的演算法建立模板，方便未來的我用上，也害怕假如未來的我以後忘記怎麼寫時就在也真的想不起來了，因為找不到<strong>過去</strong>讓我參考，希望未來的我還能記住，也希望看到此篇的讀者不會忘記。</p>
<p>寫 Blog 真的非常吃力不討好，真的好累又好麻煩，學習速度比別人慢，別人可以在你打 Blog 的時間學習更多演算法、更多知識，那你為甚麼還要打呢？因為我笨，我學習差，我需要讓瞭解演算法的自己來幫助未來可能會遺忘此演算法的自己，幫助他，讓我的未來不遺失我的過去。</p>
<h2 id="Binary-Search-無助解程式碼"><a href="#Binary-Search-無助解程式碼" class="headerlink" title="Binary Search 無助解程式碼"></a>Binary Search 無助解程式碼</h2><p>這裡則放置沒有註解的程式碼，如果讀者想要複製就從這裡進行複製吧！</p>
<h3 id="找出此數列中第一個數值是大於等於想查詢的值，類似於-C-的-lower-bound-1"><a href="#找出此數列中第一個數值是大於等於想查詢的值，類似於-C-的-lower-bound-1" class="headerlink" title="找出此數列中第一個數值是大於等於想查詢的值，類似於 C++ 的 lower_bound"></a>找出此數列中第一個數值是大於等於想查詢的值，類似於 C++ 的 <code>lower_bound</code></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N </span></span><br><span class="line"><span class="keyword">int</span> num[n] </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bs</span><span class="params">(<span class="keyword">int</span> l , <span class="keyword">int</span> r , <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m ;</span><br><span class="line">    <span class="keyword">while</span>(r&gt;l)&#123;</span><br><span class="line">        m = (r+l) / <span class="number">2</span> ;</span><br><span class="line">        <span class="keyword">if</span>(b[v] &gt; b[t[m]] ) l = m+<span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">else</span> r = m ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="找出此數列中最後一個數值是大於等於想查詢的值，類似於-C-的-upper-bound-1"><a href="#找出此數列中最後一個數值是大於等於想查詢的值，類似於-C-的-upper-bound-1" class="headerlink" title="找出此數列中最後一個數值是大於等於想查詢的值，類似於 C++ 的 upper_bound"></a>找出此數列中最後一個數值是大於等於想查詢的值，類似於 C++ 的 <code>upper_bound</code></h3><p>讀者在觀看此程式碼前，必須先將前一個程式碼熟悉。</p>
<p>稍微要記住的是，這裡的區間範圍是 \( [ left , Right) \)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N </span></span><br><span class="line"><span class="keyword">int</span> num[n] </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bs</span><span class="params">(<span class="keyword">int</span> l , <span class="keyword">int</span> r , <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m ;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">        <span class="comment">//debug</span></span><br><span class="line">        <span class="comment">//cout &lt;&lt; num[l] &lt;&lt; ' ' &lt;&lt; num[r] &lt;&lt; '\n' ;</span></span><br><span class="line">        m = (l+r) / <span class="number">2</span> ;</span><br><span class="line">        <span class="keyword">if</span>(num[m] &lt;= v) l = ++m;</span><br><span class="line">        <span class="keyword">else</span> r = m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m<span class="number">-1</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>演算法知識</category>
      </categories>
      <tags>
        <tag>程式解題</tag>
        <tag>演算法知識</tag>
        <tag>Binary Search 二分搜尋</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa957 - Popes (Binary Search)</title>
    <url>/2020/11/15/UVa/UVa957/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>我們有過去歷史教皇選舉的資料，現在我們需要知道在 x 年期間中的教皇選舉最多次，並告訴我們期間開始選舉的教皇與期間最後選舉教皇</p>
<p>我們會給定<strong>已經排序</strong>好的選舉日期，就請寫出程式找出答案吧！</p>
</blockquote>
<a id="more"></a>

<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>這題可以用兩種方式去解，一種是最長區間覆蓋長，屬於動態規劃，另一種是 Binary Search，這裡我們使用 Binary Search 去 AC 此題。</p>
<p>如果還不太懂 LIS 是甚麼問題，建議看看 <a href="https://theriseofdavid.github.io/2020/11/15/Explain_Algorithm/binary_search/" target="_blank" rel="noopener">演算法知識 - Binary Search 二分搜尋</a>，這裡有對於此演算法有完整的介紹 </p>
<h2 id="焦點回到題目上，解開題目的小設計"><a href="#焦點回到題目上，解開題目的小設計" class="headerlink" title="焦點回到題目上，解開題目的小設計"></a>焦點回到題目上，解開題目的小設計</h2><p>這題總共需要求出 3 個答案，第一是期間內的最多選舉次數，再來是期間內的第一次選舉與最後一次選舉。</p>
<p>我們透過題目的公式 \( N+Y-1 \)，其中 N 等於 \(一開始可查詢選舉年份 + Y 期間 - 1 = 符合題目條件的最終可查詢選舉年份 \)，我們只需要對每一個選舉年份 + Y - 1，就可以找出每個期間的選舉次數，並記錄最大的選舉次數與一開始可選舉日期以及 Binary Search 找到的最後大於等於最終可查詢的選舉年份即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">last = bs(i,p,num[i]+y<span class="number">-1</span>) ; <span class="comment">//bs binary Search，以下簡稱 bs</span></span><br><span class="line"><span class="comment">// num[i]+y-1 表示最終可查詢年份 , last = 透過 bs 找出在此數列中的大於等於最終可查詢年份之選舉年份位置</span></span><br><span class="line">first = i ; <span class="comment">// first = 一開始可查詢選舉年份在此數列中的位置</span></span><br><span class="line">large = last - first +<span class="number">1</span> ; <span class="comment">// large = 最終可查詢年份 - 最初可查詢年份 + 1，表示裡面有多少選舉</span></span><br></pre></td></tr></table></figure>

<p>透過迴圈針對每一次的選舉進行查詢，並記錄最大即可。</p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>老話一句，英文很重要QQ，我到底因為英文不好吃了幾次虧啦…。</p>
<p>我看了很久QQ，查了好多英文單字，我竟然連 Popes 都不知道是甚麼QQ，我還需要好好磨練、好好讓自己的英文能力進步啦，英文真的好重要好重要，可是我每次只要回到家都沒有再讀英文…，我也太沒用了八。</p>
<p>好啦，題外話講多了，其實我在寫這一題時，我發現這題其實沒有很難寫，但是卡在解決二分搜尋的一些小毛病，例如要大於等於…之類的，最近在增強自己沒有透過紙筆也能夠進行表達以及程式思考的方式，加強我自己對於一些簡單判斷的基礎能力，如果可以將簡單判斷減少依賴，或許我在表達時就可以表達的流暢些，我常常在口述表達自己時長不完善，但只要透過文字我就可以很能夠表達我自己，因為文字我可以做 Review，但口述卻沒辦法。</p>
<p>之後也要好好努力，成為一位不愧對過去自己的人。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>其實就是沒有附上說明的程式碼，看得懂跟說得出來真的是兩回事，也許還有人覺得我說的很差，不過我已經盡力解釋。希望可以幫助到各位。</p>
<p>也希望大家想要學習的知識都可以快速學習而成，不要因為自身的環境不足而學習不到。</p>
<p>於是這裡就補述一些題目給的資料範圍限制與標頭檔了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 1000010</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> y , p , temp , num[MAX] ;</span><br><span class="line"><span class="keyword">int</span> max_large , max_first , max_last ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bs</span><span class="params">(<span class="keyword">int</span> l , <span class="keyword">int</span> r , <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m ;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">        <span class="comment">//debug</span></span><br><span class="line">        <span class="comment">//cout &lt;&lt; num[l] &lt;&lt; ' ' &lt;&lt; num[r] &lt;&lt; '\n' ;</span></span><br><span class="line">        m = (l+r) / <span class="number">2</span> ;</span><br><span class="line">        <span class="keyword">if</span>(num[m] &lt;= v) l = ++m;</span><br><span class="line">        <span class="keyword">else</span> r = m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m<span class="number">-1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> );</span><br><span class="line">    <span class="comment">//freopen("out.txt" , "w" , stdout);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">int</span> large , first , last ;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; y)&#123;</span><br><span class="line">        max_large = max_first = max_last = <span class="number">0</span> ;</span><br><span class="line">        large = first = last = <span class="number">0</span> ;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; p ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; p ; i++) <span class="built_in">cin</span> &gt;&gt; num[i] ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; p ; i++)&#123;</span><br><span class="line">            last = bs(i,p,num[i]+y<span class="number">-1</span>) ;</span><br><span class="line">            first = i ;</span><br><span class="line">            large = last - first +<span class="number">1</span> ;</span><br><span class="line">            <span class="comment">//debug</span></span><br><span class="line">            <span class="comment">//cout &lt;&lt; "i = " &lt;&lt; i &lt;&lt; " binary search range " &lt;&lt; num[first] &lt;&lt; "-" &lt;&lt; num[last] &lt;&lt; " result is " &lt;&lt; large &lt;&lt; '\n' ;</span></span><br><span class="line">            <span class="keyword">if</span>(large &gt;  max_large)&#123;</span><br><span class="line">                max_large = large ;</span><br><span class="line">                max_first = first ;</span><br><span class="line">                max_last = last ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; max_large &lt;&lt; <span class="string">" "</span> &lt;&lt; num[max_first] &lt;&lt; <span class="string">" "</span> &lt;&lt; num[max_last] &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>演算法知識</tag>
      </tags>
  </entry>
  <entry>
    <title>Rselenium 一些應用與教學</title>
    <url>/2020/11/15/R/R-Rselenium/</url>
    <content><![CDATA[<h2 id="內容說明"><a href="#內容說明" class="headerlink" title="內容說明"></a>內容說明</h2><blockquote>
<p>主要是透過 Rselenium 來模擬人類打開網頁並對其進行操作，以下是一些 Rselenium 下載的教學步驟</p>
</blockquote>
<a id="more"></a>

<h2 id="安裝-Rselenium"><a href="#安裝-Rselenium" class="headerlink" title="安裝 Rselenium"></a>安裝 Rselenium</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">install.packages(<span class="string">"RSelenium"</span>)</span><br></pre></td></tr></table></figure>

<h2 id="安裝-WebDriver"><a href="#安裝-WebDriver" class="headerlink" title="安裝 WebDriver"></a>安裝 WebDriver</h2><h3 id="Step-1"><a href="#Step-1" class="headerlink" title="Step 1:"></a>Step 1:</h3><p>由於我們安裝好 Selenium 後，Selenium 是程式語言與 browser 溝通的關鍵，於是我們還需要安裝一個機器人專用的<strong>瀏覽器</strong>來給他進行操控，目前支持機器人操控瀏覽器的有 Google Chrome and Firefox</p>
<p>首先先去<a href="https://www.selenium.dev/downloads/" target="_blank" rel="noopener">這裡</a>，找到目前最新的 Selenium Server 版本，作者在寫此文章時是這個版本。</p>
<p><strong>如果電腦沒有 java 必須先去下載 java 才能安裝成功，建議可以將命令先 cd 至爬蟲資料夾</strong></p>
<p><img src="/images/R-Rselenium/1.PNG" alt=""></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta"># java -jar selenium-server-standalone-X.XXX.XX.jar</span></span><br></pre></td></tr></table></figure>

<h3 id="Step-2"><a href="#Step-2" class="headerlink" title="Step 2:"></a>Step 2:</h3><p>下一步則是我們要將 Google Chrome 專用的瀏覽器進行下載，先在 R console 中輸入</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">binman::list_versions(<span class="string">"chromedriver"</span>)</span><br></pre></td></tr></table></figure>

<p>應該要能夠出現，以下的感覺</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="string">"85.0.4183.87"</span> <span class="string">"86.0.4240.22"</span> <span class="string">"87.0.4280.20"</span></span><br></pre></td></tr></table></figure>

<p>接著去<a href="https://chromedriver.chromium.org/downloads" target="_blank" rel="noopener">此網站</a>，下載最適合的版本，並放入你寫程式的資料夾內，建議放入與上述 <code>selenium-server-standalone-X.XXX.XX.jar</code>相同位置</p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://blog.gtwang.org/r/rselenium-r-selenium-browser-web-scraping-tutorial/" target="_blank" rel="noopener">RSelenium：R 使用 Selenium 操控瀏覽器下載網頁資料</a><br><a href="https://www.selenium.dev/downloads/" target="_blank" rel="noopener">Selenium</a><br><a href="https://mran.microsoft.com/snapshot/2017-12-11/web/packages/RSelenium/vignettes/RSelenium-basics.html" target="_blank" rel="noopener">RSelenium: Basics</a><br><a href="https://stackoverflow.com/questions/56857745/chromedriver-vs-chrome-update-incompatibility" target="_blank" rel="noopener">Chromedriver vs. Chrome update incompatibility</a></p>
]]></content>
      <categories>
        <category>R語言</category>
      </categories>
      <tags>
        <tag>R語言</tag>
        <tag>學習筆記</tag>
        <tag>網路爬蟲</tag>
      </tags>
  </entry>
  <entry>
    <title>QUESTION! 在 R 語言中數字後面有 L 是甚麼意思呢？</title>
    <url>/2020/11/15/R/R-L_meaning/</url>
    <content><![CDATA[<h2 id="內容說明："><a href="#內容說明：" class="headerlink" title="內容說明："></a>內容說明：</h2><blockquote>
<p>在 R 語言中數字後面有 L 是甚麼意思呢？<br>例如： 1233L 是甚麼意思？</p>
</blockquote>
<a id="more"></a>

<h2 id="Answer-表示長整數"><a href="#Answer-表示長整數" class="headerlink" title="Answer: 表示長整數"></a>Answer: 表示長整數</h2><p>如果有再寫 C++ 的人可以知道，在 C++ 中有一個資料型態叫做 <code>int</code>，可以表達數字在 \(\pm 2^{31}-1\)，在 R 語言中數字後面加上 L 也是此意思。</p>
<p>主要是因為 R 語言中數值型態有分，數值(numeric) or 整數 (integer)，因此才需要再有一些些麻煩的設定。</p>
<h2 id="參考連結："><a href="#參考連結：" class="headerlink" title="參考連結："></a>參考連結：</h2><p><a href="https://bookdown.org/tonykuoyj/eloquentr/variable-types.html" target="_blank" rel="noopener">8 精簡的變數型別</a></p>
]]></content>
      <categories>
        <category>R語言</category>
      </categories>
      <tags>
        <tag>R語言</tag>
        <tag>學習筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 比較時間先後</title>
    <url>/2020/11/24/Python/Python_compare_time/</url>
    <content><![CDATA[<h2 id="內容說明"><a href="#內容說明" class="headerlink" title="內容說明"></a>內容說明</h2><blockquote>
<p>有時候在寫程式的時候，需要比較兩個時間的先來後到，那我們應該要怎麼比較呢？</p>
</blockquote>
<a id="more"></a>

<h2 id="最簡單的比較方式"><a href="#最簡單的比較方式" class="headerlink" title="最簡單的比較方式"></a>最簡單的比較方式</h2><p>在擁有著大量套件的 Python 中，如果要比較時間大小不一定需要使用到數學XD，Python 可以用一個語法 <code>time.strftime</code> 透過<strong>日期格式</strong>轉換成數字，就變成了單純的比數字大小遊戲XD。</p>
<h3 id="比較沒有紀錄天數的時間點"><a href="#比較沒有紀錄天數的時間點" class="headerlink" title="比較沒有紀錄天數的時間點"></a>比較沒有紀錄天數的時間點</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">int(time.strftime(<span class="string">"%H%M%S"</span>))</span><br><span class="line"></span><br><span class="line">int(time.strftime(<span class="string">"%H%M%S"</span>,<span class="string">"09:12:22"</span>)) = <span class="number">091222</span></span><br></pre></td></tr></table></figure>

<h3 id="比較日期"><a href="#比較日期" class="headerlink" title="比較日期"></a>比較日期</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">int(time.strftime(<span class="string">"%Y-%m-%d"</span>))</span><br><span class="line"></span><br><span class="line">int(time.strftime(<span class="string">"%Y-%m-%d"</span>,<span class="string">"2020-11-24"</span>)) = <span class="number">20201124</span></span><br></pre></td></tr></table></figure>

<p>注意:不需要擔心數字會不會超過 int or long long 的長度，因為 Python 的數字內建支援大數運算XD。</p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://blog.csdn.net/junbujianwpl/article/details/60984757" target="_blank" rel="noopener">Python比较2个时间的大小</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>Python 好簡單，可以把一些比較麻煩的事情都解決掉，設計出 Python 的人是天才八，好感謝這個世界有這麼多人無私的奉獻才有辦法讓我自學努力到現在。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 有沒有 do...until 迴圈</title>
    <url>/2020/11/24/Python/Python_do_until/</url>
    <content><![CDATA[<h2 id="內容說明"><a href="#內容說明" class="headerlink" title="內容說明"></a>內容說明</h2><blockquote>
<p>Python 有沒有 do…until 迴圈來幫助我們寫呢？</p>
</blockquote>
<a id="more"></a>

<h2 id="答案是…沒有！"><a href="#答案是…沒有！" class="headerlink" title="答案是…沒有！"></a>答案是…沒有！</h2><p>很意外八！但還是有解決方案的，不然我就不會寫一篇了對吧！</p>
<p>寫法主要如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    do_something()</span><br><span class="line">    <span class="keyword">if</span> condition():</span><br><span class="line">       <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<p>透過在最後用一個 if 進行判斷，來模擬成 do..until 迴圈。</p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://stackoverflow.com/questions/1662161/is-there-a-do-until-in-python" target="_blank" rel="noopener">Is there a “do … until” in Python? [duplicate]</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>雖然是有點麻煩的事情，不過其實還算是可以接受啦，有沒有改進其實都還可以，沒有問題的XD。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 操控 Excel 利用 openpyxl 套件</title>
    <url>/2020/11/24/Python/Python_openpyxl/</url>
    <content><![CDATA[<h2 id="內容說明"><a href="#內容說明" class="headerlink" title="內容說明"></a>內容說明</h2><blockquote>
<p>說明大衛在 Python openpyxl 套件學習的路上，有用到的語法紀錄</p>
</blockquote>
<a id="more"></a>

<h2 id="安裝套件"><a href="#安裝套件" class="headerlink" title="安裝套件"></a>安裝套件</h2><p>如果你跟我用的一樣，都是用 Spyder 此軟體來寫程式的話，只需要去旁邊的 Console 打下方指令即可。</p>
<p>如果不是，那就在 terminal 中打此指令也是可以的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install openpyxl</span><br></pre></td></tr></table></figure>

<h2 id="在程式中匯入套件"><a href="#在程式中匯入套件" class="headerlink" title="在程式中匯入套件"></a>在程式中匯入套件</h2><p>沒有匯入的話，這份程式碼是沒辦法使用此套件的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> openpyxl</span><br></pre></td></tr></table></figure>

<h2 id="Python-Openpyxl-的一些用法"><a href="#Python-Openpyxl-的一些用法" class="headerlink" title="Python Openpyxl 的一些用法"></a>Python Openpyxl 的一些用法</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> openpyxl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立一個 Excel </span></span><br><span class="line">workbook = openpyxl.Workbook()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 焦點放在第一張工作表</span></span><br><span class="line">sheet = workbook.worksheets[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一張工作表 A1 儲存格設定值為 "Hello David and Openpyxl."</span></span><br><span class="line">sheet[<span class="string">"A1"</span>] = <span class="string">"Hello David and Openpyxl."</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 將 text 設定成第一張工作表 A1 儲存格</span></span><br><span class="line">text = sheet[<span class="string">"A1"</span>].value</span><br><span class="line"></span><br><span class="line"><span class="comment"># row 最大數量</span></span><br><span class="line">print(sheet.max_row)</span><br><span class="line"></span><br><span class="line"><span class="comment"># column 最大數量</span></span><br><span class="line">print(sheet.max_column)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 儲存檔案</span></span><br><span class="line">workbook.save(<span class="string">'test.xlsx'</span>)</span><br></pre></td></tr></table></figure>

<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://ithelp.ithome.com.tw/articles/10246377" target="_blank" rel="noopener">[2020鐵人賽Day16]糊裡糊塗Python就上手-Python Excel 操縱套餐(使用openpyxl)</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>Python 操作 Excel 比起 C++ 真的是優秀太多了，很不賴欸，怪不得會有那麼多人喜歡寫 Python，如果是要寫應用，我自己也會越來越喜歡寫 Python XD，不過可能要注意一下還是要懂那些內涵，不然就像是一個會用的麻瓜。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 一個 function 回傳兩個值</title>
    <url>/2020/11/24/Python/Python_return_two_value_from_a_function/</url>
    <content><![CDATA[<h2 id="內容說明"><a href="#內容說明" class="headerlink" title="內容說明"></a>內容說明</h2><blockquote>
<p>在寫程式的時候，偶爾會需要一個 function 回傳兩個值，但你卻很懶惰的不想用一個 list 裝，此時又想到 C++ 有 pair 可以用，那 Python 有沒有呢？</p>
</blockquote>
<h2 id="答案是…沒有！"><a href="#答案是…沒有！" class="headerlink" title="答案是…沒有！"></a>答案是…沒有！</h2><p>但有兩種解決方案，如果你非常需要用到 pair 這資料結構時，那就直接自己寫一個 class 來定義吧！或是將兩個變數丟給 function，之後再回傳兩個 value。</p>
<h3 id="解決方案-寫一個-Class"><a href="#解決方案-寫一個-Class" class="headerlink" title="解決方案 - 寫一個 Class"></a>解決方案 - 寫一個 Class</h3><p>就…手寫阿XD，之後宣告一個 pair 即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">pair</span><span class="params">()</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,key,value)</span>:</span></span><br><span class="line">    self.key = key </span><br><span class="line">    self.value = value</span><br></pre></td></tr></table></figure>

<h3 id="解決方案-function-return-two-value"><a href="#解決方案-function-return-two-value" class="headerlink" title="解決方案 - function return two value"></a>解決方案 - function return two value</h3><p>透過 function 回傳兩個值來解決此問題。</p>
<p>觀看下方 function 可以了解到，<code>thing function</code>回傳了兩個值 a,b，並將 a 給予 c、b 給予 d。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">thing</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> a , b </span><br><span class="line"></span><br><span class="line">c , d = thing()</span><br></pre></td></tr></table></figure>

<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://stackoverflow.com/questions/9752958/how-can-i-return-two-values-from-a-function-in-python" target="_blank" rel="noopener">How can I return two values from a function in Python?</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>Python 好簡單，可以把一些比較麻煩的事情都解決掉，設計出 Python 的人是天才八，好感謝這個世界有這麼多人無私的奉獻才有辦法讓我自學努力到現在。</p>
<p>我想應該是有人有寫出這種類似 C++ pair 的套件，不過我不確定就是了。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 切割字串</title>
    <url>/2020/11/24/Python/Python_split/</url>
    <content><![CDATA[<h2 id="內容說明"><a href="#內容說明" class="headerlink" title="內容說明"></a>內容說明</h2><blockquote>
<p>通常在寫程式時都會需要用到字串切割，那 Python 的字串切割要怎麼做呢？</p>
</blockquote>
<a id="more"></a>

<h2 id="Python-String-split-切割字串函數"><a href="#Python-String-split-切割字串函數" class="headerlink" title="Python String.split 切割字串函數"></a>Python String.split 切割字串函數</h2><p>只要在 <code>string.split()</code> 就可以切割函數</p>
<p>通常會用到的有這幾種，如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">str = <span class="string">"this is David and ...!!"</span></span><br><span class="line">print(str.split()) # 用空格來切割</span><br><span class="line">print(str.split(<span class="string">"i"</span>,<span class="number">1</span>)) # 以 i 來切割，但只切割第一次</span><br><span class="line">print(str.split(<span class="string">"a"</span>)) # 以 a 來切割，但不斷切割，直到字串結尾</span><br></pre></td></tr></table></figure>

<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://www.runoob.com/python3/python3-string-split.html" target="_blank" rel="noopener">Python3 split()方法</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>Python 好簡單，可以把一些比較麻煩的事情都解決掉，設計出 Python 的人是天才八，好感謝這個世界有這麼多人無私的奉獻才有辦法讓我自學努力到現在。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 使用 threading 套件來讓多執行緒來加速運算速度</title>
    <url>/2020/11/25/Python/Python_threading/</url>
    <content><![CDATA[<h2 id="內容說明"><a href="#內容說明" class="headerlink" title="內容說明"></a>內容說明</h2><blockquote>
<p>有的時候會需要用到多執行緒來讓整個程式加速運算，在現代電腦中擁有多核心 CPU 以是常態，但通常一份程式碼都是使用單核心來操控，如果我們讓他多核心操控就可以擁有更快速度啦！</p>
<p>一種自己程式碼寫不好就幫硬體升級的概念XD。</p>
</blockquote>
<a id="more"></a>

<h2 id="一些說明："><a href="#一些說明：" class="headerlink" title="一些說明："></a>一些說明：</h2><ul>
<li>在使用 threading 套件時，不可以將 list 傳給多個 threading<br>舉例： A threading 移除 list index 0 的值，B 則呼叫 list index 0 的值，此時會產生錯誤，原因是因為 B threading 還認為 list index 0 的 memory 還在那位置，但卻發現不再、被移除。</li>
<li><em>因此我們無法保證 List 在多執行緒時能被正常使用。*</em></li>
<li>在多執行緒需要同時用到一個陣列時，建議使用 deque(內建)，<code>import queue</code><br>Python 有保證 queue 在 threading 時絕對安全，因此個人建議盡量使用他。</li>
</ul>
<h2 id="安裝套件"><a href="#安裝套件" class="headerlink" title="安裝套件"></a>安裝套件</h2><p>沒有！他是內建的，完全不需要安裝喔，讚啦。</p>
<h2 id="在程式中匯入套件"><a href="#在程式中匯入套件" class="headerlink" title="在程式中匯入套件"></a>在程式中匯入套件</h2><p>還是要的，這是必備。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br></pre></td></tr></table></figure>

<h2 id="建立子執行緒的例子"><a href="#建立子執行緒的例子" class="headerlink" title="建立子執行緒的例子"></a>建立子執行緒的例子</h2><p>要稍微注意一下：<code>threading.Thread(target= function,args= (A,B))</code> ，這裡的 <code>function</code> <strong>不可以加括號</strong>，因為這裡是找他記憶體位置，但如果你想要執行的 function 有參數要傳進去則要在後面加入 <code>args= (A,B)</code>，並記住，<strong>他一定要是一個 list or tuple</strong>，不可以只是一個 int or string..，一定是要一個陣列。</p>
<p>如果要問我為甚麼？我只知道這是寫套建時的規則，我也沒辦法說出一個很好的大概。</p>
<p>如果需要不斷的讓這些執行緒工作，這裡有一個不錯的寫法，建議看看：<br><a href="https://theriseofdavid.github.io/2020/11/30/Python/Python_Open_multiple_threads_and_find_idle_threads/" target="_blank" rel="noopener">Python 開多執行緒並找出空閒執行緒的方法 (使用 threading 套件)</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading <span class="comment"># 匯入套件</span></span><br><span class="line"><span class="keyword">import</span> time <span class="comment"># 匯入套件</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">job</span><span class="params">(it,nu)</span>:</span>  <span class="comment"># thread 要執行的工作內容</span></span><br><span class="line">  print(<span class="string">"thread"</span> , it , <span class="string">" is ready to work."</span>)</span><br><span class="line">  time.sleep(<span class="number">2</span>)</span><br><span class="line">  print(<span class="string">"thread"</span> , it , <span class="string">"is finished."</span>)</span><br><span class="line"></span><br><span class="line">t = [] <span class="comment"># 這是 threading 的陣列，我們用這個陣列來表示裡面的某個執行緒。</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>): <span class="comment"># 這裡我們假設給 3 個執行緒</span></span><br><span class="line">    t.append(threading.Thread(target = job , args=(i,<span class="string">""</span> )))</span><br><span class="line">    <span class="comment"># t 陣列增加一個執行緒，執行 function 為 job ， 參數為 args</span></span><br><span class="line">    t[i].start() <span class="comment"># 執行此執行緒</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>): <span class="comment"># 檢查這些執行緒有沒有都做完，才特別寫的</span></span><br><span class="line">    <span class="keyword">if</span>(t[i].isAlive()): <span class="comment">#確認這個執行緒有沒有正在被使用，如果有則是 True</span></span><br><span class="line">      t[i].join() <span class="comment">#等待這個執行緒工作完畢</span></span><br></pre></td></tr></table></figure>

<h2 id="將執行緒寫成-OOP"><a href="#將執行緒寫成-OOP" class="headerlink" title="將執行緒寫成 OOP"></a>將執行緒寫成 OOP</h2><p>作者還沒讀到，未來會看看。</p>
<h2 id="QUEUE-搭配-執行續"><a href="#QUEUE-搭配-執行續" class="headerlink" title="QUEUE 搭配 執行續"></a>QUEUE 搭配 執行續</h2><p>作者還沒讀到，未來會看看。</p>
<h2 id="防止兩個多執行緒同時寫入一個檔案-LOCK"><a href="#防止兩個多執行緒同時寫入一個檔案-LOCK" class="headerlink" title="防止兩個多執行緒同時寫入一個檔案 (LOCK)"></a>防止兩個多執行緒同時寫入一個檔案 (LOCK)</h2><p>作者還沒讀到，未來會看看。</p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://blog.gtwang.org/programming/python-threading-multithreaded-programming-tutorial/" target="_blank" rel="noopener">Python 多執行緒 threading 模組平行化程式設計教學</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>Python 好簡單，可以把一些比較麻煩的事情都解決掉，設計出 Python 的人是天才八，好感謝這個世界有這麼多人無私的奉獻才有辦法讓我自學努力到現在。</p>
<p>多執行緒真的好方便，初學者如果想要略過一些複雜的理論或實作時，用 Python 可以省去很多麻煩呢。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 使用 Pymysql 套件來在 Python 中執行資料庫 (for windows)</title>
    <url>/2020/11/30/Python/Python_Mysql_pymysql/</url>
    <content><![CDATA[<h2 id="內容說明"><a href="#內容說明" class="headerlink" title="內容說明"></a>內容說明</h2><blockquote>
<p>寫程式如果需要讀取大量資料或抓取資料時，使用資料庫是在好不過的選擇了！這裡就來說說 MySQL 應用在 Python 的教學八！</p>
<p>此文章只針對 Windows OS，沒有對 Linux 進行解說，未來有機會會寫一篇</p>
<p><a href="http://note.drx.tw/2012/12/mysql-syntax.html" target="_blank" rel="noopener">MySQL 語法連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="安裝-MySQL"><a href="#安裝-MySQL" class="headerlink" title="安裝 MySQL"></a>安裝 MySQL</h2><p>沒有資料庫，你要怎麼應用資料庫XD。</p>
<h3 id="下載-MySQL-for-windows"><a href="#下載-MySQL-for-windows" class="headerlink" title="下載 MySQL (for windows)"></a>下載 MySQL (for windows)</h3><p>這裡的下載 MySQL 以 Windows 為主，如果想要知道 Linux 的使用方法話，就去看其他文章吧！作者目前還沒遇到此問題www，相信以後就會碰到QQ。</p>
<p>從這裡 <a href="https://dev.mysql.com/downloads/installer/" target="_blank" rel="noopener">下載 MySQL</a>後，點選此下載<br><img src="/images/Python_Mysql_pymysql/1.PNG" alt=""></p>
<p>下載後，在點擊下方的 <strong>No thanks, just start my download.</strong> 後則立即下載。<br><img src="/images/Python_Mysql_pymysql/2.PNG" alt=""></p>
<ul>
<li><p>開啟安裝檔後，點 Developer Default，之後點選 Next</p>
</li>
<li><p>接下來設定 MySQL 的資料庫帳號，必須設置，<strong>無法跳過</strong></p>
</li>
<li><p>設置完成後接下來則需要登入帳密檢查</p>
</li>
<li><p>之後點擊灰色方塊即可，並輸入帳號密碼即可<br><img src="/images/Python_Mysql_pymysql/3.PNG" alt=""></p>
</li>
</ul>
<h2 id="建立-MySQL-資料庫"><a href="#建立-MySQL-資料庫" class="headerlink" title="建立 MySQL 資料庫"></a>建立 MySQL 資料庫</h2><ul>
<li><p>登入成功並進去後，點擊資料庫圖示，建立資料庫，改成自己想要的名子、並將 Charset 改成 UTF-8，並點選右下角的 Apply 建立資料庫，並一直點擊 apply、Finish 就可以建立成功。<br><img src="/images/Python_Mysql_pymysql/4.PNG" alt=""></p>
</li>
<li><p>接下來找到 Schemas 點擊<br><img src="/images/Python_Mysql_pymysql/5.PNG" alt=""></p>
</li>
<li><p>點擊 table(1)，再來點 table 右鍵為新增<strong>資料表</strong>(英文為 create table)，新增資料庫欄位(2)，完成後點擊 Apply(3)<br>注意：新增資料庫欄位(2)，Primary key 一定要對 PK、NN 打勾。<br><img src="/images/Python_Mysql_pymysql/6.PNG" alt=""></p>
<h3 id="MySQL-pk、nn、qu、b、un、zf、ai、g-的意思"><a href="#MySQL-pk、nn、qu、b、un、zf、ai、g-的意思" class="headerlink" title="MySQL pk、nn、qu、b、un、zf、ai、g 的意思"></a>MySQL pk、nn、qu、b、un、zf、ai、g 的意思</h3></li>
<li><p>PK primary key 主键</p>
</li>
<li><p>NN not null 欄位不可為空</p>
</li>
<li><p>UQ unique 唯一索引</p>
</li>
<li><p>BIN binary 二進位資料，比 text 更大的二進位資料</p>
</li>
<li><p>UN unsigned 沒有正負符號</p>
</li>
<li><p>ZF zero fill 將剩餘的位數填 0，舉例： int(4) 內容顯現為 0001</p>
</li>
<li><p>AI auto increment 自增</p>
</li>
<li><p>G generated column 生成列</p>
</li>
<li><p>\g 等同於 MySQL 中的 “;” </p>
</li>
<li><p>\G 等同於將資料轉向，舉例：縱向資料表轉變成橫向資料表</p>
</li>
</ul>
<h2 id="在-Python-操作-MySQL"><a href="#在-Python-操作-MySQL" class="headerlink" title="在 Python 操作 MySQL"></a>在 Python 操作 MySQL</h2><p>MySQL 建置完成後，透過 Python 進行操作。</p>
<h3 id="安裝套件"><a href="#安裝套件" class="headerlink" title="安裝套件"></a>安裝套件</h3><ul>
<li>在 cmd 安裝 <code>pip install pymysql</code></li>
</ul>
<h3 id="測試資料庫"><a href="#測試資料庫" class="headerlink" title="測試資料庫"></a>測試資料庫</h3><p>如果下方程式碼成功印出連線成功，就表示資料庫連線成功了！</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"></span><br><span class="line">db_settings = &#123;</span><br><span class="line">  <span class="string">"host"</span> : <span class="string">"127.0.0.1"</span>,</span><br><span class="line">  <span class="string">"port"</span> : <span class="number">3306</span>,</span><br><span class="line">  <span class="string">"user"</span> : <span class="string">"資料庫管理員帳號"</span> ,</span><br><span class="line">  <span class="string">"password"</span> : <span class="string">"資料庫管理員密碼"</span> ,</span><br><span class="line">  <span class="string">"db"</span> : <span class="string">"demo"</span> ,　<span class="comment"># 根據你的資料庫名稱</span></span><br><span class="line">  <span class="string">"charset"</span> : <span class="string">"utf8"</span>　</span><br><span class="line">&#125;</span><br><span class="line">conn = pymysql.connect(**db_settings)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 建立Connection物件</span></span><br><span class="line">    conn = pymysql.connect(**db_settings)</span><br><span class="line">    print(<span class="string">"連線成功"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> conn.cursor() <span class="keyword">as</span> cursor: </span><br><span class="line">    <span class="comment">#稍微注意一下 with statement 完成後，會自動關閉資料庫的連線操作，詳請需要 with 指令</span></span><br><span class="line">      <span class="comment">#資料表相關操作</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> ex: <span class="comment"># 出現意外時印出</span></span><br><span class="line">    print(ex)</span><br></pre></td></tr></table></figure>

<h3 id="新增資料"><a href="#新增資料" class="headerlink" title="新增資料"></a>新增資料</h3><p>檢查 MySQL Workbench 如果成功有出現一筆資料則表示成功！</p>
<p>應該會出現如下：<br><img src="/images/Python_Mysql_pymysql/7.PNG" alt=""></p>
<p>P.S. 需要點擊 MySQL 指令的閃電，才會重新執行指令呦！位置如下：<br><img src="/images/Python_Mysql_pymysql/9.PNG" alt=""></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"></span><br><span class="line">db_settings = &#123;</span><br><span class="line">  <span class="string">"host"</span> : <span class="string">"127.0.0.1"</span>,</span><br><span class="line">  <span class="string">"port"</span> : <span class="number">3306</span>,</span><br><span class="line">  <span class="string">"user"</span> : <span class="string">"資料庫管理員帳號"</span> ,</span><br><span class="line">  <span class="string">"password"</span> : <span class="string">"資料庫管理員密碼"</span> ,</span><br><span class="line">  <span class="string">"db"</span> : <span class="string">"demo"</span> ,</span><br><span class="line">  <span class="string">"charset"</span> : <span class="string">"utf8"</span></span><br><span class="line">&#125;</span><br><span class="line">conn = pymysql.connect(**db_settings)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">  <span class="keyword">with</span> conn.cursor() <span class="keyword">as</span> cursor:</span><br><span class="line">    command = <span class="string">f"INSERT INTO class(id,name) VALUES (%s,%s)"</span> </span><br><span class="line">    <span class="comment"># 需要特別注意，我們要新增的值，並不是根據資料庫的類型，而是要能夠符合 Python String 要求</span></span><br><span class="line">    <span class="comment"># 於是全部的值都設定成 %s</span></span><br><span class="line">    cursor.execute(command,(<span class="string">"1"</span>,<span class="string">"science"</span>)) <span class="comment">#後面則是我們 %s 要傳給 MySQL 的值</span></span><br><span class="line">    <span class="comment"># 記住： 一定要用小括號包住，即使是只有傳回一個值也是如此，語法規定。</span></span><br><span class="line">    print(<span class="string">"新增資料完成"</span>)</span><br><span class="line">    conn.commit() <span class="comment">#這是最重要的，如果沒有儲存變更，則 Py 會一直操作 MySQL 不會退出</span></span><br><span class="line">    <span class="comment"># 而導致 MySQL 被占用，而無法被其他程式呼叫或使用</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> ex:</span><br><span class="line">    print(ex)</span><br></pre></td></tr></table></figure>

<h3 id="查詢資料"><a href="#查詢資料" class="headerlink" title="查詢資料"></a>查詢資料</h3><p>剛剛已經新增過資料，那現在我們來測試查詢資料，我們透過 Primary key 來查詢！</p>
<p>查詢的 id = ‘1’，應該要傳回的值如下：<br><img src="/images/Python_Mysql_pymysql/8.PNG" alt=""></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"></span><br><span class="line">db_settings = &#123;</span><br><span class="line">  <span class="string">"host"</span> : <span class="string">"127.0.0.1"</span>,</span><br><span class="line">  <span class="string">"port"</span> : <span class="number">3306</span>,</span><br><span class="line">  <span class="string">"user"</span> : <span class="string">"資料庫管理員帳號"</span> ,</span><br><span class="line">  <span class="string">"password"</span> : <span class="string">"資料庫管理員密碼"</span> ,</span><br><span class="line">  <span class="string">"db"</span> : <span class="string">"demo"</span> ,</span><br><span class="line">  <span class="string">"charset"</span> : <span class="string">"utf8"</span></span><br><span class="line">&#125;</span><br><span class="line">conn = pymysql.connect(**db_settings)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">  <span class="keyword">with</span> conn.cursor() <span class="keyword">as</span> cursor:</span><br><span class="line">    command = <span class="string">f"select * from class where id = %s"</span> </span><br><span class="line">    cursor.execute(command,(<span class="string">"1"</span>)) </span><br><span class="line">    print(<span class="string">"查詢資料完成"</span>)</span><br><span class="line">    results = cursor.fetchall() <span class="comment">#傳回資料，P.S. 這裡會傳回全部的資料，並使用 tuple 包裝</span></span><br><span class="line">    print(results[<span class="number">0</span>]) <span class="comment">#傳回的那行會用 tuple 包裝</span></span><br><span class="line">    conn.commit() <span class="comment">#這是最重要的，如果沒有儲存變更，則 Py 會一直操作 MySQL 不會退出</span></span><br><span class="line">    <span class="comment"># 而導致 MySQL 被占用，而無法被其他程式呼叫或使用</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> ex:</span><br><span class="line">    print(ex)</span><br></pre></td></tr></table></figure>

<h3 id="修改資料"><a href="#修改資料" class="headerlink" title="修改資料"></a>修改資料</h3><p>剛剛也成功查詢了，現在我們來修改吧！應該要能夠出來以下的值才表示成功：<br><img src="/images/Python_Mysql_pymysql/10.PNG" alt=""></p>
<p>P.S. 記住要重新執行一次查詢指令XD</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"></span><br><span class="line">db_settings = &#123;</span><br><span class="line">  <span class="string">"host"</span> : <span class="string">"127.0.0.1"</span>,</span><br><span class="line">  <span class="string">"port"</span> : <span class="number">3306</span>,</span><br><span class="line">  <span class="string">"user"</span> : <span class="string">"root"</span> ,</span><br><span class="line">  <span class="string">"password"</span> : <span class="string">"1234"</span> ,</span><br><span class="line">  <span class="string">"db"</span> : <span class="string">"demo"</span> ,</span><br><span class="line">  <span class="string">"charset"</span> : <span class="string">"utf8"</span></span><br><span class="line">&#125;</span><br><span class="line">conn = pymysql.connect(**db_settings)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">  <span class="keyword">with</span> conn.cursor() <span class="keyword">as</span> cursor:</span><br><span class="line">    command = <span class="string">f"update class set name= %s where id = %s"</span> </span><br><span class="line">    <span class="comment"># 需要特別注意，我們要新增的值，並不是根據資料庫的類型，而是要能夠符合 Python String 要求</span></span><br><span class="line">    <span class="comment"># 於是全部的值都設定成 %s</span></span><br><span class="line">    cursor.execute(command,(<span class="string">"math"</span>,<span class="string">"1"</span>)) <span class="comment">#後面則是我們 %s 要傳給 MySQL 的值</span></span><br><span class="line">    <span class="comment"># 記住： 一定要用小括號包住，即使是只有傳回一個值也是如此，語法規定。</span></span><br><span class="line">    print(<span class="string">"修改資料完成"</span>)</span><br><span class="line">    conn.commit() <span class="comment">#這是最重要的，如果沒有儲存變更，則 Py 會一直操作 MySQL 不會退出</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> ex:</span><br><span class="line">    print(ex)</span><br></pre></td></tr></table></figure>

<h3 id="刪除資料"><a href="#刪除資料" class="headerlink" title="刪除資料"></a>刪除資料</h3><p>修改完資料後，接下來就是刪除資料拉。刪除資料後資料庫應該要為空，如下：<br><img src="/images/Python_Mysql_pymysql/11.PNG" alt=""></p>
<p>記住也要重新執行查詢指令XD。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"></span><br><span class="line">db_settings = &#123;</span><br><span class="line">  <span class="string">"host"</span> : <span class="string">"127.0.0.1"</span>,</span><br><span class="line">  <span class="string">"port"</span> : <span class="number">3306</span>,</span><br><span class="line">  <span class="string">"user"</span> : <span class="string">"root"</span> ,</span><br><span class="line">  <span class="string">"password"</span> : <span class="string">"1234"</span> ,</span><br><span class="line">  <span class="string">"db"</span> : <span class="string">"demo"</span> ,</span><br><span class="line">  <span class="string">"charset"</span> : <span class="string">"utf8"</span></span><br><span class="line">&#125;</span><br><span class="line">conn = pymysql.connect(**db_settings)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">  <span class="keyword">with</span> conn.cursor() <span class="keyword">as</span> cursor:</span><br><span class="line">    command = <span class="string">f"delete from class where id =%s"</span> </span><br><span class="line">    <span class="comment"># 需要特別注意，我們要新增的值，並不是根據資料庫的類型，而是要能夠符合 Python String 要求</span></span><br><span class="line">    <span class="comment"># 於是全部的值都設定成 %s</span></span><br><span class="line">    cursor.execute(command,(<span class="string">"1"</span>)) <span class="comment">#後面則是我們 %s 要傳給 MySQL 的值</span></span><br><span class="line">    <span class="comment"># 記住： 一定要用小括號包住，即使是只有傳回一個值也是如此，語法規定。</span></span><br><span class="line">    print(<span class="string">"刪除資料完成"</span>)</span><br><span class="line">    conn.commit() <span class="comment">#這是最重要的，如果沒有儲存變更，則 Py 會一直操作 MySQL 不會退出</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> ex:</span><br><span class="line">    print(ex)</span><br></pre></td></tr></table></figure>

<h2 id="可能會遇到的問題"><a href="#可能會遇到的問題" class="headerlink" title="可能會遇到的問題"></a>可能會遇到的問題</h2><p>這裡收錄大衛在學習 Py MySQL 操作時一些遇到的小錯誤，如果讀者也剛好有此問題剛好能看我文章解決那就再好不過了。<br><a href="https://theriseofdavid.github.io/2020/11/30/Python/Python_Pymysql_fetchone_fetchall/" target="_blank" rel="noopener">Python 套件中 Pymysql 的 fetchone() 與 fetchall() 差別</a><br><a href="https://theriseofdavid.github.io/2020/11/30/MySQL/MySQL_stop_windows_server/" target="_blank" rel="noopener">MySQL 停止在 windows 上的服務</a></p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://www.learncodewithmike.com/2020/02/python-mysql.html" target="_blank" rel="noopener">[Python實戰應用]掌握Python連結MySQL資料庫的重要操作</a><br><a href="https://blog.csdn.net/ZeroBz/article/details/79136926" target="_blank" rel="noopener">mysql pk、nn、qu、b、un、zf、ai、g代表的意思</a><br><a href="http://note.drx.tw/2012/12/mysql-syntax.html" target="_blank" rel="noopener">MySQL 語法連結</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>寫教學文章真的好難…，其實我發現我寫應用的教學文章比較沒有甚麼心得感言XD，因為都是使用別人的套件，偶爾採坑上網查資料去換另外一種寫法，直到找出可以寫的方法，不得不說有了資料庫與 Python 後我的學習路上一帆風順，我不需要懂基礎知識就可以應用，但這也同時讓我感到害怕，我是不是就只學會如何找工具，並拿來放，有點像是工人，而散播套件的人則是工廠，大量產生工具給我們用。</p>
<p>工人永遠都不懂工具是怎麼被製造而成，但工人會不斷地應用，我覺得這似乎是一件很可怕的事情，應該要懂工具是怎麼被製作、應用，學習才有踏實感也有意義吧，不然感覺現在的我似乎還是沒有像學習演算法時那樣，了解整個套件的應用。</p>
]]></content>
      <categories>
        <category>Python</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>Python</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 開多執行緒並找出空閒執行緒的方法 (使用 threading 套件)</title>
    <url>/2020/11/30/Python/Python_Open_multiple_threads_and_find_idle_threads/</url>
    <content><![CDATA[<h2 id="內容說明"><a href="#內容說明" class="headerlink" title="內容說明"></a>內容說明</h2><blockquote>
<p>這裡留存大衛在寫 Python 開多執行緒並找出空閒執行緒的方法，大衛認為此寫法不錯，因此放在這裡供各位與未來的我參考</p>
</blockquote>
<a id="more"></a>

<h2 id="寫法"><a href="#寫法" class="headerlink" title="寫法"></a>寫法</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"><span class="keyword">import</span> threading </span><br><span class="line"></span><br><span class="line">workers = queue.deque()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    workers.append(threading.Thread(target=function,args=(<span class="number">1</span>,)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> workers[<span class="number">0</span>].isAlive(): <span class="comment">#找出沒有工作的執行緒</span></span><br><span class="line">    labor = workers[<span class="number">0</span>]  <span class="comment"># labor 就是 workers[0] 並且她正在工作</span></span><br><span class="line">    workers.popleft() <span class="comment"># 將wokrers 0 移除</span></span><br><span class="line">    workers.append(labor) <span class="comment"># 再將 labor 放入，即將 workers[0] 放到 queue 的最後</span></span><br><span class="line">    time.sleep(<span class="number">1</span>) <span class="comment"># 等待一秒，在查詢下一個執行緒有沒有工作</span></span><br></pre></td></tr></table></figure>

<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>有時候真的好佩服我自己可以寫得出這種想法，我發現我的想法都是在浴室洗澡的時候想出來，看來我有一個很棒的理由可以說自己為甚麼每天要洗兩次澡了XD，因為只有在那個時候我的腦袋思緒會特別清楚，會不會是因為我把身體洗乾淨，所以腦袋也乾淨了呢wwww。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>Python</tag>
        <tag>優秀寫法紀錄</tag>
      </tags>
  </entry>
  <entry>
    <title>Python ERROR !  argument after * must be an iterable, not int</title>
    <url>/2020/11/30/Python/Python_argument_after_must_be_an_iterable_not_int/</url>
    <content><![CDATA[<h2 id="內容說明"><a href="#內容說明" class="headerlink" title="內容說明"></a>內容說明</h2><blockquote>
<p>記錄我在學習 Python 路上遇到的坑，並將以補足。 </p>
</blockquote>
<a id="more"></a> 

<h2 id="Python-ERROR-argument-after-must-be-an-iterable-not-int"><a href="#Python-ERROR-argument-after-must-be-an-iterable-not-int" class="headerlink" title="Python ERROR !  argument after * must be an iterable, not int"></a>Python ERROR !  argument after * must be an iterable, not int</h2><p>這問題主要是在講例如使用 <code>threading</code> 套件時，可能會遇到的問題。</p>
<p>以 <code>threading</code> 套件而立，args 不可以是一個數字，就算 function 的值只需要一個參數，也必須要用 tuple(或可迭代的 object)，此指令才允許被執行。</p>
<p>通常是語法規定，原因可能要問當初設計這樣的用意XD。</p>
<h3 id="正確寫法"><a href="#正確寫法" class="headerlink" title="正確寫法"></a>正確寫法</h3><p>使用正確寫法後，相信就能執行成功了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">threading.Thread(target=function, args=(<span class="number">1</span>,))</span><br></pre></td></tr></table></figure>

<h3 id="錯誤寫法"><a href="#錯誤寫法" class="headerlink" title="錯誤寫法"></a>錯誤寫法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">threading.Thread(target=function, args=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://stackoverflow.com/questions/52575418/reverse-with-prefix-argument-after-must-be-an-iterable-not-int" target="_blank" rel="noopener">_reverse_with_prefix() argument after * must be an iterable, not int</a><br><a href="https://stackoverflow.com/questions/56545387/typeerror-start-argument-after-must-be-an-iterable-not-int" target="_blank" rel="noopener">TypeError: start() argument after * must be an iterable, not int [duplicate]</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>Python 真的很方便，但即使再方便的程式語言也必須合乎套件要求才有辦法正常執行，只有學會正確的使用方式才可以完整的操作 Python，一起加油吧！</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>Python</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>QUESTION! git push 需要不斷重複輸入帳號密碼，並且還是出現登入失敗</title>
    <url>/2020/11/27/git/git_login_repeat/</url>
    <content><![CDATA[<h2 id="文章大意："><a href="#文章大意：" class="headerlink" title="文章大意："></a>文章大意：</h2><blockquote>
<p>解決 <code>git push</code> 需要一直登入帳號密碼，但還是沒辦法推上去的問題。</p>
</blockquote>
<a id="more"></a>

<h2 id="QUESTION-git-push-需要不斷重複輸入帳號密碼，並且還是出現登入失敗"><a href="#QUESTION-git-push-需要不斷重複輸入帳號密碼，並且還是出現登入失敗" class="headerlink" title="QUESTION! git push 需要不斷重複輸入帳號密碼，並且還是出現登入失敗"></a>QUESTION! git push 需要不斷重複輸入帳號密碼，並且還是出現登入失敗</h2><p>在使用 <code>git push</code> 時，可能會遇到一種狀況時，系統不斷跳出要你輸出帳號 and 密碼，你重新輸入過後，又跳出一個新視窗，此視窗與先前的不同，輸入帳號密碼後，明明正確還是說你驗證失敗時要怎麼辦呢？</p>
<h2 id="situlation-Creating-a-personal-access-token-建立個人訪問令牌"><a href="#situlation-Creating-a-personal-access-token-建立個人訪問令牌" class="headerlink" title="situlation : Creating a personal access token (建立個人訪問令牌)"></a>situlation : Creating a personal access token (建立個人訪問令牌)</h2><p>透過此方式，就可以回復到像其他教學文章、或你之前的使用體驗一樣，只需要 <code>git push</code> 就可以成功放到 github 了！</p>
<h3 id="Step-1-先從-Github-拿到-access-token"><a href="#Step-1-先從-Github-拿到-access-token" class="headerlink" title="Step 1: 先從 Github 拿到 access token"></a>Step 1: 先從 Github 拿到 access token</h3><p>先去 github 找出設定後並點擊，先點右上角的頭像，之後點下方 Setting<br><img src="/images/git_login_repeat/1.PNG" alt=""></p>
<p>接下來點擊 Developer settings<br><img src="/images/git_login_repeat/2.PNG" alt=""></p>
<p>點擊 Personal access token<br><img src="/images/git_login_repeat/3.PNG" alt=""></p>
<p>點擊 Generate new token，之後輸入密碼<br><img src="/images/git_login_repeat/4.PNG" alt=""></p>
<p>有打藍色勾勾的，都要勾起來，之後點擊 Generate token<br><img src="/images/git_login_repeat/5.PNG" alt=""></p>
<p>之後會看到一組 token，複製此 token<br><img src="/images/git_login_repeat/6.PNG" alt=""></p>
<h2 id="Step-2-將此-token-套用在我們電腦中的-git"><a href="#Step-2-將此-token-套用在我們電腦中的-git" class="headerlink" title="Step 2: 將此 token 套用在我們電腦中的 git"></a>Step 2: 將此 token 套用在我們電腦中的 git</h2><p>這次我們就先使用 <code>git clone https://.../repo.git</code>，來呼叫出我們要不斷登入的畫面，之後只要是 Username 的部分我們就一樣打 Username，另外一個 Password 則是打 <strong>token</strong>，如果需要打兩次是屬於正常，但如果還是一直失敗就要注意可能是哪裡有問題了。</p>
<p>統整一下的話則像這樣子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git clone https:&#x2F;&#x2F;......&#x2F;repo.git</span><br><span class="line">Username: your_username</span><br><span class="line">Password: your_token</span><br></pre></td></tr></table></figure>

<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://docs.github.com/en/free-pro-team@latest/github/authenticating-to-github/creating-a-personal-access-token" target="_blank" rel="noopener">Creating a personal access token</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>此參考連結救了大衞長久以來的問題了QQ，原本是想說只是要登入兩次也不是甚麼太麻煩的事情，但到了最近卻發現登入兩次也沒辦法拯救此問題，實在是忍不了，就上網爬文求 solution，不過不要學我拉，我是不好示範，我等到我受不了才去找問題，通常只要有一些小毛病就要去解決，不要拖。</p>
<p><strong>拖只會讓問題越來越嚴重</strong>，所以要盡早解決，不要變成大病了才來重視他，有點為時已晚。</p>
<p>不過我又學了好多知識，好開心喔&gt;&lt;</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL Boolean 資料類別</title>
    <url>/2020/11/30/MySQL/MySQL_boolean/</url>
    <content><![CDATA[<h2 id="內容說明"><a href="#內容說明" class="headerlink" title="內容說明"></a>內容說明</h2><blockquote>
<p>簡單紀錄在 MySQL 新增 Boolean 型態的 column(欄位)，會突然變成 tinyint</p>
</blockquote>
<a id="more"></a>

<h2 id="MySQL-Boolean-資料類別簡單介紹："><a href="#MySQL-Boolean-資料類別簡單介紹：" class="headerlink" title="MySQL Boolean 資料類別簡單介紹："></a>MySQL Boolean 資料類別簡單介紹：</h2><p>因為 MySQL 並沒有內建 Boolean 類別，為了更方便的使用，於是他使用了 TINYINT(1) - 只能存放 0 與 1 數字的資料型態，通常 0 表示 FALSE、1 表示 TRUE。</p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://www.yiibai.com/mysql/boolean.html" target="_blank" rel="noopener">MySQL boolean类型</a><br><a href="https://stackoverflow.com/questions/7156147/inserting-boolean-value-into-mysql-with-python" target="_blank" rel="noopener">Inserting boolean value into MySQL with Python</a></p>
<h2 id="心得："><a href="#心得：" class="headerlink" title="心得："></a>心得：</h2><p>學了一課，我對於 MySQL 原本一點認識都沒有，透過這幾天的自學，慢慢學到了許多東西，MySQL 真的是太贊了，也要謝謝各位願意將技術文章放在網路上才能夠讓我學習。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 套件中 Pymysql 的 fetchone() 與 fetchall() 差別</title>
    <url>/2020/11/30/Python/Python_Pymysql_fetchone_fetchall/</url>
    <content><![CDATA[<h2 id="內容說明"><a href="#內容說明" class="headerlink" title="內容說明"></a>內容說明</h2><blockquote>
<p>簡單介紹 Python 套件中 Pymysql 的 fetchone() 與 fetchall() 差別</p>
</blockquote>
<a id="more"></a>

<h2 id="fetchone"><a href="#fetchone" class="headerlink" title="fetchone():"></a>fetchone():</h2><p>回傳 Python 呼叫 MySQL 指令的<strong>一條</strong>紀錄(row)，如果沒有回傳值則返回 <code>None</code></p>
<h2 id="fetchall"><a href="#fetchall" class="headerlink" title="fetchall()"></a>fetchall()</h2><p>回傳 Python 呼叫 MySQL 指令的<strong>多條</strong>紀錄(row)，如果沒有則回傳 <code>()</code></p>
<h2 id="兩者差異"><a href="#兩者差異" class="headerlink" title="兩者差異"></a>兩者差異</h2><p>稍微看得出來差異吧XD，<code>fetchone()</code> 回傳一條紀錄，於是如果回傳超過一條紀錄時，只會回傳<strong>第一條</strong>紀錄，且是<strong>一維 tuple</strong></p>
<p><code>fetchall()</code> 如果只有回傳一條紀錄時一樣是傳回 <strong>二維 tuple</strong>。</p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://blog.csdn.net/u014234260/article/details/79581041" target="_blank" rel="noopener">【Python】fetchone()和fetchall()</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>學起來了，學起來了，學習這些知識使我在未來想要實踐自己的程式能力時，可以更好發揮。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 停止在 windows 上的服務</title>
    <url>/2020/11/30/MySQL/MySQL_stop_windows_server/</url>
    <content><![CDATA[<h2 id="內容說明"><a href="#內容說明" class="headerlink" title="內容說明"></a>內容說明</h2><blockquote>
<p>有時候 MySQL 可能會出點 Bug，我們會需要 MySQL 先關閉再開啟，來解決遇到 Bug 或卡頓的問題，對不起，我就懶，想要暴力解。</p>
<p>這篇只適用 windows，其他作業系統不適合QQ。</p>
</blockquote>
<a id="more"></a>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="找到-services-msc-並關閉-MySQL"><a href="#找到-services-msc-並關閉-MySQL" class="headerlink" title="找到 services.msc 並關閉 MySQL"></a>找到 services.msc 並關閉 MySQL</h3><p>在搜尋框內輸入 services.msc，並且點擊那圖是有<strong>齒輪</strong>的唯一搜尋資料。</p>
<blockquote>
<p><img src="/images/MySQL_stop_windows_server/1.PNG" alt=""></p>
</blockquote>
<p>之後點開後畫面則像這樣</p>
<blockquote>
<p><img src="/images/MySQL_stop_windows_server/2.PNG" alt=""></p>
</blockquote>
<h3 id="開啟-services-ms"><a href="#開啟-services-ms" class="headerlink" title="開啟 services.ms"></a>開啟 services.ms</h3><p>找到 MySQL，通常是 MySQLXX，XX 為版本</p>
<blockquote>
<p><img src="/images/MySQL_stop_windows_server/3.PNG" alt=""></p>
</blockquote>
<p>並對她按右鍵後，點擊停止就立即停止 MySQL 服務。</p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://stackoverflow.com/questions/10885038/stop-mysql-service-windows" target="_blank" rel="noopener">Stop MySQL service windows</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>這篇參考連結救了我…，嗚嗚，要是沒了他我不知道還要找多久資料…</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 輸出資料至 EXCEL</title>
    <url>/2020/11/30/MySQL/MySQL_Export_Excel/</url>
    <content><![CDATA[<h2 id="內容說明"><a href="#內容說明" class="headerlink" title="內容說明"></a>內容說明</h2><blockquote>
<p>說明如何透過 SQL 語法輸出資料至 EXCEL</p>
</blockquote>
<a id="more"></a>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h2><p>在 MySQL 沒有辦法直接將資料輸出成 Excel 格式，但可以輸出成 csv 之後並透過 Excel 進行打開，範例如下：</p>
<h3 id="不含標題"><a href="#不含標題" class="headerlink" title="不含標題"></a>不含標題</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT ... FROM ... WHERE ... </span><br><span class="line">INTO OUTFILE &#39;file.csv&#39;</span><br><span class="line">FIELDS TERMINATED BY &#39;,&#39;</span><br></pre></td></tr></table></figure>

<h3 id="含標題"><a href="#含標題" class="headerlink" title="含標題"></a>含標題</h3><p>如果需要標題時要怎麼辦呢？自己打，對，我真的沒有開玩笑…，我也很難過，嗚嗚。不過這樣自由度也高拉，其實也不差，範例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT &#39;ColName1&#39;, &#39;ColName2&#39;, &#39;ColName3&#39;</span><br><span class="line">UNION ALL</span><br><span class="line">SELECT ... FROM ... WHERE ... </span><br><span class="line">INTO OUTFILE &#39;file.csv&#39;</span><br><span class="line">FIELDS TERMINATED BY &#39;,&#39;</span><br></pre></td></tr></table></figure>

<h2 id="可能會遇到的問題"><a href="#可能會遇到的問題" class="headerlink" title="可能會遇到的問題"></a>可能會遇到的問題</h2><p>這裡收錄大衛在輸出 MySQL csv 時一些遇到的小錯誤，如果讀者也剛好有此問題剛好能看我文章解決那就再好不過了。<br><a href="https://theriseofdavid.github.io/2020/11/30/MySQL/MySQL_ERROR_1290_(HY000)_secure_file_priv_option/" target="_blank" rel="noopener">MySQL ERROR 1290 (HY000) he MySQL server is running with the –secure-file-priv option so it cannot execute this statement (for windows)</a></p>
<h2 id="參考連結："><a href="#參考連結：" class="headerlink" title="參考連結："></a>參考連結：</h2><p><a href="https://stackoverflow.com/questions/10295228/exporting-results-of-a-mysql-query-to-excel" target="_blank" rel="noopener">Exporting results of a Mysql query to excel?</a><br><a href="https://stackoverflow.com/questions/5941809/include-headers-when-using-select-into-outfile" target="_blank" rel="noopener">Include headers when using SELECT INTO OUTFILE?</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>Stackoverflow 是甚麼網站阿，為甚麼我想要答案都會在哪裡，其他隔壁的農場文章都是負責抄襲此網站，而且水準以及翻譯水平即差，希望 Google 可以將一些垃圾資訊移除，才會方便需要學習的讀者可以查詢到需要的網頁，而不是一直搜尋到品質低劣的網站。</p>
<p>Stackoverflow 你好偉大…，嗚嗚嗚嗚，沒有你的我好爛。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL ERROR 1290 (HY000) he MySQL server is running with the --secure-file-priv option so it cannot execute this statement (for windows)</title>
    <url>/2020/11/30/MySQL/MySQL_ERROR_1290_(HY000)_secure_file_priv_option/</url>
    <content><![CDATA[<h2 id="內容說明"><a href="#內容說明" class="headerlink" title="內容說明"></a>內容說明</h2><blockquote>
<p>當你在寫 MySQL 並輸出檔案時可能會遇到一些問題，這裡提供一種解決方式。</p>
<p>目前只提供 Windows 方案，之後如果 Linux 我也有遇到此問題我則會補上。</p>
</blockquote>
<a id="more"></a>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h2><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>在 MySQL 中檔案輸出是有嚴格的要求，我不確定是甚麼因素導致 MySQL 對於輸出資料庫檔案如此要求，但他要求了，不符合我們的需求，那我們就要來調整至我們的需求瞜XD。</p>
<h3 id="查詢此位置-SECURE-FILE-PRIV"><a href="#查詢此位置-SECURE-FILE-PRIV" class="headerlink" title="查詢此位置 SECURE-FILE-PRIV"></a>查詢此位置 SECURE-FILE-PRIV</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SHOW GLOBAL VARIABLES LIKE &#39;%secure%&#39;;</span><br></pre></td></tr></table></figure>

<p>通常在進行此查詢後，會看到一段路徑，移動到此路徑，以我為範例，我輸出的路徑則是 <code>C:\ProgramData\MySQL\MySQL Server 8.0</code></p>
<p><img src="/images/MySQL_ERROR_1290_(HY000)_secure_file_priv_option/1.PNG" alt=""></p>
<h3 id="找到-MySQL-Server-X-X-的-my-ini-並修改"><a href="#找到-MySQL-Server-X-X-的-my-ini-並修改" class="headerlink" title="找到 MySQL Server X.X 的 my.ini 並修改"></a>找到 MySQL Server X.X 的 my.ini 並修改</h3><p>由於問題是 secure-file-priv 此參數設定我們輸出的檔案只能在他規定的路徑下，於是我們要修改他的路徑，要如何修改呢，首先就是要先找到 <code>my.ini</code>，通常位置如果沒有被改變，應該是預設在 <code>C:\ProgramData\MySQL\MySQL Server 8.0</code></p>
<p>找到  secure-file-priv 並修改值為 <code>&quot;&quot;</code>，當值被設定為<code>&quot;&quot;</code>時表示不監控檔案輸出路徑，即你想輸出在哪個位置都可以。<br><img src="/images/MySQL_ERROR_1290_(HY000)_secure_file_priv_option/2.PNG" alt=""></p>
<h3 id="重開-MySQL-server"><a href="#重開-MySQL-server" class="headerlink" title="重開 MySQL server"></a>重開 MySQL server</h3><p>注意，並不是只將 MySQL Workbench 關掉重開即可，要<strong>完整關掉</strong>。</p>
<p>詳細步驟可以看此連結 <a href="https://theriseofdavid.github.io/2020/11/30/MySQL/MySQL_stop_windows_server/" target="_blank" rel="noopener">MySQL 停止在 windows 上的服務</a></p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://stackoverflow.com/questions/34102562/mysql-error-1290-hy000-secure-file-priv-option" target="_blank" rel="noopener">MySQL ERROR 1290 (HY000) –secure-file-priv option</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>Stackoverflow 是甚麼網站阿，為甚麼我想要答案都會在哪裡，其他隔壁的農場文章都是負責抄襲此網站，而且水準以及翻譯水平即差，希望 Google 可以將一些垃圾資訊移除，才會方便需要學習的讀者可以查詢到需要的網頁，而不是一直搜尋到品質低劣的網站。</p>
<p>Stackoverflow 你好偉大…，嗚嗚嗚嗚，沒有你的我好爛。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>資料庫管理 筆記 - 大二上期中考</title>
    <url>/2020/12/01/NTUT_note/database_1/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊與財金管理系大二上資料庫管理學重點整理<br><font color="#dd0000">並非所有人都適用，部分對我而言稍加容易的內容並不會寫在此內。</font></p>
</blockquote>
<a id="more"></a>

<h1 id="資料庫管理期中考"><a href="#資料庫管理期中考" class="headerlink" title="資料庫管理期中考"></a>資料庫管理期中考</h1><h2 id="老師說得必考"><a href="#老師說得必考" class="headerlink" title="老師說得必考"></a>老師說得必考</h2><ul>
<li>非主鍵的外來鍵(Foreign key) 畫虛線</li>
<li>外來鍵用其他表的主鍵表示兩表格的關係</li>
<li>候選鍵一定要有值，非候選鍵不一定有值</li>
<li>主鍵是從候選鍵挑出來的<h3 id="determinant-行列式-and-Candidate-key-候選鍵"><a href="#determinant-行列式-and-Candidate-key-候選鍵" class="headerlink" title="determinant(行列式) and Candidate key(候選鍵)"></a>determinant(行列式) and Candidate key(候選鍵)</h3>可以識別一筆row的資料，但若為複合鍵的情況下，Candidate key的所有屬性都不能是多餘的(redundancy)，也就是不能有屬性是刪除後對於Candidate key識別一筆row資料沒有影響；Candidate key 一定是 Determinant，但Determinant不一定是Candidate key。<h3 id="問你主鍵-Primary-Keys-是什麼-參考限制條件"><a href="#問你主鍵-Primary-Keys-是什麼-參考限制條件" class="headerlink" title="問你主鍵(Primary Keys)是什麼 參考限制條件"></a>問你主鍵(Primary Keys)是什麼 參考限制條件</h3></li>
<li>一定要畫<strong>實線</strong></li>
<li>不可有空值(Not Null)</li>
<li>永遠不會改變(Never Change)</li>
<li>非識別值(Nonidentifying Value)<br>即「值」本身沒有意義。例如買電子產品都會有一個「序號」，假設第一碼代表供應商麼，第二碼代表所在地區(台北、台中…)，有一天供應商搬家了，從台北搬到台中，那第二碼就不會符合現況。</li>
<li>主鍵是關係的唯一標識符。 示例包括員工編號，社會保險號等。這可以確保所有行都是唯一的。</li>
<li>Primary keys are unique identifiers of the relation. Examples include employee numbers, social security numbers, etc. This guarantees that all rows are unique.</li>
</ul>
<h4 id="Domain-Constraints-域約束"><a href="#Domain-Constraints-域約束" class="headerlink" title="Domain Constraints 域約束"></a>Domain Constraints 域約束</h4><ul>
<li>Allowable values for an attribute (includes data types and restrictions on values)</li>
<li>屬性的允許值（包括數據類型和值限制）</li>
</ul>
<h4 id="Entity-Integrity-實體完整性"><a href="#Entity-Integrity-實體完整性" class="headerlink" title="Entity Integrity 實體完整性"></a>Entity Integrity 實體完整性</h4><ul>
<li>No primary key attribute may be null. All primary key fields MUST contain data values.</li>
<li>主鍵屬性不能為空。 所有主鍵字段必須包含數據值。</li>
</ul>
<h4 id="Referential-Integrity-參照完整性"><a href="#Referential-Integrity-參照完整性" class="headerlink" title="Referential Integrity 參照完整性"></a>Referential Integrity 參照完整性</h4><ul>
<li>Rules that maintain consistency between the rows of two related tables.</li>
<li>維護兩個相關表的行之間一致性的規則。</li>
</ul>
<h3 id="資料正規化-3個異常-4-38-4-39"><a href="#資料正規化-3個異常-4-38-4-39" class="headerlink" title="資料正規化 3個異常 4-38 4-39"></a>資料正規化 3個異常 4-38 4-39</h3><p><img src="https://i.imgur.com/pQz0S5h.png" alt=""></p>
<h4 id="Insertion"><a href="#Insertion" class="headerlink" title="Insertion"></a>Insertion</h4><ul>
<li>can’t enter a new employee without having the employee take a class (or at least empty fields of class information)</li>
<li>在沒有讓員工參加課程的情況下（或至少在課程信息的空白字段中）不能輸入新員工</li>
</ul>
<h4 id="Deletion"><a href="#Deletion" class="headerlink" title="Deletion"></a>Deletion</h4><ul>
<li>if we remove employee 140, we lose information about the existence of a Tax Acc class</li>
<li>如果我們刪除員工140，我們將丟失有關Tax Acc類的信息</li>
</ul>
<h4 id="Modification"><a href="#Modification" class="headerlink" title="Modification"></a>Modification</h4><ul>
<li>giving a salary increase to employee 100 forces us to update multiple records</li>
<li>給員工100加薪迫使我們更新多個記錄</li>
</ul>
<h2 id="資料正規化"><a href="#資料正規化" class="headerlink" title="資料正規化"></a>資料正規化</h2><h3 id="1NF"><a href="#1NF" class="headerlink" title="1NF"></a>1NF</h3><ul>
<li>是指在資料表中的所有記錄之屬性內含值都是基元值(Atomic Value)。<br>基元值(Atomic Value) = 亦即無重覆項目群</li>
<li>沒有任何兩筆以上的資料是完全重覆</li>
<li>資料表中有主鍵, 而其他所有的欄位都相依於「主鍵」。<h3 id="2NF"><a href="#2NF" class="headerlink" title="2NF"></a>2NF</h3><a href="https://hackmd.io/DafKP08ARwKBz-78gBSFYQ#%E8%B3%87%E6%96%99%E6%AD%A3%E8%A6%8F%E5%8C%96-3%E5%80%8B%E7%95%B0%E5%B8%B8-4-38-4-39" target="_blank" rel="noopener">看這裡就可以</a><h3 id="3NF"><a href="#3NF" class="headerlink" title="3NF"></a>3NF</h3>各欄位與「主鍵」之間沒有「遞移相依」的關係。</li>
<li>遞移相依<br>A 跟 B 有關係，B 跟 C 有關係，則 A 跟 C 就是<strong>遞移相依</strong><h3 id="實務範例"><a href="#實務範例" class="headerlink" title="實務範例"></a>實務範例</h3><img src="https://i.imgur.com/YLLLT5T.png" alt=""></li>
</ul>
<h2 id="資料來源"><a href="#資料來源" class="headerlink" title="資料來源"></a>資料來源</h2><p><a href="https://blog.kkbruce.net/2010/10/normalization-key.html#.X7qQVM0zaUl" target="_blank" rel="noopener">關聯資料表正規化(NORMALIZATION)–鍵,KEY</a><br><a href="https://answers.sap.com/questions/2689632/key-and-non-key-fields.html" target="_blank" rel="noopener">Key and Non-Key Fields</a><br><a href="http://abbydoubleb.blogspot.com/2014/10/1031-chapter-4-database-design.html" target="_blank" rel="noopener">1031 - 資料庫管理概論 Chapter 4 Database design</a><br><a href="http://cc.cust.edu.tw/~ccchen/doc/db_04.pdf" target="_blank" rel="noopener">資料庫正規化</a></p>
]]></content>
      <categories>
        <category>北科上課筆記</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>資料庫管理</tag>
      </tags>
  </entry>
  <entry>
    <title>投資學 筆記 - 股票交易制度</title>
    <url>/2020/12/01/NTUT_note/investment_stock_trading_system/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊與財金管理系大二上投資學重點整理<br><font color="#dd0000">並非所有人都適用，部分對我而言稍加容易的內容並不會寫在此內。</font><br>本章主要內容</p>
<ul>
<li>上市櫃股票交易流程</li>
<li>上市櫃股票交易成本</li>
<li>上市櫃股價漲跌幅與檔次</li>
<li>上市櫃股票信用交易</li>
<li>上市櫃股票鉅額交易與零股交易</li>
<li>興櫃股票交易制度</li>
</ul>
</blockquote>
<a id="more"></a>

<h2 id="基本觀念"><a href="#基本觀念" class="headerlink" title="基本觀念"></a>基本觀念</h2><p>台灣的股票交易採用兩層式架構，股票交易人將買或賣的委託單交由證券經紀商，輸入證交所或櫃買中心的交易系統中，進行撮合交易。</p>
<ul>
<li>2020 年 3 月 23 日 開始進行盤中逐筆交易</li>
<li>2020 年 10 月 26 日 盤中集合競價</li>
</ul>
<h3 id="股票交易程序"><a href="#股票交易程序" class="headerlink" title="股票交易程序"></a>股票交易程序</h3><ul>
<li>投資人需要開立三個帳戶 <ul>
<li>有價證券受託買賣帳戶 (交易帳戶)</li>
<li>證券集中保管帳戶 (證券存摺)</li>
<li>款券劃撥帳戶 (銀行活期存款存摺)</li>
</ul>
</li>
<li>開戶<br>個人需帶身分證、第二證件與印章至證券經紀商營業處，法人則須被授權人辦理，帶法人證件等、公司印鑑、被授權人身分證影本。</li>
<li>委託<ul>
<li>時間<br>委託時間在 8:30(開盤) ~ 13:30(收盤)，可進行交易，14:00 ~ 14:30(收盤)則可以根據收盤價進行交易，且盤後交易不可超過 499 單位</li>
<li>有效時間<br>可以在還沒成交前，取消委託，委託只限當日有效，到隔天則須重新委託。</li>
</ul>
</li>
<li>結算 (三種方式結算) <ul>
<li>公式<br>結算公式： \(結算 = 券的交割 + 結清款項\)</li>
<li>當日交割<br>必須當日完成，鉅額買賣為超過 500 交易單位</li>
<li>普通交易交割<br>成交日後的第二天(營業日)辦理交割，通常使用此方式。</li>
<li>違約交割<br>沒有在成交日後的第二天(營業日)辦理交割，違約，三年內不可再開戶與委託買賣。</li>
</ul>
</li>
<li>股票保管<ul>
<li>線上管理，都放在<strong>證券存摺</strong></li>
</ul>
</li>
</ul>
<h2 id="集合競價與逐筆競價制度"><a href="#集合競價與逐筆競價制度" class="headerlink" title="集合競價與逐筆競價制度"></a>集合競價與逐筆競價制度</h2><p>8:30-9:00(開盤前)、13:25-13:30(開盤即將結束)為集合競價，9:00-13:25 則採用逐筆競價</p>
<h3 id="集合競價"><a href="#集合競價" class="headerlink" title="集合競價"></a>集合競價</h3><p>買入累計與賣出累計為全部價位中的最大值，則此價位為成交價。<br>P.S. 買方必須都先 -100，圖片有問題</p>
<blockquote>
<p><img src="/images/investment_stock_trading_system/1.PNG" alt=""></p>
</blockquote>
<ul>
<li>只能下限價單，低於此價位就不賣出。(以賣出為例)</li>
</ul>
<h3 id="逐筆競價"><a href="#逐筆競價" class="headerlink" title="逐筆競價"></a>逐筆競價</h3><p>看圖說明即可，注意：如果有比你低的價位可買入，則優先買入</p>
<blockquote>
<p><img src="/images/investment_stock_trading_system/2.PNG" alt=""></p>
</blockquote>
<ul>
<li>可以下市價單、立即成交取消、全部成交或取消的委託單</li>
<li>限價委託<br>以買入為例，限價 50 表示在成交價 50 以下(含)才買入。</li>
<li>市價單<br>根據市場成交價買賣。</li>
</ul>
<h2 id="股票交易成本"><a href="#股票交易成本" class="headerlink" title="股票交易成本"></a>股票交易成本</h2><ul>
<li>手續費<br>股票、ETF、基金，證券商自訂，憑證上限為 0.1425%</li>
<li>證券交易稅<br>3%，完全不可變動。</li>
</ul>
<h2 id="股票信用交易"><a href="#股票信用交易" class="headerlink" title="股票信用交易"></a>股票信用交易</h2><p>期限通常為一年，最多可延兩次半年</p>
<h3 id="融資"><a href="#融資" class="headerlink" title="融資"></a>融資</h3><p>投資人以部分自備款擔保，向證券商購買股票</p>
<ul>
<li>融資對象<ul>
<li>20歲以上國民</li>
<li>開立買賣帳戶 3 個月以上</li>
<li>近一年委託買賣達 10 筆，融資額度只能到累積成交金額 50%。</li>
<li>融資額度為所得與全部財產的 30%。<h3 id="融券"><a href="#融券" class="headerlink" title="融券"></a>融券</h3>手上沒有股票但先賣股票，此時我們則欠證券商股票，必須在規定期限內買入股票歸還。</li>
</ul>
</li>
</ul>
<h3 id="融資融券的證券"><a href="#融資融券的證券" class="headerlink" title="融資融券的證券"></a>融資融券的證券</h3><ul>
<li>股票<br>上市櫃 6 個月且每股淨值都在票面之上的普通股股票。</li>
<li>台灣存託憑證<br>上市櫃滿六個月，且無累積虧損</li>
<li>受益憑證<br>上市須滿六個月，但 ETF 除外。</li>
<li><strong>股價波動劇烈、成交量異常、股權或受益權集中都不可融資融券</strong></li>
<li><strong>零股買賣、鉅額買賣不可融資融券</strong></li>
</ul>
<h4 id="規定事項"><a href="#規定事項" class="headerlink" title="規定事項"></a>規定事項</h4><blockquote>
<p><img src="/images/investment_stock_trading_system/3.PNG" alt=""></p>
</blockquote>
<h4 id="擔保維持率"><a href="#擔保維持率" class="headerlink" title="擔保維持率"></a>擔保維持率</h4><p>必須要維持<strong>擔保維持率</strong>，如果低於一定比率(2019 為 130%)，則委託人必須先補繳融資自備款達到比例，且期限為兩天，若沒達成條件則處分擔保品(俗稱斷頭)。<br>擔保維持率公式： \(\frac{融資擔保品市值+原融券擔保品及保証金}{原融資金額+融券標的証券市價}\)</p>
<h4 id="範例"><a href="#範例" class="headerlink" title="範例"></a>範例</h4><blockquote>
<p><img src="/images/investment_stock_trading_system/4.PNG" alt=""><br><img src="/images/investment_stock_trading_system/5.PNG" alt=""></p>
</blockquote>
<h4 id="暫停融資融券"><a href="#暫停融資融券" class="headerlink" title="暫停融資融券"></a>暫停融資融券</h4><ul>
<li>發行公司停止過戶日前五個營業日，停止融資買進三天</li>
<li>聽止過戶日前七個營業日，停止融券賣出五天</li>
</ul>
<blockquote>
<p><img src="/images/investment_stock_trading_system/6.PNG" alt=""></p>
</blockquote>
<h3 id="當日沖銷-當沖"><a href="#當日沖銷-當沖" class="headerlink" title="當日沖銷 (當沖)"></a>當日沖銷 (當沖)</h3><p>指投資人當天融資買入又融券賣出相同的股票，以兩者相抵後的餘額交割。</p>
<h4 id="範例-1"><a href="#範例-1" class="headerlink" title="範例"></a>範例</h4><blockquote>
<p><img src="/images/investment_stock_trading_system/7.PNG" alt=""></p>
</blockquote>
<h2 id="標借、議借與標購"><a href="#標借、議借與標購" class="headerlink" title="標借、議借與標購"></a>標借、議借與標購</h2><p>當某股票的融券數量超過證券金融公司的可融券數量時則會發生<strong>融券券源不足</strong>，可以向證交所貨櫃買中心申請，在網站上公告向投資人借股票，並由證券金融公司支付費用。</p>
<p>程序如下：</p>
<ol>
<li>先辦理<strong>標借</strong></li>
<li>券源不足，可<strong>議借</strong></li>
<li>還是不足，可<strong>標購</strong></li>
</ol>
<h3 id="標借"><a href="#標借" class="headerlink" title="標借"></a>標借</h3><ul>
<li>時間<br>8:30 開始公告<strong>標借</strong>證券，8:30-12:10 接受投標，12:30 電腦自動投標</li>
<li>價格<ul>
<li><strong>標借</strong>價格不超過融券差額發生日的收盤價或參考價的 7%。</li>
<li>開標按當日決標之借券費率，由低而高依序取借</li>
<li>當數量大過於需要的標借數量時按照輸入時間順序標借</li>
</ul>
</li>
</ul>
<h3 id="議借"><a href="#議借" class="headerlink" title="議借"></a>議借</h3><p>如果<strong>標借</strong>後仍有券源不足，可在 14:00 前<strong>議借</strong>，議借差額不可大於收盤價 10%</p>
<h3 id="標購"><a href="#標購" class="headerlink" title="標購"></a>標購</h3><p>如果<strong>議借</strong>後仍有券源不足，則在 14:30 委託證交所標購，差額不可大於 15%</p>
<h2 id="上市櫃股票鉅額交易與零股交易"><a href="#上市櫃股票鉅額交易與零股交易" class="headerlink" title="上市櫃股票鉅額交易與零股交易"></a>上市櫃股票鉅額交易與零股交易</h2><h3 id="鉅額交易"><a href="#鉅額交易" class="headerlink" title="鉅額交易"></a>鉅額交易</h3><ul>
<li>單一證券交易超過 500 個</li>
<li>單一證券交易超過 1500 萬</li>
<li>五種股票以上，總金額大於 1500 萬</li>
</ul>
<h4 id="交易方式"><a href="#交易方式" class="headerlink" title="交易方式"></a>交易方式</h4><ul>
<li>逐筆交易<br>採取撮合成交，採 T+2 日交割，申報時間為周一至周五 9:00-17:00</li>
<li>配對交易<br>採撮合成交，<strong>可以指定對象</strong>，採 T+2 日交割，申報時間為周一至周五 8:00-8:30 and 9:00-17:00</li>
</ul>
<h3 id="零股交易"><a href="#零股交易" class="headerlink" title="零股交易"></a>零股交易</h3><ul>
<li>不滿一個成交單位，即不滿 1000 股</li>
<li>盤中可以交易，且每三分鐘撮合一次</li>
<li>不可融資融券</li>
<li>圖表<blockquote>
<p><img src="/images/investment_stock_trading_system/8.PNG" alt=""></p>
</blockquote>
</li>
</ul>
<h3 id="定期定額買股票與自行買零股差異"><a href="#定期定額買股票與自行買零股差異" class="headerlink" title="定期定額買股票與自行買零股差異"></a>定期定額買股票與自行買零股差異</h3><ul>
<li>定期定額只需要設定一次之後就自動扣款，幫助投資人有紀律的投資</li>
<li>成交機率較高，券商可以匯總所有客戶款項再根據實際成交價、委託申購股數比例來進行分配</li>
</ul>
<h2 id="興櫃股票交易制"><a href="#興櫃股票交易制" class="headerlink" title="興櫃股票交易制"></a>興櫃股票交易制</h2><p><strong>未上市市櫃的股票也可以進行交易</strong>，台灣要上市上櫃的股票都必須要先在興櫃市場掛牌交易六個月以上，興櫃市場交易制度則是投資人透過交易系統與證券商進行議價交易。</p>
<h3 id="興櫃股票成交方式"><a href="#興櫃股票成交方式" class="headerlink" title="興櫃股票成交方式"></a>興櫃股票成交方式</h3><ul>
<li>到價委託單<br>\(投資人買價 \geq 證券商報賣價 \)，反之亦同，以價格優先，根據時間優先分配給推薦證券商成交</li>
<li>未到價委託單<br>\(投資人委託買價 &lt; 推薦證券商賣價 \)，證券商沒有成交義務，但可以點選成交 </li>
</ul>
]]></content>
      <categories>
        <category>北科上課筆記</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>北科大二上投資學筆記</tag>
        <tag>北科大大二上投資學期中考筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>投資學 筆記 - 股票資產組合管理基礎篇(報酬與風險)</title>
    <url>/2020/12/02/NTUT_note/investment-stock-Asset-Portfolio-Management-Basic/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊與財金管理系大二上投資學重點整理<br><font color="#dd0000">並非所有人都適用，部分對我而言稍加容易的內容並不會寫在此內。</font><br>本章主要內容</p>
<ul>
<li>量化金融資產用預期報酬與風險</li>
<li>了解預期報酬與風險</li>
<li>透過過去歷史資料計算每種資產預期報酬率</li>
</ul>
</blockquote>
<a id="more"></a>

<h2 id="名目利率與實質利率和報酬率"><a href="#名目利率與實質利率和報酬率" class="headerlink" title="名目利率與實質利率和報酬率"></a>名目利率與實質利率和報酬率</h2><h3 id="實質利率"><a href="#實質利率" class="headerlink" title="實質利率"></a>實質利率</h3><p>每借 1 元，一年所要付出的代價，反之亦同。</p>
<p>\(實際利率 \approx 名目利率 - 通貨膨脹率 \)</p>
<h3 id="名目利率"><a href="#名目利率" class="headerlink" title="名目利率"></a>名目利率</h3><p>名目利率會隨著預期通貨膨脹率同步增加，公式則是 \(rn = rr + E(i) \)。</p>
<ul>
<li>\(rn\) 名目年利率</li>
<li>\(rr\) 實際年利率</li>
<li>\(E(i)\) 下一期通貨膨脹率的預測</li>
</ul>
<h3 id="報酬率"><a href="#報酬率" class="headerlink" title="報酬率"></a>報酬率</h3><p>\(預期報酬率 = 無風險利率 + 承擔通貨膨脹風險\)，換句換說則表示 \(金融資產的預期報酬 = 無風險利率+各種可能風險之溢酬\)</p>
<h2 id="金融資產可能的風險溢酬"><a href="#金融資產可能的風險溢酬" class="headerlink" title="金融資產可能的風險溢酬"></a>金融資產可能的風險溢酬</h2><ul>
<li>物價膨脹風險溢酬</li>
<li>信用與違約風險溢酬</li>
<li>變現性風險溢酬</li>
<li>到期日風險溢酬</li>
</ul>
<h3 id="預期報酬與實際報酬"><a href="#預期報酬與實際報酬" class="headerlink" title="預期報酬與實際報酬"></a>預期報酬與實際報酬</h3><ul>
<li>無風險利率<br>將資金投資於短期政府國庫券、銀行存款能賺取的報酬率</li>
<li>風險溢酬<br>股票風險與無風險利率的差距，則稱為股票的風險溢酬</li>
<li>超額報酬<br>風險性資產的實際報酬高於國庫券利率水準的為超額報酬，超額報酬的標準差很合適做為<strong>風險衡量值</strong></li>
</ul>
<h3 id="金融資產的預期報酬率與風險"><a href="#金融資產的預期報酬率與風險" class="headerlink" title="金融資產的預期報酬率與風險"></a>金融資產的預期報酬率與風險</h3><p>持有期間報酬 (HPR) 為\(HPR = \frac{期末股價-期初股價+現金股利}{期初股價}\)</p>
<h4 id="報酬的機率分配"><a href="#報酬的機率分配" class="headerlink" title="報酬的機率分配"></a>報酬的機率分配</h4><p>設第 s 種情境的持有期間報酬 \(r(s)\)<br>第 s 種情境的發生機率 \(p(s)\)</p>
<ul>
<li>預期報酬為機率分配的期望值<br>\(E(r) =\Sigma p(s)r(s)  \)</li>
<li>風險為機率分配的標準差(變異數取平方根)<br>\(\sigma^2 = \Sigma p(x)[r(s)-E(r)]^2\)<h5 id="例題"><a href="#例題" class="headerlink" title="例題"></a>例題</h5><blockquote>
<p><img src="/images/investment-stock-Asset-Portfolio-Management-Basic/1.PNG" alt=""><br><img src="/images/investment-stock-Asset-Portfolio-Management-Basic/2.PNG" alt=""></p>
</blockquote>
</li>
</ul>
<h2 id="預期報酬與風險的估計"><a href="#預期報酬與風險的估計" class="headerlink" title="預期報酬與風險的估計"></a>預期報酬與風險的估計</h2><p>資產報酬的真實分配可視為母體，一般會用樣本資料推估，使用過去的歷史資料作為樣本來推估資產的預期報酬與波動是非常有用的方法之一</p>
<h3 id="樣本平均數"><a href="#樣本平均數" class="headerlink" title="樣本平均數"></a>樣本平均數</h3><p>樣本平均數則表示報酬率分配的期望值，樣本標準差則為報酬率分配的標準差。</p>
<p>先找出一段時間的每一期(如每天、每月或每年)的期間實際報酬率計算，再做為樣本計算樣本平均數與標準差</p>
<h4 id="樣本平均報酬-共有兩種辦法"><a href="#樣本平均報酬-共有兩種辦法" class="headerlink" title="樣本平均報酬 (共有兩種辦法)"></a>樣本平均報酬 (共有兩種辦法)</h4><ul>
<li>算術平均報酬<br>\(\bar{r_{A}} = \frac{r_1 + r_2 + … + r_n}{n} \)</li>
<li>幾何平均報酬<br>\(\bar{r_G} = \sqrt[n]{(1+r_1) * (1+r_2) * … * (1+r_n) } -1\)</li>
<li>算術與幾何平均報酬比較<ul>
<li>幾何平均報酬以<strong>每期末投資計算複利</strong>收益較精確</li>
<li>算數大於幾何報酬率時，稱為<strong>平均數不等式</strong></li>
<li>\(幾何平均 = 算數平均 - 1/2 \sigma^2\)<h4 id="例題-1"><a href="#例題-1" class="headerlink" title="例題"></a>例題</h4><blockquote>
<p><img src="/images/investment-stock-Asset-Portfolio-Management-Basic/3.PNG" alt=""></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="樣本標準差"><a href="#樣本標準差" class="headerlink" title="樣本標準差"></a>樣本標準差</h3><p>樣本標準差公式為 \(\sigma = \sqrt{\frac{1}{n-1} \sum_{t=1}^{n} (r_t - \bar{r_A})^2 } \)</p>
<h4 id="例題-2"><a href="#例題-2" class="headerlink" title="例題"></a>例題</h4><blockquote>
<p><img src="/images/investment-stock-Asset-Portfolio-Management-Basic/4.PNG" alt=""></p>
</blockquote>
<h2 id="國庫券風險與報酬"><a href="#國庫券風險與報酬" class="headerlink" title="國庫券風險與報酬"></a>國庫券風險與報酬</h2><p>國庫券通常視為最沒有風險的金融資產，但他還是用通貨膨脹的風險。</p>
<h2 id="風險性資產組合的歷史報酬與風險"><a href="#風險性資產組合的歷史報酬與風險" class="headerlink" title="風險性資產組合的歷史報酬與風險"></a>風險性資產組合的歷史報酬與風險</h2><p>只要有投資風險的資產都被稱為風險性資產</p>
<ul>
<li>高帳面市值比則稱為價值型股票組合</li>
<li>低帳面市值比則稱為成長型股票組合</li>
</ul>
<h3 id="名詞解釋"><a href="#名詞解釋" class="headerlink" title="名詞解釋"></a>名詞解釋</h3><ul>
<li>市值<br>\(流通在外股數 * 每股市價 \)</li>
<li>帳面市價比<br>\( 每股帳面價值 / 每股市價 \)</li>
<li>價值型股票<br>股價相對獲利能力被低估的股票</li>
<li>成長型股票<br>股價相對於目前的獲利能力被高估的股票</li>
</ul>
]]></content>
      <categories>
        <category>北科上課筆記</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>北科大二上投資學筆記</tag>
        <tag>北科大大二上投資學期中考筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>投資學 筆記 - 股票資產組合管理資產組合與資本資產定價模型篇</title>
    <url>/2020/12/03/NTUT_note/investment_stock_asset_profolio_and_capital_asset_pricing_model/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊與財金管理系大二上投資學重點整理<br><font color="#dd0000">並非所有人都適用，部分對我而言稍加容易的內容並不會寫在此內。</font><br>本章主要內容</p>
<ul>
<li>資產多元化配置以降低風險</li>
<li>判斷市場均衡時定出資本資產定價模型，並判定個別資產是否有被高估或低估</li>
</ul>
</blockquote>
<a id="more"></a>

<h2 id="資金配置於風險及無風險兩個組合"><a href="#資金配置於風險及無風險兩個組合" class="headerlink" title="資金配置於風險及無風險兩個組合"></a>資金配置於風險及無風險兩個組合</h2><p>資金配置是指將資金配置到數種不同的資產類別，</p>
<h3 id="無風險資產"><a href="#無風險資產" class="headerlink" title="無風險資產"></a>無風險資產</h3><p><strong>真正的無風險資產可以對抗違約風險、利率風險、通貨膨脹風險的金融資產</strong>，實務上通常將國庫券視為無風險資產，但實務上一般投資人將定存單(CD)、商業本票(CP)或貨幣市場基金視為無風險資產，但因為是短期工具，因此對利率與通貨膨脹反映比較有限。</p>
<p>相較於國庫券，CP 與 CD 的殖利率較高，但發生金融動盪時，實際上與國庫券的殖利率差也會突然暴增。</p>
<p>通常在大型事件發生時，大部份投資人會轉向無風險資產，如第一次石油危機、股市崩盤。</p>
<h3 id="單一風險資產與單一無風險資產組合"><a href="#單一風險資產與單一無風險資產組合" class="headerlink" title="單一風險資產與單一無風險資產組合"></a>單一風險資產與單一無風險資產組合</h3><h4 id="名詞定義"><a href="#名詞定義" class="headerlink" title="名詞定義"></a>名詞定義</h4><ul>
<li>\(C=P+F\)，C = 財富金額、P = 投資於風險資產、F = 投資無風險資產，<del>廢話</del>。</li>
<li>\(r = 報酬 \) </li>
<li>風險資產 P 的預期報酬與風險以 \(E(r_p)\)及 \(\sigma_p\)表示</li>
<li>\(y = 無風險資產 \)、 \( 1-y = 風險資產 \)</li>
</ul>
<h3 id="舉例找出資產組合的資本配置線-CAL-："><a href="#舉例找出資產組合的資本配置線-CAL-：" class="headerlink" title="舉例找出資產組合的資本配置線 (CAL)："></a>舉例找出資產組合的資本配置線 (CAL)：</h3><p><del>這次沒有圖片拉，大衛用手打的</del></p>
<p>有下列兩種風險資產 p and f :</p>
<p>如果  \(E(r_p) = 15\%\)、\(\sigma_p = 22\%\)，且 \(E(r_p)-r_f = 7 \% \) 則完整組合的報酬率與風險分別為：<br>\(E(r_c) = y * 15\% + (1-y) * 7\% \)<br>\(\sigma_c^2 = Var(r_c) = Var(y* r_p + (1-y) * r_F) = y^2 \sigma_{P}^2 = y * \sigma_P = y * 22 \%  \)</p>
<p>將資產組合預期報酬率作為縱軸、標準差做為橫軸並將 y=0 and y=1 的兩個座標連起來則可以得到資本配置線 (CAL)</p>
<blockquote>
<p><img src="/images/investment_stock_asset_profolio_and_capital_asset_pricing_model/24.PNG" alt=""></p>
</blockquote>
<h3 id="資本配置線"><a href="#資本配置線" class="headerlink" title="資本配置線"></a>資本配置線</h3><p>當資本配置線的 y(標準差)，介於 0 與 1 之間時表示投資人資金分配在兩種不同資產；但相對投資人如果<strong>不分配無風險資產且借入資金購買風險資產</strong>則表示 \(y &gt; 1\)，也就是投資人不止將全部的資金都投資在風險資產上，同時還用無風險利率借入資金投資風險資產</p>
<blockquote>
<p><img src="/images/investment_stock_asset_profolio_and_capital_asset_pricing_model/25.PNG" alt=""></p>
</blockquote>
<p>根據前面的例題配合上方圖片的 y = 140% 時，投資人完整組合的預期報酬率與風險如下：\(E(r_C)=7\% + y * (15\% - 7\%) = 7\% + 140\% * (15\% - 7\%) = 18.2\% \)<br>\(\sigma_C = y * 22\% = 140\% * 22\% = 30.8\% \)</p>
<h4 id="CAL-的方程式"><a href="#CAL-的方程式" class="headerlink" title="CAL 的方程式"></a>CAL 的方程式</h4><p>透過點斜式計算方程式，透過 F 或 P 其中一點找出該直線的斜率，斜率的計算方式則是 \(\frac{E(r_P)-r_F}{\sigma_P}\)，此斜率的意義為：平均每一一單位風險所要求的風險溢酬，也就是後面提到的<a href="#Sharpe_ratio_找出兩個風險資產最適配置">Sharpe_ratio</a>因此該直線的方程式為 \(E(r_C) = r_F+\frac{E(r_P)-r_F}{\sigma_P} * \sigma_C = r_F + \frac{\sigma_C}{\sigma_P} * [E(r_P)-r_F ]\)</p>
<ul>
<li>實務上通常借款利率會比無風險利率高，<del>不然就不會有人借你</del>，此時 CAL 會有所變化，不再是原本的一直線，因為會變成報酬利率減去借款利率，用圖來說明，假設 \(r_B = 9\% &gt; 7\% = r_F \)<blockquote>
<p><img src="/images/investment_stock_asset_profolio_and_capital_asset_pricing_model/26.PNG" alt=""></p>
</blockquote>
</li>
</ul>
<h4 id="例題"><a href="#例題" class="headerlink" title="例題"></a>例題</h4><blockquote>
<p><img src="/images/investment_stock_asset_profolio_and_capital_asset_pricing_model/27.PNG" alt=""><br><img src="/images/investment_stock_asset_profolio_and_capital_asset_pricing_model/28.PNG" alt=""></p>
</blockquote>
<h2 id="被動投資策略與資本市場線"><a href="#被動投資策略與資本市場線" class="headerlink" title="被動投資策略與資本市場線"></a>被動投資策略與資本市場線</h2><p>被動投資策略為認定所有金融資產都充分表達在價格，因此不直接或間接分析證券價值來建立資產組合，而改成直接投資與市場指數相同報酬的組合。</p>
<p>如果一個投資者採用被動投資策略，則風險組合只會選擇含系統風險的指數型基金或追蹤市場指數的 ETF，也就是<strong>資本配置線(CAL)</strong>，中的 P 點為指數基金或 ETF，這時候的 CAL 則變成資本市場線(CML)。</p>
<p>通常 CML 表示投資人以被動投資策略搭配國庫券的各種投資機會集合。</p>
<p>資本配置線(CAL) 為風險資產與任一風險組合的連線</p>
<h3 id="名詞解釋"><a href="#名詞解釋" class="headerlink" title="名詞解釋"></a>名詞解釋</h3><ul>
<li>CML 中的 P 點為市場組合</li>
<li>\(E(r_m)\) 為預期報酬率</li>
<li>\(\sigma_m\) 為風險</li>
<li>CML 的數學方程式則是 \(E(r_C)= r_F + \frac{E(r_M)-r_F}{\sigma_M} * \sigma_C\)</li>
</ul>
<h2 id="Reviews"><a href="#Reviews" class="headerlink" title="Reviews"></a>Reviews</h2><ul>
<li>期望值的定義<br>\(E(X) = \sum_{i=1}^N P(X_i)X_i \)</li>
<li>運算規則<ul>
<li>\(E(aX+b) = aE(X) + b\)</li>
<li>\(E(aX+bY) =  aE(X) + bE(Y) \)</li>
</ul>
</li>
<li>變異數與共變異數的定義<ul>
<li>\(V(X) = \sigma_X^2 = E(X^2)-[E(X)]^2 \)</li>
<li>\(Cov(X,Y) =\sigma_{X,Y} = E(XY)-E(X)E(Y) \)</li>
<li>\(Cov(X,X) = \sigma_{X,X} = V(X) = \sigma_X^2 \)</li>
</ul>
</li>
<li>變異數與共變異數的運算規則<ul>
<li>\(V(aX+b) = V(aX) = a^2V(X) = a^2 \sigma_X^2 \)</li>
<li>\(V(aX \pm bY)=V(aX) + V(bY) \pm 2ab Cov(X,Y) = a^2 \sigma_X^2 + b^2 \sigma_Y^2 \pm 2ab \sigma_{X,Y}  \)</li>
<li>\(Cov(aX+bY , Z) = Cov(aX,Z) + Cov(bY,Z) = aCov(X,Z) + bCov(Y,Z) = a \sigma_{X,Z} + b \sigma_{Y,Z} \)</li>
</ul>
</li>
</ul>
<h2 id="兩種風險性資產組合"><a href="#兩種風險性資產組合" class="headerlink" title="兩種風險性資產組合"></a>兩種風險性資產組合</h2><p>假設兩種資產分別為 D and S，投資 D 的資金比重為 \(w_D\)，投資於 S 的資金比重為 \(w_S\)，且 \(w_D + w_S = 1\)，則此風顯資產組合報酬率為 \(r_p = w_D * r_D + w_S * r_S\)</p>
<ul>
<li>資產組合的預期報酬率<br>\(E(r_p) = E(w_D * r_D + w_S * r_S) = w_D * E(r_D) + w_S * E(r_S) \)</li>
<li>變異數<br>\(\sigma_{P}^2 = V(r_P) \\ = w_D^2 * \sigma_D^2 + w_S^2 * \sigma_S^2 + 2 w_D w_S \sigma_{D,S} \\ = w_D^2 * \sigma_D^2 + w_S^2 * \sigma_S^2 + 2 w_D w_S \sigma_{D} \sigma_{S} \rho_{D,S}  \)</li>
<li>\(\rho_{D,S} \) 為 D 及 S 報酬率的相關係數，\( -1 \leq \rho_{D,S} \leq 1 \)</li>
</ul>
<h3 id="相關係數"><a href="#相關係數" class="headerlink" title="相關係數"></a>相關係數</h3><p>相關係數是一種統計工具，用來衡量兩個隨機變數的線性關係，其值介於 -1 ~ +1。<br>公式為  \( \rho_{a,b} = \frac{\sigma_{a,b}}{\sigma_a \sigma_b}\)</p>
<h4 id="係數說明"><a href="#係數說明" class="headerlink" title="係數說明"></a>係數說明</h4><ul>
<li>相關係數為正時表示兩變數為正相關</li>
<li>為負時表示兩變數成負相關</li>
<li>為零時表示兩者變動互不相關</li>
</ul>
<h4 id="說明"><a href="#說明" class="headerlink" title="說明"></a>說明</h4><ul>
<li>當 \(\rho_{D,S} = 1 \) 表示兩者完全正相關，因此當 D 及 S 報酬率爭相關時，資產組合的標準差為兩資產個別標準查的加權平均，其係數為投資比重</li>
<li>當 \(\rho_{D,S} = -1 \) 表示兩者完全負相關，因此表示為對沖性的資產組合，可以降低資產組合的粽風險，因此對於其他組合，喜歡規避風險的投資人會喜歡對沖姓資產組合</li>
<li>只要相關係數不是完全正相關，則風險會比個別資產的風險低，因此只要相關係數不等於 1 就有分散風險效果，-1 時降低風險效果最大</li>
</ul>
<h4 id="例題-1"><a href="#例題-1" class="headerlink" title="例題"></a>例題</h4><p>假設 \(E(r_D) = 0.08\)，\(E(r_S) = 0.13\)、\(\sigma_D = 0.12\)、\(\rho_{D,S} = 0.3\)，則風險最小的資產配置為？</p>
<p>由於 \(w_D + w_S = 1 \)，且 \(\sigma_{p}^{2} \geq 0\)，因此一定存在全域最小值，求解時只需要利用一階必要條件。<br>\(\frac{d \sigma_{P}^{2}}{d w_D} = 2(0.12)^2 w_D  + 2(0.2)^2(1-w_D)(-1) \\ + 2(0.12)(0.2)(0.3)-2 * 2(0.12)(0.2)(0.3) w_D = 0 \)<br>需要注意的是最後兩項 \(w_D w_S = (1-w_D)w_D = w_D - w_D^2\)，因此式子會變得非常複雜QQ。</p>
<p>答案： \(w_D = 0.82\), \(w_S = 1 - w_D = 0.18 \)；\(E(r_p) = 0.089\)，\(\sigma_{P}^{2} = (0.115)^2 \)</p>
<p>紅色圈圈為註解：</p>
<blockquote>
<p><img src="/images/investment_stock_asset_profolio_and_capital_asset_pricing_model/1.PNG" alt=""></p>
</blockquote>
<ol>
<li>\( E(r_P) = 0.08(w_D) + 0.13(1 - w_D) = 0.08(w_D) + 0.13 - 0.13(w_D)\)<br>放大 20 倍後並移項則變成 \(20 E(r_P) = (w_D) + 2.6(1 - w_D)\)</li>
<li>透過 1. 推出 \((1-w_D) = w_S \)，就變成 \(w_S = -1.6 + 20E(r_p)\)，再把 \(w_S \) 改回 \(1-w_D\) 即可</li>
<li>真的太複雜了，我真的不算</li>
</ol>
<h2 id="股票、債券及無風險資產所構成組合的最適選擇"><a href="#股票、債券及無風險資產所構成組合的最適選擇" class="headerlink" title="股票、債券及無風險資產所構成組合的最適選擇"></a>股票、債券及無風險資產所構成組合的最適選擇</h2><p>如果有兩個風險資產與一個無風險資產時，通常是先決定好兩個風險資產的最適當配置，再將其視為一個風險資產，將資金分配在一個無風險資產與<strong>合併的一個風險資產</strong></p>
<blockquote>
<p><img src="/images/investment_stock_asset_profolio_and_capital_asset_pricing_model/2.PNG" alt=""></p>
</blockquote>
<p>我們在<a href="#單一風險資產與單一無風險資產組合">前面章節</a>已經知道 CAL 為無風險資產與任一風險組合的連線</p>
<h3 id="Sharpe-ratio-找出兩個風險資產最適配置"><a href="#Sharpe-ratio-找出兩個風險資產最適配置" class="headerlink" title="Sharpe ratio 找出兩個風險資產最適配置"></a>Sharpe ratio 找出兩個風險資產最適配置</h3><p>Sharpe ratio 可以用來作為資產組合績效的指標，績效越好的資產組合會是投資人所偏愛的組合，因此我們要找出 Sharpe ratio 最大，也就是 CAL 斜率最大的組合，也就是最適當的風險資產組合。</p>
<p>公式為：</p>
<ul>
<li>\(E(r_P) = w_D E(r_D) + w_S E(r_S)\)</li>
<li>\( \sigma_{P}^{2} = w_D^2 * \sigma_D^2 + w_S^2 * \sigma_S^2 + 2 w_D w_S \sigma_{D} \sigma_{S} \rho_{D,S}  \)</li>
<li>找出 \(w_D\)，再找出 \(w_S\) 即可，\(w_S = 1 - w_D \)</li>
<li>\(\text{Sharpe_Ratio}  = (報酬率 - 無風險利率) /  標準差 \)<h4 id="舉例"><a href="#舉例" class="headerlink" title="舉例"></a>舉例</h4>\(E(r_D) = 0.08 \), \(E(r_S)=0.13\),\(\sigma_{D} =0.12\),\(\sigma_{S}=0.2\),\(\rho_{D,S}=0.03\)，試問 ratio 極大的資產配置組合、該組合的預期報酬率、標準差與 Sharpe ratio</li>
</ul>
<p>5 % 應該是無風險利率，但此題並沒有說無風險利率是幾 % </p>
<blockquote>
<p><img src="https://imgur.com/I9BTJpD.jpg" alt=""></p>
</blockquote>
<h3 id="將兩個風險資產合併成一個風險資產後，找出風險資產與無風險資產最適配置"><a href="#將兩個風險資產合併成一個風險資產後，找出風險資產與無風險資產最適配置" class="headerlink" title="將兩個風險資產合併成一個風險資產後，找出風險資產與無風險資產最適配置"></a>將兩個風險資產合併成一個風險資產後，找出風險資產與無風險資產最適配置</h3><p>透過 Sharpe ratio 合併兩個風險資產後，將其視為一個風險資產，並找出風險資產與無風險資產最適配置，透過受限制條件下的預期效用函數極大化求值即可。</p>
<p>公式如下： 基本上都是先前的知識結合應用就不贅述</p>
<blockquote>
<p><img src="/images/investment_stock_asset_profolio_and_capital_asset_pricing_model/4.PNG" alt=""></p>
</blockquote>
<h3 id="note-預期效用函數"><a href="#note-預期效用函數" class="headerlink" title="note 預期效用函數"></a>note 預期效用函數</h3><p>設定絕對風險規避衡量值為 A(課本沒有告訴我們怎麼算)，當投資人風險規避 \(A &gt; 0\)，且規避風險越高時 A 值越大，如果投資活動對投資人財富的變動率為常態分配時，則可以推出預期效用函數 \(U = U(E(r),\sigma ) = E(r) - \frac{1}{2}A \sigma^2\)</p>
<p>注意，這裡的 \(y = 風險資產\)，與前面的不同</p>
<blockquote>
<p><img src="/images/investment_stock_asset_profolio_and_capital_asset_pricing_model/5.PNG" alt=""><br><img src="/images/investment_stock_asset_profolio_and_capital_asset_pricing_model/6.PNG" alt=""></p>
</blockquote>
<h3 id="複習"><a href="#複習" class="headerlink" title="複習"></a>複習</h3><blockquote>
<p><img src="/images/investment_stock_asset_profolio_and_capital_asset_pricing_model/7.PNG" alt=""></p>
</blockquote>
<h2 id="馬可維茲組合-多種風險資產及一種無風險資產組合的最適選擇"><a href="#馬可維茲組合-多種風險資產及一種無風險資產組合的最適選擇" class="headerlink" title="馬可維茲組合 - 多種風險資產及一種無風險資產組合的最適選擇"></a>馬可維茲組合 - 多種風險資產及一種無風險資產組合的最適選擇</h2><p>此決策方式，與先前提到的方式相同，但他的方程式更為複雜，此方程式的正式名稱為最小變異數前緣 (minimun-variance frontier)</p>
<p>在寫出求解過程前，我們先了解多種風險資產組合的預期報酬率及風險，先來說明一下我們會用的公式，目前我還沒想出標準差是怎麼來的。</p>
<blockquote>
<p><img src="/images/investment_stock_asset_profolio_and_capital_asset_pricing_model/8.PNG" alt=""><br><img src="/images/investment_stock_asset_profolio_and_capital_asset_pricing_model/9.PNG" alt=""><br><img src="/images/investment_stock_asset_profolio_and_capital_asset_pricing_model/10.PNG" alt=""></p>
</blockquote>
<h3 id="效率組合與效率前緣"><a href="#效率組合與效率前緣" class="headerlink" title="效率組合與效率前緣"></a>效率組合與效率前緣</h3><ul>
<li>風險資產效率組合定義<ul>
<li>所有相同期望報酬率組合最低風險</li>
<li>所有相同風險組合中最高預期報酬率</li>
</ul>
</li>
<li>風險資產組合效率前緣<br>效率前緣就是最小變異數(最低風險)，也就是前緣中正斜率處</li>
</ul>
<h4 id="效率前緣"><a href="#效率前緣" class="headerlink" title="效率前緣"></a>效率前緣</h4><p>找出效率式非常麻煩的一件事情，假如有 30 種資產就必須先預測 30 種資產預期報酬率，接著要計算 30 個標準差，再來要計算相關係數，標準差與相關係數共有 435 個。</p>
<p>假如你負責配置資產組合，在有限制條件的情況下建立出的效率前緣條件則會與完全自由無限制時不同，如限制你投資高配息的股票或只能投資某產業等。</p>
<h4 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h4><ul>
<li>決定風險資產組合與無風險資產間配置為 \(y=\frac{E(r_P)-r_F}{A \sigma_{P}^2}\)</li>
<li>風險資產組合的數學模型為<blockquote>
<p><img src="/images/investment_stock_asset_profolio_and_capital_asset_pricing_model/11.PNG" alt=""></p>
</blockquote>
</li>
</ul>
<h3 id="階段性區隔特性-由多種風險資產與一種風險資產構成的資產組合決策"><a href="#階段性區隔特性-由多種風險資產與一種風險資產構成的資產組合決策" class="headerlink" title="階段性區隔特性 - 由多種風險資產與一種風險資產構成的資產組合決策"></a>階段性區隔特性 - 由多種風險資產與一種風險資產構成的資產組合決策</h3><p>風險資產組合建構過程中，最適當的風險資產一定是 \(\rho \) 點，不論他的風險規避程度，也就是風險資產組合的選擇與其風險偏好程度是完全無關，決定過程是<strong>客觀且技術性</strong>。</p>
<p>決定配置比例時，是根據投資人能接受的風險規避，此時決定過程是<strong>主觀且策略性的</strong>，此時投資人根據自身策略在風險資產組合 \(\rho\)點間抉擇，差異只會在風險規避程度不同與資產組合分配比率不同。</p>
<h2 id="風險資產組合之風險分散效果"><a href="#風險資產組合之風險分散效果" class="headerlink" title="風險資產組合之風險分散效果"></a>風險資產組合之風險分散效果</h2><p>透過投資資產多元化可以消除個別資產的獨立風險，主要是透過不同公司的好消息與壞消息，獲得的正報酬與負報酬抵銷，而讓風險分散。</p>
<p>但如果是共同風險，如：市場風險、系統風險，這些風險都沒辦法透過多元化投資不同股票消除，當往好消息成長時，會增加所有報酬，反之亦同。</p>
<h3 id="表達式"><a href="#表達式" class="headerlink" title="表達式"></a>表達式</h3><blockquote>
<p><img src="/images/investment_stock_asset_profolio_and_capital_asset_pricing_model/12.PNG" alt=""><br><img src="/images/investment_stock_asset_profolio_and_capital_asset_pricing_model/13.PNG" alt=""><br><img src="/images/investment_stock_asset_profolio_and_capital_asset_pricing_model/14.PNG" alt=""></p>
</blockquote>
<h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p>根據最後一張圖片的 \(\rho = 0\)，當 n 趨近於無限時，則 \(\sigma_{P}^2 = 0\)，表示完全沒有共同風險。</p>
<p>如果 \(\rho &gt; 0 \)，實務上的正常情況，儘管有些資產的相關係數為負，但整體平均為正，則當 n 趨近於無限時，\(\sigma_{P}^2 \) 趨近於某一正數，且 \(\rho \) 越大則代表資產組合風險越高。</p>
<p>最極端的情況下，\(\rho = 1\)，不論 n 是多少，資產組合的風險都會是\(\sigma_{P}^2 \) 表示資產多元化對於<strong>風險分散完全沒有任何效果</strong></p>
<h2 id="資本資產定價模型-CAPM"><a href="#資本資產定價模型-CAPM" class="headerlink" title="資本資產定價模型 CAPM"></a>資本資產定價模型 CAPM</h2><h3 id="基本觀念"><a href="#基本觀念" class="headerlink" title="基本觀念"></a>基本觀念</h3><ul>
<li>CPAM 是財務領域第一個資產定價模型，雖然假設多且簡化人類投資，但清楚地描述風險資產的預期報酬率與其風險關係。</li>
<li>CAPM 描述的預期報酬與風險關係在實務上的應用</li>
</ul>
<ul>
<li>描述的均衡關係用來判定任何一風險資產是否偏離此關係，從中發現被低估或高估的可能性</li>
<li>描述的預期報酬率可作為資本財的成本，並賴以評估投資案的選擇決策</li>
</ul>
<h3 id="假設條件"><a href="#假設條件" class="headerlink" title="假設條件"></a>假設條件</h3><ol>
<li>所有投資人都是資產價格的接受者，不會因為某些投資人的交易結果而發生重大改變，即風險資產的市場為完全競爭市場。</li>
<li>投資人的活動都是一期，不會有多期</li>
<li>只能投資在市場上交易的資產，如股票</li>
<li>投資人不需要負擔交易稅、佣金，沒有交易成本</li>
<li>投資人的目的都是為了找到效率前緣</li>
<li>所有投資人的未來資產報酬分配具有同質性預期，也就是他們面對的效率前緣完全相同，沒有個別差異</li>
</ol>
<h3 id="重要結論"><a href="#重要結論" class="headerlink" title="重要結論"></a>重要結論</h3><ul>
<li>投資人只能夠持有市場組合(股票、無風險)，投資人之間的差異只有在市場組合的比重不同</li>
<li>市場組合一定是效率前緣上的組合，更是所有投資人面對的最適風險組合，由無風險資產與市場風險組合間的連結為最佳的 CAL，我們稱之為 CML</li>
</ul>
<blockquote>
<p><img src="/images/investment_stock_asset_profolio_and_capital_asset_pricing_model/15.PNG" alt=""></p>
</blockquote>
<h3 id="QUESTION-為何投資人都會持有市場投資組合"><a href="#QUESTION-為何投資人都會持有市場投資組合" class="headerlink" title="QUESTION: 為何投資人都會持有市場投資組合"></a>QUESTION: 為何投資人都會持有市場投資組合</h3><ul>
<li>投資人採用相同平均值 - 變異數分析(假設條件 5 )</li>
<li>投資人將資金投資在相同投資機會 (假設條件 3)</li>
<li>投資人有相同的持有期間 (假設條件 2)</li>
<li>投資人有相同的效率前緣 (假設條件 6)</li>
<li>投資人有相同的交易成本 (假設條件 4)</li>
</ul>
<h3 id="全體投資人必然會選擇持有相同的最適風險投資組合"><a href="#全體投資人必然會選擇持有相同的最適風險投資組合" class="headerlink" title="全體投資人必然會選擇持有相同的最適風險投資組合"></a>全體投資人必然會選擇持有相同的最適風險投資組合</h3><p>根據前面的 QUESTION，投資人可導出相同的效率前緣線，進而得到相同的最適風險性投資組合，即潔具向無風險利率水準的資本配置線與效率前緣線的切點 M，如下圖。</p>
<blockquote>
<p><img src="/images/investment_stock_asset_profolio_and_capital_asset_pricing_model/16.PNG" alt=""></p>
</blockquote>
<h3 id="市場組合的風險溢酬"><a href="#市場組合的風險溢酬" class="headerlink" title="市場組合的風險溢酬"></a>市場組合的風險溢酬</h3><p>投資者每個人都會找到同樣的效率前緣，因此每個人不同只因為每個人有不同的 \(A_i\)，因此平均每個人擁有的無風險資產為 0%，也表示每一個人持有的風險部位為 100%，也就表示市場組合的風險溢酬與市場組合的風險和風險規避平均值呈比率關係。</p>
<blockquote>
<p><img src="/images/investment_stock_asset_profolio_and_capital_asset_pricing_model/17.PNG" alt=""></p>
</blockquote>
<h3 id="CAPM-特性"><a href="#CAPM-特性" class="headerlink" title="CAPM 特性"></a>CAPM 特性</h3><ul>
<li>個別資產的風險溢酬是對整個市場組合的風險大小而定，風險大小等於 beta。<blockquote>
<p><img src="/images/investment_stock_asset_profolio_and_capital_asset_pricing_model/18.PNG" alt=""></p>
</blockquote>
</li>
<li>風險溢酬也亦是如此<blockquote>
<p><img src="/images/investment_stock_asset_profolio_and_capital_asset_pricing_model/19.PNG" alt=""></p>
</blockquote>
</li>
</ul>
<p>市場組合的 beta 值為 1，將組合個別資產的 beta 市值比例加權總計必等於 1，因此推論任何一個資產組合 beta 值大於 1 表示主動性策略，組合中大部分所選的投資產品 beta 值多數大於 1；反之則稱為防禦型投資策略。</p>
<h2 id="證券市場線-SML"><a href="#證券市場線-SML" class="headerlink" title="證券市場線 SML"></a>證券市場線 SML</h2><p>將預期報酬視為 Y 軸，Beta 係數視為 X 軸，則預期報酬與 Beta 則有線性關係，斜率就是市場風險溢酬，如下圖</p>
<blockquote>
<p><img src="/images/investment_stock_asset_profolio_and_capital_asset_pricing_model/20.PNG" alt=""></p>
</blockquote>
<h3 id="SML-應用"><a href="#SML-應用" class="headerlink" title="SML 應用"></a>SML 應用</h3><p>如果某一種風險資產價格被低估則預期報酬率必然高於 SML 線對應的均衡預期報酬率；反之，如果風險資產價格被高估則預期報酬率則會低於 SML 所對應的均衡預期報酬率</p>
<p>通常風險資產組合的預期報酬率與 SML 線所對應的均衡報酬率之間差額為風險資產的 Alpha，部分投資分析則是在尋找 Alpho 的投資組合，在 CAPM 的前提下買入有正 Alpha，賣出負 Alpha 的資產。</p>
<p>如下圖： 下圖為 Alpha 的差額</p>
<blockquote>
<p><img src="/images/investment_stock_asset_profolio_and_capital_asset_pricing_model/21.PNG" alt=""></p>
</blockquote>
<h4 id="例題-2"><a href="#例題-2" class="headerlink" title="例題"></a>例題</h4><blockquote>
<p><img src="/images/investment_stock_asset_profolio_and_capital_asset_pricing_model/22.PNG" alt=""><br>看圖可以得知 0.12 時比 SML 線還高，但 0.13 則比 SML 線還低<br><img src="/images/investment_stock_asset_profolio_and_capital_asset_pricing_model/23.PNG" alt=""></p>
</blockquote>
<h2 id="Fama-and-French-的-3-因子模型"><a href="#Fama-and-French-的-3-因子模型" class="headerlink" title="Fama and French 的 3 因子模型"></a>Fama and French 的 3 因子模型</h2><p>CAPM 的研究發現，單獨市場組合風險溢酬(beta)沒辦法完全解釋資產的風險溢酬，於是考量了其他變數，在此模型中加入了公司規模、帳面市值比兩項因素，模型為 \(E(r_i) = r_F + [E(r_M) - r_F] * \beta_{i,1} + E(SMB) * \beta_{i,2} + E(HML) * \beta_{i,3} \)</p>
<p>上面模型為小公司預期報酬率減大公司預期報酬率，稱為公司規模溢酬；HML為高 B/M 股票預期報酬率減低 B/M 股票預期報酬率，稱為公司價值溢酬。</p>
<h2 id="Fama-and-French-的-4-因子模型"><a href="#Fama-and-French-的-4-因子模型" class="headerlink" title="Fama and French 的 4 因子模型"></a>Fama and French 的 4 因子模型</h2><p>接下來又建立了一個四因子模型，模型為<br>\(E(r_i)=r_F + [E(r_M)-r_F] * \beta_{i,1} + E(SMB) * \beta_{i,2} + E(HML) * \beta_{i,3} + E(PR1YR) * \beta_{i,4}\)</p>
<ul>
<li>PR1YR 前一年動能組合<br>前 12 個月報酬較高的股票，繼續投資能有獲得超額報酬機會，因此我們可以放空前 12 個月低報酬的公司股票組合去投資前 12 個月高報酬公司股票組合來獲得風險溢酬。</li>
</ul>
]]></content>
      <categories>
        <category>北科上課筆記</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>北科大二上投資學筆記</tag>
        <tag>北科大大二上投資學期中考筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>投資學 筆記 - 股票價值基本分析 (產業分析與個別公司績效分析)</title>
    <url>/2020/12/06/NTUT_note/investment_stock_value_analysis_company_performance/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊與財金管理系大二上投資學重點整理<br><font color="#dd0000">並非所有人都適用，部分對我而言稍加容易的內容並不會寫在此內。</font><br>本章主要內容</p>
<ul>
<li>公司在產業中的競爭力分析</li>
<li>台灣產業分類與特性</li>
<li>利用經營指標分析公司股價</li>
</ul>
</blockquote>
<a id="more"></a>

<h1 id="產業分析"><a href="#產業分析" class="headerlink" title="產業分析"></a>產業分析</h1><h2 id="景氣循環"><a href="#景氣循環" class="headerlink" title="景氣循環"></a>景氣循環</h2><h3 id="產業景氣循環"><a href="#產業景氣循環" class="headerlink" title="產業景氣循環"></a>產業景氣循環</h3><p>經濟活動會重複性的經歷擴張與收縮，稱為景氣循環，循環的轉折點稱為高峰、低谷，高峰為擴張期結束和收縮期結束的交接點，谷底則出現在衰退期的底部，準備開始復甦</p>
<ul>
<li>成長性產業<br>具有高成長性，不受景氣循環影響，如：網通業、太陽能產業等，新產品或新技術有重大突破的產業</li>
<li>循環性產業<br>受景氣循環影響，如：汽車、家電產業</li>
<li>防禦性產業<br>受景氣循環小，如：食品生產、加工業、製藥業</li>
</ul>
<blockquote>
<p><img src="/images/investment_stock_value_analysis_company_performance/1.PNG" alt=""></p>
</blockquote>
<h3 id="產業競爭力分析架構"><a href="#產業競爭力分析架構" class="headerlink" title="產業競爭力分析架構"></a>產業競爭力分析架構</h3><blockquote>
<p><img src="/images/investment_stock_value_analysis_company_performance/2.PNG" alt=""></p>
</blockquote>
<h3 id="產業生命週期"><a href="#產業生命週期" class="headerlink" title="產業生命週期"></a>產業生命週期</h3><ul>
<li>開創期<br>產業發展的早期階段，特徵是擁有新技術與新產品，新產品在市場上尚未飽和，銷貨和盈餘成長很快，但不確定性也高，因為機器設備投資而讓資金大量流出</li>
<li>成長期<br>產業領導者開始出現，市場占有率容易被預測，產業的領頭羊廠商績效帶領著整體產業績效，此時產品普遍被消費者使用，在成長後期開始有大量現金流入</li>
<li>成熟期<br>產品已經廣為消費者使用，各公司的產品逐漸標準化，產品創新不多，開始進入價格戰爭，導致邊際利潤減少，現金流入極大後開始慢慢減少</li>
<li>衰退期<br>開始有新的替代產品出現或有低價產品入侵，產業成長率開始低於整體經濟社會甚至為負，現金流入不斷減少</li>
</ul>
<blockquote>
<p><img src="/images/investment_stock_value_analysis_company_performance/3.PNG" alt=""></p>
</blockquote>
<h2 id="台灣股票分類"><a href="#台灣股票分類" class="headerlink" title="台灣股票分類"></a>台灣股票分類</h2><h3 id="台灣對特定類股專有名詞"><a href="#台灣對特定類股專有名詞" class="headerlink" title="台灣對特定類股專有名詞"></a>台灣對特定類股專有名詞</h3><ul>
<li>主流股 投資人在短期內看好某類股票</li>
<li>內需股 產品以內銷為主，如水泥、食品、營建</li>
<li>資產股 公司有大量的不動產，如飯店、營建</li>
<li>投機股 股價波動大的股票</li>
<li>中國概念股 在中國設廠投資的股票</li>
<li>摩根概念股 納入<strong>新興市場自由指數(EMF)</strong>的股票</li>
</ul>
<h3 id="傳產股"><a href="#傳產股" class="headerlink" title="傳產股"></a>傳產股</h3><p>台灣投資人除了<strong>電子業</strong>與<strong>金融業</strong>之外的產業稱為傳統產業</p>
<ul>
<li>傳統產業的特性<ul>
<li>大多為成熟型產業，毛利率較低，不容易有獲利大幅成長情況</li>
<li>產品生命週期比較長</li>
</ul>
</li>
<li>須注意事項<ul>
<li>營建業為<strong>火車頭工業</strong>，他帶動著其他傳產業的發展，如：水泥、玻璃、鋼鐵</li>
<li>傳產業也有高科技技術產品，如：紡織股</li>
</ul>
</li>
</ul>
<blockquote>
<p><img src="/images/investment_stock_value_analysis_company_performance/4.PNG" alt=""><br><img src="/images/investment_stock_value_analysis_company_performance/5.PNG" alt=""></p>
</blockquote>
<h3 id="資訊電子業"><a href="#資訊電子業" class="headerlink" title="資訊電子業"></a>資訊電子業</h3><ul>
<li>台灣電子產業特性<ul>
<li>電子產業生命週期短，如果沒有開發新產品或創造有營利的產品，股價容易一落千丈</li>
<li>國內電子產業主要以代工為主，因此當國外廠商抽單時，營運馬上就發生危機</li>
<li>大多以出口為主，因此很受國外景氣與匯率影響極大</li>
<li>台灣的電子類股通常會引領大盤走向</li>
</ul>
</li>
</ul>
<blockquote>
<p><img src="/images/investment_stock_value_analysis_company_performance/6.PNG" alt=""></p>
</blockquote>
<h3 id="金融-保險-股"><a href="#金融-保險-股" class="headerlink" title="金融(保險)股"></a>金融(保險)股</h3><p>台灣的金融類股共有</p>
<ul>
<li>金融股<br>允許業者提供各種金融產品與服務，金控公司開始成立</li>
<li>商業銀行股<ul>
<li>銀行傳統收入大多來源放款與存款的利息差額，與外匯買賣、消費金融，近年改以手續費收入為收入來源</li>
<li>銀行放款大多為不動產抵押貸款，因此當房地產行情不佳時，呆帳增加則會降低銀行利潤</li>
</ul>
</li>
<li>保險股<br>分為<strong>壽險</strong>與<strong>產險</strong>，國人重視保險時有助於此產業的發展，但保險資金的投資運用有<strong>嚴格限制</strong>，經營上多投資不動產或國內外債券</li>
</ul>
<h2 id="國家發展計畫-2021年-2014年"><a href="#國家發展計畫-2021年-2014年" class="headerlink" title="國家發展計畫 2021年 - 2014年"></a>國家發展計畫 2021年 - 2014年</h2><ul>
<li>2016 年的 5+2 產業政策<br>加速台灣產業轉型並升級，提出<strong>智慧機械、亞洲矽谷、綠能產業、生醫產業、國防產業、新農業、循環經濟</strong>，來驅動台灣產業成長的核心</li>
<li>2020 年的 5+2 產業政策</li>
<li><em>強化半導體，建構 5G 與 AI 應用*</em>，鼓勵領航企業進行前瞻技術布局，提供研發經費補助，希望台灣成為亞洲研發核心</li>
<li>2021 - 2024 國家發展策略圖表<blockquote>
<p><img src="/images/investment_stock_value_analysis_company_performance/7.PNG" alt=""></p>
</blockquote>
</li>
</ul>
<h2 id="公司績效"><a href="#公司績效" class="headerlink" title="公司績效"></a>公司績效</h2><p>利用財報資訊來理解公司績效是<strong>基本分析</strong>的重要關鍵，通常透過 3 項財務數據作為指標</p>
<ul>
<li>ROE 股東權益報酬率 <ul>
<li>股東權益報酬率為企業為股東資金創造獲利的效率，比率越高表示股東獲利越多</li>
<li>\(ROE = (稅後淨利 / 銷售收入) * (銷貨收入 / 平均總資產 ) * (平均總資產 / 股東權利 ) \\ = 稅後淨利率 * 總資產周轉率 * 權益乘數\)</li>
<li>權益乘數<br>資產總額除以股東權益，表示企業負債程度，比率越高表示負債越高</li>
<li>通常 ROE 的主要變因在於<strong>稅後淨利率</strong></li>
<li><blockquote>
<p><img src="/images/investment_stock_value_analysis_company_performance/8.PNG" alt=""></p>
</blockquote>
</li>
</ul>
</li>
<li>ROA 總資產報酬率<br>評價企業運用全部資產的總體獲利能力，比率越高表示企業資產利用效益越好，企業盈利越強</li>
<li>EPS 每股盈餘</li>
<li><em>三項指標最為重要*</em>，對於有將股票在公開交易市場的企業而言，每股盈餘對企業的股價有一定的連動性</li>
</ul>
]]></content>
      <categories>
        <category>北科上課筆記</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>北科大二上投資學筆記</tag>
        <tag>北科大大二上投資學期中考筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>投資學 筆記 - 股票價值基本分析 (國內外政經事件與國內總經因素)</title>
    <url>/2020/12/05/NTUT_note/investment_stock_value_analysis_economic/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊與財金管理系大二上投資學重點整理<br><font color="#dd0000">並非所有人都適用，部分對我而言稍加容易的內容並不會寫在此內。</font><br>本章主要內容</p>
<ul>
<li>討論股票每股真實價值</li>
<li>分析影響股票市價因素</li>
</ul>
</blockquote>
<a id="more"></a>

<h1 id="基本分析"><a href="#基本分析" class="headerlink" title="基本分析"></a>基本分析</h1><h2 id="基本分析架構圖"><a href="#基本分析架構圖" class="headerlink" title="基本分析架構圖"></a>基本分析架構圖</h2><blockquote>
<p><img src="/images/investment_stock_value_analysis_economic/1.PNG" alt=""></p>
</blockquote>
<h3 id="國際與國內政經事件"><a href="#國際與國內政經事件" class="headerlink" title="國際與國內政經事件"></a>國際與國內政經事件</h3><ul>
<li>重大政治、金融風暴、戰爭與天災都會讓股市產生劇烈波動</li>
<li>經濟體越小的國家，國內政經動盪影響股市越大，反之亦同</li>
<li>政治變動，特別是民主國家的政權替換，通常會造成<strong>短期股市震盪</strong>，當大部分會回到原本走勢</li>
<li>天災、金融風暴、戰爭對股市影響特別大，基本上都需要非常長的時間才能回復到原本走勢</li>
</ul>
<h2 id="全球經濟"><a href="#全球經濟" class="headerlink" title="全球經濟"></a>全球經濟</h2><p>經濟成長率通長以一國的生產毛額(GDP)的年增率表示。</p>
<h5 id="QUESTION-What-is-the-difference-between-GDP-and-GNP"><a href="#QUESTION-What-is-the-difference-between-GDP-and-GNP" class="headerlink" title="QUESTION: What is the difference between GDP and GNP"></a>QUESTION: What is the difference between GDP and GNP</h5><ul>
<li>GDP 國內生產毛額<br>計算<strong>國內</strong>全部的生產毛額</li>
<li>GNP 國民生產毛額<br>計算<strong>國民</strong>全部的生產毛額，此國民無論人在國內國外都應該要被計算</li>
</ul>
<h3 id="各國經濟成長率與股市報酬率"><a href="#各國經濟成長率與股市報酬率" class="headerlink" title="各國經濟成長率與股市報酬率"></a>各國經濟成長率與股市報酬率</h3><ul>
<li>各國經濟成長率表示各國整體購買力，成長率越高就表示對未來的經濟發展越有淺力，國民投資能力越強</li>
<li>台灣是<strong>小型經濟開放體</strong>，依賴貿易，因此會受國際經濟景氣影響，特別是其他大型經濟體，如美國、中國、日本</li>
<li>股市通常比景氣更快反應，也就是說景氣要好轉前股市就會先好轉。P.S. 因為股市帶動景氣</li>
</ul>
<h2 id="匯率"><a href="#匯率" class="headerlink" title="匯率"></a>匯率</h2><ul>
<li>表示本國貨幣轉換成外國貨幣的比率，當本國貨幣可以換得更多外國貨幣則為<strong>升值</strong>，反之貶值</li>
<li>匯率會影響一國產品在國際市場的競爭力，匯率會影響整個產業，尤其以進出口為主要經濟活動的產業</li>
<li>新台幣升值時對進口廠商有利，對出口商不利；反之亦同。<br>因為我們進口時是給予外國貨幣，因此當新台幣升值時可以換得更多外國貨幣；出口時是對方給予我們外國貨幣，但因為本國貨幣升值，導致我們換回的新台幣變少而貶值。</li>
</ul>
<p>台灣進口美國產品，台灣廠商先換成美國貨幣在交易；台灣出口美國產品，美國則給予我們美國貨幣交易。</p>
<p>為甚麼都是以美國貨幣為主？因為在大多數情況下，交易都是用國際貨幣(通常是美金)為主</p>
<h3 id="貨幣通常被三項因素控制"><a href="#貨幣通常被三項因素控制" class="headerlink" title="貨幣通常被三項因素控制"></a>貨幣通常被三項因素控制</h3><ul>
<li>物價膨脹</li>
<li>國民所得、經濟成長率</li>
<li>利率水準</li>
<li>除了上面此三項因素，通常資金控制越開放的國家，匯率變動頻率也會越高</li>
<li>當市場預期新台幣貶值時，會擔心以新臺幣為主的資產縮水，因此市場投資人(特別是外資)會傾向將資金移出，造成資金外流，股市缺乏資金隨之下跌。</li>
</ul>
<h3 id="央行對於外匯管理措施"><a href="#央行對於外匯管理措施" class="headerlink" title="央行對於外匯管理措施"></a>央行對於外匯管理措施</h3><p>為了防止外資炒作外匯，中央銀行有對外資做些限制：</p>
<ul>
<li>資金停泊<br>外資匯入後，要在一周之內將新台幣投入股市，以免被誤認為有炒匯嫌疑</li>
<li>投資限額<br>央行規定，外資匯入後，購買公債等固定收益商品，不可超過匯入資金的三成，以免之後台灣匯率被國外控制</li>
<li>匯入<br>外資將外國貨幣轉入新台幣</li>
</ul>
<h2 id="經濟循環"><a href="#經濟循環" class="headerlink" title="經濟循環"></a>經濟循環</h2><p>一國的經濟循環變動稱為景氣循環，通常是指經過衰退、蕭條、復甦、繁榮，不斷來回的現象，股市可以看出景氣變得的特性，當股價上升時通常表時景氣準備上升、反之亦同。</p>
<p>用來觀測總體經濟景氣變化的指標為：景氣對策訊號、景氣動向指標</p>
<p>主要的總體經濟變數則包括：物價與油價、貨幣供給量、利率、採購經理人指數</p>
<h3 id="景氣對策信號"><a href="#景氣對策信號" class="headerlink" title="景氣對策信號"></a>景氣對策信號</h3><p>通常由國發會發布，透過利用多項經濟指標量化產生分數後，再將分數分級成某種燈號，來判斷經濟景氣的情況</p>
<ul>
<li><p>燈號</p>
<ul>
<li>綠燈 = 穩定</li>
<li>紅燈 = 熱絡</li>
<li>藍燈 = 低迷</li>
<li>紅黃燈 = 紅燈準備轉向綠燈</li>
<li>黃藍燈 = 藍燈準備轉向綠燈</li>
</ul>
</li>
<li><p>台灣股市與景氣對策訊號</p>
<ul>
<li>當藍燈出現時股價比較低，紅燈時股價高</li>
<li><strong>但景氣對策訊號有一項為股價指數，因此用來預測股市繁榮效用不高</strong></li>
<li>但如果長期持有股票且經濟體發展穩健，那反應到股價則時遲早問題</li>
</ul>
</li>
</ul>
<h3 id="景氣動向指標"><a href="#景氣動向指標" class="headerlink" title="景氣動向指標"></a>景氣動向指標</h3><p>將季節調整、標準化因子調整、加權平均後建構出的綜合性指標，可以反應出景氣的變動與幅度，且<strong>領先指標可以被投資分析所使用</strong></p>
<p>領先指標能夠<strong>提前</strong>反應景氣變動，轉折點也領先於景氣循環的轉折點，如果連續三個月往上則表示景氣將好轉，股價也會有好的表現</p>
<h3 id="油價與物價"><a href="#油價與物價" class="headerlink" title="油價與物價"></a>油價與物價</h3><ul>
<li>物價<ul>
<li>物價膨脹率可以用物價指數(CPI or WPI)的變動率計算，上升時會提高生產成本，產商如果沒辦法將成本轉嫁給消費者，將會影響到公司獲利而降低股價</li>
<li>中央銀行會抑止股價上速上揚，會採取緊縮性貨幣政策，例如調高利率或減少市面貨幣供給量，導致股市失去資金動能而下跌</li>
</ul>
</li>
<li>油價<ul>
<li>原油屬於上游原料，當油價上漲大多數的產品成本也會上漲，而影響產品價格進而間接影響股價(造成公司獲利減少)</li>
<li>如果是原油供給面減少則會讓經濟與股價<strong>全面性衰退</strong>；如果是需求面增加則有可能造成經濟與股價<strong>全面性上揚</strong><br>因為有更多需求表示可以為公司增加更多財富，但供給減少表示沒辦法讓公司增加財富還會增加公司生產成本</li>
</ul>
</li>
</ul>
<h3 id="貨幣供給量"><a href="#貨幣供給量" class="headerlink" title="貨幣供給量"></a>貨幣供給量</h3><p>在某一個特定時間，銀行體系的企業與個人能保油的通貨與存款總額，當貨幣供給量增加，市場上的資金不缺乏，充滿資金動能，股價容易上漲；當貨幣供給量減少則缺乏資金動能，股價容易下跌。</p>
<h4 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h4><ul>
<li>\(M_{1a} = 通貨發行淨額 + 支票存款 + 活期存款\)</li>
<li>\(M_{1b} = M_{1a} + 活期儲蓄存款 \)</li>
<li>\(M_2 = M_{1b} + 定期存款 + 郵政儲金 + 外國人持有本國貨幣 + 外幣定存 + 附買回交易\)</li>
<li>活期存款是<strong>法人或公司</strong>所持有</li>
<li>活期儲蓄存款為<strong>個人</strong>所持有</li>
</ul>
<h4 id="觀念"><a href="#觀念" class="headerlink" title="觀念"></a>觀念</h4><p>當 \(M_{1b}\) 年增率上升時表示有多餘的資金動能帶動股市上漲，特別是當年的 \(M_{1b}\) 年增率高於 \(M_2\) 且交叉向上形成黃金交叉表示市場資金充沛，資金動能更多，股票會有一段時間上漲(因為可以支配的錢已經比被鎖住的錢還多)</p>
<p>當 \(M_{1b}\) 年增率上升時會帶動股市上漲，當 \(M_{1b}\) 下降時常會造成股價下跌，\(M_2\) 則不明顯，因為大部分都是被鎖住資金，操作自由度不高</p>
<h3 id="利率"><a href="#利率" class="headerlink" title="利率"></a>利率</h3><ul>
<li>利率上升時會使投資人的報酬要求率上升，評估企業價值時，其價值會降低，股價也會降低</li>
<li>當利率上升時，如果股票投資率不高於銀行存款利率時，投資人會將資金放入銀行而不是股市</li>
<li>利率上升表示公司資金成本上升，使其獲利下降、股價下挫</li>
<li>長期利率的差距<br>長期的負斜率狀態與經濟率退有很高的關聯性，且經濟衰退又會導致股價下跌</li>
</ul>
<h3 id="採購經理人指數-PMI"><a href="#採購經理人指數-PMI" class="headerlink" title="採購經理人指數 PMI"></a>採購經理人指數 PMI</h3><p>以 50 作為製造業景氣好壞的分水嶺，當該指數高於 50 時表示景氣熱絡、對股市有利；反之亦同。</p>
<p>在台灣，2011 年開始有台灣製造業採購經理人指數，可作為投資人掌握台灣景氣波動的參考指標</p>
<h3 id="台灣經濟指標公布時間"><a href="#台灣經濟指標公布時間" class="headerlink" title="台灣經濟指標公布時間"></a>台灣經濟指標公布時間</h3><blockquote>
<p><img src="/images/investment_stock_value_analysis_economic/2.PNG" alt=""></p>
</blockquote>
]]></content>
      <categories>
        <category>北科上課筆記</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>北科大二上投資學筆記</tag>
        <tag>北科大大二上投資學期中考筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>演算法知識 - Two way search 雙向搜尋</title>
    <url>/2020/12/14/Explain_Algorithm/Two-way-search/</url>
    <content><![CDATA[<h2 id="Two-way-search-介紹"><a href="#Two-way-search-介紹" class="headerlink" title="Two way search 介紹"></a>Two way search 介紹</h2><blockquote>
<p>雙向搜尋主要是透過起點與終點都進都進行搜尋來獲得答案，主要是為了加快搜尋效率而產生的一種新觀念</p>
<p>下面將介紹兩種雙向搜尋演算法</p>
<ul>
<li>雙向同時搜尋</li>
<li>Meet in the middle </li>
</ul>
</blockquote>
<a id="more"></a>

<h2 id="雙向同時搜尋"><a href="#雙向同時搜尋" class="headerlink" title="雙向同時搜尋"></a>雙向同時搜尋</h2><p>基本作法是先透過起點端或終點端進行一次搜尋(BFS or DFS)，其中當起點在進行的搜尋與終點在進行的搜尋遇到時則表示找到答案解，在其必要時透過<strong>兩次搜尋</strong>，將沒有連接終點與起點的節點進行刪除(枝剪)。</p>
<h3 id="例題"><a href="#例題" class="headerlink" title="例題"></a>例題</h3><ul>
<li><a href="https://theriseofdavid.github.io/2020/12/14/UVa/UVa208/" target="_blank" rel="noopener">UVa 208 – Firetruck</a> </li>
</ul>
<h2 id="Meet-in-the-middle-中間相遇法"><a href="#Meet-in-the-middle-中間相遇法" class="headerlink" title="Meet in the middle 中間相遇法"></a>Meet in the middle 中間相遇法</h2><p>Meet in the middle 沒有正式的中文名稱，常見名稱<strong>中間相遇法</strong>，此觀念適用在於輸入數據較小，但並沒有小到能夠直接 brute force 的情況時就適合用 Meet in the middle。</p>
<p>基本作法為將一張圖切成兩部分，分別進行搜尋，最後再將兩邊的結果合併，brute force 的時間複雜度通常為 \(O(N_n)\)，但透過 Meet in the middle 可以將時間複雜度降為 \(O(N^{n/2})\)，方便我們去嘗試 brute force。</p>
<h3 id="例題-1"><a href="#例題-1" class="headerlink" title="例題"></a>例題</h3><ul>
<li><a href="https://theriseofdavid.github.io/2020/12/15/UVa/UVa1326/" target="_blank" rel="noopener">UVa1326 - Jurassic Remains</a></li>
</ul>
]]></content>
      <categories>
        <category>演算法知識</category>
      </categories>
      <tags>
        <tag>程式解題</tag>
        <tag>演算法知識</tag>
        <tag>雙向搜尋</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa208 - Firetruck (雙向搜尋-逆向搜尋)</title>
    <url>/2020/12/14/UVa/UVa208/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>在一個區域中必定會有一個消防局，現在有一個點失火，我們想知道從消防局到失火點的所有路徑，並且輸出。<br>請注意：消防員不願意接受繞圓此動作(繞了一個圓圈再回到某個點，即形成一個循環)，因為會影響他們的行進速度。</p>
<p>題目測資的點不會超過 22 個點，也就是路徑最多不會超過 22 條路徑。</p>
</blockquote>
<a id="more"></a>

<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>這題是使用雙向搜尋是最適合的題目之一，由於此題目必須要輸出每一個路徑，因此用 brute force 是最好的應用，但如果想到這邊然後就直接進行 DFS or BFS 搜尋就會遇到一個大麻煩，時間 TLE。</p>
<p>為甚麼會遇到 TLE 呢？我們舉個例子：我們假設道路都是單行道，只能向北走，想請問有沒有辦法從台北走到高雄？</p>
<p>答案是不行的，因為道路都是<strong>單行道且只能往北走</strong>台北往到高雄勢必是不可能，但程式會不斷嘗試的從台北出發往北的道路不斷進行搜尋，因此在道路複雜許多後就會造成 TLE 的問題，這時候就要用到一個觀念，<strong>雙向搜尋</strong>。</p>
<h2 id="雙向搜尋-同時搜尋"><a href="#雙向搜尋-同時搜尋" class="headerlink" title="雙向搜尋-同時搜尋"></a><a href="https://theriseofdavid.github.io/2020/12/14/Explain_Algorithm/Two-way-search/" target="_blank" rel="noopener">雙向搜尋-同時搜尋</a></h2><p>我們先從終點進行搜尋(<strong>反向搜尋</strong>)，透過終點搜尋(BFS,DFS)可以接觸到的所有節點，並記錄下來；之後再透過起點進行搜尋(<strong>正向搜尋</strong>)，在正向搜尋時再附加一個條件為<strong>必須要是反向搜尋有經過的節點</strong>，才可以確保目前正向搜尋的路線中是正確的方向，而不是在往錯誤的方向前進。</p>
<p>這裡我們則使用 DFS 進行撰寫。</p>
<h3 id="QUESTION-為甚麼要這樣寫呢？這樣不是把兩張一樣的圖搜尋過一遍嗎"><a href="#QUESTION-為甚麼要這樣寫呢？這樣不是把兩張一樣的圖搜尋過一遍嗎" class="headerlink" title="QUESTION: 為甚麼要這樣寫呢？這樣不是把兩張一樣的圖搜尋過一遍嗎"></a>QUESTION: 為甚麼要這樣寫呢？這樣不是把兩張一樣的圖搜尋過一遍嗎</h3><p>這個問題問得很好，我與我的演算法隊友齊笎經過一番論戰過後，找出原因，測試資料中有一筆測資是起點並沒有與終點連在一起，也就是他們是兩張分開的圖，其他的點則交互連在一起。</p>
<p>如果沒有這個反向 dfs 就會導致起點不斷的進行搜尋卻怎麼樣都沒有搜尋到終點，當測資一大時就會超時，極端的測資是 終點自己一個點，然後起點與其他點都互相連接，即每個點都有 n-2 個邊。扣掉終點與自己</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse_dfs</span><span class="params">(<span class="keyword">int</span> u )</span></span>&#123; <span class="comment">//反向搜尋</span></span><br><span class="line">    join[u] = <span class="number">1</span> ; <span class="comment">//join 紀錄反向搜尋會經過的點，1表示會經過</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; MAXN ; i++)</span><br><span class="line">        <span class="keyword">if</span>( !join[i] &amp;&amp; road[u][i] ) reverse_dfs(i);</span><br><span class="line">        <span class="comment">//road 表示這條路徑目前已經被用過</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="焦點回到題目上，解開題目的小設計"><a href="#焦點回到題目上，解開題目的小設計" class="headerlink" title="焦點回到題目上，解開題目的小設計"></a>焦點回到題目上，解開題目的小設計</h2><p>之後只需要做好每一次在讀取測試資料時要清除上筆測試的資料且<strong>題目輸出格式正確，輸出的路徑那行最後不可以有空白</strong>，即<code>1 3 5</code>，以及不要將 DFS 寫爛即可。</p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="http://acm.zzkun.com/archives/92" target="_blank" rel="noopener">UVa 208 – Firetruck [双向DFS]</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>雙向搜尋是我這一周碰到的新觀念，觀念雖然是簡單但其實如果用在題目上，我還會傻住，這也驗證了演算法一向都是觀念好懂，實作很難的事物阿，希望我之後可以善用此演算法在未來或是大型的演算法比賽中。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>其實就是沒有附上說明的程式碼，看得懂跟說得出來真的是兩回事，也許還有人覺得我說的很差，不過我已經盡力解釋。希望可以幫助到各位。</p>
<p>也希望大家想要學習的知識都可以快速學習而成，不要因為自身的環境不足而學習不到。</p>
<p>於是這裡就補述一些題目給的資料範圍限制與標頭檔了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 22</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n , kase , cnt , vis[MAXN] , road[MAXN][MAXN] , join[MAXN];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse_dfs</span><span class="params">(<span class="keyword">int</span> u )</span></span>&#123;</span><br><span class="line">    join[u] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; MAXN ; i++)</span><br><span class="line">        <span class="keyword">if</span>( !join[i] &amp;&amp; road[u][i] ) reverse_dfs(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u )</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u == n )&#123; <span class="comment">//到達終點，輸出路徑</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; res.size()<span class="number">-1</span> ; i++) <span class="built_in">cout</span> &lt;&lt; res[i] &lt;&lt; <span class="string">' '</span> ;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; res[res.size()<span class="number">-1</span>] ;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">        cnt++ ;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; MAXN ; i++)&#123; </span><br><span class="line">        <span class="keyword">if</span>(!vis[i] &amp;&amp; road[u][i] &amp;&amp; join[i] )&#123; <span class="comment">//符合條件後記錄節點 </span></span><br><span class="line">            vis[i] = <span class="number">1</span> ;</span><br><span class="line">            res.push_back(i);</span><br><span class="line">            dfs(i);</span><br><span class="line">            res.pop_back();</span><br><span class="line">            vis[i] = <span class="number">0</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123; <span class="comment">//清除資料並重新整理</span></span><br><span class="line">    <span class="built_in">memset</span>(road,<span class="number">0</span>,<span class="keyword">sizeof</span>(road));</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="built_in">memset</span>(join,<span class="number">0</span>,<span class="keyword">sizeof</span>(join));</span><br><span class="line">    cnt = <span class="number">0</span> ;</span><br><span class="line">    res.clear();</span><br><span class="line">    vis[<span class="number">1</span>] = <span class="number">1</span> ;</span><br><span class="line">    res.push_back(<span class="number">1</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> );</span><br><span class="line">    freopen(<span class="string">"out.txt"</span> , <span class="string">"w"</span> , <span class="built_in">stdout</span>) ;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">int</span> a,b ;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n)&#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &amp;&amp; a &amp;&amp; b )&#123; </span><br><span class="line">            road[a][b] = <span class="number">1</span> ; road[b][a] = <span class="number">1</span> ; <span class="comment">//紀錄路徑</span></span><br><span class="line">        &#125;</span><br><span class="line">        reverse_dfs(n);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"CASE "</span> &lt;&lt; ++kase &lt;&lt; <span class="string">":\n"</span> ;</span><br><span class="line">        dfs(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"There are "</span> &lt;&lt; cnt &lt;&lt; <span class="string">" routes from the firestation to streetcorner "</span> &lt;&lt; n &lt;&lt; <span class="string">".\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="紙筆紀錄"><a href="#紙筆紀錄" class="headerlink" title="紙筆紀錄"></a>紙筆紀錄</h2><p>上方有一點提到我與齊笎進行探討，我將我們在那邊進行廝殺的紀錄放在此處，留念XD。</p>
<p><img src="https://i.imgur.com/DDeJi7M.jpg" alt=""></p>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>演算法知識</tag>
        <tag>雙向搜尋</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa1326 - Jurassic Remains (雙向搜尋-Meet in the middle、位元運算)</title>
    <url>/2020/12/15/UVa/UVa1326/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>考古學家們挖到恐龍化石，但恐龍化石太大沒有辦法被載送回來，於是考古學家就將化石切成零件，並做上標記，載回博物館；但遇到了一個麻煩，同時有另外一批化石也被送回博物館，同時也是將化石切稱 零件，運氣不好的是他們的零件標記與我們使用的符號相同，我們的目標就是找出我們的恐龍化石，並且透過我們的零件組回化石。</p>
<p>有五點需要特別注意：</p>
<ul>
<li>零件組合必須是兩個相同的標籤組成</li>
<li>每一個化石標籤，都必須都有相同的化石標籤且<strong>不一定是</strong>另外一個零件，也可以是自己的</li>
<li>我們找回的化石必須要是零件配對數量最大的，也就是零件配對數量必須要最高</li>
<li>一個零件中的所有標籤，每一個都必須被使用到</li>
<li>零件最多不會超過 25</li>
</ul>
</blockquote>
<a id="more"></a>


<h2 id="懶人包題目大意："><a href="#懶人包題目大意：" class="headerlink" title="懶人包題目大意："></a>懶人包題目大意：</h2><p>是不是覺得上面很煩不想看？因此我有特別寫一個簡單版的。</p>
<p>利用題目測試資料的 x 行選出 y 行能夠將每一個字母的數字總合為偶數，且 y 必須是最大。<del>好懂了八</del></p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>由於必須輸出最大的行數且必須要輸出有哪些行，因此這裡 brute force 會是最好的選擇。</p>
<p>這題 Udebug 沒有提供測資，好難過啊QwQ。</p>
<h3 id="時間複雜度"><a href="#時間複雜度" class="headerlink" title="時間複雜度"></a>時間複雜度</h3><p>我們先來分析一下時間複雜度，如果使用 brute force 時複雜度會是 \(O(2^24)\)，選或不選並且有至少有 24 個英文字母，時間複雜度會太高，因此我們這邊使用<a href="https://theriseofdavid.github.io/2020/12/14/Explain_Algorithm/Two-way-search/" target="_blank" rel="noopener">雙向搜尋-Meet in the middle</a>，將時間複雜度優化至\(O(2^{12} * 12) \)，選或不選有 12 個英文字母，且每一個都可以在與另外 12 個英文字母考慮選或不選，</p>
<ul>
<li>時間複雜度 \(O(2^{24})\)，運行時間為 1.110s<br>程式碼由<a href="https://blog.csdn.net/keshuai19940722/article/details/18995013" target="_blank" rel="noopener">JeraKrs 提供</a></li>
<li>時間複雜度 \(O(2^{12} * 12\)，運行時間為 0.3s</li>
</ul>
<h3 id="雙向搜尋-Meet-in-the-middle"><a href="#雙向搜尋-Meet-in-the-middle" class="headerlink" title="雙向搜尋-Meet in the middle"></a><a href="https://theriseofdavid.github.io/2020/12/14/Explain_Algorithm/Two-way-search/" target="_blank" rel="noopener">雙向搜尋-Meet in the middle</a></h3><p>透過雙向搜尋-Meet in the middle，我們將 12 個字母分成一組，再將兩組合併，只要這兩組的字母合起來為偶數並偶數數量為最大值時則代表我們搜尋成功。</p>
<h3 id="字母-Hash"><a href="#字母-Hash" class="headerlink" title="字母 Hash"></a>字母 Hash</h3><p>稍微複習一下，左移(<code>a &lt;&lt; b</code> )，為 \(a * 2 ^ b\)、右移(<code>a &gt;&gt; b</code>)，為 \(a / 2 ^ b\)</p>
<p>在這題，我們將運用到全新的黑科技(神奇的寫法)，透過<strong>二進位</strong>來 hash 每一個字母，A 為 1、B 為 2、C 為 4、D 為 8，想必大家都看的出來了，沒錯，那就是透過二進位的位數來進行 hash，因此程式碼會這樣寫</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> &lt;&lt; (<span class="built_in">string</span>[j] - <span class="string">'A'</span>) <span class="comment">//找出該字母的 hash</span></span><br></pre></td></tr></table></figure>

<p>再聰明一點的朋友肯定會更多想一步，那這樣我就可以透過加法來給出每一行字串的 hash 了，這時候要請大家再回去看<a href="https://theriseofdavid.github.io/2020/12/15/UVa/UVa1326/#題目大意：" target="_blank" rel="noopener">題目大意</a>需要注意的第二點，那些標籤也可以跟自己的字串組合，因此這裡我們不使用加法而是使用 <strong>xor</strong>，來解決此問題，透過 xor 在兩個字母的 hash 都一樣時會變回 0，就可以方便處理到加法會進位的問題。</p>
<p>舉例： <code>3 xor 3 = 0</code></p>
<p>因此我們的 hash 字母可以這樣寫：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">memset</span>(mark,<span class="number">0</span>,<span class="keyword">sizeof</span>(mark)); <span class="comment">//mark 為每一行存的 hash 值</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i++)&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; temp ;</span><br><span class="line">    x = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; temp.length() ; j++)</span><br><span class="line">        x ^= <span class="number">1</span> &lt;&lt; (temp[j] - <span class="string">'A'</span>); <span class="comment">//字母 hash 並檢查奇偶數</span></span><br><span class="line">    mark[i] = x ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="雙向搜尋-Meet-in-the-middle-實作"><a href="#雙向搜尋-Meet-in-the-middle-實作" class="headerlink" title="雙向搜尋-Meet in the middle 實作"></a>雙向搜尋-Meet in the middle 實作</h3><p>這裡也要用到 2 進位，2 進位真的好用。</p>
<p>透過二進位的關係，可以寫出一種組合為<strong>全部的資料運用</strong>，我們用舉例的應該大家會比較好懂：</p>
<h4 id="舉例：n-3，我們想要輸出-3-的全部組合"><a href="#舉例：n-3，我們想要輸出-3-的全部組合" class="headerlink" title="舉例：n = 3，我們想要輸出 3 的全部組合"></a>舉例：n = 3，我們想要輸出 3 的全部組合</h4><p>n = 3，於是我們找到二進位位數等於 3 的最大值 = 7，並透過 for(i &lt;= 8)，對 i 變數中位元為 1 的值紀錄可以發現以下有趣的事：</p>
<table>
<thead>
<tr>
<th>數字</th>
<th>位元為 1 的值紀錄</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>2</td>
<td>1</td>
</tr>
<tr>
<td>3</td>
<td>0,1</td>
</tr>
<tr>
<td>4</td>
<td>2</td>
</tr>
<tr>
<td>5</td>
<td>0,2</td>
</tr>
<tr>
<td>6</td>
<td>1,2</td>
</tr>
<tr>
<td>7</td>
<td>0,1,2</td>
</tr>
<tr>
<td>8</td>
<td>3</td>
</tr>
</tbody></table>
<p>透過紀錄每一個數字位元為 1 的值，竟然可以將每一行的組合都找到！太神了拉！</p>
<p>其實是利用二進位的數字增加，透過此方式來找出全部的組合。</p>
<h3 id="回歸焦點"><a href="#回歸焦點" class="headerlink" title="回歸焦點"></a>回歸焦點</h3><p>我們現在已經可以找出全部的組合了，再來就是要每個組合進行 xor，並且保存記錄下來，值得注意的地方則是假如有兩個的 hash 值為一樣時，題目要求的是組合行數最大，因此當兩個 hash 值相同時我們則要找出使用最多行的 hash 值作為標準(最多行的組合)，因此我們再透過<code>__builtin_popcount</code>函數可以幫助我們找出此數字內有多少個 1，來完成此判斷。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m1 , m2 ; <span class="comment">//紀錄 m1 為拆開的前半圖、m2為拆開的後半圖</span></span><br><span class="line"><span class="keyword">int</span> div1 = n/<span class="number">2</span> , div2 = n - n/<span class="number">2</span> ; <span class="comment">//div1 為前半圖的寬度,div2 為後半圖的寬度</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; ( <span class="number">1</span> &lt;&lt;div1) ; i++ )&#123; <span class="comment">// 1 &lt;&lt; div1 找到最大位數</span></span><br><span class="line">    x = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; div1 ; j++ )&#123; <span class="comment">//div1 檢查這三位數即可</span></span><br><span class="line">        <span class="keyword">if</span>((i &gt;&gt; j ) &amp; <span class="number">1</span>) x ^= mark[j] ; <span class="comment">//紀錄有 1 的位數，並且讓他與那行進行 hash</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!m1.count(x) || __builtin_popcount(m1[x]) &lt; __builtin_popcount(i) ) </span><br><span class="line">    <span class="comment">//比較是否有更多行的組合</span></span><br><span class="line">        m1[x] = i ; <span class="comment">//紀錄用到的行數，之後可以用位元為 1 的值回推</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; (<span class="number">1</span> &lt;&lt; div2) ; i++)&#123; <span class="comment">// 1 &lt;&lt; div2 的最大位數</span></span><br><span class="line">    x = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; div2 ; j++)&#123; <span class="comment">//div2 檢查這三位數即可</span></span><br><span class="line">        <span class="keyword">if</span>((i &gt;&gt; j ) &amp; <span class="number">1</span>) x ^= mark[j + div1]; </span><br><span class="line">        <span class="comment">//紀錄有 1 的位數，並且讓他與那行進行 hash，並且 mark[j + div1]，</span></span><br><span class="line">        <span class="comment">//需要加 div1 是因為這是後半張的圖，且我們 index 從 0 開始，因此只需要加 dvi1，不須 +1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!m2.count(x) || __builtin_popcount(m2[x]) &lt; __builtin_popcount(i) )</span><br><span class="line">    <span class="comment">//比較是否有更多行的組合</span></span><br><span class="line">        m2[x] = i ; <span class="comment">//紀錄用到的行數，之後可以用位元為 1 的值回推</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="結合兩張圖，找出答案"><a href="#結合兩張圖，找出答案" class="headerlink" title="結合兩張圖，找出答案"></a>結合兩張圖，找出答案</h3><p>現在我們將兩張圖都執行完畢也得到結果了，那是時候進行合併了！要怎麼合併呢？我們只需要查詢 m1 的資料有沒有在 m2 裡面就可以了！</p>
<p>為甚麼只需要這樣做呢？是因為我們 m1,m2 分別存了兩張圖的所有組合，我們只要找出這兩張圖組合起來最大的值即可，所以不需要檢查前半圖某一的組合裡面的某幾行是否有跟後半圖的某幾行形成偶數，因為這樣就會是前半圖的另外一個組合選項，故此不用。</p>
<p>並且記錄最大配對數量與最多配對行的 hash 即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> resMask = <span class="number">0</span> , resCnt = <span class="number">0</span> ; <span class="comment">//resCnt 最大的配對數量</span></span><br><span class="line"><span class="comment">//resMask 紀錄我們用到的值，hash 狀態，方便我們之後透過位元為1的位數來回推用到的行數 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it : m1)&#123; <span class="comment">//不斷進行配對</span></span><br><span class="line">    <span class="keyword">if</span>(m2.count(it.first))&#123; <span class="comment">//找到適合的配對</span></span><br><span class="line">        x = (m2[it.first] &lt;&lt; div1) | it.second ; </span><br><span class="line">        <span class="comment">//(m2[it.first] &lt;&lt; div1) 我們先前存的資料行數是假設為這是一張獨立分開的圖，</span></span><br><span class="line">        <span class="comment">//因此現在我們進行合併，就要將資料行數返回題目原本正確的行數，因此幫她 &lt;&lt; div1 </span></span><br><span class="line">        <span class="keyword">if</span>(resCnt &lt; __builtin_popcount(x)) resCnt = __builtin_popcount(x) , resMask = x ;</span><br><span class="line">        <span class="comment">//如果有比當前配對最大數量還高時，我們就將 resCnt , resMask 換成現在的值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="hash-resMask"><a href="#hash-resMask" class="headerlink" title="hash resMask"></a>hash resMask</h3><p>這時候我們將記錄好的 resMask，解密成我們原本要的值，透過之前的表格可以得知，假如我們的 <code>resMask = 7</code>，則我們用到的行數則是 1,2,3，因此我們只需要將紀錄的 resMask 找出所有位數為 1 的值就能將值解密成功。</p>
<p>需要注意的是，在輸出時，每行的最後一個都必須是數字，而不是空格。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> flag = <span class="number">1</span> ; <span class="comment">//紀錄第一個值是否已經被印出</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; resCnt &lt;&lt; <span class="string">'\n'</span> ; <span class="comment">//印出最大配對數量</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>((resMask &gt;&gt; i) &amp; <span class="number">1</span>)&#123; <span class="comment">//判斷 i 位數是否為 1</span></span><br><span class="line">        <span class="keyword">if</span>(flag) <span class="built_in">cout</span> &lt;&lt; i+<span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; i+<span class="number">1</span> ;</span><br><span class="line">        flag = <span class="number">0</span> ; <span class="comment">//被輸出因此設成 0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h3><p>記住如果是要判斷字典是否有此值時請使用，<code>if(map.count(i))</code>，而不是<code>if(map[i])</code>，在現在的 UVa Judge 中，只有第一種可以被允許使用，第二種目前不行，因此請不要隨意亂使用</p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>老實講，難的不是雙向搜尋，而是位元運算阿…，特別是那個透過二進位加法來找出全部的組合真的是跟神一樣，這是我從來沒有想過的解決方案，讓我在這邊學到了，算是非常開心呢！雖然自學演算法真的是一件非常痛苦的事情，但學習成功的成就感以及能讓腦袋智力快速上升的感覺真的事非常痛快呢！</p>
<p>也希望我可以在比賽中成功使用到我所學習到的演算法，或是在生活中用到，那是再好不過的了！</p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://blog.csdn.net/sinat_36215255/article/details/78266381?utm_medium=distribute.pc_relevant.none-task-blog-searchFromBaidu-1.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-searchFromBaidu-1.control" target="_blank" rel="noopener">[UVA-1326] （暴力+位运算+中间相遇法）</a><br><a href="http://morris821028.github.io/2015/04/27/uva-1326/" target="_blank" rel="noopener">UVa 1326 - Jurassic Remains</a><br><a href="https://blog.csdn.net/keshuai19940722/article/details/18995013" target="_blank" rel="noopener">uva 1326 - Jurassic Remains(暴力+位运算+中间相遇法）</a></p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>其實就是沒有附上說明的程式碼，看得懂跟說得出來真的是兩回事，也許還有人覺得我說的很差，不過我已經盡力解釋。希望可以幫助到各位。</p>
<p>也希望大家想要學習的知識都可以快速學習而成，不要因為自身的環境不足而學習不到。</p>
<p>於是這裡就補述一些題目給的資料範圍限制與標頭檔了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 30</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="keyword">int</span> n , mark[MAXN] , x ;</span><br><span class="line"><span class="built_in">string</span> temp ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(mark,<span class="number">0</span>,<span class="keyword">sizeof</span>(mark));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; temp ;</span><br><span class="line">            x = <span class="number">0</span> ;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; temp.length() ; j++)</span><br><span class="line">                x ^= <span class="number">1</span> &lt;&lt; (temp[j] - <span class="string">'A'</span>);</span><br><span class="line">            mark[i] = x ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m1 , m2 ;</span><br><span class="line">        <span class="keyword">int</span> div1 = n/<span class="number">2</span> , div2 = n - n/<span class="number">2</span> ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; ( <span class="number">1</span> &lt;&lt;div1) ; i++ )&#123;</span><br><span class="line">            x = <span class="number">0</span> ;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; div1 ; j++ )&#123;</span><br><span class="line">                <span class="keyword">if</span>((i &gt;&gt; j ) &amp; <span class="number">1</span>) x ^= mark[j] ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!m1.count(x) || __builtin_popcount(m1[x]) &lt; __builtin_popcount(i) )</span><br><span class="line">                m1[x] = i ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; (<span class="number">1</span> &lt;&lt; div2) ; i++)&#123;</span><br><span class="line">            x = <span class="number">0</span> ;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; div2 ; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>((i &gt;&gt; j ) &amp; <span class="number">1</span>) x ^= mark[j + div1];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!m2.count(x) || __builtin_popcount(m2[x]) &lt; __builtin_popcount(i) )</span><br><span class="line">                m2[x] = i ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> resMask = <span class="number">0</span> , resCnt = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it : m1)&#123;</span><br><span class="line">            <span class="keyword">if</span>(m2.count(it.first))&#123;</span><br><span class="line">                x = (m2[it.first] &lt;&lt; div1) | it.second ;</span><br><span class="line">                <span class="keyword">if</span>(resCnt &lt; __builtin_popcount(x)) resCnt = __builtin_popcount(x) , resMask = x ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">1</span> ;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; resCnt &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((resMask &gt;&gt; i) &amp; <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(flag) <span class="built_in">cout</span> &lt;&lt; i+<span class="number">1</span> ;</span><br><span class="line">                <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; i+<span class="number">1</span> ;</span><br><span class="line">                flag = <span class="number">0</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="在寫-UVa-1326-的紙筆紀錄"><a href="#在寫-UVa-1326-的紙筆紀錄" class="headerlink" title="在寫 UVa 1326 的紙筆紀錄"></a>在寫 UVa 1326 的紙筆紀錄</h2><p>因為只是自己在思考過程中隨手做的筆記，覺得不是對讀者這麼有幫助，因此放在文章最下面。</p>
<p>有時候用想或用看的可能不太能夠懂這演算法，那就用寫的吧！這是大衛我自己學習的手稿，紀錄者我的學習過程。</p>
<p><img src="/images/UVa11475/2.jpg" alt=""></p>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>演算法知識</tag>
        <tag>雙向搜尋</tag>
        <tag>位元運算</tag>
      </tags>
  </entry>
  <entry>
    <title>人生規劃書 - 20201218</title>
    <url>/2020/12/18/life_experence/Life_Plan_20201218/</url>
    <content><![CDATA[<h2 id="說明"><a href="#說明" class="headerlink" title="說明"></a>說明</h2><blockquote>
<p>由於最近的自己一直沒辦法安下心來，不斷的充滿迷茫感，於是特地寫下我對於我人生的要求，之後再不斷進行修正或更改八。</p>
<p>如果用公司來比喻的話，那麼這家公司的目標、產業發展都不明確(自己的規劃)，而股東們都有自己的想法，公司提出來的版本都還沒有辦法讓每位股東願意信服、投資，因此讓每位股東對這家公司感到擔憂、不信任。</p>
</blockquote>
<a id="more"></a>

<h2 id="前提概要："><a href="#前提概要：" class="headerlink" title="前提概要："></a>前提概要：</h2><p>我在高一入學時，暑假作業有一個是要寫給三年後的自己的作業，有點類似於時光膠囊，只是他保證一定會在高三畢業還給你XD，我很謝謝那位有提出此想法的老師，他讓我更有深度、更有眼界。</p>
<p>在高一時候的我寫下了對自己的期望，現在的我還記得的就只剩下，有沒有考上台中科大、有沒有跟初戀和好，有沒有開開心心的？</p>
<h3 id="稍微來回顧一下"><a href="#稍微來回顧一下" class="headerlink" title="稍微來回顧一下"></a>稍微來回顧一下</h3><ul>
<li>有沒有考上中科呢？<br>不只考上了中科，甚至考上了北科，還對北科不滿足(<del>另類的貪心</del>)。但自己在高中付出了極大的努力，甚至可以說是燃燒生命八，我捨棄了我所愛的一切，就只為了讓自己達到此目標，個人認為代價似乎有點太大了。但整體而言是好的，有完成到</li>
<li>跟初戀和好嘛<br>老實說，沒有。<br>真的沒有，基本上我的高一難過都是因為我的初戀而難過，我那時候真的很喜歡他，我覺得我這個人最大的錯誤、最大的罪惡就是讓喜歡我的女生傷心離開。</li>
<li>有沒有開開心心的？<br>老實講，沒有。<br>我在高二的時候曾經被我們班的人陷害，他們讓我很難過一陣子，也讓我了解到霸凌的滋味，這是我第一次被霸凌，因此我從此之後就具有強大的正義，不允許別人欺負別人。<br>但也是因為他們的霸凌使我優秀了起來，因為他們欺負我，激發出我要離開此環境的慾望，讓我與隔壁班的建名合作參加科展與專題，之後努力學習程式得到了金手獎，因此送上北科。<br>我發現人都是現實的，但你的成就、名聲都比別人高時，基本上別人就不會瞧不起你，還會尊重你，當我陸續拿到許多獎項後，沒有人再欺負我，因為我的價值比他人高，這很不好。但我想這就是現實。</li>
</ul>
<h2 id="大二的自己"><a href="#大二的自己" class="headerlink" title="大二的自己"></a>大二的自己</h2><p>由於現在對未來的自己充滿期待也還怕失敗，於是乎我希望自己能夠給予每一個階段的自己信任這個由每一個階段的自己所構出來的人物，現在我要寫出一份關於目前的我對於未來的計劃，並在 2021 年 12 月再寫一次進行核對與檢討、修正，讓大三的自己來改進大二寫的企劃，或是完全重寫一次。</p>
<h2 id="人生規劃："><a href="#人生規劃：" class="headerlink" title="人生規劃："></a>人生規劃：</h2><h3 id="短期目標-大學結束前"><a href="#短期目標-大學結束前" class="headerlink" title="短期目標 - 大學結束前"></a>短期目標 - 大學結束前</h3><p>此短期目標比較具有可視性，我也比較知道如何去規劃，不至於有太大的變動，目前的主要想法如下：</p>
<ul>
<li>寫好演算法，拿到 ICPC 2021 銀獎<br>這目標是我的最主要目標，演算法是我的核心也是我成長的關鍵。寫好演算法等於我鞏固了我的所有知識與深度，因此我認為我需要被某個檢定或考試認可，ICPC 是我目前所知最大型、最重要的比賽之一，因此我需要拿到銀獎</li>
<li>投資股票，希望投資報酬可以來到 50% 1 年，目前預計本金是 10 萬<br>投資是很重要的課題，我相信是這樣的事情。透過投資可以有效利用財富來讓我去獲得世上更好的資源，希望能夠透過我未來學習到的知識幫助我在投資的路上更順，畢竟在世界上錢可以解決一定的壓力與紛爭，特此我需要學會投資來減輕我的壓力。</li>
<li>認識統計，類似 UVa 的題目來讓我練習<br>統計是我很需要學會的一件事情，到目前為止的人生中，我有太多的事情是值得被統計量化而我卻只是用文字帶過，當我學會了統計，我相信能夠更認識我自己，明白我自己的性格、優點、弱點。</li>
<li>找到一份薪水有 500 元的工作<br>老實講，這可能有點難完成。但我認為我需要這樣要求自己，因為當公司願意開給我 500 元的價值時表示我在社會上是一定有 500 元的價值，這是客觀認定。我需要透過客觀的認定來讓我知道社會中我是屬予那一塊的人，社會或企業有沒有需要我，我能夠透過一份工作的薪水來知道我在這間社會、產業是多麼重要或是不需要的人。</li>
<li>減肥，目標是 70 KG<br>我知道體重是我現在蠻大的一個缺點，我不瘦，我自認我沒有很胖，但我知道肥胖確實對身體不好，也會對於我的體力造成影響，因此我需要減肥，他對於我的人生各方面都有好處，只是我常將時間分配給上面的重點，而不會給減肥，因為我個人對於吃很要求，如果有好吃的食物會讓我在各方面開心許多，期許我會給予自己一些機會去運動、健身。透過在家健身的方式來讓自己的體態稍微棒些。</li>
<li>學會基本穿搭<br>我認為穿搭會讓我在社交時增加自信，在增加自信的同時我想會對於我在與他人交流時增加我意見的權重，我知道蠻多人再開會或是討論意見時，其實都不是對於這意見進行發表，而是先看是誰發表意見才來思考這意見是不是好意見，因此我把穿搭先學好，可以讓一些比較膚淺的人對於我不會有偏見，讓我在社會立足時會更好些。</li>
<li>讀好英文，多益能上 700<br>這應該比較不好達成，我是這麼認為的。因為我會將時間花在上面，可能對於英文不會那麼的重視，但姑且先放在這，讓明天的我可以來罵過去的自己XD。</li>
<li>讀好日文，檢定能上 N5<br>我相信這也很難達成，但我認為學會日文還蠻重要的，我很喜歡日本的事物，我蠻想要去多了解一下，透過學習他人國家的環境來讓我自身有所成長，我覺得這會是一個很好的學習歷程與機會，當然我需要去學習其他國家的語言，但以我目前的所在環境中，除了中文、英文，日文應該會是我最有動力學習的語言。</li>
</ul>
<h3 id="中期目標-研究所"><a href="#中期目標-研究所" class="headerlink" title="中期目標 - 研究所"></a>中期目標 - 研究所</h3><p>目前只希望自己可以考上台清交成，且是自己所喜歡的科目。如果能考上國外的研究所且比台清交成更好那是再好不過的。</p>
<p>因為我沒有辦法對於自己的中期目標看到方向，現在只能夠大概的描述方向，細節可能需要交給未來的我來規劃。</p>
<h3 id="長期目標-研究所畢業到-30-歲"><a href="#長期目標-研究所畢業到-30-歲" class="headerlink" title="長期目標 - 研究所畢業到 30 歲"></a>長期目標 - 研究所畢業到 30 歲</h3><ul>
<li>步入婚姻<ul>
<li>原因<br>婚姻是人生中重要的一件事情，雖然現在的我認為我還是很對不起喜歡過我的女生，但我認為我需要愛情，沒有愛情的我沒有辦法讓我自己找到安全感與立足點，因此我認為我需要一個愛情來滋潤我的生活，在我難過時給予我打氣、加油，讓我有勇氣再站起來。</li>
</ul>
</li>
<li>老婆要有的特質<ul>
<li>愛我<br>這很重要，沒有愛我哪來美滿的家庭，或許連家庭都稱不上。</li>
<li>溫柔<br>家庭應該要是我的後盾，我不允許家庭對待我是沒有尊嚴或尊重的，我的努力一定必須要在家庭中受到肯定，畢竟我的成長一定會等比例的給予家庭正面影響。如果失去了溫柔，那我很高機率不會喜歡家裡的失誤，導致我對家的責任失格。</li>
<li>會撒嬌<br>我需要被補充一些男子氣概，不可否認的，我在難過或失意時是非常脆弱的，如果這時候沒有一位女孩來撒嬌或安慰我，我很有可能會放棄我在此領域的研究或是要花很大的時間才能走出來，就像情傷一樣，我到現在還是沒有走出來。</li>
<li>長相我喜歡<br>一定是需要一位長相是我喜歡的人，這樣我才會回家時有種驕傲且幸福的感覺！我是視覺動物，還是需要視覺被滋潤的，不然當我上班永遠都是看到男生，整個價值觀會偏差的。</li>
<li>沒有重大病痛，至少要在我能夠接受的範圍內<br>這點是一定要遵守的，再好的女生也不可以有重大病痛，有重大病痛的女生在他發生關於性命的事件時，我是會擔憂到吃不下飯、睡不著覺的，要是他提前離開此世界那就等於我失去了世上最好的女生了，再讓我找一個我也會覺得自己對他很不負責任，為了我的自私，因此我不會跟重大病痛的女生組成家庭，我會害怕我哪天失去它，自從失去她的那天我就失去了我面對世界的勇氣。</li>
</ul>
</li>
</ul>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>希望每一個階段的我在不安心的時候都能想起來，大二的我有打此篇文章，透過閱讀大二的我來堅強自己內心，對自己充滿信心。我知道世界上的任何一件負面情緒都會對自己帶來受傷的心情，但我們要知道一件事情，我們都是大衞的一份子，如果我們被打倒了，那麼大衛就被打倒了，如果我們團結了，那麼大衛就團結了，如果我們成功了，那麼大衛就成功了。</p>
<p>只要我們一起努力，即使大衛沒有成為優秀的人，我們也會笑著說<strong>我們很棒吧</strong>，一同完成了這麼偉大的一件事情。</p>
]]></content>
      <categories>
        <category>人生旅途</category>
      </categories>
      <tags>
        <tag>大學Life</tag>
        <tag>人生旅途</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa118 - Mutant Flatworld Explorers (實作題)</title>
    <url>/2020/12/24/UVa/UVa118/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>我們命令機器人依照我們的指令在陸地上移動，如果機器人根據我們的指令跳入海裡時，那接下來的機器人會知道那邊是海，而不會執行我們的指令。</p>
<p>舉例：假如向前走會掉入海裡，那則不會執行命令</p>
<p>指令有向左轉與向右轉、往前走，一開始會給你地圖的右上角，之後就是每一個機器人與其需要執行的指令。</p>
<p>題目要求 由於是根據向量座標，於是往北走的座標則為 x,y+1 , 南(x,y-1) , 西(x-1,y) , 東(x+1,y)</p>
</blockquote>
<a id="more"></a>


<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>簡單的實作題，根據地圖的大小，以及其方向執行命令，然後我們透過 map 記住現在的機器人掉入海的方向與其 x,y 座標，如果接下來有其他機器人也碰到此情況就不執行指令，然後需要記住題目給定的座標方向QQ。(我沒看懂這座標方向浪費了一堆時間)。</p>
<p>需要記住的是只有<strong>向前走</strong>才會掉入海哩，所以轉向的指令都會被執行。</p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>嗚嗚，英文好難。</p>
<p>圖論搜尋的題目再給予向量座標時跟用二維陣列的表格差太多了，我習慣的北方是(x-1,y)，但她的卻是 (x,y+1)， 還有想太少XD，我漏想只有往前走在會掉入海裡，原本的程式碼只要轉向朝海就會被我不執行XDDD，太貼心了www。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 110</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">map</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;,<span class="keyword">int</span>&gt; mp_lost ;</span><br><span class="line"><span class="keyword">int</span> direct[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;&#125; ;</span><br><span class="line"><span class="keyword">int</span> n , m ; <span class="comment">// n,m is border and d is now direct</span></span><br><span class="line"><span class="keyword">int</span> sx , sy , tx , ty , d ; <span class="comment">//start x , start y ,</span></span><br><span class="line"><span class="built_in">string</span> ins , str_d; <span class="comment">//instruction</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; map_sd ;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="built_in">string</span>&gt; back_sd ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">in_grid</span><span class="params">(<span class="keyword">int</span> x , <span class="keyword">int</span> y , <span class="keyword">int</span> d  )</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; <span class="number">0</span> || x &gt; n )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">if</span>(y &lt; <span class="number">0</span> || y &gt; m )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> );</span><br><span class="line">    freopen(<span class="string">"out.txt"</span> , <span class="string">"w"</span> , <span class="built_in">stdout</span> );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ;</span><br><span class="line">    map_sd[<span class="string">'N'</span>] = <span class="number">0</span> ;</span><br><span class="line">    map_sd[<span class="string">'W'</span>] = <span class="number">1</span> ;</span><br><span class="line">    map_sd[<span class="string">'S'</span>] = <span class="number">2</span> ;</span><br><span class="line">    map_sd[<span class="string">'E'</span>] = <span class="number">3</span> ;</span><br><span class="line">    back_sd[<span class="number">0</span>] = <span class="string">"N"</span>;</span><br><span class="line">    back_sd[<span class="number">1</span>] = <span class="string">"W"</span>;</span><br><span class="line">    back_sd[<span class="number">2</span>] = <span class="string">"S"</span>;</span><br><span class="line">    back_sd[<span class="number">3</span>] = <span class="string">"E"</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; sx &gt;&gt; sy &gt;&gt; str_d )&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; ins ;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; ins &lt;&lt; '\n' ;</span></span><br><span class="line">        d = map_sd[str_d[<span class="number">0</span>]] ;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; ins.length() ; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ins[i] == <span class="string">'F'</span>)&#123;</span><br><span class="line">                tx = sx ;</span><br><span class="line">                ty = sy ;</span><br><span class="line">                sx += direct[d][<span class="number">0</span>] ;</span><br><span class="line">                sy += direct[d][<span class="number">1</span>] ;</span><br><span class="line">                pair&lt;int,int&gt; pa(tx,ty) ;</span><br><span class="line">                <span class="keyword">if</span>(in_grid(sx,sy,d) == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(mp_lost.count(pa))&#123; <span class="comment">//indicate past robot fell</span></span><br><span class="line">                        sx = tx ;</span><br><span class="line">                        sy = ty ;</span><br><span class="line">                        <span class="keyword">continue</span> ;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; tx &lt;&lt; <span class="string">' '</span> &lt;&lt; ty &lt;&lt; <span class="string">' '</span> &lt;&lt; back_sd[d] &lt;&lt; <span class="string">' '</span> &lt;&lt; <span class="string">"LOST"</span> &lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">                    mp_lost[pa] = <span class="number">1</span> ;</span><br><span class="line">                    flag = <span class="number">0</span> ;</span><br><span class="line">                    <span class="keyword">break</span> ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(ins[i] == <span class="string">'L'</span>) <span class="comment">//change direction</span></span><br><span class="line">                d = (d+<span class="number">4</span>+<span class="number">1</span>) % <span class="number">4</span> ;</span><br><span class="line">            <span class="keyword">if</span>(ins[i] == <span class="string">'R'</span>) <span class="comment">//change direction</span></span><br><span class="line">                d = (d+<span class="number">4</span><span class="number">-1</span>) % <span class="number">4</span> ;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; "i is : " &lt;&lt; sx &lt;&lt; ' ' &lt;&lt; sy &lt;&lt; ' ' &lt;&lt; back_sd[d] &lt;&lt; '\n' ;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; sx &lt;&lt; <span class="string">' '</span> &lt;&lt; sy &lt;&lt; <span class="string">' '</span> &lt;&lt; back_sd[d] &lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>Competitive Programming3</tag>
        <tag>實作題</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa280 - Vertex(DFS)</title>
    <url>/2020/12/24/UVa/UVa280/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>給你一張單向圖，寫一個程式，我們想詢問從 x 點進行搜尋會有哪些點是不會被搜尋到。</p>
<p>題目測資有點小麻煩，需要處理。</p>
</blockquote>
<a id="more"></a>

<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>標準的 DFS，基本上沒有難度的，需要注意的是要輸出的節點是未經過，所以要記錄下來。</p>
<p>需要特別注意的是一開始的點<strong>並不會被當作有經過</strong>，所以一開始的點不能被視為 visit。</p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>這應該是我覺得最簡單的題目之一，寫得好開心。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 200</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> visit[MAXN] , graph[MAXN][MAXN] ;</span><br><span class="line"><span class="keyword">int</span> n , len , sz , temp_n , temp_i ;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; record ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x )</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; i++ )&#123;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; i &lt;&lt; ' ' &lt;&lt; graph[x][i] &lt;&lt; '\n' ;</span></span><br><span class="line">        <span class="keyword">if</span>(graph[x][i] &amp;&amp; !visit[i])&#123;</span><br><span class="line">            visit[i] = <span class="number">1</span> ;</span><br><span class="line">            dfs(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> );</span><br><span class="line">    freopen(<span class="string">"out.txt"</span> , <span class="string">"w"</span> , <span class="built_in">stdout</span> );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n &amp;&amp; n )&#123;</span><br><span class="line">        <span class="built_in">memset</span>(graph,<span class="number">0</span>,<span class="keyword">sizeof</span>(graph));</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; temp_i &amp;&amp; temp_i )</span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; temp_n &amp;&amp; temp_n) graph[temp_i][temp_n] = <span class="number">1</span> ;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; len ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; len ; i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; temp_n ;</span><br><span class="line">            sz = <span class="number">0</span> ;</span><br><span class="line">            record.clear();</span><br><span class="line">            <span class="built_in">memset</span>(visit,<span class="number">0</span>,<span class="keyword">sizeof</span>(visit));</span><br><span class="line">            dfs(temp_n);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!visit[j])</span><br><span class="line">                    record.push_back(j);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; record.size() ;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> it : record )</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; it ;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>Competitive Programming3</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa318 - Domino Effect(Dijkstra)</title>
    <url>/2020/12/24/UVa/UVa318/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>Domino Effect 指一件事的發生會產生一連串的連鎖反應，但這不是我們的重點XD。</p>
<p>我們的重點就如題目，給你一張骨牌的圖，並告訴你<strong>關鍵點</strong>以及從此關鍵點到下一個關鍵點的<strong>秒數</strong>。然後我們想要推動其中一個關鍵點，來讓圖上所有的骨牌倒塌，想請問是在第幾秒的時候全部倒塌，在那一個<strong>關鍵點</strong>開始倒榻。</p>
<p>關鍵點: 可以影響到兩個骨牌以上的骨牌。<br>秒數的一個小提示，假如最後倒塌是從兩個關鍵點一起倒榻時則計算秒數方式如下 \(0.5(起點到關鍵點一 +  起點到關鍵點二 + 關鍵點一至關鍵點二)\)</p>
<p>這題的測試資料有個問題，最後一筆是只有一個 0，因此在判斷時，只要判斷 N 是否為 0 即可，如果全部都判斷反而會有錯誤(cin 的情況，因為我是用 cin )。</p>
</blockquote>
<a id="more"></a>

<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>這題有點小難，一開始的時候我不太懂這題需要使用到 Dijkstra，我想說應該是用洪水法去解出，但後來發現洪水法的話雖然一樣可以得出單緣最短路徑，但並不好寫，至少需要開兩張一樣大的圖，查網路上後知道這題用 Dijkstra 更好，要是沒有查的話可能會浪費時間寫，還要再重改八QQ。</p>
<p>用 adjecency matrix 會更好寫，如果用 Piority 來寫的話會發現其實沒有那麼好寫，思考邏輯會比較混亂，於是 Dijkstra 就用 adjecency matrix 寫。</p>
<p>我們先算出最長的最短路徑(找出最後一個骨牌落下的時間，並定義 max_path )，同時並記錄每一個關鍵點的最短路徑(跌落秒數)，再來我們透過 burte force 的方式將每一個連接邊去揣測，如果可以揣測出比 max_path 更大的跌落秒數就表示此骨牌應該是兩個關鍵點同時跌落而不是當最後一個點跌落結束全部都結束。</p>
<h2 id="參考來源"><a href="#參考來源" class="headerlink" title="參考來源"></a>參考來源</h2><p><a href="https://blog.csdn.net/mobius_strip/article/details/64440081" target="_blank" rel="noopener">UVa 318 - Domino Effect（zoj 1298</a><br><a href="http://celinechiu0809.blogspot.com/2015/05/uva318-domino-effect-dijkstra-single.html" target="_blank" rel="noopener">【UVa】318-Domino effect (Dijkstra, Single source shortest path)</a></p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 520</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> oo 1e20</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> kase=<span class="number">0</span> , N , M ;</span><br><span class="line"><span class="keyword">int</span> a , b , v , x , st , ed , flag , now   ;</span><br><span class="line"><span class="keyword">double</span> graph[MAXN][MAXN] ;</span><br><span class="line"><span class="keyword">int</span> used[MAXN] ;</span><br><span class="line"><span class="keyword">double</span> max_path , speed[MAXN] ; <span class="comment">//speed = start to each node shortest path </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line">    speed[<span class="number">1</span>] = <span class="number">0</span> ;</span><br><span class="line">    used[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    now = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= N ; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(graph[now][j] &amp;&amp; speed[j] &gt; graph[now][j] + speed[now] )&#123;</span><br><span class="line">                speed[j] = graph[now][j] + speed[now];</span><br><span class="line">                <span class="comment">//cout &lt;&lt; speed[j] &lt;&lt; '\n' ;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        max_path = oo ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= N ; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>( !used[j] &amp;&amp; max_path &gt; speed[j])&#123;</span><br><span class="line">                max_path = speed[j] ;</span><br><span class="line">                now = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; "i is " &lt;&lt; i &lt;&lt; ' ' &lt;&lt; now &lt;&lt; ' ' &lt;&lt; max_path &lt;&lt; '\n' ;</span></span><br><span class="line">        used[now] = <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> );</span><br><span class="line">    freopen(<span class="string">"out.txt"</span> , <span class="string">"w"</span> , <span class="built_in">stdout</span> );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M &amp;&amp; N )&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= N ; j++) graph[i][j] = <span class="number">0</span> ;</span><br><span class="line">            speed[i] = oo ;</span><br><span class="line">            used[i] = <span class="number">0</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= M ; i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; v ;</span><br><span class="line">            graph[a][b] = v ;</span><br><span class="line">            graph[b][a] = v ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        flag = <span class="number">0</span> ;</span><br><span class="line">        dijkstra() ;</span><br><span class="line">        max_path = speed[now];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span> ; j &lt;= N ; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(graph[i][j]  &amp;&amp;max_path &lt; <span class="number">0.5</span> * (speed[i] + speed[j] + graph[i][j]))&#123;</span><br><span class="line">                    max_path = <span class="number">0.5</span> * (speed[i] + speed[j] + graph[i][j]) ;</span><br><span class="line">                    st = i ;</span><br><span class="line">                    ed = j ;</span><br><span class="line">                    flag = <span class="number">1</span> ;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"System #"</span> &lt;&lt; ++kase &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="number">1</span> )&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"The last domino falls after "</span> &lt;&lt; fixed &lt;&lt; setprecision(<span class="number">1</span>) &lt;&lt; max_path</span><br><span class="line">             &lt;&lt; <span class="string">" seconds, between key dominoes "</span> &lt;&lt; st &lt;&lt;<span class="string">" and "</span> &lt;&lt; ed &lt;&lt; <span class="string">"."</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"The last domino falls after "</span> &lt;&lt; fixed &lt;&lt; setprecision(<span class="number">1</span>) &lt;&lt; max_path &lt;&lt; <span class="string">" seconds, at key domino "</span> &lt;&lt; now &lt;&lt; <span class="string">"."</span> ;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"\n\n"</span> ;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>Dijkstra&#39;s</tag>
        <tag>程式解題</tag>
        <tag>Competitive Programming3</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa614 - Mapping the Route(DFS)</title>
    <url>/2020/12/24/UVa/UVa614/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>給予一張地圖，再給你起點與終點，我們想要你輸出透過<strong>題目規定的 DFS</strong>，畫出一張圖。<br>測試資料則會給予每一個節點來給定南邊或東邊的牆是否存在。</p>
<p>題目規定的 DFS:必須依序 西、北、東、南的方式遍地</p>
<p>輸出規定 </p>
<ul>
<li>如果是有經歷過的節點但卻不是從起點至終點的路徑時，輸出 “???”</li>
<li>沒有經歷過的節點，也不是起點到終點的路徑，輸出 “   “</li>
<li>如果是起點至終點的路徑就輸出從起點開始的第幾個節點</li>
<li>左邊的牆輸出 ‘|’，右邊的牆輸出 “—“</li>
</ul>
</blockquote>
<a id="more"></a>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>輸出好難，他是在考你輸出八 = =。</p>
<p>由於這題是使用<strong>邊</strong>來判定有沒有連結，而不是透過<strong>點至點</strong>，而讓整個程式難寫許多，透過兩個陣列 graph 地圖狀態、record 從起點到終點的路徑。</p>
<p>幾個地方需要注意：如下</p>
<ul>
<li>我們透過回推的方式判斷，假如 x,y 西邊有牆，也就代表 x,y-1 的東邊有牆，透過此方次來回推西邊或北邊是否有牆即可，以及要注意邊界問題。</li>
<li>我們都先假設我們的搜尋(record 陣列紀錄)是對的，所以當前的 record x,y = 上一個 record x,y+1，如果不對再改為 -1 </li>
<li>要判斷邊界</li>
<li>輸出也要注意，他是3位為一道牆，因此如果數值位數沒有大於 3，就需要在左邊補上空白，如果是用 cout 就需要補上 <code>set(3) &lt;&lt; right</code>。</li>
<li>再來需要透過 flag 來判斷是否有成功抵達終點，如果沒有成功抵達終點則起點也會是 “???”，因為他不是從起點到終點的路徑。<br>function <code>row_wall()</code></li>
<li>定義一個陣列 south_wall 來判斷 x,y 的南邊是否有牆，才可以在輸出時正確輸出。</li>
<li>走過，但並不是路徑的則將 <code>record[x][y] = -1</code>，在輸出時才可以正確知道此處為 “???”<br>dfs 處每一個遞迴的下一行處，但需要先判斷 flag，來得知這路徑是否為起點到終點的路徑，不是才符合此條件</li>
</ul>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>這題的輸出才是最難的問題吧…，UVA 是不是認為這種類型的題目都不難因此都特地出一些很難的輸出格式來考大家的反應能力壓QQ，而且我最近在挑戰寫程式的過程中不用紙筆，發現很難、而且下次看到程式碼的時候還需要很多時間去重新理解、思考。我原先以為如果不用紙筆輔助思考會讓腦袋的印相加深，但似乎是不對的QQ。</p>
<p>然後英文還是需要加強，英文還是有點太爛了….。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 15</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> graph[MAXN][MAXN] ;</span><br><span class="line"><span class="keyword">int</span> record[MAXN][MAXN] ;</span><br><span class="line"><span class="keyword">int</span> direct[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">int</span> south_wall[MAXN] ;</span><br><span class="line"><span class="keyword">int</span> sx , sy , N , M , ex , ey ;</span><br><span class="line"><span class="keyword">int</span> a , kase = <span class="number">0</span> , flag = <span class="number">0</span> ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isboard</span><span class="params">(<span class="keyword">int</span> x , <span class="keyword">int</span> y , <span class="keyword">int</span> i )</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(x + direct[i][<span class="number">0</span>] &gt; N || x + direct[i][<span class="number">0</span>] &lt; <span class="number">1</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">if</span>(y + direct[i][<span class="number">1</span>] &gt; M || y + direct[i][<span class="number">1</span>] &lt; <span class="number">1</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; x + direct[i][0] &lt;&lt; ' ' &lt;&lt; y + direct[i][1] &lt;&lt; ' ' &lt;&lt; N &lt;&lt; ' ' &lt;&lt; M  &lt;&lt; '\n' ;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x , <span class="keyword">int</span> y )</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ox , oy   ;</span><br><span class="line">    ox = x ;</span><br><span class="line">    oy = y ;</span><br><span class="line">    <span class="keyword">if</span> (x == ex &amp;&amp; y == ey) &#123;</span><br><span class="line">        flag = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(isboard(x,y,<span class="number">0</span>) )&#123; <span class="comment">//west</span></span><br><span class="line">        x = ox + direct[<span class="number">0</span>][<span class="number">0</span>] ;</span><br><span class="line">        y = oy + direct[<span class="number">0</span>][<span class="number">1</span>] ;</span><br><span class="line">        <span class="keyword">if</span>(record[x][y] == <span class="number">0</span> &amp;&amp; (graph[x][y] == <span class="number">2</span> || graph[x][y] == <span class="number">0</span>))&#123;</span><br><span class="line">            record[x][y] = record[ox][oy] + <span class="number">1</span> ;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; y &lt;&lt; " west" &lt;&lt; '\n' ;</span></span><br><span class="line">            dfs(x,y);</span><br><span class="line">            <span class="keyword">if</span>(flag) <span class="keyword">return</span> ;</span><br><span class="line">            record[x][y] = <span class="number">-1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(isboard(x,y,<span class="number">1</span>))&#123; <span class="comment">//north</span></span><br><span class="line">        x = ox + direct[<span class="number">1</span>][<span class="number">0</span>] ;</span><br><span class="line">        y = oy + direct[<span class="number">1</span>][<span class="number">1</span>] ;</span><br><span class="line">        <span class="keyword">if</span>(record[x][y] == <span class="number">0</span> &amp;&amp; (graph[x][y] == <span class="number">1</span> || graph[x][y] == <span class="number">0</span>))&#123;</span><br><span class="line">            record[x][y] = record[ox][oy] + <span class="number">1</span> ;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; y &lt;&lt; " north" &lt;&lt; '\n' ;</span></span><br><span class="line">            dfs(x,y);</span><br><span class="line">            <span class="keyword">if</span>(flag) <span class="keyword">return</span> ;</span><br><span class="line">            record[x][y] = <span class="number">-1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(isboard(ox,oy,<span class="number">2</span>) )&#123;<span class="comment">//east</span></span><br><span class="line">        x = ox + direct[<span class="number">2</span>][<span class="number">0</span>] ;</span><br><span class="line">        y = oy + direct[<span class="number">2</span>][<span class="number">1</span>] ;</span><br><span class="line">        <span class="keyword">if</span>(record[x][y] == <span class="number">0</span> &amp;&amp; (graph[ox][oy] == <span class="number">2</span> || graph[ox][oy] == <span class="number">0</span>))&#123;</span><br><span class="line">            record[x][y] = record[ox][oy] + <span class="number">1</span> ;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; y &lt;&lt; " east" &lt;&lt; '\n' ;</span></span><br><span class="line">            dfs(x,y);</span><br><span class="line">            <span class="keyword">if</span>(flag) <span class="keyword">return</span> ;</span><br><span class="line">            record[x][y] = <span class="number">-1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(isboard(ox,oy,<span class="number">3</span>))&#123;<span class="comment">//south</span></span><br><span class="line">        x = ox + direct[<span class="number">3</span>][<span class="number">0</span>] ;</span><br><span class="line">        y = oy + direct[<span class="number">3</span>][<span class="number">1</span>] ;</span><br><span class="line">        <span class="keyword">if</span>(record[x][y] == <span class="number">0</span> &amp;&amp; (graph[ox][oy] == <span class="number">1</span> || graph[ox][oy] == <span class="number">0</span> ))&#123;</span><br><span class="line">            record[x][y] = record[ox][oy] + <span class="number">1</span> ;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; y &lt;&lt; " south" &lt;&lt; '\n' ;</span></span><br><span class="line">            dfs(x,y);</span><br><span class="line">            <span class="keyword">if</span>(flag) <span class="keyword">return</span> ;</span><br><span class="line">            record[x][y] = <span class="number">-1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">row_wall</span><span class="params">( )</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= M ; i++)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"+"</span> ;</span><br><span class="line">        <span class="keyword">if</span>(south_wall[i])&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"---"</span> ;</span><br><span class="line">            south_wall[i] = <span class="number">0</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"   "</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"+\n"</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Maze "</span> &lt;&lt; ++kase &lt;&lt; <span class="string">"\n\n"</span> ;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; flag &lt;&lt; '\n' ;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= M ; i++) south_wall[i] = <span class="number">1</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(flag == <span class="number">0</span> ) record[sx][sy] = <span class="number">-1</span> ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; i++)&#123;</span><br><span class="line">        row_wall();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">'|'</span> ;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; M &lt;&lt; '\n' ;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= M ; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(record[i][j] == <span class="number">-1</span>)</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"???"</span> ;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(record[i][j] &gt; <span class="number">0</span>)</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; setw(<span class="number">3</span>) &lt;&lt; right &lt;&lt; record[i][j] ;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"   "</span> ;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(j == M || graph[i][j] == <span class="number">1</span> || graph[i][j] == <span class="number">3</span>)</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"|"</span> ;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> ;</span><br><span class="line">            <span class="keyword">if</span>(graph[i][j] == <span class="number">2</span> || graph[i][j] == <span class="number">3</span>)</span><br><span class="line">                south_wall[j] = <span class="number">1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= M ; i++) south_wall[i] = <span class="number">1</span> ;</span><br><span class="line">    row_wall();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\n\n"</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> );</span><br><span class="line">    freopen(<span class="string">"out.txt"</span> , <span class="string">"w"</span> , <span class="built_in">stdout</span> );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M &gt;&gt; sx &gt;&gt; sy &gt;&gt; ex &gt;&gt; ey &amp;&amp; N)&#123;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; N &lt;&lt; ' ' &lt;&lt; M &lt;&lt; ' ' &lt;&lt; sx &lt;&lt; ' ' &lt;&lt; sy &lt;&lt; '\n' ;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= M ; j++)&#123;</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; a ;</span><br><span class="line">                graph[i][j] = a ;</span><br><span class="line">                record[i][j] = <span class="number">0</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        flag = <span class="number">0</span> ;</span><br><span class="line">        record[sx][sy] = <span class="number">1</span> ;</span><br><span class="line">        dfs(sx,sy);</span><br><span class="line">        output();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>Competitive Programming3</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa824 - Coast Tracker(實作)</title>
    <url>/2020/12/24/UVa/UVa824/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>我們寫 GPS 的一小部分功能，給予一張圖，地圖上只有陸地與海，我們只能走陸地且要沿著海岸線走，我們透過逆時鐘方向進行搜尋，找出下一個節點是我們可以走的方向，輸出下一個節點可以走的方向位置</p>
<p>方向位置圖如下:<br><img src="https://i.imgur.com/i6ufysm.png" alt=""></p>
<p>需要注意的是，我們是根據上一個節點的方向開始逆時鐘，而不是每次都是從上一張圖的 1 開始。<br>　座標則是像我們畫方程式的座標相同，也就是北(x,y+1)，左上(-1,1)…以此類推，<strong>與平常不同</strong>。</p>
</blockquote>
<a id="more"></a>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>這題的邏輯跟我腦袋想的不太一樣啊…，讓我腦袋打結了QQ，我好笨。</p>
<p>這題有個地方比較酷，他是給你當前的方向，但你不可以直接使用當前方向直接進行逆時鐘搜尋，看下面的圖</p>
<blockquote>
<p><img src="https://i.imgur.com/wDlQiOi.png" alt=""></p>
</blockquote>
<p>你會發現，他的搜尋方向是 1，是因為他的上一個位置是 6，再來透過逆時鐘搜尋 7,0 都是海洋所以不可以往那方向走，但是 1 就是陸地所以可以往那方向走，所以搜尋位置就要從反向的位置 +1，來進行搜尋。</p>
<p>也就是上上面那張圖誤導了大家wwww，或是英文變不好QQ。</p>
<p>這裡我有用一個比較特別的寫法是我將陸地變成 1，海洋變成 2，這樣再透過 map 實作時會更加方便些，然後要記住上一個位置一定會是陸地，但這題是可以往回走的(不過是最後一個選擇)，需要特別注意。</p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>這題好吃 2D 邏輯與方向感，在我不願意透過紙筆來輔助時則發現我常常將一樣的邏輯重複思考，有點笨欸www，需要將英文再複習，我也透過了這題目將 2D 的邏輯與方向感變好，感覺好棒，學了好多東西呢，也要在將邏輯弄得夠清晰。<br>ε٩(๑&gt; ₃ &lt;)۶з。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pos 8</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> direct[pos][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">1</span>&#125;&#125; ;</span><br><span class="line"><span class="keyword">int</span> counter_direct[] = &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125; ;</span><br><span class="line"><span class="built_in">map</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;,<span class="keyword">int</span>&gt; record;</span><br><span class="line"><span class="keyword">int</span> x , y , d , a , b , c ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> );</span><br><span class="line">    <span class="comment">//freopen("out.txt" , "w" , stdout );</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y &gt;&gt; d &amp;&amp; x != <span class="number">-1</span>)&#123;</span><br><span class="line">        record.clear();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; pos ; i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c ;</span><br><span class="line">            record[make_pair(a,b)] = c ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ox , oy , r ;</span><br><span class="line">        ox = x ; oy = y ;</span><br><span class="line">        r = counter_direct[d];</span><br><span class="line">        <span class="comment">//record[make_pair(x+direct[r][0],y+direct[r][1])] = 0;</span></span><br><span class="line">        <span class="comment">//cout &lt;&lt; "r is " &lt;&lt; x+direct[r][0] &lt;&lt; ' ' &lt;&lt; y+direct[r][1] &lt;&lt; '\n' ;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= pos ; i++)&#123;</span><br><span class="line">            d = (r+i) % <span class="number">8</span> ;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; "r is " &lt;&lt; r &lt;&lt; '\n' ;</span></span><br><span class="line">            x = ox + direct[d][<span class="number">0</span>] ;</span><br><span class="line">            y = oy + direct[d][<span class="number">1</span>] ;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; y &lt;&lt; '\n' ;</span></span><br><span class="line">            <span class="keyword">if</span>(record[make_pair(x,y)] == <span class="number">1</span> )&#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; d &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">                <span class="keyword">break</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>Competitive Programming3</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa168 - Theseus and the Minotaur (DFS)</title>
    <url>/2020/12/24/UVa/Uva168/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>英雄要捕捉牛頭怪，牛頭怪怕光也怕英雄，給你一張圖(有節點與邊)，英雄可以在 K 步後的節點蠟燭，這樣牛頭人就不會在往那通道走，總有一天英雄會抓到牛頭人，我們想請問牛頭人最後走到哪裡就無路可走。</p>
<p>牛頭人走路有順序性，一定會先走<strong>字典序</strong>最小的值，但不會回頭走。<br>英雄一開始一定在牛頭人旁邊的節點，也就是英雄與牛頭人的距離只有 1 (只有一個邊)。</p>
<p>題目輸入極其難受，請仔細思考<br>P.S. 注意 K 沒有限制，想要多大都可以，但基本上可以不需要在意這個問題。</p>
</blockquote>
<a id="more"></a>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>這裡主要有兩點需要特別注意，由於 K 數字沒有極限，但是這題目的 K 基本上暴力是可以通過，不需要做 mod，但如果要 mod 就會變成 NP 問題，雖然 mod 出來的數字與 K 相同，但是<strong>英雄的位置則不一定相同</strong>，回推就會不同，輸出的路徑也就不一定相同。</p>
<p>基本上就是紀錄遇到 K 時就紀錄這個節點，直到沒辦法再繼續 DFS 時最後的那個節點就是牛頭人無處可逃的地方，但是需要記得一件事情因為 K 沒有限制，但遞迴最多只能向下深層 9998，再往下就會 stack overflow(不是你想的那個論壇，就實際上的名字)，因此要將遞迴 DFS 改成迴圈 DFS，也就是把繼續遞迴的地方改成 break 模擬遞迴。 </p>
<h3 id="輸入格式"><a href="#輸入格式" class="headerlink" title="輸入格式"></a>輸入格式</h3><p>由於題目的輸入格式與眾不同，是 A 節點配上 ‘:’(冒號) 在加上後面全部的所有字元，假設 <code>A:BCD</code>，那就是 A 連接 B ,A 連接 C,A 連接 D。</p>
<p>我的想法是先將前面那行輸入成 String，接下來則用 flag 當作標誌</p>
<ul>
<li>flag = 0<br>表示讀到 ‘:’(冒號)，因此我們找 ‘:’(冒號) 的前一字元即可，同時將 flag = 1，由於題目有說明一個節點只會有英文字母才能這樣做</li>
<li>flag = 1<br>為 ‘:’(冒號) 後面的所有的值，因此將 <code>vector[A].push_back(b)</code>，b 為 : 後的所有值</li>
<li>讀到  ‘.’(句號) 或 ‘;’(分號)<br>讀到 ‘.’(句號) 或 ‘;’(分號)  這裡時，就換成下一個 A 節點，因此 flag 設 0 換設定下一個節點與其他節點的連結</li>
</ul>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 300</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN_Alpha 27</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">string</span> strQ  ;</span><br><span class="line"><span class="keyword">char</span> strM , strT ;</span><br><span class="line"><span class="keyword">int</span> M , T , K , ans , cnt ; <span class="comment">//cnt is all of use letter</span></span><br><span class="line"><span class="keyword">int</span> flag , nx , ny; <span class="comment">//nx nodex ny nodey</span></span><br><span class="line"><span class="keyword">int</span> visit[MAXN];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; record ;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path[MAXN_Alpha] ;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> m , <span class="keyword">int</span> t , <span class="keyword">int</span> k )</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        flag = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span> )&#123; </span><br><span class="line">            visit[t] = <span class="number">1</span> ;</span><br><span class="line">            record.push_back(t) ;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; "candle is " &lt;&lt; (char)(t+'A') &lt;&lt; '\n' ;</span></span><br><span class="line">            k = K ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; "m is " &lt;&lt; (char)(m+'A') &lt;&lt; '\n' ;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it : path[m])&#123; <span class="comment">//DFS</span></span><br><span class="line">            <span class="keyword">if</span>((visit[it] == <span class="number">0</span> &amp;&amp; it != t) )&#123; <span class="comment">// recursive -&gt; break</span></span><br><span class="line">                <span class="comment">//cout &lt;&lt; i &lt;&lt; '\n' ;</span></span><br><span class="line">                flag = <span class="number">0</span> ;</span><br><span class="line">                t = m ;</span><br><span class="line">                m = it ;</span><br><span class="line">                k-- ;</span><br><span class="line">                <span class="keyword">break</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> );</span><br><span class="line">    freopen(<span class="string">"out.txt"</span> , <span class="string">"w"</span> , <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; strQ &amp;&amp; strQ != <span class="string">"#"</span>)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; strM &gt;&gt; strT &gt;&gt; K ;</span><br><span class="line">        T = strT - <span class="string">'A'</span> ;</span><br><span class="line">        M = strM - <span class="string">'A'</span> ;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; T &lt;&lt; ' ' &lt;&lt; M &lt;&lt; ' ' &lt;&lt; K &lt;&lt; '\n' ;</span></span><br><span class="line">        flag = <span class="number">0</span>;</span><br><span class="line">        cnt = <span class="number">0</span> ;</span><br><span class="line">        <span class="built_in">memset</span>(visit,<span class="number">0</span>,<span class="keyword">sizeof</span>(visit));</span><br><span class="line">        record.clear();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; MAXN_Alpha ; i++)</span><br><span class="line">            path[i].clear();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; strQ.length() ; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(flag == <span class="number">0</span> &amp;&amp; strQ[i] == <span class="string">':'</span>)&#123;</span><br><span class="line">                cnt ++;</span><br><span class="line">                nx = strQ[i<span class="number">-1</span>] - <span class="string">'A'</span> ;</span><br><span class="line">                flag = <span class="number">1</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(strQ[i] == <span class="string">'.'</span> || strQ[i] == <span class="string">';'</span>)&#123;</span><br><span class="line">                flag = <span class="number">0</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(flag == <span class="number">1</span> )&#123;</span><br><span class="line">                ny = strQ[i] - <span class="string">'A'</span> ;</span><br><span class="line">                path[nx].push_back(ny);</span><br><span class="line">                <span class="comment">//cout &lt;&lt; "edge is " &lt;&lt; nx &lt;&lt; ' ' &lt;&lt; ny &lt;&lt; '\n' ;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//K %= cnt ;</span></span><br><span class="line">        <span class="comment">//if(K == 0 ) K = cnt ;</span></span><br><span class="line">        ans = dfs(M,T,K);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it : record )</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; (<span class="keyword">char</span>)( <span class="string">'A'</span> + it) &lt;&lt; <span class="string">' '</span> ;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">'/'</span> &lt;&lt; (<span class="keyword">char</span>)( <span class="string">'A'</span> + ans) &lt;&lt; <span class="string">'\n'</span>  ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>Competitive Programming3</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa10055 - Hashmat the Brave Warrior (水題)</title>
    <url>/2020/12/27/UVa/UVa10055/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>勇敢的戰士要作戰，他們知道對方的士兵數量以及我方的士兵數量，他們想要知道對方與我方的差額是多少。</p>
<p>輸出不會大於 \(2^{32}\) </p>
</blockquote>
<a id="more"></a>

<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>水到不行，英文又簡單。真的香。</p>
<p>就兩個數字減法即可。</p>
<h2 id="重點觀念："><a href="#重點觀念：" class="headerlink" title="重點觀念："></a>重點觀念：</h2><ul>
<li>題目只有說輸出不會大於 \(2^{32}\) ，沒有說資料不會超過，所以記得要開 long long<br>有個小偷懶步驟，可以把 long long define 成 int，接著再將 main 前面的 int 換成 int32_t，就可以無痛轉移 long long XD。</li>
</ul>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>題目真水，英文又簡單。應該多出這點題目XD，這樣那些聰明人看起來就跟我一樣笨www。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> N , M ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> );</span><br><span class="line">    freopen(<span class="string">"out.txt"</span> , <span class="string">"w"</span> , <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">abs</span>(N-M) &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>水題</tag>
        <tag>UVa</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa10077 - The Stern-Brocot Number System (二分搜尋)</title>
    <url>/2020/12/27/UVa/UVa10077/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>The Stern-Brocot tree 能夠完美的建構出沒有任何一個負分數，且 n 與 m 絕對互質，也就表示產生的值絕對不會有重複。</p>
<p>現在給你 The Stern-Brocot tree 其中一個值，我們想詢問透過 The Stern-Brocot tree 的方式，那它的位置在哪裡？透過 R and F 描述</p>
<p>舉例： 找出 \(\frac{3}{1}\)，那就是 RR 。</p>
</blockquote>
<a id="more"></a>

<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>這題考的是腦筋急轉彎，問你會不會運用自身所學的知識。</p>
<p>其實這題就是二分搜尋，只是他將規則稍微改變。<br>但如果你可以從中得出結論你可以發現，數字的左邊值一定比中間的數字小，反之，右邊則會比中間數字大。</p>
<p>只要透過此規則進入左邊輸入 L、右邊輸入 R 就是答案了。</p>
<p>圖示：</p>
<blockquote>
<p><img src="https://i.imgur.com/AaPrjHo.png" alt=""></p>
</blockquote>
<h2 id="重點觀念："><a href="#重點觀念：" class="headerlink" title="重點觀念："></a>重點觀念：</h2><ul>
<li>在判斷的時候因為有分子與分母要判斷，必須兩個都同時等於才跳出迴圈，因此 <code>(b1 != d1 &amp;&amp; b1 != d2)</code> 這邏輯是錯誤的，錯誤舉例：b1 = 1 , b2 = 2 , d1 = 1 , d2 = 3。因此要改變下，變成 <code>!(b1 == d1 &amp;&amp; b2 == d2)</code> 即可。</li>
<li>int 在相除時出來的數字還是 int，因此需要將兩個數字都先轉成 float 再進行除法才會得出小數。<br>舉例：<code>double r = (float)b1 / (float)b2</code></li>
<li>不要強轉型態，會很花時間，向第二個重點的寫法，就會導致超時，因此要將這兩個額外拉出宣告兩個小數點變數。</li>
</ul>
<h2 id="變數命名"><a href="#變數命名" class="headerlink" title="變數命名"></a>變數命名</h2><ul>
<li>int <ul>
<li>a1 , a2<br>左邊的值</li>
<li>b1 , b2<br>中間的值</li>
<li>c1 , c2<br>右邊的值</li>
<li>d1 , d2<br>題目需要找到的值</li>
</ul>
</li>
<li>double<ul>
<li>compute_b , compute_d<br>計算大小用</li>
<li>d_b1 , d_b2 , d_d1 , d_d2<br>計算 b and d  的值，強轉型態會浪費時間因此拉出 double 宣告</li>
</ul>
</li>
</ul>
<h2 id="參考來源"><a href="#參考來源" class="headerlink" title="參考來源"></a>參考來源</h2><p><a href="http://programming-study-notes.blogspot.com/2014/01/uva-10077-stern-brocot-number-system.html" target="_blank" rel="noopener">Programming學習筆記 - UVa 10077 The Stern-Brocot Number System</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>這題目真的好棒啊，我被她考到我卻一點怨言都沒有，出這題目的人是天才八，把我玩弄得心服口服，可惡，我學起來了，下次不會再犯了。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a1=<span class="number">0</span> , a2=<span class="number">1</span> , b1=<span class="number">1</span> , b2=<span class="number">1</span> , c1=<span class="number">1</span> , c2=<span class="number">0</span> ;</span><br><span class="line"><span class="keyword">int</span> d1 , d2 , t1 , t2 ;</span><br><span class="line"><span class="keyword">double</span> compute_b , compute_d , d_b1 , d_b2 , d_d1 , d_d2 ;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bs</span><span class="params">()</span></span>&#123; <span class="comment">//binary search</span></span><br><span class="line">    a1 = <span class="number">0</span> ; a2 = <span class="number">1</span> ;</span><br><span class="line">    b1 = <span class="number">1</span> ; b2 = <span class="number">1</span> ;</span><br><span class="line">    c1 = <span class="number">1</span> ; c2 = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">while</span>(!(b1 == d1 &amp;&amp; b2 == d2))&#123;</span><br><span class="line">        d_b1 = b1 ; d_b2 = b2 ;</span><br><span class="line">        d_d1 = d1 ; d_d2 = d2 ;</span><br><span class="line">        compute_b = d_b1 / d_b2 ;</span><br><span class="line">        compute_d = d_d1 / d_d2 ;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; compute_b &lt;&lt; ' ' &lt;&lt; compute_d &lt;&lt; '\n' ;</span></span><br><span class="line">        <span class="keyword">if</span>(compute_d &gt; compute_b )&#123; <span class="comment">//great than</span></span><br><span class="line">            a1 = b1 ; a2 = b2 ;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"R"</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123; <span class="comment">//less than</span></span><br><span class="line">            c1 = b1 ; c2 = b2 ;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"L"</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        b1 = a1 + c1 ;</span><br><span class="line">        b2 = a2 + c2 ;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; "a is " &lt;&lt; a1 &lt;&lt; '/' &lt;&lt; a2 &lt;&lt; '\n' ;</span></span><br><span class="line">        <span class="comment">//cout &lt;&lt; "b is " &lt;&lt; b1 &lt;&lt; '/' &lt;&lt; b2 &lt;&lt; '\n' ;</span></span><br><span class="line">        <span class="comment">//cout &lt;&lt; "c is " &lt;&lt; c1 &lt;&lt; '/' &lt;&lt; c2 &lt;&lt; '\n' ;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> );</span><br><span class="line">    freopen(<span class="string">"out.txt"</span> , <span class="string">"w"</span> , <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; d1 &gt;&gt; d2 &amp;&amp; d1 + d2 != <span class="number">2</span> )&#123;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; d1 &lt;&lt; ' ' &lt;&lt; d2 &lt;&lt; '\n' ;</span></span><br><span class="line">        bs();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>Binary Search 二分搜尋</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa10071 - Back to High School Physics (水題)</title>
    <url>/2020/12/28/UVa/UVa10071/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>有一個飛天粒子有初始速度與加速度，我們給你 t 秒的速度，想請問 2t 秒後的位置是多少</p>
<p>P.S. 謝謝立委翻譯</p>
</blockquote>
<a id="more"></a>

<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>水到不行，靠公式即可www。</p>
<p>公式：\(距離 = 速度 * 時間 * 倍率\)，這裡的倍率是 2。</p>
<h2 id="參考來源"><a href="#參考來源" class="headerlink" title="參考來源"></a>參考來源</h2><ul>
<li>立委翻譯支援</li>
</ul>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>這題 cetain time(一定時間)，讓我納悶了很久，幸好有立委幫我翻譯我就解出來，這題不難，相信大家都會的！</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> u , v  ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> );</span><br><span class="line">    freopen(<span class="string">"out.txt"</span> , <span class="string">"w"</span> , <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; u * v * <span class="number">2</span> &lt;&lt; <span class="string">'\n'</span>  ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>水題</tag>
        <tag>UVa</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa10281 - Back to High School Physics (實作題)</title>
    <url>/2020/12/28/UVa/UVa10281/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>有台汽車的里程數壞掉了，於是我們手動拿上碼表 + 定速開車，想詢問每次我們標記的時間時已經行駛了多少公里。</p>
</blockquote>
<a id="more"></a>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>毒，到處都是毒。這題是大毒阿，快逃RRRR</p>
<p>很簡單的操作題，先將所有的時間換成秒數，之後再乘以速度，但這裡的速度是 km/hr，因此要在除以 3600 就是答案。</p>
<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li>這題如果要使用 cin，會非常難寫，建議使用 scanf<br>因為你沒辦法知道他到底這次有沒有要加速或是詢問你當前的距離</li>
<li>如果習慣 <code>#define int long long</code> 記住使用 scanf 要搭配 <code>%lld</code></li>
<li>windows 情況下，double 有機率無法被 scanf 用到，毒，這是毒阿。<br><a href="https://stackoverflow.com/questions/30950834/scanf-gcc-for-long-double" target="_blank" rel="noopener">scanf GCC for long double [duplicate]</a></li>
<li>有可能他連續加速兩次，因此計算里程數時不可以等到要查詢碼表時間是在算，必須每次都要算，<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;舉例</span><br><span class="line">00:00:01 12</span><br><span class="line">00:00:03 24</span><br></pre></td></tr></table></figure></li>
<li>任何一個計算公式都不可以有 int 與 float 運算出現，不然會高機率出錯。因此建議不用</li>
</ul>
<h2 id="參考來源"><a href="#參考來源" class="headerlink" title="參考來源"></a>參考來源</h2><p>齊笎編寫的 hackmd 詳解 </p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>這題滿滿的都是坑阿…，我最不擅長寫關於小數點的題目了，希望以後遇到小數點的題目都可以安然度過。這次的 scanf 不能輸入 double 我花了 2 小時去想真的是太難過了…，不過齊笎介紹使用的 sscanf 到蠻好用的，值的紀錄。</p>
<p>可以用 sscanf 加一個 string 格式化輸入資料，還可以知道有多少筆資料被成功輸入，真的好用、真的香，讚啦</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>  h , m , s , data  ;</span><br><span class="line"><span class="keyword">float</span> new_speed , speed=<span class="number">0</span>  , mile=<span class="number">0</span> ,s1=<span class="number">0</span> ,s2=<span class="number">0</span> ; <span class="comment">//s1 begin time , s2 end time</span></span><br><span class="line"><span class="keyword">char</span> strQ[<span class="number">128</span>] ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> );</span><br><span class="line">    freopen(<span class="string">"out.txt"</span> , <span class="string">"w"</span> , <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">while</span>(gets(strQ))&#123;</span><br><span class="line">        <span class="comment">//printf("%s\n" , strQ);</span></span><br><span class="line">        data = <span class="built_in">sscanf</span>(strQ , <span class="string">"%lld:%lld:%lld %f"</span> , &amp;h , &amp;m , &amp;s , &amp;new_speed);</span><br><span class="line">        <span class="comment">//printf("%lld:%lld:%lld %f\n",h , m , s , new_speed);</span></span><br><span class="line">        s2 = s1 ;</span><br><span class="line">        s1 = h * <span class="number">3600</span> + m * <span class="number">60</span> + s ;</span><br><span class="line">        mile += <span class="built_in">abs</span>(s1-s2) * speed / <span class="number">3600</span> ;</span><br><span class="line">        <span class="keyword">if</span>(data == <span class="number">4</span>)&#123;</span><br><span class="line">            speed =new_speed ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(data == <span class="number">3</span>)&#123;</span><br><span class="line">            <span class="comment">//printf("speed is %f\n" , speed);</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%.2lld:%.2lld:%.2lld %.2f km\n"</span> , h , m ,s ,mile);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>實作題</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa10469 - To Carry or not to Carry (水題)</title>
    <url>/2020/12/28/UVa/UVa10469/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>有一個人的加法器寫爛了，他的加法器不會進位，你可以模擬她這個笨蛋寫法嗎？</p>
</blockquote>
<a id="more"></a>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>很水，很簡單。</p>
<p>但這題其實可以再簡單一點，透過 xor 的特性，只有 0,1 or 1,0 才會輸出 1，0,0 or 1,1 都會輸出 0，所以只要用 xor 就好了，簡單吧！</p>
<p>如果不願意用 xor 也可以暴力解拉XD</p>
<h2 id="參考來源"><a href="#參考來源" class="headerlink" title="參考來源"></a>參考來源</h2><ul>
<li>齊笎詳解</li>
</ul>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>這題真的輕鬆，好開心。但不能每個題目都這樣啦，這樣會變笨www。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b ;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; (a^b) &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>水題</tag>
        <tag>UVa</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa10773 - Back to Intermediate Math (數論 Math theorm)</title>
    <url>/2020/12/28/UVa/UVa10773/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>給你河流寬度 d、河流速度 v、船速 u，想詢問一個小學生都可以回答的問題，船要渡河，我們想請問兩種方式相差的秒數為多少？</p>
<p>如果算不出來或這兩條路徑相同請輸出 can’t determine</p>
<ul>
<li>最短路徑<br>也就是直線經過</li>
<li>最快速度<br>順著河流速度經過</li>
</ul>
</blockquote>
<a id="more"></a>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>這題不是難題，但也不太像是水題，因為他需要用到三角函數與反三角函數。<del>我都沒學好於是去 wiki 查詢了一陣子QQQ</del>。</p>
<p>算出最短路徑所花費的秒數再算出最快速度所花費的秒數之後相減即可。</p>
<p>值得注意的是算最短路徑比較麻煩，且有一些例外案例。</p>
<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li>兩個路徑的長度必須是 double </li>
<li>秒數沒有正負，因此要加絕對值</li>
<li>判斷是否輸出 can’t determine<ul>
<li>船速等於 0，則永遠不會到終點</li>
<li>河流流速等於 0，則兩條路徑相同，題目 output 有說明一定要這兩條路徑不同才可以輸出答案</li>
<li>如果河流速度大於船的速度，則最短路徑則沒辦法抵達終點</li>
</ul>
</li>
<li>不可以判斷 d = 0 則不可以輸出 can’t determine<br>題目的坑…，他有可能 d 是 0，那這兩條路徑則視為不相同，但我覺得理應相同，不過是題目 bug 就算了www。</li>
<li>最短路徑與最快速度，先給出圖<blockquote>
<p><img src="https://i.imgur.com/almrnLB.png" alt=""></p>
</blockquote>
<ul>
<li>最快路徑公式(Shortest Time) \(d / u \)<ul>
<li>因為是最快路徑，因此我們順著河流，藉此讓船速跟河流速度的抵抗將至 0。所以只要距離除以船速即可。</li>
</ul>
</li>
<li>最短路徑公式(Shortest Path) \( cosθ = cos(arcsin(v / u))\)，前面是 v，後面是 u <ul>
<li>根據上面的圖我們可以知道河流會影響到我們的行進速度，於是我們需要更多時間來保證我們行徑的是最短路徑，因此船速要去抵抗河流速度，因此當河流往右時則我們船方向就往左來走出最短路徑。</li>
<li><blockquote>
<p><img src="https://i.imgur.com/GqsCe0L.png" alt=""><br>根據上圖可以看到類似於最短路徑的三角形產生， v 就是 x 然後 u 就是 1，因此 \(v / u \)就是我們需要的 \(cos(arcsin(v / u))\)，但要注意的是還需要乘以 u，因為我們剛剛是透過三角形公式先轉換成符合套件的度量衡，現在再乘回來才會得到正確答案</p>
</blockquote>
</li>
<li>之後與最快路徑公式相同，讓 \(d / (u * cos(arcsin(v / u))) \) 即可。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="參考來源"><a href="#參考來源" class="headerlink" title="參考來源"></a>參考來源</h2><ul>
<li>齊笎詳解</li>
<li><a href="https://zh.wikipedia.org/wiki/%E5%8F%8D%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0" target="_blank" rel="noopener">反三角函數 - wiki</a></li>
</ul>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>這個好難QQQ，竟然要用到三角函數，快把我給考倒了拉！！幸好有隊友的詳解來讓我快速學會，不然我在學習這題目的過程中一定會卡很久的關XD。</p>
<p>如果比賽要用到三角函數，我可能要先投降了..。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> kase ;</span><br><span class="line"><span class="keyword">double</span> n , u , d , v ;</span><br><span class="line"><span class="keyword">double</span> fast ,shortest ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> );</span><br><span class="line">    freopen(<span class="string">"out.txt"</span> , <span class="string">"w"</span> , <span class="built_in">stdout</span> );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; d &gt;&gt; v &gt;&gt; u;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Case "</span> &lt;&lt; ++kase &lt;&lt; <span class="string">": "</span> ;</span><br><span class="line">        <span class="keyword">if</span>(u == <span class="number">0</span> || v == <span class="number">0</span> || v &gt;= u )&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"can't determine"</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">            <span class="keyword">continue</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fast = <span class="number">0</span> ; shortest = <span class="number">0</span> ;</span><br><span class="line">        fast = d / u ;</span><br><span class="line">        shortest = d / (u *<span class="built_in">cos</span>(<span class="built_in">asin</span>(v/u)));</span><br><span class="line">        <span class="comment">//cout &lt;&lt; fast &lt;&lt; ' ' &lt;&lt; shortest &lt;&lt; '\n' ;</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; fixed &lt;&lt; setprecision(<span class="number">3</span>) &lt;&lt; <span class="built_in">abs</span>(fast - shortest ) &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>數論 Math theorm</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa11614 - Etruscan Warriors Never Play Chess (數論 Math theorm)</title>
    <url>/2020/12/28/UVa/UVa11614/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>有一組軍隊，他們的排隊方式向金字塔般，第一排一個、第二排兩個、第三排三個，以此類推，想請問你第 n 個人是第幾排？</p>
<p>測試資料最大不會超過 \(10^{18{\)</p>
</blockquote>
<a id="more"></a>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>不是難題，但也是有點腦筋急轉彎的感覺。</p>
<p>我們可以看出他像是金字塔一樣，因此透過梯形面積公式 \((上底 + 下底) * 高  / 2 \)的方式得出人數，上底必定是 1，因為第一排有一個人。</p>
<p>之後再透過配方法去解即可。</p>
<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li>公式解(配方法)，以下進行推導，題目要求的 row 必為正數，因此負不合<br>\(\frac{(1+row) * row}{2} \geq n \\ ⇒ row^2 + row -2n = 0 \\ ⇒ row = \frac{-1 \pm \sqrt{ 1^2 - (4 * 1 * (-2n))}{2}} \\ ⇒ row = \frac{-1+ sqrt{1+8n}}{2}   \)</li>
</ul>
<h2 id="參考來源"><a href="#參考來源" class="headerlink" title="參考來源"></a>參考來源</h2><ul>
<li>齊笎詳解</li>
<li><a href="http://ptvs24.blogspot.com/2017/05/uva-q11614-etruscan-warriors-never-play.html" target="_blank" rel="noopener">UVA Q11614 - Etruscan Warriors Never Play Chess</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E9%85%8D%E6%96%B9%E6%B3%95" target="_blank" rel="noopener">配方法</a></li>
</ul>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>這題不難，運用了國中知識解出。相信大家有一定概念都會的XD</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 10000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n , a ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compute</span><span class="params">(<span class="keyword">int</span> a )</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="number">-1</span> + <span class="built_in">sqrt</span>(<span class="number">1</span>+<span class="number">8</span>*a)) / <span class="number">2</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> );</span><br><span class="line">    freopen(<span class="string">"out.txt"</span> , <span class="string">"w"</span> , <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a ;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; compute(a) &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="手寫紀錄"><a href="#手寫紀錄" class="headerlink" title="手寫紀錄"></a>手寫紀錄</h2><p>記錄我在解這題的紀錄，透過紙筆來思考會讓我聰明很多<br><img src="https://i.imgur.com/yjQScQd.jpg" alt=""></p>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>數論 Math theorm</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa11723 - Numbering Roads! (水題)</title>
    <url>/2020/12/28/UVa/UVa11723/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>有一個國家的道路命名方式是這樣的，透過數字 0-9 與字母 A-Z，數字配上一個字母(也可以不配)來當作一個道路的命名，<del>類似舊高雄市</del>XD。<br>給你需要命名的道路數量，可用數字為 3，告訴我們可不可以全部命名成功，且輸出可以用到最少的字母，也就是只需要用到第幾個字母就命名完全道路，如果不行請輸出 impossible。</p>
<p>舉例，道路有 5 條，可用數字為 2<br>那道路就有 1,2,1a,2a,1b,2b ，因此就輸出 2，因為用到 b</p>
</blockquote>
<a id="more"></a>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>這題很簡單XD，我們只要把不一定要配上字母的命名也當作是一種字母，也就表示總共有 27 個字母可以使用，之後再讓道路數量除以可命名數字在減一就會是答案了XD。</p>
<h2 id="觀念重點"><a href="#觀念重點" class="headerlink" title="觀念重點"></a>觀念重點</h2><ul>
<li>由於 C++ 的除法是無條件輸入法，但在這裡我們需要的是無條件進位法，因為我們只要用到字母輸出就需要 +1，因此我們的做法是讓 <code>(道路數量 + 可用命名數量 -1 ) / 可用命名數量</code>，就可以達到無條件進位了！ -1 是防止 <code>(2+2) / 2 = 2</code> 的產生，因為道路數量只有 2，因此才需要將可用命名數量 -1 </li>
</ul>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>這題也是簡單 KO，這題的腦筋急轉彎比較少，我就順利通關，太開心了YA，小有成就感www。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 27</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> r , n , kase , cnt ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">compute</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cnt = (r + n<span class="number">-1</span>) / n ;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Case "</span> &lt;&lt; ++kase &lt;&lt; <span class="string">": "</span>;</span><br><span class="line">    <span class="keyword">if</span>(cnt &gt; <span class="number">27</span> )</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt;<span class="string">"impossible\n"</span> ;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; cnt<span class="number">-1</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> );</span><br><span class="line">    freopen(<span class="string">"out.txt"</span> , <span class="string">"w"</span> , <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; r &gt;&gt; n &amp;&amp; r+n != <span class="number">0</span> )&#123;</span><br><span class="line">        compute();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>水題</tag>
        <tag>UVa</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa11805 - Bafana Bafana (水題)</title>
    <url>/2020/12/30/UVa/UVa11805/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>一個足球隊要訓練傳球，球員圍成一個圓圈且球員的傳球方式是傳給左手邊的隊友，也就是 1 傳給 2 傳給 3 已此類推，教練一開始會把球傳給 k 球員，想詢問傳了 p 次後球會在那個隊員腳上？</p>
</blockquote>
<a id="more"></a>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>英文很難…XD，這很痛苦wwww。這句英文特難啊，就讓我放在這邊來讓未來的我緬懷現在英文不好的我www。</p>
<h3 id="英文翻譯"><a href="#英文翻譯" class="headerlink" title="英文翻譯"></a>英文翻譯</h3><p>In each pass, a player will give the ball to his partner who is in his immediate right side.</p>
<p>在每一次的傳球，一個球員將傳給他的夥伴並且他的夥伴是在<strong>右手邊</strong>收到球。</p>
<p>看到了嘛！！！！！ 他的語句是被動型態，且是以收球者觀點為主，在華人社會很少會這樣講，直接習慣性以踢球者為主的角度去看，讓我以為她踢球是讓球員遞減，隊友 3 傳給隊友 2 傳給隊友 1，這種感覺..。</p>
<p>基本上這題不難，只需要將 \((現在的球員號碼 + 傳 x 次) % 隊員數量\) 即可，注意是當餘數為 0 時要特別改成 n 即可。因為模數的特姓，在球員號碼等同於隊員數量時上面公式會輸出 0，因此特別拉出來寫案例即可。</p>
<h2 id="觀念重點"><a href="#觀念重點" class="headerlink" title="觀念重點"></a>觀念重點</h2><ul>
<li>\((現在的球員號碼 + 傳 x 次) % 隊員數量\)</li>
<li>當上面的公式值為 0 時將改成輸出隊員數量</li>
</ul>
<h2 id="參考來源"><a href="#參考來源" class="headerlink" title="參考來源"></a>參考來源</h2><ul>
<li>齊笎詳解</li>
</ul>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>這題不難拉，只需要解決英文問題就好了，最近都在訓練數學題目順便增強英文閱讀能力，最近覺得英文閱讀能力有變好，算是一大感動嘛XD</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> t , n , k , p ;</span><br><span class="line"><span class="keyword">int</span> kase ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compute</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = (k + p) % n ;</span><br><span class="line">    <span class="keyword">if</span>(temp == <span class="number">0</span> )</span><br><span class="line">        <span class="keyword">return</span> n ;</span><br><span class="line">    <span class="keyword">return</span>  temp ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t ;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k &gt;&gt; p ;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Case "</span> &lt;&lt; ++kase &lt;&lt; <span class="string">": "</span> &lt;&lt; compute() &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>水題</tag>
        <tag>UVa</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa11875 - Brick Game (水題)</title>
    <url>/2020/12/30/UVa/UVa11875/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>孟加拉國對於 Brick Game 非常熱衷，最近出現了電競的賽事，隊伍的隊員數量必定是奇數，且透過年齡進行排序，可能會給遞增或遞減。需要一個隊長且隊長年齡必須是隊伍的中間值，否則會出現代溝，請輸出隊長的最適合年齡。</p>
<p>P.S. 隊友年齡都是獨一無二，不會有另外一個隊友與其他隊友年齡相同。</p>
</blockquote>
<a id="more"></a>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>水到不行www，前題是你英文夠好的話…。<del>我就理解錯了方向，還我寫了一個錯誤的版本</del></p>
<p>由於題目的隊員數量必定是奇數因此不需要擔心偶數 / 2 的問題，再加上年齡一定是遞增或是遞減，在奇數情況時連排序都不需要www。</p>
<h3 id="偶數的情況-題目沒有用到"><a href="#偶數的情況-題目沒有用到" class="headerlink" title="偶數的情況 - 題目沒有用到"></a>偶數的情況 - 題目沒有用到</h3><p>偶數比較麻煩，假如 1,2,3,4 我們要找出隊長就有可能是 2,3，但因為題目是奇數所以就不用擔心了XD。</p>
<p>假如隊長改成偶數且年齡必須是<strong>等於或等於 + 1</strong> 的年齡這時候排序就會很重要，不然直接輸入至陣列時就會因為沒有排序，如果同筆測試資料只是順序遞增與遞減時輸出答案就會不一至。</p>
<h4 id="舉例：-1-2-3-4-and-4-3-2-1-如果隊員是偶數時則選中位數-1-的隊友"><a href="#舉例：-1-2-3-4-and-4-3-2-1-如果隊員是偶數時則選中位數-1-的隊友" class="headerlink" title="舉例： 1,2,3,4 and 4,3,2,1 如果隊員是偶數時則選中位數 + 1 的隊友"></a>舉例： 1,2,3,4 and 4,3,2,1 如果隊員是偶數時則選中位數 + 1 的隊友</h4><p>同樣放在題目的這份程式碼，公式是 \(n/2+1\)，那在這兩種順序就會輸出 2 或者 3，答案不一致。</p>
<h3 id="錯誤方向"><a href="#錯誤方向" class="headerlink" title="錯誤方向"></a>錯誤方向</h3><p>擷取題目的關鍵字，這是誤導我的方向</p>
<p>Hence they select the captain of a team in such a way so that the number of player in the team who are younger than that captain is equal to the number of players who are older than that captain</p>
<p>因此選擇一個隊長的方法是選擇一位隊員且此<strong>隊員年齡會是隊伍的中間值</strong>。<br>P.S. 中間值 = 中位數。</p>
<p>我把它理解成了平均值…，於是我就用了加權平均數去計算，再找出最靠近加權平均數的年齡，後來才發現她要的是中位數..。</p>
<h3 id="觀念重點"><a href="#觀念重點" class="headerlink" title="觀念重點"></a>觀念重點</h3><ul>
<li>先將隊員年齡放入陣列中(index 0)，在 \(n/2\) 即可。</li>
</ul>
<h2 id="參考來源"><a href="#參考來源" class="headerlink" title="參考來源"></a>參考來源</h2><ul>
<li>齊笎詳解</li>
</ul>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>這題不難拉，只需要解決英文問題就好了，最近都在訓練數學題目順便增強英文閱讀能力，最近覺得英文閱讀能力有變好，算是一大感動嘛XD</p>
<p>可是我已經連續兩題英文閱讀方向錯了…，可以給我翻譯蒟蒻嘛。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 15</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> oo 1e9</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> num[MAXN] ;</span><br><span class="line"><span class="keyword">int</span> t , n ;</span><br><span class="line"><span class="keyword">int</span>  kase  ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compute</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; num[i] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//sort(num,num+n);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> num[n/<span class="number">2</span>] ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> );</span><br><span class="line">    freopen(<span class="string">"out.txt"</span> , <span class="string">"w"</span> , <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t ;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Case "</span> &lt;&lt; ++kase &lt;&lt; <span class="string">": "</span> &lt;&lt; compute() &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>水題</tag>
        <tag>UVa</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa12149 - Feynman( 數論 Math theorm )</title>
    <url>/2021/01/02/UVa/UVa12149/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>費曼在筆記中夾著餐巾紙，上面寫到在一個 n * n 的正方形中，裡面可以有多少種不同的正方形。<br>舉例：在 2 * 2 的正方形中，總共會有 5 種不同的正方形<br><img src="https://i.imgur.com/qpMeoD0.png" alt=""></p>
</blockquote>
<a id="more"></a>

<h2 id="觀念重點"><a href="#觀念重點" class="headerlink" title="觀念重點"></a>觀念重點</h2><ul>
<li><strong>推算</strong>出 n 的正方形有多少種正方形</li>
<li>再將這<strong>推算</strong>變成一數學公式</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>大難題XD，對於數學底子不好的我來說完全沒有辦法克服這題阿，我就像笨蛋一樣，嗚嗚。看了詳解並且詳細推了公式之後才了解一些。</p>
<h3 id="想出其他測試資料"><a href="#想出其他測試資料" class="headerlink" title="想出其他測試資料"></a>想出其他測試資料</h3><p>一開始要先稍微去推導其他例子，也就是除了範例以外我們再去想想在 n = 多少時會有多少正方形。</p>
<ul>
<li>n = 2 ，此時總共有  5 個正方形</li>
<li>n = 3 ，此時總共有 14 個正方形</li>
<li>n = 4 ，此時總共有 30 個正方形</li>
<li><del>不要問我怎麼算的，手畫真的很累..</del></li>
</ul>
<h3 id="歸納"><a href="#歸納" class="headerlink" title="歸納"></a>歸納</h3><p>如果真的有努力畫到 n = 4，那應該可以歸納出一個邏輯</p>
<ul>
<li>正方形邊長為 1<br>假如有一個 n 邊長的正方形，那他一定會有 n * n 個邊長為 1 的正方形</li>
<li>正方形邊長為 2<br>假如有一個 n 邊常的正方形，且 \(n \geq 2 \) 那他一定會有 \((n-1) * (n-1)\) 個邊長為 2 的正方形。至於為甚麼呢則在下方進行說明<ul>
<li>不同的正方形<br>因為不同的正方形定義只要裡面其中有一格是與其他正方形不同就可以獨立算是另一個新的正方形，但因為是正方形所以沒有辦法一格不同，只能夠 1 * n。</li>
<li>只需要 1 * n 個不同，我們要極大化正方形數量，因此我們從正方形左上角開始，不斷往下堆疊出邊長為 2 的正方形，會發現只能夠堆疊出 n - 1 個正方形<ul>
<li>舉例 n = 3，只能夠堆疊出兩個<br>如果想堆疊到第三個會發現會超出邊界，因此不可以</li>
<li>舉例 n = 4，只能夠堆疊出三個</li>
</ul>
</li>
<li>由於正方形長寬都一樣，因此 \( (n-1) * (n-1)\) 就會等於此正方形中邊長為 2 的所有正方形數量</li>
</ul>
</li>
<li>正方形邊長為 3<br>假如有一個 n 邊常的正方形，且 \(n \geq 3 \) 那他一定會有 \((n-2) * (n-2)\) 個邊長為 3 的正方形。至於為甚麼呢則在下方進行說明<ul>
<li>不同的正方形<br>因為不同的正方形定義只要裡面其中有一格是與其他正方形不同就可以獨立算是另一個新的正方形，但因為是正方形所以沒有辦法一格不同，只能夠 1 * n。</li>
<li>只需要 1 * n 個不同，我們要極大化正方形數量，因此我們從正方形左上角開始，不斷往下堆疊出邊長為 3 的正方形，會發現只能夠堆疊出 n - 1 個正方形<ul>
<li>舉例 n = 3，只能夠堆疊出一個<br>如果想堆疊到第二個會發現會超出邊界，因此不可以</li>
<li>舉例 n = 4，只能夠堆疊出兩個</li>
</ul>
</li>
<li>由於正方形長寬都一樣，因此 \( (n-2) * (n-2)\) 就會等於此正方形中邊長為 3 的所有正方形數量</li>
</ul>
</li>
<li>下方為圖示，為上方兩個正方形變長的範例 <blockquote>
<p><img src="https://i.imgur.com/WACl1u2.jpg" alt=""></p>
</blockquote>
</li>
<li>透過此方式可以推出在正方形邊長為 x 時，那會等於此正方形中邊長為 x 的所有正方形數量公式為 \((n-x) * (n-x) \)，也就是 \(\sum_{i=0}^{n-1} (n-i) * (n-i) \)。</li>
</ul>
<h3 id="將公式轉換"><a href="#將公式轉換" class="headerlink" title="將公式轉換"></a>將公式轉換</h3><p>再來我們將公式進行轉換，\(\sum_{i=0}^{n-1} (n-i) * (n-i) \) 雖然看起來可以用了，但我們還可以把它更優化。</p>
<p>\(\sum_{i=0}^{n-1} (n-i) * (n-i) \) 可以透過平方化簡等於 \(\sum_{i=0}^{n-1} (n-i)^2 \)。</p>
<p>再來，我們舉例假設 n = 3 的時候，應該會是 \((3-0)^2 + (3-1)^2 + (3-2)^2 = 3^2 + 2^2 + 1^2\)，透過這個舉例我們可以再將它化簡為 \(\sum_{i=1}^{n} i^2 \)，而此公式就是大家熟知的<strong>連續正整數平方和公式</strong>。</p>
<h3 id="連續正整數平方和公式"><a href="#連續正整數平方和公式" class="headerlink" title="連續正整數平方和公式"></a>連續正整數平方和公式</h3><p>再來就套用連續平方何公式即可。</p>
<p>關於此公式證明請看<a href="http://www.mathland.idv.tw/fun/Sum_of_squares.htm" target="_blank" rel="noopener">圖解連續正整數平方和公式</a></p>
<p>我會在講解一遍，但我認為我講解的不一定好於是附上網址，讓不懂我講解的人去看此，也謝謝此網站作者將學習資源公布在網路上</p>
<h4 id="證明"><a href="#證明" class="headerlink" title="證明"></a>證明</h4><p><img src="https://i.imgur.com/Jmuro5W.png" alt=""></p>
<ul>
<li><p>歸納<br>由此圖可知，有 5 個正方形與 5 個長方形組成此圖，且這 5 個正方形邊長分別為 1,2,3,4,5、5 個長方形邊長則為 1 * 1 , 1 * (1+2) , 1 * (1+2+3) , 1 * (1+2+3+4) , 1 * (1+2+3+4+5)。</p>
</li>
<li><p>我們想找的面積<br>而其實我們想要計算的連續正整數平方和就是紫色面積的正方形總和，如果我們透過數學算式去計算就是總面積減去黃色面積就是我們要查詢的面積。<br>於是我們就可以將公式稍微推出來，\([1 + 2 + 3 + … + (n-1) + n ] * (n+1) - [1 + (1+2) + (1+2+3) + … + (1+2+3+4+ … + n )] \)，翻譯成中文就是總面積的長度乘以總面積的高減去黃色部分就是紫色面積。 </p>
</li>
<li><p>將想找出的面積透過數學方式描述<br>\( [1 + (1+2) + (1+2+3) + … + (1+2+3+4+ … + n )] \) 是黃色面積中每一條長方型的面積，總和起來就是總黃色面積。</p>
</li>
<li><p>將其公式化<br>現在我們可以推出公式 \(\sum_{i=1}^{n} = i^2  =  \frac{n(n+1)}{2}(n+1) - \sum_{i = 1}^{n} \frac{i(i+1)}{2}   \)，這裡的 \(\frac{i(i+1)}{2} \) 為連續和公式。(梯形公式，上底為 1，下底為 n，高為 n )</p>
</li>
<li><p>推導與化簡步驟 1<br>再來進行化簡<br>\( \frac{n(n+1)}{2}(n+1) - \sum_{i = 1}^{n} \frac{i(i+1)}{2} = \frac{n(n+1)}{2}(n+1) - \frac{1}{2} \sum_{i=1}^{n} i(i+1) \)</p>
</li>
<li><p>推導與化簡步驟 2<br>\( \frac{n(n+1)}{2}(n+1) - \frac{1}{2} \sum_{i=1}^{n} i(i+1) =\frac{n(n+1)}{2}(n+1) - \frac{1}{2} \sum_{i=1}^{n} i^2 - \frac{1}{2} \sum_{i=1}^{n} i  \)，把 \( \sum_{i=1}^{n} i(i+1) \) 拉出來寫</p>
</li>
<li><p>推導與化簡步驟 3<br>這裡我們要進行移項，還記得一開始是  \(\sum_{i=1}^{n} = i^2 \) 嗎? 是我們不斷進行推導剛剛的步驟。<br>\(\sum_{i=1}^{n} = i^2 = \frac{n(n+1)}{2}(n+1) - \frac{1}{2} \sum_{i=1}^{n} i^2 - \frac{1}{2} \sum_{i=1}^{n} i \) 就變成了<br>\(  \frac{3}{2} \sum_{i=1}^{n} i^2 =  \frac{n(n+1)}{2}(n+1) - \frac{1}{2}\sum_{i = 1}^{n} i  \)，我們將 \( \frac{1}{2} \sum_{i=1}^{n} i^2 \) 移項至 \(\sum_{i=1}^{n} = i^2\) </p>
</li>
<li><p>推導與化簡步驟 4<br>\( \frac{n(n+1)}{2}(n+1) - \frac{1}{2}\sum_{i = 1}^{n} i = \frac{n(n+1)}{2}(n+1)  - \frac{1}{2} \frac{n(n+1)}{2} \)，將 \(\sum_{i = 1}^{n} i \) 轉換成連續和公式。</p>
</li>
<li><p>推導與化簡步驟 5<br>\( \frac{n(n+1)}{2}(n+1)  - \frac{1}{2} \frac{n(n+1)}{2} = \frac{n(n+1)}{2}(n+1) - (n + 1 - ) \frac{1}{2} \)，\(\frac{1}{2} \frac{n(n+1)}{2}\) 這項進行運算並化簡。</p>
</li>
<li><p>推導與化簡步驟 6<br>\( \frac{n(n+1)}{2}(n+1) - (n + 1 - ) \frac{1}{2} = \frac{n(n+1)(2n+1)}{4}\)，前面那項進行運算並化簡</p>
</li>
<li><p>推導與化簡步驟 7<br>還記得剛剛的值是 \(  \frac{3}{2} \sum_{i=1}^{n} i^2 \) 嗎？現在我們要在變回 \(  \sum_{i=1}^{n} i^2 \)於是<br>\(  \frac{3}{2} \sum_{i=1}^{n} i^2 = \frac{n(n+1)(2n+1)}{4}\) 將 \(  \frac{3}{2} \) 變成移項至另一邊，移項是分數數值會顛倒於是就變成了 \(\sum_{i=1}^{n} i^2 =  \frac{n(n+1)(2n+1)}{6}\)</p>
</li>
</ul>
<p><strong>現在我們有公式了，就來解決吧！</strong>，其實寫程式很簡單，如果有推出公式的話XD。</p>
<h2 id="參考來源"><a href="#參考來源" class="headerlink" title="參考來源"></a>參考來源</h2><ul>
<li><a href="https://knightzone.studio/2012/07/15/1759/uva%EF%BC%9A12149%EF%BC%8Dfeynman/" target="_blank" rel="noopener">uva：12149－feynman</a></li>
<li><a href="http://www.mathland.idv.tw/fun/Sum_of_squares.htm" target="_blank" rel="noopener">昌爸工作坊</a></li>
<li>微積分老師洪揮霖</li>
</ul>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>老實講，這題我寫的好痛苦XDDD，我自己的數學觀念太差了，雖然看了大神的 blog 得知這題是算出連續正整數平方和公式，但也是花了很多時間才想通QQQQ，再來連續正整數平方和公式我想要推出其證明還卡關…，問了微積分老師洪揮霖(他人很好，幫助我很多數學問題)發現我竟然是卡在移項問題沒看懂..(冏。</p>
<p>因為這題我花的時間比較久且大部分都是在公式推導上於是我就將我的公式推導流程放上來，如果有數學底子跟我一樣差的或許就能看懂了！希望不要有人跟我一樣差拉，很痛苦的，真的。都怪我國中太愛玩都沒有好好上數學課。</p>
<p>總之，學會了，我也變強了，希望之後可以發揮我現在學習的一課！<del>學習 1 小時，寫心得 4 小時是正常的嘛…</del></p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n &amp;&amp; n )&#123;</span><br><span class="line">        n = (n * (n+<span class="number">1</span>) * (<span class="number">2</span>*n+<span class="number">1</span>)) / <span class="number">6</span> ;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="思考流程"><a href="#思考流程" class="headerlink" title="思考流程"></a>思考流程</h2><p>透過紙筆與黑板而思考而成的片段，放在網路上供我紀念XD</p>
<blockquote>
<p><img src="https://i.imgur.com/EhqZ4y7.jpg" alt=""></p>
</blockquote>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>數論 Math theorm</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa12502 - Three Families(數論 Math theorm )</title>
    <url>/2020/12/31/UVa/UVa12502/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>A,B,C 這 3 個家庭共同管理一個花園，其中有一周 C 家庭出去玩，讓 A 與 B 共同去整理花園，當 C 回來時給予一筆錢來感謝 A 與 B 一起整理花園，題目詢問 A 應該要拿到多少錢比較好？ </p>
<p>x 為 A 家庭整理花園的時數<br>y 為 B 家庭整理花園的時數<br>z 為 C 家庭給予的錢</p>
<p>貼心提示</p>
<ul>
<li>假如 x 為 5、y 為 4、z 為 90，那公式並不是 \(90/(5+4)*5 = 50 \)，需要仔細想想，題目不會告訴你 </li>
<li>如果用到小數點時請小心使用，建議盡量避免</li>
</ul>
</blockquote>
<a id="more"></a>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>這題是大坑…，題目寫得很委婉希望你不要用小數..，但其實就是在暗示你說基本上你用有 95% 的機率不會過，另外 5% 是運氣www，然後我就是那 95 % 的人，真難過，嗚嗚嗚。</p>
<p>如果用題目推薦的方法，也就是不使用小數來計算時那我們就需要透過公式，公式推導如下：</p>
<ul>
<li>\(\frac{x+y}{3} = one\)，one 為三個家庭都應該要花的時數</li>
<li>\(x^{\prime} = x - one\)， \(x^{\prime} \) A 家庭多做的時數，如果是負數表示為少做</li>
<li>\(y^{\prime} = y - one \)，\(x ^ {\prime}\) B 家庭多做的時數，如果是負數表示為少做</li>
<li>\(z_a = z * \frac{x^{\prime} }{^{\prime}+y^{\prime}  } \)，\(z_a\) 為 A 家庭應該獲得的錢</li>
<li>將 \(z_a \) 開始進行推導<br>\(z_a = z * \frac{x^{\prime} }{x^{\prime}+y^{\prime}} \\ = z * \frac{x - one }{(x -one ) + (y - one)} \\ = z * \frac{(x - \frac{x+y}{3})} {  (x - \frac{x+y}{3}) + (y - \frac{x+y}{3}) } \\ = z * \frac{ \frac{2x-y}{3}}{\frac{2x-y}{3} + \frac{2y-x}{3}} \\ = z * \frac{2x-y}{2x-y+2y-x} \\ = z * \frac{(2x-y)}{x+y} \)</li>
<li>根據我們得出的結論就可以得到此公式 \(z * \frac{(2x-y)}{x+y}\)，再透過此公式進行計算即可且此計算還可以避免掉小數問題，符合題目需求，讚。(只使用一次除法會產生小數點，是最簡避免方法)</li>
</ul>
<h2 id="觀念重點"><a href="#觀念重點" class="headerlink" title="觀念重點"></a>觀念重點</h2><ul>
<li>思考出這題要帶給你的邏輯觀念</li>
<li>公式推導</li>
<li>讓你知道在程式中多使用小數點是非常不好的事，盡量避免小數除法</li>
<li>如果 A 沒有幫忙工作，反而還少工作此時 A 則不應該拿到薪水，如果計算出來為負也要改為 0<br><del>壞家庭 A</del></li>
<li>享受題目的惡意</li>
</ul>
<h2 id="參考來源"><a href="#參考來源" class="headerlink" title="參考來源"></a>參考來源</h2><ul>
<li><a href="https://knightzone.studio/2020/01/22/4687/uva%EF%BC%9A12502%EF%BC%8Dthree-families/" target="_blank" rel="noopener">UVa：12502－Three Families</a></li>
</ul>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>這題好機車..，主要任務是將小數點誤差降至最低但是卻又不跟你說明白，有點暗示暗示的概念小討厭阿，查看了 google 上其他大神的詳解後發現他們的解法才是真的強阿，透過不斷推導、不斷優化來找出答案，讓我不禁覺得自己是個笨蛋了…。</p>
<p>不過透過他們的推導也讓我自己對這種類型的題目有了更深的體悟，也讓我思考的觀點有多了一個，學習到了新事物的感覺真的不錯呀，整個腦袋感覺都被提升了一個檔次。</p>
<p>只是題目沒有明示我真的猜不出來…，我不夠熟還需要懂淺規則RRRRR。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">float</span> t , hr , x , y , z ;</span><br><span class="line"><span class="keyword">int</span> cost ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>,<span class="string">"r"</span> , <span class="built_in">stdin</span>) ;</span><br><span class="line">    freopen(<span class="string">"out.txt"</span>, <span class="string">"w"</span> , <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t ;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y &gt;&gt; z ;</span><br><span class="line">        cost = z * (<span class="number">2</span> * x - y) / (x + y ) ;</span><br><span class="line">        <span class="keyword">if</span>(cost &lt; <span class="number">0</span> ) cost = <span class="number">0</span> ;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; cost &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>##　思考流程<br>透過紙筆與黑板而思考而成的片段，放在網路上供我紀念XD</p>
<blockquote>
<p><img src="https://i.imgur.com/NN4I3DT.jpg" alt=""><br><img src="https://i.imgur.com/yTbnkno.jpg" alt=""><br><img src="https://i.imgur.com/7d1P97E.jpg" alt=""><br><img src="https://i.imgur.com/MPX4z1C.jpg" alt=""></p>
</blockquote>
<h2 id="錯誤的思考方向"><a href="#錯誤的思考方向" class="headerlink" title="錯誤的思考方向"></a>錯誤的思考方向</h2><p>我在寫程式的時後我一開始有透過我的思考方式來寫出這份題目，但發現有個很重要的問題XD，那就是誤差太大了…。</p>
<p>在透過題目的樣本測資時並沒有錯誤，但在 udebyg 上的測資發現有兩筆答案都少一個數字，我很納悶於是用手重新算了一遍則發現是小數點誤差導致發生其問題。</p>
<p>我一開始寫的程式邏輯如下</p>
<ul>
<li>先算出每個家庭應該要工作的時數，公式是 \((x+y) / 3\)，因為題目有說明所有家庭的打掃速度都是相同</li>
<li>由於 C 家庭付出薪水而沒有工作(資本主義的荼毒)，因此我們可以假設成 C 付出的錢等於一個家庭的工作量</li>
<li>C 付出的薪水除以一個家庭應該要工作的時數，等於 1 小時的薪資</li>
<li>A 家庭減去一個家庭應該要工作的時數，剩下的時數就是幫 C 工作的時數，再將我們計算好 1 hr 的薪水去乘 A 多工作的時數</li>
<li>輸出 A 應該要拿到的薪水</li>
</ul>
<h3 id="會錯誤的原因-誤差"><a href="#會錯誤的原因-誤差" class="headerlink" title="會錯誤的原因 - 誤差"></a>會錯誤的原因 - 誤差</h3><ul>
<li>第一個誤差<br>其實這個邏輯沒有錯，錯就錯在小數點誤差…，一開始必須要算出一個人的工作時數，此時需要除以 3，如果這時候會有小數時就會有誤差</li>
<li>第二個誤差<br>再來是 C 付出的錢要除以一個家庭應該要工作的時數，如果這時候也除不盡也會有誤差</li>
<li>第三個誤差<br>再來是 A 家庭要拿到多工作的薪水，如果前面是小數點且有誤差的狀態則會讓誤差被放大，但如果前面兩個誤差都不會發生那就沒有問題XD。</li>
</ul>
<p>有上面三個誤差，就導致在某些測資上會產生 &gt;= 1 的誤差，因此錯誤，才要透過大神們的推導來寫，只會有一個機會誤差。</p>
<h3 id="舉例-x-3-y-2-z-90"><a href="#舉例-x-3-y-2-z-90" class="headerlink" title="舉例 x = 3 , y = 2 , z = 90"></a>舉例 x = 3 , y = 2 , z = 90</h3><h4 id="錯誤思考"><a href="#錯誤思考" class="headerlink" title="錯誤思考"></a>錯誤思考</h4><p>那每個家庭平均的工作量應該要是 (3+2) / 3 = 1.66<br>由於 C 付出 90 元，因此 90 / 1.66 = 54.21，也就是 1hr 為 54.21 元<br>3 - 1.66 = 1.34 ，1.34 為 x 多做的部分，因此給他時薪也就是 54.21 * 1.34 = 72.614</p>
<h4 id="正確方向"><a href="#正確方向" class="headerlink" title="正確方向"></a>正確方向</h4><p>透過推導公式可以得出 \(90 * \frac{2 * 3 - 2 }{3 + 2 } = 90 * \frac{4}{5} = 72 \)，與錯誤思考相差 0.614 元，因此正確方向比較好，遇到小數點誤差機率降低</p>
<h3 id="錯誤程式碼"><a href="#錯誤程式碼" class="headerlink" title="錯誤程式碼"></a>錯誤程式碼</h3><p>放在這裡來紀念寫錯程式碼的我來讓我進步吧XD</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">float</span> t , hr , x , y , z ;</span><br><span class="line"><span class="keyword">int</span> cost ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>,<span class="string">"r"</span> , <span class="built_in">stdin</span>) ;</span><br><span class="line">    freopen(<span class="string">"out.txt"</span>, <span class="string">"w"</span> , <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t ;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y &gt;&gt; z ;</span><br><span class="line">        cost = z * (<span class="number">2</span> * x - y) / (x + y ) ;</span><br><span class="line">        <span class="keyword">if</span>(cost &lt; <span class="number">0</span> ) cost = <span class="number">0</span> ;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; cost &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>數論 Math theorm</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa10181 - 15-Puzzle Problem(A*搜尋 )</title>
    <url>/2021/01/09/UVa/UVa10181/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>大家有玩過數字拼圖嗎？這題是數字拼圖，給你一個隨機生成的數字拼圖，透過上下左右的方式讓空白附近的方塊跟空白交換，操作方式如下：<br><img src="https://i.imgur.com/mAx9XXC.png" alt=""></p>
<p>如果可以在 50 步以內玩到拼圖的所有數字從左到右、從上到下都按照數字順序，那稱之為完成。並輸出從初始拼圖至最終拼圖的操作，輸出字元只能是 U,D,L,R。<br>P.S. 完成必須要是此圖<br><img src="https://i.imgur.com/t8TEweY.png" alt=""></p>
<p>如果不行，輸出 “This puzzle is not solvable.”</p>
</blockquote>
<a id="more"></a>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>這題好噁心…，好想回去寫數學…，數學好懂很多，這個讓我痛苦了 3 天左右、近 70 次左右的 TLE，嗚嗚。</p>
<p>這題可以用 IDA* or A* 去解決，比較推薦前者 IDA* 來解決，A* 有很多細節要進行處理，如果你是一位熱愛被題目折磨的好友就使用 A* 吧！</p>
<p>注意：此題目為 NP 問題，還沒有被科學家所研究出相關公式，只有研究出是否可解。</p>
<h3 id="分析棋面"><a href="#分析棋面" class="headerlink" title="分析棋面"></a>分析棋面</h3><p>首先，我們先來定義<strong>棋面</strong>的意思，此名詞為每一個拼圖狀態的樣子，只要有進行移動，即是兩個不同的棋面，相信大家看的出來這題是必須要輸出路徑至變成最終拼圖狀態，那這時最好的演算法就是 Dijkstra，但棋面的複雜度應該是 \(O(16! / 2) = 1.04e13\)，其中除 2 是左邊方塊與右邊方塊交換、右邊方塊與左邊方塊交換相同，則其道理上下也是</p>
<p>時間複雜度為 \(O(E \log \ V ) = 1.25e13\)、\(E = 1.04e13 , V = 16 \)，有 16 個點要找出最短路徑最短路徑，有 \(1.04e13\) 個狀態(邊)，但問題是最優秀的最短路徑演算法也需要對於這題做一些小技巧，不可以透過單純的 piority_queue 去解決，必須再透過一些小技巧來優化。</p>
<h4 id="儲存棋面"><a href="#儲存棋面" class="headerlink" title="儲存棋面"></a>儲存棋面</h4><p>我們粗略的判斷一下，每一個拼圖號碼都可以放在 16 個位置，總共有 16 個拼圖，並且拼圖順序不同也算是不同的棋面那總共會有 \(2e9\) 個棋面，\(E = 24 * 24 = 576 \)、\(V = 16 \)，如果透過簡單的 piority_queue，要對哪個棋面優先 top queue 環節。但由於每一次的狀態都會產生出 4 個狀態，因此有一個好的函示來判斷要先取出那個狀態做 dijkstra 是非常重要的，而這函式我們稱為<a href="https://theriseofdavid.github.io/2021/01/07/Explain_Algorithm/Astar/" target="_blank" rel="noopener">啟發式搜尋 heuristic search</a></p>
<h3 id="啟發式搜尋-heuristic-search"><a href="#啟發式搜尋-heuristic-search" class="headerlink" title="啟發式搜尋 heuristic search"></a><a href="https://theriseofdavid.github.io/2021/01/07/Explain_Algorithm/Astar/" target="_blank" rel="noopener">啟發式搜尋 heuristic search</a></h3><h4 id="判斷每一個拼圖是否在每個正確的位置上，沒有就加-1"><a href="#判斷每一個拼圖是否在每個正確的位置上，沒有就加-1" class="headerlink" title="判斷每一個拼圖是否在每個正確的位置上，沒有就加 1"></a>判斷每一個拼圖是否在每個正確的位置上，沒有就加 1</h4><p>這樣勢必是不行的，那麼在每次判斷的時候都必須跑一次迴圈進行測試，效率太差。且如果再正確位置空白下放 1 拼圖、正確位置 1 放空白拼圖，那麼此方法沒有辦法去解決此拼圖；因為只要換了就會讓錯的數字更多。</p>
<h4 id="曼哈頓距離"><a href="#曼哈頓距離" class="headerlink" title="曼哈頓距離"></a>曼哈頓距離</h4><p>曼哈頓距離，是幾何學中的用語，<del>幾何學的用語都很不淺顯易懂</del>，簡單來說的話就是，某一個拼圖要用最短步驟才可以到達正確拼圖的位置。</p>
<p>例如下圖中的 3，移到正確位置是多少曼哈頓距離。</p>
<blockquote>
<p><img src="https://i.imgur.com/CsjmuLp.png" alt=""></p>
</blockquote>
<p>正確答案是 4，最短只需要透過 4 步就可以到達正確拼圖的位置。而這樣可以透過國中就學習過的公式來進行推導 \(|x_1 - x_2 | + |y_1 - y_2 |\)。</p>
<h3 id="剛剛我們已經決定好要用曼哈頓距離，那-piority-queue-的判斷就是曼哈頓距離最小嗎？"><a href="#剛剛我們已經決定好要用曼哈頓距離，那-piority-queue-的判斷就是曼哈頓距離最小嗎？" class="headerlink" title="剛剛我們已經決定好要用曼哈頓距離，那 piority_queue 的判斷就是曼哈頓距離最小嗎？"></a>剛剛我們已經決定好要用曼哈頓距離，那 piority_queue 的判斷就是曼哈頓距離最小嗎？</h3><p>當然不是，嗚嗚。我在這裡也犯過錯QQQ。</p>
<p>正確來說的公式應該是 \(已經行走的步驟 + 曼哈頓距離 * x = 優先權重\)，其中 x 為係數並且要大於等於 1，程式這裡為 10，且優先權重最<strong>小</strong>的先進行此次的 dijkstra。</p>
<p>稍微解釋一下公式，為甚麼曼哈頓距離需要乘以 x，是因為曼哈頓距離是我們預估的權重數量，並不是我們真正已經走的步驟，曼哈頓距離是我們<strong>尚未走</strong>的步驟。</p>
<p>如果沒有放大倍率那會造成已經走的步驟跟曼哈頓距離其實是一樣的概念，但其實並不是，已經走的步驟必定是<strong>當前</strong>最佳解且已經走過路徑，但曼哈頓路徑還不確定路徑需要去嘗試，因此最好的方法就是讓<br>必曼哈頓距離乘以 x 來讓他在權重中的影響力降低，在我們先將優先權重最小的點拿出的情況下。</p>
<h4 id="struct-使用-priority-queue-重點提醒"><a href="#struct-使用-priority-queue-重點提醒" class="headerlink" title="struct 使用 priority_queue 重點提醒"></a>struct 使用 priority_queue 重點提醒</h4><p>由於本人我在寫 pioirity_queue 犯過一個錯誤，其實是作者自己記憶力不好一直忘記QQ，因此寫在這邊稍微複習一下。</p>
<p>pioirity_queue 是 queue 的強化版，透過 heap sort 來強化<strong>權重</strong>的價值，預設情況下是遞減，因此如果我們特別自定一個 struct 時，C++ 並不清楚大小排序是如何？因此我們要自己寫一個 operator 來告知判斷大小的依據。</p>
<p>當要自己寫一個 operator 時，由於 pioirity_queue 是遞減，因此我們可以用一種偷懶的寫法，只要右邊的 struct 變數 A 小於左邊的 sturct 變數 st 依據是 A 的 h + step 要大於 st.h + st.step，透過此模式就可以在 priority_queue 遞減的情況下 struct 輸出的資料則是遞增。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">state</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> graph[<span class="number">4</span>][<span class="number">4</span>] ;</span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="keyword">int</span> h=<span class="number">-1</span> , step=<span class="number">0</span> ;</span><br><span class="line">    <span class="built_in">string</span> path =<span class="string">""</span> ;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(state st) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> h + step &gt; st.h + st.step ; </span><br><span class="line">        <span class="comment">//因此在這邊 st 要大於 state 的依據就是， state 的 h + step 要大於 st，</span></span><br><span class="line">        <span class="comment">//如果有符合此條件，那 heap sort 就會往上一層去比較，以達到 heap 遞減。</span></span><br><span class="line">        <span class="comment">//如果 st 沒有大於 state，那 st 的 h + step 就比 state 大</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可閱讀此篇來進行更好的理解<a href="https://blog.csdn.net/luomingjun12315/article/details/47376359" target="_blank" rel="noopener">STL 之 优先队列(priority_queue) Enstein_Jun </a></p>
<h3 id="這裡我們就不使用-map-or-set-紀錄棋面，而是用-priority-queue-去找優先權重最小，如果找到重複也沒關係"><a href="#這裡我們就不使用-map-or-set-紀錄棋面，而是用-priority-queue-去找優先權重最小，如果找到重複也沒關係" class="headerlink" title="這裡我們就不使用 map or set 紀錄棋面，而是用 priority_queue 去找優先權重最小，如果找到重複也沒關係"></a>這裡我們就不使用 map or set 紀錄棋面，而是用 priority_queue 去找優先權重最小，如果找到重複也沒關係</h3><p>為甚麼我們會這樣寫呢，根據上面的分析，棋面真的太多了，如果用 set or unorder_map 每次不斷去查詢是否有重複的棋面，那複雜度則會大幅上升。map 時間複雜度是 \(o(log \ n )\)，每次進行查詢與插入(新增棋面) 兩次的 \(o(log \ n )\)，會讓程式笨重許多。因此建議就是不進行記錄，我們透過 priority_queue 最小的取出的方式，直接取出最小值，只要我們能夠不斷取出最小值，小到 0 就會是答案。</p>
<p>可能會有人想問 priority_queue 複雜度也是 \(o(log \ n )\)，為甚麼就可以用它呢？那是因為我們一定要用到他，不然 dijkstra 就寫不出來了XD。</p>
<h3 id="但注意的是，我們還是要禁止他不斷的左右交換、上下交換"><a href="#但注意的是，我們還是要禁止他不斷的左右交換、上下交換" class="headerlink" title="但注意的是，我們還是要禁止他不斷的左右交換、上下交換"></a>但注意的是，我們還是要禁止他不斷的左右交換、上下交換</h3><p>由於我們缺少了紀錄棋面，因此在 Dijkstra 當下的棋面會不斷的嘗試進行上下左右交換，但假如剛剛我們才讓空白拼圖與某一數字交換，現在又在交換回來不就徒勞無功了嗎？因此我們要拒絕這種可能性，而解決此問題就是紀錄剛剛的 Path，如果剛剛從左來，那我們就禁止往右、剛剛從上來，就禁止往下.、剛剛從下來，就禁止往上、剛剛從右來，就禁止往左。</p>
<h3 id="判斷拼圖有沒有解"><a href="#判斷拼圖有沒有解" class="headerlink" title="判斷拼圖有沒有解"></a>判斷拼圖有沒有解</h3><p>在數字拼圖中是有無解的情況發生，舉個例子， n = 2，透過 (1,1) = 1, (1,2) = 3 , (2,1) = 2，讀者嘗試看看是否能夠解出XD。</p>
<p>一定沒有辦法解出。能解出還請私密我XD，你太強了www。在數字拼圖的論文中則有講到先將數字拼圖展開成一維陣列，之後透過下述規則判斷是否可解。</p>
<ul>
<li>N 為奇數，那<strong>遞減數對</strong>為偶數時可以被解出</li>
<li>N 為偶數<ul>
<li>如果空白拼圖是出現在由底部開始數的<strong>奇數</strong>時，則遞減數對在<strong>偶數</strong>時可解</li>
<li>如果空白拼圖是出現在由底部開始數的<strong>偶數</strong>時，則遞減數對在<strong>奇數</strong>時可解</li>
</ul>
</li>
<li>遞減數對是甚麼？<br>如上面的 n = 2 例子，展開成一維陣列即是 1,3,2，那 3,2 就是遞減數對，數對定義為只要兩個數字且前面數字大於後面數字就代表一組數對，但必須維持原本一維陣列的順序。</li>
<li>更好的解釋請查看 <a href="https://www.geeksforgeeks.org/check-instance-15-puzzle-solvable/" target="_blank" rel="noopener">How to check if an instance of 15 puzzle is solvable? GeeksforGeeks</a></li>
</ul>
<h4 id="證明"><a href="#證明" class="headerlink" title="證明"></a>證明</h4><p>我們先將拼圖變成一維陣列後，可以知道在水平移動時一維陣列並不會被更動，空白拼圖不可以被當作數字，因此不會用 (數字,空白) 的遞減數對發生；但在垂直移動時一維陣列的值就會被改動，且影響的方式是將某一數字與另一數字位置交換，我們稱之為對調。</p>
<p>由於數字拼圖的每一步可以想像成每一組數字的排列，我們只是將她重新排列成某一狀態，這時我們可以將題目理解成將 <code>1,2,3,4,5</code> 轉換成 <code>4,2,1,3,5</code>，只需要將 4 移動到 1 前面再來讓 1 移動到 3 前面即可得到答案。</p>
<p>再來讓 4 移動到 1 前面總共移動了 3 步，讓 1 移動到 3 前面總共移動了 2 步，因此每次的移動就會是 \(n-1 \)，n 為中間有多少數字。</p>
<h4 id="再來我們要怎麼用奇偶數來解決是否可以解出來呢？"><a href="#再來我們要怎麼用奇偶數來解決是否可以解出來呢？" class="headerlink" title="再來我們要怎麼用奇偶數來解決是否可以解出來呢？"></a>再來我們要怎麼用奇偶數來解決是否可以解出來呢？</h4><blockquote>
<p><img src="https://i.imgur.com/1XXxwtr.png" alt=""></p>
</blockquote>
<p>如果我們假設綠色格子是奇數，紅色格子是偶數，那我們要能夠將空白拼圖從紅色格子移到綠色格子時，奇偶數一定會產生變化，根據上方遞減數對的交換的說明。</p>
<p>因此我們就可以得知一個結論，透過舉例說明：</p>
<ul>
<li>一開始的狀態，紅色的格子(3,3)為空白區塊，且目前為奇數。</li>
<li>最終狀態，綠色的格子(4,4)為空白區塊，且為偶數。<br>這樣一定可以達到，對八，因為只要進行一次交換那奇偶數就會交換。</li>
<li>那我們把最終型態改變一下，綠色的格子(4,4)為空白區塊，且為奇數。<br>這樣就勢必沒有辦法達到，因為紅色格子在跟綠色格子交換時奇偶數就會被改變，因此我們永遠不可能達到此情況。</li>
</ul>
<p>題目要求我們的最終棋面的遞減數對為 0，因此空白最下方並且遞減數對為偶數。</p>
<p>更好的解釋請看 <a href="https://www.youtube.com/watch?v=Jidu5yA99u0&ab_channel=%E6%96%B9%E5%A1%8A%E8%BD%89%E4%B8%8D%E5%BF%AB" target="_blank" rel="noopener">你解不開！數字華容道 (15 puzzle) 與奇偶性 - 方塊轉不快</a>，但要注意這裡有將空白拼圖當作 16 但此證明沒有，但他的動畫很棒，因此建議大家觀看。</p>
<p>再來我們可以得知，如果是水平互換時，遞減數對不變，垂直互換時則遞減數對則增加或減少 \(N-1\)，在沒有 16 的情況下。</p>
<ul>
<li>如果 n 是偶數，那麼在此公式下  \(N-1\) 出來必定會是奇數，因此每次的遞減數對都會少了奇數<ul>
<li>因此如果空白為底部開始數的第一行時，那麼遞減數對在偶數時可解</li>
<li>因此如果空白為底部開始數的第二行時，那麼遞減數對在奇數時可解<br>因為每次的遞減數對都會增加或減少 \(N-1\)，N 為 puzzle 寬度</li>
</ul>
</li>
<li>根據上面兩個重點就可以得知 N 為偶數且空白拼圖是出現在由底部開始數的<strong>奇數</strong>時，則遞減數對在<strong>偶數</strong>時可解</li>
<li>如果空白拼圖是出現在由底部開始數的<strong>偶數</strong>時，則遞減數對在<strong>奇數</strong>時可解</li>
<li>如果 n 是奇數，那麼垂直移動時遞減數對會減少 \(N-1\)，但由於 N 為奇數因此公式下來必定是偶數，但偶數減偶數還是偶數XD，好饒舌www，因此我們只需要判斷遞減數對為偶數即可。</li>
</ul>
<p>透過此結論就可以知道</p>
<ul>
<li>如果 N 為奇數，則能夠被解出的狀態只有遞減數對為偶數</li>
<li>如果 N 為偶數<ul>
<li>如果空白拼圖是出現在由底部開始數的<strong>奇數</strong>時，則遞減數對在<strong>偶數</strong>時可解</li>
<li>如果空白拼圖是出現在由底部開始數的<strong>偶數</strong>時，則遞減數對在<strong>奇數</strong>時可解</li>
</ul>
</li>
</ul>
<h3 id="判斷-puzzle-是否可被解的小優化"><a href="#判斷-puzzle-是否可被解的小優化" class="headerlink" title="判斷 puzzle 是否可被解的小優化"></a>判斷 puzzle 是否可被解的小優化</h3><p>cnt = 遞減數對、x 為一般我們在計算時的方向位置，舉例：(3,2) = 空白，那 x 就等於 3。<br>如果 x 等於奇數時，就表示由底部開始算就會是偶數，因為 N = 4，當 n = 4 那從底部算就會是 1，因此剛好符合條件底部為偶數時，遞減數對在奇數是可解，所以我們就直接 \(+x\)，因為奇數加偶數還是等於奇數。</p>
<p>反之，那 x 等於偶數時，底部就會是奇數，相加時狀態不會改變，如果 cnt = 奇數，那加上偶數還是奇數，如果 cnt = 偶數，那加上偶數還是偶數，因此只要 mod 2 == 0 就表示不可解。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>((cnt+x)%<span class="number">2</span> ==<span class="number">0</span>) <span class="comment">//判斷是否可解，這裡用了小優化，可看上面文章理解</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span> ;</span><br></pre></td></tr></table></figure>

<h3 id="小優化-string"><a href="#小優化-string" class="headerlink" title="小優化 string"></a>小優化 string</h3><p>string 用平常的 +=，時間複雜度比較高，因此這裡我們使用 <code>string.push_back(char)</code>，會更好些，因為我們要不斷的做在字串尾巴中加入方向，如果一直不段使用 += 會拖累我們的效能，因此用<code>string.push_back(char)</code>會更為優秀些。</p>
<h2 id="觀念重點"><a href="#觀念重點" class="headerlink" title="觀念重點"></a>觀念重點</h2><ul>
<li>A* 用法使用得宜</li>
<li>piority_queue struct 寫 operator</li>
<li>puzzle 是否可以被解出<ul>
<li>核心推理證明</li>
<li>遞減數對與空白在哪個位置要判斷奇偶數的小優化</li>
</ul>
</li>
<li>不可以使用 map or set 紀錄</li>
<li>跑 dijkstra 拒絕回到上一步</li>
<li>紀錄正確位置的寫法</li>
<li>string 小優化</li>
</ul>
<h2 id="參考來源"><a href="#參考來源" class="headerlink" title="參考來源"></a>參考來源</h2><ul>
<li><a href="https://oi-wiki.org/search/astar/" target="_blank" rel="noopener">A* oiwiki</a></li>
<li><a href="https://blog.csdn.net/helloworld10086/article/details/41908903" target="_blank" rel="noopener">UVA - 10181 15-Puzzle Problem（15数码 A*） HelloWorld10086 </a></li>
<li><a href="https://www.geeksforgeeks.org/check-instance-15-puzzle-solvable/" target="_blank" rel="noopener">How to check if an instance of 15 puzzle is solvable? GeeksforGeeks</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E6%88%B4%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">戴克斯特拉演算法 - wiki </a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E7%BD%AE%E6%8F%9B#cite_note-combination-1" target="_blank" rel="noopener">排列 - wiki </a></li>
<li><a href="https://blog.csdn.net/luomingjun12315/article/details/47376359" target="_blank" rel="noopener">STL 之 优先队列(priority_queue) Enstein_Jun </a></li>
<li><a href="https://sites.google.com/site/zsgititit/home/jin-jiec-cheng-shi-she-ji/stl/priority" target="_blank" rel="noopener">priority queue 高中資訊科技概論教師黃建庭的教學網站 </a></li>
<li><a href="https://www.youtube.com/watch?v=Jidu5yA99u0&ab_channel=%E6%96%B9%E5%A1%8A%E8%BD%89%E4%B8%8D%E5%BF%AB" target="_blank" rel="noopener">你解不開！數字華容道 (15 puzzle) 與奇偶性 - 方塊轉不快</a></li>
</ul>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>這題好難…，可能是我第一次學 A* 在寫這份題目中我獲得了許多痛苦的感覺XD，畢竟在還沒有辦法把題目解開之前人都不會是開心的八，歷經了 4 次程式版本，看了許多網路上大佬的程式碼仔細研究分析，終於找到適合我學習的程式碼好開心&gt;&lt;。題外話：我寫了 4 個版本，結果都 TLE 卡住</p>
<p>就算通關後還是為了要能夠讓我完整了解此題的運作，我又花了很多時間不斷去理解、嘗試，最終理解至現在，不得不說學習到了很多觀念與事物，但在了解的過程中也獲得了很多絕望感XD，因為想不出來嘛，就很容懷疑自己到底為甚麼要走演算法，讓自己過的那麼不開心。但其實通關後的成就感以及讓我學習到的思維，我認為是不會愧對於前面的痛苦地。</p>
<p>但每次想到要寫演算法，心還是會揪一下XD。</p>
<p>不過這裡還是要謝謝齊芫，他在我學習這題的過程中不斷指出我的邏輯問題，也退回我的邏輯概念讓我有機會可以去重新學習此題，減少了我在未來中可能會因為這次的學習瑕疵而犯的漏洞，很謝謝他。</p>
<p>要是沒有他每次給我一個邏輯壓制，我可能現在還覺得我很會寫演算法呢XD。</p>
<p>也謝謝在網路上提供資料的大神們，沒有你們我連學習的機會都沒有…，然後農場文章真的不要那麼氾濫，Google 管一下拉。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n ;</span><br><span class="line"><span class="comment">//unordered_map&lt;string,int&gt; visit ;</span></span><br><span class="line"><span class="comment">//set&lt;string&gt; visit ; // no set will be AC</span></span><br><span class="line"><span class="keyword">int</span> direct[<span class="number">4</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;&#125;; <span class="comment">//方向</span></span><br><span class="line"><span class="keyword">int</span> place[<span class="number">18</span>][<span class="number">2</span>] ; <span class="comment">//紀錄最終棋面每一個數字的 x,y 座標</span></span><br><span class="line"><span class="keyword">char</span> dname[<span class="number">4</span>] = &#123;<span class="string">'R'</span> , <span class="string">'L'</span> , <span class="string">'D'</span> , <span class="string">'U'</span>&#125;; <span class="comment">// 方向</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">state</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> graph[<span class="number">4</span>][<span class="number">4</span>] ;</span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="keyword">int</span> h=<span class="number">-1</span> , step=<span class="number">0</span> ;</span><br><span class="line">    <span class="built_in">string</span> path =<span class="string">""</span> ;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(state st) <span class="keyword">const</span>&#123; <span class="comment">//priority_queue 使用</span></span><br><span class="line">        <span class="keyword">return</span> h + step &gt; st.h + st.step ; <span class="comment">//輸出最小</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123; <span class="comment">//debug 測試用</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">4</span> ; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; <span class="number">4</span> ; j++)</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; graph[i][j] &lt;&lt; <span class="string">' '</span> ;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">h</span><span class="params">(<span class="keyword">int</span> graph[][<span class="number">4</span>])</span></span>&#123; <span class="comment">//曼哈頓距離</span></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">4</span> ; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; <span class="number">4</span> ; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(graph[i][j] == <span class="number">0</span> || (i == place[graph[i][j]][<span class="number">0</span>] &amp;&amp; \</span><br><span class="line">                                      j == place[graph[i][j]][<span class="number">1</span>]  ))</span><br><span class="line">                <span class="keyword">continue</span> ;</span><br><span class="line">            cnt += <span class="built_in">abs</span>(place[graph[i][j]][<span class="number">0</span>] - i) + <span class="built_in">abs</span>(place[graph[i][j]][<span class="number">1</span>] - j ) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt * <span class="number">10</span>  ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isboard</span><span class="params">(<span class="keyword">int</span> x , <span class="keyword">int</span> y )</span></span>&#123; <span class="comment">//判斷邊界</span></span><br><span class="line">    <span class="keyword">if</span>(x &gt;= <span class="number">0</span> &amp;&amp; x &lt; <span class="number">4</span> &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; <span class="number">4</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span> ;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isback</span><span class="params">(<span class="built_in">string</span> path , <span class="keyword">char</span> nxtD )</span></span>&#123; <span class="comment">//拒絕回到上一步的棋面</span></span><br><span class="line">    <span class="keyword">if</span>(path.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span> ; </span><br><span class="line">    <span class="keyword">char</span> D = path[path.size()<span class="number">-1</span>] ;</span><br><span class="line">    <span class="keyword">if</span>(D == <span class="string">'L'</span> &amp;&amp; nxtD == <span class="string">'R'</span> ) <span class="keyword">return</span> <span class="literal">true</span> ;</span><br><span class="line">    <span class="keyword">if</span>(D == <span class="string">'R'</span> &amp;&amp; nxtD == <span class="string">'L'</span> ) <span class="keyword">return</span> <span class="literal">true</span> ;</span><br><span class="line">    <span class="keyword">if</span>(D == <span class="string">'U'</span> &amp;&amp; nxtD == <span class="string">'D'</span> ) <span class="keyword">return</span> <span class="literal">true</span> ;</span><br><span class="line">    <span class="keyword">if</span>(D == <span class="string">'D'</span> &amp;&amp; nxtD == <span class="string">'U'</span> ) <span class="keyword">return</span> <span class="literal">true</span> ;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Astar</span><span class="params">(state input )</span></span>&#123; <span class="comment">// Astar 核心</span></span><br><span class="line">    priority_queue&lt;state&gt; q ;</span><br><span class="line">    <span class="comment">//visit.clear() ;</span></span><br><span class="line">    <span class="keyword">int</span> x , y;</span><br><span class="line">    state now , next ;</span><br><span class="line">    q.push(input);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        now = q.top() ; q.pop() ;</span><br><span class="line">        <span class="comment">//now.print();</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">4</span> ; i++)&#123; <span class="comment">//方向選擇</span></span><br><span class="line">            x = now.x + direct[i][<span class="number">0</span>] ;</span><br><span class="line">            y = now.y + direct[i][<span class="number">1</span>] ;</span><br><span class="line">            <span class="keyword">if</span>(!isboard(x,y)) <span class="keyword">continue</span> ; <span class="comment">//判斷邊界</span></span><br><span class="line">            <span class="keyword">if</span>(isback(now.path,dname[i])) <span class="keyword">continue</span> ; <span class="comment">//判斷是否回到上一步</span></span><br><span class="line">            next = now ; <span class="comment">//TLE key because this line go to 85 before.</span></span><br><span class="line">            next.step = now.step + <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">if</span>(next.step &gt; <span class="number">50</span> ) <span class="keyword">continue</span> ; <span class="comment">//判斷是否超過 50 步</span></span><br><span class="line">            swap(next.graph[x][y] , next.graph[now.x][now.y]);</span><br><span class="line">            <span class="comment">//now.print() ;</span></span><br><span class="line">            <span class="comment">//cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; y &lt;&lt; '\n' ;</span></span><br><span class="line">            <span class="comment">//next.print();</span></span><br><span class="line">            next.x = x ; next.y = y ;</span><br><span class="line">            next.h = h(next.graph) ;</span><br><span class="line">            next.path.push_back(dname[i]) ;</span><br><span class="line">            q.push(next);</span><br><span class="line">            <span class="keyword">if</span>(next.h == <span class="number">0</span> )&#123; <span class="comment">// 判斷是否已走到正確答案</span></span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; next.path &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; next.path &lt;&lt; '\n' ;</span></span><br><span class="line">            <span class="comment">//next.print();</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">issolve</span><span class="params">(<span class="keyword">int</span> graph[][<span class="number">4</span>])</span></span>&#123; <span class="comment">//此拼圖是否可以被解出</span></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span> , x , y  ;</span><br><span class="line">    <span class="keyword">int</span> num[<span class="number">16</span>] = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">4</span> ; i++)&#123; <span class="comment">//一維陣列化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; <span class="number">4</span> ; j++)&#123;</span><br><span class="line">            num[cnt++] = graph[i][j] ;</span><br><span class="line">            <span class="keyword">if</span>(graph[i][j]==<span class="number">0</span>) x = i , y = j ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cnt = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">16</span> ; i++)&#123; <span class="comment">//有多少遞減數對</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span> ; j &lt; <span class="number">16</span> ; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num[j] &amp;&amp; num[j] &lt; num[i]) cnt++ ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((cnt+x)%<span class="number">2</span> ==<span class="number">0</span>) <span class="comment">//判斷是否可解，這裡用了小優化，可看上面文章理解</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="comment">//ios::sync_with_stdio(0);</span></span><br><span class="line">    <span class="comment">//cin.tie(0);</span></span><br><span class="line">    <span class="comment">//cout.tie(0);</span></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">4</span> ; i++)&#123; <span class="comment">//紀錄正確答案位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; <span class="number">4</span> ; j++)&#123;</span><br><span class="line">            place[cnt][<span class="number">0</span>] = i ;</span><br><span class="line">            place[cnt++][<span class="number">1</span>] = j ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123; <span class="comment">//測資開始</span></span><br><span class="line">        state input ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">4</span> ; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; <span class="number">4</span> ; j++)&#123;</span><br><span class="line">                 <span class="built_in">cin</span> &gt;&gt; input.graph[i][j] ;</span><br><span class="line"></span><br><span class="line">                 <span class="keyword">if</span>(input.graph[i][j] == <span class="number">0</span>)</span><br><span class="line">                    input.x = i , input.y = j ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!issolve(input.graph) || !Astar(input))</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"This puzzle is not solvable.\n"</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="思考流程"><a href="#思考流程" class="headerlink" title="思考流程"></a>思考流程</h2><p>透過紙筆與黑板而思考而成的片段，放在網路上供我紀念XD</p>
<p>錯誤的程式碼就不放上來讓大家見笑了QQQQ。</p>
<blockquote>
<p><img src="https://i.imgur.com/UMMzOGr.jpg" alt=""><br><img src="https://i.imgur.com/6X3AmHY.jpg" alt=""><br><img src="https://i.imgur.com/Cnilh1u.jpg" alt=""><br><img src="https://i.imgur.com/raKaHeL.jpg" alt=""></p>
</blockquote>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>A*搜尋</tag>
      </tags>
  </entry>
  <entry>
    <title>演算法知識 - A* 搜尋</title>
    <url>/2021/01/07/Explain_Algorithm/Astar/</url>
    <content><![CDATA[<h2 id="A-介紹"><a href="#A-介紹" class="headerlink" title="A* 介紹"></a>A* 介紹</h2><p>A* 搜尋演算法，(A* 讀做 Astar)，在圖形平面上對對多個節點路徑求出最低成本的演算法，是將 BDS 與遍地圖(Graph Travel )的改進演算法。</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>主體還是以 BFS 為主，但多增加一個函式，啟發式搜尋(heuristic)找出最高的權重在使其進行 BFS，找出最高的權重為 \(f(x) = g(x) + h(x) \)，其中 \(g(x)\) 則是從起點走到當前節點的距離，\(h(x)\) 則是啟發式搜尋，用於猜測當前節點至終點的距離。</p>
<h3 id="啟發式搜尋-heuristic"><a href="#啟發式搜尋-heuristic" class="headerlink" title="啟發式搜尋(heuristic)"></a>啟發式搜尋(heuristic)</h3><p>在搜尋演算法中作為效率提升的一個手段，對於當前已知的資訊或結點進行評判，並對資訊進行評分，透過評分方式來使搜尋演算法找到最優的搜尋方向。</p>
<h2 id="資料來源"><a href="#資料來源" class="headerlink" title="資料來源"></a>資料來源</h2><p><a href="https://oi-wiki.org/search/astar/" target="_blank" rel="noopener">A* OIwiki</a><br><a href="https://oi-wiki.org/search/heuristic/" target="_blank" rel="noopener">启发式搜索 OIwiki</a></p>
]]></content>
      <categories>
        <category>演算法知識</category>
      </categories>
      <tags>
        <tag>程式解題</tag>
        <tag>演算法知識</tag>
        <tag>A*</tag>
      </tags>
  </entry>
  <entry>
    <title>資料庫管理 筆記 - 第七章 Databases in Applications</title>
    <url>/2021/01/13/NTUT_note/database7/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊與財金管理系大二上資料庫管理重點整理<br><font color="#dd0000">並非所有人都適用，部分對我而言稍加容易的內容並不會寫在此內。</font></p>
</blockquote>
<a id="more"></a>

<h2 id="Client-Server-Architecture-客戶端與伺服器架構"><a href="#Client-Server-Architecture-客戶端與伺服器架構" class="headerlink" title="Client/Server Architecture 客戶端與伺服器架構"></a>Client/Server Architecture 客戶端與伺服器架構</h2><ul>
<li>網路計算模型 Networked computing model</li>
<li>處理客戶端與伺服器行程(執行的程式) Processes distributed between clients and servers</li>
<li>客戶端<br>使用服務的計算機</li>
<li>伺服器<br>接受要求的計算機</li>
<li>DBMS 只有資料庫的伺服器</li>
<li>Internet 網路伺服器</li>
<li>圖解架構 <ul>
<li>上層 GUI 介面</li>
<li>中層 program , function </li>
<li>下層 DBMS activities(運作)</li>
<li>圖解<blockquote>
<p><img src="https://imgur.com/WcwVgZN.jpg" alt=""></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="應用分區-APPLICATION-PARTITIONING"><a href="#應用分區-APPLICATION-PARTITIONING" class="headerlink" title="應用分區 APPLICATION PARTITIONING"></a>應用分區 APPLICATION PARTITIONING</h3><ul>
<li>將每一分 code 放到適合的地方去運作，適合的地方有客戶端 / 伺服器</li>
<li>優點<ul>
<li>性能提升 Improved performance</li>
<li><a href="https://zh.wikipedia.org/zh-tw/%E4%BA%92%E6%93%8D%E4%BD%9C%E6%80%A7" target="_blank" rel="noopener">互操作性改善</a> Improved interoperability</li>
<li>平衡工作量 Balanced workloads</li>
</ul>
</li>
</ul>
<h3 id="Fat-and-Thin-Client"><a href="#Fat-and-Thin-Client" class="headerlink" title="Fat and Thin Client"></a>Fat and Thin Client</h3><ul>
<li>Fat<br>對於客戶端的電腦計算需求較大，DBMS 在客戶端</li>
<li>Thin<br>讓客戶端電腦只接受客戶需求，不在本地存取資料</li>
<li>圖解<blockquote>
<p><img src="https://i.imgur.com/A75n2jI.jpg" alt=""></p>
</blockquote>
</li>
</ul>
<h2 id="網路應用程式要素-WEB-APPLICATION-COMPONENTS"><a href="#網路應用程式要素-WEB-APPLICATION-COMPONENTS" class="headerlink" title="網路應用程式要素 WEB APPLICATION COMPONENTS"></a>網路應用程式要素 WEB APPLICATION COMPONENTS</h2><ul>
<li>Database server<br>需要一個 database Server，例如：Oracle, SQL Server, Informix, MS Access, MySql</li>
<li>Web server<br>接收與回應 http 要求，例如：apache</li>
<li>Application server，例如：PHP<br>透過程式碼編寫的<strong>動態網頁</strong></li>
<li>Web browser<br>客戶可以透過網頁來瀏覽，例如：chrome、IE</li>
</ul>
<h2 id="MIDDLEWARE-中介軟體-AND-APIS"><a href="#MIDDLEWARE-中介軟體-AND-APIS" class="headerlink" title="MIDDLEWARE(中介軟體) AND APIS"></a>MIDDLEWARE(中介軟體) AND APIS</h2><ul>
<li>MIDDLEWARE<br>允許應用程式去操作，而不需要用戶取理解程式碼或編寫。</li>
<li>Application Program Interface (API)<br>是一種應用程式，用來請求計算機執行程式或運算。</li>
<li>Common database APIs –ODBC, ADO .NET, JDBC</li>
</ul>
<h2 id="透過中介軟體使用-API-的-6-部曲-STEPS-FOR-USING-DATABASES-VIA-MIDDLEWARE-APIS"><a href="#透過中介軟體使用-API-的-6-部曲-STEPS-FOR-USING-DATABASES-VIA-MIDDLEWARE-APIS" class="headerlink" title="透過中介軟體使用 API 的 6 部曲  STEPS FOR USING DATABASES VIA MIDDLEWARE APIS"></a>透過中介軟體使用 API 的 6 部曲  STEPS FOR USING DATABASES VIA MIDDLEWARE APIS</h2><ul>
<li>建立或識別資料庫驅動程式</li>
<li>打開並連接資料庫</li>
<li>對資料庫執行查詢</li>
<li>處理查詢結果</li>
<li><strong>必要</strong>，反覆執行前兩點</li>
<li>關閉資料庫連接</li>
</ul>
<h2 id="Python-應用資料庫管理"><a href="#Python-應用資料庫管理" class="headerlink" title="Python 應用資料庫管理"></a>Python 應用資料庫管理</h2><ul>
<li>Model Class<br>創建數據、查詢數據</li>
<li>Serialize Class<br>轉換資料格式，如：data</li>
<li>View Class<br>讓使用者方便閱讀，如：browser</li>
</ul>
<h2 id="應用資料庫時的-3-個需要考慮因素"><a href="#應用資料庫時的-3-個需要考慮因素" class="headerlink" title="應用資料庫時的 3 個需要考慮因素"></a>應用資料庫時的 3 個需要考慮因素</h2><ul>
<li>儲存<ul>
<li>放在 DBMS 的程式碼</li>
<li>改善效能</li>
</ul>
</li>
<li>請求與呼叫資料庫 Transactions<ul>
<li>涉及許多資料庫的更新</li>
<li>有成功，才會執行成功，反之不執行</li>
</ul>
</li>
<li>資料庫連接<ul>
<li>開放連接並長期使用時會占用 database 大量資源</li>
<li>使用<a href="https://zh.wikipedia.org/wiki/%E8%BF%9E%E6%8E%A5%E6%B1%A0" target="_blank" rel="noopener">連接池</a></li>
</ul>
</li>
<li>考慮這些因素時的優點<ul>
<li>編譯 SQL code 效能提升</li>
<li>減少網路流量，而導致塞車的情況</li>
<li>提高安全性</li>
<li>加強資料完整性</li>
<li>Thinner clients</li>
<li>Scalability 可延伸性</li>
<li>Long-term cost reduction 降低長期成本</li>
<li>要求方與回應方更好進行配對 Better match of systems to business needs</li>
<li>改善客戶伺服器</li>
<li>擁有競爭優勢 Competitive advantage</li>
</ul>
</li>
<li>缺點<ul>
<li>寫程式要更多時間</li>
<li>有些演算法不可移植，需要重寫</li>
</ul>
</li>
</ul>
<h3 id="請求與呼叫完整性：ACID-TRANSACTION-INTEGRITY-ACID-RULES"><a href="#請求與呼叫完整性：ACID-TRANSACTION-INTEGRITY-ACID-RULES" class="headerlink" title="請求與呼叫完整性：ACID  TRANSACTION INTEGRITY: ACID RULES"></a>請求與呼叫完整性：ACID  TRANSACTION INTEGRITY: ACID RULES</h3><ul>
<li>Atomic<ul>
<li>請求與呼叫不可分割</li>
<li>Transaction cannot be subdivided</li>
</ul>
</li>
<li>Consistent <ul>
<li>請求前到請求後都沒有被改變</li>
<li>Constraints don’t change from before transaction to after transaction</li>
</ul>
</li>
<li>Isolated<ul>
<li>請求完成後用戶才會接收到資料</li>
<li>Database changes not revealed to users until after transaction has completed</li>
</ul>
</li>
<li>Durable<ul>
<li>資料庫的改動具有永久性</li>
<li>Database changes are permanent</li>
</ul>
</li>
</ul>
<h3 id="要求合法訪問-CONTROLLING-CONCURRENT-ACCESS"><a href="#要求合法訪問-CONTROLLING-CONCURRENT-ACCESS" class="headerlink" title="要求合法訪問 CONTROLLING CONCURRENT ACCESS"></a>要求合法訪問 CONTROLLING CONCURRENT ACCESS</h3><ul>
<li>問題<br>在多用戶不斷發送要求給伺服器時，同時訪問會造成資料庫資料不一致。(lost update problem)</li>
<li>解決方法<ul>
<li>保持資料完整性、並確保不會因為交互操作而導致資料庫資料不一致</li>
<li>Serializability 可序列化<br>變成 queue，一次一筆操作。請排隊</li>
<li>Locking Mechanisms 鎖定處理<ul>
<li>可序列化常用方法<br>The most common way of achieving serialization</li>
<li>在執行要求中，伺服器被鎖定<br>Data that is retrieved for the purpose of updating is locked for the updater</li>
<li>解鎖之前，其他用戶不可使用<br>No other user can perform update until unlocked</li>
<li>操作如下<blockquote>
<p><img src="https://i.imgur.com/q5KaIxk.jpg" alt=""></p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li>問題範例，同時操作資料庫但資料庫資料不一致<blockquote>
<p><img src="https://i.imgur.com/haCtPzf.jpg" alt=""></p>
</blockquote>
</li>
</ul>
<h4 id="LOCK-LEVEL"><a href="#LOCK-LEVEL" class="headerlink" title="LOCK LEVEL"></a>LOCK LEVEL</h4><ul>
<li>Database - used during database updates</li>
<li>Table - used for bulk updates 區塊更新</li>
<li>Block or page – very commonly used 非常常用</li>
<li>Record - only requested row; fairly commonly used 經常會用</li>
<li>Field –requires significant overhead; impractical<br>字段，需要大量效能，不切實際。</li>
</ul>
<h4 id="Types-of-locks"><a href="#Types-of-locks" class="headerlink" title="Types of locks"></a>Types of locks</h4><ul>
<li>Shared lock<ul>
<li>唯讀，只能在讀取資料時使用</li>
<li>Read but no update permitted. Used when just reading to prevent another user from placing an exclusive lock on the record</li>
</ul>
</li>
<li>Exclusive lock<ul>
<li>不可以用來閱讀，只能在更新時使用</li>
<li>No access permitted. Used when preparing to update</li>
</ul>
</li>
<li>Dead Lock<ul>
<li>兩個以上的請求佔住公用資源，並都在等待對方解鎖資源時就會發生</li>
<li>An impasse that results when two or more transactions have locked common resources, and each waits for the other to unlock their resources</li>
<li>圖解<blockquote>
<p><img src="https://imgur.com/84roCgl.jpg" alt=""></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h5 id="MANAGING-DEADLOCK"><a href="#MANAGING-DEADLOCK" class="headerlink" title="MANAGING DEADLOCK"></a>MANAGING DEADLOCK</h5><ul>
<li>Deadlock prevention 預防死鎖<ul>
<li>開始請求前，先將所有請求紀錄</li>
<li>試圖更新（上傳）的資料的會被鎖住</li>
<li>死鎖有成長期與收縮期</li>
<li>可能沒辦法去判斷需要多少資源來解決死鎖</li>
</ul>
</li>
<li>Deadlock Resolution 死鎖原因<ul>
<li>一定是因為允許死鎖的發生，<del>廢話，幹。但 PPT 真的這樣說..</del></li>
<li>打破了防止死鎖的機制</li>
<li>資源使用矩陣</li>
</ul>
</li>
</ul>
<h2 id="VERSIONING-版本化"><a href="#VERSIONING-版本化" class="headerlink" title="VERSIONING 版本化"></a>VERSIONING 版本化</h2><ul>
<li>替代鎖定</li>
<li>假設不同版本不會同時更新<br>Assumption is that simultaneous updates will be infrequent</li>
<li>每一筆請求都可以嘗試更新<br>Each transaction can attempt an update as it wishes</li>
<li>系統會建立新版本，而不是不斷替換舊版本<br>The system will create a new version of a record instead of replacing the old one</li>
<li>當請求衝突發生時，接收一個用戶的更新並通知另一用戶需要再次發送請求<br>When a conflict occurs, accept one user’s update and inform the other user that its update needs to be tried again</li>
<li>發生請求衝突時，將造成請求衝突的請求回朔到發生請求之前<br>Use of rollback and commit for this</li>
<li>圖解<br><a href="https://i.imgur.com/Wx9o930.jpg" target="_blank" rel="noopener">https://i.imgur.com/Wx9o930.jpg</a></li>
</ul>
<h2 id="DATA-SECURITY"><a href="#DATA-SECURITY" class="headerlink" title="DATA SECURITY"></a>DATA SECURITY</h2><ul>
<li>保護資料不被破壞或丟失<br>Protection of the data against accidental or intentional loss, destruction, or misuse</li>
<li>由於可以透過網路訪問而讓 DATA SECURITY 增加難度<br>Increased difficulty due to Internet access and client/server technologies</li>
</ul>
<h3 id="THREATS-TO-DATA-SECURITY-威脅資料安全"><a href="#THREATS-TO-DATA-SECURITY-威脅資料安全" class="headerlink" title="THREATS TO DATA SECURITY 威脅資料安全"></a>THREATS TO DATA SECURITY 威脅資料安全</h3><p>威脅來自許多來源，資訊系統中的多個位置都存在漏洞<br>Threats come from many sources and vulnerabilities exist in multiple places within an information system</p>
<ul>
<li>意外損失原因 Accidental losses attributable<ul>
<li>人為錯誤</li>
<li>軟體故障 Software failure</li>
<li>硬體故障 Hardware failure</li>
</ul>
</li>
<li>盜竊和詐欺 Theft and fraud</li>
<li>失去隱密或機密性 Loss of privacy or confidentiality<ul>
<li>Loss of privacy (personal data)</li>
<li>Loss of confidentiality (corporate data)公司資料</li>
</ul>
</li>
<li>失去資料完整性 Loss of data integrity </li>
<li>無法使用資料 Loss of availability (e.g., through sabotage) 例如：破壞</li>
</ul>
<blockquote>
<p><img src="https://imgur.com/CHuIq6N.jpg" alt=""></p>
</blockquote>
<h2 id="CLIENT–SERVER-APPLICATION-SECURITY"><a href="#CLIENT–SERVER-APPLICATION-SECURITY" class="headerlink" title="CLIENT–SERVER APPLICATION SECURITY"></a>CLIENT–SERVER APPLICATION SECURITY</h2><ul>
<li>Static HTML files are easy to secure(安全)<ul>
<li>Standard database access(訪問) controls</li>
<li>Place(放置) Web files in protected directories(目錄) on server</li>
</ul>
</li>
<li>Dynamic pages are harder<ul>
<li>User authentication</li>
<li>Session security</li>
<li>SSL for encryption</li>
<li>Restrict(限制) number of users and open ports</li>
<li>Remove unnecessary programs</li>
</ul>
</li>
</ul>
<h2 id="DATA-PRIVACY-隱私"><a href="#DATA-PRIVACY-隱私" class="headerlink" title="DATA PRIVACY(隱私)"></a>DATA PRIVACY(隱私)</h2><ul>
<li>W3C Web Privacy Standard<br>Platform for Privacy Protection (P3P)</li>
<li>Addresses the following 需要解決的問題<ul>
<li>Who collects data</li>
<li>What data is collected and for what purpose</li>
<li>Who is data shared with</li>
<li>Can users control access to their data 使用者可以去訪問資料</li>
<li>How are disputes resolved 如何解決紛爭</li>
<li>Policies(政策) for retaining(保留) data</li>
<li>Where are policies kept and how can they be accessed 哪裡可以查詢政策</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>北科上課筆記</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>資料庫管理</tag>
      </tags>
  </entry>
  <entry>
    <title>資料庫管理 筆記 - 第六章 Advanced SQL</title>
    <url>/2021/01/13/NTUT_note/database6/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊與財金管理系大二上資料庫管理重點整理<br><font color="#dd0000">並非所有人都適用，部分對我而言稍加容易的內容並不會寫在此內。</font></p>
</blockquote>
<a id="more"></a>

<h2 id="PROCESSING-MULTIPLE-TABLES-處理兩者以上的表"><a href="#PROCESSING-MULTIPLE-TABLES-處理兩者以上的表" class="headerlink" title="PROCESSING MULTIPLE TABLES 處理兩者以上的表"></a>PROCESSING MULTIPLE TABLES 處理兩者以上的表</h2><ul>
<li>Join<br>a relational operation that causes(原因) two or more tables with a common domain to be combined into a single table or view</li>
<li>Equi-join 類似於交集 - 有重複值<br>A join in which the joining condition(情況) is based on equality between values in the common columns; common columns appear redundantly(多餘) in the result table，也就是只要兩個表的某個值相同就會輸出，但那兩個同樣的值會被輸出兩次</li>
<li>Natural (inner) join 類似於交集<br>An equi-join(上面那點) in which one of the duplicate columns is eliminated(消除) in the result table</li>
<li>Outer join 類似於餘集<br>輸出表為值不相同的，A join in which rows that do not have matching values in common columns are nonetheless(儘管如此) included in the result table (as opposed(反對) to innerjoin, in which rows must have matching values in order to appear in the result table)</li>
<li>Union join 類似於聯集<br>Includes all data from each table that was joined</li>
<li>圖表<blockquote>
<p><img src="https://i.imgur.com/1U7KjW0.jpg" alt=""></p>
</blockquote>
</li>
<li>圖示 join 查詢<blockquote>
<p><img src="https://imgur.com/XzERFKl.jpg" alt=""></p>
</blockquote>
</li>
</ul>
<h3 id="上述-join-的-example"><a href="#上述-join-的-example" class="headerlink" title="上述 join 的 example"></a>上述 join 的 example</h3><ul>
<li>Equi-join<blockquote>
<p><img src="https://imgur.com/x1dEZK9.jpg" alt=""></p>
</blockquote>
</li>
<li>Inner Join <ul>
<li>INNER JOIN clause(子句) is an alternative(可替代) to WHERE clause, and is used to match primary(主) and foreign(外來) keys.</li>
<li>An INNER join will only return rows from each table that have matching rows in the other.</li>
<li>This query produces the same results as the previous(先前) equi-join example</li>
<li>程式碼 (圖)<blockquote>
<p><img src="https://imgur.com/H3MlEGa.jpg" alt=""></p>
</blockquote>
</li>
</ul>
</li>
<li>Nature Join <blockquote>
<p><img src="https://imgur.com/3j0Z2Iq.jpg" alt=""></p>
</blockquote>
</li>
<li>Outer Join <ul>
<li>LEFT OUTER JOIN clause causes(原因) rows from the first mentioned(提起) table (customer) to appear even if there is no corresponding order data.</li>
<li>Unlike(不像) an INNER join, this will include customer rows with no matching order rows.</li>
<li>程式碼 (圖)<blockquote>
<p><img src="https://imgur.com/BFq96ka.jpg" alt=""></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="透過命名變數讓輸出的名子改變"><a href="#透過命名變數讓輸出的名子改變" class="headerlink" title="透過命名變數讓輸出的名子改變"></a>透過命名變數讓輸出的名子改變</h2><p>What are the employee ID and name of each employee and the name of his or her supervisor(主管) (label the supervisor’s name Manager)?</p>
<blockquote>
<p><img src="https://imgur.com/C3p7gm8.jpg" alt=""></p>
</blockquote>
<h2 id="SUBQUERIES-子查詢"><a href="#SUBQUERIES-子查詢" class="headerlink" title="SUBQUERIES 子查詢"></a>SUBQUERIES 子查詢</h2><p>placing an inner query(內部查詢) (SELECT statement) inside an outer query(外部查詢)</p>
<ul>
<li>Options <ul>
<li>In a condition of the WHERE clause</li>
<li>As a “table” of the FROM clause</li>
<li>Returning a field(區塊) for the SELECT clause</li>
<li>Within the HAVING clause 在 having 子句內</li>
</ul>
</li>
<li>能夠做到的事<ul>
<li>Noncorrelated(非相關性) <ul>
<li>executed once for the entire outer query 執行一次整個外部查詢</li>
<li>Do not depend on data from the outer query 指不需要再外面寫一個 select，內部就可以寫外部查詢了 </li>
</ul>
</li>
<li>Correlated <ul>
<li>executed once for each row returned by the outer query 對每一欄執行一次外部查詢</li>
<li>Make use of data from the outer query 利用外部查詢的資料</li>
<li>Can use the EXISTS and ALL operators 可以使用EXISTS和ALL運算 </li>
<li>Example<blockquote>
<p><img src="https://imgur.com/JKUC8EC.jpg" alt=""></p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li>Example<ul>
<li><blockquote>
<p><img src="https://imgur.com/CwUaZFZ.jpg" alt=""></p>
</blockquote>
</li>
<li>另外一個方法可以解決上述問題<blockquote>
<p><img src="https://imgur.com/XsbGxFo.jpg" alt=""></p>
</blockquote>
</li>
</ul>
</li>
<li>查詢方法圖示<blockquote>
<p><img src="https://imgur.com/phHXpiU.jpg" alt=""></p>
</blockquote>
</li>
</ul>
<h3 id="ANOTHER-SUBQUERY-EXAMPLE-DERIVED-TABLE-另一種子查詢"><a href="#ANOTHER-SUBQUERY-EXAMPLE-DERIVED-TABLE-另一種子查詢" class="headerlink" title="ANOTHER SUBQUERY EXAMPLE /(DERIVED TABLE) 另一種子查詢"></a>ANOTHER SUBQUERY EXAMPLE /(DERIVED TABLE) 另一種子查詢</h3><p>將我們子查詢的值設成變數，在使他可以跟上面的查詢進行比較</p>
<blockquote>
<p><img src="https://imgur.com/ItsxXAo.jpg" alt=""></p>
</blockquote>
<h2 id="COMBINING-QUERIES"><a href="#COMBINING-QUERIES" class="headerlink" title="COMBINING QUERIES"></a>COMBINING QUERIES</h2><h3 id="UNION"><a href="#UNION" class="headerlink" title="UNION"></a>UNION</h3><p>將多個查詢 union 在一起，但所有的資料欄位與屬性都必須相同</p>
<p>Combine the output (union of multiple queries) together into a single result table<br>With UNION queries, the quantity and data types of the attributes in the SELECT clauses of both queries must be identical.</p>
<blockquote>
<p><img src="https://imgur.com/EYpaZ6w.jpg" alt=""></p>
</blockquote>
<h3 id="If-寫法，CONDITIONAL-EXPRESSIONS-USING-CASE-KEYWORD-使用大小寫關鍵字的條件表達"><a href="#If-寫法，CONDITIONAL-EXPRESSIONS-USING-CASE-KEYWORD-使用大小寫關鍵字的條件表達" class="headerlink" title="If 寫法，CONDITIONAL EXPRESSIONS USING CASE KEYWORD 使用大小寫關鍵字的條件表達"></a>If 寫法，CONDITIONAL EXPRESSIONS USING CASE KEYWORD 使用大小寫關鍵字的條件表達</h3><p>Select Case 可以做到程式中的 if-then，只需要透過此方式即可。 </p>
<p>CASE expression acts like an if-then statement. It allows you to choose what will appear in a column of the result set, depending on a condition.</p>
<p>範例如下</p>
<blockquote>
<p><img src="https://imgur.com/m6EKI08.jpg" alt=""></p>
</blockquote>
<h3 id="操作-View-關聯表-，MORE-COMPLICATED-SQL-QUERIES-更多複雜的-SQL-操作"><a href="#操作-View-關聯表-，MORE-COMPLICATED-SQL-QUERIES-更多複雜的-SQL-操作" class="headerlink" title="操作 View(關聯表)，MORE COMPLICATED SQL QUERIES 更多複雜的 SQL 操作"></a>操作 View(關聯表)，MORE COMPLICATED SQL QUERIES 更多複雜的 SQL 操作</h3><ul>
<li>資料庫可能會有好幾千個 table，而且 table 有很多 column<br>Production databases contain hundreds or even thousands of tables, and tables could include hundreds of columns.</li>
<li>因此查詢可能會變得非常複雜<br>So, sometimes query requirements can be very complex.</li>
<li>有時可以透過 View 來合併查詢<br>sometimes it’s useful to combine queries, through the use of Views.</li>
<li>如果使用 View(其中一個查詢)，也可以讓另外一個查詢使用 View，類似操作 table<br>If you use a view (which is a query), you could have another query that uses the view as if it were a table.</li>
<li>簡單來說 View 就是虛擬的 table，結合現在的 table or View 產生</li>
</ul>
<p>View 的操作範例</p>
<blockquote>
<p><img src="https://imgur.com/VB38lat.jpg" alt=""></p>
</blockquote>
<h3 id="TIPS-FOR-DEVELOPING-QUERIES"><a href="#TIPS-FOR-DEVELOPING-QUERIES" class="headerlink" title="TIPS FOR DEVELOPING QUERIES"></a>TIPS FOR DEVELOPING QUERIES</h3><ul>
<li>熟悉資料模型，實體與關聯性<br>Be familiar with the data model (entities and relationships)</li>
<li>了解想要的結果<br>Understand the desired(了解) results</li>
<li>知道結果中鎖需要的屬性<br>Know the attributes desired in results</li>
<li>辨識實體所包含的屬性<br>Identify the entities that contain desired attributes</li>
<li>Review ERD</li>
<li>對每一個 link 建構一個 where 相等性<br>Construct a WHERE equality for each link</li>
<li>如果需要，使用 GROUP BY 和 HAVING 子句<br>Fine tune with GROUP BY and HAVING clauses if needed</li>
<li>考慮異常資料對資料庫的影響<br>Consider the effect on unusual data</li>
</ul>
<h2 id="查詢效率的注意事項-QUERY-EFFICIENCY-CONSIDERATIONS"><a href="#查詢效率的注意事項-QUERY-EFFICIENCY-CONSIDERATIONS" class="headerlink" title="查詢效率的注意事項 QUERY EFFICIENCY CONSIDERATIONS"></a>查詢效率的注意事項 QUERY EFFICIENCY CONSIDERATIONS</h2><ul>
<li>在 select 中標註屬性而不用 *<br>Instead of SELECT *, identify the specific attributes in the SELECT clause; this helps reduce network traffic of result set</li>
<li>限制子查詢的數量，盡量在單查詢中查尋完畢<br>Limit the number of subqueries; try to make everything done in a single query if possible</li>
<li>如果要多次使用同樣查詢，就建立成關聯表(View)<br>If data is to be used many times, make a separate query and store it as a view</li>
</ul>
<h2 id="查詢設計方法-GUIDELINES-FOR-BETTER-QUERY-DESIGN"><a href="#查詢設計方法-GUIDELINES-FOR-BETTER-QUERY-DESIGN" class="headerlink" title="查詢設計方法 GUIDELINES FOR BETTER QUERY DESIGN"></a>查詢設計方法 GUIDELINES FOR BETTER QUERY DESIGN</h2><ul>
<li>了解再查詢資料中使用 index<br>Understand how indexes are used in query processing</li>
<li>保持優化且為最新<br>Keep optimizer statistics up to date</li>
<li>對於文字或字段兩種資料型態兼容<br>Use compatible data types for fields and literals(文字)</li>
<li>Write simple queries</li>
<li>把複雜查詢拆成簡單查詢<br>Break complex queries into multiple simple parts</li>
<li>盡量不要把查詢內嵌在另一個查詢<br>Don’t nest one query inside another query</li>
<li>自身查詢不跟自身連接<br>Don’t combine a query with itself (if possible avoid self-joins)</li>
<li>創建暫存表在擁有非常多查詢時<br>Create temporary tables for groups of queries</li>
<li>Combine update operations 合併更新操作</li>
<li>僅檢索需要的數據<br>Retrieve only the data you need</li>
<li>沒有 index 就沒辦法對 DBMS 排序<br>Don’t have the DBMS sort without an index</li>
<li>Learn! (…)</li>
<li>考慮某些特殊查詢在總查詢處理時間會不會過多<br>Consider the total query processing time for ad hoc queries</li>
</ul>
<h2 id="使用與定義關聯表-USING-AND-DEFINING-VIEWS"><a href="#使用與定義關聯表-USING-AND-DEFINING-VIEWS" class="headerlink" title="使用與定義關聯表 USING AND DEFINING VIEWS"></a>使用與定義關聯表 USING AND DEFINING VIEWS</h2><ul>
<li>Dynamic View<ul>
<li>對於用戶新增動態<strong>虛擬表</strong><br>A “virtual table” created dynamically upon request by a user</li>
<li>沒有資料儲存在 View，而是將原始資料提供給用戶<br>No data actually stored; instead data from base table made available to user</li>
<li>為 table or View 中的 SQL select 語法<br>Based on SQL SELECT statement on base tables or other views</li>
<li>Advantage 優點<ul>
<li>Simplify query commands</li>
<li>Assist(協助) with data security</li>
<li>Enhance(提高) programming productivity(生產率)</li>
<li>Contain most current base table data</li>
<li>Use little storage space</li>
<li>Provide customized(專屬打造) view for user</li>
<li>Establish(建立) physical(物理) data independence</li>
<li>每次使用 View 都需要時間<br>Use processing time each time view is referenced(被引用)</li>
<li>可能沒有辦法直接更新<br>May or may not be directly updateable</li>
<li>謹慎使用 View<br>As with all SQL constructs, you should use views with discretion</li>
</ul>
</li>
</ul>
</li>
<li>實質關聯表 Materialized View<ul>
<li>複製資料，實際儲存在 View<br>Copy or replication of data, data actually stored</li>
<li>需要不斷更新才可以與原本查詢的 table 資料相符<br>Must be refreshed periodically to match corresponding base tables</li>
</ul>
</li>
<li>Sample <ul>
<li>View has a name</li>
<li>View is based on a SELECT statement</li>
<li>CHECK_OPTIO 只能用來可以被更新的關聯表，並禁止更新不包含在 View 裡的資料<br>CHECK_OPTION works only for updateable views and prevents updates that would create rows not included in the view</li>
</ul>
</li>
</ul>
<h2 id="例行程序-ROUTINES-AND-TRIGGERS"><a href="#例行程序-ROUTINES-AND-TRIGGERS" class="headerlink" title="例行程序 ROUTINES AND TRIGGERS"></a>例行程序 ROUTINES AND TRIGGERS</h2><ul>
<li>Routines 需要執行的程式區塊</li>
<li>Functions 給 Routines 參數並回傳值</li>
<li>Procedures 給 Routines 參數並<strong>不傳</strong>值</li>
<li>Triggers 當 Routines 啟動到特殊事件時觸發</li>
<li>Procedures and functions are called explicitly(明確調用). Triggers are event-driven(事件觸發).</li>
<li>圖示<blockquote>
<p><img src="https://imgur.com/qtZevFX.jpg" alt=""></p>
</blockquote>
</li>
<li>Triggers Sample 有兩張<blockquote>
<p><img src="https://imgur.com/dnxZMF3.jpg" alt=""><br><img src="https://imgur.com/6p5occl.jpg" alt=""></p>
</blockquote>
</li>
</ul>
<h2 id="SQL-ENHANCEMENTS-增強"><a href="#SQL-ENHANCEMENTS-增強" class="headerlink" title="SQL ENHANCEMENTS(增強)"></a>SQL ENHANCEMENTS(增強)</h2><ul>
<li>User-defined data types (UDT) 自定義資料型態</li>
<li>可設定子類別為標準型態 or object<br>Subclasses of standard types or an object type</li>
<li>Analytical functions (for OLAP)<ul>
<li>CEILING, FLOOR, SQRT, RANK, DENSE_RANK, ROLLUP, CUBE, SAMPLE,</li>
<li>WINDOW –improved numerical analysis capabilities</li>
</ul>
</li>
<li>New Data Types<br>BIGINT, MULTISET (collection), XML</li>
<li>CREATE TABLE LIKE<br>create a new table similar to an existing one</li>
<li>MERGE</li>
</ul>
<h2 id="SQL-EXTENSIONS-擴展"><a href="#SQL-EXTENSIONS-擴展" class="headerlink" title="SQL EXTENSIONS(擴展)"></a>SQL EXTENSIONS(擴展)</h2><ul>
<li>Persistent(永久的) Stored Modules (SQL/PSM)</li>
<li>Capability(能力) to create and drop(刪除) code modules</li>
<li>New statements: CASE, IF, LOOP, FOR, WHILE, etc.</li>
<li>Makes SQL into a <a href="https://zh.wikipedia.org/wiki/%E8%BF%87%E7%A8%8B%E5%BC%8F%E7%BC%96%E7%A8%8B" target="_blank" rel="noopener">procedural language(可以變成函式相互呼叫)</a></li>
<li>Oracle has propriety version(專有版本) called PL/SQL, and Microsoft SQL Server has Transact/SQL</li>
</ul>
]]></content>
      <categories>
        <category>北科上課筆記</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>資料庫管理</tag>
      </tags>
  </entry>
  <entry>
    <title>b944- 好想上廁所(男廁篇)</title>
    <url>/2021/01/21/zerojudge/b944/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>男生要上廁所，通常會相隔一個小便斗，如果沒有，就從數字最小的廁所開始找第一間空間上廁所，沒有辦法上廁所就輸出 “  Not enough” </p>
<p>輸出<br><a href="https://zerojudge.tw/ShowProblem?problemid=b944" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="觀念重點"><a href="#觀念重點" class="headerlink" title="觀念重點"></a>觀念重點</h2><ul>
<li>兩種規則<ul>
<li>先嘗試能否在相隔的情況下上廁所</li>
<li>從最小的廁所開始上，找到空格</li>
</ul>
</li>
<li>有可能進去上廁所，但是時間是零秒，但在這次還是要照常輸出</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>簡單的操作題，根據題目進行分析輸出，在每一個程式碼中放入簡單註解，希望大家可以看懂XD。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">b944</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		<span class="keyword">int</span> n , a , b ;</span><br><span class="line">		n = input.nextInt() ;</span><br><span class="line">		<span class="keyword">int</span> num[] = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">2</span>]; <span class="comment">//使用的編號 </span></span><br><span class="line">		<span class="keyword">int</span> time[] = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">2</span>]; <span class="comment">//剩下使用的時間</span></span><br><span class="line">		<span class="keyword">while</span>(input.hasNext()) &#123;</span><br><span class="line">			a = input.nextInt(); </span><br><span class="line">			b = input.nextInt();</span><br><span class="line">			<span class="keyword">int</span> flag = <span class="number">1</span> ; <span class="comment">//判斷這次有沒有成功找到廁所</span></span><br><span class="line">            <span class="comment">// 1 是還沒找到廁所， 0 是找到了</span></span><br><span class="line">			</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; i++) &#123; <span class="comment">//將上次的狀態進行更新</span></span><br><span class="line">				<span class="keyword">if</span>(num[i] != <span class="number">0</span>) &#123; <span class="comment">//表示有人正在使用</span></span><br><span class="line">					time[i] -=<span class="number">1</span> ; <span class="comment">//時間減一 </span></span><br><span class="line">					<span class="keyword">if</span>(time[i] &lt; <span class="number">0</span> ) time[i] = <span class="number">0</span> ; </span><br><span class="line">                    <span class="comment">//如果剛剛上廁所的人是零秒，在剛剛會被 -1 秒，因此現在歸零</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span>(time[i] &lt;= <span class="number">0</span> ) num[i] = <span class="number">0</span> ; <span class="comment">// 0 秒表示上完廁所，使用號碼歸零</span></span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; i++) &#123; <span class="comment">//第一個規則</span></span><br><span class="line">				<span class="keyword">if</span>(num[i]==<span class="number">0</span> &amp;&amp; num[i-<span class="number">1</span>]==<span class="number">0</span> &amp;&amp; num[i+<span class="number">1</span>]==<span class="number">0</span>) &#123; </span><br><span class="line">                    <span class="comment">//看當前間、左邊、右邊使否為空間</span></span><br><span class="line">					num[i] = a ; <span class="comment">//這間廁所被 a  使用  </span></span><br><span class="line">					time[i] = b ; <span class="comment">// 使用 b 秒</span></span><br><span class="line">					flag = <span class="number">0</span> ; <span class="comment">//成功找到廁所</span></span><br><span class="line">					<span class="keyword">break</span> ;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(flag==<span class="number">1</span>) &#123; <span class="comment">//還沒找到廁所，就用第二種規則</span></span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; i++) &#123;</span><br><span class="line">					<span class="keyword">if</span>(num[i] == <span class="number">0</span>) &#123; <span class="comment">//這間廁所沒有被使用，那就讓她使用</span></span><br><span class="line">						num[i] = a ; </span><br><span class="line">						time[i] = b ;</span><br><span class="line">						flag = <span class="number">0</span> ; <span class="comment">//成功找到廁所</span></span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span>(flag == <span class="number">1</span> ) <span class="comment">//表示還沒找到廁所，所以輸出 not enough </span></span><br><span class="line">				System.out.print(<span class="string">"  Not enough\n"</span>);</span><br><span class="line">			</span><br><span class="line">			System.out.print(<span class="string">"Number:"</span>); <span class="comment">//輸出廁所使用的編號</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; i++) &#123;</span><br><span class="line">				System.out.printf(<span class="string">" %d"</span> , num[i]);</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.printf(<span class="string">"\n"</span>);</span><br><span class="line">			</span><br><span class="line">			System.out.print(<span class="string">"Time:"</span>); <span class="comment">//輸出每個廁所的使用時間</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; i++) &#123;</span><br><span class="line">				System.out.printf(<span class="string">" %d"</span> , time[i]);</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.printf(<span class="string">"\n"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>久違的寫 zerojudge 程式題目，zerojudge 是刷簡單題的好區，可以快速累積新手經驗值，可以讓自己程式變優秀的好地方(◍•ᴗ•◍)❤️。</p>
<p>題外話：UVa 好難喔..，一個啟發式搜尋要讓我使用 range tree，我真的會哭喔 ಥ⌣ಥ。</p>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>程式解題</tag>
        <tag>實作題</tag>
        <tag>zerojudge</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa12863 - Journey through the kingdom(A*搜尋 、2D BIT)</title>
    <url>/2021/01/24/UVa/UVa12863/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>ICPC 是一家保全公司，負責將重要的資料從 A 地搬運到 B 地，此地圖是個表格，我們會告訴你每一個點 (i,j)，能夠到的最大的距離與成本，接下來請寫一個程式告訴我們從 A 地到 B 地的最小成本。</p>
<p>提供 3 個 n*m 的陣列，第一個是成本陣列、第二個是每一個節點最大可以走幾個 Row、第三個則是每一個節點最多可以走 Column。</p>
<p>此題為嚴格輸出比對，需要完全的嚴謹。<br><a href="">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li>最短路徑用法 (dijkstra)</li>
<li>RangeTree<ul>
<li>選擇要用哪個比較好，BIT or Segment Tree? 這裡要使用 BIT</li>
</ul>
</li>
<li>判斷時間複雜度與了解 Range Tree 每一種資料結構的時間複雜度</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>好題，好題，這題好題，讓我學到了很多知識，也謝謝 morris 大大讓我在學習知識的路上成長了許多。</p>
<p>首先根據題目要求我們可以明顯知道這題一定是使用 Dijkstra，那現在我們接下來就會遇到一些問題</p>
<h3 id="QUESTION-A-如何判斷-dijkstra-的權重呢"><a href="#QUESTION-A-如何判斷-dijkstra-的權重呢" class="headerlink" title="QUESTION A: 如何判斷 dijkstra 的權重呢"></a>QUESTION A: 如何判斷 dijkstra 的權重呢</h3><p>由於題目要求成本必須最小，因此我們一定要設定一個 struct，並且寫一個 operator 讓成本最小的優先讓 queue top，假如成本都一樣時，我們就比較<a href="https://theriseofdavid.github.io/2021/01/09/UVa/UVa10181/#曼哈頓距離" target="_blank" rel="noopener">曼哈頓距離</a>誰比較接近終點的優先 top。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Node &amp;a) <span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(v != a.v) <span class="comment">//成本</span></span><br><span class="line">        <span class="keyword">return</span> a.v &lt; v ;</span><br><span class="line">    <span class="keyword">return</span> a.h &lt; h ; <span class="comment">//曼哈頓距離</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="QUESTION-B-要如何知道當前節點能走到那些節點呢？"><a href="#QUESTION-B-要如何知道當前節點能走到那些節點呢？" class="headerlink" title="QUESTION B: 要如何知道當前節點能走到那些節點呢？"></a>QUESTION B: 要如何知道當前節點能走到那些節點呢？</h3><p>由於每個節點都有可以走訪的最大長度 C(column) or R(row)，因此我們只要判斷\(當前節點 \pm 最大長度 \)，並不讓它超出邊界即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">lr = max(<span class="number">1</span>, u.r-R[u.r][u.c]); rr = min(n, u.r+R[u.r][u.c]);</span><br><span class="line"><span class="comment">//lr = 左邊界 rr = 右邊界</span></span><br><span class="line">lc = max(<span class="number">1</span>, u.c-C[u.r][u.c]); rc = min(m, u.c+C[u.r][u.c]);</span><br><span class="line"><span class="comment">// lc = 上邊界 rc = 下邊界</span></span><br></pre></td></tr></table></figure>

<h3 id="QUESTION-C-要如何知道節點有沒有被走訪過呢？"><a href="#QUESTION-C-要如何知道節點有沒有被走訪過呢？" class="headerlink" title="QUESTION C: 要如何知道節點有沒有被走訪過呢？"></a>QUESTION C: 要如何知道節點有沒有被走訪過呢？</h3><p>由於這題的邊都是單向邊，然而我們的目標則是要找出所有未走訪的點加入 queue，我們每次要查找有哪些點沒有被走訪時，可以有這幾種方法</p>
<ul>
<li>for 雙重迴圈查找<br>由於每次的時間複雜度都是 \(n^2\)，不理想，因此我們不使用</li>
<li>2D Binary Index Tree<br>由於 Binary Index Tree 查詢時間複雜度是 \(O(\log{N})\)，單點修改也是\(O(\log{N})\)，在對於會有大量節點進入 queue 中的 dijkstra 中是一個好選擇</li>
<li>2D Segment Tree<br>Segment Tree 與 Binary Index Tree 大致相同，Segment Tree 比 Binary Index Tree 用途更廣泛一些，但 Binary Index Tree 實現過程中較為好寫 ，但因為這裡的矩陣長度一致性極高，不會有區間不相同的問題且區間相同都是 1，因此這裡我們使用 Binary Index Tree。</li>
</ul>
<p><a href="https://stackoverflow.com/questions/17466218/what-are-the-differences-between-segment-trees-interval-trees-binary-indexed-t" target="_blank" rel="noopener">What are the differences between segment trees, interval trees, binary indexed trees and range trees? - stackoverflow</a></p>
<p>對於 Binary Index Tree or Segment Tree 我還沒寫出詳解，以後如果有寫會補上。</p>
<h3 id="2D-Binary-Index-Tree-建立、修改、查詢方法"><a href="#2D-Binary-Index-Tree-建立、修改、查詢方法" class="headerlink" title="2D Binary Index Tree 建立、修改、查詢方法"></a>2D Binary Index Tree 建立、修改、查詢方法</h3><h4 id="建立-init"><a href="#建立-init" class="headerlink" title="建立 init"></a>建立 init</h4><p>在 2D Binary Index Tree 中不會像 1D Binary Index Tree 建立方式完全相同，大致上相同，且每個點都需要新增(modify)初始值。</p>
<p>值得注意的是 2D Binary Index Tree，的最大長度在這題我們會設定不可以大於 Row or Column 的最大數量，因為我們可以透過 2D Binary Index Tree 相減的方式來找出當前節點應該要有的值為何</p>
<p>舉例：我們想要查找 4 的值，那就只需要讓 4 這個節點減掉 2 與 3 這兩個節點就可以知道 4 原本的值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> A[MAXN][MAXN] ;</span><br><span class="line"><span class="keyword">int</span> R , C ;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> _R, <span class="keyword">int</span> _C)</span></span>&#123;</span><br><span class="line">    R = _R ;</span><br><span class="line">    C = _C ;</span><br><span class="line">    <span class="built_in">memset</span>(A,<span class="number">0</span>,<span class="keyword">sizeof</span>(A));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= R ; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= C ; j++)</span><br><span class="line">            modify(i, j, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="modify-修改"><a href="#modify-修改" class="headerlink" title="modify 修改"></a>modify 修改</h4><p>2D Binary Index Tree，使用雙重迴圈，由於是二維的因此 x,y 座標都必須使用 lowbit 且 y 軸必須因為 x 軸的變化而變回 1。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(; x &lt;= R ; x += lowbit(x))&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = y ; i &lt;= C ; i += lowbit(i))</span><br><span class="line">            A[x][i] += val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="query-查詢"><a href="#query-查詢" class="headerlink" title="query 查詢"></a>query 查詢</h4><p>這是與 1D Binary Index Tree，最不同的地方，因為 2D Binary Index Tree 如果只對一個區間查詢如 \((x_1,y_1)\) ~ \((x_2,y_2)\)，如果只對 \((x_2,y_2)\) 進行像 1D Binary Index Tree 查詢就會使查找範圍變為 \((1,1)\) ~ \((x_2,y_2)\)，這裡的 index 從 1 開始，透過圖片來示意即是：</p>
<p><a href="https://iq.opengenus.org/2d-fenwick-tree/" target="_blank" rel="noopener">2D Fenwick Tree / 2D Binary Indexed Tree</a></p>
<blockquote>
<p><img src="https://i.imgur.com/nHz5TUm.png" alt=""></p>
</blockquote>
<p>相信讀者已經大概了解我在說甚麼，為了讓我們的查找範圍可以順利查找成功，因此我們要減去\((x_2,y_1)\) ~ \((0,0)\) 與 \((x_1,y_2)\) ~ \((0,0)\) 再加上 \((x_1,y_1)\) 的範圍來補回我們之前多減的區塊。</p>
<p>可能會有些讀者想問，那我能不能夠一口氣查詢 \((x_1,y_1)\) ~ \((x_2,y_2)\) 的範圍呢？答案是不行的，因為我們在修改值的時候會讓 1 的節點值加給 2 號節點，再讓 2 號節點加給 3 號節點(lowbit) 的效果，因此我們沒有辦法一口氣就查詢完畢。</p>
<p>必須先寫一個 sub query 來讓對每塊長方形進行查詢，在進行加減法來達到我們想查詢的範圍</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123; <span class="comment">//子查詢 sub query</span></span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span>(; x &gt; <span class="number">0</span> ; x -= lowbit(x))&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = y ; i&gt;<span class="number">0</span> ; i -= lowbit(i))</span><br><span class="line">            cnt += A[x][i] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rectCnt</span><span class="params">(<span class="keyword">int</span> lx, <span class="keyword">int</span> ly, <span class="keyword">int</span> rx, <span class="keyword">int</span> ry)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> query(rx,ry) - query(lx<span class="number">-1</span>,ry) - query(rx, ly<span class="number">-1</span>) + query(lx<span class="number">-1</span>, ly<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="QUESTION-D-嚴格比對怎麼寫比較好呢？"><a href="#QUESTION-D-嚴格比對怎麼寫比較好呢？" class="headerlink" title="QUESTION D: 嚴格比對怎麼寫比較好呢？"></a>QUESTION D: 嚴格比對怎麼寫比較好呢？</h3><p>由於是嚴格比對，因此我們輸出要特別小心，要<strong>完全一樣</strong>，但比較能夠放心的是我們可以用簡單的寫法去實現即可，也就是當我們讀到最後一筆時再輸出 <code>\n</code>，其他都輸出 space 即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++)&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; findPath(r, c, P[i<span class="number">-1</span>][<span class="number">0</span>], P[i<span class="number">-1</span>][<span class="number">1</span>], P[i][<span class="number">0</span>], P[i][<span class="number">1</span>]) ;</span><br><span class="line">    <span class="keyword">if</span>(i==n<span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="QUESTION-E-priority-queue-有沒有清空函式呢"><a href="#QUESTION-E-priority-queue-有沒有清空函式呢" class="headerlink" title="QUESTION E: priority_queue 有沒有清空函式呢"></a>QUESTION E: priority_queue 有沒有清空函式呢</h3><p>答案是沒有，因此手寫一個迴圈不斷 pop 到 queue 被清空即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(!q.empty()) q.pop(); <span class="comment">//由於 queue 沒有清空，因此寫個清空</span></span><br></pre></td></tr></table></figure>

<h2 id="參考來源"><a href="#參考來源" class="headerlink" title="參考來源"></a>參考來源</h2><ul>
<li><a href="http://morris821028.github.io/2014/11/22/uva-12863/" target="_blank" rel="noopener">UVa 12863 - Journey through the kingdom - Morris’ Blog </a></li>
<li><a href="https://iq.opengenus.org/2d-fenwick-tree/" target="_blank" rel="noopener">OpenGenus IQ: Learn Computer Science - 2D Fenwick Tree / 2D Binary Indexed Tree</a></li>
<li><a href="https://stackoverflow.com/questions/17466218/what-are-the-differences-between-segment-trees-interval-trees-binary-indexed-t" target="_blank" rel="noopener">What are the differences between segment trees, interval trees, binary indexed trees and range trees? - stackoverflow</a></li>
</ul>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>這題學到蠻多東西的，也讓我把整個程式碼的排版稍微再重新整理一些，最近學到要讓自己的程式碼風格與大家相同才會讓他人在看我的程式碼時不會感到厭煩，會開心一些。</p>
<p>也謝謝我在學習演算法時網路上提供資源的大神們，讓我在學習的路上可以更輕鬆，有資源讓我進行成長，沒有他們我不知道這題我還要學習多久。</p>
<p>題外話：最近發現寫網頁前端不需要訓練太久，薪水也蠻不錯的就讓我覺得學演算法似乎沒什麼太大幫忙QQ，希望未來可以打翻這個認知，不然會讓我很難過啊，嗚嗚。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 512</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) x&amp;(-x)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> V[MAXN][MAXN], R[MAXN][MAXN], C[MAXN][MAXN], P[MAXN][<span class="number">2</span>] ;</span><br><span class="line"><span class="comment">//V 是成本 R 是可擴長的 row , C 是可擴展的 column , P 是要查詢從某地到某地的紀錄</span></span><br><span class="line"><span class="keyword">int</span> TX , TY ; <span class="comment">// 終點 x 終點 y</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span> <span class="comment">//dijkstra 用到的節點</span></span><br><span class="line">    <span class="keyword">int</span> r, c, v, h; <span class="comment">// r=x , c=y , h 等於漢明距離 , v 是成本</span></span><br><span class="line">    Node(<span class="keyword">int</span> _r=<span class="number">0</span>,<span class="keyword">int</span> _c=<span class="number">0</span>, <span class="keyword">int</span> _v=<span class="number">0</span>, <span class="keyword">int</span> _h=<span class="number">0</span>):  <span class="comment">//輸入值可以有這種寫法</span></span><br><span class="line">        r(_r), c(_c), h(_h), v(_v) &#123;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Node &amp;a) <span class="keyword">const</span>&#123; <span class="comment">//看大衛的筆記 , UVa 10181 </span></span><br><span class="line">        <span class="keyword">if</span>(v != a.v)</span><br><span class="line">            <span class="keyword">return</span> a.v &lt; v ; <span class="comment">//最小</span></span><br><span class="line">        <span class="keyword">return</span> a.h &lt; h ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;Node&gt; q ; <span class="comment">// dijkstra</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BIT</span>&#123;</span> <span class="comment">// 2D binary indexed tree，狀態樹 注意，這裡是二維</span></span><br><span class="line">    <span class="keyword">int</span> A[MAXN][MAXN] ; <span class="comment">// 走過的點 1 為還沒走過</span></span><br><span class="line">    <span class="keyword">int</span> R , C ;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> _R, <span class="keyword">int</span> _C)</span></span>&#123;</span><br><span class="line">        R = _R ;</span><br><span class="line">        C = _C ;</span><br><span class="line">        <span class="built_in">memset</span>(A,<span class="number">0</span>,<span class="keyword">sizeof</span>(A));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= R ; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= C ; j++)</span><br><span class="line">                modify(i, j, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> val)</span></span>&#123; <span class="comment">//修改值</span></span><br><span class="line">        <span class="keyword">for</span>(; x &lt;= R ; x += lowbit(x))&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = y ; i &lt;= C ; i += lowbit(i))</span><br><span class="line">                A[x][i] += val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123; <span class="comment">//sub query</span></span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span>(; x &gt; <span class="number">0</span> ; x -= lowbit(x))&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = y ; i&gt;<span class="number">0</span> ; i -= lowbit(i))</span><br><span class="line">                cnt += A[x][i] ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rectCnt</span><span class="params">(<span class="keyword">int</span> lx, <span class="keyword">int</span> ly, <span class="keyword">int</span> rx, <span class="keyword">int</span> ry)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> query(rx,ry) - query(lx<span class="number">-1</span>,ry) - query(rx, ly<span class="number">-1</span>) + query(lx<span class="number">-1</span>, ly<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> lx, <span class="keyword">int</span> ly, <span class="keyword">int</span> rx, <span class="keyword">int</span> ry, <span class="keyword">int</span> val, <span class="keyword">int</span> tot)</span></span>&#123;</span><br><span class="line">        <span class="comment">//lr = 左邊界 rr = 右邊界</span></span><br><span class="line">        <span class="comment">//lc = 上邊界 rc = 下邊界</span></span><br><span class="line">        <span class="comment">// val 成本 tot 當前還有多少節點</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(tot == <span class="number">-1</span>) <span class="comment">//表示還未查詢過，現在進行查詢</span></span><br><span class="line">            tot = rectCnt(lx,ly,rx,ry); </span><br><span class="line">        <span class="keyword">if</span>(tot == <span class="number">0</span>) <span class="keyword">return</span> ; <span class="comment">//已經沒有節點，表示都有走訪過</span></span><br><span class="line">        <span class="keyword">if</span>(lx == rx)&#123; <span class="comment">//先透過 x 進行二分查詢，如果一樣在對 y 進行二分查詢</span></span><br><span class="line">            <span class="keyword">if</span>(ly == ry)&#123; <span class="comment">//已經抵達未走訪的節點</span></span><br><span class="line">                q.push(Node(lx, ly, val+V[lx][ly], <span class="built_in">abs</span>(lx-TX)+<span class="built_in">abs</span>(ly-TY))); <span class="comment">//增加節點</span></span><br><span class="line">                modify(lx, ly, <span class="number">-1</span>);</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> cnt = rectCnt(lx, ly, rx, (ly+ry)/<span class="number">2</span>); <span class="comment">//查找二分後的節點，cnt 表示左邊</span></span><br><span class="line">            <span class="keyword">if</span>(cnt) <span class="comment">//如果左邊還有節點表示還沒有走訪</span></span><br><span class="line">                update(lx, ly, rx, (ly+ry)/<span class="number">2</span>, val, cnt);</span><br><span class="line">            <span class="keyword">if</span>(cnt &lt; tot)  <span class="comment">//表示右半部還有節點還沒有走訪</span></span><br><span class="line">                update(lx, (ly+ry)/<span class="number">2</span> + <span class="number">1</span>, rx, ry, val, tot - cnt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> cnt = rectCnt(lx, ly, (lx+rx)/<span class="number">2</span>, ry);  <span class="comment">//查找二分後的節點，cnt 表示左邊</span></span><br><span class="line">            <span class="keyword">if</span>(cnt) <span class="comment">//如果左邊還有節點表示還沒有走訪</span></span><br><span class="line">                update(lx, ly, (lx+rx)/<span class="number">2</span>, ry, val, cnt);</span><br><span class="line">            <span class="keyword">if</span>(cnt &lt; tot) <span class="comment">//表示右半部還有節點還沒有走訪</span></span><br><span class="line">                update((lx+rx)/<span class="number">2</span> + <span class="number">1</span>, ly, rx, ry, val, tot - cnt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;bit;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findPath</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="keyword">int</span> sx, <span class="keyword">int</span> sy, <span class="keyword">int</span> ex, <span class="keyword">int</span> ey)</span></span>&#123; <span class="comment">//dijkstra 主題核心</span></span><br><span class="line">    <span class="keyword">if</span>(sx == ex &amp;&amp; sy == ey ) <span class="keyword">return</span> <span class="number">0</span> ; <span class="comment">//當前位置就是終點位置</span></span><br><span class="line">    TX = ex ; TY = ey ; <span class="comment">//設定值</span></span><br><span class="line">    bit.init(n, m); <span class="comment">//建立圖</span></span><br><span class="line">    bit.modify(sx, sy, <span class="number">-1</span>); <span class="comment">//將起點可以走訪到的點都設為 -1</span></span><br><span class="line">    <span class="comment">//clear</span></span><br><span class="line">    <span class="keyword">while</span>(!q.empty()) q.pop(); <span class="comment">//由於 queue 沒有清空，因此寫個清空</span></span><br><span class="line">    q.push(Node(sx, sy, V[sx][sy], <span class="built_in">abs</span>(sx-TX)+<span class="built_in">abs</span>(sy-TY))); <span class="comment">//放入初始節點</span></span><br><span class="line"></span><br><span class="line">    Node u;</span><br><span class="line">    <span class="keyword">int</span> lr, rr, lc, rc;</span><br><span class="line">    <span class="comment">//lr = 左邊界 rr = 右邊界</span></span><br><span class="line">    <span class="comment">//lc = 上邊界 rc = 下邊界</span></span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123; <span class="comment">//如果節點還沒有被走訪完就繼續 dijkstra</span></span><br><span class="line">        u = q.top(); q.pop(); </span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(u.r - ex) &lt;= R[u.r][u.c] &amp;&amp; <span class="built_in">abs</span>(u.c - ey) &lt;= C[u.r][u.c])</span><br><span class="line">        <span class="comment">//當前節點已經可以碰到終點節點了，因此就輸出成本即可。</span></span><br><span class="line">            <span class="keyword">return</span> u.v;</span><br><span class="line"></span><br><span class="line">        lr = max(<span class="number">1</span>, u.r-R[u.r][u.c]); rr = min(n, u.r+R[u.r][u.c]);</span><br><span class="line">        lc = max(<span class="number">1</span>, u.c-C[u.r][u.c]); rc = min(m, u.c+C[u.r][u.c]);</span><br><span class="line">        <span class="comment">//確認當前節點可以到的最大範圍</span></span><br><span class="line">        bit.update(lr, lc, rr, rc, u.v, <span class="number">-1</span>); <span class="comment">//進行更新，將這些裡面的節點都標示為走訪過</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//如果無法抵達，那就輸出 -1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">int</span> r, c, n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; r &gt;&gt; c &gt;&gt; n)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=r; i++)&#123; <span class="comment">//輸入成本陣列</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=c ;j++)</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; V[i][j] ; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=r; i++)&#123; <span class="comment">//輸入最大 Row陣列</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=c ;j++)</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; R[i][j] ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=r; i++)&#123; <span class="comment">//輸入最大 Column 陣列</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=c ;j++)</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; C[i][j] ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) <span class="comment">//紀錄所有的目的地</span></span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; P[i][<span class="number">0</span>] &gt;&gt; P[i][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++)&#123; </span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; findPath(r, c, P[i<span class="number">-1</span>][<span class="number">0</span>], P[i<span class="number">-1</span>][<span class="number">1</span>], P[i][<span class="number">0</span>], P[i][<span class="number">1</span>]) ;</span><br><span class="line">            <span class="keyword">if</span>(i==n<span class="number">-1</span>) <span class="comment">//嚴格比對，因此這樣寫</span></span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="思考流程"><a href="#思考流程" class="headerlink" title="思考流程"></a>思考流程</h2><p>透過紙筆與黑板而思考而成的片段，放在網路上供我紀念XD</p>
<blockquote>
<p><img src="https://i.imgur.com/SW9JQzx.jpg" alt=""></p>
</blockquote>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>A*搜尋</tag>
        <tag>2D Fenwick Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces 1474C - Array Destruction (設計解題、數學推理)</title>
    <url>/2021/01/28/Codeforces/Codeforces%201474C/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>有一個陣列，裡面只有正整數，要進行以下操作：</p>
<ul>
<li>一開始先選出某一數字為 \(x\)</li>
<li>移除陣列中的兩個元素，定義 \(a,b\)，移除時必須符合此公式 \(a+b=x\)</li>
<li>之後必須將 \(max(a,b) = x \)，讓 a or b 中的最大值成為 x</li>
</ul>
<p>如果可以透過規則讓陣列元素全部被清空就輸出 “Yes”，否則就輸出 “NO”</p>
<p>舉例： \(a = [3,5,1,2] \)，那清空的操作如下</p>
<ul>
<li>\(x=6=5+1\)</li>
<li>\(x=5=2+3\)</li>
</ul>
<p><a href="https://codeforces.com/contest/1474/problem/C" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li>對於數字的邏輯推理</li>
<li>快速找出題目的重點與其作答方向</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>好題，這種給你一種遊戲方式來讓你去解出來的，我稱之為「設計解題」，這種題目由於沒辦法先前準備，因此很吃反應能力跟思考速度，一個不小心可能就亂掉了QQ。</p>
<h3 id="QUESTION-A-如果找出-x-？"><a href="#QUESTION-A-如果找出-x-？" class="headerlink" title="QUESTION A: 如果找出 \(x\)？"></a>QUESTION A: 如果找出 \(x\)？</h3><p>首先，\(x\) 值一定要是比陣列中所有元素更大，且要讓陣列元素中的某兩個值相加 \(a,b\)。<br>再來，\(x\) 值會變成\(a,b\)中取最大的值做為下一次的 \(x\)。</p>
<p>因此我們可以知道，<strong>\(x\) 一定會遞減</strong>。</p>
<h3 id="QUESTION-B-那-x-值一開始會是多少呢？有辦法推出來嘛？"><a href="#QUESTION-B-那-x-值一開始會是多少呢？有辦法推出來嘛？" class="headerlink" title="QUESTION B: 那 \(x\) 值一開始會是多少呢？有辦法推出來嘛？"></a>QUESTION B: 那 \(x\) 值一開始會是多少呢？有辦法推出來嘛？</h3><p>沒有辦法。<br>因為我們不確定哪兩個元素為 \(x\) 之後，就可以讓後面不斷運行的操作都可以成立，每次都可以順利讓 \(a+b=x\)。</p>
<p>因此，在這種情況下只剩下暴力嘗試去找出其一開始的 \(x\) 值，讓元素中最大的數字去加上元素中其中另一元素當作 x，不斷反覆去嘗試配對，直到可以將所有數字用完就是正解。</p>
<p>至於為甚麼是先讓元素中最大的數字去配陣列中其他元素？<br>我們可以舉個例子：   \(a = [3,5,1,2] \)</p>
<ul>
<li>一開始我們使用 \(a+b=x\) 等同於 \(3+1=4\)，這樣就<strong>不是</strong>讓元素中最大的數字去配陣列中其他元素</li>
<li>再來我們必須使用 3 來讓成為下次的 \(x\)，此時我們可以發現 5 這個元素再也沒有辦法被移除，因為 x 已經小於 5 了，因此這種配對方式一定會失敗。</li>
<li>這點我們有在 QUESTION A 討論過，這裡透過舉例讓讀者更加清晰。</li>
</ul>
<h2 id="參考來源"><a href="#參考來源" class="headerlink" title="參考來源"></a>參考來源</h2><p><a href="https://codeforces.com/blog/entry/86933" target="_blank" rel="noopener">Codeforces Round #696 Editorial</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>原本我在寫這題時一直卡關，想不出來怎麼解…，數字推理與反應速度慢的不可思議啊QQQQ，之後透過不斷的寫演算法題目來讓我的思考能力變快、更迅速，一定可以幫忙到生活上的所有事物，可能我會不清楚在哪裡用到，但現在的我認為這一定是會讓自己變更聰明的學習！</p>
<p>雖然學的過程中真的蠻痛苦的…，希望我可以多努力加油。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1000020</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> t, n, x, num[MAXN], a[MAXN];  </span><br><span class="line"><span class="comment">// a 為題目給的元素陣列 </span></span><br><span class="line"><span class="comment">//num 為那個數字有幾個，舉例： num[2]=1 a陣列中有 2 這個數值並且有一個</span></span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt; record; <span class="comment">//紀錄要輸出的 pair</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    sort(a,a+<span class="number">2</span>*n); <span class="comment">//先進行排序，方便找出陣列中最大的數值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>*n<span class="number">-1</span>; i++)&#123; <span class="comment">//陣列中最大的數值與某一數值合併</span></span><br><span class="line">        record.clear(); <span class="comment">//清空紀錄</span></span><br><span class="line">        <span class="built_in">memset</span>(num, <span class="number">0</span>, <span class="keyword">sizeof</span>(num)); <span class="comment">//先將 num 清空</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">2</span>*n<span class="number">-1</span>; j++) <span class="comment">//讓 num 的資料與 a 同步</span></span><br><span class="line">            num[a[j]]++;</span><br><span class="line">        x = a[i] + a[<span class="number">2</span>*n<span class="number">-1</span>]; <span class="comment">//最一開始的 x</span></span><br><span class="line">        <span class="comment">//cout &lt;&lt; "x is " &lt;&lt; x &lt;&lt; '\n';</span></span><br><span class="line">        <span class="keyword">int</span> cnt = n; <span class="comment">//需要組成幾個 pair，如果都可以成功組出表示沒問題</span></span><br><span class="line">        <span class="keyword">while</span>(cnt)&#123; <span class="comment">//這裡的判斷是剩下幾個 pair</span></span><br><span class="line">            <span class="keyword">int</span> pos = <span class="number">2</span>*n<span class="number">-1</span>; <span class="comment">//從最大開始找， 2*n-1 為初始陣列中最長的位置</span></span><br><span class="line">            <span class="keyword">while</span>(pos &gt; <span class="number">0</span> &amp;&amp; num[a[pos]] == <span class="number">0</span>) </span><br><span class="line">            <span class="comment">//從後面開始算，如果後面那些值被用過就往前算，用來找出當前最大的 x</span></span><br><span class="line">                pos--;</span><br><span class="line">            num[a[pos]]--; num[x-a[pos]]--; <span class="comment">//更新 num 值狀態，那兩個值透過規則被提出</span></span><br><span class="line">            <span class="comment">//x=a+b，當 a,x 值固定 則 b(x-a[pos]) 值一定是固定</span></span><br><span class="line">            <span class="comment">// 注意，這裡的 a 不是陣列 a，是我們定義的數值 a</span></span><br><span class="line">            <span class="keyword">if</span>(num[a[pos]] &lt; <span class="number">0</span> || num[x-a[pos]] &lt; <span class="number">0</span>) </span><br><span class="line">            <span class="comment">//如果 num 值裡面是 -1 就表示陣列中沒有這個數字，不能拿來當成一個 pair</span></span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">//再換新組合</span></span><br><span class="line">            record.push_back(&#123;a[pos], x-a[pos]&#125;); </span><br><span class="line">            <span class="comment">//記錄這個 pair，因為通過上面的 if 表示通過考驗</span></span><br><span class="line">            <span class="comment">//cout &lt;&lt; a[pos] &lt;&lt; ' ' &lt;&lt; x-a[pos] &lt;&lt; '\n';</span></span><br><span class="line">            x = max(a[pos], x-a[pos]); <span class="comment">//選擇下一個 x</span></span><br><span class="line">            cnt--; <span class="comment">//還需要的 pair 數量 -1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt == <span class="number">0</span> )&#123; <span class="comment">//等於 0 表示，已經可以完全匹配到了</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"YES\n"</span>;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; record[<span class="number">0</span>].first + record[<span class="number">0</span>].second &lt;&lt; <span class="string">'\n'</span>; </span><br><span class="line">            <span class="comment">//題目要求輸出最一開始的 x</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> it: record) <span class="comment">//輸出所有配對</span></span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; it.first &lt;&lt; <span class="string">' '</span> &lt;&lt; it.second &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">//由於配對成功，所以 return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"NO\n"</span>; <span class="comment">//配對失敗</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>*n; i++) <span class="comment">//輸入資料</span></span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>設計解題</tag>
        <tag>程式解題</tag>
        <tag>Codeforces</tag>
        <tag>數學推理</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces 1474D - Array Destruction (設計解題、數學推理)</title>
    <url>/2021/01/31/Codeforces/Codeforces%201474D/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>有一個遊戲規則，遊戲規則如下：<br>有 x 堆的石頭，每堆石頭都可以跟鄰近的石頭進行移除，移除方式為雙方各移除 y 顆石頭，移除數量必須小於石頭數量，最終要求為要讓所有堆的石頭全部數量歸零。</p>
<p>特殊規則：可以有一次將兩堆石頭進行交換。</p>
<p><a href="https://codeforces.com/contest/1474/problem/D" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li>對於數字的邏輯推理</li>
<li>快速找出題目的重點與其作答方向</li>
</ul>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>我們可以先根據題目找出一些邏輯觀念：</p>
<ul>
<li>定義石頭堆為 \(a_i\)</li>
<li>沒有移動石頭堆的情況下<ul>
<li>如果 \( a_1 &gt; a_2 \)，那麼 \(a_1 \) 這堆石頭永遠不會歸零，因此就永遠無法完成題目的 “Yes”</li>
<li>即使 \( a_1 &gt; a_2 \)，那也要移除到最後一堆石頭時剛好全部移除完畢，因此需要開一個陣列紀錄 \(a_{i-1} - a_{i-2} \) 的剩下數量，再跟我們的 \(a_i\) 進行移除比較；這裡我們透過一個陣列來維護他，陣列就稱為 <code>pre</code>。</li>
<li>因此可以得出一個規則， 石頭堆中的每一個 \(pre[i-1] &lt; pre[i] \)，否則無法完成題目的 “Yes”，定義為<strong>向後消除規則</strong>；因為此規則紀錄的陣列就與前綴和近乎相同，只有在前綴和為 -1 時，後面全部都設為 -1，表示無法被成功移除，只要到最後一堆石頭完成時前綴和為 0 就會是 “Yes”</li>
<li>可以再延伸出一個規則，題目沒有說移除的方向，因此可以從左邊移除也可以從右邊移除石頭</li>
<li>即使 \( a_1 &lt; a_2 \)，那也要移除到最後一堆石頭時剛好全部移除完畢，因此需要開一個陣列紀錄 \(a_{i+1} - a_{i+2} \) 的剩下數量，再跟我們的 \(a_i\) 進行移除比較；這裡我們透過一個陣列來維護他，陣列就稱為 <code>suf</code>。</li>
<li>因此可以得出一個規則， 石頭堆中的每一個 \(suf[i] &gt; suf[i+1] \)，否則無法完成題目的 “Yes”，定義為<strong>向前消除規則</strong>，陣列就稱為 <code>suf</code>；因為此規則紀錄的陣列就與後綴和近乎相同，只有在後綴和為 -1 時，前面全部都設為 -1，表示無法被成功移除，只要到第一堆石頭完成時後綴和為 0 就會是 “Yes”</li>
<li><strong>向後消除規則</strong>或<strong>向前消除規則</strong>滿足其中一個條件即可，</li>
</ul>
</li>
<li>有交換石頭堆的情況下<ul>
<li>由於可以進行交換石頭，因此前面兩個規則就不適用，但可以透過他們擴展出一套新的規則，如果只是將某兩堆的石頭進行交換，可以發現一定會影響到 \(pre[i]\) and \(suf[i+1]\)</li>
<li>再來我們可以發現在一個可以被全解的石頭堆測試範例中可以發現 \(pre[i] = suf[i+1]\)，那是因為<strong>移除</strong>本身沒有方向性，因此如果以 i 為分水嶺，i 前面的都用<strong>向後消除規則</strong>，i 後面的都用<strong>向前消除規則</strong>，會發現則最後一個移除無論是向後消除規則或向前消除規則都是相同的。</li>
<li>因此 \(pre[i] = suf[i+1]\) 表示這裡是最後一次的移除，並且可以完全移除成功，如果不等於就表示把這裡當作最後一次的移除時，並沒有辦法完全移除成功。</li>
<li>根據上面的規則，因為只有 \(pre[i]\) and \(suf[i+1]\) 會被更動到，因此我們先假設讓 \(a[i] \) 與 \(a[i+1]\) 交換，算出交換後的 \(pre[i]\) and \(suf[i+1]\)，再判斷他們是否相等即可。</li>
<li>只要 \(pre[i-1]\) 為 -1 表示已經打破了<strong>向後消除規則</strong>，在 \(a_i\) 前面就已經有石頭堆不可以被消除 or \(suf[i+2]\) 為 -1 表示已經打破了<strong>向前消除規則</strong> 在 \(a_i\) 後面就已經有石頭堆不可以被消除；因此 \(pre[i] = -1\) or \(suf[i+1] = -1 \) 就表示在這邊交換也沒辦法完成題目規定的 “Yes”。</li>
</ul>
</li>
</ul>
<h2 id="參考來源"><a href="#參考來源" class="headerlink" title="參考來源"></a>參考來源</h2><p><a href="https://codeforces.com/blog/entry/86933" target="_blank" rel="noopener">Codeforces Round #696 Editorial - IgorI’s blog</a><br><a href="https://tomjobs.blog.csdn.net/article/details/112889868?utm_medium=distribute.pc_relevant.none-task-blog-OPENSEARCH-2.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-OPENSEARCH-2.control" target="_blank" rel="noopener">Codeforces-1474 D. Cleaning（前缀和） - tomjobs  </a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>這題好難QQQ，我花了將近 3 天的時間才能理解懂，很懊惱自己的腦袋為甚麼不夠聰明沒辦法把這些思緒都想懂阿，希望我每周這樣不斷地對自己進行訓練能夠讓自己在生活日常中不斷地運用到，讓我在寫程式的過程中不斷地運用到，那我就沒有白費我現在每天這麼努力的練習自己的腦袋了。</p>
<p>希望自己未來的腦袋能變好，這種設計解題都能夠順利解開</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 200020</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f * 10 <span class="comment">//為解說中說明的 -1</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> t, n, num[MAXN];</span><br><span class="line"><span class="keyword">int</span> pre[MAXN], suf[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span></span>&#123; <span class="comment">//判斷是否可以解出</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(suf[i+<span class="number">1</span>] == pre[i]) <span class="comment">//表示不須交換就可以消除，把這裡的 i 讓他做後一次消除可以輸出 yes</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">//成功輸出 yes</span></span><br><span class="line">        <span class="keyword">int</span> x = num[i+<span class="number">1</span>] - pre[i<span class="number">-1</span>], y = num[i] - suf[i+<span class="number">2</span>] ; </span><br><span class="line">        <span class="comment">// x = pre[i] y = suf[i+1]，讓 x,y 視為交換後的調整</span></span><br><span class="line">        <span class="keyword">if</span>(x &gt;= <span class="number">0</span> &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; x == y) </span><br><span class="line">        <span class="comment">// x,y 都要大於 0，表示假設這裡進行最後一次移除，可以嘗試判斷能否全部移除成功</span></span><br><span class="line">        <span class="comment">//如果 x,y 其中一個為負數表示被 INF 減去，</span></span><br><span class="line">        <span class="comment">//也表示這裡就算進行最後一次移除也沒辦法全部移除成功，</span></span><br><span class="line">        <span class="comment">//如果 pre 或 suf 為 INF 表示前面或後面已經有石頭沒辦法被消除，分析有對此進行詳細說明</span></span><br><span class="line">        <span class="comment">// x==y 表示答案相同，代表這裡為最後一次移除可以完全移除成功，因此可以輸出 "YES"</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//表示沒有辦法被完全移除成功，符合題目要求，因此輸出 "NO"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; num[i];</span><br><span class="line">        suf[n+<span class="number">1</span>] = <span class="number">0</span>; <span class="comment">//先將 suf[n+1] 為 0，才可以讓找後綴和不會抓到前筆資料</span></span><br><span class="line">        pre[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">//pre[0] 為 0，才不會讓前綴和抓到前筆資料</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123; <span class="comment">//向前消除規則</span></span><br><span class="line">            <span class="keyword">if</span>(num[i] - pre[i<span class="number">-1</span>] &lt; <span class="number">0</span>) </span><br><span class="line">            <span class="comment">//為了防止 pre[i-1] = -1 時，num[i] - (-1) 會等於正數時的冏境，因此將 pre[i] 設為 INF</span></span><br><span class="line">                pre[i] = INF; <span class="comment">//為分析中所說的 -1，由於在等等程式撰寫方便，因此使用 INT</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                pre[i] = num[i] - pre[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &gt; <span class="number">0</span>; i--)&#123; <span class="comment">//向後消除規則</span></span><br><span class="line">            <span class="keyword">if</span>(num[i] - suf[i+<span class="number">1</span>] &lt; <span class="number">0</span>)</span><br><span class="line">                suf[i] = INF + MAXN; <span class="comment">//為分析中所說的 -1，由於在等等程式撰寫方便，因此使用 INT + MAXN</span></span><br><span class="line">                <span class="comment">//為了要讓 suf[i+1] == pre[i] 成立，且不讓 suf[i+1] == pre[i] == INF 時也成立，</span></span><br><span class="line">                <span class="comment">//因此讓 suf 在 INF 的時候再加 MAXN 來使在 INF 時 suf[i+1] != pre[i] </span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                suf[i] = num[i] - suf[i+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(solve())</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"YES\n"</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"NO\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="思考流程"><a href="#思考流程" class="headerlink" title="思考流程"></a>思考流程</h2><p>透過紙筆與黑板而思考而成的片段，放在網路上供我紀念XD</p>
<p>錯誤的程式碼就不放上來讓大家見笑了QQQQ。</p>
<blockquote>
<p><img src="https://i.imgur.com/eUgR0A4.jpg" alt=""><br><img src="https://i.imgur.com/IGVGdSI.jpg" alt=""><br><img src="https://i.imgur.com/lKYs80H.jpg" alt=""><br><img src="https://i.imgur.com/WVQw5IJ.jpg" alt=""></p>
</blockquote>
]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>設計解題</tag>
        <tag>程式解題</tag>
        <tag>Codeforces</tag>
        <tag>數學推理</tag>
      </tags>
  </entry>
  <entry>
    <title>演算法知識 - Disjoint Set 並查集</title>
    <url>/2021/02/02/Explain_Algorithm/disjoint-set/</url>
    <content><![CDATA[<h2 id="Disjoint-Set-介紹與應用"><a href="#Disjoint-Set-介紹與應用" class="headerlink" title="Disjoint Set 介紹與應用"></a>Disjoint Set 介紹與應用</h2><blockquote>
<p>Disjoint Set 並查集是資料結構的其中一種，主要用來處理元素間的合併與查詢，並查集有 2 種操作</p>
<ul>
<li>查詢 查詢某個元素是在哪個集合中，通常是返回集合內的<strong>代表元素</strong>，也就是在查詢此集合中的任一元素時，都會傳回此元素</li>
<li>合併 將兩個集合合併成一個</li>
</ul>
<p>由於此兩操作時間複雜度都是 \(O(\log_n\)，且編寫容易，因此受到大量地使用，是個很棒的資料結構</p>
</blockquote>
<a id="more"></a>

<h2 id="Disjoint-Set-原理"><a href="#Disjoint-Set-原理" class="headerlink" title="Disjoint Set 原理"></a>Disjoint Set 原理</h2><h3 id="建立初始-Disjoint-Set"><a href="#建立初始-Disjoint-Set" class="headerlink" title="建立初始 Disjoint Set"></a>建立初始 Disjoint Set</h3><p>由於一開始每個元素都是獨立的集合且也是自己集合中的<strong>代表元素</strong>，因此先寫一個迴圈讓每個元素都是集合中的<strong>代表元素</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 2000</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXN; i++)&#123;</span><br><span class="line">        tree[i] = i;</span><br><span class="line">        cnt[i] = <span class="number">1</span>; <span class="comment">//cnt 為數量，也就是每一個集合的數量，一開始都是 1，因為只有自己。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="查詢"><a href="#查詢" class="headerlink" title="查詢"></a>查詢</h3><p>查詢是要查詢某個元素是在哪個集合中，因此我們只需要寫這樣即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_root</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[i] != i) <span class="comment">//如果 tree[i] 本身並不是集合中的代表元素，</span></span><br><span class="line">    <span class="comment">//表示這個集合中有其他元素，並且其他元素才是代表元素</span></span><br><span class="line">        <span class="keyword">return</span> tree[i] = find_root(tree[i]); <span class="comment">//遞迴，將 tree[i] 的元素在進行查詢，</span></span><br><span class="line">        <span class="comment">//並將代表元素設為現在的 tree[i]</span></span><br><span class="line">    <span class="keyword">return</span> tree[i]; <span class="comment">//回傳代表元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="合併"><a href="#合併" class="headerlink" title="合併"></a>合併</h3><p>合併較為簡單，只需要先<strong>查詢</strong> <code>tree[a],tree[b]</code> 這兩個的代表元素是否為一樣，如果不一樣就表示兩個為不同集合，讓 <code>tree[b]</code>代表元素與<code>tree[a]</code>相同即可，這樣之後在查詢中代表元素就會相同。</p>
<p>計算數量的陣列也要進行改變，因為這兩個集合被合併了，因此數量要進行更新，讓 <code>cnt[b]</code> 的值加給 <code>cnt[a]</code>， <code>cnt[b]</code> 之後再將他歸 0。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    rx = find_root(tree[a]); <span class="comment">//找出 find_root(tree[a]) 的代表元素</span></span><br><span class="line">    ry = find_root(tree[b]); <span class="comment">//找出 find_root(tree[b]) 的代表元素</span></span><br><span class="line">    <span class="keyword">if</span>(rx != ry) <span class="comment">//如果不一樣就合併</span></span><br><span class="line">        tree[ry] = rx; <span class="comment">//要合併的是代表元素，不是 tree[b]</span></span><br><span class="line">        cnt[rx] += cnt[ry]; <span class="comment">//將原本另一集合的數量加到這集合，因為他們合併了</span></span><br><span class="line">        cnt[ry] = <span class="number">0</span>;  <span class="comment">//由於合併，因此將原本獨立的集合數量歸 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="QUESTION-可能有些人會想問這樣真的就可以合併成功嗎？"><a href="#QUESTION-可能有些人會想問這樣真的就可以合併成功嗎？" class="headerlink" title="QUESTION: 可能有些人會想問這樣真的就可以合併成功嗎？"></a>QUESTION: 可能有些人會想問這樣真的就可以合併成功嗎？</h4><p>我知道大家好奇的原因，因為我也好奇過XD。</p>
<p>可是我們稍微思考一下，由於我們是將 <code>tree[ry]</code> 的代表元素更換為 <code>tree[rx]</code> 的代表元素，因此在<strong>查詢到</strong> <code>tree[ry]</code>，就會發現 <code>tree[ry]</code>已經不是代表元素了，因此會再進行一次遞迴，就會查詢到 <code>tree[rx]</code>，發現他是代表元素，就開始不斷的進行 return。</p>
<h4 id="QUESTION-可能還會有些人好奇那原本-tree-ry-的集合中其他元素不還是指向-tree-ry-嗎-沒關係嗎"><a href="#QUESTION-可能還會有些人好奇那原本-tree-ry-的集合中其他元素不還是指向-tree-ry-嗎-沒關係嗎" class="headerlink" title="QUESTION: 可能還會有些人好奇那原本 tree[ry] 的集合中其他元素不還是指向 tree[ry] 嗎?沒關係嗎?"></a>QUESTION: 可能還會有些人好奇那原本 <code>tree[ry]</code> 的集合中其他元素不還是指向 <code>tree[ry]</code> 嗎?沒關係嗎?</h4><p>沒關係的，在查詢中一樣會先查詢到 <code>tree[ry]</code> 但它並不是代表元素，因此會在遞迴查詢，就會查到 <code>tree[rx]</code>，之後再遞迴回傳時在讓當前的 <code>tree[i]</code>直接指向代表元素即可，加快效率。</p>
<h3 id="count-計算數量"><a href="#count-計算數量" class="headerlink" title="count 計算數量"></a>count 計算數量</h3><p>disjoint set 常常會需要計算數量，這時我們前面使用的 cnt 陣列就派上用場了，用法很簡單，因為前面在合併的過程中都幫助我們處理好了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; cnt[find_root(x)] ; <span class="comment">// x 為要查詢的集合</span></span><br></pre></td></tr></table></figure>

<h4 id="QUESTION-這樣真的就會計算數量成功嗎-我們只有將兩個集合加入，但還會有點沒有被算到吧？"><a href="#QUESTION-這樣真的就會計算數量成功嗎-我們只有將兩個集合加入，但還會有點沒有被算到吧？" class="headerlink" title="QUESTION: 這樣真的就會計算數量成功嗎? 我們只有將兩個集合加入，但還會有點沒有被算到吧？"></a>QUESTION: 這樣真的就會計算數量成功嗎? 我們只有將兩個集合加入，但還會有點沒有被算到吧？</h4><p>會的，因為每一次的合併都會將別人的元素加入，最一開始的合併一定是 1+1，也就是兩個點的合併，只要一開始是正確的，後面就都會正確。</p>
<p>不然就不叫程式了XD。</p>
<h2 id="Disjoint-Set-應用"><a href="#Disjoint-Set-應用" class="headerlink" title="Disjoint Set 應用"></a>Disjoint Set 應用</h2><ul>
<li><a href="https://theriseofdavid.github.io/2020/03/23/UVa/Uva11987/" target="_blank" rel="noopener">Uva11987 - Almost Union-Find (Disjoint Set)</a></li>
<li><a href="https://theriseofdavid.github.io/2021/02/02/UVa/UVa599/" target="_blank" rel="noopener">UVa599 - The Forrest for the Trees(Disjoint Set)</a></li>
<li><a href="https://theriseofdavid.github.io/2021/02/06/UVa/UVa11503/" target="_blank" rel="noopener">UVa11503 - Virtual Friends(Disjoint Set)</a></li>
</ul>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://zh.wikipedia.org/wiki/%E5%B9%B6%E6%9F%A5%E9%9B%86" target="_blank" rel="noopener">併查集</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>這是我在高中時期就學會的演算法之一，在高職的時候我是自己學的，在新北市政府的幫助之下讓我去版中上課，接觸到了許多優秀的人才以及優秀的老師(蝸牛老師)，老師在教演算法這塊特別優秀，教導的十分好懂，是我的演算法啟蒙老師之一，很謝謝老師的講解！讓我在快要忘記之餘強制複習，才讓他完全記錄在我的腦海之中。</p>
]]></content>
      <categories>
        <category>演算法知識</category>
      </categories>
      <tags>
        <tag>Disjoint Set 並查集</tag>
        <tag>程式解題</tag>
        <tag>演算法知識</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa599 - The Forrest for the Trees(Disjoint Set)</title>
    <url>/2021/02/02/UVa/UVa599/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>給你很多個邊，這些邊透過節點的連接組成，接下來給你一些節點，要詢問這些節點有哪些節點有跟其他的節點做連結，哪些沒有。</p>
<p>有跟其他點做連結的點稱之為 tree，沒有的稱之為 acorns，請輸出他們的數量。</p>
<p><a href="https://onlinejudge.org/external/5/599.pdf" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="觀念重點"><a href="#觀念重點" class="headerlink" title="觀念重點"></a>觀念重點</h2><ul>
<li>並查集的應用</li>
<li>計算數量 acrons 與 tree 時的程式編寫</li>
<li>輸入的格式判斷</li>
</ul>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>明顯可以看得出來這是一個 disjoint set 題目，哪裡可以看的出來呢？</p>
<p>在他說輸出 tree 與 acorns 時，不難發現 tree 就是有跟其他節點連結過的集合，acorns 就是沒有跟其他節點連結過的集合，透過 disjoint set 可以很快完美解決此問題。</p>
<p>如果還不懂 disjoint set 的可以看<a href="https://theriseofdavid.github.io/\2021/02/02/Explain_Algorithm/disjoint-set/" target="_blank" rel="noopener">演算法知識 - Disjoint Set 並查集</a>或<a href="https://www.youtube.com/watch?v=wU6udHRIkcc" target="_blank" rel="noopener">Abdul Bari</a></p>
<h3 id="tree-and-acrons-的程式碼編寫"><a href="#tree-and-acrons-的程式碼編寫" class="headerlink" title="tree and acrons 的程式碼編寫"></a>tree and acrons 的程式碼編寫</h3><p>一開始先開兩個陣列 cT and cA，cT 用來數 tree 的數量，cA 用來數 acorns。<br>並且在 disjoint set 建立時，先讓每個 <code>cA[i]</code>都設為 1，表示當前每個都是 acorns。</p>
<p>我們可以在每次的合併查詢中多寫一句話</p>
<ul>
<li>如果代表元素不等於自己，那就讓 <code>cA[i]</code> 等於 0 且 <code>cT[i]</code> 為 1</li>
</ul>
<p>接下來在到測資結束前，對題目想查詢的節點進行計數，如果 <code>cA[i] = 1</code>，等等輸出的 acorns 就加一，如果 <code>cT[i] = 1</code>，等等輸出的 tree 就加一</p>
<p>這樣可以方便又快速的解決此問題，這是我個人想到的，並不一定要用此方式解。</p>
<h3 id="由於他詢問的節點不一定按照字母順序，記得要先用-vector-存起來。"><a href="#由於他詢問的節點不一定按照字母順序，記得要先用-vector-存起來。" class="headerlink" title="由於他詢問的節點不一定按照字母順序，記得要先用 vector 存起來。"></a>由於他詢問的節點不一定按照字母順序，記得要先用 vector 存起來。</h3><p>記得對每一個要查詢的值進行判斷是 acorn or tree，再用 vector 紀錄，等等再進行計數。</p>
<p>我知道可能沒有寫得很乾淨，可以改進XD。</p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>這題讓我複習了很多 disjoint set，把我的小腦袋給弄醒了一些呀，好希望自己可以在學習的過程中更優秀、更努力，就可以讓自己變得更強，也透過寫演算法來增加我的思維。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 30 <span class="comment">//題目最大數量</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> tree[MAXN], cT[MAXN], cA[MAXN]; <span class="comment">//cntTree cntAcorn 判斷 i 是 tree or acorn</span></span><br><span class="line"><span class="comment">//tree 為 disjoint set </span></span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"><span class="built_in">string</span> temp;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; record; <span class="comment">//紀錄查詢的字元</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123; <span class="comment">//初始</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXN; i++)&#123; </span><br><span class="line">        tree[i] = i; <span class="comment">//重設 disjoint set</span></span><br><span class="line">        cA[i] = <span class="number">1</span>; <span class="comment">//一開始每個節點都是 acorns</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(cT, <span class="number">0</span>, <span class="keyword">sizeof</span>(cT)); <span class="comment">//一開始沒有節點是 tree</span></span><br><span class="line">    record.clear(); <span class="comment">//查詢字元紀錄刪除</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_root</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123; <span class="comment">//disjoint set 查詢</span></span><br><span class="line">    <span class="keyword">if</span>(tree[i] != i)</span><br><span class="line">        <span class="keyword">return</span> tree[i] = find_root(tree[i]);</span><br><span class="line">    <span class="keyword">return</span> tree[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">()</span></span>&#123; <span class="comment">//debug 用，無意義</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; MAXN; i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; MAXN; i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; tree[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; MAXN; i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; cA[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"out.txt"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; temp)&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp[<span class="number">0</span>] == <span class="string">'('</span>)&#123; <span class="comment">//合併節點</span></span><br><span class="line">                <span class="keyword">int</span> x, y, rx, ry; <span class="comment">//rootx rooty</span></span><br><span class="line">                x = temp[<span class="number">1</span>] - <span class="string">'A'</span> + <span class="number">1</span>; <span class="comment">//hash 用，透過 ascii</span></span><br><span class="line">                y = temp[<span class="number">3</span>] - <span class="string">'A'</span> + <span class="number">1</span>;</span><br><span class="line">                rx = find_root(tree[x]); <span class="comment">//找集合內代表元素</span></span><br><span class="line">                ry = find_root(tree[y]); <span class="comment">//找集合內代表元素</span></span><br><span class="line">                <span class="keyword">if</span>(rx != ry) <span class="comment">//兩個不再同集和內就合併</span></span><br><span class="line">                    tree[ry] = rx;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(temp[<span class="number">0</span>] == <span class="string">'*'</span>)&#123; <span class="comment">//查詢節點</span></span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; temp;</span><br><span class="line">                <span class="keyword">int</span> root, x;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; temp.length(); i+=<span class="number">2</span>)&#123;</span><br><span class="line">                    x = temp[i] - <span class="string">'A'</span> + <span class="number">1</span>; <span class="comment">//hash 用，透過 ascii</span></span><br><span class="line">                    record.push_back(x); <span class="comment">//紀錄查詢字元</span></span><br><span class="line">                    root = find_root(tree[x]); <span class="comment">//找集合內代表元素</span></span><br><span class="line">                    <span class="comment">//cout &lt;&lt; root &lt;&lt; ' ' &lt;&lt; x &lt;&lt; "\n";</span></span><br><span class="line">                    <span class="keyword">if</span>(root != x)&#123; <span class="comment">//如果集合內代表元素並不是 x 就表示他一定是 tree</span></span><br><span class="line">                        cA[x] = <span class="number">0</span>; <span class="comment">// 證明 x 不是 acorn</span></span><br><span class="line">                        cA[root] = <span class="number">0</span>; <span class="comment">//root 也不會是 acorn 因此設為 0</span></span><br><span class="line">                        cT[root] = <span class="number">1</span>; <span class="comment">//但 root 會 +1，因為有跟其他值連結</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//debug();</span></span><br><span class="line">        <span class="keyword">int</span> sum_cT = <span class="number">0</span>, sum_cA = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; record.size(); i++)&#123; <span class="comment">//計算 acorn and root 數量，透過記錄的查詢字元</span></span><br><span class="line">            <span class="keyword">if</span>(cT[record[i]]) sum_cT++; <span class="comment">//表示 i 是 tree</span></span><br><span class="line">            <span class="keyword">if</span>(cA[record[i]]) sum_cA++; <span class="comment">//表示 i 是 acorn</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"There are "</span> &lt;&lt; sum_cT &lt;&lt; <span class="string">" tree(s) and "</span> &lt;&lt; sum_cA &lt;&lt; <span class="string">" acorn(s).\n"</span>; <span class="comment">//輸出</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>Disjoint Set 並查集</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa10895 - Matrix Transpose(水題)</title>
    <url>/2021/02/02/UVa/UVa10895/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>給你一個矩陣，請你將原本的矩陣進行對調，原本是 \(num_ij\) 的值改放到 \(num_ji\)。</p>
<p>注意：題目的輸入輸出格式較為特別，需要注意</p>
<p><a href="https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1836" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="觀念重點"><a href="#觀念重點" class="headerlink" title="觀念重點"></a>觀念重點</h2><ul>
<li>對題目的格式清楚了解</li>
<li>英文閱讀</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>這題基本上沒有難度，直接讓陣列顛倒即可，怎麼顛倒呢？</p>
<p>題目對每一 row 都會給兩行，第一行的第一個數字是 row 中有幾個 index 要被輸入，這 row 中非 0 元素的 index，第二行則是這些非 0 元素 index 的數值，依此類推，注意，如果 row 沒有值要被輸入，那下一行則會空行。</p>
<p>這是題目的輸入說明，他的輸入格式翻譯成中文再經由我轉述，希望可以讓大家看懂，因為他的輸入於其他 uva 格式較為不同。</p>
<p>只需要將測資輸入到程式時是顛倒就可以了，記得是<strong>嚴格比對</strong>，然後 row 如果沒有非 0 元素，下行要是空行。</p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>除了練好我的英文能力以外，也要增加我對英文的自信心阿，加強英文閱讀速度，一定會讓我對未來更有力的。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 10020</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> num[MAXN][MAXN], row[MAXN]; </span><br><span class="line"><span class="comment">//num 題目中的 matrix, row 為非零元素的 index</span></span><br><span class="line"><span class="keyword">int</span> n, m, r;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">input_row</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123; <span class="comment">//對每一列的非零元素進行輸入</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; r; <span class="comment">//表示有 r 個非零元素</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= r; j++) <span class="comment">//輸入 index </span></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; row[j];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= r; j++) <span class="comment">//再將這些值直接進行轉換傳給 num</span></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; num[row[j]][i]; <span class="comment">//row[j] 要在前面，因為直接進行轉換</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; m &lt;&lt; <span class="string">' '</span> &lt;&lt; n &lt;&lt; <span class="string">'\n'</span>; <span class="comment">//顛倒輸出，因為矩陣轉換</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; record; <span class="comment">//紀錄這行的非零元素 index</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        record.clear(); <span class="comment">//換新行，清空</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num[i][j]) record.push_back(j); <span class="comment">//如果 num 數值不是 0，那 record 紀錄 index</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; record.size(); <span class="comment">//有多少非零元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it: record) <span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; it; <span class="comment">//輸出這些 index </span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(record.size() &gt; <span class="number">0</span>)&#123; <span class="comment">//如果有元素可以被輸出，才須要輸出數值</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; record.size()<span class="number">-1</span>; j++) <span class="built_in">cout</span> &lt;&lt; num[i][record[j]] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">            <span class="comment">//依序輸出每個非零元素，最後一個獨立輸出，因為她的後面不能加上空白</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; num[i][record[record.size()<span class="number">-1</span>]] ; <span class="comment">//獨立輸出</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>; <span class="comment">//換行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"out.txt"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(num, <span class="number">0</span>, <span class="keyword">sizeof</span>(num)); <span class="comment">//初始題目陣列</span></span><br><span class="line">        <span class="built_in">memset</span>(row, <span class="number">0</span>, <span class="keyword">sizeof</span>(row)); <span class="comment">//初始紀錄非零元素的 index 陣列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) input_row(i); <span class="comment">//對每 row 進行輸入值</span></span><br><span class="line">        output(); <span class="comment">//輸出轉換</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>水題</tag>
        <tag>UVa</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa10507 - Waking up brain(BFS)</title>
    <url>/2021/02/02/UVa/UVa10507/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>近代的研究指出如果要喚醒腦袋的區域時，必須要附近三塊的腦袋都是清醒的狀況才有辦法喚醒此區域，我們會給你已經清醒的區域，還有哪些區域是有連結的，想請問多久後才可以將腦袋中所有區域喚醒成功？</p>
<p>P.S. 喚醒需要一年的時間，請輸出多久可以喚醒，如果沒辦法喚醒輸出 “THIS BRAIN NEVER WAKES UP”，可以就輸出 “WAKE UP IN, n, YEARS”, where n is the number of the years all the brain has taken to wake up</p>
<p><a href="https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1448" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li>必須要看懂英文，這題對我來說英文有點難QQQ</li>
<li>觀察出此題類似於 BFS，但都只跑一層</li>
<li>哪些節點可以被喚醒再跑一次<strong>第二點</strong>。</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>這題與 BFS 比較不同的地方就是加入節點的要求是需要有鄰近 3 個區域被喚醒才可以被加入節點，為了要解決這個問題，我們開一個陣列叫做 area，每次讓喚醒的區域連結到還在睡著的區域，就讓被睡著的區域加一，如果加到 3 就加入節點，做下一次的 BFS。</p>
<h3 id="QUESTION-那要怎麼找出是需要幾年可以把全部區域喚醒呢"><a href="#QUESTION-那要怎麼找出是需要幾年可以把全部區域喚醒呢" class="headerlink" title="QUESTION: 那要怎麼找出是需要幾年可以把全部區域喚醒呢"></a>QUESTION: 那要怎麼找出是需要幾年可以把全部區域喚醒呢</h3><p>這時候就需要遞迴來幫助我們了，我們 BFS 的 vector (定義 vA)是當前有被喚醒的區域，裡面的節點都成功去 link 每個未喚醒的節點後就 pop，那如果有節點在此時被喚醒我們則把她加入到新的 vector 中(定義 vB)，當 vA 全部完成後，如果 vB 有節點我們就進行下一次的 BFS，使用遞迴則是可以方便知道我們總共喚醒幾次。</p>
<p>只需要將每一次的遞迴視為明年會被激活的區域即可。特別注意的是，一開始的區域不可以被 +1，因為那是已經醒來的區域，因此在進入遞迴時先將值設為 -1，這樣進入第一層遞迴時就會歸零。</p>
<h3 id="QUESTION-但上面那個問題沒有解決怎麼知道全部的區域都被喚醒呢？"><a href="#QUESTION-但上面那個問題沒有解決怎麼知道全部的區域都被喚醒呢？" class="headerlink" title="QUESTION: 但上面那個問題沒有解決怎麼知道全部的區域都被喚醒呢？"></a>QUESTION: 但上面那個問題沒有解決怎麼知道全部的區域都被喚醒呢？</h3><p>我們一開始不是有一個陣列(area) 可以知道此區域有幾個喚醒的區域連結嗎？我們只需要寫一個迴圈查詢所有的節點是不是都有 3 個或 3 個以上的區域連結就可以檢查了！</p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>這題其實不難，但蠻酷的，有一些很簡單的腦筋急轉彎需要去思考，遞迴裡面塞入一個 BFS，似乎有點類似於 IDDFS，但年代久遠我有點忘記了QQ，還需要在去複習一下，寫演算法很容易會忘記QQ，希望我的腦袋可以把這些思維都記錄下來並應用在生活上，這樣我就會是一個很不賴的人了！</p>
<p>希望自己的大腦要能夠一直都醒來拉，不醒來會對周遭的人很麻煩，會麻煩到他們的。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。</p>
<p>裡面為了讓程式碼更好寫，有做一些小手腳，在這邊會加上一些定義，供大家在閱讀時更好閱讀</p>
<ul>
<li><code>-INF</code> 已經有被掃描過的區域</li>
<li><code>flag</code> 判斷有多少節點是喚醒的</li>
<li><code>ca, cb</code> 輸入題目中的邊時要用到的字元</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 30</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f <span class="comment">//-INF 表示此節點已經被掃描過</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, cnt, flag;</span><br><span class="line"><span class="keyword">int</span> area[MAXN];</span><br><span class="line"><span class="built_in">string</span> temp;</span><br><span class="line"><span class="keyword">char</span> ca, cb;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; edge[MAXN]; <span class="comment">//每一個邊，第一個維度是分類為 edge[i] 可以連接到哪些邊</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123; <span class="comment">//將所有的陣列清空，不被上次的測資干擾</span></span><br><span class="line">    <span class="built_in">memset</span>(area,<span class="number">0</span>,<span class="keyword">sizeof</span>(area)); <span class="comment">//清空所有的 area</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXN; i++) edge[i].clear(); <span class="comment">//清空所有的邊</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wake</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; record)</span></span>&#123; <span class="comment">// BFS遞迴，查詢喚醒次數跟讓上次被喚醒的區域再跟其他區域連結 </span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp2; <span class="comment">//這次經過連結後會被喚醒的區域先暫存的 vector</span></span><br><span class="line">    cnt++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it: record)&#123; <span class="comment">//將上次被喚醒的區域去跟其他節點連結</span></span><br><span class="line">        <span class="comment">//cout &lt;&lt; (char)(it+'A') &lt;&lt; ' ';</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edge[it].size(); i++)&#123; <span class="comment">//每一個邊連結的其他邊</span></span><br><span class="line">            area[edge[it][i]]++; <span class="comment">//被連結的其他區域 +1，表示鄰近被喚醒的區域 +1</span></span><br><span class="line">            <span class="keyword">if</span>(area[edge[it][i]] &gt;= <span class="number">3</span>)&#123; <span class="comment">//如果大於 3，表示下次這個區域可以被喚醒</span></span><br><span class="line">                temp2.push_back(edge[it][i]); <span class="comment">//先放入暫存 vector</span></span><br><span class="line">                area[edge[it][i]] = -INF; <span class="comment">//此節點被放入 vector 了，因此設為 -INF</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; '\n';</span></span><br><span class="line">    <span class="keyword">if</span>(temp2.empty()) <span class="keyword">return</span> ; <span class="comment">//如果是空的就表示已經沒有區域被喚醒，沒辦法在跟其他區域連結</span></span><br><span class="line">    <span class="keyword">return</span> wake(temp2); <span class="comment">//還有區域被喚醒，因此進入下次的遞迴在跟其他區域連結</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"out.txt"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m)&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; record; <span class="comment">//紀錄有被喚醒的區域</span></span><br><span class="line">        init(); <span class="comment">//初始化，清空</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; temp; <span class="comment">//輸入字串，為一開始有被喚醒的區域</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; temp.length(); i++)&#123; </span><br><span class="line">            record.push_back(temp[i] - <span class="string">'A'</span>); <span class="comment">//將被喚醒的區域加入 vector，等等 BFS</span></span><br><span class="line">            area[temp[i] - <span class="string">'A'</span>] = -INF; <span class="comment">//點被加入 vector，因此值設為 -INF</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m ; i++)&#123; <span class="comment">//輸入連結的邊</span></span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; ca &gt;&gt; cb;</span><br><span class="line">            edge[ca - <span class="string">'A'</span>].push_back(cb - <span class="string">'A'</span>); <span class="comment">//hash 透過 ascii，A = 0, B = 1,...</span></span><br><span class="line">            edge[cb - <span class="string">'A'</span>].push_back(ca - <span class="string">'A'</span>); <span class="comment">//雙向連結，題目有說明是雙向邊</span></span><br><span class="line">        &#125;</span><br><span class="line">        cnt = <span class="number">-1</span>; flag = <span class="number">0</span>; <span class="comment">//cnt = -1，第一次的區域是已經醒來，所以不需要等待</span></span><br><span class="line">        <span class="comment">//flag 是要查詢哪些區域有被喚醒且已經被掃描過，如果有被喚醒就一定會被掃瞄，BFS 會做好這件事</span></span><br><span class="line">        wake(record);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXN; i++)&#123; <span class="comment">//查詢所有區域是否有被喚醒且已經被掃描過</span></span><br><span class="line">            <span class="keyword">if</span>(area[i] &lt; <span class="number">0</span>) flag++; <span class="comment">//有就 flag++</span></span><br><span class="line">            <span class="comment">//cout &lt;&lt; area[i] &lt;&lt; '\n';</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(flag == n) <span class="built_in">cout</span> &lt;&lt; <span class="string">"WAKE UP IN, "</span> &lt;&lt; cnt &lt;&lt; <span class="string">", YEARS\n"</span>;</span><br><span class="line">        <span class="comment">//表示有被喚醒且已經被掃描過區域等同題目給的所有區域也就是所有區域都被喚醒，因此可以輸出 cnt，代表只需要 cnt 年就可以將腦袋全部區域喚醒</span></span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"THIS BRAIN NEVER WAKES UP\n"</span>; </span><br><span class="line">        <span class="comment">//表示所有區域並沒有都被喚醒且已經被掃描過，有些區域沒有被喚醒，因此輸入永遠沒辦法讓大腦醒來 QQ。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>Disjoint Set 並查集</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa11503 - Virtual Friends(Disjoint Set)</title>
    <url>/2021/02/06/UVa/UVa11503/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>大家都喜歡線上交友，線上交友成為了一種大家的習慣或嗜好，我們每行會給你兩個名子，那兩個人是朋友關係，因為線上交友的關係，因此那兩人的朋友們也都會互相成為朋友。</p>
<p>每次新增朋友關係後，請試者輸出那群朋友的數量</p>
<p><a href="https://onlinejudge.org/index.php?option=onlinejudge&Itemid=8&page=show_problem&problem=2498" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li>了解 Disjoint Set</li>
<li><a href="https://theriseofdavid.github.io/2021/02/02/Explain_Algorithm/disjoint-set/" target="_blank" rel="noopener">演算法知識 - Disjoint Set 並查集</a></li>
</ul>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>很明顯的並查集，我們只需要寫好並查集的模板，接著將字串進行 hash，就可以得到答案。</p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>最近這幾天心情很煩燥，很多事情都安不下心，我還是一個小孩，還不願成長為一個大人，好多事情我都想逃避，但是世界不會讓我逃避、都市不會讓我逃避。</p>
<p>希望最近能讓我好點。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。</p>
<p>裡面為了讓程式碼更好寫，有做一些小手腳，在這邊會加上一些定義，供大家在閱讀時更好閱讀</p>
<ul>
<li><code>num</code> 為 disjoint set 判斷 <code>num[index]</code> 在哪個集合內</li>
<li><code>cnt</code> 為 disjoint set 判斷 <code>cnt[index]</code> 此代表元素的集合內有多少元素有多少元素</li>
<li><code>hs</code> 用來 hash 值，來讓字串進行加密壓縮</li>
<li><code>record</code> 字典，用來紀錄字串 hash 成 int 的值</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100020</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> t, f, hs;</span><br><span class="line"><span class="keyword">int</span> num[MAXN], cnt[MAXN]; </span><br><span class="line"><span class="built_in">string</span> n1, n2;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; record;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_root</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123; <span class="comment">//disjoint set 查詢</span></span><br><span class="line">    <span class="keyword">if</span>(num[i] != i) <span class="keyword">return</span> num[i] = find_root(num[i]);</span><br><span class="line">    <span class="keyword">return</span> num[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"out.txt"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXN; i++)&#123; <span class="comment">//最一開始先幫所有陣列初始化</span></span><br><span class="line">        num[i] = i; <span class="comment">//重設 disjoint set</span></span><br><span class="line">        cnt[i] = <span class="number">1</span>; <span class="comment">//重設 disjoint set</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; f;</span><br><span class="line">        hs = <span class="number">0</span>; record.clear();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; f; i++)&#123; <span class="comment">//讓上次測資不干擾這次測資</span></span><br><span class="line">            num[i] = i;  <span class="comment">//重設 disjoint set</span></span><br><span class="line">            cnt[i] = <span class="number">1</span>;  <span class="comment">//重設 disjoint set</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; f; i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; n1 &gt;&gt; n2;</span><br><span class="line">            <span class="comment">//壓縮字串為 int，如果字典沒有這個字串那就給他從未用過的 hash 值</span></span><br><span class="line">            <span class="keyword">if</span>(!record.count(n1)) record[n1] = hs++; </span><br><span class="line">            <span class="keyword">if</span>(!record.count(n2)) record[n2] = hs++;</span><br><span class="line">            <span class="keyword">int</span> rx, ry;</span><br><span class="line">            <span class="comment">//為 disjoint set 的合併，開始</span></span><br><span class="line">            rx = find_root(num[record[n1]]); </span><br><span class="line">            ry = find_root(num[record[n2]]); </span><br><span class="line">            <span class="keyword">if</span>(rx != ry)&#123; </span><br><span class="line">                num[ry] = num[rx];</span><br><span class="line">                cnt[rx] += cnt[ry];</span><br><span class="line">                cnt[ry] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//為 disjoint set 的合併，結束</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; cnt[rx] &lt;&lt; <span class="string">'\n'</span>; <span class="comment">//輸出集合內的元素數量</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>Disjoint Set 並查集</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa11991 - Easy Problem from Rujia Liu?(水題)</title>
    <url>/2021/02/02/UVa/UVa11991/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>Rujia Liu(華人大神出了許多演算法競賽的書，被稱之為聖經) 出了一份題目希望讓大家可以一起來為了演算法競賽而努力，題目內容如下：</p>
<p>給你一組陣列，進行查詢，查詢的模式是在 v 此數字出現第 k 次的位置是在陣列中的哪個 index</p>
<p><a href="https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=3142" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="觀念重點"><a href="#觀念重點" class="headerlink" title="觀念重點"></a>觀念重點</h2><ul>
<li>能夠快速把此題寫完</li>
<li>清空陣列，讓每筆測資不受干擾</li>
</ul>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>明顯可以看出此題是水體，鼓勵各位新手來進入這個演算法競賽中(<del>地獄</del>)www，這題主要可以用 vector 去解，可以將 vector 開到題目測試資料極限最大值，再將每個數字的 index 不斷存入屬於那個數字的 vector，如果要查詢的 size 比當前的 vector size 大就表示一定沒辦法查詢，輸出 “0”，不然就輸出 <code>num[v][k-1]</code>，vector 的 index 是從 0 開始。</p>
<p>上面講的是基本作法，但有一個地方需要注意</p>
<p>需要特別注意的是我們的數字最大可以來到 \(10^9\)，因此不可以直接用 <code>vector[(10^9)]</code>，如果使用的話會導致 TLE，需要在一個 unordered_map 來進行 hash，由於數字陣列最大只會來到 \(10^5\)，因此讓先讀到的數字先放入 unordered_map，假如沒有被記錄在 unordered_map 表示這個數字還沒有被 hash，現在給他 hash，之後如果查詢此值就給他 hash 過的數值，以此為標準來找出 <code>num[v][k-1]</code> 的值，注意這裡的 <code>num[v][k-1]</code> 是 <code>num[unordered_map[v]][k-1]</code></p>
<p>map 在數量大於 300 時，速度會開始變慢，如果已知需要紀錄的數量大於 300 時使用 unordered_map。</p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>原本我一開始這題還想要開一個二維陣列去寫，第一個維度是這個數字(定義 x)，第二個維度是出現地次數(定義為 y)，值為題目陣列的 index，但發現這樣很難寫，而且很麻煩XDD，所以後來就改使用 vector 去寫，非常方便又好用阿XD。</p>
<p>題外話：現在在寫 UVA 時 judge 壞掉了，好難過QQQQ。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100020</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, k, v, temp; </span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; num[MAXN]; <span class="comment">//我們用來分類的陣列，第一個維度是每一個數字的分類</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; record; <span class="comment">//用來記錄 hash，陣列的 int 值會 hash 變成低於 MAXN 的值，才可以讓 num vector 成功存入</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"out.txt"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m)&#123; <span class="comment">//輸入資料</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= MAXN; i++) num[i].clear();</span><br><span class="line">        <span class="comment">//一定要把之前的全部查詢都清除，不然會讓上筆測資跟這次的干擾；</span></span><br><span class="line">        <span class="comment">//一定要是 MAXN，題目的數字是 0 &lt; x &lt; MAX</span></span><br><span class="line">        cnt = <span class="number">0</span>; record.clear(); <span class="comment">//cnt 是 hash 的值，如果 record 沒有紀錄此數字就讓 cnt 表示這值，</span></span><br><span class="line">        <span class="comment">//進行 hash 後就不會有浪費 num vector 的問題。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123; <span class="comment">//輸入資料</span></span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; temp;</span><br><span class="line">            <span class="keyword">if</span>(!record.count(temp)) record[temp] = cnt++; <span class="comment">//如果 record 沒有 hash 過現在這個數值，現在進行 hash，然後讓 cnt 的值再加一。</span></span><br><span class="line">            num[record[temp]].push_back(i); <span class="comment">//將要查詢的數字先轉成 hash 過的值，在用其 hash 值的 num 找出 index。</span></span><br><span class="line">            <span class="comment">//並且透過第二個維度來表示第幾個出現，一開始第一個出現的會是零</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123; <span class="comment">//查詢 query</span></span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; k &gt;&gt; v;</span><br><span class="line">            <span class="keyword">if</span>(num[record[v]].size() &lt; k ) <span class="built_in">cout</span> &lt;&lt; <span class="string">"0\n"</span>; <span class="comment">//如果 k 比 num[record[v]](hash 值) size 小，表示查詢不到輸出 0</span></span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; num[record[v]][k<span class="number">-1</span>] &lt;&lt; <span class="string">'\n'</span>; <span class="comment">//輸出 index</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>Disjoint Set 並查集</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>人生心得 2021年02月06日</title>
    <url>/2021/02/06/life_experence/experence20210206/</url>
    <content><![CDATA[<h2 id="說明"><a href="#說明" class="headerlink" title="說明"></a>說明</h2><blockquote>
<p>覺得最近得自己又開始不安穩了，不安感又開始隱隱作亂，我好怕失敗，我都在努力，能不能。</p>
<p>能不能讓我一定會成功，讓我安心。<br>我不是壞人，我沒有錯，我不應該受到這種折磨。</p>
</blockquote>
<a id="more"></a>

<h2 id="演算法的挫敗"><a href="#演算法的挫敗" class="headerlink" title="演算法的挫敗"></a>演算法的挫敗</h2><p>因為我高中是寫演算法的，但是我演算法沒有寫得比台大頂尖好，但演算法路很小，通常非頂尖就不會有工作。</p>
<p>但是我喜歡演算法，所以我現在還繼續努力，只是遇到太多的挫折就會很受傷，有時候是覺得自己的腦袋不聰明、有時候是別人常會看不起你，認為自己高中沒能力就不要再繼續往這條路走；我很頑固，我不願意承認，到現在都還是不認輸，導致我現在沒人看好，自己也看不好我自己，但我卻還是往這方向走。</p>
<p>希望自己組隊的演算法可以在今年九月打到銀獎，讓現在的我與高中的我可以不愧對自己，能夠告訴自己，自己是做得到的，我才沒有那麼沒用。<br>即使那時候的我嚎啕大哭，我也不覺得丟臉。</p>
<h2 id="自動投資"><a href="#自動投資" class="headerlink" title="自動投資"></a>自動投資</h2><p>雞蛋不應該都放在同個籃子哩，所以我不讓自己的人生輸在演算法上，接了兩個案子，一個是自動投資，但現在也沒有到很棒的起步，由於現在還在摸索中，還沒有辦法穩上腳步。</p>
<p>很怕自己沒有辦法寫成功，怕賠了教授的錢，更怕的是毫無起步，浪費了時間。</p>
<p>嘴巴說我是大學生，我不怕失敗，那是騙人的，我很害怕失敗，我超怕我自己做錯了一切，我沒有人帶，一切都憑著自信與厚臉皮來讓自己表現出我的能力，但其實每一次的我都在緊張，我都在畏懼。</p>
<p>希望自己這次能夠做好這件事，但目前看起來也還有很多要學習，希望學習不會使我茫然。</p>
<h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><p>有一個加州大學柏克萊分校的教授很欣賞我，台灣人。</p>
<p>他找我進入他的公司，我加入了，但問題又來了，雖然我有滿腔的熱血，但是公司認為我是菜鳥，因此我負責的東西比較不是公司主要的，每次我報告都沒有認真聽，久而久之開始累了，對工作也趕到疲憊。</p>
<p>由於我也不太確定自己的薪水，不清楚自己在公司的價值是如何，我常認為自己就像免洗筷一樣，用不到就丟了吧！</p>
<p>希望自己可以找到滿意的薪水，找到工作的安全感，接著努力工作，等待獎賞。</p>
<h2 id="大學"><a href="#大學" class="headerlink" title="大學"></a>大學</h2><p>由於上述的各種原因，大二就有種庸庸碌碌、汲汲營營的感覺，沒有明確的目標再行動，沒有系統化的成<br>長，成績也沒有變高，甚至還掉落，讓人的信心越來越低。</p>
<p>加上自己沒有一個女朋友可以聽自己得內心，我也不擅長將自己的內心打開，只能打在網路上，無論有誰看到我都不在意，因為他們不認識我，不會在背後嘲笑我。</p>
<p>我可能需要一個女朋友來讓我安心，讓她告訴我，我永遠是對的，你的失敗我都會包容，你不會失敗，因為你有我這個女朋友。<br>太夢想了對吧，不過我就是個理想主義者，每次都帶著期待又害怕的心情去面對每件事情，然後開心或者失望的歸來。</p>
<h2 id="內心"><a href="#內心" class="headerlink" title="內心"></a>內心</h2><p>我覺得自己最近成長了很多，可能是青少年(還沒有滿 20 歲)或小大人的轉折點吧，原本的我很悲觀，因為高中時期的我面對的問題都是可以憑者<strong>我的努力</strong>去完成，去改變它；但現在的我發現，我想要解決的問題都不是只要我<strong>努力</strong>，就可以解決的。</p>
<p>於是我拚了命的想要讓自己不斷成功，但換來的是痛苦和難過，在這麼多的情況下，漸漸的我也調適了自己，強制了自己演化。</p>
<p>在跟揮霖老師講到自動投資的專案時，老師有說樂觀是很重要的一件事在；ICPC 2020 比賽時，陳風平學長也說樂觀很重要，這是有研究證明的，當時的我不懂此道理，一心的想要反駁，認為悲觀會使我努力，我努力就能解決問題。</p>
<p>現在的我知道這是錯的，很多問題都不是靠著努力就能解決，有時候能夠成功的點並不是努力，而是機運，經歷過多次失敗後，我終於知道自己需要的是堅強與樂觀，樂於接受事實，並在對問題進行改進，讓下次更好或是認賠殺出，我從來沒有認賠殺出過，我也很討厭這個選項，希望我這輩子都不需要使用這個選項。<br>我想要最完美的過程，最完美的結局，我知道不可能達成，早就失敗了，就像急診室醫生一般，明知道這位患者一定不能被救活，但還是會想要拚了命的救活。醫生想要的不是奇蹟，而是不願意在眼前目送著生命的逝去。</p>
<p>現在的我，是樂觀的，我要不害怕每個挑戰，我不需要面子，我需要的是貨真價值的能力。<br>希望我能夠做得到。</p>
]]></content>
      <categories>
        <category>人生旅途</category>
      </categories>
      <tags>
        <tag>大學Life</tag>
        <tag>人生旅途</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces 1477A - Nezzar and Board (設計解題、暴力搜尋 Brute force)</title>
    <url>/2021/02/10/Codeforces/Codeforces%201477A/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>有一個黑板上有許多數字，你可以透過 \(z = 2x-y\)，其中 x,y 為黑板上的數字且可以相同，你可以將 z 在寫到黑板上，並且 x,y 不移除，試問能否用黑板的數字求出 k？</p>
<p><a href="https://codeforces.com/contest/1477/problem/A" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li>能夠將 \(2x-y\) 進行推導與聯想</li>
<li>了解貝祖定理</li>
</ul>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>好題，太好了，能寫出來的都是天才八。</p>
<p>我們將推導進行分解，方便理解。</p>
<h3 id="Step-A-2x-y-k-推導"><a href="#Step-A-2x-y-k-推導" class="headerlink" title="Step A: \(2x-y = k\) 推導"></a>Step A: \(2x-y = k\) 推導</h3><ul>
<li>我們可以將 \(2x-y = k\)，理解成 \(x-y=k-x\)。</li>
<li>再來我們進行分析，公式推導<ul>
<li>\(x_i = x_j + (x_j - x_k) \)</li>
<li>\(x_a = x_i + (x_i - x_b) \)</li>
<li>\(x_c = x_a + (x_a - x_d) \)</li>
<li>我們就可以將 \(x_c\) 表示為 \(x_c = x_j + (x_j - x_k) + (x_i - x_b) + (x_a - x_d) \)</li>
<li>因此我們公式就成了 \(\sigma (x_i - y_i) = k - x_i\)，sigma 不用白板數字全部累加，只要我們需要的就好，我們也可以針對需要的不斷進行操作，也就是可以 \(y(x_i - y_i) = k - x_i\)。</li>
</ul>
</li>
<li>再來我們可以透過 \(2x-y = k\) 反覆求得 x or y。<ul>
<li>\(2x-y = k = x + (x-y)\)，這裡我們把 \(x + (x-y) \) 視為新的數字(k)</li>
<li>將 k 視為 \(x + (x-y) \) 跟原先的 x 在嘗試一次 \(2x-y\)<br>就可以理解成為 \(2x - [x + (x-y)] = 2x - 2x + y = y\)，可以透過此推導再次求回 y，反之，也可以求出 x，將係數相反放即可。</li>
</ul>
</li>
<li>因為可以透過 \(2x-y\) 不斷求出 x 與 y，因此我們可以理解此數學式 \(\sigma (x_i - y_i) = k - x_i\) 為 \(\sigma (x_i - x_1) = k - x_1\)，其實 \(x_1\) 為隨便一個 x 數值即可，因為每個 x 都可以被 \(2x-y\) 反覆求出。</li>
<li>再來我們將這個公式寫成方程式，\(y_1(x_1-x_1) + y_2(x_2-x_1) + y_3(x_3-x_1) + … + y_n(x_n-x_1) = k - x_1 \)，其中 y 值可以為 0 or 1，不斷產生的 \(x_i\)，如果我們求出的 k 不會用到就可以讓 y 為零。</li>
</ul>
<h3 id="Step-B-貝祖定理"><a href="#Step-B-貝祖定理" class="headerlink" title="Step B: 貝祖定理"></a>Step B: 貝祖定理</h3><p>貝祖定理是關於最大公因數的其中一個定理之一，此定理說明 \(ax+by = dm\)，其中 a,b 為已知數值，m 為 a,b 最大公因數，d 為倍率。</p>
<p>詳細證明請參考<a href="https://zh.wikipedia.org/wiki/%E8%B2%9D%E7%A5%96%E7%AD%89%E5%BC%8F" target="_blank" rel="noopener">貝祖定理 - wiki </a></p>
<p>因此就可以讓貝祖定理套用在 \(y_1(x_1-x_1) + y_2(x_2-x_1) + y_3(x_3-x_1) + … + y_n(x_n-x_1) = k - x_1 \) 此公式，只要證明 \(k - x_1 = gcd( \sigma(x_i- x_1))\) 即可。</p>
<h3 id="Step-C-可是-y-1-x-1-x-1-y-2-x-2-x-1-y-3-x-3-x-1-…-y-n-x-n-x-1-k-x-1-此公式只有用到已知的-x，那我們根據-2x-y-所推出來的數值不就都沒有用到嗎"><a href="#Step-C-可是-y-1-x-1-x-1-y-2-x-2-x-1-y-3-x-3-x-1-…-y-n-x-n-x-1-k-x-1-此公式只有用到已知的-x，那我們根據-2x-y-所推出來的數值不就都沒有用到嗎" class="headerlink" title="Step C: 可是 \(y_1(x_1-x_1) + y_2(x_2-x_1) + y_3(x_3-x_1) + … + y_n(x_n-x_1) = k - x_1 \) 此公式只有用到已知的 x，那我們根據 \(2x-y\) 所推出來的數值不就都沒有用到嗎?"></a>Step C: 可是 \(y_1(x_1-x_1) + y_2(x_2-x_1) + y_3(x_3-x_1) + … + y_n(x_n-x_1) = k - x_1 \) 此公式只有用到已知的 x，那我們根據 \(2x-y\) 所推出來的數值不就都沒有用到嗎?</h3><p>這裡就又一個新推導了，我們假設白板上只有兩個數字 a,b，我們可以給他進行反覆操作</p>
<ul>
<li>\(2a-b\) 是新的數值</li>
<li>\(2b - 2a-b = b - 2a\) 又是新的數值</li>
<li>\(2(2a-b) - b = 4a - b \)，這裡我們假設 \(4a -b = k\)</li>
<li>因此 \(k = 4a - 1b\)，這裡會符合貝祖定理，因此 \( k = gcd(a,b) \)</li>
</ul>
<p>因此我們可以推論出只要是透過原先白板的數值推出的值都一定會符合 \(gcd(a,b)\)。</p>
<h2 id="Step-D-求出公式"><a href="#Step-D-求出公式" class="headerlink" title="Step D: 求出公式"></a>Step D: 求出公式</h2><p>只要 \(\gcd(x_i - x_1) = d(k - x_i) \) 就可以被解出，也就是只要 \(\gcd(x_i - x_1) \ mod \ (k - x_i) = 0 \)，就是有解。</p>
<p>d 則是貝祖定理的數值，並不再本題討論中，詳請須看貝祖定理的證明</p>
<h2 id="參考來源"><a href="#參考來源" class="headerlink" title="參考來源"></a>參考來源</h2><ul>
<li><a href="https://blog.csdn.net/weixin_45697774/article/details/113655626" target="_blank" rel="noopener">Codeforces Round #698 (Div. 2) D. Nezzar and Board（一步步推出来，超级清晰，不猜结论，看不懂来打我 ~ 好题 ） - 繁凡さん</a></li>
<li><a href="https://codeforces.com/blog/entry/87294" target="_blank" rel="noopener">Editorial of Codeforces Round #698 (Div.1, Div.2) - Nezzar’s blog</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E8%B2%9D%E7%A5%96%E7%AD%89%E5%BC%8F" target="_blank" rel="noopener">貝祖定理 - wiki </a></li>
</ul>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>這題真的是一個好題，複雜的推導，又需要用到數學定理，現在回頭想想或許 \(2x-y=k\)，題目這裡其實就在暗示這題可以使用貝祖定理來解，但因為寫題目的經驗不夠多沒有反應到，錯失了寫出這題的能力，好可惜呀！</p>
<p>也要謝謝繁凡さん的 blog，他寫得很詳細，如果沒有他的 blog，我可能還沒有辦法意識到自己到底怎麼錯的，錯在哪，正確的思維要怎麼走。</p>
<p>題外話，我看懂這題花了 3hr，是不是有點太笨了QQ。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1000200</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> t, n, k;</span><br><span class="line"><span class="keyword">int</span> num[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">cin</span> &gt;&gt; num[i]; <span class="comment">//輸入數列</span></span><br><span class="line">        sort(num, num+n); <span class="comment">//排序，以免會有相減，減出負值的冏境發生，讓 gcd 失靈。</span></span><br><span class="line">        <span class="keyword">int</span> x1 = num[<span class="number">0</span>], gcd = <span class="number">0</span>; <span class="comment">//c++ 的 gcd 在其中有一值為 0 時，gcd 為另一數</span></span><br><span class="line">        <span class="comment">//這裡不可以用 1，這樣最大的公因數永遠會是 1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) gcd = __gcd(gcd,num[i] - x1); </span><br><span class="line">        <span class="comment">//開始找所有數列的最大公因數</span></span><br><span class="line">        <span class="keyword">if</span>((k - x1) % gcd == <span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">"YES\n"</span>;</span><br><span class="line">        <span class="comment">//如果可以整除表示符合貝祖定理，證明可解。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"NO\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="思考流程"><a href="#思考流程" class="headerlink" title="思考流程"></a>思考流程</h2><p>透過紙筆與黑板而思考而成的片段，放在網路上供我紀念XD</p>
<p>錯誤的程式碼就不放上來讓大家見笑了QQQQ。</p>
<blockquote>
<p><img src="https://i.imgur.com/0bD4xXC.jpg" alt=""></p>
</blockquote>
]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>設計解題</tag>
        <tag>程式解題</tag>
        <tag>Codeforces</tag>
        <tag>暴力搜尋 Brute force</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa1237 - Expert Enough?(水題)</title>
    <url>/2021/02/10/UVa/UVa1237/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>有一家公司要建立汽車資料庫，會給你很多筆的汽車品牌與他的最低價與最高價，之後在給你一個價格請你幫忙查詢此價格有哪一個汽車品牌落在區間？</p>
<p>如果這個價格有兩個汽車品牌以上的話或都沒有汽車品牌在此價格就輸出 UNDETERMINED，其他都輸出牌子。<br><a href="https://onlinejudge.org/index.php?option=onlinejudge&Itemid=8&page=show_problem&problem=3678" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="觀念重點"><a href="#觀念重點" class="headerlink" title="觀念重點"></a>觀念重點</h2><ul>
<li>選擇適合的演算法</li>
<li>評估程式好寫以及題目最大容許的時間複雜度</li>
</ul>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>這題其實用程式碼寫可以非常簡單，<del>不然怎麼可以叫水題嘛XD</del>，但這題可以直接用線性查詢的方式查出，由於題目的資料庫資料最大只會來到 10000，且查詢只會有 1000，因此這題的時間複雜度可以到 \(O(10^7)\)，基本上所有的程式題目都會容許此時間複雜度，因此我們就直接用最暴力的方式解即可。</p>
<p>建議 UVA 的題目都已嚴格輸出為導向，我有時候常常會因為這個卡很久QQ。</p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>其實這題我原本是想要用線段樹來解的，但寫到一半發現，要離散化的線段樹我沒有寫過呀QQQ，如果要寫要花很多時間呀，而且中途有遇到很多障礙QQ。</p>
<p>後來在翻網路資料時，意外看到有篇說這題可以暴力輾過，我才想起這題的時間複雜度不高呀，我為甚麼要讓自己走 hard 路線了，應該走 easy 路線呀！</p>
<p>對於每份題目，應該要能夠寫出最符合題目要求且讓自己編寫速度最快的演算法，畢竟比賽分秒必爭，AC 卻不看程式碼的品質。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 10020</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> t, h, m, l, p, d, q; <span class="comment">//題目的輸入資訊</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Com</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r; <span class="comment">//l 最低價格 r 最高價格</span></span><br><span class="line">    <span class="built_in">string</span> v; <span class="comment">//v 公司名子</span></span><br><span class="line">&#125;;</span><br><span class="line">Com com[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> name = <span class="string">""</span>; <span class="comment">//輸出汽車品牌</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; d; i++)&#123; <span class="comment">//開始暴力查詢</span></span><br><span class="line">        <span class="keyword">if</span>(p &gt;= com[i].l &amp;&amp; p &lt;= com[i].r)&#123; <span class="comment">//如果在此區間就進入 if</span></span><br><span class="line">            <span class="keyword">if</span>(name == <span class="string">""</span> ) name = com[i].v; <span class="comment">//如果還沒有被輸入汽車品牌，那就輸入</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="string">"UNDETERMINED"</span>;</span><br><span class="line">            <span class="comment">//表示前面有被輸入，這個價格有兩個以上的汽車品牌，因此輸入  "UNDETERMINED"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(name == <span class="string">""</span> ) name = <span class="string">"UNDETERMINED"</span>; <span class="comment">//沒有品牌，輸輸=入  "UNDETERMINED"</span></span><br><span class="line">    <span class="keyword">return</span> name; <span class="comment">// 輸出 name</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"out.txt"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; d;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; d; i++) <span class="built_in">cin</span> &gt;&gt; com[i].v &gt;&gt; com[i].l &gt;&gt; com[i].r;</span><br><span class="line">        <span class="comment">//資料庫輸入</span></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; q;</span><br><span class="line">        <span class="built_in">string</span> name;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; q; i++)&#123; <span class="comment">//查詢</span></span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; p;</span><br><span class="line">            name = solve(p);</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; name &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>水題</tag>
        <tag>UVa</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa927 - Integer Sequences from Addition of Terms(數論 Math theorm)</title>
    <url>/2021/02/10/UVa/UVa927/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>有一個數列，有三種模式，分成 a,b,c，index 從 0 開始，且有一個數字 d，a 為主要的數列，b 數列的方式是重複 \(a_i\) 的數列 \(i * d\) 次，而 c 則是一個 hash 的數列，公式如下<br>\(a_n = c_0 + c_1 n + c_2 n^2 + … + c_i n*i\)，注意，這裡的 n 是第 n 項，而非 sigma 的意思。</p>
<p>給你 c 數列與 d，還有一個數字 k，詢問 \(b_k\) 的位置？</p>
<p><a href="https://onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=868" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li>了解題目意思，懂得基本數學觀念 </li>
<li>善用數學的等差公式概念</li>
</ul>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>我們主要的目的是要找出 \(b_k\) 的位置，由於 b 數列會隨著 d 遞增，但 b 會重複 \(a_i\) 的數列，因次我們要先找出 \(a_i \)，但題目只給我們 c，因此我們要用 c 去推 a，這時候題目的公式就派上用場了。</p>
<p>那現在我們要找出的就是 \(b_k\) 是用到 a 的那個數值了。</p>
<p>怎麼找？</p>
<p>透過等差公式。</p>
<p>由於b 數列的方式是重複 \(a_i\) 的數列 \(i * d\) 次，與等差數列的概念吻合，因此我們進行疊代，找到一個數值(定義 p)可以 \(\geq k\)，再將 p 去套入公式即可，這裡的 p 是公式的 n。</p>
<p>需要特別注意的是那條最長的數列，第一個為數列長度，然後 index 從 0 開始。</p>
<h2 id="參考來源"><a href="#參考來源" class="headerlink" title="參考來源"></a>參考來源</h2><p><a href="https://blog.csdn.net/mobius_strip/article/details/73590707" target="_blank" rel="noopener">UVa 927 - Integer Sequences from Addition of Terms - 小白菜又菜</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>肯定是我的英文太弱才讓我看英文的數學題讓我這麼痛苦QQ，一開始的我把 n 理解為最後一項，害我整個程式都寫錯，看別人的 uva 詳解我才知道這題要怎麼解，題目意思是如何，表示我對英文的數學理解力還不夠。</p>
<p>再多刷些 uva 題目增強八。</p>
<p>我還將那條最長的數列以為全部都是數列的值，都用 stringstream 去解..，後來才發現第一項是 n，index 從 0 開始，嗚嗚。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 10020</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> C, d, k, temp1, clen; <span class="comment">//clen = c 數列 length</span></span><br><span class="line"><span class="keyword">int</span> c[MAXN], a[MAXN]; <span class="comment">//數列 c 與數列 a</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = d, y = <span class="number">0</span>, p = <span class="number">0</span> ; <span class="comment">//y 為 a_i，p 判斷當前等差數列的最大長度</span></span><br><span class="line">    <span class="comment">// x 則是下底</span></span><br><span class="line">    <span class="keyword">while</span>(p &lt; k)&#123; <span class="comment">//如果當前等差數列的最大長度還沒有大於 k 就繼續</span></span><br><span class="line">        y++; <span class="comment">//累加，進行疊代。</span></span><br><span class="line">        p = y * (d + x) / <span class="number">2</span>; <span class="comment">//等差數列公式</span></span><br><span class="line">        <span class="comment">//cout &lt;&lt; "p is" &lt;&lt; p &lt;&lt; '\n';</span></span><br><span class="line">        x += d; <span class="comment">//下底加大</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; "y is " &lt;&lt; y &lt;&lt; '\n';</span></span><br><span class="line">    <span class="keyword">int</span> ans = c[<span class="number">0</span>], cnt = y;  <span class="comment">//cnt 計算 n * i 的倍數</span></span><br><span class="line">    <span class="comment">//ans 是答案，由於第一項不乘以 n，且題目 k 最小為 1，因此我設定第一項是最小答案</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= clen; i++ )&#123;</span><br><span class="line">        ans += c[i] * cnt; <span class="comment">//題目公式</span></span><br><span class="line">        <span class="comment">//cout &lt;&lt; c[i] &lt;&lt; ' ' &lt;&lt; cnt &lt;&lt; '\n';</span></span><br><span class="line">        cnt *= y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"out.txt"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; C;</span><br><span class="line">    <span class="keyword">while</span>(C--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; clen; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= clen; i++) <span class="built_in">cin</span> &gt;&gt; c[i]; </span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; d &gt;&gt; k;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; solve() &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>數論 Math theorm</tag>
      </tags>
  </entry>
  <entry>
    <title>電影觀後感 - 靈魂急轉彎 (5/5)</title>
    <url>/2021/02/12/movie/soul/</url>
    <content><![CDATA[<h2 id="前情概要"><a href="#前情概要" class="headerlink" title="前情概要"></a>前情概要</h2><blockquote>
<p>喬（Joe Gardner）人過中年仍抱有在爵士樂團擔任鋼琴手的夢想，卻懷才不遇只能在紐約一所國中擔任兼職音樂教師。一日，透過以往學生阿寇（Curley）的引薦，喬得到與知名爵士樂手桃樂絲（Dorothea Williams）面試的機會，桃樂絲對於喬渾然忘我的即興演出印象深刻，同意他晚上來二分音符酒吧參加樂團表演。喬深感自己夢想即將成真，在狂喜之下衝出街道，然而大意掉進人孔重傷昏迷。當喬恢復意識時，發現自己瀕臨死亡邊緣，成為一個靈魂，身在名為作古畢業班（Great Beyond）的空間，三位靈魂告知喬此處是靈魂的終點，隨後消失於空間盡頭的白光，見到此景的喬陷入恐懼，朝邊界奮力掙扎，意外落入名為投胎先修班（Great Before）的空間，亦稱作人生研討會（The You Semina）。</p>
 <div class="video-container"><iframe src="https://www.youtube.com/embed/zXTVxkd9KUY" frameborder="0" loading="lazy" allowfullscreen></iframe></div>

<p><a href="https://zh.wikipedia.org/wiki/%E9%9D%88%E9%AD%82%E5%A5%87%E9%81%87%E8%A8%98" target="_blank" rel="noopener">資料來源</a></p>
</blockquote>
<a id="more"></a>

<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>整體我非常喜歡這部片，以下是我的靈魂急轉彎心得。</p>
<p>但由於我寫電影心得的時間拖太長，可能有些地方寫得不好，還請大家見諒。</p>
<h3 id="主角在中學當代課老師"><a href="#主角在中學當代課老師" class="headerlink" title="主角在中學當代課老師"></a>主角在中學當代課老師</h3><p>我認為這部片很吃情感與人生經驗，沒有這種不斷失敗、渴望成功的人會感受不到主角為何拼命，主角熱愛爵士樂，夢想是想要加入知名的爵士樂團，但因為現在的環境只能讓他在中學老師當代課老師，這種離自己夢想越來越遠，離妥協越來越近的無力感，會讓人想愈現實妥協。</p>
<p>人的適應力很強，只要溫水煮青蛙，可以讓每位抱有理想的英雄都成了現實中的螺絲釘。</p>
<p>男主角收到了學生的邀請，可以去當知名爵士樂團的臨時演員，男主角的專注演奏感化了樂團，樂團願意讓他一起加入，但男主角卻沒有得到喜悅，但這明明是他迫切想要得到的呀，但卻為甚麼會這樣呢？</p>
<p>我能理解，有的時候我們所渴望的是追逐目標的感覺，但我們卻深不自知，只覺得我一定要達成目標我就會很快樂，我原本以為我拿到金手這就是我的人生快樂之一，但我卻發現當我拿到金手後，我還是我，完全沒有改變，明天還是要去上學，過著一樣的生活。</p>
<p>那我是為了甚麼才這麼努力？為了目標，這樣說對嗎？對。<br>那我努力後為甚麼沒有成就感？我目標不是達成了嗎？</p>
<p>因為我們達成了，在完成目標的同時，也象徵著我們失去了目標，也就表示自己失去了追逐目標的權利，當我們下次再燃起幹勁一定就是我們要追逐新的目標。</p>
<h3 id="小女孩的轉變"><a href="#小女孩的轉變" class="headerlink" title="小女孩的轉變"></a>小女孩的轉變</h3><p>老實講，我很喜歡小女孩。<del>犯罪預告</del></p>
<p>小女孩對音樂的熱愛在班級中無人能比，但也就因為無人能比才無人理解，但小女孩演奏樂器到忘我的境界時卻被班上的人嘲笑，小女孩因此感到丟臉，因為感到丟臉，不想要與他人不同，因此希望自己在班上吹奏音樂時可以不要出現忘我的境界。</p>
<p>ummm…這在現實中很常發現，對八。很多時候大家都會做一件事做到忘我，但其他人卻沒有時，視覺的反差感會讓人感到害羞，進而封閉自己忘我的境界，特別在中學、人格發展的階段如果經常遭到此對待會很容易讓自己再也不敢達到忘我的境界，失去了每個人最獨有、最能表達自己的時候。</p>
<p>而男主角在此時也做出了正確的舉動，制止了他人，但在中學時期，朋友帶給自己的觀念總比老師講述給自己的觀念有用多了，小女孩最後還是決定想要跟老師說放棄練習樂隊。</p>
<p>但當 22 號支持他放棄音樂時，他則反悔了，突然自願的吹奏起音樂，又重新想要繼續在樂隊練習，我認為小女孩只是想向往常一般從男主角這邊獲得勇氣與支持，但因為現在男主角的身體正被 22 號駕駛，才會對小女孩說放棄也不錯，但小女孩壓根從沒有這樣想，他只是想要找到能夠理解他的人，他以為老師也認為他不喜歡樂器了！趕緊吹奏一首樂器來表示自己其實很想要繼續留在樂隊，也很害怕自己又被老師勸退樂隊，趕緊跟老師說我下禮拜練習而趕快下樓。</p>
<p>這種感覺很棒啊，中學時期就有屬於自己的人生動力去學習、去成長，而沒有被人生的一些娛樂所迷惑。不像我常常被愛情、成績、人際關係所迷惑….QQ，能夠找到自己想要的事情去成長且能夠不斷達到忘我的境界，當從忘我的境界回來時，最有成就感、人生中滿足的一刻嗎？</p>
<h3 id="靈魂先修班-死後的世界"><a href="#靈魂先修班-死後的世界" class="headerlink" title="靈魂先修班(死後的世界)"></a>靈魂先修班(死後的世界)</h3><p>在男主角進入靈魂先修班後，導師們帶領男主角去看著靈魂們去領取不同的個性，在萬物堂體驗各個事物，領悟自己的火花，用這樣的方式去描述其實很有趣，現在的我們無從推得我們的個性到底是怎麼來的，所以電影透過其實有萬物隨便的指定的你的個性這種方式來告訴大家每個人的個性其實都不是自己決定的，都是傑瑞們<strong>隨便</strong>給的。</p>
<p>而靈魂們就透過導師們的隨意，再加上自己跟著導師找到屬於自己的火化後，一同再次加入地球，成為下一個新生命。</p>
<blockquote>
<p><img src="https://i.imgur.com/EBHZ6Q0.jpg" alt="靈魂先修班"></p>
</blockquote>
<h3 id="22-號的個性"><a href="#22-號的個性" class="headerlink" title="22 號的個性"></a>22 號的個性</h3><p>22 號是一個與眾不同的靈魂，他跟其他的靈魂不同，他與其他人的價值觀不同，在靈魂急轉彎中死後的世界有著，他不成熟，我們不確定他在生前遇到了甚麼，但我們知道他生前肯定沒有很快樂、沒有受到很正面的影響，他看甚麼事情都是負面的，從來沒有想要體驗生活，也並不認為體驗生活、找到自己的火花是一件快樂的事情。</p>
<blockquote>
<p><img src="https://i.imgur.com/gE5dtB9.jpg" alt="體驗萬物"></p>
</blockquote>
<p>由於他有著不可撼動的價值觀，因此他在對待導師時總是可以找到導師們的弱點進行反擊，讓導師們生氣，但男主角意外的成為導師，且她的生活是不像其他導師們般光鮮亮麗，有著成功的事蹟、幸福的人生，這讓 22 號卸下心防，也很好奇，這個人是甚麼怪咖，生活這麼爛還想要回去，就只是為了演奏 sax？</p>
<p>22 號帶她去找船長進入迷失的靈魂中，如果是一位專注的人則會在泡泡中專心，如果是一位執著的人則會成為迷失的靈魂，被黑霧壟罩，我超喜歡這種世界觀的，社會不就是如此嗎？但我們對一件事情執著到近乎瘋狂時常常會做出一些傷害他人或自身的事情，而不自知或是置之不理，這些人不就是迷失的靈魂嗎？</p>
<h3 id="男主角回去地球參加演出"><a href="#男主角回去地球參加演出" class="headerlink" title="男主角回去地球參加演出"></a>男主角回去地球參加演出</h3><p>男主角太想要回去地球，於是船長幫助他回去世界，但卻發現 22 號進去到男主角的身體，而貓的身體裡面有男主角？其實這裡我有一個地方很好奇，那貓原本的靈魂呢？</p>
<p>22 號與男主角體驗了人生的事物，對於男主角是平常在不過的事情，但對於 22 號卻是非常有趣的、新鮮的，22 號在導師那邊所體驗不到的事情，他在地球上都體驗到了！我認為導師沒辦法撼動他是合理的，你跟一個不會寫字的人說，現在的人可以透過寫符號就可以與他人溝通，對不會寫字的人是很難理解的。</p>
<p>用俗語來比喻最相似的應該就是，貧窮限制了我的想像。</p>
<p>於是 22 號透過在地球中的體驗，活過來了，打破了他以前的價值觀，他找到了有趣的事物、值得他專注的事物。</p>
<h3 id="22-號不願意將身體還給男主角"><a href="#22-號不願意將身體還給男主角" class="headerlink" title="22 號不願意將身體還給男主角"></a>22 號不願意將身體還給男主角</h3><p>22 號由於害怕自己找不到火花沒有辦法在享受到在地球上的人生，必須要回去會面無聊的導師們，他跑走了，他害怕自己現在所接觸到的事物只是體驗，回去導師區後只能夠<strong>模擬</strong>人生，她害怕地跑走了。</p>
<p>此時的我在想 22 號應該有被加入<strong>自私</strong>此個性，他從來沒有去考慮過其他人，永遠都只有考慮自己，明明這是別人的身體、別人現在有著最重要的事物，但 22 號卻從沒有考慮他人，而直接向前衝果斷地離開男主角。</p>
<p>而後來會計師(專門清點靈魂的導師)發現這個錯誤，要把這個問題給解決掉，順利找到了 22 號與男主角。</p>
<p>其中還跟男配角說洋芋片很不健康、不要吃，我那時候想到很幽默的話XD，只要多吃點就可以提早見到導師摟XD。</p>
<h3 id="理髮師與-22-號的對話"><a href="#理髮師與-22-號的對話" class="headerlink" title="理髮師與 22 號的對話"></a>理髮師與 22 號的對話</h3><p>這裡是電影中我覺得非常精采的片段，由於 22 號的幽默風趣與以往的男主角不同，讓理髮師有了更廣的對話內容，不再只有 jazz，聊到了理髮師的過去，其實原本理髮師也不是真的想要當理髮師，他也有他的人生目標，22 號認為那理髮師的火花應該不是理髮師，應該要去努力追求她所愛的理想，但理髮師卻對他自己現在的工作感到滿足，雖然不是最好，但也是份不錯、有價值的工作。</p>
<p>此時讓我意識到了理髮師並沒有說出自己當時選擇的痛苦與逃避的過程，而是講出了最美好的一段，我想這是動畫必須的場景，動畫必須傳達給人們正面的感覺，而不是負面感，我也認為這才是動畫一定要做的事情，當人們具有正能量才有辦法繼續向前，不然就很容易像 22 號一樣，這也是我的微積分教授所教導我的，我非常感謝他。</p>
<p>理髮師開心的與 22 號聊天，其中也說到了，男主角基本上只會跟理髮師聊 jazz 的事情，其他都不提起，也就意味著男主角只完全在意著自己所愛的事物，並沒有關注他人的個性，也許它的個性沒有被加入<strong>觀察</strong>，而這些個性我們卻不能夠自己去追求，而是被傑瑞們隨便給予，這不是很不公平的一件事嗎？</p>
<blockquote>
<p><img src="https://i.imgur.com/50ho4rZ.jpg" alt="與理髮師的對話"></p>
</blockquote>
<h3 id="重回靈魂先修班"><a href="#重回靈魂先修班" class="headerlink" title="重回靈魂先修班"></a>重回靈魂先修班</h3><p>重回靈魂先修班後，22 號獲得了火花，男主角也受到傑瑞們的稱讚，男主角感到憤怒，22 號憑著自私就可以獲得了重生的機會，而他卻不行？明明有錯的是他阿，他向 22 號發怒，22 號感到他的怒氣，這時 22 號因為被他人羞辱，而放棄掉她的重生機會，甩給了男主角。</p>
<p>這裡也有個疑惑，為甚麼男主角重生是回到他原本的身體，而不是新生命呢？</p>
<p>男主角成功的表演，享受完了樂團表演，此時他認為他完成了自身的人生目標，也就意味著他失去了人生目標，在此，我的認知是他<strong>暫時</strong>失去了火花，因此他想把他的生命權給予 22 號，透過找到船長來讓自己可以將生命權傳給 22 號。</p>
<p>發現 22 號成為了迷失的靈魂，他由於害怕自己被眾人給看扁、給予負面評價而感到畏懼，感到害怕，成為了一位的靈魂，就像那些畏首畏尾的人們，那些人般令人討厭，連我也開始討厭起 22 號，但或許這就是傑瑞給他的個性使然，又讓我認為我真的應該要討厭 22 號嗎？</p>
<p>總之，熱血的對手戲結束後，22 號回復正常。</p>
<h3 id="傑瑞的獎賞"><a href="#傑瑞的獎賞" class="headerlink" title="傑瑞的獎賞"></a>傑瑞的獎賞</h3><p>由於 22 號與男主角的過程都被傑瑞看在眼底，換句話說，其實傑瑞跟著我們一起看電影XD，傑瑞認為自己也受到了一場教育，因此願意給男主角在一次一個機會讓他可以重回自己的生命。</p>
<p>這讓我知道了，傑瑞可能不是神，傑瑞也類似於人，需要透過學習，需要看著別人的賣命而讓自己獲得收穫，就好比傑瑞看著每場電影，再把每個人分成某些電影類，再讓某些人成為濫電影、某些成為好電影。</p>
<p>但即使傑瑞獲得了收穫，但傑瑞還是隨意的將人給予不同的個性，這是有必要的嗎？還是其實連傑瑞也不懂、不理解呢？</p>
<h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>我認為靈魂急轉彎是非常棒的作品，但他的客群我認為應該在 25 - 55 之間，想要讓大家明白自己為甚麼而活，而動力是為何，希望可以讓每個人都再次找到自己的火花，繼續讓自己燃燒自己，努力的讓自己的火花發亮。</p>
<p>但有些支線劇情交代不清，我認為可以將這些劇情進行刪減，將主線劇情交代完整，例如男主角媽媽與男主角的對手戲我認為就相當不好，令我感受不到感情、感覺不到愛，就像是因為我想要，所以我就要的概念一樣，打不太動我的心。</p>
<p>但就只有這裡不好，其他我覺得都不賴，整體的世界觀我超極喜歡，所有的劇情鋪設都超級讚，畫面也細膩，我非常建議大家來看。</p>
<p>不然我的心得也沒有辦法打那麼多，那肯定是因為好看我才能夠打那麼多。</p>
]]></content>
      <categories>
        <category>電影心得</category>
      </categories>
      <tags>
        <tag>人生旅途</tag>
        <tag>電影心得</tag>
        <tag>動畫類電影心得</tag>
      </tags>
  </entry>
  <entry>
    <title>2020/02/02 大屯國小遊記</title>
    <url>/2021/02/13/life_experence/datun_elementary20210202/</url>
    <content><![CDATA[<h2 id="說明"><a href="#說明" class="headerlink" title="說明"></a>說明</h2><blockquote>
<p>之前與嘉偉還有柏翰(以下稱 boso)，一起騎車去大屯山看夜景，出去玩樂的趣事。</p>
</blockquote>
<a id="more"></a>

<h2 id="前情概要"><a href="#前情概要" class="headerlink" title="前情概要"></a>前情概要</h2><p>我們在寒假要開始前我們就已經說好要去洗車，然後再去騎車，結果我們遲遲都沒有約，我忘記，他們也在忙跳舞社的事情就一路這樣拖拖到了 2 月 2 日。</p>
<p>中午的我跟隊伍在向指導老師討論演算法，討論時間不久，一下就好了，然後我就打電話跟嘉偉說我們來洗車八！但是我原本跟嘉偉約 5 點，但 3 點就好了，所以她趕緊打電話給 boso，讓他來北科。</p>
<h2 id="北科到大屯山"><a href="#北科到大屯山" class="headerlink" title="北科到大屯山"></a>北科到大屯山</h2><p>再從北科騎車到大屯山的時候有說有笑，騎到百齡橋的時候 boso 提醒我，我繞遠路了XD，下次我再把它改進啦，騎到大屯山的時候，那兩台 125cc 的機車都追不上我，我每個過彎的補油都比他們快些，畢竟是 150 嘛XD，但這也是我第一次感受到 150 明顯大於 125 的時候，而且還是 boso 跟我說的，不然我原本還不知道原來 150 這麼強，畢竟我沒有騎過 125 的機車上來大屯山www。</p>
<p>但如果平常都騎在平地上還是建議牽 125 拉，小台好停車又省油，我那台 150 大胖子每次在都市停車都是一場災難QQ。</p>
<p>然後在我們騎車的時候還不小心騎到了別人丟在道路上的廚餘，廚餘汁直接噴在我的車上RRRRR，超受傷的，嗚嗚，最慘的是沒想到連我的衣服都有一點…，在道路上丟廚餘的太過分了拉。</p>
<h2 id="大屯國小"><a href="#大屯國小" class="headerlink" title="大屯國小"></a>大屯國小</h2><p>我們到了四季觀景台(約大屯國小附近)，由於那時候大概是 4 點左右，還沒有日落，那時的我們先在四季觀景台看看風景，發現四季觀景台早上真的不好看QQ，太多鐵皮屋妨礙景觀了拉…，不過這也沒辦法，畢竟台灣並沒有對市容做強制整理，雖然我也不認為一定要做拉，不過就是早上的 View 會不好看些。</p>
<p>看膩了風景後，boso 提意要去大屯國小，我原本持反對意見，因為我怕國小警衛可能會把我們趕出去，但 boso 覺得到時再說XD，所以我們就上去啦，結果很意外的他們的大門是開放式大門連門的實體都沒有，只有一塊石頭和階梯，石頭上則寫著<strong>大屯國小</strong></p>
<h3 id="幼兒園區"><a href="#幼兒園區" class="headerlink" title="幼兒園區"></a>幼兒園區</h3><p>進到大屯國小後，首先映入眼簾的是幼兒園區，他們的幼兒園區很棒呀！有沙灘、溜滑梯，還有兩個我在都市從未見過的，知道是甚麼嗎？是<strong>木屋、手動發電的鋼琴</strong>，超酷的，有一個小木屋！可以在裡面逗留，當個小哨兵看守，又有手動發電的鋼琴，只要肯願意一直讓手去轉動發電器就可以開始去彈鋼琴，超酷的啦！<del>但是鋼琴要用兩隻手，要有一個人幫你轉才能發電XD</del></p>
<blockquote>
<p>樹屋<br><img src="https://i.imgur.com/t1NAHY6.jpg" alt=""></p>
</blockquote>
<blockquote>
<p>樹屋前的小吊橋<br><img src="https://i.imgur.com/w6O3V1z.jpg" alt=""></p>
</blockquote>
<blockquote>
<p>樹屋內部構造<br><img src="https://i.imgur.com/kDG0S8M.jpg" alt=""></p>
</blockquote>
<p>他們的幼兒園看起來有三班，但看起來都蠻不錯的，不過他們也是向我小學一樣吃著桶餐，我以為可能會是帶便當之類的呢，但是他們有專業的廚工在做菜，而不是像我們一樣是有著中央廚房在準備，我想有專業的廚工一定會很好吃吧！</p>
<p>而且他們的幼稚園老師也都有放出證明，這點讓我覺得不錯？可能是我社會化了，沒想到現在看到有放出證造的幼稚園我就會放心許多。</p>
<blockquote>
<p>某位老師的幼稚園老師證書<br><img src="https://i.imgur.com/7dENF67.jpg" alt=""></p>
</blockquote>
<h3 id="國小區"><a href="#國小區" class="headerlink" title="國小區"></a>國小區</h3><p>後來 boso 再往裡面探險些，發現了小學區，我們就上去他們的小學區探險拉，大屯國小蓋在山丘上所以他們是具有階梯式的，他們的操場不大，連籃球場都有點簡陋，中間有個簡易操場與司令台，供小孩們跑跳。但我認為他們確實不需要籃球場，他們有著許多有趣的遊樂設施，並不需要這種運動來強健身體，而是需要與大自然親近。</p>
<p>他們的 1,2,3 年級就在操場旁邊，操場旁邊有著攀岩，可能是要訓練小學生的肌耐力八，這感覺就超棒的呀，我的小學因為人數眾多，也沒有這種攀岩設備，於是老師們都是帶領著我們去跳花台，來訓練我們的平衡感、空間感、耐力，但這裏有著攀岩，就可以訓練到身體整個的流暢度，我認為我小時候如果有訓練過一定會更好！我個人因為小學跳花台的原因，下半身的反應特好，但上半身的反應明顯有落差，因為小學的成長都沒有去訓練到上半身。</p>
<blockquote>
<p>嘉偉的殘影 1<br><img src="https://i.imgur.com/WrPQeVx.jpg" alt=""></p>
</blockquote>
<blockquote>
<p>嘉偉的殘影 2<br><img src="https://i.imgur.com/QJQRSv7.jpg" alt=""></p>
</blockquote>
<p>我跟嘉偉在那邊拍攝我們攀岩的過程，很酷，超級酷的啦！boso 則在旁邊放著愜意的音樂，讓我的這倘旅程更加輕鬆</p>
<blockquote>
<p>嘉偉的慢動作攀岩</p>
<div class="video-container"><iframe src="https://www.youtube.com/embed/l95aNZITv8E" frameborder="0" loading="lazy" allowfullscreen></iframe></div>
</blockquote>
<blockquote>
<p>大衛的慢動作攀岩<br> <div class="video-container"><iframe src="https://www.youtube.com/embed/nHGEIx8w6kI" frameborder="0" loading="lazy" allowfullscreen></iframe></div></p>
</blockquote>
<p>他們的國小有種菜區來讓學生們學會種菜，我覺得這超酷的！在我的小學，那是一定沒有辦法的事情，因為我生活在都市中（萬華），這裡雖然沒有向大安區的高房價，但也不便宜，沒有辦法讓所有學生都在學校內有一個小植物來種菜，老實講，我認為小學能夠學會種菜這種技能相當不錯！</p>
<p>他們還有燒窯區，超酷的！我們國中的童軍課是簡單的烤肉，他們卻可以在小學就有這種體驗，感覺就超棒的！體驗到許多非都市生活，能夠在台北市體驗到大自然的學校真的不多，能夠在這種地方體驗燒窯，雖然機會可能就只在小學間，但那也是個不錯的回憶吧！</p>
<p>但比較可惜的是我認為他們可能會因為是鄉村小學的關係，人數不多，再舉辦運動會或園遊會就是一大難關，目測沒有跑道，可能沒有大隊接力這種運動方式八QQ，不過也沒辦法啦，山上的小學校資源本來就沒有辦法比都市多，要能夠有像都市一樣的高科技建築，可能還是比較難的。</p>
<blockquote>
<p>真人尺寸的圍棋棋盤<br><img src="https://i.imgur.com/H05NM5J.jpg" alt=""></p>
</blockquote>
<p>但他們有打鼓隊跟舞龍舞獅隊，應該有八，我們有看到器具XD，還是很不賴的啦。</p>
<p>但他們吃午餐看起來是十分愜意的一件事呢，他們的教室前面有著許多桌子，我想可以供他們坐在室外吃飯，看著大自然的風景，眺望者大台北吃飯，這可真是一個美好的事情呀，不需要待在教室像都市的學生一樣被制式管理，能夠多些互動空間。</p>
<blockquote>
<p>午餐區風景 1，傍晚時刻拍攝<br><img src="https://i.imgur.com/KZefjNW.jpg" alt=""></p>
</blockquote>
<blockquote>
<p>午餐區風景 2，傍晚時刻拍攝<br><img src="https://i.imgur.com/KKAL2b0.jpg" alt=""></p>
</blockquote>
<p>他們還有一個可以訓練小孩子爬行的能力的一個遊樂設施，看起來超級好玩的！可惜我們大了不能玩…。</p>
<p>此時夜晚已經悄悄降臨，大屯國小這時沒有照明設備了，我們到了警衛室，警衛室的側門貼著模範生，其中有一個讓我印象最深刻的就是他的夢想是想要去去外太空看地球，好啊！這就是有志向的年輕人！我祈求著他不會因為現實的壓力或者社會的歷練而將她的夢想只能收藏在妄想之中。</p>
<p>我曾經也是一個有著夢想的小孩，但社會把我打到了，現在的我只能看著現實給我的選項去選擇。</p>
<p>另外一位夢想則是想要有著歡樂的家庭，真的，有一個歡樂的家庭才有著面對世界挑戰的勇氣，不然就像是在生存一樣，令人感到疲憊。</p>
<p>如果不願意讓我公開，請私密我，我會將照片刪除。</p>
<blockquote>
<p>模範生 1 - 夢想是希望上月球<br><img src="https://drive.google.com/file/d/1ZVFTJE3w_7bic9S1oGiOFhtQp3OlJPOT/view?usp=sharing" alt=""></p>
</blockquote>
<blockquote>
<p>模範生 2 - 夢想是有著歡樂家庭<br><img src="https://drive.google.com/file/d/1J4wAjRZfzGVubQSaEaBqip4fZntzwXBH/view?usp=sharing" alt=""></p>
</blockquote>
<p>他們還針對每個月份都有著要求的事情，每個看起來都好棒，我相信女生應該都做得到，但是男生做得到嗎XD</p>
<blockquote>
<p>大屯國小 109 學期 12 月份四大天王檢核項目<br><img src="https://i.imgur.com/WgKblFq.jpg" alt=""></p>
</blockquote>
<h2 id="重返四季的夜景"><a href="#重返四季的夜景" class="headerlink" title="重返四季的夜景"></a>重返四季的夜景</h2><p>由於到了夜晚，我們再次重回四季觀景台看看，這時候的 VIEW 就好看很多了，畢竟夜晚了，那些醜化美觀的招牌與鐵皮屋都被夜色遮住，取而代之的是路燈、車燈、或是些許的招牌燈，點綴了整個黑夜，車燈就像動畫般緩慢的移動，美麗的瞬間不是我這種不會用相機的麻瓜可以拍攝到的。</p>
<blockquote>
<p>四季觀景台夜景 1<br><img src="https://i.imgur.com/pzAmQ3w.jpg" alt=""></p>
</blockquote>
<blockquote>
<p>四季觀景台夜景 2<br><img src="https://i.imgur.com/XT3hPda.jpg" alt=""></p>
</blockquote>
<h2 id="下山"><a href="#下山" class="headerlink" title="下山"></a>下山</h2><p>時候差不多，氣溫也開始轉冷了，我們就準備下山吃晚餐，我跟 boso 說我們不要發動引擎就可以開下山了XD，這裡的坡都很陡完全只依靠著坡的動力就能夠滑下去，可惜 boso 的車子只要一開燈就會發動引擎，沒有辦法跟我的車車一樣不發動引擎也能騎車XD。</p>
<p>下山之後我們到處晃晃，到了捷運唭哩岸去吃東西，為甚麼會到那麼遠呢？因為我想要吃飯飯XD，但是 8 點大部分的晚餐店都關掉了QQ，就跑去了捷運站附近來吃啦，原本想要吃咖哩飯，結果沒想到輪到我們的時候飯就沒了！太可惜了八…。</p>
<p>之後我們在騎車的過程中有聞到一間加熱滷味看起來就像是小巷中的名店，我們就買了，料不錯吃，但滷汁有點淡稍加可惜，豬肉片是精華一定要點，缺點是沒有內用，於是我們到了捷運的鐵橋下吃飯，結果 boso 還打翻碗噴到嘉偉XD，小鬧事，但很有趣。</p>
<h2 id="洗車"><a href="#洗車" class="headerlink" title="洗車"></a>洗車</h2><p>我們在騎車去吃飯的同時有找到一間自助洗車，於是我們就去那間自助洗車，那間自助洗車很乾淨，而且似乎主打高級的清潔劑，他的清潔劑 10 元只有 30s，有夠貴QQ，但我還是花了 20 元來洗，不得不說，把車洗乾淨的感覺真的超棒，但就是我當天背的書包必須一直背著好重RRRR，好想要放下來阿，但是我怕碰到洗車場髒髒的地方，所以一直死背著XD。</p>
<p>boso 幫我洗我的車(高壓清水)，他人超棒的，要是這裏我是女生我一定大加分，可惜我不是拉XD。下次也要帶海綿，不然會沒辦法洗車拉XD。</p>
<p>老樣子我每次洗車都會檢查自己的車車有沒有受傷，這次運氣不錯，都沒有受傷刮痕，於是這次就不用補漆拉。</p>
<h2 id="回程"><a href="#回程" class="headerlink" title="回程"></a>回程</h2><p>由於 boso 要回到內湖而我跟嘉偉要回到萬華與大安，路途不同，boso 騎到一半就往另一方向離開，而我則跟嘉偉到市民大道才分離，這是個美好的夜晚、美好的過程，讓我用文字記錄，那時候的美與快樂。</p>
<h2 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h2><p>總覺得人們的生活步調太快了，都不記錄自己的人生，就隨著時間將自己的回憶丟掉，這樣真的好可惜。</p>
]]></content>
      <categories>
        <category>人生旅途</category>
      </categories>
      <tags>
        <tag>大學Life</tag>
        <tag>人生旅途</tag>
      </tags>
  </entry>
  <entry>
    <title>電影觀後感 - 角頭：浪流連 (2/5)</title>
    <url>/2021/02/14/movie/Gatao-The-last-stray/</url>
    <content><![CDATA[<h2 id="前情概要"><a href="#前情概要" class="headerlink" title="前情概要"></a>前情概要</h2><blockquote>
<p>故事時間發生在《角頭2：王者再起》6年前，阿慶在北館角頭大哥仁哥的女兒滿月宴上，偶遇攝影師小淇進而衍生出一段相愛卻不能相守的愛情故事。身為角頭的阿慶遇到了小淇，原本水火不容的兩人，再一次次的爭吵中發現其實自己最在乎對方。阿慶與小淇相愛、相知、相惜、互相扶持，阿慶為小淇解決困難、小淇在阿慶事業遇到瓶頸時給予鼓勵。但就在此時湳沆的世界在背地裡陷害北館販毒，不僅讓北館深陷危機，仁哥與五虎們相繼誤解阿慶，小淇也因為阿慶受重傷。阿慶分身乏術，痛定思痛決定奮力一搏。</p>
<div class="video-container"><iframe src="https://www.youtube.com/embed/vpczVM8ddwk" frameborder="0" loading="lazy" allowfullscreen></iframe></div>

<p><a href="https://zh.wikipedia.org/wiki/%E8%A7%92%E9%A0%AD%EF%BC%8D%E6%B5%AA%E6%B5%81%E9%80%A3" target="_blank" rel="noopener">資料來源</a></p>
</blockquote>
<a id="more"></a>

<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>整體對於這部片並不喜歡，劇情支離破碎沒有一個完整的架構來建立，整體而言我們看的是演員的演技而不是劇情。</p>
<h3 id="滿月禮"><a href="#滿月禮" class="headerlink" title="滿月禮"></a>滿月禮</h3><p>滿月禮因為女主角的同事沒辦法感到因此換女主角代班，男主角被女主角的氣勢所逼，不甘情願地幫他做事，最後弄壞了相機鏡頭，想要賠錢了事但女主角不願意。</p>
<p>男主角回到店裡用錢對女主角賠罪但卻沒有成功，過程中看到拍攝到自己的相片，覺得拍攝的好而開始欣賞女主角。</p>
<p>整體到這邊演出了台灣道地的傳統，整體而言非常喜歡。</p>
<h3 id="女主角慢慢喜歡男主角"><a href="#女主角慢慢喜歡男主角" class="headerlink" title="女主角慢慢喜歡男主角"></a>女主角慢慢喜歡男主角</h3><p>女主角因為要拍攝北館但被當地小混混搶錢，富有正義感的女主角打抱不平，男主角看到後遏止了手下的小弟，男主角陪同女主角來拍北館，後來在一家餐廳用餐聊天聊到了雙方的身家背景，後來有次男主角要去看女主角而到女主角的工作地方時發現他不再，詢問工作同事後知道女主角的社區但不知道位置，男主角靠著厚臉皮找到女主角，之後男主角送女主角下山看醫院。</p>
<p>男主角的演技超好，那個有趣的對話腳本不得不說，超級漂亮，我都想要筆記怎麼會有好笑的對話內容XD，導演跟演員擅長這種曖昧對話的過程，但將鏡頭拉遠就會覺得這是個非常不合邏輯的地方，這種大型社區通常都會有警衛怎麼不直接詢問警衛就好了呢？還有怎麼會有人看到別人發燒還背女主角，那不是讓女主角更不舒服嗎QQ，通常應該是叫救護車吧，以及整體時間點過怪，男女主角離開女主角家是尚未傍晚，但男女主角在車上(應該是去醫院，因為沒有演到醫院那段不能確定)時間點卻是晚上，整體完全沒有交代女主角的病因，時間點也落差很大，放遠鏡頭後就覺得整體劇情奇怪，令人百思不得其解。</p>
<p>之後女主角就慢慢喜歡男主角開始有了曖昧情節，給予了男主角回饋，心的距離越來越近。</p>
<p>這裡的劇情十分不錯，非常優良，就是女主角喜歡男生這段內心戲沒有交代清楚，我覺得不好。</p>
<h3 id="橋下打鬥"><a href="#橋下打鬥" class="headerlink" title="橋下打鬥"></a>橋下打鬥</h3><p>一句話，看得過癮。整片最高潮、最吸睛的地方。</p>
<p>讓我在看的過程手腳都冒汗，怵目驚心。</p>
<h3 id="男女主角的約會"><a href="#男女主角的約會" class="headerlink" title="男女主角的約會"></a>男女主角的約會</h3><p>過程也是一樣棒，充滿了有趣的反差，讓人在看完戰鬥後感到開心與幸福，但想要充滿預言的鯊魚我這邊卻認為有點太硬要。</p>
<p>在書局，男主角特地拍獅子頭要做給女主角，聯合兄弟一起做菜這種感覺真的不錯，有著友情的快樂感覺。</p>
<p>鯊魚是女主角向男主角暗示的話，暗示他就像鯊魚般，沒有一刻可以休息下來。</p>
<p>用最新的鯊魚當梗本身是很棒的事，但導演可能忘記 IKEA 的鯊魚是表示可愛不是用在小流氓或兄弟身上呀！</p>
<h3 id="湳坑接班人賣毒"><a href="#湳坑接班人賣毒" class="headerlink" title="湳坑接班人賣毒"></a>湳坑接班人賣毒</h3><p>由於湳坑接班人(世界 - 人名)想要將北館打壞，認為北館佔了太多利益，因此想要將北館打下來，透過賣毒的方始來讓北館戰力降低，透過手下們建立起一間製毒室來拖垮對手戰力，找了大學生小陶來製毒。</p>
<p>這裡的劇情普通，在為了以後鋪陳，但也塑造了世界兇猛的形象。</p>
<h3 id="湳坑接班人去北館賭場鬧事"><a href="#湳坑接班人去北館賭場鬧事" class="headerlink" title="湳坑接班人去北館賭場鬧事"></a>湳坑接班人去北館賭場鬧事</h3><p>世界去北館玩天九牌，最終獲得勝利，但她帶著槍械違反北館規定，北館趕緊找人支援，最終世界放棄自己所勝利的籌碼瀟灑地走出出口。</p>
<p>中間仁哥跟世界的對話也是經典中的經典，雖然是經典，但我認為缺乏了些記憶點，我除了記得<strong>我認你一次、兩次，但不會有第三次！</strong>這種不太像是名言的名言樣就沒有甚麼感覺了。</p>
<p>倒是世界這邊帥氣地將錢撒出，講出一句<strong>吃紅</strong>真的帥，也讓我默默地在心中想著其實他並不是壞人，而是需要別人跟他大量的溝通來讓他理解情勢與情況，只可惜沒有人願意跟他進行大量溝通，只想讓<strong>現在的他</strong>當好一條狗。</p>
<blockquote>
<p>湳坑接班人去北館賭場鬧事<br><img src="https://i.imgur.com/2i76i4l.png" alt=""></p>
</blockquote>
<h3 id="市刑大警官-紅猴-去北館泡茶"><a href="#市刑大警官-紅猴-去北館泡茶" class="headerlink" title="市刑大警官(紅猴)去北館泡茶"></a>市刑大警官(紅猴)去北館泡茶</h3><p>紅猴聽到風聲說北館有賣毒，北館老大(貴董)直接否認，並且讓仁哥多注意。</p>
<p>這裡的紅猴姓氏為<strong>侯</strong>，讓人不禁就會聯想到新北市長侯友宜XD，令人有種微妙的感覺，紅猴這裡是個有趣的角色，透過自己的社交手法去處理任何事情，不動用任何<strong>物理</strong>上的權力，只靠著威脅、提醒的方式來讓所有人都明白情況、狀況，扮演著劇情的推動者，非常棒的角色，只可惜沒有多描述他的劇情。</p>
<p>紅猴在警局對男主角說，女主角跟我很熟，他還要叫我一聲 uncle，這裡我覺得超級好笑、超有梗，對話超棒。</p>
<h3 id="湳坑接班人與湳坑老大泡溫泉"><a href="#湳坑接班人與湳坑老大泡溫泉" class="headerlink" title="湳坑接班人與湳坑老大泡溫泉"></a>湳坑接班人與湳坑老大泡溫泉</h3><p>世界在跟湳坑老大(石霸)聊天，石霸問他是否有在北館賣毒，世界當然否認，世界被石壩潑了一杯酒後，用大吼發洩情緒。</p>
<p>這裡演出世界其實是有情有義的，他知道這是他老婆的爸爸，他對她有著其必要的尊重也並不打破，他完全能夠理解事情的重要性，而不是一言不合就拔刀的人。</p>
<h3 id="湳坑接班人與妻子的甜蜜故事"><a href="#湳坑接班人與妻子的甜蜜故事" class="headerlink" title="湳坑接班人與妻子的甜蜜故事"></a>湳坑接班人與妻子的甜蜜故事</h3><p>世界只有國中畢業但她非常愛她的老婆，特地燒了一手好菜給老婆，老婆也很開心，但老婆的擔心終究是忍耐不住，向世界提醒，並且刺激到世界，讓世界最後不願意與家人吃飯。</p>
<p>完全將世界的個性描寫的相當優秀，但一樣的大問題，鏡頭拉遠就讓人覺得不合邏輯，國中畢業的男生跟高材女生結婚，而石壩卻能接受？通常不會發生吧。</p>
<p>石議員不斷地刺激世界說，他爸不要讓世界這樣做，先聽他爸的，希望世界有著穩重的性格，但世界卻不願意一直接受刺激而生氣，這裡完美的揮發了世界的個性，甚至讓我覺得這裡有兩條劇情線的展開，讓我覺得這部戲好看了許多。</p>
<p>看的出來世界很愛老婆也對老婆很忠心，能為老婆能屈能伸，也不願意將老婆帶入他的賣毒計畫中，一心只想要守護著他的老婆，幫助他老婆，剷除他的所有敵人，也演出了沒有耐心的性格，這裡就跟他的設定一樣，國中畢業，沒有耐心可以讀下書，為了趕快接受到結果而用盡一切手段。</p>
<blockquote>
<p>議員提醒世界<br><img src="https://i.imgur.com/ap3za9J.png" alt=""></p>
</blockquote>
<h3 id="女生享受毒品的過程"><a href="#女生享受毒品的過程" class="headerlink" title="女生享受毒品的過程"></a>女生享受毒品的過程</h3><p>這裡真的莫名其妙，奇怪的音樂，就像想要告訴聽眾不要吸毒，在隱射著 W 飯店的女模一樣，雖然本身是好效果，但在這部電影宣導就向電視突然進廣告一樣令人厭煩，放個字幕轉下就好了，不要這麼硬要啦。</p>
<blockquote>
<p>男生給女生毒品後<br><img src="https://i.imgur.com/XpeHzH9.jpg" alt=""></p>
</blockquote>
<h3 id="世界想要殺掉男主角"><a href="#世界想要殺掉男主角" class="headerlink" title="世界想要殺掉男主角"></a>世界想要殺掉男主角</h3><p>由於男主角在監視器抓到了世界賣毒，因此抓住世界來工地福利社想來個人贓俱獲，但卻一無所有，加上新聞報導毒品的流串，讓世界必須在這裡下令殺害阿慶。</p>
<p>如果有看角頭二就知道，如果是那種目的式通常會讓殺手備感壓力，特別是第一次的人。</p>
<p>世界威脅其手下來進行殺害，此時男女主角正在暗巷中約會，這時男主角被圍毆，女主角也被爆打一頓，慘阿。</p>
<p>但這裡的賣點超棒，角頭浪流連最強的就是打鬥，怵目驚心，這不向劇情一樣可以用文字表述，只能夠用畫面、身體去記住，但是男女主角都沒有死，讓我好生氣！那些配角死的好冤阿QQ。</p>
<p>主角的光環太大往往會讓人出戲，建議改進。</p>
<blockquote>
<p>世界手下砍男主角<br><img src="https://i.imgur.com/NNSnDMF.jpg" alt=""></p>
</blockquote>
<h3 id="世界的手下被仁哥拷問"><a href="#世界的手下被仁哥拷問" class="headerlink" title="世界的手下被仁哥拷問"></a>世界的手下被仁哥拷問</h3><p>老樣子，怵目驚心。</p>
<p>坳手指的過程，拳打腳踢，男主角那個想要復仇的心，刻苦銘心，完全充滿了遏止了我想當 8+9 的心XD。</p>
<h3 id="男女主角的對手戲"><a href="#男女主角的對手戲" class="headerlink" title="男女主角的對手戲"></a>男女主角的對手戲</h3><p>本片我最不喜歡的地方。</p>
<p>鏡頭晃來晃去把我暈死了，想要理解劇情還必須看著鏡頭晃來晃去，完全不會想要理解劇情，不確定這裡導演為何要用此手法去演，希望我能夠去理解，因為我還沒有想到任何原因。</p>
<p>最後片尾演員進場，我上前發問也沒有給我一個答案，只說我們沒有討論到這個問題。</p>
<p>總之男生表現得還不錯，只帶一句<strong>你懂甚麼</strong>，充分顯現了一個沒讀過甚麼書，不容易溝通的表現，女主角則表演了女主角對於愛情的執著，拋棄掉理性的樣子，對白感人，就是鏡頭飄移讓我感到不適。</p>
<h3 id="世界中槍"><a href="#世界中槍" class="headerlink" title="世界中槍"></a>世界中槍</h3><p>世界，辛苦你了，你好可憐QQ。</p>
<p>從世界被開槍一樣也是打鬥的精華了，打鬥一直都是角頭最優秀的地方，男主角三方混戰這邊演得不錯，但我認為有理解力的觀眾可能會感到困惑，當下看可能反應不過來(包括我XD)，因為我們是上帝視角觀看，建議能夠用些簡單的手法輔述。</p>
<p>男主角一路追擊，小陶最後注射毒品，鼓起勇氣不斷向世界開槍，最終讓世界倒地，石議員最後去醫院看她(這裡是演員補述，電影沒有演到)，男主角過海去大陸。</p>
<p>莫名奇妙，明明是小陶打的為甚麼是男主角去大陸躲風聲，演的完整些會更好，這應該是一個武俠打鬥片不是一個劇情推理片，不應該放一堆模糊的片段讓觀眾去猜測阿。</p>
<h3 id="男女主角分手"><a href="#男女主角分手" class="headerlink" title="男女主角分手"></a>男女主角分手</h3><p>女主角躺在醫院，男主角去往大陸，紅猴來探望女主角，宗保告訴她分手並且請他理解，最後女主角痛哭，之後女主角在攝影展大展身手。</p>
<p>我認為其實沒有必要演到女主角在攝影展那段，可以補足其劇情而不是要刻意在這裡迎向劇情的高潮，前面的鋪陳都沒有弄得很完善阿！沒辦法帶入劇情…，這裡再放男主角(應該是虛擬)來看攝影展，看到自己的照片，讓這裡的劇情變得更加不明所以，讓人不得不對這片產生一個很明顯的問號，我開始完全不懂我到底看了甚麼。</p>
<h2 id="石壩與貴董的交談"><a href="#石壩與貴董的交談" class="headerlink" title="石壩與貴董的交談"></a>石壩與貴董的交談</h2><p>好啦，我猜這裡又有新外傳可以演吧，好煩，一堆破碎劇情。</p>
<p>石壩與貴董在這裡相談舊事，並且同意制裁世界，就像是很久沒見面的老朋友般，一樣熟悉的感覺。</p>
<p>特地演這齣，更加強大了我對破碎劇情，對這部戲的歡喜度又降低了。</p>
<h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>這裡中間的配樂我認為都不優，不好聽，沒有把台語的味道發揚光大，詞曲都沒有辦法擊中我心；並且劇情支離破碎，男主角的不死能力、男主角去往大陸時不明所以的劇情，特別是宗保那句<strong>你會來跟我搶角頭嗎？</strong>根本沒有演到，這裡放著回憶不會太怪嗎、女主角的病情、毒品事件只有演到中間就沒有再繼續。</p>
<p>一堆未完再續得劇情令我感到斐以所思，這是外傳，真的不考慮把劇情交代清楚嗎，導演擅長對於點進行發揮，那就讓劇情推演的慢且詳細，就像日劇一樣，這次的劇情雜而沒有條理，除非下次還有要演下集，但演下集也不應該放那麼多片段劇情！</p>
<p>演員打架、對白，都是設計漂亮的，且演員都有演到位，真的讚。</p>
<p>世界與石議員的劇情線比男女主角好太多，更 touch my heart。</p>
<p>最終，片尾是最好聽的。</p>
<p>電影結束後，演員親自感謝我們在第一周就觀看影片，我特地拍了演員們留念，最可惜的就是我詢問演員，男女吵架的對手戲那邊鏡頭為何特別晃則沒有一個好的回覆。</p>
<blockquote>
<p>片偉結束後，親眼看到演員<br><img src="https://i.imgur.com/PuCTPT8.jpg" alt=""></p>
</blockquote>
<p>如果要我硬說，我會認為這是一部爽片，看過就可以忘了，並沒有相當大的價值可以給後輩看。</p>
]]></content>
      <categories>
        <category>電影心得</category>
      </categories>
      <tags>
        <tag>人生旅途</tag>
        <tag>電影心得</tag>
        <tag>戰鬥類電影心得</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces 1480D2 - Painting the Array II (設計解題、數學推理)</title>
    <url>/2021/02/16/Codeforces/Codeforces%201480D2/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>給出一個陣列，我們可以把它放到另外兩個陣列 (A,B)，A,B 這兩個陣列計算元素是這樣計算的：</p>
<ul>
<li>陣列中如果周遭都是相同的數值就可以表示為一個元素，如 \((3,3,3) \) 就算一個、\((1,2,3)\) 就算是三個。</li>
<li>順序不可以交換，必須是一開始陣列的順序，透過給予 A or B 來讓 A and B 這兩個陣列元素最小，求這兩個 A,B 全部元素的數量</li>
</ul>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li>跳脫思考，不將重心思考放在如何把數字給這兩個陣列</li>
<li>思考放在如何讓重複的數字做到最大合併</li>
</ul>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>CF 的設計解題都是好題阿，往往都能啟發出我的好想法，或是透過他人的好想法來進行學習，真的有趣，需要多練習。</p>
<p>首先我們先將題目一開始的陣列進行壓縮，相同的重複數值合併成一個，定義此陣列 \(num\)</p>
<p>這題最好的方式就是將重心放在如何將所有相同的數字都放在一起，為了方便說明，我們一樣假設我們有兩個陣列 (A,B)，而他們陣列中最後的元素為 \(x,y\)，我們可以進行假設</p>
<ul>
<li>如果 \(num = x \ or \ num = y\)，這種情況當下不會多產生一個新元素</li>
<li>如果 \(num != x \ or \ num != y\)，那勢必會增加一個陣列新元素嗎？ <ul>
<li>如果這個數字在上次合併前沒有出現過，那一定會增加新元素</li>
<li>如果有出現過，則不會</li>
</ul>
</li>
</ul>
<p>合併是甚麼意思，看下面舉例。</p>
<h3 id="舉例"><a href="#舉例" class="headerlink" title="舉例"></a>舉例</h3><p>我們假設題目陣列為 \(1,2,3,1,2,2\)，壓縮後的 num 陣列為 \(1,2,3,1,2\)</p>
<p>我們一開始定義 A,B 兩個陣列，會依照順序給值，因此在 num 陣列給 \(1,2,3\) 應該要是這樣</p>
<ul>
<li>\(A = 1,3\)</li>
<li>\(B = 2\)</li>
</ul>
<p>接下來下一個 num 值是 1，這個時候問題來了。<br>我們其實可以做點操作，假如我們把 A 陣列的 3，給到 B 是不是就可以讓 num 的 1 放入 A 達到不產生元素的效果？對，沒問題，因此 A,B 陣列變了</p>
<ul>
<li>\(A = 1\)</li>
<li>\(B = 2,3\)</li>
</ul>
<p>此時 num 陣列中的素質為 2，我們還可以合併嗎？不行<br>為甚麼不能合併呢，因為我們前面已經進行了一次合併，num \(1,2,3,1\) 這邊我們已經進行了合併，我們不可以破壞上次的合併，否則會破壞題目陣列的順序姓，因此這邊勢必要加一元素。</p>
<p>但我們可以保留 A 的 1 與 B 的 3，這兩個可以被合併，因為他們是陣列最尾端，與他們合併並不會破壞其陣列順序姓。</p>
<ul>
<li>一個是因為進行合併而使得 A 陣列中的元素還是 1</li>
<li>另一個則是題目陣列中當前倒數第一個的數值</li>
</ul>
<p>透過此方式就能解出此題，用 map 紀錄哪些數字未合併但已被加入 A,B 陣列，如果下個數字是有在未合併中的數字時那就進行合併，如果還是一個未合併數字就讓答案加一。</p>
<h2 id="參考來源"><a href="#參考來源" class="headerlink" title="參考來源"></a>參考來源</h2><p><a href="https://blog.csdn.net/qq_46047971/article/details/113756394" target="_blank" rel="noopener">D2. Painting the Array II -  准准准准准菜鸡</a><br><a href="https://codeforces.com/blog/liouzhou_101" target="_blank" rel="noopener">Editorial of Codeforces Round #700 - liouzhou_101’s blog </a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>這題要是沒有<strong>准准准准准菜鸡</strong>的大力解說，我一定沒有辦法那麼快就想出這題，透過他在網路上的詳細解說讓我快速地學會此題，我要非常謝謝他！</p>
<p>希望我自己在解設計解題時都可以想到這些想法，那我在現實生活中一定會比這些不會寫 cf 的人更聰明、更加優秀。</p>
<p>希望大家都能夠快速理解，那是我的榮幸。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1000020</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, temp;</span><br><span class="line"><span class="keyword">int</span> a[MAXN]; <span class="comment">//原本題目陣列</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; num; <span class="comment">//壓縮的題目陣列</span></span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; mp; <span class="comment">//紀錄這些還沒合併的數字</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">cin</span> &gt;&gt; a[i]; <span class="comment">//輸入資料</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123; <span class="comment">//壓縮陣列</span></span><br><span class="line">        <span class="keyword">if</span>(a[i] == a[i<span class="number">-1</span>]) temp = a[i]; <span class="comment">//如果等於上次的，那就表示這邊可以再進行壓縮</span></span><br><span class="line">        <span class="keyword">else</span> num.push_back(a[i<span class="number">-1</span>]); <span class="comment">//不同了，所以放值</span></span><br><span class="line">    &#125;</span><br><span class="line">    num.push_back(a[n<span class="number">-1</span>]); <span class="comment">//最後的值一定要被加入，因為 for 沒有提到</span></span><br><span class="line">    <span class="comment">//for(int i = 0; i &lt; num.size(); i++) cout &lt;&lt; num[i] &lt;&lt; ' ';</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; '\n';</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num.size() ; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(mp[num[i]] == <span class="number">0</span>)&#123; <span class="comment">//又一個數字加入未合併數字中</span></span><br><span class="line">            mp[num[i]] = <span class="number">1</span>; <span class="comment">//標示被加入</span></span><br><span class="line">            ans++; <span class="comment">//答案 +1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            mp.clear(); <span class="comment">//合併了，因此要記錄新的合併</span></span><br><span class="line">            mp[num[i]] = <span class="number">1</span>; <span class="comment">//合併的數字</span></span><br><span class="line">            mp[num[i<span class="number">-1</span>]] = <span class="number">1</span>; <span class="comment">//原本當前題目壓縮陣列中最後一個元素</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>; <span class="comment">//輸出答案</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>設計解題</tag>
        <tag>程式解題</tag>
        <tag>Codeforces</tag>
        <tag>數學推理</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa11242 - Tour de France(水題)</title>
    <url>/2021/02/16/UVa/UVa11242/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>一個競速腳踏車由兩個齒輪與一條鏈子組成，鏈子則透過許多鏈輪組成，給你一些齒輪，並告訴妳這些齒輪的輪齒有多少，請幫忙選出兩個齒輪 (n/m)，n 是後輪、m 是前輪，定義為速率 \(d\)，要你找出兩個最大速率相除最大的數字。</p>
<p>最大速率有一些特別規定，如果有三種速度分別為 \(d_1, d_2 , d_3\)，排序為 \(d_1 &lt; d_2 &lt; d_3\)，那我們就不能拿 \(d_1 , d_2\) 來算最大速率，只能拿 \(d_1 \ and \ d_2 \) or \(d_2 \ and \ d_3 \) 進行相除。</p>
<p><a href="https://onlinejudge.org/index.php?option=onlinejudge&Itemid=8&page=show_problem&problem=2183" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li>學會理解英文會話題目</li>
<li>能看出此題如何運作</li>
</ul>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>其實這題不難，我們只要將全部的組合都嘗試一遍進行排序，找出相鄰的速率相除後的數字最大輸出即可。</p>
<p>需要注意的是 c++ <code>sort</code> 是由小到大，這點要特別注意。</p>
<h2 id="參考來源"><a href="#參考來源" class="headerlink" title="參考來源"></a>參考來源</h2><p><a href="https://gsourcecode.wordpress.com/2012/01/31/uva-11242/" target="_blank" rel="noopener">11242 – Tour de France - GSOURCECODE </a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>…，這題我寫了兩小時，完全思考錯 debug 方向，還以為是 cin 小數點的問題，一直在往這邊嘗試，直到找到了參考來源，互相比較後發現原來是我的 sort 排序完後，我自己會漏掉<strong>最後的一個數字</strong>去比較速率，現在改回來後，就好了很多，一次就 AC 啦！</p>
<p>題外話，往正確的 debug 方向走真的好難…，錯了都不知道。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;algorithm&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 20000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> F,R;</span><br><span class="line"><span class="keyword">double</span> f[MAXN], r[MAXN], num[MAXN]; <span class="comment">// f 前輪 r 後輪 num 速率</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"out.txt"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; F &gt;&gt; R &amp;&amp; F)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; F; i++) <span class="built_in">cin</span> &gt;&gt; f[i]; <span class="comment">//輸入資料</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; R; i++) <span class="built_in">cin</span> &gt;&gt; r[i]; <span class="comment">//輸入資料</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>; <span class="comment">//速率的最大長度</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; R; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; F; j++)&#123;</span><br><span class="line">                num[cnt++] = r[i] / f[j]; <span class="comment">//不斷交疊產生速率</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(num, num + cnt); <span class="comment">//排序</span></span><br><span class="line">        <span class="comment">//for(int i = 0; i &lt; cnt; i++ ) cout &lt;&lt; num[i] &lt;&lt; ' ';</span></span><br><span class="line">        <span class="comment">//cout &lt;&lt; '\n';</span></span><br><span class="line">        <span class="keyword">double</span> d, dmax = <span class="number">1</span>; <span class="comment">//dmax 是 1 是因為兩個數字一樣相比較最小會是 1，不會低於 1。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; cnt; i++)&#123; <span class="comment">//開始進行比較，找出兩個速率相差最大</span></span><br><span class="line">            <span class="keyword">if</span>(num[i] / num[i<span class="number">-1</span>] &gt;= dmax)&#123; <span class="comment">//如果 dmax 比較小</span></span><br><span class="line">                dmax = num[i] / num[i<span class="number">-1</span>]; <span class="comment">//替換成這兩個速率相差</span></span><br><span class="line">                <span class="comment">//cout &lt;&lt; "num is " &lt;&lt; num[i] &lt;&lt; ' ' &lt;&lt; num[i+1] &lt;&lt; '\n';</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; fixed &lt;&lt; setprecision(<span class="number">2</span>) &lt;&lt; dmax &lt;&lt; <span class="string">'\n'</span>; </span><br><span class="line">        <span class="comment">//輸出，題目要求小數點兩位，因此c++要這樣寫</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>水題</tag>
        <tag>UVa</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa1260 - Sales(LIS)</title>
    <url>/2021/02/16/UVa/UVa1260/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>有一家公司希望可以看今天的銷售金額比哪幾天高、等於，輸出哪幾天高的總和，如果前幾天是 \(20,30,40\)，那 30 那天的銷售金額就比前一天高，輸出 1；如果是 40 那天的銷售金額就輸出 2，大於前兩天的銷售金額，請輸出總和所有的銷售金額比哪些天高的天數並減一。</p>
<p><a href="https://onlinejudge.org/external/12/1260.pdf" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li>了解並學會 LIS</li>
<li>實踐 LIS</li>
<li><a href="https://theriseofdavid.github.io/2020/11/13/Explain_Algorithm/LIS/" target="_blank" rel="noopener">演算法知識 - Longest Increasing Subsequence 最長遞增子序列(時間複雜度 O(nlogn))</a></li>
</ul>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>這題就是簡單的 LIS，相信大家在看 uva 的題目時就能馬上知道這是 LIS，只需要學會 LIS 就能解出此題，但需要注意的是這題在相等時也要算入總和內，因此不可以使用 <code>lower_bound</code> 改使用 <code>upper_bound</code> 會更好！</p>
<h2 id="參考來源"><a href="#參考來源" class="headerlink" title="參考來源"></a>參考來源</h2><p><a href="https://theriseofdavid.github.io/2020/11/13/Explain_Algorithm/LIS/" target="_blank" rel="noopener">演算法知識 - Longest Increasing Subsequence 最長遞增子序列(時間複雜度 O(nlogn))</a><br><a href="http://web.ntnu.edu.tw/~algo/Subsequence.html" target="_blank" rel="noopener">演算法筆記 - Longest Increasing Subsequence</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>原本都是用比較麻煩的方式來寫，在師大的演算法筆記中發現了更棒的寫法，因此現在改用這種寫法認為會比之前更好寫!</p>
<p>也謝謝師大演算法可以讓我寫得更輕鬆如意，透過網路上教會我，是我網路上的老師！</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 5020</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[MAXN];</span><br><span class="line"><span class="keyword">int</span> T, n, len = <span class="number">0</span>, cur;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lis</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; b; <span class="comment">//用來產生 LIS 長度</span></span><br><span class="line">    b.push_back(a[<span class="number">0</span>]); <span class="comment">///先放入一個數值，以避免 b.back() 找不到值</span></span><br><span class="line">    <span class="keyword">int</span> sz = <span class="number">0</span>, temp; <span class="comment">//sz 為每個營收高於其它天的總和</span></span><br><span class="line">    <span class="comment">//temp 紀錄二分搜尋後找到的位置</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] &gt; b.back())&#123; <span class="comment">//如果現在這個數字大於此數列中最大的數字</span></span><br><span class="line">            sz += b.size(); <span class="comment">//表示今天大於其他天全部營收，直接加入 sz</span></span><br><span class="line">            b.push_back(a[i]); <span class="comment">//LIS push back</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            temp = upper_bound(b.begin(), b.end(), a[i]) - b.begin(); </span><br><span class="line">            <span class="comment">//二分搜尋，找到他適合的位置，前面數字比她小或相等，後面數字大</span></span><br><span class="line">            b.insert(b.begin()+temp , a[i]); <span class="comment">//插入她</span></span><br><span class="line">            sz += temp; <span class="comment">//sz 加上前面比她小的那些天數，注意，不需要 -1，因為 queue index 從 0 開始</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//debug</span></span><br><span class="line">            <span class="comment">//for(auto it: b) cout &lt;&lt; it &lt;&lt; ' ';</span></span><br><span class="line">            <span class="comment">//cout &lt;&lt; '\n';</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; "sz i is " &lt;&lt; sz &lt;&lt; '\n';</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sz;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"out.txt"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">cin</span> &gt;&gt; a[i]; <span class="comment">//輸入資料</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; lis() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>最長遞增子序列 Longest Increasing Subsequence</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa1103 - Ancient Messages(DFS)</title>
    <url>/2021/02/20/UVa/UVa1103/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>考古學家們給你一些古老文字，請你根據題目給你的資料進行判斷，這圖片有哪些文字，按照字母順序輸出，但你必須想辦法自己在古老文字中辨識古老文字。</p>
<p>題目給你的值是 16 位元的。<br>古老文字不會重疊、至少會有一個文字。</p>
<p><a href="https://onlinejudge.org/index.php?option=onlinejudge&Itemid=8&page=show_problem&problem=3544" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li>能夠理解題目英文</li>
<li>能找出題目文字輸出的規律性</li>
<li>了解 DFS</li>
</ul>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>難題，但不是難在該難的地方www，例如他要如何在題目資料中辨識文字呢，是按照文字中有幾個空白區段來辨識的…，沒有看別人的 blog 真的不會懂…，甚麼爛題目..。</p>
<p>特別還給他 16 位元來混淆大家的想法，這題真夠狠的，我都被他騙了 2 hr 的時間。</p>
<p>基本只有一個空格的是 W、兩個空格的是 A、三個空格是 K，以此類推 “WAKJSD”，而判斷空格的方式就是先將 16 位元先拆開來看</p>
<p>區塊定義：被 1 包圍的所有的 0。</p>
<h3 id="範例-A"><a href="#範例-A" class="headerlink" title="範例 A"></a>範例 A</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00010</span><br><span class="line">01101</span><br><span class="line">00010</span><br><span class="line">00000</span><br></pre></td></tr></table></figure>

<p>這樣的話就是 A，因為在 (4,2) 的 0，被 1 給包圍，因此答案是 A。</p>
<h3 id="範例-A-2"><a href="#範例-A-2" class="headerlink" title="範例 A-2"></a>範例 A-2</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00110</span><br><span class="line">01001</span><br><span class="line">00110</span><br><span class="line">00000</span><br></pre></td></tr></table></figure>

<p>這樣的話就是 A，因為 (3,2) 跟 (4,2)  都是 0， 1 給包圍，因此答案還是 A。</p>
<h3 id="範例-K"><a href="#範例-K" class="headerlink" title="範例 K"></a>範例 K</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">01111</span><br><span class="line">01010</span><br><span class="line">01111</span><br><span class="line">00000</span><br></pre></td></tr></table></figure>

<p>這樣的話就是 A，因為 (3,2) 跟 (5,2)  都是 0，但這兩個不是同個區塊，是被 1 分隔兩地，因此答案是，因此答案還是 K。</p>
<h3 id="重新整理"><a href="#重新整理" class="headerlink" title="重新整理"></a>重新整理</h3><p>因此我們可以知道，1 包圍很多 0 並且那些 0 都是不同的區塊時，越多區塊就是古老文字越多區塊的文字，像 D 就是有 6 個區塊，透過這樣推出。</p>
<p>沒有，這超難的…，在考大家聯想力..。</p>
<p>但現在我們可以知道了一件事，我們是要透過 1 包圍的區塊中判斷古老文字，因此我們先將 1 外圍的 0 全部都先表示成 2(有就是這些空格都是無意義，陪襯用)，接下來再判斷當我們走到 1 的使用開始搜尋外圍的 1 且當其中找到 0 時，就將那區塊全部都設為 2，表示已用過，並且記錄區塊，就可以判斷文字了！　</p>
<p>因此判斷的方式如下:</p>
<ul>
<li>先寫一個 DFS 將外圍的 0 都消除</li>
<li>再來遍地搜尋 1，但找到 1 就開始進行 DFS</li>
<li>如果從第二點的 DFS 搜尋到 0，表示這裡有區塊</li>
<li>將那些區塊全部都設為 2，因為都是同個區塊，實作用 DFS</li>
<li>根據幾個區塊而輸出文字，這樣即可。</li>
</ul>
<h2 id="參考來源"><a href="#參考來源" class="headerlink" title="參考來源"></a>參考來源</h2><p>我的朋友 - 陳立瑋</p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>這題真的很機車…，我想這題原本應該是給比賽用的才讓大家去猜測，但是我認為那個時候的大家應該也不知道吧…，這都快比 CF 的設計解題難 10 倍且還是難在非重要的地方，我認為很難過QQ，因為我就這樣被耍了兩個小時。</p>
<p>總之，訓練自己的英文能力很重要，雖然這題很機車，但是他也讓我大概理解影片解碼的方式了，謝謝他!</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> boardY 52 * 4 <span class="comment">// y 邊界，因為題目是 16 進位，但是我們要把它拆成 2 進位，才能分隔區塊</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> W, H, kase=<span class="number">0</span>, space;</span><br><span class="line"><span class="keyword">int</span> graph[<span class="number">202</span>][boardY + <span class="number">20</span>]; <span class="comment">//地圖</span></span><br><span class="line"><span class="built_in">string</span> word = <span class="string">"WAKJSD"</span>, ans, temp; <span class="comment">// word[i] 有 i 個區塊的象形文字, ans 答案</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs_white</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> w)</span></span>&#123; <span class="comment">//把當前空白區塊都掃描，用於一開始的去除外圍白色與去除 1 裡面的白色區塊</span></span><br><span class="line">    <span class="keyword">if</span>(h &gt; H + <span class="number">2</span>|| w &gt; boardY || h &lt; <span class="number">0</span> || w &lt; <span class="number">0</span>) <span class="keyword">return</span>; <span class="comment">//到邊界就不在繼續</span></span><br><span class="line">    <span class="keyword">if</span>(graph[h][w] != <span class="number">0</span>) <span class="keyword">return</span>; <span class="comment">//此座標不是白色就不繼續</span></span><br><span class="line">    graph[h][w] = <span class="number">2</span>; <span class="comment">//視為已用過</span></span><br><span class="line">    dfs_white(h + <span class="number">1</span>, w); <span class="comment">//搜尋 4 個方向</span></span><br><span class="line">    dfs_white(h - <span class="number">1</span>, w);</span><br><span class="line">    dfs_white(h, w + <span class="number">1</span>);</span><br><span class="line">    dfs_white(h, w - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs_black</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> w)</span></span>&#123; <span class="comment">//沿著 1 搜尋，只要碰到 0 就表示裡面有區塊，跳至 dfs_white 將那區塊全部掃描</span></span><br><span class="line">    <span class="keyword">if</span>(h &gt; H + <span class="number">2</span> || w &gt; boardY || h &lt; <span class="number">0</span> || w &lt; <span class="number">0</span>) <span class="keyword">return</span>; <span class="comment">//到邊界就不在繼續</span></span><br><span class="line">    <span class="keyword">if</span>(graph[h][w] == <span class="number">1</span>)&#123; <span class="comment">//表示此座標是 1</span></span><br><span class="line">        graph[h][w] = <span class="number">2</span>; <span class="comment">//視為已用過</span></span><br><span class="line">        dfs_black(h + <span class="number">1</span>, w); <span class="comment">//搜尋 4 個方向繼續沿著 1 搜尋</span></span><br><span class="line">        dfs_black(h - <span class="number">1</span>, w);</span><br><span class="line">        dfs_black(h, w + <span class="number">1</span>);</span><br><span class="line">        dfs_black(h, w - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(graph[h][w] == <span class="number">0</span>)&#123; <span class="comment">//表示這邊有區塊</span></span><br><span class="line">        space++; <span class="comment">//區塊++</span></span><br><span class="line">        <span class="comment">//cout &lt;&lt; "space is " &lt;&lt; space &lt;&lt; '\n';</span></span><br><span class="line">        dfs_white(h, w); <span class="comment">//將那區塊全部掃描一次</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; "dfs_black " &lt;&lt; h &lt;&lt; ' ' &lt;&lt; w &lt;&lt; '\n';</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">()</span></span>&#123; <span class="comment">//debug 用</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; H + <span class="number">2</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">5</span>; j &lt;= (W + <span class="number">1</span>) * <span class="number">4</span>; j++) <span class="built_in">cout</span> &lt;&lt; graph[i][j] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="comment">//freopen("out.txt", "w", stdout);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; H &gt;&gt; W &amp;&amp; H &amp;&amp; W)&#123; <span class="comment">//輸入 H,W</span></span><br><span class="line">        <span class="built_in">memset</span>(graph, <span class="number">0</span>, <span class="keyword">sizeof</span>(graph)); <span class="comment">//重置，避免影響這次測資</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= H; i++)&#123; <span class="comment">//輸入資料</span></span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; temp;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; W; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">isdigit</span>(temp[j])) space = temp[j] - <span class="string">'0'</span>; </span><br><span class="line">                <span class="comment">//16 進位判斷，前 9 個數字都跟 10 進位相同</span></span><br><span class="line">                <span class="keyword">else</span> space = temp[j] - <span class="string">'a'</span> + <span class="number">10</span>; <span class="comment">//將 16 進位轉成 10 進位</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) graph[i][(j + <span class="number">1</span>) * <span class="number">4</span> + <span class="number">4</span> - k] = (<span class="keyword">int</span>) <span class="number">1</span> &amp; (space &gt;&gt; k);</span><br><span class="line">                <span class="comment">//將 10 進位轉 2 進位，由於原本是 16 進位，因此最大只會有 4 個數字(位元)，</span></span><br><span class="line">                <span class="comment">// 1 &amp; (space &gt;&gt; k) 則是判斷那個數字(位元)原本是 1 還是 0，由於只要判斷 1 位元，並不要把其他位元牽扯，因此 &amp; 1。</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs_white(<span class="number">0</span>, <span class="number">0</span>); <span class="comment">//先將外圍的 0 先消除</span></span><br><span class="line">        <span class="comment">//debug();</span></span><br><span class="line">        ans = <span class="string">""</span>; <span class="comment">//答案清除</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">202</span>; i++)&#123; <span class="comment">//掃描，找出 1</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; boardY; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(graph[i][j] == <span class="number">1</span>)&#123; <span class="comment">//找到 1</span></span><br><span class="line">                    space = <span class="number">0</span>; <span class="comment">//將區塊設為 0</span></span><br><span class="line">                    dfs_black(i, j); <span class="comment">//沿著 1 搜尋</span></span><br><span class="line">                    ans += word[space]; <span class="comment">//幾個區塊就輸出相對應的象形文字</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(ans.begin(), ans.end()); <span class="comment">//字典排序</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Case "</span> &lt;&lt; ++kase &lt;&lt; <span class="string">": "</span>; <span class="comment">//說明這是第幾個 case</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>UVa</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa11094 - Continents(DFS)</title>
    <url>/2021/02/21/UVa/UVa11094/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>有一個國王喜歡佔領領土，給你一張地圖，這張地圖左右邊是有相同連結的！請你找出除了國王所在的地方外，最大的一片土地，國王要去征戰他</p>
<p>提醒，由於國家的地圖沒有統一標準，因此陸地或是海洋的標示都不相同，但會給你國王所在地。</p>
<p><a href="https://onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=2035" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="觀念重點"><a href="#觀念重點" class="headerlink" title="觀念重點"></a>觀念重點</h2><ul>
<li>理解題目英文</li>
<li>要讓 dfs 搜尋可以左邊邊界能與右邊邊界相通</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>這題不難，只需要在 dfs 時特別判斷，碰到左右邊界時會連接到另一邊的邊界即可。</p>
<p>然後有一個小技巧，雖然你不知道陸地或海洋的字元，但是因為國王永遠都在陸地，所以可以假設國王所在地是陸地，那個字元就是陸地字元，那麼另外一個字元就是海洋，然後 DFS 即可。</p>
<h2 id="參考來源"><a href="#參考來源" class="headerlink" title="參考來源"></a>參考來源</h2><p><a href="https://hackmd.io/@txya900619/Uva11094" target="_blank" rel="noopener">Uva11094 - Continents - txya900619</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>這題沒有很難，但我原本想說我簡單快速看題目，結果出來的是 WA，在我百思不得其解時問了力瑋，他跟我說明這題題目大意，我才又認真地回去看發現自己一堆東西都漏看…，真不該相信自己的閱讀能力..。</p>
<p>可以用國王的位置當作陸地的字元這點是力瑋告訴我的，不然我一開始還真沒有想到，力瑋好聰明</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 25 <span class="comment">//最大值</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BX 20 <span class="comment">// 題目 X 最大邊界</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BY 20 <span class="comment">// 題目 Y 最大邊界</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> N, M, X, Y; <span class="comment">//題目的輸入</span></span><br><span class="line"><span class="keyword">char</span> graph[MAXN][MAXN]; <span class="comment">//題目的地圖 </span></span><br><span class="line"><span class="keyword">char</span> land, water; <span class="comment">//陸地 與 水 的字元</span></span><br><span class="line"><span class="built_in">string</span> s; <span class="comment">//輸入題目陣列元素用</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123; <span class="comment">//用來搜尋陸地區塊</span></span><br><span class="line">    <span class="keyword">if</span>(x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span> || x &gt;= N || y &gt;= M) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//超出邊界</span></span><br><span class="line">    <span class="keyword">if</span>(graph[x][y] != land) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//如果這塊不是未被記錄的陸地就 return </span></span><br><span class="line">    graph[x][y] = <span class="string">'`'</span>; <span class="comment">//修改為已用過，由於題目的字元並不會用到此字元，因此改為她</span></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">1</span>; <span class="comment">//表示這塊是陸地，所以必定會有 1</span></span><br><span class="line">    cnt += dfs(x<span class="number">-1</span>, y); <span class="comment">//四個方向搜尋</span></span><br><span class="line">    cnt += dfs(x+<span class="number">1</span>, y);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(y == M<span class="number">-1</span>) cnt += dfs(x, <span class="number">0</span>); <span class="comment">//搜尋到右邊界，下次搜尋左邊界</span></span><br><span class="line">    <span class="keyword">else</span> cnt += dfs(x, y+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(y == <span class="number">0</span>) cnt += dfs(x,M<span class="number">-1</span>); <span class="comment">//搜尋到左邊界，下次搜尋右邊界</span></span><br><span class="line">    <span class="keyword">else</span> cnt += dfs(x, y<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> cnt; <span class="comment">//回傳陸地區塊</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">()</span></span>&#123; <span class="comment">//debug 用</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; M; j++)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; graph[i][j] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"out.txt"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M)&#123; <span class="comment">//輸入資料</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; M; j++) graph[i][j] = s[j];</span><br><span class="line">            <span class="comment">//注意這裡的 s[j]，不是 s[i]</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>; <span class="comment">//最大陸地</span></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; X &gt;&gt; Y;</span><br><span class="line">        land = graph[X][Y]; <span class="comment">//判斷是 land 的字元</span></span><br><span class="line">        dfs(X, Y);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123; <span class="comment">//遍地走訪</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; M; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(graph[i][j] == land) ans = max(ans, dfs(i, j));</span><br><span class="line">                <span class="comment">//如果此點有陸地，就全部搜尋看最大區塊是否有比 ans 大，有就更換答案</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//debug();</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>; <span class="comment">//輸出答案</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>UVa</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa11953 - Battleships(DFS)</title>
    <url>/2021/02/21/UVa/UVa11953/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>大家有玩過 Battleships game 嗎? 用兩張紙畫，目標是要擊沉對手的所有船艦，每一艘船艦都是 1 * N 大小的，要全部都被擊中就算輸了</p>
<p>題目是給你一張圖，請你判斷還有哪些戰艦還沒有被擊沉，被擊中並不包含擊沉</p>
<p><a href="https://onlinejudge.org/index.php?option=onlinejudge&Itemid=8&page=show_problem&problem=3104" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li>理解英文題目</li>
<li>DFS 應用</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>這題不難，學會 DFS 後，只要碰到非 ‘.’ 的格子，就進行 DFS 只要 DFS 中有遇到 ‘x’ 就表示這艘船還沒有被完全擊沉就加一</p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>簡單，開始慢慢學會，也慢慢改變自己的程式碼風格，使其更好閱讀</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 120</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> T, N, kase = <span class="number">0</span>; <span class="comment">//kase 輸出第幾個測資</span></span><br><span class="line"><span class="keyword">char</span> graph[MAXN][MAXN]; <span class="comment">//題目的地圖</span></span><br><span class="line"><span class="built_in">string</span> s; <span class="comment">//輸入題目資料用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123; <span class="comment">//搜尋 DFS，判斷這區塊有沒有還存活的戰艦</span></span><br><span class="line">    <span class="keyword">if</span>(x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span> || x &gt;= N || y &gt;= N) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//超出邊界</span></span><br><span class="line">    <span class="keyword">if</span>(graph[x][y] == <span class="string">'.'</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//碰到海洋</span></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>; <span class="comment">//表示還有幾個地方沒有被擊中</span></span><br><span class="line">    <span class="keyword">if</span>(graph[x][y] == <span class="string">'x'</span>) cnt += <span class="number">1</span>; <span class="comment">//表示這地方沒有被擊中</span></span><br><span class="line">    graph[x][y] = <span class="string">'.'</span>; <span class="comment">//算過因此，表示為海洋</span></span><br><span class="line">    cnt += dfs(x<span class="number">-1</span>, y); <span class="comment">//四個方向</span></span><br><span class="line">    cnt += dfs(x+<span class="number">1</span>, y);</span><br><span class="line">    cnt += dfs(x, y<span class="number">-1</span>);</span><br><span class="line">    cnt += dfs(x, y+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> cnt; <span class="comment">//回傳有幾個地方還沒被擊中</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">()</span></span>&#123; <span class="comment">//debug 用</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++) <span class="built_in">cout</span> &lt;&lt; graph[i][j] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"out.txt"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; N;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123; <span class="comment">//輸入資輛</span></span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++) graph[i][j] = s[j];</span><br><span class="line">            <span class="comment">//注意這裡的 s[j]，不是 s[i]</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>; <span class="comment">//幾艘還在</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123; <span class="comment">//遍地搜尋</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(graph[i][j] != <span class="string">'.'</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(dfs(i, j) != <span class="number">0</span>) ans++; <span class="comment">//如果 != 0 就表示還有地方沒有被擊中，因此戰艦+1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Case "</span> &lt;&lt; ++kase &lt;&lt; <span class="string">": "</span>; <span class="comment">//輸出答案</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>UVa</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa722 - Lakes(DFS)</title>
    <url>/2021/02/20/UVa/UVa722/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>有一張地圖，我們會給你一個 x,y 座標，請你幫我們找出以此座標為基準、陸地為邊界擴大搜尋的水有幾格？</p>
<p><a href="https://onlinejudge.org/index.php?option=onlinejudge&Itemid=8&page=show_problem&problem=663" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li>學會理解英文會話題目</li>
<li>DFS 的應用</li>
<li>如何配合題目輸入資料輸入</li>
</ul>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>這題是簡單的 DFS 分析，其實應該是要使用 BFS 會更好些，避免遞迴崩潰的問題，但因為題目的地圖部會不會超過 \(99 * 99\)。</p>
<h2 id="參考來源"><a href="#參考來源" class="headerlink" title="參考來源"></a>參考來源</h2><p><a href="https://hackmd.io/@txya900619/Uva772" target="_blank" rel="noopener">Uva722 - Lakes txya900619 </a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>這題簡單複習 DFS，加強自己的敏感度。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。 </p>
<p>注意，為了題目好寫，我將 0 設為陸地，1 設為水</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 120</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> graph[MAXN][MAXN]; <span class="comment">//地圖</span></span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>, M, a, b, flag = <span class="number">1</span>; <span class="comment">//cnt 計算水的數量、flag 判斷 output 輸出 '\n'</span></span><br><span class="line"><span class="built_in">string</span> temp; <span class="comment">//用來輸入題目的地圖位置</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span> || x &gt; <span class="number">100</span> || y &gt; <span class="number">100</span>) <span class="keyword">return</span>; <span class="comment">//判斷邊界</span></span><br><span class="line">    <span class="keyword">if</span>(graph[x][y] == <span class="number">0</span>) <span class="keyword">return</span>; <span class="comment">//碰到陸地返回</span></span><br><span class="line">    graph[x][y] = <span class="number">0</span>; <span class="comment">//這邊的水被設為陸地，因為被記錄過</span></span><br><span class="line">    cnt++; <span class="comment">//增加計算水的樹木</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; "cnt x y " &lt;&lt; cnt &lt;&lt; ' ' &lt;&lt; x &lt;&lt; ' ' &lt;&lt; y &lt;&lt; '\n';</span></span><br><span class="line">    dfs(x<span class="number">-1</span>, y); <span class="comment">//四個方向進行搜尋</span></span><br><span class="line">    dfs(x+<span class="number">1</span>, y);</span><br><span class="line">    dfs(x, y<span class="number">-1</span>);</span><br><span class="line">    dfs(x, y+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123; <span class="comment">//debug 輸出用</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">100</span>; j++) <span class="built_in">cout</span> &lt;&lt; graph[i][j] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"out.txt"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; M;</span><br><span class="line">    <span class="keyword">while</span>(M--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b; <span class="comment">//輸入要查詢的座標</span></span><br><span class="line">        <span class="built_in">cin</span>.ignore(); <span class="comment">//這時候 cin 在 b 的尾端因此要 cin.ignore 來讓他直接指針指到下一個字元的前面。</span></span><br><span class="line">        <span class="built_in">memset</span>(graph, <span class="number">0</span>, <span class="keyword">sizeof</span>(graph)); <span class="comment">//重新整理，以免讓過去資料影響現在</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>; <span class="comment">//表示輸入地圖到底幾行</span></span><br><span class="line">        <span class="keyword">while</span>(getline(<span class="built_in">cin</span>,temp) &amp;&amp; temp != <span class="string">""</span>)&#123; <span class="comment">//判斷是否有資料，沒有就是 temp == ""</span></span><br><span class="line">            <span class="comment">//cout &lt;&lt; temp &lt;&lt; '\n';</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; temp.length(); j++) graph[i][j] = (temp[j] - <span class="string">'0'</span>) ^ <span class="number">1</span>; </span><br><span class="line">            <span class="comment">//輸入資料，後面 ^ 1，這是方便運算， 0 ^ 1 = 1 就可以表示水</span></span><br><span class="line">            <span class="comment">//in my code 1 is water, 0 is land</span></span><br><span class="line">            i++; <span class="comment">//換下行輸入</span></span><br><span class="line">        &#125;</span><br><span class="line">        cnt = <span class="number">0</span>; <span class="comment">//重置計算水的數目</span></span><br><span class="line">        <span class="comment">//print();</span></span><br><span class="line">        dfs(a<span class="number">-1</span>, b<span class="number">-1</span>); <span class="comment">//由於我們題目 index 從 0 計算，因此 a, b 都減一</span></span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="number">1</span> )&#123; <span class="comment">//這時候不需要中間空一行，因為是答案第一筆</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; cnt &lt;&lt; <span class="string">'\n'</span>; <span class="comment">//輸出計算的水量</span></span><br><span class="line">            flag = <span class="number">0</span>; <span class="comment">//表示已經不是答案第一筆</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span> &lt;&lt; cnt &lt;&lt; <span class="string">'\n'</span>; <span class="comment">//現在開始需要</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>UVa</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa758 - The Same Game(DFS)</title>
    <url>/2021/02/21/UVa/UVa758/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>一個小遊戲(類似於 candy crush)，目標是拿到最大分，規則與分數如下：</p>
<ul>
<li>有三種顏色的石頭，只要有三顆相同顏色的石頭在一起就可以被消除掉</li>
<li>如果石頭有被消除掉，當前的格子為空，那上面的石頭會替補上來(column)</li>
<li>如果有一整排(column)為空，那將右邊的那些石頭全部都往左移一排(column)</li>
<li>分數計算是消掉的石頭(m) \((m-2) ^ 2\)</li>
<li>如果全部的石頭都被消去就多獲得 1000 分</li>
</ul>
<p>一個好的策略是從左下底端開始尋找，找出有最大堆顏色的石頭將它們消去，不斷重複至不能消除<br>必須要輸出如何消除、總共分數、剩下幾顆。</p>
<p><a href="https://onlinejudge.org/index.php?option=onlinejudge&Itemid=8&page=show_problem&problem=699" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="觀念重點"><a href="#觀念重點" class="headerlink" title="觀念重點"></a>觀念重點</h2><ul>
<li>理解題目英文</li>
<li>這題屬於複雜操作題，腦袋清晰地寫</li>
<li>需要不斷反覆除錯</li>
</ul>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>麻煩的題目…，寫這題需要高度的專心力與注意力才可以把這題寫好…。</p>
<p>這題不難，就是依照題目的要求直接暴力解即可，不太需要想甚麼優化的問題，測資並不大。</p>
<p>題外話：我倒是花了一堆時間在想要怎麼把程式碼精簡，最終還是放棄QQ。</p>
<h2 id="參考來源"><a href="#參考來源" class="headerlink" title="參考來源"></a>參考來源</h2><p><a href="https://hackmd.io/@txya900619/Uva758" target="_blank" rel="noopener">Uva758 - The Same Game - txya900619</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>這題真的夠了..，一年寫一次這種題目就好了，我都想稱他為麻煩大題了QQ，我寫完後硬是讓自己逃避了 3,4 hr 再來 debug 這題，很怕有大錯讓自己要重改之類的RRRR。</p>
<p>總之，希望自己的程式能力速度可以變快。</p>
<p>透過學習立委的程式碼，讓我覺得自己變聰明了些。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。 </p>
<p>程式碼很長，希望大家都能專心QQ。</p>
<p>hash 模式<br>R = 1<br>G = 2<br>B = 3<br>消除的石頭(0) = 0;</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BX 10 <span class="comment">// 題目 X 最大邊界</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BY 15 <span class="comment">// 題目 Y 最大邊界</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> extra 5 <span class="comment">//擴增陣列，以防超出</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> graph[BX+extra][BY+extra], visit[BX+extra][BY+extra]; </span><br><span class="line"><span class="comment">//graph 遊戲的圖 visit 判斷有沒有走過，用於一開始的搜尋</span></span><br><span class="line"><span class="keyword">int</span> n, kase = <span class="number">0</span>; <span class="comment">//kase 輸出當前第幾測資</span></span><br><span class="line"><span class="built_in">string</span> s; <span class="comment">//輸入題目陣列元素用</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; mp; <span class="comment">// char hash 成 int</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">char</span>&gt; mp2; <span class="comment">// int hash 成 char</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs_search</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> value)</span></span>&#123; <span class="comment">//用來搜尋同樣顏色的石頭最大面積</span></span><br><span class="line">    <span class="keyword">if</span>(x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span> || x &gt; BX || y &gt; BY) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//超出邊界</span></span><br><span class="line">    <span class="keyword">if</span>(visit[x][y] == <span class="number">1</span> || graph[x][y] != value) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//已被走訪過 或 不同顏色石頭</span></span><br><span class="line"></span><br><span class="line">    visit[x][y] = <span class="number">1</span>; <span class="comment">//走訪過</span></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">1</span>; <span class="comment">//最大面積，還沒往其他地方探索，因此只有自己所以 1</span></span><br><span class="line">    cnt += dfs_search(x<span class="number">-1</span>, y, value); <span class="comment">//往四個地方進行走訪，value 是一開始搜尋的石頭顏色</span></span><br><span class="line">    cnt += dfs_search(x+<span class="number">1</span>, y, value);</span><br><span class="line">    cnt += dfs_search(x, y<span class="number">-1</span>, value);</span><br><span class="line">    cnt += dfs_search(x, y+<span class="number">1</span>, value);</span><br><span class="line">    <span class="keyword">return</span> cnt; <span class="comment">//回傳最大面積</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs_remove</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> value)</span></span>&#123; <span class="comment">//用來移除石頭，在找到最大面積石頭時使用</span></span><br><span class="line">    <span class="keyword">if</span>(x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span> || x &gt; BX || y &gt; BY) <span class="keyword">return</span>; <span class="comment">//超出邊界</span></span><br><span class="line">    <span class="keyword">if</span>(graph[x][y] != value) <span class="keyword">return</span>; <span class="comment">//顏色不同石頭</span></span><br><span class="line">    graph[x][y] = <span class="number">0</span>; <span class="comment">//移除，因此變零</span></span><br><span class="line">    dfs_remove(x<span class="number">-1</span>, y, value); <span class="comment">//四個方向移除</span></span><br><span class="line">    dfs_remove(x+<span class="number">1</span>, y, value);</span><br><span class="line">    dfs_remove(x, y<span class="number">-1</span>, value);</span><br><span class="line">    dfs_remove(x, y+<span class="number">1</span>, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span></span>&#123; <span class="comment">//將消除的石頭位置放上新石頭</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>; <span class="comment">//k 用來判斷位置</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; BX; i++)&#123; <span class="comment">//rule 1 題目大意的規則 2</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; BY; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(graph[i][j] == <span class="number">0</span>)&#123; <span class="comment">//表示這裡有被移除的石頭</span></span><br><span class="line">                k = i+<span class="number">1</span>; <span class="comment">//要跟上面沒有被移除的石頭的 x index </span></span><br><span class="line">                <span class="keyword">while</span>(k &lt; BX)&#123; <span class="comment">//如果沒有超出邊界，就繼續</span></span><br><span class="line">                    <span class="keyword">if</span>(graph[k][j] != <span class="number">0</span>)&#123; <span class="comment">//index k 的石頭沒有被消除</span></span><br><span class="line">                        swap(graph[i][j], graph[k][j]); <span class="comment">//那就交換</span></span><br><span class="line">                        <span class="keyword">break</span>; <span class="comment">// 消除成功，所以退出</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    k++; <span class="comment">//沒有找到，所以 k++</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//至於為甚麼要這樣找，不是直接跟上一個交換?</span></span><br><span class="line">                <span class="comment">//因為有可能上面三個都被移除，那移除石頭交換本身沒意義</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//注意，這裡是將 y index 放在外迴圈</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; BY; j++)&#123; <span class="comment">//rule2 題目大意的規則 3</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>; <span class="comment">//sum 用來判斷那行 column 是否都是空的</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; BX; i++) sum += graph[i][j]; </span><br><span class="line">        <span class="comment">//因為 hash 後的數值都大於 1，因此如果等於 0 一定都沒有</span></span><br><span class="line">        <span class="keyword">if</span>(sum == <span class="number">0</span>)&#123;</span><br><span class="line">            k = j+<span class="number">1</span>; <span class="comment">//用來交換的 index </span></span><br><span class="line">            <span class="keyword">while</span>(k &lt; BY)&#123;  <span class="comment">//如果沒有超出邊界，就繼續</span></span><br><span class="line">                <span class="keyword">if</span>(graph[<span class="number">0</span>][k] != <span class="number">0</span>)&#123; <span class="comment">//index k 的石頭沒有被消除</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; BX; i++) swap(graph[i][j], graph[i][k]);</span><br><span class="line">                    <span class="comment">//整行交換</span></span><br><span class="line">                    <span class="keyword">break</span>;  <span class="comment">// 消除成功，所以退出</span></span><br><span class="line">                &#125;</span><br><span class="line">                k++; <span class="comment">//沒有找到，所以 k++</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visit_debug</span><span class="params">()</span></span>&#123; <span class="comment">//debug 用</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = BX<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= BY<span class="number">-1</span>; j++) <span class="built_in">cout</span> &lt;&lt; visit[i][j] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">graph_debug</span><span class="params">()</span></span>&#123; <span class="comment">//debug 用</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = BX<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= BY<span class="number">-1</span>; j++) <span class="built_in">cout</span> &lt;&lt; mp2[graph[i][j]] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"out.txt"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCLA</span></span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    mp[<span class="string">'R'</span>] = <span class="number">1</span>; mp[<span class="string">'G'</span>] = <span class="number">2</span>; mp[<span class="string">'B'</span>] = <span class="number">3</span>; <span class="comment">//hash </span></span><br><span class="line">    mp2[<span class="number">1</span>] = <span class="string">'R'</span>; mp2[<span class="number">2</span>] = <span class="string">'G'</span>; mp2[<span class="number">3</span>] = <span class="string">'B'</span>; mp2[<span class="number">0</span>] = <span class="string">'0'</span>; <span class="comment">//hash </span></span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Game "</span> &lt;&lt; ++kase &lt;&lt; <span class="string">":\n\n"</span>; <span class="comment">//輸出當前 case </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = BX<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--)&#123; <span class="comment">//輸入資料</span></span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; BY; j++) graph[i][j] = mp[s[j]]; </span><br><span class="line">            <span class="comment">//注意這裡的 s[j]，不是 s[i]</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, score, step = <span class="number">1</span>, remain = BX*BY; </span><br><span class="line">        <span class="comment">//ans 答案 score 當前分數 step 移動第幾次 remain 還有幾個石頭沒有被消除</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123; <span class="comment">//不斷輪迴，嘗試消除石頭</span></span><br><span class="line">            <span class="keyword">int</span> block = <span class="number">0</span>, max_block = <span class="number">0</span>, mx, my; </span><br><span class="line">            <span class="comment">//block 當前區塊 max_block 最大區塊 mx my 最大區塊的 x,y</span></span><br><span class="line">            <span class="built_in">memset</span>(visit, <span class="number">0</span>, <span class="keyword">sizeof</span>(visit)); <span class="comment">//重設為 0</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; BY; j++)&#123; <span class="comment">//對每一個石頭進行搜尋</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; BX; i++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(visit[i][j] == <span class="number">0</span> &amp;&amp; graph[i][j] != <span class="number">0</span>) block = dfs_search(i, j, graph[i][j]);</span><br><span class="line">                    <span class="comment">//如果這個石頭沒有被搜尋，就 dfs 這邊的石頭</span></span><br><span class="line">                    <span class="keyword">if</span>(max_block &lt; block)&#123; <span class="comment">//搜尋的區塊比之前搜尋的還大</span></span><br><span class="line">                        max_block = block;</span><br><span class="line">                        mx = i; my = j;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//visit_debug();</span></span><br><span class="line">            <span class="comment">//cout &lt;&lt; "max_block " &lt;&lt; max_block &lt;&lt; '\n';</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(max_block &lt; <span class="number">2</span>) <span class="keyword">break</span>; <span class="comment">//如果搜尋到的最大區塊 &lt; 2 表示沒有辦法在消除，就離開迴圈</span></span><br><span class="line">            remain -= max_block; <span class="comment">//減掉最大的區塊</span></span><br><span class="line">            score = (max_block - <span class="number">2</span>) * (max_block - <span class="number">2</span>); <span class="comment">//計算這次分數</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Move "</span>&lt;&lt; step++ &lt;&lt; <span class="string">" at ("</span> &lt;&lt; mx+<span class="number">1</span> &lt;&lt; <span class="string">","</span> &lt;&lt; my+<span class="number">1</span> &lt;&lt; \</span><br><span class="line">             <span class="string">"): removed "</span> &lt;&lt; max_block &lt;&lt; <span class="string">" balls of color "</span>&lt;&lt; mp2[graph[mx][my]] &lt;&lt; <span class="string">", got "</span> &lt;&lt; score &lt;&lt; <span class="string">" points.\n"</span>;</span><br><span class="line">            <span class="comment">//輸出這次步驟，這裡輸出顏色用 mp2</span></span><br><span class="line">            ans += score; <span class="comment">//加上這次分數</span></span><br><span class="line">            dfs_remove(mx, my, graph[mx][my]); <span class="comment">//移除最大區塊的石頭</span></span><br><span class="line">            refresh(); <span class="comment">//將題目大意的規則 2 and 3 重整一次</span></span><br><span class="line">            <span class="comment">//graph_debug(); //debug</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(remain == <span class="number">0</span>) ans += <span class="number">1000</span>; <span class="comment">//沒有剩下的石頭可以拿到 1000 分</span></span><br><span class="line">        <span class="comment">//輸出最後資訊</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Final score: "</span> &lt;&lt; ans &lt;&lt; <span class="string">", with "</span> &lt;&lt; remain &lt;&lt; <span class="string">" balls remaining.\n"</span>;</span><br><span class="line">        <span class="keyword">if</span>(n != <span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>; <span class="comment">//最後一個不斷行兩次，因為題目要求間隔斷行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>








]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>UVa</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>2021/01/29 北科大學生夜衝北海岸</title>
    <url>/2021/02/22/life_experence/north_coast_trip_with_college_friends/</url>
    <content><![CDATA[<h2 id="說明"><a href="#說明" class="headerlink" title="說明"></a>說明</h2><blockquote>
<p>跟大學程式設計社團的朋友們一起去北海岸看日出、夜衝。<br>有紹宇、力瑋、天佑、洸明</p>
</blockquote>
<a id="more"></a>

<h2 id="前情概要"><a href="#前情概要" class="headerlink" title="前情概要"></a>前情概要</h2><p>在 1 月 29 日之前我一直很想要去白沙灣看日出，但是一直都沒有找到機會可以去北海岸玩，在練習完演算法後，想說臨時約大學程式社團能不能約動，經過一番波折後終於約成了，讚啦！</p>
<h2 id="把大家拉出來玩"><a href="#把大家拉出來玩" class="headerlink" title="把大家拉出來玩"></a>把大家拉出來玩</h2><p>一開始我想要出去玩，我先問了紹宇要不要去北海岸玩，紹宇說可以啊，要不要一起問社團，我就想說那一定好啊，然後我就去問了力瑋，力瑋也說沒有問題，我想說已經綁架兩個人了，剩下兩個人一定都很好綁架拉！</p>
<p>我將力瑋形容成立法院長、紹宇是社長、機長是洸明、總統是天佑，我是副總統，直接綁架機長跟總統說要不要給我通過行政命令XD，跟某豬議題可能類似XDDD。</p>
<p>後來機長跟總統受不了我的盧，終究還是跟我出去玩了！</p>
<h2 id="改期、租車是大問題啊"><a href="#改期、租車是大問題啊" class="headerlink" title="改期、租車是大問題啊"></a>改期、租車是大問題啊</h2><p>原本我們是約好的隔天馬上就要出發，但結果因為沒有辦法租車QQQ，租車要滿 20y，我們這邊的大哥哥洸明沒有駕照，天佑有，但才剛滿 20 申請和運還沒有辦法成功，沒辦法租車就只好借家裡的車拉，結果我爸的車有問題沒有去修理，力瑋爸的車要上班不能借QQ。</p>
<p>在百般無奈之下，就取消了這次的行程。</p>
<h2 id="我怎麼可能會死心"><a href="#我怎麼可能會死心" class="headerlink" title="我怎麼可能會死心"></a>我怎麼可能會死心</h2><p>但是我還是好想要出去玩RRRRR，我就在網路上找了一堆方法來能讓這次旅行可以出去玩，我就找了幾個方法來跟天佑不斷搓合，看有沒有機會出去玩，結果找到 29 號是大家有空可以出去玩，那就趕快出門拉</p>
<blockquote>
<p>跟天佑的對話，原先還要讓他帶小夜燈，結果他只有超大手電筒www<br><img src="https://drive.google.com/u/2/uc?id=1_N1Zn28I7XKIvj8oM-SYxF6XRH2b6dEc&export=download" alt=""></p>
</blockquote>
<h2 id="DC-大討論"><a href="#DC-大討論" class="headerlink" title="DC 大討論"></a>DC 大討論</h2><p>出去玩嘛，總是要討論一下的。</p>
<p>租車細節，怎麼樣玩拉，都需要討論，其實我原本是想說車子隨便開有玩到就賺、沒玩到地方下次來，來回慢跑我都覺得沒關係，結果大家直接把我噴得滿地都是XDDD，洸明還說我演算法怎麼學得，最短路徑都沒學好QQQQ。</p>
<p>總之，在大家的激烈討論下，看來要舉辦一個活動真的不容易呢，幸好大家都有包容我，不然說不定可能會玩得很差吧XD。</p>
<p>白沙灣在北邊，我們為甚麼在北邊看日出，這是我學到的最大經驗XD。</p>
<blockquote>
<p>出去玩的規劃<br><img src="https://drive.google.com/u/2/uc?id=1GlRCwwAxNIU-6vMpXjOhMZgOHeCzM1Ym&export=download" alt=""></p>
</blockquote>
<p>也要謝謝天佑拉，租車事宜都交給他，辛苦他了QQ。</p>
<h2 id="從北科出發"><a href="#從北科出發" class="headerlink" title="從北科出發"></a>從北科出發</h2><p>我們那天在進行演算法練習，而天佑跟紹宇先去取車，我們先在 109 集合，力瑋跟洸明在聊天跟肢體語言，剛好被我記錄下來XD。</p>
<blockquote>
<p>力瑋跟洸明的肢體語言<br><img src="https://drive.google.com/u/2/uc?id=1eAWRE-8Q0JDcULj0RYfA5rDQlOpa-7zO&export=download" alt=""></p>
</blockquote>
<p>天佑跟紹宇到了，我們趕快出發去找他們，結果剛好天佑去上廁所，我們都不能進去都在外面等他XDD，我們手中拿著一堆行李重得要死，結果我們嘗試要打開後車廂放行李都打不開，然後我們就乾等天佑，結果天佑來了後說為甚麼你們都不放行李，我說沒辦法開後車箱門被鎖住了，天佑就輕輕地就打開了，完全沒有做甚麼動作，只留下充滿驚訝的我。</p>
<p>紹宇坐上了副駕，留下了尷尬的我，我心裡想，我 1.5 喔確定要讓我擠後座嘛?????，在充滿懷疑的情況下車車把我們載走出發啦。</p>
<h2 id="高速公路上"><a href="#高速公路上" class="headerlink" title="高速公路上"></a>高速公路上</h2><p>在高速公路，我們聽著周杰倫的音樂，這是洸明限定，只有他在我們才有機會聽得道音樂，然後，恩，後座真的好擠，我跟洸明一直撞到RRRR，這個時候就覺得自己瘦了真好QQ。</p>
<p>在高速公路的路上，大家車速都好快，我真的會怕QQQ，那種高速公路上車禍的影片，第一次大家一起出去玩開車，讓我心驚膽跳，大家車速都 90 幾不是一個機車騎士能夠體會到的事QQQ。</p>
<h2 id="基隆廟口"><a href="#基隆廟口" class="headerlink" title="基隆廟口"></a>基隆廟口</h2><p>到了基隆後，我們停到了一個停車場，不得不說，基隆的人行道真的對人很不友善、基隆的車子交通也不好QQQ，一堆單行道，還有兩個不同方向的單行道同時面對面，突然覺得萬華的交通也沒有很爛阿，看看基隆，萬華好多了！</p>
<p>基隆的房子似乎都更得不多，還都是比較老舊的階段，</p>
<p>走到廟口後，我們先去吃最好吃的三明治，在買天婦羅(不過洸明不推)，覺得不好吃，我們一路吃著雞排、豆花，豆花蠻好吃的，但是太多澱粉要胖拉XDDD。</p>
<blockquote>
<p>好吃的三明治<br><img src="https://drive.google.com/u/2/uc?id=1tR0zfVeEkwIkr1xMTPjf5DZ58EehY0U5&export=download" alt=""></p>
</blockquote>
<p>吃完飯後，我們漫步在基隆，不得不說，在基隆晚上走路很舒服有著海風，基隆最精華的地方就屬基隆港了吧！在那邊可以讓人心曠神怡，但一往回來走就覺得有種進入 70 年代的台灣感覺。</p>
<p>吃飽後，我們先去 24hr 的頂好，基隆只有頂好 24 hr QQ，好難過，我對頂好的印象沒有很好的說，邊走邊喝，順便大家一起走路聊天，走到港口後發現有個漂亮的船，就跟他拍照拉！</p>
<blockquote>
<p>跟船的合照<br><img src="https://drive.google.com/u/2/uc?id=1DLpyZCCIhI7nSJepBEs4ECnMIorRLJ82&export=download" alt=""></p>
</blockquote>
<blockquote>
<p>天佑再幫我拍照時，旁邊那些人都進來鏡頭惡搞，太過分嘞！那就只好讓他們上我的 blog 拉<br><img src="https://drive.google.com/u/2/uc?id=1Mo9C0aJ2ny2racxmtLoag1deM2PJvHWz&export=download" alt=""></p>
</blockquote>
<blockquote>
<p>不過基隆的夜晚很美，天佑拍了兩張照作為紀念<br><img src="https://drive.google.com/u/2/uc?id=1t-g5Buc5w0zYE1T16KER9yAeIhViIsWD&export=download" alt=""><br><img src="https://drive.google.com/u/2/uc?id=1LNIQbsieH6dRvWdKisS7Cme4PZ4LHuhb&export=download" alt=""></p>
</blockquote>
<p>走累了後，我們要去北海岸的白沙灣看看日出，於是天佑跟紹宇先去停車場開車，我跟剩下的人則是一起去頂好買東西，其中頂好前面很漂亮，特別拍了照片。</p>
<blockquote>
<p>頂好前面拍照留念<br><img src="https://drive.google.com/u/2/uc?id=19jonnkbYpWRSY3PzVrC3UBUnBoe4MP-i&export=download" alt=""><br><img src="https://drive.google.com/u/2/uc?id=13EBIm9PTL_Ky3KKk62OeecCyrDX4Lfk-&export=download" alt=""></p>
</blockquote>
<blockquote>
<p>買了一堆的收據<br><img src="https://drive.google.com/u/2/uc?id=1f7G35fUzflfZOjg9n1MgnLqe5lWh5vhj&export=download" alt=""></p>
</blockquote>
<p>我們準備要去白沙灣拉，但是大家都很想尿尿XD，我們想要去麥當勞尿尿，結果路上一堆違停，我們原本是不想違停的，但是因為破窗效應嘛，所以我們就趕快違停去上廁所XD。</p>
<h2 id="白沙灣"><a href="#白沙灣" class="headerlink" title="白沙灣"></a>白沙灣</h2><p>我們到了白沙灣拉，馬上就想上廁所XD，我們跑去了警察局要來上廁所，結果警察局跟我們說廁所在旁邊，然後我們就摸黑上廁所，半夜是停電的RRR，然後晚上還在施工，我們原本一開始以為可能不能進去了！結果沒想到還是可以XD，好險，不然這趟就白來了QQ，我們就準備下去，結果紹宇沒有帶拖鞋，天佑趕緊回去陪他拿。</p>
<p>那其他人呢？<br>我們就換好拖鞋準備踩沙拉，那天的風有夠大，快吹到死掉了，我們還拚了命的想要去鋪好紹宇帶的沙灘巾，結果風太大根本沒有辦法啊RRRR，我們犧牲洸明壓著沙灘巾，而我跟立委趕緊去把裝備搬下來，然後突然想到我帶的仙女棒沒有帶打火機呢XD，趕快叫紹宇幫我買打火機XD。</p>
<p>紹宇他們回來後，發現，怎麼這麼冷！每個人都在念我這甚麼爛活動XD，不是吼，應該會蠻好玩的吼，是風向差了點拉，不是我的錯啦QQ。</p>
<blockquote>
<p>天佑拍大家終於可以休息的畫面<br><img src="https://drive.google.com/u/2/uc?id=16bTgzZZcPleVmZb6vu01B5pSRgjEWupL&export=download" alt=""></p>
</blockquote>
<blockquote>
<p>意義不明的沙灘照XD<br><img src="https://drive.google.com/u/2/uc?id=1kbZ3OFJg1hkwCKGDBIGR7nTdRCin9acq&export=download" alt=""></p>
</blockquote>
<blockquote>
<p>畫質有點差的凌晨沙灘<br><img src="https://drive.google.com/u/2/uc?id=1Ib2Y6dyBFRly4XpXFfnIfuoppQPTcCFb&export=download" alt=""></p>
</blockquote>
<p>我們在那邊喝點小酒，踩踩沙，玩玩仙女棒，結果仙女棒我們還點不起來火，我們特地為了點火大家互相包圍住仙女棒就是祈求將火點燃，結果還是沒有辦法XDDD，後來洸明想到好方法，跑到了屋子旁邊點火，終於成功了！我興奮地大叫讚啦，將軍，讚啦，點起了仙女棒來玩。</p>
<blockquote>
<p>大家一起玩仙女棒的影片，風超大，所以超級吵得XD</p>
<div class="video-container"><iframe src="https://www.youtube.com/embed/AMVpWwPhfNo" frameborder="0" loading="lazy" allowfullscreen></iframe></div>
</blockquote>
<p>聽到紹宇的怒吼，我覺得超好笑，來了都值了XD</p>
<p>寒假應該 100 分，怎麼會是 0 分。 大衛 2021/02/22</p>
<p>結果在喝的路上開始有點慢慢醉掉了，跟力瑋、洸明一起喝酒，結果我好像喝太多直接醉了QQ，一倒車上不小心一瞇起眼睛來就開始慢慢有了嘔吐的慾望。</p>
<h2 id="三芝買早餐"><a href="#三芝買早餐" class="headerlink" title="三芝買早餐"></a>三芝買早餐</h2><p>此時早餐店已經開了，紹宇跟某人，但我有點醉就忘記是誰了，就去買了早餐，我一吃完早餐就直接吐，大家看到都被嚇到QQ，這個時候我的腦袋開始已經有醉意了，只想要睡覺其他都不想要QQ。</p>
<p>吃完早餐後，就去富貴角燈塔啦。</p>
<h2 id="富貴角燈塔"><a href="#富貴角燈塔" class="headerlink" title="富貴角燈塔"></a>富貴角燈塔</h2><p>停好車後，我又在吐了一次。<br>我很對不起大家，還有地板。</p>
<p>後來我們一起去看日出，途中遇到很多野狗很怕阿QQQQ，不得不說，為甚麼富貴角燈塔比鵝鑾鼻燈塔的裝潢都還差拉QQ，都沒有經過好的整理嘛，嗚嗚。</p>
<p>路途上風超大的，這次我難得把帽子戴了起來。</p>
<blockquote>
<p>看到日出後的合照<br><img src="https://drive.google.com/u/2/uc?id=13brD52QNYm9CUW_litN2yX1vD1kFGpfm&export=download" alt=""></p>
</blockquote>
<blockquote>
<p>紹宇跟富貴角燈塔的合照<br><img src="https://drive.google.com/u/2/uc?id=1ajJOcn2InhUteghA5aae5o4u5jDU4a1u&export=download" alt=""></p>
</blockquote>
<blockquote>
<p>業配零食，這真的好好吃<br><img src="https://drive.google.com/u/2/uc?id=19xfiFa4yruM0JM4ujKLgQ2V3kHUs_o4K&export=download" alt=""></p>
</blockquote>
<blockquote>
<p>會影分身的力瑋<br><img src="https://drive.google.com/u/2/uc?id=1DcWNdHZ6N23CScN58HTehrqcyRwAj5l9&export=download" alt=""></p>
</blockquote>
<p>看完後，我們就去老梅放風箏。</p>
<h2 id="老梅"><a href="#老梅" class="headerlink" title="老梅"></a>老梅</h2><p>我又吐了一次，三次了，事不過三。<br>途中我完全沒有印象，是大家叫我起床的，然後我就來放風箏，結果不到 10s 風箏直接被風吹走…，他叫風箏欸QQQQQ，怎麼可以被風吹走，可能真的風太大了吧QQ。</p>
<p>總之，這趟旅程獲得了快樂與暈眩，失去了風箏QQQ。</p>
<blockquote>
<p>失去風箏的我<br><img src="https://drive.google.com/u/2/uc?id=1YUhM3-04EE8TJA-ybgcraCYP2R0vyqe4&export=download" alt=""></p>
</blockquote>
<p>後來我跟天佑好像在車上睡覺，其他人在外面聊天，我有點累掛了，直接在裡面睡掛。</p>
<p>大家集合到車上後，問我這個指揮官還要不要去淡水，對不起我沒有體力了QQ，我們回家吧，下次我會少碰酒QQQQ，我會好好改進的。</p>
<h2 id="到北科"><a href="#到北科" class="headerlink" title="到北科"></a>到北科</h2><p>我們一路到北科，但我完全沒記得。</p>
<p>後來天佑跟紹宇把我們放在北科卸下行李，他們先去還車，然後我們就先去社辦放東西，大家都有點疲勞了，我們就在社辦休息一陣子後就回家。</p>
<p>真的是拚了老命回家，我到現在完全沒有印象我怎麼回家的，我那時候應該拚著意識再衝吧XD。</p>
<p>辛苦天佑了，這麼累的情況還要載我們回家，他人最好了QQ。<br>辛苦紹宇了，陪著天佑到處跑。<br>辛苦力瑋了，陪著喝醉的我。<br>辛苦洸明了，忍受我的白目。<br>辛苦大衛了，你吐了三次。</p>
<h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>還是有很多地方可以改進拉，感覺並不是每個地方都做到最好，例如去白沙灣吹那麼強的海風就是一個大問題，沒有買到煙火也是大問題，主要是這次行程太趕變得沒有規劃好很多，我以後要再好好改進。</p>
<p>然後不可以喝太多酒，不然自己會死得很難看，我們也買太多，剩下一堆酒XD。</p>
<p>總之，還是謝謝大家在我的大學生活，我很快樂XD。</p>
]]></content>
      <categories>
        <category>人生旅途</category>
      </categories>
      <tags>
        <tag>大學Life</tag>
        <tag>人生旅途</tag>
      </tags>
  </entry>
  <entry>
    <title>演算法知識 - Topological Ordering 拓樸排序(時間複雜度 O(V+E))</title>
    <url>/2021/02/26/Explain_Algorithm/Topological_Ordering/</url>
    <content><![CDATA[<h2 id="Topological-Ordering-拓樸排序-介紹"><a href="#Topological-Ordering-拓樸排序-介紹" class="headerlink" title="Topological Ordering 拓樸排序 介紹"></a>Topological Ordering 拓樸排序 介紹</h2><blockquote>
<p>在有些程式問題，可能會有以下這些需求</p>
<ul>
<li>我們需要做完 n 個任務，但有些任務有依賴需求，需要某個任務完成才可以做這個任務，請給出一份符合要求的任務清單</li>
<li>要幫學員排隊，但有些人必須排在某些人的後面，請給出一份符合要求的排隊順序</li>
</ul>
<p>也就是對於一個序列，其中的某兩點具有先後關係，即是拓樸排序</p>
</blockquote>
<a id="more"></a>

<h2 id="Topological-Ordering-限制"><a href="#Topological-Ordering-限制" class="headerlink" title="Topological Ordering 限制"></a>Topological Ordering 限制</h2><p>Topological Ordering 有些要求，如下</p>
<ul>
<li>必須是有向圖<br>如果是無向圖，不會有順序的概念。</li>
<li>不可以有環(cycle)<br>如果有環，無法確定先後的關係，例如順時鐘或逆時鐘，則 1 這個數字的位置就不同。</li>
</ul>
<h2 id="Topological-Ordering-實作與說明"><a href="#Topological-Ordering-實作與說明" class="headerlink" title="Topological Ordering 實作與說明"></a>Topological Ordering 實作與說明</h2><p>在程式碼進行說明，相信會比較好理解些。</p>
<p>基本上此演算法類似於 BFS，如果有學過 BFS 一定會相當好懂。</p>
<h3 id="定義名詞"><a href="#定義名詞" class="headerlink" title="定義名詞"></a>定義名詞</h3><ul>
<li>紀錄關係<br>a,b ，則 a 必須在 b 前面、c,d，則 c 必須在 d 前面，此時我們會稱 a,c 為前面節點、b,d 是後面節點。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 120</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, a, b;</span><br><span class="line"><span class="keyword">int</span> cnt[MAXN]; <span class="comment">//記錄關係，以此節點為後面，而有多少節點在其前面</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; root[MAXN], ans; </span><br><span class="line"><span class="comment">//root 記錄關係，以此節點為前面，而另一節點就在後面 (vector.push_back)</span></span><br><span class="line"><span class="comment">//ans 答案序列，拓樸排序的序列</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">topo</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123; <span class="comment">//不斷輸入 </span></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b; <span class="comment">//輸入記錄關係，a 是前者 b 是後者</span></span><br><span class="line">        root[a].push_back(b);  <span class="comment">//記錄關係，記錄 a 有多少後面節點，並且記錄。</span></span><br><span class="line">        cnt[b]++; <span class="comment">//記錄有幾個前面節點，如果 b 是後面關係時。</span></span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; q; <span class="comment">//用來判斷有哪些節點現在已經可以直接被放到答案序列</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt[i] == <span class="number">0</span>) q.push_back(i); </span><br><span class="line">        <span class="comment">//在記錄關係中，如果以此節點為後面，沒有節點在前面就加入 q</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> now; <span class="comment">//暫存 bfs(q) 當前的節點</span></span><br><span class="line">    ans.clear(); <span class="comment">//答案序列清空</span></span><br><span class="line">    <span class="keyword">while</span>(ans.size() != n)&#123; <span class="comment">//如果答案序列的長度跟題目給的長度一樣就跳出</span></span><br><span class="line">        <span class="keyword">if</span>(q.empty()) <span class="keyword">break</span>; <span class="comment">//如果沒有節點可以直接被放入答案序列就跳出</span></span><br><span class="line">        now = q.front(); q.pop_front(); <span class="comment">//把當前節點給 now</span></span><br><span class="line">        ans.push_back(now); <span class="comment">//將 now 放入答案序列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it: root[now])&#123; <span class="comment">//由於 now 節點被放入答案陣列，</span></span><br><span class="line">        <span class="comment">//之前的記錄關係就不須記錄，因為放到答案陣列就剩下的後面節點就必定在後面</span></span><br><span class="line"></span><br><span class="line">            cnt[it]--; <span class="comment">//將所有原本在記錄關係中後面的節點 -1，減少了一個記錄關係</span></span><br><span class="line">            <span class="keyword">if</span>(cnt[it] == <span class="number">0</span>) q.push_back(it); <span class="comment">//如果都沒有記錄關係就可以放到 q</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ans.size() == n)&#123; <span class="comment">//如果答案序列跟 n 一樣，表示可以成功排出拓樸排序，就輸出答案</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ans.size(); i++) <span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; ans[i];</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Topological-Ordering-應用"><a href="#Topological-Ordering-應用" class="headerlink" title="Topological Ordering 應用"></a>Topological Ordering 應用</h2><p>點擊 tag Topological Ordering 就可以看到所有我寫過的應用題目</p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="http://web.ntnu.edu.tw/~algo/DirectedAcyclicGraph.html#2" target="_blank" rel="noopener">師大演算法 - Topological Ordering </a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>想註解真的是一件很難的事情！我腦袋滿滿的想法就是講不出來…，是我的高職國文沒有學好嗎，感覺自己的詞彙量沒有很大，還需要再好好進步，讓自己對於國文的表達能力在更好些。</p>
<h2 id="Topological-Ordering-無註解程式碼"><a href="#Topological-Ordering-無註解程式碼" class="headerlink" title="Topological Ordering 無註解程式碼"></a>Topological Ordering 無註解程式碼</h2><p>這裡則放置沒有註解的程式碼，如果讀者想要複製就從這裡進行複製吧！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n, m, a, b;</span><br><span class="line"><span class="keyword">int</span> cnt[MAXN];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; root[MAXN], ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">topo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt[i] == <span class="number">0</span>) q.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> now;</span><br><span class="line">    ans.clear();</span><br><span class="line">    <span class="keyword">while</span>(ans.size() != n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(q.empty()) <span class="keyword">break</span>;</span><br><span class="line">        now = q.front(); q.pop_front();</span><br><span class="line">        ans.push_back(now);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it: root[now])&#123;</span><br><span class="line">            cnt[it]--;</span><br><span class="line">            <span class="keyword">if</span>(cnt[it] == <span class="number">0</span>) q.push_back(it);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ans.size() == n)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; ans.size(); i++) <span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; ans[i];</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>演算法知識</category>
      </categories>
      <tags>
        <tag>程式解題</tag>
        <tag>演算法知識</tag>
        <tag>Topological Ordering 拓樸排序</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa10305 - Ordering Tasks(拓樸排序)</title>
    <url>/2021/02/27/UVa/UVa10305/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>John 有很多任務要做，但有些任務息息相關，希望你可以幫他寫出一份任務清單讓他來做任務</p>
<p><a href="https://onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1246" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li><a href="https://theriseofdavid.github.io/2021/02/26/Explain_Algorithm/Topological_Ordering/" target="_blank" rel="noopener">拓樸排序</a>的應用</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>簡單的拓樸排序，如果不太懂拓樸排序就看 <a href="https://theriseofdavid.github.io/2021/02/26/Explain_Algorithm/Topological_Ordering/" target="_blank" rel="noopener">演算法知識 - Topological Ordering 拓樸排序(時間複雜度 O(V+E))</a>，有對於一些拓樸排序有些基礎的教學，希望大家都可以看懂。</p>
<p>標準模板題，但要注意必需 n and m 都要是 <strong>0</strong> 才可以把程式終止喔，這題會有 n or m 一個零的情況。</p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="http://web.ntnu.edu.tw/~algo/DirectedAcyclicGraph.html#2" target="_blank" rel="noopener">師大演算法 - Topological Ordering </a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>這題真的是師大演算法給我大助攻阿！發現開學後我的腦袋變得沒有原本寒假時候清晰了，太多雜事要忙要做了，都沒有辦法用心做這件事，以前還記得的演算法現在都忘記了，現在趕快補這些知識回來。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。 </p>
<p>下面 <code>topo function</code> 的程式碼 <a href="https://theriseofdavid.github.io/2021/02/26/Explain_Algorithm/Topological_Ordering/" target="_blank" rel="noopener">演算法知識 - Topological Ordering 拓樸排序(時間複雜度 O(V+E))</a> 相同，就不寫講解，如果不太懂直接看此網頁就好。</p>
<ul>
<li>紀錄關係<br>a,b ，則 a 必須在 b 前面、c,d，則 c 必須在 d 前面，此時我們會稱 a,c 為前面節點、b,d 是後面節點。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 120</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, a, b;</span><br><span class="line"><span class="keyword">int</span> cnt[MAXN]; </span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; root[MAXN], ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">topo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt[i] == <span class="number">0</span>) q.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> now;</span><br><span class="line">    ans.clear();</span><br><span class="line">    <span class="keyword">while</span>(ans.size() != n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(q.empty()) <span class="keyword">break</span>;</span><br><span class="line">        now = q.front(); q.pop_front();</span><br><span class="line">        ans.push_back(now);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it: root[now])&#123;</span><br><span class="line">            cnt[it]--;</span><br><span class="line">            <span class="keyword">if</span>(cnt[it] == <span class="number">0</span>) q.push_back(it);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ans.size() == n)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; ans.size(); i++) <span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; ans[i];</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="comment">//freopen("out.txt", "w", stdout);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &amp;&amp; n + m != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) root[i].clear(); <span class="comment">//將資料清空，以免這次測資被上次測資干擾</span></span><br><span class="line">        <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span>(cnt)); </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123; <span class="comment">//輸入資料</span></span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">            root[a].push_back(b); <span class="comment">//記錄關係，記錄 a 有多少後面節點，並且記錄。</span></span><br><span class="line">            <span class="comment">//這裡的後面節點須看 [大衛的筆記 拓樸排序] 意思。</span></span><br><span class="line">            cnt[b]++; <span class="comment">//記錄有幾個前面節點</span></span><br><span class="line">        &#125;</span><br><span class="line">        topo(); <span class="comment">//拓樸排序開始</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>Topological Ordering 拓樸排序</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa11060 - Beverages(拓樸排序)</title>
    <url>/2021/02/27/UVa/UVa11060/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>Dilbert 是一位學生，他喜歡喝酒的時候先喝低濃度酒精飲料，之後慢慢變濃，不會再回去喝比較低的酒精飲料，給你他要喝的飲料，在給你一些酒精的先後關係，請給他一種飲料排序是可以符合他的喝酒規則。</p>
<p><a href="https://onlinejudge.org/index.php?option=onlinejudge&Itemid=8&page=show_problem&problem=2001" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li><a href="https://theriseofdavid.github.io/2021/02/26/Explain_Algorithm/Topological_Ordering/" target="_blank" rel="noopener">拓樸排序</a>的應用</li>
<li>將酒精飲料 hash 成數值</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>簡單的拓樸排序，如果不太懂拓樸排序就看 <a href="https://theriseofdavid.github.io/2021/02/26/Explain_Algorithm/Topological_Ordering/" target="_blank" rel="noopener">演算法知識 - Topological Ordering 拓樸排序(時間複雜度 O(V+E))</a>，有對於一些拓樸排序有些基礎的教學，希望大家都可以看懂。</p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>最近不斷在複習演算法，但是內心卻因為感情的事情不斷在擔憂，真的好煩。</p>
<p>好希望自己能夠安靜下心來，順利做完每個任務，好想讓自己可以變成一個溫暖、開心的人。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。 </p>
<p>關於 function <code>topo</code> 的程式碼說明請大家點<a href="https://theriseofdavid.github.io/2021/02/26/Explain_Algorithm/Topological_Ordering/" target="_blank" rel="noopener">拓樸排序</a>，有更完整的解釋，會讓讀者更好吸收。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 220</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> cnt[MAXN];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; root[MAXN];</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; mp; <span class="comment">//飲料 hash 成數字</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; mp2; <span class="comment">//還原 hash</span></span><br><span class="line"><span class="keyword">int</span> n, m, kase; <span class="comment">//題目資訊</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">topo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt[i] == <span class="number">0</span>) q.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    <span class="keyword">int</span> now;</span><br><span class="line">    <span class="keyword">while</span>(ans.size() != n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(q.empty()) <span class="keyword">break</span>;</span><br><span class="line">        sort(q.begin(), q.end());</span><br><span class="line">        now = q.front(); q.pop_front();</span><br><span class="line">        ans.push_back(now);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it: root[now])&#123;</span><br><span class="line">            <span class="keyword">if</span>(--cnt[it] == <span class="number">0</span>) q.push_back(it);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n == ans.size())&#123; <span class="comment">//輸出資料</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Case #"</span> &lt;&lt; ++kase &lt;&lt; <span class="string">": Dilbert should drink beverages in this order:"</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it: ans) <span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; mp2[it];</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">".\n\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"out.txt"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="built_in">string</span> temp, temp2; <span class="comment">//輸入題目資料</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123; <span class="comment">//輸入資料</span></span><br><span class="line">            root[i].clear(); <span class="comment">//先清空之前資料 </span></span><br><span class="line">            cnt[i] = <span class="number">0</span>; <span class="comment">//清除之前的記錄關係</span></span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; temp;</span><br><span class="line">            mp[temp] = i; <span class="comment">//hash，由於 i 值相對應每一個資料，不會碰撞所以就用 i hash</span></span><br><span class="line">            mp2[i] = temp; <span class="comment">//記錄還原</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; m; <span class="comment">//輸入記錄關係</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123; <span class="comment">//不斷輸入 </span></span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; temp &gt;&gt; temp2;</span><br><span class="line">            root[mp[temp]].push_back(mp[temp2]); </span><br><span class="line">            <span class="comment">//記錄關係，記錄 a 有多少後面節點，並且記錄。</span></span><br><span class="line">            cnt[mp[temp2]]++; <span class="comment">//記錄有幾個前面節點，如果 b 是後面關係時。</span></span><br><span class="line">        &#125;</span><br><span class="line">        topo();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>Topological Ordering 拓樸排序</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa872 - Ordering(拓樸排序)</title>
    <url>/2021/02/27/UVa/UVa872/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>有一種排序是，給你一些英文字母，再告訴你某個英文字母必須要在另個英文字母前面(定義為記錄關係)。</p>
<p>請輸出一種排序可以符合題目的所有記錄關係。</p>
<p><a href="https://onlinejudge.org/index.php?option=onlinejudge&Itemid=8&page=show_problem&problem=813" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li><a href="https://theriseofdavid.github.io/2021/02/26/Explain_Algorithm/Topological_Ordering/" target="_blank" rel="noopener">拓樸排序</a>的應用</li>
<li>如何輸入</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>這邊我用另種方式來寫拓樸排序，想說透過 DFS 的方式看能否寫出拓樸排序，但我認為我寫得不太好，這是我的自創方式，建議還是不要多看這個。</p>
<p>但如果想要了解我的思考，還是建議看看。</p>
<p>這題比較不好輸入，要用上 <code>stringstream</code> 這是類似於 <code>cin</code>，透過這個可以方便輸入題目資料，再來記錄所有的<strong>記錄關係</strong>，每次進行 DFS 時，確認之前的 DFS 的資料都有符合記錄關係才繼續，如果沒有就退回上層 DFS。</p>
<p>缺點是每層 DFS 都要做一次確認，時間複雜度會爆炸多，建議在比賽中還是不要使用。</p>
<p>DFS 只要能夠成功就一定會是拓樸排序，因為每層都會確認關係，因此只要走到 DFS 深度與原本序列一樣長就可以。</p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://github.com/morris821028/UVa/blob/master/volume008/872%20-%20Ordering.cpp" target="_blank" rel="noopener">UVa872 - morris821028</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>其實我一開始已經忘記<strong>拓樸排序</strong>了，那是高中學的，上了大學後都忘記了…，然後在根據 Competitive Programming3，複習的過程中在寫這題 UVA，翻著有沒有其他人寫詳解，結果發現 morris821028 沒有寫詳解QQ，但是有 github，就看著他的程式碼來解，但後來發現師大演算法的 BFS 版本更好，後面就改用師大演算法的了。</p>
<p>很感謝師大演算法與 morris821028 大大，願意讓學習資源在網路上才有辦法讓我學習到，很感謝他們。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。 </p>
<ul>
<li>紀錄關係<br>a,b ，則 a 必須在 b 前面、c,d，則 c 必須在 d 前面，此時我們會稱 a,c 為前面節點、b,d 是後面節點。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 40</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">stringstream</span> ss;</span><br><span class="line"><span class="keyword">int</span> graph[MAXN], visit[MAXN]; <span class="comment">//graph 由於題目給的是字串，所以我們把它 hash 成 int</span></span><br><span class="line"><span class="comment">//visit 判斷這個點有沒有被 DFS 經歷過</span></span><br><span class="line"><span class="keyword">int</span> order[MAXN][MAXN]; <span class="comment">//order 記錄關係</span></span><br><span class="line"><span class="keyword">int</span> n, lg, flag2, flag3; <span class="comment">//n 測資長度, lg 每一個陣列長度</span></span><br><span class="line"><span class="comment">//flag2 判斷有沒有辦法拓樸排序, flag3 控制每個測資的斷行</span></span><br><span class="line"><span class="keyword">char</span> ch; <span class="comment">//用來讀字元</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans; <span class="comment">//記錄拓樸排序的陣列</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    visit[x] = <span class="number">1</span>; <span class="comment">//這個點被經歷過</span></span><br><span class="line">    ans.push_back(x); <span class="comment">//放入 ans</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//for(auto it: ans) cout &lt;&lt; (char) (it + 'A') &lt;&lt; ' ';</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; '\n';</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ans.size() == lg)&#123; <span class="comment">//如果答案陣列跟原本陣列長度一樣</span></span><br><span class="line">        flag2 = <span class="number">0</span>; <span class="comment">//有找到拓圖排序</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; (<span class="keyword">char</span>) (ans[<span class="number">0</span>] + <span class="string">'A'</span>); <span class="comment">//輸出第一個字元，這裡是嚴格輸出</span></span><br><span class="line">        <span class="comment">//輸出資料</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; ans.size(); i++) <span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; (<span class="keyword">char</span>) (ans[i] + <span class="string">'A'</span>);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">//退回</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> flag; <span class="comment">//判斷當前答案陣列能不能在擴展</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXN; i++)&#123; <span class="comment">//遍地搜尋</span></span><br><span class="line">        flag = <span class="number">1</span>; </span><br><span class="line">        <span class="keyword">if</span>(graph[i] != <span class="number">1</span> || visit[i] == <span class="number">1</span>) <span class="keyword">continue</span>; </span><br><span class="line">        <span class="comment">//有被經歷過了或沒有這個節點(graph[i] != 1)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it: ans)&#123; <span class="comment">//遍地搜尋 ans 有沒有都符合記錄關係</span></span><br><span class="line">            <span class="keyword">if</span>(order[it][i])&#123; <span class="comment">//等於 1 表示沒有符合</span></span><br><span class="line">                flag = <span class="number">0</span>; <span class="comment">//退出 for，不能擴展繼續嘗試其他的節點</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="number">1</span>)&#123; <span class="comment">//表示此節點可以被擴展</span></span><br><span class="line">            dfs(i);　<span class="comment">//進入 DFS</span></span><br><span class="line">            visit[i] = <span class="number">0</span>; <span class="comment">//由於退回了，此節點要還原成原本狀態</span></span><br><span class="line">            ans.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"out.txt"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n; <span class="comment">//輸入資料</span></span><br><span class="line">    <span class="built_in">cin</span>.ignore(); <span class="comment">//為了後面的 getline，現在要讓指標先到下一行</span></span><br><span class="line">    flag3 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="built_in">string</span> temp;</span><br><span class="line">        getline(<span class="built_in">cin</span>, temp); <span class="comment">//replace blank line 把空白行消除掉</span></span><br><span class="line">        getline(<span class="built_in">cin</span>, temp); <span class="comment">//輸入題目陣列</span></span><br><span class="line">        <span class="comment">//cout &lt;&lt; "temp is " &lt;&lt; temp &lt;&lt; '\n';</span></span><br><span class="line">        ss.clear(); ss.str(<span class="string">""</span>); ss &lt;&lt; temp; <span class="comment">//給 stringstream 方便等等輸入資料</span></span><br><span class="line">        <span class="built_in">memset</span>(graph, <span class="number">0</span>, <span class="keyword">sizeof</span>(graph)); <span class="comment">//重新整理資料，避免干擾</span></span><br><span class="line">        <span class="built_in">memset</span>(order, <span class="number">0</span>, <span class="keyword">sizeof</span>(order));</span><br><span class="line">        lg = <span class="number">0</span>; <span class="comment">//用來記錄題目陣列長度</span></span><br><span class="line">        <span class="keyword">while</span>(ss &gt;&gt; ch)&#123; </span><br><span class="line">            graph[ch - <span class="string">'A'</span>] = <span class="number">1</span>; <span class="comment">//把每個值 hash 成 字元 - 'A'，1 就是有這節點</span></span><br><span class="line">            lg++; <span class="comment">//長度增加</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        getline(<span class="built_in">cin</span>, temp); <span class="comment">//輸入記錄關係</span></span><br><span class="line">        ss.clear(); ss.str(<span class="string">""</span>); ss &lt;&lt; temp; <span class="comment">//給 stringstream 方便等等輸入資料</span></span><br><span class="line">        <span class="keyword">while</span>(ss &gt;&gt; temp) order[temp[<span class="number">2</span>] - <span class="string">'A'</span>][temp[<span class="number">0</span>] - <span class="string">'A'</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//由於記錄關係是用字串表達，且只會有一個字母，所以就用這樣記錄</span></span><br><span class="line">        <span class="comment">//需要提醒的是，我是記錄違法記錄關係的，也就是會把後面關係放在前面 index，前面關係放在後面</span></span><br><span class="line">        <span class="comment">//這樣只要 DFS 有掃到就可以表示不符合關係。</span></span><br><span class="line">        <span class="comment">//也有其他種寫法，可以自己嘗試</span></span><br><span class="line"></span><br><span class="line">        flag2 = <span class="number">1</span>; <span class="comment">//判斷有沒有拓樸排序</span></span><br><span class="line">        <span class="keyword">if</span>(flag3 == <span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>; <span class="comment">//嚴格比較，每筆測資的斷航</span></span><br><span class="line">        <span class="keyword">if</span>(flag3) flag3 = <span class="number">0</span>; <span class="comment">//第一筆沒有斷行，因此第二筆開始都是 0。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXN; i++)&#123; <span class="comment">//遍地搜尋 </span></span><br><span class="line">            <span class="keyword">if</span>(graph[i] == <span class="number">1</span>)&#123; <span class="comment">//有此節點就繼續</span></span><br><span class="line">                dfs(i); <span class="comment">//擴展 DFS</span></span><br><span class="line">                ans.pop_back(); <span class="comment">//還原狀態</span></span><br><span class="line">                visit[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag2) <span class="built_in">cout</span> &lt;&lt; <span class="string">"NO\n"</span>; <span class="comment">//如果沒有找到，就輸出 no</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>Topological Ordering 拓樸排序</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown 放入 google drive 圖片</title>
    <url>/2021/02/28/blog/hackmd_view_googledricePIC/</url>
    <content><![CDATA[<h2 id="主要內容"><a href="#主要內容" class="headerlink" title="主要內容"></a>主要內容</h2><blockquote>
<p>主要介紹如何將 google drive 的圖片放到 markdown 上，並且會自動顯示。</p>
</blockquote>
<a id="more"></a>

<h2 id="如何在-Markdown-放入-google-drive-圖片呢？"><a href="#如何在-Markdown-放入-google-drive-圖片呢？" class="headerlink" title="如何在 Markdown 放入 google drive 圖片呢？"></a>如何在 Markdown 放入 google drive 圖片呢？</h2><p>就快速講結果，不講過程了。如果對過程有興趣就看參考連結，參考連結講的超棒我就不贅述了。</p>
<h3 id="Step1-先共享自己要放入-markdown-的圖片，然後找出網址"><a href="#Step1-先共享自己要放入-markdown-的圖片，然後找出網址" class="headerlink" title="Step1 先共享自己要放入 markdown 的圖片，然後找出網址"></a>Step1 先共享自己要放入 markdown 的圖片，然後找出網址</h3><p>通常網址會是如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;drive.google.com&#x2F;file&#x2F;d&#x2F;XXXXXX&#x2F;view?usp&#x3D;sharing</span><br></pre></td></tr></table></figure>

<p>其中 XXXX 就是這張圖片的 ID。</p>
<h3 id="Stpe2-將網址替換，並且將-ID-換上"><a href="#Stpe2-將網址替換，並且將-ID-換上" class="headerlink" title="Stpe2 將網址替換，並且將 ID 換上"></a>Stpe2 將網址替換，並且將 ID 換上</h3><p>換成如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;drive.google.com&#x2F;u&#x2F;2&#x2F;uc?id&#x3D;XXXXX&amp;export&#x3D;download</span><br></pre></td></tr></table></figure>

<p>然後嘗試</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![](https://drive.google.com/u/2/uc?id=XXXXX&amp;export=download)</span><br></pre></td></tr></table></figure>

<p>這樣就可以了！</p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://hackmd.io/@cnsrl/H1gHwCyGw" target="_blank" rel="noopener">於 HackMD 使用 Google 雲端硬碟中的圖片 - cnsrl</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>很感謝 cnsrl 大大願意教學，原本看 google drive 是提供 iframe 的方法，但是我對這方法不滿意，在網路上翻查後發現有這更好的方式。實在是太棒了！</p>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>QUESTION! C++11 upperbound and lowerbound 用法</title>
    <url>/2021/02/28/C++/C++_binarysearch/</url>
    <content><![CDATA[<h2 id="內容說明"><a href="#內容說明" class="headerlink" title="內容說明"></a>內容說明</h2><blockquote>
<p>語法常常讓人忘記，尤其是相似的語法更為容易，這裡告訴讀者這兩個用法差別，讓讀者在忘記時可以用到。</p>
</blockquote>
<a id="more"></a>

<h2 id="QUESTION-C-11-upperbound-and-lowerbound-用法"><a href="#QUESTION-C-11-upperbound-and-lowerbound-用法" class="headerlink" title="QUESTION! C++11 upperbound and lowerbound 用法"></a>QUESTION! C++11 upperbound and lowerbound 用法</h2><p>這兩個用法使用的是 <a href="https://theriseofdavid.github.io/2020/11/15/Explain_Algorithm/binary_search/" target="_blank" rel="noopener">binary serach 演算法</a>，這裡有詳細的解釋可以看看。</p>
<h3 id="upperbound-上限，傳回-index"><a href="#upperbound-上限，傳回-index" class="headerlink" title="upperbound 上限，傳回 index"></a>upperbound 上限，傳回 index</h3><p>傳回一個 index 為，選定的 \(value &lt; element\) 並傳回第一個元素，其中 value 是我們想找的數值，element 則是陣列中的元素數值。</p>
<p>另一種講法則是，uppderbound 表示對於有序的陣列能夠最<strong>後</strong>大於的數值。</p>
<h4 id="舉例-1-2-3-3-3-4-5，如果我們要找-3-那-uppderbound-會傳回甚麼"><a href="#舉例-1-2-3-3-3-4-5，如果我們要找-3-那-uppderbound-會傳回甚麼" class="headerlink" title="舉例 1,2,3,3,3,4,5，如果我們要找 3 那 uppderbound 會傳回甚麼"></a>舉例 1,2,3,3,3,4,5，如果我們要找 3 那 uppderbound 會傳回甚麼</h4><p>此時會傳回 5，表示 index，那元素數值則是 4。</p>
<p>寫法如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::upper_bound (struct.begin(), struct.end(), value) - <span class="class"><span class="keyword">struct</span>.<span class="title">begin</span>();</span></span><br></pre></td></tr></table></figure>

<h3 id="lowerbound-下限，傳回-index"><a href="#lowerbound-下限，傳回-index" class="headerlink" title="lowerbound 下限，傳回 index"></a>lowerbound 下限，傳回 index</h3><p>傳回一個 index 為，選定的 \(value \leq element\) 並傳回第一個元素，其中 value 是我們想找的數值，element 則是陣列中的元素數值。</p>
<p>另一種講法則是，lowerbound 表示對於有序的陣列能夠最<strong>先</strong>大於的數值。</p>
<h4 id="舉例-1-2-3-3-3-4-5，如果我們要找-3-那-lowerbound-會傳回甚麼"><a href="#舉例-1-2-3-3-3-4-5，如果我們要找-3-那-lowerbound-會傳回甚麼" class="headerlink" title="舉例 1,2,3,3,3,4,5，如果我們要找 3 那 lowerbound 會傳回甚麼"></a>舉例 1,2,3,3,3,4,5，如果我們要找 3 那 lowerbound 會傳回甚麼</h4><p>此時會傳回 2(表示 index)，那元素數值則是 3，因為 3(要找的數值) 等於 3(陣列元素數值)。</p>
<p>寫法如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::lower_bound (struct.begin(), struct.end(), value) - <span class="class"><span class="keyword">struct</span>.<span class="title">begin</span>();</span></span><br></pre></td></tr></table></figure>

<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="http://www.cplusplus.com/reference/algorithm/lower_bound/" target="_blank" rel="noopener">lower_bound - cplusplus</a><br><a href="https://blog.csdn.net/tjpuacm/article/details/26389441" target="_blank" rel="noopener">C++ STL lower_bound upper_bound的用法以及cmp函数 - AcmMissile</a><br><a href="https://blog.csdn.net/hpu_zyh/article/details/11497527" target="_blank" rel="noopener">C++ STL中的 lower_bound() 和 upper_bound() - Hanks-zyh</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>有時候語言寫多常常會讓自己搞混很多語法，透過自己的 blog 紀錄才不會忘記的時候查到不是自己需要的資料，自己寫的比較能夠知道自己不會甚麼！</p>
]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>Cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>正規表達式表達 windows 檔案命名規則</title>
    <url>/2021/03/01/Regular%20Expression/Regular-Expression-win-file-manager/</url>
    <content><![CDATA[<h2 id="內容說明"><a href="#內容說明" class="headerlink" title="內容說明"></a>內容說明</h2><blockquote>
<p>如果在寫程式的過程中需要輸出檔案到 windows OS 上時，<code>/  \   *  ?   :    &quot;   &lt;   &gt;  |</code> 都不可以用是檔名，此時正規表達式來幫助我們解決這問題是最好的了！</p>
<p>　如何寫出正規表達式表達 windows 檔案命名規則呢，就是我們的主題。</p>
</blockquote>
<a id="more"></a>

<h2 id="何寫出正規表達式表達-windows-檔案命名規則？"><a href="#何寫出正規表達式表達-windows-檔案命名規則？" class="headerlink" title="何寫出正規表達式表達 windows 檔案命名規則？"></a>何寫出正規表達式表達 windows 檔案命名規則？</h2><p>廢話不多說，這是我自己的版本提供大家使用 <code>/|\\*|\\?|:|\&quot;|&gt;|&lt;|\\|</code>，希望大家都能使用成功，有問題也能跟我說。</p>
<h2 id="參考來源"><a href="#參考來源" class="headerlink" title="參考來源"></a>參考來源</h2><p><a href="https://sites.google.com/site/zigongdaolun/zuo-ye-xi-tong-jie-shao/fen-lei/windows-dang-an-ming-cheng" target="_blank" rel="noopener">windows檔案命名規則 - 資工導論</a></p>
]]></content>
      <categories>
        <category>正規表示式 Regular Expression</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>正規表示式 Regular Expression</tag>
      </tags>
  </entry>
  <entry>
    <title>正規表達式 Regular Expression 基本方法</title>
    <url>/2021/03/01/Regular%20Expression/Regular-Expression/</url>
    <content><![CDATA[<h2 id="正規表達式-Regular-Expression-介紹"><a href="#正規表達式-Regular-Expression-介紹" class="headerlink" title="正規表達式 Regular Expression 介紹"></a>正規表達式 Regular Expression 介紹</h2><blockquote>
<p>在電腦科學中用來判斷一個字串是否符合我們所規定的特定模式，在文字編輯器中用來檢索、替換那些符合某個規則的文字。。</p>
</blockquote>
<a id="more"></a>

<h2 id="基本語法"><a href="#基本語法" class="headerlink" title="基本語法"></a>基本語法</h2><p>以下提供一些基本語法介紹</p>
<ul>
<li>or <code>|</code><br><code>a|b</code></li>
<li><code>+</code> 代表前面的字元必須至少出現一次<br><code>da+vid</code>，<code>da</code> 一定要出現一次</li>
<li><code>?</code> 代表前面的字元最多只可以出現一次，零次也可以<br><code>da?vid</code>，只要 <code>d or a</code> 出現或沒出現都可以。</li>
<li><code>*</code> 代表前面的字元出現或不出現都可以，也可以出現很多次。<br><code>d*avid</code>，<code>d</code> 想出現、重複、不出現都可以。</li>
<li><code>()</code> 優先順序，表示最優先<br>跟程式一樣</li>
<li><code>^</code> 必須在字首</li>
<li><code>$</code> 必須在字尾</li>
<li><code>[string]</code>，表示裡面其中一個字元有符合到都可以。</li>
<li><code>[a-z]</code>，只要 a 到 z 任意一個字元有就算符合。</li>
</ul>
<h2 id="一些題目或範例"><a href="#一些題目或範例" class="headerlink" title="一些題目或範例"></a>一些題目或範例</h2><p>都在 categories 分類中，<a href="https://theriseofdavid.github.io/categories/%E6%AD%A3%E8%A6%8F%E8%A1%A8%E7%A4%BA%E5%BC%8F-Regular-Expression/" target="_blank" rel="noopener">點這裡就可以看到很多範例</a></p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://zh.wikipedia.org/wiki/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F" target="_blank" rel="noopener">正規表示式 - wiki</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>雖然很早以前就知道正規表達式 Regular Expression，但是一直都沒有把他打成 blog，現在剛好用到就來打打，方便搜尋知識。</p>
<p>希望自己未來可以成為一個有用，成功的人！</p>
]]></content>
      <categories>
        <category>正規表示式 Regular Expression</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>正規表示式 Regular Expression</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces 1485C - Floor and Mod (設計解題、數學推理)</title>
    <url>/2021/02/22/Codeforces/Codeforces%201485C/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>有一種特殊的 pair(A,B)，定義這種 pair 必須符合 \([ \frac{a}{b} ] = a \ mod \ b\)</p>
<p>給你一個數字 x,y，其中特殊的 pair 數值必須是 \(1 \leq x \leq a \)、\(1 \leq y \leq  b\)，告訴我在這個範圍內有多少這種 pair 的數量。</p>
<p><a href="https://codeforces.com/contest/1485/problem/C" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li>數學邏輯推理</li>
<li>時間複雜度推測</li>
</ul>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>這題有難度XD，我被考倒了QQ。稍微看了下題目發現這是移項問題，只要移項移好腦袋清楚就可以把它成功解出了！</p>
<p>這題的 x,y 都是 \(10^9\)，有點刺激阿，由於 \(O(N) = 10^8\)，因此似乎這題時間複雜度要比 \(O(n)\) 還小。</p>
<p>codeforec 有很多人教學，在看了多遍後，能將這些話給講出來。</p>
<h3 id="StepA-推出-K-的範圍"><a href="#StepA-推出-K-的範圍" class="headerlink" title="StepA 推出 K 的範圍:"></a>StepA 推出 K 的範圍:</h3><p>我們可以定義 \( a \ mod \ b \) 出來的值為 k，因此 \([ \frac{a}{b} ] = a \ mod \ b = k\)</p>
<p>稍微進行移項，\( a = bk + k\)，其中 \(b &gt; k\)，否則不符合 \( [ \frac{a}{b} ]  = k \)</p>
<p>再來我們稍微進行粗略分析，\(bk+k &gt; k^2\)，我們前面有提到 \(b &gt; k\)，我們把所有的數學推導都拉出來寫寫看。</p>
<p>\(x \geq a = bk + k \geq k^2 \)，再來我們進行約分，收斂下後就可以得到 \(k \leq \sqrt{x}\)</p>
<h3 id="StepB-找出-b-的範圍"><a href="#StepB-找出-b-的範圍" class="headerlink" title="StepB 找出 b 的範圍:"></a>StepB 找出 b 的範圍:</h3><p>現在我們可以知道有特殊的 pair，範圍只在 \(1 \leq k \leq \sqrt{x}\) 、\(b &gt; k\)、 \(1 \leq kb+k \leq x\)，\(kb+k\) 是 \([\frac{a}{b}] = k\) 的移項。</p>
<p>再來我們進行推導，就可以將 \(1 \leq kb+k \leq x\) 推成 \(1 \leq b \leq x\k-1\)，同除 k，但 1 不變動，因為題目要求最小值是 1。</p>
<h3 id="StepC-找出公式"><a href="#StepC-找出公式" class="headerlink" title="StepC 找出公式"></a>StepC 找出公式</h3><p>再來我們可以推出一個算式，\(min(y,x/k-1) - k\)，我們這邊是在找有哪些 b 可以用，而不是再找有哪些方式 k 會符合，透過找有幾個 b 可以用來算出答案。</p>
<p>StepB 有說到 \(1 \leq b \leq x\k-1\)，但 y 不一定會小於 \(x\k-1\) 也不一定大於，因此特別用個 min 來找出最小值，找出最小的值。這裡是公式最重要最需要注意的地方。</p>
<p>減 k 則是 Step1 有說到，b 必須要大於 k，否則不滿足。</p>
<h3 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h3><p><a href="https://codeforces.com/blog/entry/87470" target="_blank" rel="noopener">Editorial of Codeforces Round #701 (Div. 2) - Codeforces By TheScrasse </a><br><a href="https://blog.csdn.net/qq_44791484/article/details/113832913?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-2&spm=1001.2101.3001.4242" target="_blank" rel="noopener">codeforces 1485 C Floor and Mod (枚举+推导) - CSDB by (xsj) </a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>這題真的很讚。</p>
<p>有好多的邏輯推導是我沒有被訓練過的，一時都沒有辦法學起來。老實講我沒有把握我現在就把這些都吸收完成，但我相信只要我多練習幾次，一定可以把這些問題都解開。</p>
<p>我希望我能夠成為一位優秀的解題大師，可以解出所有的問題。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1e10 <span class="comment">//題目最大值</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long <span class="comment">//用 long long 才不會 i*i 無法被 int 記下</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> x, y, n, ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y; <span class="comment">//輸入資料</span></span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i*i &lt; x; i++) ans += max(<span class="number">0l</span>l, min(x/i<span class="number">-1</span>, y) - i);</span><br><span class="line">        <span class="comment">//k 要小於 sqrt x，這裡的 k 是 i，再配合公式就可以得出答案</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>設計解題</tag>
        <tag>程式解題</tag>
        <tag>Codeforces</tag>
        <tag>數學推理</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces 1492C - Maximum width (二元搜尋)</title>
    <url>/2021/03/02/Codeforces/Codeforces%201492C/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>有兩個字串 s and t，題目定義一個 beautiful 的概念，beautiful 概念如下<br>必須 \(s_p_i = t_i\)，且 \(1 \leq p_1 &lt; p_2 &lt; … \leq n\)，一個 beautiful 概念應該是 \(max_{1 \leq i \leq m } (p_{i+1} - p_i\)</p>
<p>請你輸出最大的 beautiful width </p>
<p><a href="https://codeforces.com/contest/1492/problem/C" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li>二分搜尋</li>
<li>理解英文題目</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>其實就是按照題目的規則，將 t 字串的字元依照 t 的順序，分布在 s 的字串中，並且讓分布的其中一個距離最大，並且輸出他。</p>
<p>這樣要怎麼思考呢，很簡單，我們可以用二分搜尋來解決此問題。</p>
<p>我們先用一個陣列 \(p\) 表示如果我們都將 t 的字串放在 s 相同字元的最前面，再來我們只要能夠將 \(t_{i+1}\) 字元拉最遠，就可以達到我們的要求。</p>
<p>用 <code>upperbound</code> 讓 \(t_i\) 字串放在 s 相同字元的最前面並記錄在  \(p\)<br>用 <code>lowerbound</code> 找出 \(t_{i+1}\) 字元拉最遠的位置，在跟 \(t_i\) 相減就能記錄這次的最大長度。</p>
<h3 id="QUESTION-為甚麼找最前面用-upperbound，找最後面用-lowerbound-呢"><a href="#QUESTION-為甚麼找最前面用-upperbound，找最後面用-lowerbound-呢" class="headerlink" title="QUESTION: 為甚麼找最前面用 upperbound，找最後面用 lowerbound 呢"></a>QUESTION: 為甚麼找最前面用 <code>upperbound</code>，找最後面用 <code>lowerbound</code> 呢</h3><ul>
<li>第一點 <code>upperbound</code><br>那是因為 c++ 的特性，<code>lowerbound</code> 會找到 \(element \geq value\) 的值，如果 value 是剛剛的最左邊，那下個字元如果跟上個字元相同那下次的 <code>lowerbound</code> 也會找到同樣的左邊邊界，但實際必須加一，因此這裡用 upperbound 就沒有等於的情況。</li>
<li>第二點 <code>lowerbound</code><br>第二個點為甚麼要用 <code>lowerbound</code>，因為 <code>upperbound</code> 會找到 \(element &gt; value\) 的值，如果值是剛剛的最右邊 那下個字元如果跟上個字元相同那下次的 <code>upperbound</code>，也會找到同樣的右邊邊界，因此這邊改用 <code>lowerbound</code> 並且減一來減少此情況。<code>lowerbound</code> 有等於的情況就不會找到相同邊界，再透過減一表示跟剛剛的邊界不同。</li>
</ul>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://codeforces.com/blog/entry/87792?locale=en" target="_blank" rel="noopener">Codeforces Round #704 Editorial - ch_egor’s blog</a><br><a href="https://blog.csdn.net/tomjobs/article/details/114005919" target="_blank" rel="noopener">Codeforces-1492 C. Maximum width（构造）- tomjob </a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>這題我原本是想要我的方式來寫，透過字串壓縮來解決此題，但因為比賽時間只有 2hr，我寫前面的題目就來不及了後來就沒有將此題實現，後來看了其他人的寫法後覺得其他人的寫法更讚，因此學習然後寫一遍高手的寫法，讓我學習學習。</p>
<p>確實網路上永遠都會有人寫得比我更好，這種寫法讓我學起來，這樣會讓我學得更快！以後用得更好。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 0x3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">string</span> s, t; <span class="comment">//放題目的兩個字串</span></span><br><span class="line"><span class="keyword">int</span> n, m, pre = <span class="number">-1</span>, nxt = MAXN, num, ans;  </span><br><span class="line"><span class="comment">//pre 當前的最左邊邊界，nxt 當前的最右邊邊界</span></span><br><span class="line"><span class="keyword">int</span> p[MAXN]; <span class="comment">//每一個字元的最右邊邊界</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec[<span class="number">30</span>]; <span class="comment">//紀錄每個相同字元的 index，方便二分搜尋</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m; <span class="comment">//輸入資料</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s &gt;&gt; t;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123; <span class="comment">//將相同字元放入同樣 vector</span></span><br><span class="line">        num = s[i] - <span class="string">'a'</span>;</span><br><span class="line">        vec[num].push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123; <span class="comment">//對每個字元找出最左邊邊界</span></span><br><span class="line">        num = t[i] - <span class="string">'a'</span>; </span><br><span class="line">        p[i] = *upper_bound(vec[num].begin(), vec[num].end(), pre); </span><br><span class="line">        <span class="comment">//找最左邊邊界</span></span><br><span class="line">        <span class="comment">//cout &lt;&lt; "pre p[i] " &lt;&lt; i &lt;&lt; ' ' &lt;&lt; p[i] &lt;&lt; '\n';</span></span><br><span class="line">        pre = p[i];</span><br><span class="line">    &#125;</span><br><span class="line">    nxt = n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = m<span class="number">-1</span>; i &gt; <span class="number">0</span>; i--)&#123;</span><br><span class="line">        num = t[i] - <span class="string">'a'</span>;</span><br><span class="line">        p[i] = *--lower_bound(vec[num].begin(), vec[num].end(), nxt); <span class="comment">//找最右邊邊界</span></span><br><span class="line">        nxt = p[i]; <span class="comment">//將 p[i] 改為最右邊邊界，方便等等計算</span></span><br><span class="line">        <span class="comment">//cout &lt;&lt; "nxt p[i] " &lt;&lt; i &lt;&lt; ' ' &lt;&lt; p[i] &lt;&lt; '\n';</span></span><br><span class="line">        ans = max(ans, p[i] - p[i<span class="number">-1</span>]); <span class="comment">//比較哪個比較大</span></span><br><span class="line">        <span class="comment">//i 與 i-1，和 i+1 與 i 相同概念。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>; <span class="comment">//輸出答案</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>程式解題</tag>
        <tag>Binary Search 二分搜尋</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>演算法知識 - Segment Tree 線段樹</title>
    <url>/2021/03/06/Explain_Algorithm/segment-tree/</url>
    <content><![CDATA[<h2 id="Segment-Tree-線段樹-介紹"><a href="#Segment-Tree-線段樹-介紹" class="headerlink" title="Segment Tree 線段樹 介紹"></a>Segment Tree 線段樹 介紹</h2><blockquote>
<p>線段樹是一種二元樹型態的資料結構，通常用於需要大量查詢區間的問題，空間複雜度是 \(O(n)\)，查詢的時間複雜度則是 \(O(log \ n + k\)，k 為符合條件的區間數量</p>
<p>這種資料結構也能夠擴展到高維度</p>
<p><a href="https://zh.wikipedia.org/wiki/%E7%B7%9A%E6%AE%B5%E6%A8%B9" target="_blank" rel="noopener">線段樹 - wiki</a></p>
</blockquote>
<a id="more"></a>

<h2 id="Segment-Tree-線段樹-原理"><a href="#Segment-Tree-線段樹-原理" class="headerlink" title="Segment Tree 線段樹 原理"></a>Segment Tree 線段樹 原理</h2><blockquote>
<p>先透過一張圖進行解釋，這就是線段樹的原貌<br><img src="https://i.imgur.com/sC6SBjn.png" alt=""><br><a href="https://hackmd.io/@wiwiho/CPN-segment-tree" target="_blank" rel="noopener">師大附中校隊 hackmd 提供，如不願讓我使用請通知我</a></p>
</blockquote>
<p>為了方便好寫，通常我會將線段樹的區間設定為 \([1, n]\)，而非從零開始，但其實從零開始也可以實作成功。</p>
<p>線段樹一開始都會先到 root，之後根據我們所要查詢的區間往那方向進行查詢。</p>
<h4 id="舉例，查詢-3-5"><a href="#舉例，查詢-3-5" class="headerlink" title="舉例，查詢 \([3, 5]\)"></a>舉例，查詢 \([3, 5]\)</h4><ul>
<li>先查詢 \([0, 8]\)，向下找 \([0, 4]\)、\([5, 8]\)<ul>
<li>\([0, 4]\)，找  \([3, 4]\)，另外一邊則不再我們的查詢區間<ul>
<li>\([3, 4]\) 是在我們查詢的區間，不再往下查詢，直接回傳此答案</li>
</ul>
</li>
<li>\([5, 8]\)，查找 \([5, 6]\)，另外一邊則不再我們的查詢區間<ul>
<li>\([5, 6]\) 查詢 \([5, 5]\)，另外一邊則不再我們的查詢區間<ul>
<li>\([5, 5]\) 是在我們查詢的區間，不再往下查詢，直接回傳此答案</li>
</ul>
</li>
</ul>
</li>
<li>將前面兩個回傳的查詢，進行比較，取出最大 or 最小值，然後輸出。</li>
</ul>
</li>
</ul>
<p>主要就是線段樹的查詢過程</p>
<h3 id="結構型態"><a href="#結構型態" class="headerlink" title="結構型態"></a>結構型態</h3><p>線段樹的每個節點必須要有三個值，左邊邊界、右邊邊界、儲存的值。</p>
<p>需要值得注意的是，由於線段樹的底層是一顆二元樹，因此大小<strong>絕對不能只開一樣大</strong>，必須要開到 \(4 * n\)，至於為甚麼要開 \(4 * n\)，以下進行證明。</p>
<ul>
<li>一顆二元樹的葉節點假如是 \(2_i\)，\(i\) 為負整數</li>
<li>因此這棵樹所有節點不會大於 \(2^{i+1}\)，此證明如下<ul>
<li>第一層的節點是 1</li>
<li>第二層節點是第二層的兩倍，之後以此類推</li>
<li>得出公式 \(\sum_{i = 0}^{h-1} 2^i = 2^h-1\)，其中 h 為最大的深度，h-1 就表示非葉節點的最大深度</li>
<li>一個最簡單的證明就是 2 進位的 \(111_{(2)}\) 不會大於 \(1000_{(2)}\)，且\(1000_{(2)} - 1 = 111_{(2)}\) </li>
</ul>
</li>
<li>因此二元樹總節點會是 \(2^{h}-1 + 2^h\)，化簡後就是 \(2^{h+1} -1\)</li>
</ul>
<h4 id="證明參考"><a href="#證明參考" class="headerlink" title="證明參考"></a>證明參考</h4><blockquote>
<p><a href="http://wayne.cif.takming.edu.tw/datastru/tree.pdf" target="_blank" rel="noopener">資料結構的樹與二元樹（Trees and Binary Trees） -     林偉川老師 </a><br><a href="https://hackmd.io/@wiwiho/CPN-segment-tree" target="_blank" rel="noopener">師大附中校隊 hackmd </a></p>
</blockquote>
<blockquote>
<p>紹宇的證明提供，我在證明這裡時突然卡關，我好笨RRRR<br><img src="https://drive.google.com/u/2/uc?id=1DqmC6gLOn-nJJ7S8OOeiNNzaW2fzAUN3&export=download" alt=""></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> left; <span class="comment">// 左邊邊界</span></span><br><span class="line">    <span class="keyword">int</span> right; <span class="comment">//右邊邊界</span></span><br><span class="line">    <span class="keyword">int</span> value; <span class="comment">//儲存的值</span></span><br><span class="line">    <span class="keyword">int</span> z; <span class="comment">//區間修改用，如果沒有區間修改就不需要</span></span><br><span class="line">&#125;node[<span class="number">4</span> * N ];</span><br></pre></td></tr></table></figure>
<h2 id="透過實作來說明-Segment-Tree-線段樹"><a href="#透過實作來說明-Segment-Tree-線段樹" class="headerlink" title="透過實作來說明 Segment Tree 線段樹"></a>透過實作來說明 Segment Tree 線段樹</h2><p>這邊的問題則是給你一段數列，想請你告訴我們查詢的區間中最小值為何，下面的 <code>question()</code> 則是產生題目的數列。</p>
<h3 id="建立線段樹"><a href="#建立線段樹" class="headerlink" title="建立線段樹"></a>建立線段樹</h3><p>剛剛我們已經知道了節點數量的最大的大小，現在來進行建立的步驟。</p>
<p>我們要建立跟此網頁上第一張圖一樣的概念，直接透過程式碼說明，這邊我們要查詢的以最小值(min)為例。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Lson(x) (x &lt;&lt; 1) <span class="comment">//左子樹</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Rson(x) ((x &lt;&lt; 1) +1) <span class="comment">//右子樹</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">question</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) num[i] = i * <span class="number">123</span> % <span class="number">5</span>; </span><br><span class="line">    <span class="comment">// num 為題目產生的一段數列</span></span><br><span class="line">    <span class="comment">// hash 函數，讓 num 的 i 被隨機打亂</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> left , <span class="keyword">int</span> right , <span class="keyword">int</span> x = <span class="number">1</span> )</span></span>&#123; </span><br><span class="line">    <span class="comment">// left 為題目最大左邊界，right 為題目最大右邊界，圖片最上面的 root 為第一個節點</span></span><br><span class="line">    node[x].left = left ; <span class="comment">//給 x 節點左右邊界</span></span><br><span class="line">    node[x].right = right ;</span><br><span class="line">    <span class="keyword">if</span>(left == right)&#123; <span class="comment">//如果左右邊界節點相同，表示這裡是葉節點</span></span><br><span class="line">        node[x].value = num[left] ;  <span class="comment">//把 num 值給 node[x]</span></span><br><span class="line">        <span class="comment">//這裡的 num 值表示，我們要在 value 要放的值</span></span><br><span class="line">        <span class="keyword">return</span> ; <span class="comment">//向前返回</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (left + right ) / <span class="number">2</span> ; <span class="comment">//切半，產生二元樹</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//debug</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; mid &lt;&lt; '\n' ;</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; node[x].left &lt;&lt; ' ' &lt;&lt; node[x].right &lt;&lt; ' ' &lt;&lt; '\n' ;</span></span><br><span class="line"></span><br><span class="line">    build(left , mid , Lson(x)) ; <span class="comment">//將區間改為 [left, mid] 然後帶給左子樹</span></span><br><span class="line">    build(mid + <span class="number">1</span> , right , Rson(x)) ; <span class="comment">//將區間改為 [mid+1, right] 然後帶給右子樹</span></span><br><span class="line">    node[x].value = min(node[Lson(x)].value  , node[Rson(x)].value ) ;</span><br><span class="line">    <span class="comment">//查詢左右子樹哪個數值最小，並讓左右子樹最小值表示此區間最小數值。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="單點修改"><a href="#單點修改" class="headerlink" title="單點修改"></a>單點修改</h3><p>畢竟是線段樹，題目不可能數值都一成不變，有時候會進行變動，這裡我們將說明程式碼如何幫助線段樹進行單點修改。</p>
<p>基本上與建立相似，只是我們是先找到葉節點後，在向上比較，如果我們的值比較小就修改，沒有就保持原狀</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> position , <span class="keyword">int</span> value , <span class="keyword">int</span> x = <span class="number">1</span> )</span></span>&#123; <span class="comment">//修改數字</span></span><br><span class="line">    <span class="keyword">if</span>(node[x].left == position &amp;&amp; node[x].right == position )&#123; <span class="comment">//找到葉節點</span></span><br><span class="line">       node[x].value = value ; <span class="comment">//修改</span></span><br><span class="line">       <span class="keyword">return</span> ; <span class="comment">//傳回</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (node[x].left + node[x].right ) / <span class="number">2</span> ; <span class="comment">//切半，向下修改</span></span><br><span class="line">    <span class="keyword">if</span>(position &lt;= mid ) <span class="comment">//如果要修改的點在左邊，就往左下角追蹤</span></span><br><span class="line">        modify(position , value , Lson(x) );</span><br><span class="line">    <span class="keyword">if</span>(mid &lt; position ) <span class="comment">//如果要修改的點在右邊，就往右下角追蹤</span></span><br><span class="line">        modify(position , value , Rson(x)) ;</span><br><span class="line">    node[x].value = min(node[Lson(x)].value , node[Rson(x)].value );</span><br><span class="line">    <span class="comment">//比較左右子樹哪個值比較小，較小值為此節點的 value</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="區間修改"><a href="#區間修改" class="headerlink" title="區間修改"></a>區間修改</h3><p>線段樹中比較不好懂得部分，我們假設有一種題目是會把某個區間的值全加一個數字來進行舉例。</p>
<p>主要需要兩個 function 來寫</p>
<ul>
<li><code>push_down</code>，用來將先前的懶人標記往下推</li>
<li><code>update</code>，用來將一開始的區間推至線段樹<strong>適合的位置</strong></li>
</ul>
<p>假如我們要在區間 \([1, 10]\)，都進行加二，線段數的目標是找區間最小值，這時我們需要呼叫 <code>update</code>，幫助我們找到線段樹節點 \([1, 10]\)，把這邊的數值加二，並且給予一個懶人標記表示下面的所有子樹都沒有被進行加二，因此懶人標記就會是加二；如果之後會<strong>查詢、區間修改</strong>到其他值時，我們就會利用 <code>push_down</code> 讓<strong>下一層的子樹</strong>執行區間加二的指令。</p>
<p>那如果都不需要再向下查詢，那就讓懶人標記一直維持在此不需要對下面子樹進行更動，降低時間複雜度。</p>
<ul>
<li>如果不太懂可以看台大演算法線段樹區間修改教學，或是看我的程式碼來進行理解。<br><a href="https://www.csie.ntu.edu.tw/~sprout/algo2018/ppt_pdf/segment_tree_2.pdf" target="_blank" rel="noopener">Segment/Interval Tree - 2 by 林品諺</a></li>
</ul>
<p>但我很喜歡林品諺大佬的一句話，<strong>只在你需要的時候做事，有時候你不需要那麼勤勞</strong>。</p>
<p>我認為透過程式碼說明，勝過於簡單的文字說明。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> add)</span></span>&#123; <span class="comment">//將懶人標記往下推，讓下一層子樹進行區間修改</span></span><br><span class="line">    <span class="keyword">int</span> lson = Lson(x), rson = Rson(x);</span><br><span class="line">    node[lson].z += add;  <span class="comment">//給予懶人標記，表示子樹如果要給子樹的子樹區間修改時，</span></span><br><span class="line">    node[rson].z += add;  <span class="comment">//數值要是多少，左右子樹都需要做</span></span><br><span class="line"></span><br><span class="line">    node[lson].v += add; <span class="comment">//更新左右子樹的值</span></span><br><span class="line">    node[rson].v += add;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> cmd, <span class="keyword">int</span> x = <span class="number">1</span>)</span></span>&#123; </span><br><span class="line"><span class="comment">//a, b 為區間修改的 left and right, cmd 為要增加的數值 </span></span><br><span class="line">    <span class="keyword">if</span>(a &lt;= node[x].l &amp;&amp; b &gt;= node[x].r)&#123; </span><br><span class="line">        <span class="comment">//如果節點的 left and right，跟 a, b 區間是相等，或更小就，只要在這邊修改 cmd，</span></span><br><span class="line">        <span class="comment">//就可以讓 node[x].v 的值直接變為區間修改後的數值，</span></span><br><span class="line">        <span class="comment">//之後如果要讓這查詢向子樹進行區間修改，就用 push_down，</span></span><br><span class="line">        <span class="comment">//我們這邊的懶人標記就會告訴左右子樹要修改的值為多少</span></span><br><span class="line"></span><br><span class="line">        node[x].v += cmd; <span class="comment">//區間修改後的 v</span></span><br><span class="line">        node[x].z = cmd; <span class="comment">//區間修改是要增加多少數值</span></span><br><span class="line">        <span class="keyword">return</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    push_down(x);<span class="comment">//先將之前的區間查詢修改值，往下給子樹以避免上次的查詢值被忽略</span></span><br><span class="line">    <span class="comment">//假如當前的 node[x].z 原本是 3，如果沒有 push_down(x)，那下面的子樹都沒有被 +3，</span></span><br><span class="line">    <span class="comment">//導致答案不正確。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = (node[x].l+node[x].r) / <span class="number">2</span>;  <span class="comment">//切半，向下修改</span></span><br><span class="line">    <span class="keyword">if</span>(a &lt;= mid) update(a, b, cmd, Lson(x)); <span class="comment">//如果要修改的點在左邊，就往左下角追蹤</span></span><br><span class="line">    <span class="keyword">if</span>(b &gt; mid) update(a, b, cmd, Rson(x)); <span class="comment">//如果要修改的點在右邊，就往右下角追蹤</span></span><br><span class="line">    node[x].v = node[Lson(x)].v + node[Rson(x)].v;</span><br><span class="line">    <span class="comment">//比較左右子樹哪個值比較小，較小值為此節點的 value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="區間查詢"><a href="#區間查詢" class="headerlink" title="區間查詢"></a>區間查詢</h3><p>線段樹重要的部分，所有的線段樹一定會進行這個動作，但查詢的方式其實與二元樹相同，畢竟是透過二元樹建立的嘛XD。</p>
<p>我們將說明程式碼如何幫助線段樹進行區間查詢。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> left , <span class="keyword">int</span> right , <span class="keyword">int</span> x = <span class="number">1</span> )</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node[x].left &gt;= left &amp;&amp; node[x].right &lt;= right) </span><br><span class="line">        <span class="keyword">return</span> node[x].Min_Value ;</span><br><span class="line">    <span class="comment">//如果我們要查詢的區間比當前節點的區間大，那我們不需再向下查詢直接輸出此答案就好。</span></span><br><span class="line">    <span class="comment">// 例如我們要查詢 [2, 8]，我們只需要查詢 [3, 4]，不須查詢 [3, 3]、[4, 4]，</span></span><br><span class="line">    <span class="comment">// [3, 4] 已經做到最小值查詢</span></span><br><span class="line"></span><br><span class="line">    push_down(x);<span class="comment">//有區間修改時才需要寫    </span></span><br><span class="line">    <span class="keyword">int</span> mid = (node[x].left + node[x].right ) / <span class="number">2</span> ; <span class="comment">//切半，向下修改</span></span><br><span class="line">    <span class="keyword">int</span> ans = INF ; <span class="comment">//一開始先假設答案為最大值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( left &lt;= mid ) <span class="comment">//如果切半後，我們要查詢的區間有在左子樹就向下查詢</span></span><br><span class="line">        ans = min(ans , query(left , right , Lson(x))) ; <span class="comment">//更新答案，比較誰比較小</span></span><br><span class="line">    <span class="keyword">if</span>(mid &lt; right ) <span class="comment">//如果切半後，我們要查詢的區間有在右子樹就向下查詢</span></span><br><span class="line">        ans = min(ans , query(left , right , Rson(x))) ; <span class="comment">//更新答案，比較誰比較小</span></span><br><span class="line">    <span class="keyword">return</span> ans ; <span class="comment">//回傳答案</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="不可離散化的-Segment-Tree-線段樹"><a href="#不可離散化的-Segment-Tree-線段樹" class="headerlink" title="不可離散化的 Segment Tree 線段樹"></a>不可離散化的 Segment Tree 線段樹</h3><p>有時候會遇到一些題目的 n 可能大於 \(10^9\)，在 C++ 沒有辦法承擔那麼大的陣列大小時，我們可以用指標來解決這個問題，或是改使用 linklist 的方式，減少因為離散化而大量設定陣列值的問題。</p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><blockquote>
<p><a href="http://wayne.cif.takming.edu.tw/datastru/tree.pdf" target="_blank" rel="noopener">資料結構的樹與二元樹（Trees and Binary Trees） -     林偉川老師 </a><br><a href="https://hackmd.io/@wiwiho/CPN-segment-tree" target="_blank" rel="noopener">師大附中校隊 hackmd </a><br><a href="https://www.csie.ntu.edu.tw/~sprout/algo2018/ppt_pdf/segment_tree_2.pdf" target="_blank" rel="noopener">Segment/Interval Tree - 2 by 林品諺</a></p>
</blockquote>
<blockquote>
<p>紹宇的證明提供，我在證明這裡時突然卡關，我好笨RRRR<br><img src="https://drive.google.com/u/2/uc?id=1DqmC6gLOn-nJJ7S8OOeiNNzaW2fzAUN3&export=download" alt=""></p>
</blockquote>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>好久沒有複習線段樹了，透過這此的編寫讓我把線段樹也重新複習了一遍，老實講我常常會覺得自己寫這些東西似乎沒用，畢竟我走資財，寫這些東西可能只能夠在純資的環境上使用，但我是資財的學生，我不知道自己到底用不用的到。</p>
<p>老實講，自己在高中學到的東西，非常快樂，非常充實。但在大學時感覺不到有一群跟我一樣愛好的人一起努力奮鬥，大家都有自己的目標要奮鬥，大家的目標不再只有那麼單一，都很多樣，有時候會讓我迷失方向，會讓我覺得我做這些事情有意義嗎。</p>
<h2 id="Segment-Tree-線段樹-無註解程式碼"><a href="#Segment-Tree-線段樹-無註解程式碼" class="headerlink" title="Segment Tree 線段樹 無註解程式碼"></a>Segment Tree 線段樹 無註解程式碼</h2><p>這裡則放置沒有註解的程式碼，如果讀者想要複製就從這裡進行複製吧！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Lson(x) (x &lt;&lt; 1) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Rson(x) ((x &lt;&lt; 1) +1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 題目陣列最大長度</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> left;</span><br><span class="line">    <span class="keyword">int</span> right; </span><br><span class="line">    <span class="keyword">int</span> value; </span><br><span class="line">    <span class="keyword">int</span> z; <span class="comment">//不須區間修改就不用寫</span></span><br><span class="line">&#125;node[<span class="number">4</span> * N ]; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">question</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) num[i] = i * <span class="number">123</span> % <span class="number">5</span>; </span><br><span class="line">    <span class="comment">// num 為題目產生的一段數列</span></span><br><span class="line">    <span class="comment">// hash 函數，讓 num 的 i 被隨機打亂</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> left , <span class="keyword">int</span> right , <span class="keyword">int</span> x = <span class="number">1</span> )</span></span>&#123; </span><br><span class="line">    node[x].left = left ;</span><br><span class="line">    node[x].right = right ;</span><br><span class="line">    <span class="keyword">if</span>(left == right)&#123; </span><br><span class="line">        node[x].value = num[left] ; </span><br><span class="line">        <span class="keyword">return</span> ; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (left + right ) / <span class="number">2</span> ; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//debug</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; mid &lt;&lt; '\n' ;</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; node[x].left &lt;&lt; ' ' &lt;&lt; node[x].right &lt;&lt; ' ' &lt;&lt; '\n' ;</span></span><br><span class="line"></span><br><span class="line">    build(left , mid , Lson(x)) ; </span><br><span class="line">    build(mid + <span class="number">1</span> , right , Rson(x)) ;</span><br><span class="line">    node[x].value = min(node[Lson(x)].value  , node[Rson(x)].value ) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> position , <span class="keyword">int</span> value , <span class="keyword">int</span> x = <span class="number">1</span> )</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node[x].left == position &amp;&amp; node[x].right == position )&#123;</span><br><span class="line">       node[x].value = value ;</span><br><span class="line">       <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (node[x].left + node[x].right ) / <span class="number">2</span> ; </span><br><span class="line">    <span class="keyword">if</span>(position &lt;= mid ) </span><br><span class="line">        modify(position , value , Lson(x) );</span><br><span class="line">    <span class="keyword">if</span>(mid &lt; position )</span><br><span class="line">        modify(position , value , Rson(x)) ;</span><br><span class="line">    node[x].value = min(node[Lson(x)].value , node[Rson(x)].value );</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> add)</span></span>&#123; <span class="comment">//將懶人標記往下推</span></span><br><span class="line">    <span class="keyword">int</span> lson = Lson(x), rson = Rson(x);</span><br><span class="line">    node[lson].z = add;</span><br><span class="line">    node[rson].z = add;</span><br><span class="line"></span><br><span class="line">    node[lson].v += add;</span><br><span class="line">    node[rson].v += add;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> cmd, <span class="keyword">int</span> x = <span class="number">1</span>)</span></span>&#123; </span><br><span class="line">    <span class="keyword">if</span>(a &lt;= node[x].l &amp;&amp; b &gt;= node[x].r)&#123; </span><br><span class="line">        node[x].v += cmd;</span><br><span class="line">        node[x].z = cmd;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    push_down(x); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = (node[x].l+node[x].r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(a &lt;= mid) update(a, b, cmd, Lson(x));</span><br><span class="line">    <span class="keyword">if</span>(b &gt; mid) update(a, b, cmd, Rson(x));</span><br><span class="line">    node[x].v = min(node[Lson(x)].v , node[Rson(x)].v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> left , <span class="keyword">int</span> right , <span class="keyword">int</span> x = <span class="number">1</span> )</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node[x].left &gt;= left &amp;&amp; node[x].right &lt;= right) </span><br><span class="line">        <span class="keyword">return</span> node[x].value ;</span><br><span class="line">    push_down(x);<span class="comment">//有區間修改時才需要寫</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> mid = (node[x].left + node[x].right ) / <span class="number">2</span> ; </span><br><span class="line">    <span class="keyword">int</span> ans = INF ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( left &lt;= mid ) </span><br><span class="line">        ans = min(ans , query(left , right , Lson(x))) ; </span><br><span class="line">    <span class="keyword">if</span>(mid &lt; right ) </span><br><span class="line">        ans = min(ans , query(left , right , Rson(x))) ; </span><br><span class="line">    <span class="keyword">return</span> ans ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>演算法知識</category>
      </categories>
      <tags>
        <tag>程式解題</tag>
        <tag>演算法知識</tag>
        <tag>線段樹 Segment Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa11235 - Frequent values(線段樹)</title>
    <url>/2021/03/04/UVa/UVa11235/</url>
    <content><![CDATA[<h1 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h1><blockquote>
<p>有一個非遞增的數列，雖然非遞增，但前一個數值必會小於等於這個數值，我們要查詢一個區間，想詢問這個區間中最常出現的數字次數是多少？</p>
<p><a href="https://onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=2176" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li>線段樹的學習與應用<br>如果需要學習演算法，請參考 <a href="https://theriseofdavid.github.io/2021/03/06/Explain_Algorithm/segment-tree/" target="_blank" rel="noopener">大衞的筆記 - Segment Tree 線段樹</a></li>
<li>對於題目的仔細閱讀</li>
<li>我們線段樹應該要保存甚麼數值，才能解決此題</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>只要遇到需要查詢區間的問題一律就要想到線段樹，線段樹的時間複雜度可以來到 \(O(n \ log \ n\)，能夠打遍百分之 90 的題目，但這邊有些小技巧要解決。</p>
<p>這題要在線段樹裡面存的就是題目所需要的出現次數，但可能會有一種疑問<br>Q: 1,2,3,3,3,3,4，如果我要找區間 \([4,5]\) 要怎麼辦呢，這裡 index 從 1 開始。</p>
<p>這個時候題目給了我們一個很大的提示，題目有說<strong>前一個數值必會小於等於這個數值</strong>，因此我們可以視為相同的數字只會出現在同個區段且不會再有其他區段重複。</p>
<p>區段： 1,1,1,1，這種連續數字在一塊地，定義為區塊</p>
<h3 id="解決方法"><a href="#解決方法" class="headerlink" title="解決方法"></a>解決方法</h3><p>我們透過舉例來說明這種解決方式，用題目測資來說明</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">index:  1   2  3  4  5  6  7   8   9  10</span><br><span class="line">value: -1  -1  1  1  1  1  3  10  10  10</span><br><span class="line">fre:    2   2  4  4  4  4  1   3   3   3</span><br><span class="line"></span><br><span class="line">left:   1   1  2  2  2  2  7   8   8   8    </span><br><span class="line">right:  2   2  6  6  6  6  6  10  10  10</span><br></pre></td></tr></table></figure>

<p>如果我們要查詢的區間是 \([4,9]\)，此時如果按照存區塊最大值時答案會是 4，但這裡的區間不應該有 4，答案要是 3，遇到這種問題就很棘手XD。</p>
<p>但還是有辦法的，我們紀錄每個區塊的右邊界與左邊界，如果我們查詢的<strong>區間</strong>比起<strong>區塊</strong>還要小的時候就可以讓<strong>區塊的右邊界</strong>減去<strong>區間的左邊界</strong>，或<strong>區間的右邊界</strong>減去<strong>區塊的左邊界</strong>，這樣就可以避免掉區間查詢查到 4 的情況。</p>
<p>而且我們只要在一開始的去判斷這種區間切到區塊的問題，之後就不需要，我們可以將要查詢的範圍減掉左右兩區間所切到的區塊，依照範例就是變為 \([7,7]\)，\([4,6]) 則是被切掉的左區間、\([8,9]]\) 則是被切掉的右區間，那麼縮小範圍後的<strong>區間</strong>裡面必包含完整區塊。畢竟裡面的區塊我們都沒有動到，所以都是完整的，也不存在不完整的情況發生。<br>不完整的區間只有在一開始的查詢區間有可能出現。</p>
<p>這時我們再進行線段樹查詢找出最大出現數字次數，就能夠成功找到答案！</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。 </p>
<p>至於 <a href="https://theriseofdavid.github.io/2021/03/06/Explain_Algorithm/segment-tree/" target="_blank" rel="noopener">大衞的筆記 - Segment Tree 線段樹</a> 有做說明的部分，這邊就不在進行說明。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Lson(x) x &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Rson(x) (x &lt;&lt; 1) + 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100020</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, q, ta, tb;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tree</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, v; <span class="comment">//將 left right value 進行簡化為 l r v</span></span><br><span class="line">    tree()&#123;&#125;</span><br><span class="line">    tree(<span class="keyword">int</span> _l, <span class="keyword">int</span> _r, <span class="keyword">int</span> _v): l(_l), r(_r), v(_v) &#123;&#125;</span><br><span class="line">&#125;node[<span class="number">4</span> * MAXN];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NUM</span>&#123;</span> <span class="comment">//用來儲存區塊</span></span><br><span class="line">    <span class="keyword">int</span> l, r, f, v; </span><br><span class="line">    <span class="comment">// l 區塊的左邊界</span></span><br><span class="line">    <span class="comment">// r 區塊的右邊界</span></span><br><span class="line">    <span class="comment">// f 區塊有多長</span></span><br><span class="line">    <span class="comment">// v 區塊的數值</span></span><br><span class="line">&#125;num[MAXN];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> x = <span class="number">1</span>)</span></span>&#123;</span><br><span class="line">    node[x].l = left;</span><br><span class="line">    node[x].r = right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(left == right)&#123;</span><br><span class="line">        node[x].v = num[left].f; <span class="comment">//區塊有多長，題目詢問的重點</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">    build(left, mid, Lson(x));</span><br><span class="line">    build(mid + <span class="number">1</span>, right, Rson(x));</span><br><span class="line">    node[x].v = max(node[Lson(x)].v, node[Rson(x)].v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> x = <span class="number">1</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num[left].v == num[right].v) <span class="keyword">return</span> right - left + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//題目所查詢的區間，剛好在同個區塊上，num[left].v == num[right].v 表示數值相同也就代表區塊相同</span></span><br><span class="line">    <span class="comment">// 因此只需要拿左區間邊界減去右區間邊界加一就可以得到答案</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(left &gt; num[left].l)&#123; <span class="comment">//查詢的左區間邊界切到區塊，且此區間有數個區塊</span></span><br><span class="line">        ans = num[left].r - left + <span class="number">1</span>; <span class="comment">//計算切到的區間大小</span></span><br><span class="line">        <span class="comment">//方法是查詢被切到的區塊右邊界減去左區間邊界加一</span></span><br><span class="line">        left = num[left].r + <span class="number">1</span>; <span class="comment">//將左區間邊界移至被切區塊的右邊界加一，就不會切到區塊</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(right &lt; num[right].r)&#123; <span class="comment">//查詢的右區間邊界切到區塊，且此區間有數個區塊</span></span><br><span class="line">        ans = max(right - num[right].l + <span class="number">1</span>, ans); <span class="comment">//計算切到的區間大小，並找出最大</span></span><br><span class="line">        <span class="comment">//方法是查詢的右邊界減掉區塊左邊界加一</span></span><br><span class="line">        right = num[right].l - <span class="number">1</span>; <span class="comment">//將右區間邊界移至被切區塊的左邊界減一，就不會切到區塊</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; "left right ans " &lt;&lt; left &lt;&lt; ' ' &lt;&lt; right &lt;&lt; ' ' &lt;&lt; ans &lt;&lt; '\n';</span></span><br><span class="line">    <span class="keyword">if</span>(left &gt; right ) <span class="keyword">return</span> ans; <span class="comment">//如果左邊界大於右邊界，表示不需要再進行查詢直接回傳答案</span></span><br><span class="line">    <span class="comment">//由於上面的 +1、-1，因此有機會出現左邊界大於右邊界的情形。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(node[x].l &gt;= left &amp;&amp; node[x].r &lt;= right ) <span class="keyword">return</span> node[x].v; </span><br><span class="line">    <span class="keyword">int</span> mid = (node[x].l + node[x].r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(left &lt;= mid) ans = max(ans, query(left, right, Lson(x)));</span><br><span class="line">    <span class="keyword">if</span>(mid &lt; right) ans = max(ans, query(left, right, Rson(x)));</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug_num</span><span class="params">()</span></span>&#123; <span class="comment">//debug 用 無意義</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">' '</span> &lt;&lt; num[i].l &lt;&lt; <span class="string">' '</span> &lt;&lt; num[i].r &lt;&lt; <span class="string">' '</span> &lt;&lt; num[i].v &lt;&lt; <span class="string">' '</span> &lt;&lt; num[i].f &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug_build</span><span class="params">()</span></span>&#123; <span class="comment">//debug 用 無意義</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">' '</span> &lt;&lt; node[i].l &lt;&lt; <span class="string">' '</span> &lt;&lt; node[i].r &lt;&lt; <span class="string">' '</span> &lt;&lt; node[i].v &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"out.txt"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">1</span>, e; <span class="comment">//長度的 start ，長度的 end</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; q &amp;&amp; n + q != <span class="number">0</span>)&#123; <span class="comment">//輸入資料，並且注意查詢可以為 0，因此 n + q 必須 != 0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123; <span class="comment">//書資料</span></span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; ta;</span><br><span class="line">            num[i].v = ta; <span class="comment">//值設定 ta</span></span><br><span class="line">            <span class="keyword">if</span>(num[i].v != num[i<span class="number">-1</span>].v)&#123; <span class="comment">//如果現在的值與前面的值不同，表示不同區塊</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = s; j &lt; i; j++)&#123; <span class="comment">//將前面的區塊的左邊界、右邊界、長度進行設定。</span></span><br><span class="line">                    num[j].l = s; <span class="comment">//設定左邊界</span></span><br><span class="line">                    num[j].r = i<span class="number">-1</span>; <span class="comment">//設定右邊界，i-1 是因為 i 已經是不同區塊 </span></span><br><span class="line">                    num[j].f = i - s; <span class="comment">//設定長度</span></span><br><span class="line">                &#125;</span><br><span class="line">                s = i; <span class="comment">//更新下個區塊的左邊界</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = s; j &lt;= n; j++)&#123; <span class="comment">//最後一個區塊必須拉出來寫，因為後面沒有數值來進行分裂</span></span><br><span class="line">            num[j].l = s;</span><br><span class="line">            num[j].r = n;</span><br><span class="line">            num[j].f = n - s + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//debug_num();</span></span><br><span class="line">        build(<span class="number">1</span>, n);</span><br><span class="line">        <span class="comment">//debug_build();</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; q; i++)&#123; <span class="comment">//輸出結果</span></span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; ta &gt;&gt; tb;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; query(ta, tb) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="http://naivered.github.io/2018/05/20/Problem_Solving/UVa/UVa-11235-Frequent-values/" target="_blank" rel="noopener">UVa 11235 - Frequent values - naivered</a><br><a href="https://algorithmist.com/wiki/Main_Page" target="_blank" rel="noopener">algorithmist wiki</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>這題複習了我很久沒有練習的線段樹，演算法太久沒有碰真的會忘記，今天在複習線段樹的時後一直卡卡的，腦袋還沒有喚醒記憶，透過今天的複習把記憶在喚醒！</p>
<p>這題的小巧思好棒，雖然我沒有在很短的時間想到怎麼解，但我透過學習 naivered 大大的想法，得知還有這種解法，希望我學習了這種解法能夠讓我在未來的路上用上！</p>
<p>題外話：人生一定要學習有意義的事情嗎？ 怎樣的事情算有意義。</p>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>線段樹 Segment Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa11402 - Ahoy, Pirates!(線段樹)</title>
    <url>/2021/03/10/UVa/UVa11402/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>在一個海盜島上有許多的海盜，它們都有被編號(從 0 至 n)，且它們都有一個陣營，此海盜島上只有兩個陣營 Buccaneer、Barbary。</p>
<p>現在來了一個大魔法師，他可以將從 0 ~ n 的人變成 Buccaneer or Barbary 陣營的人或是把某區間的人陣營對調，原本是 Buccaneer 變為 Barbary，Barbary 變為 Buccaneer</p>
<p>神知道有這件事情後，非常生氣，他會問大魔法師一個區間內有幾個 Buccaneer 海盜，沒有就殺了他，所以請幫忙解決此問題吧！</p>
<p><a href="https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2397" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li>線段樹的學習與應用<br>如果需要學習演算法，請參考 <a href="https://theriseofdavid.github.io/2021/03/06/Explain_Algorithm/segment-tree/" target="_blank" rel="noopener">大衞的筆記 - Segment Tree 線段樹</a></li>
<li>對於題目的仔細閱讀</li>
<li>這題需要用到線段樹的高深操作，<strong>區間修改</strong>、<strong>懶人標記</strong></li>
<li>題目的指令在線段樹的懶人標記時，要如何判斷誰先誰後 (<strong>非常重要</strong>，它讓我花了 12hr 思考)</li>
<li>題目的指令優化 (<strong>非常重要</strong>，它讓我花了 12hr 思考)</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>好題，好題…，它讓我學到了一堆知識，雖然也讓我一堆時間飛走了QQQ。</p>
<p>這題比較麻煩的是要判斷 segment tree 懶人標記時，要如何判斷其先後順序，如果先將 0<del>n 的人全部變成 Buccaneer 在對調，與先對調在將 0</del>n 的人全部變成 Buccaneer，是不一樣的結果，因此我們在 <code>push_down</code> 跟 <code>mod2</code> 都需要比較多的處理，來判斷假如現在懶人標記是怎樣的情況時，我們現在又有這個指令時會對下面的子樹造成的影響是甚麼。</p>
<ul>
<li>定義 <code>1</code> 為把區間的人變成 Buccaneer</li>
<li>定義 <code>0</code> 為把區間的人變成 Barbary</li>
<li>定義 <code>2</code> 為區間的人對調</li>
</ul>
<h3 id="可以找出順序"><a href="#可以找出順序" class="headerlink" title="可以找出順序"></a>可以找出順序</h3><ul>
<li>如果先進行 <code>2</code> 再進行 <code>0</code>，那就不需要進行 <code>2</code>，只需要進行 <code>0</code></li>
<li>如果先進行 <code>2</code> 再進行 <code>1</code>，那就不需要進行 <code>2</code>，只需要進行 <code>1</code></li>
<li>如果先進行 <code>2</code> 再進行 <code>2</code>，那完全不需要改動下面子樹</li>
<li>如果先進行 <code>1</code> 再進行 <code>2</code>，那就只需要進行 <code>0</code></li>
<li>如果先進行 <code>0</code> 再進行 <code>2</code>，那就只需要進行 <code>1</code></li>
<li>如果先進行 <code>1</code> 再進行 <code>0</code>，那就只需要進行 <code>0</code></li>
<li>如果先進行 <code>0</code> 再進行 <code>1</code>，那就只需要進行 <code>1</code></li>
</ul>
<p>OK，現在知道進行區間修改時如果有兩個指令卡在同個節點時，我們就可以用這些規則來告訴下面子樹要進行甚麼規則。</p>
<p>那這樣就能夠透過 <code>query</code> 找到正確答案了！動手寫程式碼八</p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://www.csie.ntu.edu.tw/~sprout/algo2018/ppt_pdf/segment_tree_2.pdf" target="_blank" rel="noopener">Segment/Interval Tree - 2 by 林品諺</a><br><a href="https://yuihuang.com/uva-11402/" target="_blank" rel="noopener">【題解】UVA 11402 Ahoy, Pirates! by YUI HUANG</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>這題真的是很棒的好題，像這樣的順序，我直接大卡關….，我花了將近 4hr 在想這些順序問題，後來真的受不了了看 YUI HUANG 的題解，發現是我自作多情，我把她想太難了！不一定要每個步驟都做，可以把它們合併再讓子樹進行一個動作就好…，原先還想要對此線段樹紀錄 queue，來記錄順序然後進行區間查詢，結果記憶體爆了…。</p>
<p>後面把 queue 改成 string 則是超時，非常建議大家不要亂魔改資料結構阿QQQ，設計出來不是做此用途就不要亂用QQQ，就算用成功了也不一定可以成功，可能會有超時的問題…。</p>
<p>不過你是大發明家就不要記住我的話拉，我是笨蛋，只能靠努力的那種。</p>
<p>總之希望自己的未來可以一片光明，每天在不安感度過的感覺真的好可怕，希望自己學習的演算法與資料結構未來可以幫助我在人生的路上！</p>
<p>不然學習了這麼多的演算法，結果都沒用上，會不會有可能太不值了呢？</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。 </p>
<p>至於 <a href="https://theriseofdavid.github.io/2021/03/06/Explain_Algorithm/segment-tree/" target="_blank" rel="noopener">大衞的筆記 - Segment Tree 線段樹</a> 有做說明的部分，這邊就不在進行說明。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1024200</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Lson(x) x&lt;&lt;1 /</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Rson(x) (x&lt;&lt;1)+1</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> t, n, m, a, b, Qcnt, q, kase, len;</span><br><span class="line"><span class="comment">//題目資料， qcnt 是每次測試資料的 q 的查詢次數</span></span><br><span class="line"><span class="comment">//len //題目的海盜數值長度，也是計算當前 num 最大的長度</span></span><br><span class="line"><span class="keyword">int</span> num[MAXN]; <span class="comment">//用來記錄海盜的陣營</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tree</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, v, z; <span class="comment">//其中 z 為懶人標記，z 的 0,1,2 為操作的意思，-1 表示沒有需要操作</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123; <span class="comment">//無意義，debug 用</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"l = "</span> &lt;&lt; l &lt;&lt; <span class="string">" r = "</span> &lt;&lt; r &lt;&lt; <span class="string">" v = "</span> &lt;&lt; v &lt;&lt; <span class="string">" z = "</span> &lt;&lt; z &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;node[MAXN*<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x = <span class="number">1</span>)</span></span>&#123; <span class="comment">//線段樹的 function build</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//cout &lt;&lt; "x = " &lt;&lt; x &lt;&lt; " l = " &lt;&lt; l &lt;&lt; " r = " &lt;&lt; r &lt;&lt; '\n';</span></span><br><span class="line">    node[x].l = l;</span><br><span class="line">    node[x].r = r;</span><br><span class="line">    node[x].z = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">        node[x].v = num[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">    build(l, mid, Lson(x));</span><br><span class="line">    build(mid+<span class="number">1</span>, r, Rson(x));</span><br><span class="line">    node[x].v = node[Lson(x)].v + node[Rson(x)].v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mod1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> cmd)</span></span>&#123; <span class="comment">//方法 1，也就是定義操作的 0 and 1，線段樹的 function update</span></span><br><span class="line">    <span class="keyword">int</span> lson = Lson(x), rson = Rson(x); <span class="comment">//定義左子樹與右子樹位置</span></span><br><span class="line">    node[lson].z = cmd; <span class="comment">//更改懶人標記，規則上面有提到，直接更改不需要判斷先後順序</span></span><br><span class="line">    node[rson].z = cmd;</span><br><span class="line"></span><br><span class="line">    node[lson].v = (node[lson].r-node[lson].l+<span class="number">1</span>) * cmd; <span class="comment">//計算數值，一個小技巧，題目的 1 剛好就是要查詢的數量，</span></span><br><span class="line">    node[rson].v = (node[rson].r-node[rson].l+<span class="number">1</span>) * cmd; <span class="comment">//因此我們直接用 * 1 or * 0，就可以算值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mod2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> cmd)</span></span>&#123; <span class="comment">//方法 2，也就是定義操作的 2，線段樹的 function update</span></span><br><span class="line">    <span class="keyword">int</span> lson = Lson(x), rson = Rson(x);  <span class="comment">//定義左子樹與右子樹位置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//更改懶人標記，規則上面有提到，直接更改不需要判斷先後順序</span></span><br><span class="line">    <span class="keyword">if</span>(node[lson].z == <span class="number">2</span>) node[lson].z = <span class="number">-1</span>; </span><br><span class="line">    <span class="comment">//上述有說到的規則，如果先進行 ``2`` 再進行 ``2``，那完全不需要改動下面子樹</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(node[lson].z != <span class="number">-1</span>) node[lson].z ^= <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//如果先進行 ``0`` 再進行 ``2``，那就只需要進行 ``1``</span></span><br><span class="line">    <span class="comment">//如果先進行 ``1`` 再進行 ``2``，那就只需要進行 ``0``</span></span><br><span class="line">    <span class="keyword">else</span> node[lson].z = cmd;</span><br><span class="line">    <span class="comment">//不需要合併操作，所以就直接寫</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(node[rson].z == <span class="number">2</span>) node[rson].z = <span class="number">-1</span>; <span class="comment">//與上面相同，只是子樹換另外一邊</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(node[rson].z != <span class="number">-1</span>) node[rson].z ^= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> node[rson].z = cmd;</span><br><span class="line"></span><br><span class="line">    node[lson].v = (node[lson].r-node[lson].l+<span class="number">1</span>) - node[lson].v;  </span><br><span class="line">    <span class="comment">//對調，於是先算出區間最大數量減掉當前數量就是對調的數值</span></span><br><span class="line">    node[rson].v = (node[rson].r-node[rson].l+<span class="number">1</span>) - node[rson].v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="comment">//線段樹的 push_down function build</span></span><br><span class="line">    <span class="keyword">if</span>(node[x].z == <span class="number">0</span>) mod1(x, <span class="number">0</span>); <span class="comment">//z = 0 就去 mod1，其中 z 的值表示操作 x</span></span><br><span class="line">    <span class="keyword">if</span>(node[x].z == <span class="number">1</span>) mod1(x, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(node[x].z == <span class="number">2</span>) mod2(x, <span class="number">2</span>);</span><br><span class="line">    node[x].z = <span class="number">-1</span>; <span class="comment">//向下延伸完畢，現在改為 -1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_mod1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> cmd, <span class="keyword">int</span> x = <span class="number">1</span>)</span></span>&#123; <span class="comment">//線段樹的 push_down function update</span></span><br><span class="line"><span class="comment">//詳細請看大衛的演算法，這邊是把方法拉出來寫</span></span><br><span class="line">    <span class="keyword">if</span>(a &lt;= node[x].l &amp;&amp; b &gt;= node[x].r)&#123;</span><br><span class="line">        node[x].v = (node[x].r-node[x].l+<span class="number">1</span>) * cmd;</span><br><span class="line">        node[x].z = cmd;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    push_down(x);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = (node[x].l+node[x].r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(a &lt;= mid) push_mod1(a, b, cmd, Lson(x));</span><br><span class="line">    <span class="keyword">if</span>(b &gt; mid) push_mod1(a, b, cmd, Rson(x));</span><br><span class="line">    node[x].v = node[Lson(x)].v + node[Rson(x)].v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_mod2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> cmd, <span class="keyword">int</span> x = <span class="number">1</span>)</span></span>&#123; <span class="comment">//線段樹的 push_down function update</span></span><br><span class="line"><span class="comment">//詳細請看大衛的演算法，這邊是把方法拉出來寫</span></span><br><span class="line">    <span class="keyword">if</span>(a &lt;= node[x].l &amp;&amp; b &gt;= node[x].r)&#123;</span><br><span class="line">        node[x].v = (node[x].r-node[x].l+<span class="number">1</span>) - node[x].v;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(node[x].z == <span class="number">2</span>) node[x].z = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (node[x].z != <span class="number">-1</span>) node[x].z ^= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> node[x].z = cmd;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    push_down(x);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = (node[x].l+node[x].r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(a &lt;= mid) push_mod2(a, b, cmd, Lson(x));</span><br><span class="line">    <span class="keyword">if</span>(b &gt; mid) push_mod2(a, b, cmd, Rson(x));</span><br><span class="line">    node[x].v = node[Lson(x)].v + node[Rson(x)].v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x = <span class="number">1</span>)</span></span>&#123; <span class="comment">//線段樹的 query function </span></span><br><span class="line">    <span class="keyword">if</span>(node[x].l &gt;= l &amp;&amp; node[x].r &lt;= r) <span class="keyword">return</span> node[x].v;</span><br><span class="line">    push_down(x);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = (node[x].l+node[x].r) / <span class="number">2</span>, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid) ans += query(l, r, Lson(x));</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid) ans += query(l, r, Rson(x));</span><br><span class="line">    <span class="comment">//cout &lt;&lt; "q x = " &lt;&lt; x &lt;&lt; " ans = " &lt;&lt; ans &lt;&lt; '\n';</span></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="built_in">string</span> temp;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123; </span><br><span class="line">        Qcnt = <span class="number">1</span>; <span class="comment">//先定義題目的查詢數量</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Case "</span> &lt;&lt; ++kase &lt;&lt; <span class="string">":\n"</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        len = <span class="number">1</span>; <span class="comment">//題目的海盜數值長度</span></span><br><span class="line">        <span class="keyword">while</span>(n--)&#123; <span class="comment">//輸入題目特別的格式，字串重複 n 次，用 0,1 表示海盜的陣營</span></span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; m &gt;&gt; temp;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123; <span class="comment">//重複 n 次此字串</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; temp.length(); j++) num[len++] = temp[j] - <span class="string">'0'</span>;</span><br><span class="line">                <span class="comment">//把字串的值給 num</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        build(<span class="number">1</span>, len);</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; q; <span class="comment">//題目資料</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; q; i++)&#123; <span class="comment">//題目的指令</span></span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; temp &gt;&gt; a &gt;&gt; b; <span class="comment">//輸入資料</span></span><br><span class="line">            a++; b++; <span class="comment">//index start from 1，由於題目 index 從 0 開始，我們線段樹從 1 開始</span></span><br><span class="line">            <span class="keyword">if</span>(temp == <span class="string">"F"</span>) push_mod1(a, b, <span class="number">1</span>); <span class="comment">//F 是操作 1</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(temp == <span class="string">"E"</span>) push_mod1(a, b, <span class="number">0</span>); <span class="comment">//E 是操作 0</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(temp == <span class="string">"I"</span>) push_mod2(a, b, <span class="number">2</span>); <span class="comment">//I 是操作 2</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(temp == <span class="string">"S"</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">"Q"</span> &lt;&lt; Qcnt++ &lt;&lt; <span class="string">": "</span> &lt;&lt; query(a, b) &lt;&lt; <span class="string">"\n"</span>; <span class="comment">//查詢指令</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="用紙筆去-Debug"><a href="#用紙筆去-Debug" class="headerlink" title="用紙筆去 Debug"></a>用紙筆去 Debug</h2><p>因為只是自己在思考過程中隨手做的筆記，覺得不是對讀者這麼有幫助，因此放在文章最下面。</p>
<p>有時候用想或用看的可能不太能夠懂這演算法，那就用寫的吧！這是大衛我自己學習的手稿，紀錄者我的學習過程。</p>
<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=16ysSTFIwr3Er3VprcxFJkijrgifBahbW&export=download" alt=""></p>
</blockquote>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>線段樹 Segment Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces 1493C - K-beautiful Strings (設計解題、實作題)</title>
    <url>/2021/03/14/Codeforces/Codeforces%201493C/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>將給你一個字串 s，以及 k，請你找出一個字串比 s 下一個小的字串並且裡面的同個字母數量都能 mod k == 0 還有產生的字串長度必須等於 s</p>
<p><a href="https://codeforces.com/contest/1493/problem/C" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li>抓到題目重點</li>
<li>想到一個好寫的程式碼流程</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>對不起，我覺得我的重點觀念很像在講幹話…，但設計解題就是這樣嘛RRRR。<br>相信大家都能夠推出重點來，只是大家不知道要怎麼寫這題目，有抓到重點但是寫不出來的那種感覺。</p>
<p>以下是我進行整理的點，由<a href="https://blog.csdn.net/Aajbelieve/article/details/114500305" target="_blank" rel="noopener">�我在</a>大大中領會出來的。</p>
<ul>
<li>\(題目字串長度 \% k = 0 \)，如果不成立就可以輸出 -1<br>因為如果不等於的話，勢必會有一個英文字母沒有辦法 mod k</li>
<li>再來我們判斷需不需要修改字串中的字元，如果不用就直接輸出原本的字串<br>這點很重要，如果我們有先處理這步驟，那後面的程式會好寫很多，<del>我就是沒想到這步才卡住</del></li>
<li>需要修改時，那我們就要進行以下處理<ul>
<li>從題目的字串尾巴開始判斷是否要修改字元<br>由於題目只能找比 s 下一個小的字串，因此我們先修改字串尾巴的字元，能夠更快找到比 s 下一個小的字串</li>
<li>如果在某 index 下修改字元，判斷要填塞哪個字母才能符合<strong>同個字母數量都能 mod k == 0</strong><br>這時，我們要計算出在<strong>某 index</strong>前面的字串們，還要再塞入<strong>一個字元幾次，例如 ‘a’ 個字元兩次</strong>才能符合<strong>同個字母數量都能 mod k == 0</strong></li>
<li>推敲出公式 <code>(k- 現在某個字元在某 index 前面字串裡的數量 %k)%k</code> 此公式為還要在幾個相同字元的數量才能符合<strong>同個字母數量都能 mod k == 0</strong><br>假如一個字串 <code>aabb</code>，k = 3，那我們勢必要在給各一個 a, b 才能符合<strong>同個字母數量都能 mod k == 0</strong>此條件，可能會有人不太懂為甚麼前面要 <code>(k -</code> and <code>%k</code>，是為了假如<strong>現在某個字元在某 index 前面字串裡的數量 = 0</strong>時，才不會出現需要 k 個字元的情況發生。</li>
</ul>
</li>
</ul>
<p>現在我們獲得這些重點後，我們就可以來寫程式了！一些重點與小技巧在程式碼那邊進行說明。</p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><ul>
<li><a href="https://blog.csdn.net/Aajbelieve/article/details/114500305" target="_blank" rel="noopener">Codeforces Round #705 (Div. 2) 1493题解A. Anti-knapsack/B. Planet Lapituletti/C. K-beautiful Strings - by �我在</a></li>
</ul>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>RRRRR，其實我應該寫得出這題的，只是我抓出了這些重點後還是沒有寫程式的想法，透過 �我在大大的程式碼後，我才發現有一個 <code>sum</code>(題目程式碼的陣列，用於記錄在每個字串前綴長度時，每個字母的數量值) 是多麼重要的一件事情！我那時要是有想到他，我就會解出來了！</p>
<p>總之希望自己在學演算法是有意義的，我覺得我正在變聰明，我也從演算法中獲取了很多知識，似乎每天努力的學習就是寫演算法的義務吧！</p>
<p>嘛，我也不知道為甚麼我會走到這條路，總之我繼續加油吧！</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100020</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> T, k, n;</span><br><span class="line"><span class="keyword">int</span> cnt[<span class="number">30</span>], sum[MAXN][<span class="number">30</span>], now;</span><br><span class="line"><span class="comment">//cnt 如果在這 index 後的字串後綴都替換後，需要給予的字元數量，index 是 a,b,c 這種感覺</span></span><br><span class="line"><span class="comment">//sum[字串當前長度][字母 (a,b, c)] = 數量，也就是字串當前長度的某個字元的數量</span></span><br><span class="line"><span class="built_in">string</span> s; <span class="comment">//輸入題目資料用</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="comment">//判斷在此 index 下能否表達出題目所要的答案字元</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = s[x]-<span class="string">'a'</span>+<span class="number">1</span>; i &lt; <span class="number">26</span>; i++)&#123; <span class="comment">//從修改的 index 字元的下一個開始，到 z 結束</span></span><br><span class="line">        <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span>(cnt)); <span class="comment">//將 cnt 歸為零，cnt 每次都要 clear</span></span><br><span class="line">        <span class="comment">//cnt 用來表示，我們的 cnt[字母 (a,b,c)] = 數量，也就是每個字母需要幾個數量才能符合，</span></span><br><span class="line">        <span class="comment">//同個字母數量都能 mod k == 0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> remain = n-x<span class="number">-1</span>; <span class="comment">//如果從此 index 開始修改，那後面的字元我們可以任意變動</span></span><br><span class="line">        <span class="comment">//但也只有這個數量可以變動，注意要 -1，因為 x 這個 index 的字元是固定的，</span></span><br><span class="line">        <span class="comment">//必須要是 i，才有符合當前字源比 s[i] 小</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; j++)&#123; <span class="comment">//每個字元還需要多少字元才能符合，</span></span><br><span class="line">        <span class="comment">//同個字母數量都能 mod k == 0</span></span><br><span class="line">            now = sum[x][j]; <span class="comment">//當前長度的 j + 'a' 字元有多少數量</span></span><br><span class="line">            <span class="keyword">if</span>(j == s[x]-<span class="string">'a'</span>) now--; <span class="comment">//由於我們是紀錄當前長度，但是我們要替換現在此 index，</span></span><br><span class="line">            <span class="comment">//因此要將 now-1，因為 s[i] 這個字元我們不會使用，如果使用就不是修改此 index</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i == j) now++; <span class="comment">//因為在這邊我們會用 i+'a' 此字元，所以將 now +1，</span></span><br><span class="line">            <span class="comment">//表示之後可以少一個 i+'a' 字元，來補我們這邊用過的</span></span><br><span class="line"></span><br><span class="line">            remain -= (k-now%k)%k; <span class="comment">//減掉我們可以用的長度字元</span></span><br><span class="line">            cnt[j] += (k-now%k)%k; <span class="comment">//此字元至少需要多少長度才符合 同個字母數量都能 mod k == 0</span></span><br><span class="line">            <span class="keyword">if</span>(remain &lt; <span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">//如果 &lt; 0，表示要比題目原本字串的長度更長才能符合，因此退出</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(remain &lt; <span class="number">0</span>) <span class="keyword">continue</span>; <span class="comment">//判斷下一個字元替換此 s[i]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果還有剩下的長度可以被使用，那我們就全加給 'a' 就好，不需要擔心 a 字母會不會 % k != 0，</span></span><br><span class="line">        <span class="comment">//因為剩下的長度必定會 %k == 0，否則我們整理的第一點就不會符合。</span></span><br><span class="line">        <span class="comment">//證明: 每個字母的長度必須都 %k == 0，因此如果有剩下的長度 &gt; 1，就表示題目的長度 %k != 0</span></span><br><span class="line">        cnt[<span class="number">0</span>] += remain;</span><br><span class="line">        <span class="keyword">return</span> i; <span class="comment">//表示此 i+'a' 此字串替換給 s[i] 是好選擇，所以回傳</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.length() % k != <span class="number">0</span>) <span class="keyword">return</span> <span class="string">"-1"</span>; <span class="comment">//我們整理的第一個重點</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) sum[<span class="number">0</span>][i] = <span class="number">0</span>; <span class="comment">//歸零，不要用 memset，我這樣更省時間</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123; <span class="comment">//開始計算在每個長度時，每個字元的數量</span></span><br><span class="line">        sum[i][s[i] - <span class="string">'a'</span>] += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; j++) sum[i+<span class="number">1</span>][j] = sum[i][j]; <span class="comment">//狀態更新給下一個長度</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">1</span>; <span class="comment">//判斷是否不需要修改</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum[n<span class="number">-1</span>][i] % k != <span class="number">0</span>)&#123; <span class="comment">//需要修改</span></span><br><span class="line">            flag = <span class="number">0</span>; </span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">//退出</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag == <span class="number">1</span>) <span class="keyword">return</span> s; <span class="comment">//如果是 1 表示不需要修改，就是我們整理的第二個重點</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> ans = <span class="string">""</span>; <span class="comment">//答案</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--)&#123; <span class="comment">//從字串最尾巴開始進行修改</span></span><br><span class="line">        flag = check(i); <span class="comment">//判斷這邊修改為哪個字元更好，0 表示都不好</span></span><br><span class="line">        <span class="keyword">if</span>(flag)&#123; <span class="comment">//如果 &gt; 0，表示有可以修改的字元</span></span><br><span class="line">            ans = s.substr(<span class="number">0</span>, i) + (<span class="keyword">char</span>) (flag+<span class="string">'a'</span>); </span><br><span class="line">            <span class="comment">//原本的字串長度從 0 到 i-1 加上修改的字元，</span></span><br><span class="line">            <span class="comment">//注意 C++ 的 substr(position, len) 函式與其他語言語法不同</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//透過字典序依序將每個字母需要的數量補入 string，這裡的 string(次數, 字元)</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) ans += <span class="built_in">string</span>(cnt[i], i+<span class="string">'a'</span>);</span><br><span class="line">            <span class="keyword">return</span> ans; <span class="comment">//回傳答案</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123; <span class="comment">//輸入題目資料</span></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k &gt;&gt; s;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; solve() &lt;&lt; <span class="string">'\n'</span>; <span class="comment">//給 sovle 回傳答案</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="思考流程"><a href="#思考流程" class="headerlink" title="思考流程"></a>思考流程</h2><p>透過紙筆與黑板而思考而成的片段，放在網路上供我紀念XD</p>
<p>錯誤的程式碼就不放上來讓大家見笑了QQQQ。</p>
<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=11coaKjqBTjjWAUFHU-SPRYdrWknoW8Lh&export=download" alt=""><br><img src="https://drive.google.com/u/2/uc?id=1swl38gr_Kmr31VLfjFCB0jTuBIl3FOFQ&export=download" alt=""></p>
</blockquote>
]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>設計解題</tag>
        <tag>程式解題</tag>
        <tag>實作題</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa12532 - Interval Product(線段樹)</title>
    <url>/2021/03/14/UVa/UVa12532/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>你現在在 pub 裡面，明天要程式設計競賽，朋友給你一個問題如果你沒有回答出來，就會要求你喝一杯酒，但你酒量不好，不可以讓自己失敗，幸好朋友給妳時間寫程式，朋友給你的題目如下：</p>
<p>會給你一個數列，之後會給你兩個命令</p>
<ul>
<li><code>C</code> 改變數列中的某個數子</li>
<li><code>P</code> 請你查詢某個區間的所有數字相乘是正或負或零。</li>
</ul>
<p><a href="https://onlinejudge.org/index.php?option=onlinejudge&Itemid=8&page=show_problem&problem=3977" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li>線段樹的學習與應用<br>如果需要學習演算法，請參考 <a href="https://theriseofdavid.github.io/2021/03/06/Explain_Algorithm/segment-tree/" target="_blank" rel="noopener">大衞的筆記 - Segment Tree 線段樹</a></li>
<li>對於題目的仔細閱讀</li>
<li>用到線段樹的單點修改</li>
<li>題目只需要你輸出區間的結果是<strong>正或負或零</strong></li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>一個簡單的線段樹，只要將題目完全看過一遍後，再搭配所學過的線段樹知識就可以解出此題，那這裡有一個小麻煩就是題目的數列的數字值是在 100 ~ -100 中，我們如果存數字進去會導致相乘溢位的狀態。</p>
<p>因此我們改成在線段樹中儲存 0, -1, 1，分別代表者 零、負數、正數的情況，正數相乘還是 1、正負數相乘就是 -1，任意數乘零都是零，剛好用這三個關鍵的數子就可以充分表達題目要我們輸出的結果是正數、負數、零。</p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>最近覺得寫演算法的時間有點多，變得其他時間不好顧呢。其實也不是寫演算法的時間變多，只是上了大二後事情變多變成每件事情都要盡快完成，有時候就會覺得這種需要花大量時間完成的事情似乎沒有甚麼 CP 值呢！內心有點迷茫，希望未來的我可以知道到底怎樣做對我最好。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。 </p>
<p>至於 <a href="https://theriseofdavid.github.io/2021/03/06/Explain_Algorithm/segment-tree/" target="_blank" rel="noopener">大衞的筆記 - Segment Tree 線段樹</a> 有做說明的部分，這邊就不在進行說明。</p>
<p>比較需要注意的是此題沒有區間修改的問題，因此我們就不需要寫 <code>push_down</code> 有關於區間修改的 function。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100020</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Lson(x) (x&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Rson(x) ((x&lt;&lt;1)+1)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> num[MAXN];</span><br><span class="line"><span class="keyword">int</span> N, K, temp, a, b;</span><br><span class="line"><span class="built_in">string</span> cmd, result;　<span class="comment">//cmd 存題目的指令是查詢還是修改值 result 存結果</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">&#125;node[<span class="number">4</span> * MAXN];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x = <span class="number">1</span>)</span></span>&#123; <span class="comment">//線段樹的 function build</span></span><br><span class="line">    node[x].l = l;</span><br><span class="line">    node[x].r = r;</span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">        node[x].v = num[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = (l+r) / <span class="number">2</span>;</span><br><span class="line">    build(l, mid, Lson(x));</span><br><span class="line">    build(mid+<span class="number">1</span>, r, Rson(x));</span><br><span class="line">    node[x].v = node[Lson(x)].v * node[Rson(x)].v; <span class="comment">//因為題目要求，注意這裡是乘法</span></span><br><span class="line">    <span class="comment">//不要跟 大衞的筆記中的線段樹說明搞混</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> v, <span class="keyword">int</span> x = <span class="number">1</span>)</span></span>&#123; <span class="comment">//線段樹的 function modify</span></span><br><span class="line">    <span class="keyword">if</span>(node[x].l == p &amp;&amp; node[x].r == p)&#123;</span><br><span class="line">        node[x].v = v;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = (node[x].l+node[x].r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(p &lt;= mid) modify(p, v, Lson(x));</span><br><span class="line">    <span class="keyword">if</span>(p &gt; mid) modify(p, v, Rson(x));</span><br><span class="line">    node[x].v = node[Lson(x)].v * node[Rson(x)].v;</span><br><span class="line">    <span class="comment">//因為題目要求，注意這裡是乘法</span></span><br><span class="line">    <span class="comment">//不要跟 大衞的筆記中的線段樹說明搞混</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x = <span class="number">1</span>)</span></span>&#123;<span class="comment">//線段樹的 function query</span></span><br><span class="line">    <span class="keyword">if</span>(node[x].l &gt;= l &amp;&amp; node[x].r &lt;= r) <span class="keyword">return</span> node[x].v;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = (node[x].l+node[x].r) / <span class="number">2</span>, ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid) ans *= query(l, r, Lson(x));</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid) ans *= query(l, r, Rson(x));</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">    <span class="comment">//因為題目要求，注意這裡是乘法</span></span><br><span class="line">    <span class="comment">//不要跟 大衞的筆記中的線段樹說明搞混</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"out.txt"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; N &gt;&gt; K)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)&#123; <span class="comment">//輸入題目數列</span></span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; temp;</span><br><span class="line">            <span class="keyword">if</span>(temp &gt; <span class="number">0</span>) temp = <span class="number">1</span>; <span class="comment">//將數列的值，壓縮成 正、負、零三種狀態</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(temp &lt; <span class="number">0</span>) temp = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(temp == <span class="number">0</span>) temp = <span class="number">0</span>;</span><br><span class="line">            num[i] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        build(<span class="number">1</span>, N);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= K; i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; cmd &gt;&gt; a &gt;&gt; b;</span><br><span class="line">            <span class="keyword">if</span>(cmd == <span class="string">"C"</span>)&#123; <span class="comment">//進入線段樹 modify function</span></span><br><span class="line">                <span class="keyword">if</span>(b &gt; <span class="number">0</span>) b = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(b &lt; <span class="number">0</span>) b = <span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(b == <span class="number">0</span>) b = <span class="number">0</span>;</span><br><span class="line">                modify(a, b);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cmd == <span class="string">"P"</span>)&#123; <span class="comment">//進入線段樹 query function</span></span><br><span class="line">                <span class="keyword">int</span> ans = query(a, b);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(ans &gt; <span class="number">0</span>) result = <span class="string">"+"</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(ans &lt; <span class="number">0</span>) result = <span class="string">"-"</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(ans == <span class="number">0</span>) result = <span class="string">"0"</span>;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>線段樹 Segment Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces 1459D - Glass Half Spilled (設計解題、動態規劃、背包問題)</title>
    <url>/2021/03/16/Codeforces/Codeforces%201459D/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>這裡有 n 個水杯，每個水杯都有其最大容量與當前裝的水量，你可以透過將 A 杯的水<strong>全倒</strong>給 B 杯的方式來讓 A 杯水量增加，但過程中水會有 1/2 的輛被灑在地上，也就是說 A 杯只會增加 B 杯一半的水量，而 B 量則會變為零。</p>
<p>我們想知道如果我們只拿 n 杯且可以做倒水的動作時，那這 n 杯的總水量為多少。</p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li>意識到是動態規劃</li>
<li>化簡為背包問題</li>
<li>將三維的 DP 轉換為二維</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>明明覺得好難，但程式碼難度卻非常簡單QQ。</p>
<p>看了 _Hayasaka 大大與 qscqesze 大大的教學後，慢慢搞懂了些。</p>
<p>由於這題是詢問拿 1 ~ n 杯的總最大水量並且分開輸出，沒有要求我們要輸出步驟，此時我們應該想到兩種解法。</p>
<ul>
<li>Greedy</li>
<li>DP</li>
</ul>
<p>但這裡 Greedy 是行不通的，稍微仔細想想，有 100 個水杯，我們腦袋沒辦法一次 Greedy 那麼多東西啊，因此這裡就選擇使用 DP。</p>
<p>再仔細想想，這跟背包問題似乎有點相像，一樣都是要找出最大值，並且只有選此杯子與不選的概念，但多加了一個轉移公式。</p>
<p>因此我們這裡大概可以想出一個概念， i 個杯子、選 j 個、最大容量 k，我們就推出了最基本的動態規劃。</p>
<h3 id="但是這樣陣列數量會不夠阿，而且很耗時，有更好的方法嗎？"><a href="#但是這樣陣列數量會不夠阿，而且很耗時，有更好的方法嗎？" class="headerlink" title="但是這樣陣列數量會不夠阿，而且很耗時，有更好的方法嗎？"></a>但是這樣陣列數量會不夠阿，而且很耗時，有更好的方法嗎？</h3><p>稍微想了一下後，發現 i 個杯子不需要放在動態規劃中，狀態永遠是按照前一個的，我們可以用一個想法是<strong>依序加入</strong>，也就是說我們可以假設題目一開始只有一個杯子，後來慢慢加入的。</p>
<p>透過這種想法，我們就可以減少一個維度，變成二維陣列了！</p>
<h3 id="動態規劃轉移式"><a href="#動態規劃轉移式" class="headerlink" title="動態規劃轉移式"></a>動態規劃轉移式</h3><p>再來我們遇到了一個問題，轉移要如何轉移，動態規劃不會知道我們選哪個杯子比較好，那我們就沒辦法將沒有選到的杯子水量轉移到選到的杯子上呀。</p>
<p>此時我們可以想出一個想法，先定義一些名詞</p>
<ul>
<li><code>all</code> 全部的水杯總容量</li>
<li><code>sum</code> 全部水杯的總水量</li>
<li><code>f[j][k]</code> 當前 j 個杯子最大 k 容量時的水量</li>
<li><code>remain</code> 沒有選到的杯子總水量</li>
</ul>
<p>OK 現在這樣有了點想法了，題目是將<code>remain</code> / 2，而 <code>remain</code> 是透過 <code>sum</code> - <code>f[j][k]</code> 來的，我們所算出的最大水量則是 \((remain / 2) + f[j][k]\)，稍微將公式簡單化一下，把 remain 拆成 <code>sum</code> - <code>f[j][k]</code>，就變成了 \((sum - f[j][k]) / 2) + f[j][k] \)，再來乘二後 \((sum - f[j][k]) ) + 2(f[j][k]) \)，之後再同除二就變成了 \((sum + f[j][k]) ) / 2 \)，因此現在我們只要在最後計算這個公式就可以知道答案了！</p>
<p>可能會有些人好奇那 DP 的公式是甚麼呢？很簡單， \(f[j][k]) = max(f[j][k]), f[j-1][k-a[i]] + b[i]))\)，其中 <code>a[i]</code> 是第 i 杯的水量、<code>b[i]</code> 是第 i 杯的容量，與背包問題概念相同。</p>
<p>最後稍微注意一個重點，我們透過 \((sum + f[j][k]) ) / 2 \) 算出的答案不可以超過 k(最大容量)，如果超過就以最大容量為準。</p>
<p>需要特別注意的是，不可以像一般的背包問題一樣，直接將前個狀態轉移，因為每個<strong>最大容量 k</strong> 不一樣，如果有轉移那我們最後的公式就求不出來。</p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://blog.csdn.net/aezakmias/article/details/111495324" target="_blank" rel="noopener">Codeforces 1459D - Glass Half Spilled（背包DP） by _Hayasaka</a><br><a href="https://www.bilibili.com/video/av843179498/" target="_blank" rel="noopener">【DP】CF1459D Glass Half Spilled</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>這題好難，其實很多東西我都沒有想出來，動態規劃、壓縮動態規劃維度、轉移公式，這些東西我都沒有辦法獨自想出來，我需要再多學習，再把這些東西都轉出來。</p>
<p>現在學習的這些，希望可以幫助我啟發自己。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 120</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> dp[MAXN][MAXN*MAXN]; </span><br><span class="line"><span class="keyword">int</span> a[MAXN], b[MAXN]; <span class="comment">//是第 i 杯的水量</span></span><br><span class="line"><span class="keyword">int</span> all, sum, n; <span class="comment">//是第 i 杯的容量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123; <span class="comment">//輸入資料</span></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; b[i] &gt;&gt; a[i]; <span class="comment">//注意: 我這裡有寫反，因為題目跟我的腦袋思考方向不一樣。</span></span><br><span class="line">        sum += a[i]; <span class="comment">//累加最大水量</span></span><br><span class="line">        all += b[i]; <span class="comment">//累加最大容量</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXN; i++)&#123; <span class="comment">//DP 設定為 -INF，否則狀態會被轉移</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; MAXN*MAXN; j++) dp[i][j] = -MAXN * MAXN;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">//從這點開始 DP，因此設為零</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123; <span class="comment">//第 i 個杯子加入 dp</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &gt;= <span class="number">1</span>; j--)&#123; <span class="comment">//選用 j 個杯子</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = all; k &gt;= b[i]; k--) dp[j][k] = max(dp[j][k], dp[j<span class="number">-1</span>][k-b[i]]+a[i]); <span class="comment">//如果選用 j-1 個杯子且最大容量是 k-b[i] 時有沒有比原先大</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123; <span class="comment">//輸出答案</span></span><br><span class="line">        <span class="keyword">double</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= all; j++)&#123; <span class="comment">//對每個最大容量進行判斷</span></span><br><span class="line">            ans = max(ans, min( (sum+dp[i][j]) / <span class="number">2.0</span>, <span class="number">1.0</span> * j));</span><br><span class="line">            <span class="comment">//             min(    轉移公式           最大容量)</span></span><br><span class="line">            <span class="comment">//cout &lt;&lt; dp[i][j] &lt;&lt; ' ';</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; '\n';</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; fixed &lt;&lt; setprecision(<span class="number">10</span>) &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>; <span class="comment">//輸出答案，小數要求 10 位數</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>設計解題</tag>
        <tag>程式解題</tag>
        <tag>背包問題 Knapsack Problem</tag>
        <tag>Codeforces</tag>
        <tag>動態規劃 Dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces 1496D - Let&#39;s Go Hiking(設計解題)</title>
    <url>/2021/03/22/Codeforces/Codeforces%201496D/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>有 Q 先生與 D 先生兩個人在玩遊戲，給你一組數列，Q 先生只能走遞減(可以向左或向右)、D 先生則是遞增(可以向左或向右)，Q 先走，D 後走，如果 Q 可以贏的話，輸出它有幾種贏法，第一個 x 的 index 算一種。<br>沒有就輸出零</p>
<p><a href="https://codeforces.com/contest/1496/problem/D" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li>了解贏有哪幾種情況</li>
<li>了解輸有哪幾種情況</li>
<li>贏的話可以有幾種贏法?</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>好題，但我智商不高一直解不出來，還有些地方一直用常理去判斷QQQ，商科的爛題目大部分都還需要常理輔佐，但演算法的題目就不用，但我常常搞混:)。</p>
<p>簡單來說，我們可以將數列進行分析，分成遞增與遞減。<br>再來我們可以知道 Q、D 先生他們只要你能夠走遞增與遞減，所以理念上是他們只要有符合某種順序即可。(也就是 Q 先生不需要在意遞增或遞減，只要讓他走這兩種隨便一種即可，D 先生亦同)。</p>
<p>我們來簡單分析一下</p>
<ul>
<li>D 先生不能在走下一步，Q 先生贏</li>
<li>但 D 先生是後手可以控制 Q 先生的走法<br>例如 <code>1 2 3</code>，Q 先生選 1，那 D 先生選 2，Q 先生就輸了</li>
<li>於是 Q 先生要到某個 x，讓他往左往右都行的通，此點我們稱為<strong>轉折點</strong><br>例如 <code>1 3 2</code>，那 Q 選 3 往 1 or 2 都行的通。</li>
<li>如果轉折點的左邊比較短，那 D 先生一定選右邊，這樣才能折磨死 Q 先生，反之亦同。長度:以轉折點為中心，向左或向右可延伸的最大數量。<br>例如 <code>1 4 3 2</code>，那 Q 先生選 4，D 先生只要選右邊(3,2)，就比左邊的邊長更長，更多步可走</li>
<li>因此我們能夠知道，要找出一種轉折點是左邊的長度與右邊的長度相同。<br>例如 <code>1 3 2</code>，這時 D 先生就不好選左邊還是右邊。</li>
<li>但題目有說，Q 先生、D 先生不能走下一步的規則是<ul>
<li>沒辦法繼續走遞增或遞減的數列</li>
<li>下一步會撞到另外一位先生</li>
</ul>
</li>
<li>也就是說，可以走曾經別人走過的路！那某些題目 D 先生又有想法可以解了<br>例如 <code>1 3 2</code>，Q 先生選 3，D 先生選 1，Q 先生選 2，D 先生選 3，D 先生贏了！</li>
<li>發現一個問題，如果左邊邊長跟右邊邊長相同且邊長數量都是偶數時，D 先生會贏</li>
<li>因此 Q 先生贏的規則如下(必須都符合)<ul>
<li>轉折點的左邊長與右邊長相同</li>
<li>兩邊的邊長必須是奇數</li>
</ul>
</li>
</ul>
<p>最後是題目的小陷阱，考驗思考完整能力</p>
<ul>
<li>如果剛好也有一個轉折點的某個邊長與，我們 Q 先生勝利規則中的轉折點長度一樣時呢?<br>很不幸的，那還是 D 先生贏，因為 D 先生可以走另外一個消耗 Q 先生的步數。舉例: <code>1 3 2 4</code>，Q 先生選 3，D 先生選 2，Q 先生選 1，D 先生選 4，D 先生贏了！</li>
<li>因此我們在歸納一下</li>
<li>因此 Q 先生贏的規則如下(必須都符合)<ul>
<li>轉折點的左邊長與右邊長相同</li>
<li>兩邊的邊長必須是奇數</li>
<li>此轉折點的邊長必須是所有轉折點的邊長中長度最大的</li>
<li>此轉折點的邊長不可以跟其他轉折點任一邊長長度相同</li>
<li>由於我們只能找邊長最長的轉折點，因此答案只能有一個</li>
</ul>
</li>
</ul>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://blog.csdn.net/weixin_43911947/article/details/114673797" target="_blank" rel="noopener">D. Let‘s Go Hiking by <del>KIKI</del></a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>題目有點考倒我了QQ，好多東西都不太懂，我研究這題研究了 3hr…，雖然大部分時間是自己耍笨一直忘記 D 先生也可以走 Q 先生走過的。</p>
<p>總之，希望我學習的演算法，會讓我變聰明八XD，能應用上生活中。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100020</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> in[MAXN], de[MAXN]; <span class="comment">//遞增長度與遞減長度的陣列，</span></span><br><span class="line"><span class="keyword">int</span> n, num[MAXN], maxn = <span class="number">0</span>; <span class="comment">//num 是題目數列資料 maxn 是最大邊長 n 是數列 size</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; record[MAXN]; <span class="comment">//紀錄在 record[index] 中，在 i 點的邊長是 index</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123; <span class="comment">//輸入資料</span></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; num[i];</span><br><span class="line">        in[i] = num[i] &gt; num[i<span class="number">-1</span>] ? in[i<span class="number">-1</span>]+<span class="number">1</span> : <span class="number">1</span>; <span class="comment">//判斷是否遞增</span></span><br><span class="line">        <span class="keyword">if</span>(maxn &lt;= in[i])&#123; <span class="comment">//判斷是否是最大邊長</span></span><br><span class="line">            maxn = in[i]; <span class="comment">//更新</span></span><br><span class="line">            record[in[i]].push_back(i); <span class="comment">//將此點加入 record[index]</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    de[n] = <span class="number">1</span>; <span class="comment">//最後的數列值，直接設 1 否則出錯</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>; i &gt;= <span class="number">1</span>; i--)&#123;</span><br><span class="line">        de[i] = num[i] &gt; num[i+<span class="number">1</span>] ? de[i+<span class="number">1</span>]+<span class="number">1</span> : <span class="number">1</span>; <span class="comment">//判斷是否遞減</span></span><br><span class="line">        <span class="keyword">if</span>(maxn &lt;= de[i]) record[de[i]].push_back(i); <span class="comment">//如果有比最大邊長大，我們再放入 record</span></span><br><span class="line">        <span class="comment">//前面是因為還不了解最大邊長是多少，才會只要大於就加入</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>; <span class="comment">//判斷 x 的可能性</span></span><br><span class="line">    <span class="keyword">if</span>(record[maxn].size() &lt;= <span class="number">2</span> &amp;&amp; maxn % <span class="number">2</span> != <span class="number">0</span>)&#123; <span class="comment">//如果最大的邊長只有兩個，並且最大邊長長度為奇數時</span></span><br><span class="line">    <span class="comment">//否則都是不成立勝利的規則</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it: record[maxn])&#123; <span class="comment">//iterator，確認那兩個最大邊長都是在同個轉折點上</span></span><br><span class="line">            <span class="keyword">if</span>(de[it] == in[it]) ans = <span class="number">1</span>; <span class="comment">//是就輸出 1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    cout &lt;&lt; '\n';</span></span><br><span class="line"><span class="comment">    for(int i = 1; i &lt;= n; i++) cout &lt;&lt; in[i] &lt;&lt; ' ';</span></span><br><span class="line"><span class="comment">        cout &lt;&lt; '\n';</span></span><br><span class="line"><span class="comment">    for(int i = 1; i &lt;= n; i++) cout &lt;&lt; de[i] &lt;&lt; ' ';</span></span><br><span class="line"><span class="comment">        cout &lt;&lt; '\n';</span></span><br><span class="line"><span class="comment">    cout &lt;&lt; "maxn = " &lt;&lt; maxn &lt;&lt; '\n';</span></span><br><span class="line"><span class="comment">    /*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>設計解題</tag>
        <tag>程式解題</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>2021/03/22 媽媽總是會拿孩子剛買的晚餐吃幾口</title>
    <url>/2021/03/22/life_experence/Involuntary_family/</url>
    <content><![CDATA[<h2 id="說明"><a href="#說明" class="headerlink" title="說明"></a>說明</h2><blockquote>
<p>宣洩文，不懂老媽的心裏在想甚麼，整天只想帶給她自己覺得很棒的價值觀。</p>
</blockquote>
<a id="more"></a>

<h2 id="事由"><a href="#事由" class="headerlink" title="事由"></a>事由</h2><p>我今天買了一份麥當勞，裡面有雞塊、薯條、可樂、麥香雞，這都是我喜歡吃的東西，我媽又習慣性的自己進來就直接要拿薯條來吃，拿了三根，這對於我來說是非常不開心的一件事情，於是我就開玩笑地說有三條薯條失去了生命，我想透過這樣來表達我非常不喜歡自己買的東西被吃掉的感覺。</p>
<p>結果，我媽就說別人家的小孩學歷比你低還會懂得分享，你考上北科還不願意分享，你花的是我的錢所以我吃你的東西也是理所當然的，我對此事情感到非常生氣。</p>
<p>他沒有在我面前講這件事，但我在背後聽到，真的非常不爽，她下次進門又拿了一塊雞塊，我就兇她，阿你不是都自己拿，整天都說別人的小孩就會分享，他就被我氣倒拉，生氣啦。</p>
<h2 id="我很生氣"><a href="#我很生氣" class="headerlink" title="我很生氣"></a>我很生氣</h2><p>我真的很討厭有人要我分享食物，從小到大我的零用錢永遠都是餓死狀態，小時候整天吃的東西都是不好吃的東西，小時候帶去補習班吃的晚餐還會被其他同學說聞起來很臭，真的會讓一個小孩的自尊受創。</p>
<p>從那開始我對吃就很要求，我認為吃東西就是好吃、新鮮，我喜歡吃的東西就是要吃，沒有甚麼比吃更重要，從之前高中慢慢爭取自己可以吃東西的權力後，我媽就會在我買速食的時候常常來吃一口兩口，我一直都不喜歡這種感覺，這是我的食物欸！我不給你就會開始講，你是我養的、錢是我給的，把那些中國孝順言論搬出來。</p>
<p>所以這樣套用在每個人就合理嗎？透過這樣來合理自己的想法，從來都沒有想過自己的小孩為甚麼不願意分享，是甚麼原因造成的，每次都說是自己的問題，自己改掉就好了。恩，很簡單啊，那你不要每天都刺激我就好啦，整天都會用這種方式拿我想吃的東西，然後吃了再開始講這是理所當然的，這種名利雙收的事還真希望我在現實中也能應用到阿。</p>
<h2 id="她的生氣"><a href="#她的生氣" class="headerlink" title="她的生氣"></a>她的生氣</h2><p>她的生氣一定就是自己的小孩為甚麼可以兇她，不孝順…這種東西，然後再跟他的那些朋友們分享之類的八，我時常都不太懂這些概念，一個受過正常教育讀過北科的小孩如果沒有分享此概念，那肯定就是在某部分的教育有缺失，他總不去思考這些，拿 1970 的思維來養小孩，小孩活的好辛苦。</p>
<p>我統整好了，小孩如何導致有自私的心理</p>
<ul>
<li>從小資源不足，金錢、衣服<br>我媽從小時候給我的錢就是少，每件事情都要我去爭取，哪個人會想要把自己努力爭取的事物直接分享給別人</li>
<li>考好幸褔的是你自己，不分享是你的問題<br>我超討厭這種不要馬吃草，又要馬跑得快的問題了，我家庭的思考方式是我給小孩多少的投資，小孩一定要給上倍的回報量才能叫做正常，我受不了那種拿自己的價值觀框固別人的思考。人脈我也沒有，學習資源基本上都是政府給的，給予我最多的就是基本生活。但我真的好累，我學到百分之 80% 的知識都是透過學校還有朋友。如果真要感謝我還真想要感謝一路幫助我的人。</li>
</ul>
<h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>真的好累，活在這種家庭下生活基本上不會快樂超過三天，一定可以有吵架讓人心情不好的事情，小事也可以拿出來吵，真的受夠了。精神上的家庭暴力。</p>
<p>想要搬出去住，這樣我就不需要給別人罵，我吃麥當勞也能夠開心的吃，不需要跟別人分享，躲在我的電腦桌前跟我一起開心的享受速食。</p>
]]></content>
      <categories>
        <category>人生旅途</category>
      </categories>
      <tags>
        <tag>大學Life</tag>
        <tag>人生旅途</tag>
      </tags>
  </entry>
  <entry>
    <title>2021/03/19 夜晚騎車跑山華梵大學、深坑老街</title>
    <url>/2021/03/22/life_experence/Shenkeng_visiting_with_yuan/</url>
    <content><![CDATA[<h2 id="說明"><a href="#說明" class="headerlink" title="說明"></a>說明</h2><blockquote>
<p>我北科材資系的朋友 陳秉沅，最近剛獲得了一台雷霆 125，找我去跑山，雖然我很懶惰XD，但是我還是跟他一起去了XD。</p>
</blockquote>
<a id="more"></a>

<h2 id="相約"><a href="#相約" class="headerlink" title="相約"></a>相約</h2><p>有天秉沅打電話給我問我要不要去跑山，其實我有點想要出門，但是我比較想要唱 KTV，所以我就有點在猶豫要不要出去，秉沅太熱情了，我的氣勢就弱掉了，就答應去跑山了。</p>
<h3 id="要去哪裡"><a href="#要去哪裡" class="headerlink" title="要去哪裡"></a>要去哪裡</h3><p>秉沅想去陽明山，大衛表示晚上沒路燈，我不要。<br>秉沅挑了一堆日子去，大衛表示很忙不想去。</p>
<p>在我不斷地拒絕一陣子後，後來終於找到一個日子，運動會前一天 03/19，去深坑吃臭豆腐啦。</p>
<h2 id="出發"><a href="#出發" class="headerlink" title="出發"></a>出發</h2><p>原本一開始是打算要約下午 4 點，但後來因為要弄台灣大專院校程式設計競賽的獎學金 delay 到 5 點半，讓秉沅等了我那麼久真的很不好意思QQ。</p>
<p>後來我們出發，我當前導，但是我沒有 GPS，我原本以為我很熟北科到深坑的路，但後來我發現我錯了QQ，我一直走錯路…，直接炸開XDDDD，幸好秉沅沒有生氣能容忍我到處亂帶錯路。</p>
<p>還不小心跑到別人人家的高級住宅區，秉沅看到某個開著很帥的車子卻不太會迴轉還偷嘴了一下XD。</p>
<p>騎到動物園時，秉沅還問我說煙囪在哪裡，我突然傻住心裡想說這裡沒有煙囪阿，在下個瞬間他跟我腦袋中的<strong>長頸鹿</strong>聯想在一起了！我就說你問的是長頸鹿八，木柵焚化爐那個。</p>
<p>題外話：木柵焚化爐的煙囪，大家會講煙囪還是長頸鹿呢。</p>
<h2 id="深坑"><a href="#深坑" class="headerlink" title="深坑"></a>深坑</h2><p>後來到了深坑後，我們準備要去停車時，我差點就被機車撞，我在外線找沒有雙黃線的地方穿過對向車道時，有一個機車騎士想要加速趕快經過，結果就差點要撞上，我的 ABS 熱血開用，直接煞住，幫助了我度過這次難關，不然我還沒有跑山就要直接出局了QQ。</p>
<p>到了深坑老街後，大約是晚上 7 點，這時候許多店家已經開始休息，在我不斷地精挑細選之下，我挑到了一家<strong>豆腐娘</strong>用餐。</p>
<p>我們吃豆腐三吃、鳳梨蝦球，食物來說蠻好吃的，但有個小插曲，原先我們是點兩碗白飯，結果服務員可能看錯菜單幫我們弄了豬油飯，我想說只差 5 元就算了，我就直接吃沒關係，結果店家說沒關係就算白飯價錢就好，我原本還想說賺到了！</p>
<p>結果，後來還是給我算豬油飯的錢:)，老闆不要騙我RRR。太狠了八<br>食物還蠻不錯，臭豆腐配大腸、鴨血那道菜，我蠻喜歡吃的，大推，感覺應該可以點個豆腐捲，棄掉炸臭豆腐。下次不要點豆腐三次，點那道就好，大推！</p>
<p>吃飽完飯後，結了帳一個人大約是 270，恩有點貴的消費，不過是出來玩應該沒關係啦XD。<br>題外話：那家店的小孩讀再興中學阿QQ，讓我覺得台灣的經濟其實蠻好的嘛，只是我不再那範圍內QQ。</p>
<p>吃飽飯後，接下來在深坑老街走走，其中走到一個很懷念的古早雜貨店，都是賣些古老的食物，讓我起了懷念心，那些糖果還有再販賣，就像是在訴說我的童年時代還沒有結束，還在似的。<br>買了一個保麗龍飛機回家玩，50 元，就繼續向裡面走了。</p>
<blockquote>
<p>50元飛機帥氣滑行的樣子</p>
<div class="video-container"><iframe src="https://www.youtube.com/embed/BxI7ap5v3rQ" frameborder="0" loading="lazy" allowfullscreen></iframe></div>
</blockquote>
<p>深坑老街走完後，有一個讓孩子們嬉戲的地方，那邊還有很多深坑國小的小孩在嬉戲，有種懷念的感覺XD，之前的我也是這樣到處嬉戲到處玩，但現在有了電腦、手機，長大以後的我被冠上了一堆責任，似乎回不太去那快樂的感覺了呢。</p>
<p>那種快快樂樂，只要跑步就能讓自己感覺到幸福的時光，不會被別人比較。</p>
<h2 id="石碇、華梵大學"><a href="#石碇、華梵大學" class="headerlink" title="石碇、華梵大學"></a>石碇、華梵大學</h2><p>深坑差不多走完後，我們開始往石碇上面跑，途中剛好遇到深坑夜市，只有二、五有營業，因為剛吃飽飯所以就不太想過去逛逛，下次有機會可以去那邊逛逛，感覺那邊就很好玩，也有很多便宜又好吃的食物！讚啦。</p>
<p>石碇的路不難跑，蠻順、蠻大條的，但是因為前一天我太晚睡覺了QQ，導致我有點沒有那麼享受跑山的熱忱中，有點像是怕自己遇到車禍的感覺有點警惕XD，大約跑到了坪林與華梵大學的分界點時，我還跟秉沅說我們要不要就在這邊回去XD，他當然是不要呀。</p>
<p>我也不知道不可能在這邊妥協的，於是我就跟他一起往華梵大學跑，一路上都沒遇到甚麼車，很輕鬆，但有些大灣需要注意點，那些灣都沒有路燈必須要很認真的注意標線，不然一不小心就飛出去摟。<br>跑山也得要注意安全，在山中飛馳的感覺很心曠神怡。但也要注意安全。</p>
<p>後來我們跑到了華梵大學後，稍為在它們的機車停車場待了下，我說不如我們就進去華梵走走，秉沅還很開心地認為這裡是文化大學有很漂亮的夜景可以拍XD，我後來跟他解釋說這裡不是陽明山拉差太多了XDDDD，她顯得有點失望QQQ。</p>
<p>在上面稍微看看，探險，華梵真的好大…，而且好斗，我才走一陣子就滿身是汗了，突然對華梵的大學生們感到佩服，能夠每天都那樣爬上爬下呢，看到他們一些很高級的教學大樓就會開始覺得，北科的建築物怎麼那麼破XDDD，看看六教、看看三教，我要哭暈在廁所哦QQQQ。</p>
<p>不小心誤入了設計館，那就進去走走拉，裡面的裝潢好香，好漂亮，跟我之前進去的北科設計館怎麼感覺有點不太一樣…。沒有戰校欸，不要罵我拉QQQQ。</p>
<blockquote>
<p>華梵設計館<br><img src="https://drive.google.com/u/2/uc?id=19Uk8IU_aZ4Hd8O552YFcQ21WDPFhVTnn&export=download" alt=""></p>
</blockquote>
<p>後來到了他們的操場，他們的操場比我們的更不堪入目QQQ，他們的操場有點破爛…，向是沒有在經營一樣，也沒有人在運動，顯得十分冷清破舊，如果在這裡拍些驚悚片似乎會是個很好的選擇。</p>
<blockquote>
<p>華梵大學操場</p>
<blockquote>
<div class="video-container"><iframe src="https://www.youtube.com/embed/ttwyEM_a0UU" frameborder="0" loading="lazy" allowfullscreen></iframe></div>
</blockquote>
</blockquote>
<p>不過希望他們可以把操場改善拉，不然蜘蛛網都黏到了秉沅的頭髮上，嗚嗚。</p>
<p>稍微看完華梵後，我們就準備騎車回家，一如剛剛上來的感覺，轉彎還是都很小心，但明顯下山的時候快了更多，比上山感覺快了 10 倍呢。</p>
<p>途中還有看到一個華梵的女學生還在等華梵大學的校車回家嗎?原本還想說詢問他要不要幫忙，不過我又很怕被當作怪叔叔XDDD。好兩難阿，大衛。</p>
<p>下山的路上稍微繞了下烏塗窟，晚上沒什麼特別的，就是那邊的狗狗都很溫柔不會亂叫，讚啦，那邊的飼主都快比萬華還好啦。</p>
<h2 id="木柵"><a href="#木柵" class="headerlink" title="木柵"></a>木柵</h2><p>到了木柵後想要洗車，到了一家洗車場後發現，那家金時代自助洗車的環境好髒阿…，髒到我都不能理解，明明是要洗乾淨的地方為甚麼可以髒到用清水洗之後還有一堆淤泥在我的腳底下呢？</p>
<p>總之，非常不推木柵金時代洗車場，太髒了。不要去哪邊洗車自找苦吃，否則你的鞋子會哭出來喔。</p>
<h2 id="回程"><a href="#回程" class="headerlink" title="回程"></a>回程</h2><p>後來回程的路上，順利的輕鬆回家，在某條路上與秉沅分離，結果秉沅比我快了兩倍速度回家…，我家太偏遠了嗎QQQQ。</p>
<p>回到家的時間是 23:50，辛苦啦，大衛。</p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>這趟的體驗讓我覺得深坑很適合情侶來趟輕旅行，或許連衣服都不用帶，直接到深坑的旅館住宿，騎著機車到處逛逛，聊天談心，偶爾在小山裡面談談心、看看快樂的孩子們，不理會都市的匆忙、比較感是件很愜意的事情，你可以明顯感覺到步調變慢的氣息。</p>
<p>但也能慢慢感受到這裏要發展起來的契機，我希望深坑可以是我輕旅行的好去處，而不要成為下一個林口，這樣我剛發現的秘密基地就會化為烏有了。</p>
<p>雖然深坑我沒有接觸到很多人，但我可以感覺到這裡有一種溫暖的氣息，而不是讓我感覺到競爭的感覺。<br>改天可以再來，但我不知道下次來是甚麼時候，希望可以跟今天來的感覺一樣美好。</p>
]]></content>
      <categories>
        <category>人生旅途</category>
      </categories>
      <tags>
        <tag>大學Life</tag>
        <tag>人生旅途</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces 1497E1 - Square-free division (easy version) (math theorm)</title>
    <url>/2021/03/22/Codeforces/Codeforces%201497E1/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>請你將題目給你的數列進行切斷，每一個切斷的數列裡不可以有某兩值相乘是完全平方數，求最小切斷的長度</p>
<p><a href="https://codeforces.com/contest/1497/problem/E1" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li>了解完全平方數的特性</li>
<li>進行優化，不可簡單思考就開始寫入</li>
</ul>
<p>##　分析<br>這題很有趣，學了一課。</p>
<p>我們可以知道完全平方數的特性是，每一個質因數的次方都是偶數才有辦法組成完全平方數，那現在只剩下一個問題了，我們怎樣知道哪些數字相乘會等於完全平方數呢？</p>
<p>此時我們可以透過完全平方數反推，只要有一個質因數的次方不是偶數就不會是完全平方數，那麼只要有另外一個數字相乘可以讓所有的質因數次方都變成偶數。</p>
<p>舉例： 18 = 2 * 3 * 3，此時我們的 2 的次方是奇數，那我們只要再補給他 2 就會等於 36 是個完全平方數了！<br>在進一步想，如果讓 18 * 8 = 144，也是完全平方數， 8 = 2 * 2 * 2，2^3 也是奇數，因此我們只要讓兩個數字相乘後每一個質因數 都是偶數，遇到這樣的情況時就可以切斷。</p>
<p>而我們知道奇數 + 奇數 就是偶數，因此我們只要知道當前片段有幾個質因數是奇數在紀錄就好。</p>
<p>現在還有一個問題要稍微避險下，18 = 2 * 3 * 3, 6 = 2 * 3，這樣是沒有滿足所有的質因數的次方都是偶數，會變成 108 = 2 * 2 * 3 * 3 * 3，因此這樣不算。</p>
<p>如果要讓 6 乘以另一個數字相乘必須是滿足所有的質因數的次方都是偶數，因次需要另外一個 6 來補足就變成了 36 = 2 * 2 * 3 * 3。<br>這裡我們得知一件事，我們除了計算哪些質因數次方是奇數外，還要讓這些奇數質因數次方相乘。</p>
<p>得出結論</p>
<ul>
<li>把所有數字拆解質因數</li>
<li>當數字的所有質因數為奇數次方時，相乘這些奇數次方的質因數(定義 p)</li>
<li>保存 p，只要後面的數字也有另外一個 p 時就切斷數列</li>
</ul>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://blog.csdn.net/asbbv/article/details/114990845" target="_blank" rel="noopener">E1. Square-free division (easy version) (数论、思维) by tom_bbv</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>題目考到我了QQ，不過我認為我學習了蠻多思維，希望這些思維我都能學會並且派上用場。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 200020</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> t, n, k, num[MAXN]; <span class="comment">//num 輸入題目數列用</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; mp; <span class="comment">//紀錄每個 p，前面定義過的</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">divid</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">1</span>; <span class="comment">//紀錄此數字所有奇數次方的質因數相乘</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i*i &lt;= x; i++)&#123; <span class="comment">//質因數分解</span></span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x % i == <span class="number">0</span>)&#123; </span><br><span class="line">            cnt++; <span class="comment">//紀錄總共有幾次的次方</span></span><br><span class="line">            x /= i; <span class="comment">//約分，加速迴圈效率</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt % <span class="number">2</span> != <span class="number">0</span>) p *= i; <span class="comment">//奇數次方的質因數相乘</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p*x; <span class="comment">//這邊還要再乘以 x，因為前面有約分，所以 x 會是最後一個沒有被加入迴圈的質因數，回傳 p</span></span><br><span class="line">    <span class="comment">//x 也可以等於 1，因為 1 是質因數</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>; <span class="comment">//紀錄要切幾個線段</span></span><br><span class="line">        mp.clear(); <span class="comment">//先將前面紀錄有哪些 p 先清除，避免干擾</span></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123; <span class="comment">//輸入題目數列</span></span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; num[i];</span><br><span class="line">            <span class="keyword">int</span> p = divid(num[i]); <span class="comment">//質因數分解，回傳此數字所有奇數次方的質因數相乘</span></span><br><span class="line">            <span class="keyword">if</span>(mp.count(p))&#123; <span class="comment">//如果 p 有被記錄表示，這裡會被組成完全平方數</span></span><br><span class="line">                ans++; <span class="comment">//這邊切線段，然後清除之前紀錄的 p</span></span><br><span class="line">                mp.clear();</span><br><span class="line">            &#125;</span><br><span class="line">            mp[p] = <span class="number">1</span>; <span class="comment">//這次的 p 要被記錄，因為是在另一個線段</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans+<span class="number">1</span> &lt;&lt; <span class="string">'\n'</span>; <span class="comment">//最後的線段不會再被我們切到，因此這邊要 +1，加入最後一個線段</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>math theorm</tag>
        <tag>設計解題</tag>
        <tag>程式解題</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa10487 - Closest Sums (二分搜尋 Binary Search)</title>
    <url>/2020/03/28/UVa/UVa10487/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>給你一個數列，再給你一個數字，請你告訴這個數字最靠近這個數列某兩個值相加之總和(不可使用同個位置的數字)</p>
<p><a href="https://onlinejudge.org/external/104/10487.pdf" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li>思考要怎麼樣迅速查詢到最靠近的值</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>基本上是水題，再透過二分搜尋的方式將答案找出。</p>
<p>先將數列中所有數字都先兩兩相加後，再用二分搜尋找出最靠近的數字。</p>
<p>注意：這裡要用 <code>upper_bound</code> 會比較好寫，他勢必會找到比題目要查詢的數字更大，因此我們<code>upper_bound</code> 找到的數值(定義num[x])，再往前一個 index，num[x-1]，一定會比查詢的數字還要小，接下來再拿這兩個數字去比較即可，輸出離查詢數字更近的。</p>
<p>注意一開始的邊界問題，因此一開始先設無限大即可。</p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>簡單的一道題，希望自己考場都寫會瞜</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1020</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, idx, ans, temp, kase=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> num[MAXN]; <span class="comment">//放題目數列用</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sum; <span class="comment">//放兩兩相加後的陣列</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n &amp;&amp; n)&#123;</span><br><span class="line">        sum.clear(); <span class="comment">//清除上次的狀態，否則會干擾此次題目</span></span><br><span class="line">        sum.push_back(<span class="number">-0x3f3f3f</span>); <span class="comment">//先放第一筆資料進去，並且是無限大才不會導致</span></span><br><span class="line">        <span class="comment">//upper_bound 找到 (index)0 時跟 (index)-1 比較的問題</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123; <span class="comment">//輸入資料</span></span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; num[i]; </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i<span class="number">-1</span>; j &gt;= <span class="number">0</span>; j--) sum.push_back(num[i]+num[j]); </span><br><span class="line">            <span class="comment">//類似於 bubble sort 的將值輸入進去，這樣就不會重複輸入兩個值以上</span></span><br><span class="line">        &#125;</span><br><span class="line">        sort(sum.begin(), sum.end()); <span class="comment">//排序，方便二分搜尋</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Case "</span> &lt;&lt; kase++ &lt;&lt; <span class="string">":\n"</span>; </span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; m; <span class="comment">//輸入題目資訊</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; temp; </span><br><span class="line">            idx = upper_bound(sum.begin(), sum.end(), temp) - sum.begin(); </span><br><span class="line">            <span class="comment">//找到離查詢的數值更大的數值，(定義t)</span></span><br><span class="line">            <span class="keyword">int</span> gap1 = <span class="built_in">abs</span>(sum[idx] - temp); <span class="comment">//差距 1，找查詢數與 t 的距離</span></span><br><span class="line">            <span class="keyword">int</span> gap2 = <span class="built_in">abs</span>(sum[idx<span class="number">-1</span>] - temp); <span class="comment">//差距 1，找查詢數與 t 的上一個數值的距離</span></span><br><span class="line">            <span class="comment">//cout &lt;&lt; sum[index] &lt;&lt; ' ' &lt;&lt; sum[index-1] &lt;&lt; '\n';</span></span><br><span class="line">            <span class="keyword">if</span>(gap2 &lt; gap1) <span class="built_in">cout</span> &lt;&lt; <span class="string">"Closest sum to "</span> &lt;&lt; temp &lt;&lt; <span class="string">" is "</span> &lt;&lt; sum [idx<span class="number">-1</span>] &lt;&lt; <span class="string">".\n"</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"Closest sum to "</span> &lt;&lt; temp &lt;&lt; <span class="string">" is "</span> &lt;&lt; sum[idx] &lt;&lt; <span class="string">".\n"</span>;</span><br><span class="line">            <span class="comment">//誰的差距大，就用另外一個差距的 sum[idx] or sum[idx-1] 來輸出答案。</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>












]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>Binary Search 二分搜尋</tag>
      </tags>
  </entry>
  <entry>
    <title>個案報告 - 協易機械 ERP顧問的評選</title>
    <url>/2021/03/28/NTUT_note/MIS-Case2/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊與財金管理系大二下管理資訊系統的個案報告心得回饋<br><font color="#dd0000">並非所有人都適用，部分對我而言稍加容易的內容並不會寫在此內。</font></p>
</blockquote>
<a id="more"></a>

<h2 id="個人心得"><a href="#個人心得" class="headerlink" title="個人心得"></a>個人心得</h2><p><img src="https://drive.google.com/file/d/1KH1V5aP3CAChwKOD_udb9hS7LPH27VOF/view?usp=sharing" alt="協易機械 ERP顧問的評選，大衛心得"></p>
]]></content>
      <categories>
        <category>北科上課筆記</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>管理資訊系統</tag>
      </tags>
  </entry>
  <entry>
    <title>個案報告 1 - 怪獸公司 資訊系統促使之企業流程變革</title>
    <url>/2021/03/28/NTUT_note/MIS-Case1/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊與財金管理系大二下管理資訊系統的個案報告心得回饋<br><font color="#dd0000">並非所有人都適用，部分對我而言稍加容易的內容並不會寫在此內。</font></p>
</blockquote>
<a id="more"></a>

<h2 id="個人心得"><a href="#個人心得" class="headerlink" title="個人心得"></a>個人心得</h2><p><img src="https://drive.google.com/file/d/1dHZEzJFJeI9wevWhSlMKa5D7I_LHn1L5/view?usp=sharing" alt="怪獸公司 資訊系統促使之企業流程變革，大衛心得"></p>
]]></content>
      <categories>
        <category>北科上課筆記</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>管理資訊系統</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa11236 - Grocery store (數論 Math theorm、暴力搜尋 Brute force)</title>
    <url>/2020/04/05/UVa/UVa%2011236/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>雜貨店的收銀員不太懂加號跟乘號這兩個意思，為了要讓他更容易理解，因此在你買雜貨店的商品時，你想要讓你買的四項商品總和價格等同於你買的四項商品價格乘積，四項商品都是相同的商品。</p>
<p>總共不可以大於 20 元，雜貨店的商品價格範圍在 0.00 ~ 20.00 範圍內，小數點前兩位都是合理的價位。<br>輸出時，四個商品價格必須是遞增</p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li>了解小數點不夠精確，因此必須化為整數運算</li>
<li>對於暴力搜尋進行優化<ul>
<li>反推最後一項商品價錢</li>
<li>暴力搜尋的範圍優化</li>
<li>解決小數會越乘越小的問題</li>
</ul>
</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>好題，好題，沒想到 UVa 裡面也有類似於 Codeforces 的題目呢。</p>
<p>我們來進行一些分析，首先由於我們知道電腦對於小數運算並不精確，假如小數數字連續乘四，有非常高的機率會使浮點數運算有誤差，導致無法 AC，因此我們的第一件事情就是要用整數來解決此題。</p>
<h3 id="擴分公式"><a href="#擴分公式" class="headerlink" title="擴分公式"></a>擴分公式</h3><p>根據題目的方程式，我們現在定義 \(p_1,p_2,p_3,p_4\)，是我們 4 個商品的價錢，因此公式要如下<br>\(p_1p_2p_3p_4 = p_1 + p_2 + p_3 p_4\)</p>
<p>接下來我們要進行擴分，這樣我們才可以用整數進行運算，我們定義括分 100 倍的價錢為 \(a_1 , a_2 , a_3 , a_4\)</p>
<ul>
<li>\(\frac{a_1}{100} \frac{a_2}{100} \frac{a_3}{100} \frac{a_4}{100} = \frac{a_1}{100}+ \frac{a_2}{100} + \frac{a_3}{100} \frac{a_4}{100}\)</li>
<li>稍微化簡下，成為 \(\frac{a_1 a_2 a_3 a_4}{10^8} = \frac{a_1+a_2+a_3+a_4}{100} \)</li>
<li>移項，\(\frac{a_1 a_2 a_3 a_4}{10^6} = a_1+a_2+a_3+a_4\)</li>
<li>分母移項 \((a_1+a_2+a_3+a_4) 10^6 = a_1 a_2 a_3 a_4 \)</li>
<li>透過此方程式，就可以用整數來寫出題目所需要的答案</li>
</ul>
<h3 id="優化迴圈"><a href="#優化迴圈" class="headerlink" title="優化迴圈"></a>優化迴圈</h3><p>由於我們還知道一件事情是，總共不能大於 20 元，且商品價格要遞增，因此大家比較容易想到的是迴圈不斷的遞增，但其實我們也可以減少迴圈的上限，來更加優化，如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> a1 = <span class="number">1</span>; a1 &lt;= <span class="number">2000</span>; a1++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> a2 = a1; a2 &lt;= <span class="number">2000</span>-a1; a2++ )&#123; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> a3 = a2; a3 &lt;= <span class="number">2000</span>-a1-a2; a3++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> a4 = a3; a4 &lt;= <span class="number">2000</span>-a1-a2-a3; a4++)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中可以注意到，a2,a3,a4 他們的迴圈上限都有被縮小，是因為題目除了要數值遞增，並且還不能超過 2000，那麼 a1 用掉的錢勢必也在 20 元以內，才可以透過這樣進行優化。</p>
<p>而遞增，減少下限就是大家比較熟悉的，不多做解釋。</p>
<h3 id="設定檢查點"><a href="#設定檢查點" class="headerlink" title="設定檢查點"></a>設定檢查點</h3><p>其中我們可以知道公式是 \((a_1+a_2+a_3+a_4) 10^6 = a_1 a_2 a_3 a_4 \)，但這裡有一個大問題，原先的題目數值是小數，如果是 \(0.1(0.2)\) 的情況下是越乘越小的，但整數的情況並不是，0因此才會有一個 \(10^6\) 的情況出現，所以反之，也就是說如果 \(a_1 a_2 a_3 a_4 &lt;= 10^6\) 的情況下表示四個數值都是 \(&gt; 1\)，乘積只會越來越小，必定不符合題目需求。</p>
<p>\(10^6\) 是因為我們先擴分 100 倍，才會有的限制器。</p>
<h3 id="減少迴圈數量"><a href="#減少迴圈數量" class="headerlink" title="減少迴圈數量"></a>減少迴圈數量</h3><p>先提一個概念，\(x+y=10\)，如果我們知道 x 的情況，那 y 是不是可以移項得出。<br>所以 \(a_1 + a_2 + a_3 + a_4 = A\)，如果前三項與 A 都知道那 \(a_4\) 也可以被得知。</p>
<p>因此我們來進行移項與定義</p>
<ul>
<li>定義 \(a_1+a_2+a_3\) 為 sum</li>
<li>定義 \(a_1 a_2 a_3\) 為 product</li>
<li>定義 \(10^6\) 為 c</li>
<li>因此 \((a_1+a_2+a_3+a_4) 10^6 = a_1 a_2 a_3 a_4 = c(sum + p_4) = product (p_4)\)</li>
<li>左項乘開 \(c(sum + p_4) = product (p_4)\) </li>
<li>再來移項 \(c(sum) + c(p_4) = product (p_4) \)</li>
<li>移項 \(c(sum) = product(p_4) - c(p_4)\)</li>
<li>結合 \(c(sum) = p_4(product - c)\)</li>
<li>移項 \(p_4 = \frac{c(sum)}{(product - c)}\)</li>
</ul>
<h3 id="擴分後的限制"><a href="#擴分後的限制" class="headerlink" title="擴分後的限制"></a>擴分後的限制</h3><p>再來我們知道了這公式後，我們還有幾個題目的限制要注意</p>
<ul>
<li>\(c(sum) % (product - c) == 0\) 因為我們進行擴分，因此如果沒有剛好 mod 等同於 0 時，表示其實此數值在縮小 100 倍後則不會剛好符合題目要求。表示 \(a_4\) 可能需要小數後 x 位才能符合題目要求，其中 x 必須大於 2。</li>
<li>\(p_3 &lt; p_4\)，題目要求</li>
<li>\(sum + p_4 \leq 2000\)，因為我們將 20 放大 100 倍</li>
<li>\(product(p_4) \leq 2(10^9)\)，由於 \(\frac{a_1 a_2 a_3 a_4}{10^8}\)，縮小 100 倍後不可以超過 20 元。注意，這裡的縮小 100 倍是每個 \(a\) 都縮小 100 倍，全部則是縮小 \(10^8\)</li>
</ul>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://www.redgreencode.com/equation-solving-is-the-key-to-uva-11236/" target="_blank" rel="noopener">EQUATION SOLVING IS THE KEY TO UVA 11236 by Red-Green-Code</a><br><a href="https://geniustanley.github.io/2017/02/15/UVa-11236-Grocery-store/" target="_blank" rel="noopener">UVa 11236 - Grocery store by geniustanley</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>這題很有趣RRR，完全不用輸入測資卻可以讓人有著這麼多的腦力激盪，其實很有趣R。</p>
<p>總之學到了很多，但我也是看著詳解一步一步慢慢地去學習，或許我的腦袋其實沒有很聰明，但我會透過學習來讓自己也能夠跟上一般人的腳步。</p>
<p>希望大家可以包容這樣的我，不夠聰明的我。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 2*1e9 <span class="comment">// 四項商品乘積放大 100 倍的值</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long <span class="comment">//避免溢位</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> c = <span class="number">1e6</span>; <span class="comment">//將他進行第溢</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//add more fast than product</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> a1 = <span class="number">1</span>; a1 &lt;= <span class="number">2000</span>; a1++)&#123;</span><br><span class="line">        <span class="comment">//if(pow(a1,4) &gt;= MAXN) break; //注意，加法運算比乘法快。</span></span><br><span class="line">        <span class="keyword">if</span>(a1+a1+a1+a1 &gt; <span class="number">2000</span>) <span class="keyword">break</span>; <span class="comment">//如果這邊就超過 2000，後面沒辦法遞增部符合題目要求</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> a2 = a1; a2 &lt;= <span class="number">2000</span>-a1; a2++ )&#123; </span><br><span class="line">            <span class="comment">//if(a1+pow(a2,3) &gt;= MAXN) break;</span></span><br><span class="line">            <span class="keyword">if</span>(a1+a2+a2+a2 &gt; <span class="number">2000</span>) <span class="keyword">break</span>; <span class="comment">//如果這邊就超過 2000，後面沒辦法遞增部符合題目要求</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> a3 = a2; a3 &lt;= <span class="number">2000</span>-a1-a2; a3++)&#123;</span><br><span class="line">                <span class="comment">//if(a1+a2+pow(a3,2) &gt;= MAXN) break;</span></span><br><span class="line">                <span class="keyword">if</span>(a1+a2+a3+a3 &gt; <span class="number">2000</span>) <span class="keyword">break</span>; <span class="comment">//如果這邊就超過 2000，後面沒辦法遞增部符合題目要求</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> sum = a1 + a2 + a3;</span><br><span class="line">                <span class="keyword">int</span> product = a1 * a2 * a3;</span><br><span class="line">                <span class="keyword">if</span>(product &lt;= c) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>((sum*c) % (product-c) != <span class="number">0</span>) <span class="keyword">continue</span>; <span class="comment">//mod != 0 </span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//上方擴分後的限制有提到</span></span><br><span class="line">                <span class="keyword">int</span> a4 = (sum*c) / (product-c);</span><br><span class="line">                <span class="keyword">if</span>(a3 &gt; a4) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(sum + a4 &gt; <span class="number">2000</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(product * a4 &gt; MAXN) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; fixed &lt;&lt; setprecision(<span class="number">2</span>) &lt;&lt; a1/<span class="number">100.0</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; \</span><br><span class="line">                    fixed &lt;&lt; setprecision(<span class="number">2</span>) &lt;&lt; a2/<span class="number">100.0</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; \</span><br><span class="line">                    fixed &lt;&lt; setprecision(<span class="number">2</span>) &lt;&lt; a3/<span class="number">100.0</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; \</span><br><span class="line">                    fixed &lt;&lt; setprecision(<span class="number">2</span>) &lt;&lt; a4/<span class="number">100.0</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">                <span class="comment">//小數運算</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    solve();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>數論 Math theorm</tag>
        <tag>暴力搜尋 Brute force</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa10660 - Citizen attention offices (暴力搜尋 Brute force)</title>
    <url>/2020/03/28/UVa/UVa10660/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>有一個正方形的城市，被分隔成 25 個區域，size 是 5 * 5，每個區域都有住著許多人，政府要在裡面設 5 個行政據點，其目標是可以幫助此城市所有人都可以透過直走與橫走的方式走到行政據點(其中一個就可以)，且讓都市中的所有人總和走起來距離最短。</p>
<p><a href="https://onlinejudge.org/external/106/10660.pdf" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li>寫出時間複雜度</li>
<li>進行思考，是否有非暴力搜尋的方式可以解出此題</li>
<li>能夠閱讀題目</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>這題是一個很麻煩的題目…，通常我看到這種題目我都會認為一定有一種規律可行、可解。</p>
<p>結果這題我想了很久後，還是想不太出來，查了查詳解後才知道這題應該直接用暴力破解的方式將她解出，由於 DFS 的時間複雜度是 \(O(n^m)\)，n 是邊數、m 是深度，而這裡的最大時間複雜度應該是 \(25^5 = 9765625\)，在時間複雜度低於 2000 萬以內，基本上一個良好的 OJ 都能夠順利解開，因此我們就直接使用 DFS。</p>
<p>怎麼做呢?</p>
<p>作法很簡單，不斷進行 DFS，必且深度搜尋，當深度抵達 5 時，判斷城市中所有 area 到行政據點的最短距離乘上人口數量，找出最小值，就是我們要的答案。</p>
<p>需要注意的是，那個區域只需要<strong>找到一個行政據點</strong>距離最小就好，我這邊還卡了一下..。</p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://blog.csdn.net/mobius_strip/article/details/86564658" target="_blank" rel="noopener">UVa 10660 - Citizen attention offices by 小白菜又菜</a><br><a href="https://zh.wikipedia.org/wiki/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2" target="_blank" rel="noopener">深度優先搜尋 by Wiki</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>習慣性看到這種題目就是要找規律，然後找到可以優化的點進行優化，就能輕鬆解出。雖然大部分時間都找不出來優化點….QQ。我不夠聰明RRR。</p>
<p>經過了這題後，稍微沒有那麼思考僵化了，其實有的時候一直過度寫同樣題目容易造成自己的思考模式都往同個部分思考，現在有寫過這題後對於思考方式又更發散了一些。雖然說太發散找不到方向，但是不發散絕對找不到正確答案。</p>
<p>總之，希望自己 ICPC 可以得到銀獎，拜託了。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 30 <span class="comment">//題目最大區域量，保險起見開更大</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> num[MAXN], ans[MAXN], result[MAXN];</span><br><span class="line"><span class="comment">//num 題目的區域，ans 我們要輸出的答案，result 當前 DFS 中每個區域到行政據點最短距離的總和</span></span><br><span class="line"><span class="comment">//ans, result 只會用到前 5 個陣列值</span></span><br><span class="line"><span class="keyword">int</span> t, n, a, b, c; <span class="comment">//輸入資料用</span></span><br><span class="line"><span class="keyword">int</span> d = MAXN*MAXN*<span class="number">1000</span>; <span class="comment">//理論上每個區域到行政據點最大距離不超過此值，因為人口最多只有 1000</span></span><br><span class="line"><span class="comment">//因此 25個區域*最大距離25(不可能達到)*人口數量，可以當作此題的最大值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> office)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(office &gt;= <span class="number">5</span>)&#123; <span class="comment">//如果建立了 5 個辦公室，就開始找每個區域到行政據點最短距離的總和</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>; <span class="comment">//當前 DFS 每個區域到行政據點最短距離的總和</span></span><br><span class="line">        <span class="comment">//cout &lt;&lt; "result " &lt;&lt; result[i] &lt;&lt; '\n';</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">25</span>; j++)&#123; <span class="comment">//遍地每個區域</span></span><br><span class="line">            <span class="keyword">int</span> compute = MAXN*MAXN*<span class="number">1000</span>, temp; </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123; <span class="comment">//判斷哪個行政據點離當前區域最短</span></span><br><span class="line">                temp = num[j] * (<span class="built_in">abs</span>(result[i]/<span class="number">5</span> - j/<span class="number">5</span>) + <span class="built_in">abs</span>(result[i]%<span class="number">5</span> - j%<span class="number">5</span>));</span><br><span class="line">                compute = min(temp, compute); <span class="comment">//取最小的</span></span><br><span class="line">            &#125;</span><br><span class="line">            sum += compute; <span class="comment">//加到 sum</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定義: A = 每個區域到行政據點最短距離的總和</span></span><br><span class="line">        <span class="keyword">if</span>(sum &lt; d)&#123; <span class="comment">//如果當前的 A 比過去中最小的 A，還小就取代</span></span><br><span class="line">            <span class="comment">//cout &lt;&lt; "test:" &lt;&lt; sum &lt;&lt; ' ';</span></span><br><span class="line">            d = sum; <span class="comment">//將答案值替換</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123; <span class="comment">//將答案值替換</span></span><br><span class="line">                ans[i] = result[i];</span><br><span class="line">                <span class="comment">//cout &lt;&lt; result[i] &lt;&lt; ' ';</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; '\n';</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = p+<span class="number">1</span>; i &lt; <span class="number">25</span>; i++)&#123; <span class="comment">//不斷進行 DFS，做所有的排列組合</span></span><br><span class="line">        result[office] = i; <span class="comment">//當前的第 office 的辦公室為 i 區域 </span></span><br><span class="line">        dfs(i, office+<span class="number">1</span>); <span class="comment">//往下一層邁進，題目有說明輸出要遞增，因此 i 必須是 p+1，否則會重覆到</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">()</span></span>&#123; <span class="comment">//debug 用</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; num[i*<span class="number">5</span>+j] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="built_in">memset</span>(num, <span class="number">0</span>, <span class="keyword">sizeof</span>(num)); <span class="comment">//清空，以免干擾這次資料</span></span><br><span class="line">        <span class="keyword">while</span>(n--)&#123; <span class="comment">//輸入資料</span></span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">            num[a*<span class="number">5</span>+b] = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//debug();</span></span><br><span class="line">        d = MAXN*MAXN*<span class="number">1000</span>;</span><br><span class="line">        dfs(<span class="number">-1</span>, <span class="number">0</span>); <span class="comment">//一開始是 -1 是因為，我們的 DFS 排列組合迴圈是 p+1</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">5</span>; i++) <span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; ans[i]; <span class="comment">//輸出答案</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>暴力搜尋 Brute force</tag>
      </tags>
  </entry>
  <entry>
    <title>2021/04/03 跟蘇子權一起看哥吉拉大戰金剛</title>
    <url>/2021/04/05/life_experence/Godzilla-vs.-Kong-by-subarya/</url>
    <content><![CDATA[<h2 id="說明"><a href="#說明" class="headerlink" title="說明"></a>說明</h2><blockquote>
<p>之前在新北市奧林匹亞資訊認識的好朋友，後來考上台灣師大，問她要不要陪我去看哥吉拉大戰金剛</p>
</blockquote>
<a id="more"></a>

<h2 id="相約"><a href="#相約" class="headerlink" title="相約"></a>相約</h2><p>我其實很想要去看<a href="https://theriseofdavid.github.io/2021/04/05/movie/Godzilla-vs.-Kong/" target="_blank" rel="noopener">哥吉拉大戰金剛</a>，我就在想要找誰一起去，就在 fb 看到子權的貼文，我就想要問她要不要陪我去看XD。</p>
<p>我原本跟她約 04/02，結果他不行QQ，後來我們就改約 04/03。</p>
<h2 id="見面"><a href="#見面" class="headerlink" title="見面"></a>見面</h2><p>我們原本是約下午 4 點，但我後來我晚上 7 點有要弄資產配置競賽要開會阿，然後我保險的那 Part 還沒有做QQQ，所以我就在 3 號晚上 12 點趕快問子權能不能改時間，子權也馬上就說可以啦！</p>
<p>然後隔天見面，恩..我遲到了，讓子權等了我 30min 實在非常抱歉，我下次會改進的QQ。</p>
<h2 id="看電影"><a href="#看電影" class="headerlink" title="看電影"></a>看電影</h2><p>稍微聊了天後就去看電影，沒想到哥吉拉的電影場次人這麼多，多到爆炸RRRR，都快比公車班次還多了！</p>
<p>進去電影院後，我們買了爆米花跟可樂來搭配，結果子權說他可以在電影還沒播放前就把爆米花吃完，太強了阿阿阿，講了一些趣事後，電影就開始了。</p>
<h2 id="吃飯"><a href="#吃飯" class="headerlink" title="吃飯"></a>吃飯</h2><p>看完電影後我們稍微吃下兩餐，兩餐不能預約只能夠排隊叫號，於是我們就當場去然後排隊等號碼，原本服務生是跟我們說 54 號，但我有點忘記了我就問子權說 52 號嗎？他就說，對啊！然後看到顯示牌說 52 號可以入場，我們就進去，結果服務員在跟我們確認的時候才說我們是 54 號！害我們尷尬了一下XDD。</p>
<p>而且子權的專題很酷，中天新聞留言分析，感覺超級酷的。我自己覺得這是個很好的專題點子，可惜我沒想到阿，我的想像力變差了QQ。<br>不過聽說師大的虛擬機有點爛，有點小難過:(，雖然北科的比較好一點拉，就一點。</p>
<p>吃飯的過程中，我們聊天，聊了很多師大的八卦，離散數學、邏輯課…，離散數學我也是上的超級認真，就可以跟他有來有往，我還怕我老人腦袋裡的知識都輸給年輕人呢QQQ。</p>
<h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>跟他聊天，其實真的很快樂，而且又能獲得很多新知識，是我的好朋友，希望我可以都跟他保持聯絡我們的感情不會淡掉，那他就不可以忘記我呢！所以我要多在他快忘記我的時候出現XD。</p>
<p>總之，我覺得他是我生命中很信賴的人拉，失去的信賴的人總是會難過的，所以不可以難過的方法就是不失去XD。</p>
]]></content>
      <categories>
        <category>人生旅途</category>
      </categories>
      <tags>
        <tag>大學Life</tag>
        <tag>人生旅途</tag>
      </tags>
  </entry>
  <entry>
    <title>快速建立屬於你的 online judge</title>
    <url>/2021/03/29/linux/linux-build-online-judge/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>在北科大二下時我擔任了資財-資料結構的助教，負責設計考卷，看了先前的考古題後發現老師都是讓大家手寫程式，我認為這樣沒有辦法讓大家學到資料結構的知識，因此這邊做一個小創新，讓大家都學習如何使用 online judge</p>
<p>透過大家使用 online judge 就可以讓大家在有限的時間內寫出程式，感受壓力，並也在感受壓力的過程中將資料結構成功記住！</p>
<p>就因為這樣，我稍微去學習如何快速建立 online judge，透過中國青島大學開源的 online judge，在這邊很感謝中國青島大學，讓我可以快速的建立起 online judge QQ。</p>
</blockquote>
<a id="more"></a>

<h2 id="QDUOJ"><a href="#QDUOJ" class="headerlink" title="QDUOJ"></a>QDUOJ</h2><p>中國青島大學開源的 online judge，建立容易，且有很直觀的後台管理、使用者使用環境，在這三大優點下，使用此開源 online judge。</p>
<p><a href="https://github.com/QingdaoU/OnlineJudgeDeploy/tree/2.0" target="_blank" rel="noopener">QDUOJ 佈署</a>連結，如果看不太懂我的寫法，建議直接去看 QDUOJ 的XD。</p>
<p>建議不要使用 windows 安裝，只使用 linux，windows 有太多地雷了…，沒有的話可以在 windows 裡面開虛擬機。<br><del>我在 windows 環境下用虛擬機再用 docker，虛擬在虛擬，這難道是幻覺嗎RRRRRR</del></p>
<h2 id="環境設定"><a href="#環境設定" class="headerlink" title="環境設定"></a>環境設定</h2><p>在 docker 中建立 online judge，docker 將作業系統虛擬化，可以讓 online judge 更快速的被執行與建立，因為只有服務 online judge 嘛。<br>還有一個好處是如果 online judge 爛掉，不至於會讓整個作業系統爛掉，只會讓 docker 爛掉而已XD。</p>
<p>建議先輸入這三行，檢查是否所有需要的環境設定是否有安裝</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get update &amp;&amp; sudo apt-get install -y vim python3-pip curl git</span><br><span class="line">pip3 install --upgrade pip</span><br><span class="line">pip install docker-compose</span><br><span class="line">sudo curl -sSL get.docker.com | sh</span><br></pre></td></tr></table></figure>

<h2 id="開始安裝"><a href="#開始安裝" class="headerlink" title="開始安裝"></a>開始安裝</h2><p>不多說，repo 拉下來就對了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone -b 2.0 https:&#x2F;&#x2F;github.com&#x2F;QingdaoU&#x2F;OnlineJudgeDeploy.git &amp;&amp; cd OnlineJudgeDeploy</span><br></pre></td></tr></table></figure>

<h2 id="建立-docker-服務"><a href="#建立-docker-服務" class="headerlink" title="建立 docker 服務"></a>建立 docker 服務</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo docker-compose up -d</span><br></pre></td></tr></table></figure>

<p>這裡要等一段時間，大約半小時左右就會建立成功。</p>
<h2 id="享受-docker-服務"><a href="#享受-docker-服務" class="headerlink" title="享受 docker 服務"></a>享受 docker 服務</h2><p>輸入 <code>sudo docker ps -a</code>，如果正確則應該會出現類似此畫面</p>
<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1Q9jNBzboAqaDPZQ070xDa1HBj5-4sBPx&export=download" alt=""></p>
</blockquote>
<h2 id="來整理我們的-online-judge-八！"><a href="#來整理我們的-online-judge-八！" class="headerlink" title="來整理我們的 online judge 八！"></a>來整理我們的 online judge 八！</h2><p>如果對於我的講解認為不夠好的，可以查看<a href="https://docs.onlinejudge.me/" target="_blank" rel="noopener">QDUOJ 教學說明</a></p>
<p>到 browser 打 <code>localhost:80</code>，應該能夠順利出現網頁，畫面如下</p>
<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=18-pHEQoLwUZUACZx5kEu1Rg183tRwHxL&export=download" alt=""></p>
</blockquote>
<h3 id="進入後台"><a href="#進入後台" class="headerlink" title="進入後台"></a>進入後台</h3><p>我們先進入管理者的權限，查看後台配置</p>
<ul>
<li>管理者帳號 <code>root</code></li>
<li>管理者密碼 <code>rootroot</code></li>
</ul>
<p>如果怕其他人也知道管理者的密碼時，建議大家將 root 密碼改掉XD。</p>
<p>再來點選 root -&gt; management，進入管理頁面</p>
<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1Ec8StoEFVBt9BV4wI1S_lOUzQWJxLvnd&export=download" alt=""></p>
</blockquote>
<p>讓我們來看看有那些功能，我們先看有關於使用者的功能，點擊 General</p>
<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1tPzXULZP-urt3z7KUpE6VtT1biXDOsmT&export=download" alt=""></p>
</blockquote>
<p>依序功能如下：</p>
<ul>
<li>user 所有使用者的資訊，帳號密碼</li>
<li>announcement 可以發布公告，有就是在 home 的畫面在那邊會有新的留言公告</li>
<li>後面三個我們不會用到，因此先忽略</li>
</ul>
<h3 id="註冊-user"><a href="#註冊-user" class="headerlink" title="註冊 user"></a>註冊 user</h3><p>進入 user 頁面後，會發現只有 root 這個用戶QQ，</p>
<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=18pg7_6c82ZQ4h27tl9Prodji_5-x1nNP&export=download" alt=""></p>
</blockquote>
<p>進來這個頁面後，<code>import user</code> 提供 csv 輸入會員資料，格式如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">memberA,passwordA,email</span><br><span class="line">memberB,passwordB,email</span><br></pre></td></tr></table></figure>

<p>下方的 Generate User 可以快速的生成 user，參數如下</p>
<ul>
<li><code>prefix</code> 帳號的前綴字元</li>
<li><code>suffix</code> 帳號的後綴字元</li>
<li><code>start number</code> 帳號中間要塞入的數字起點</li>
<li>````end number``` 帳號中間要塞入的數字終點</li>
<li><code>password length</code> 密碼長度，會是高強度密碼(簡稱亂碼)</li>
</ul>
<p>因此假如 prefix = a, suffix = v, start number=2, end number = 4, password length = 4，就會產生以下的會員</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a2v,xxxx,xx@gmail.com</span><br><span class="line">a3v,xxxx,xx@gmail.com</span><br><span class="line">a4v,xxxx,xx@gmail.com</span><br></pre></td></tr></table></figure>

<p>如此的概念，其中 xxxx 是高強度密碼(亂碼)</p>
<h2 id="發布公告"><a href="#發布公告" class="headerlink" title="發布公告"></a>發布公告</h2><p>點入 general 在點擊 announcement，就可發布公告</p>
<h2 id="加入題目"><a href="#加入題目" class="headerlink" title="加入題目"></a>加入題目</h2><p>這是最重要的部分，如果沒有的話怎麼讓大家寫題目嘛</p>
<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1hBp92mbyy9Kr3jwtSASxm8E3pXFmFEKK&export=download" alt=""></p>
</blockquote>
<p>點擊 problem 後可以點 problem list 看到現在所有的題目，而其中的 <code>create problem</code> 則可以建立題目，點擊他</p>
<p>相信上面大家都會使用，需要注意的是 sampleX，X 為數字，則是顯示在題目上的範例測資中，實際的官方測資則是要從這裡加入</p>
<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1xzGD6wEYtk-0h9IlEQAIgGv3Ve6k_Fae&export=download" alt=""></p>
</blockquote>
<p>圖中的 Choose File 中加入，特別需要值得一提的是</p>
<ul>
<li><code>filename.in</code> 是程式輸入的題目資料</li>
<li><code>filename.out</code> 則是程式輸出的正確資料</li>
</ul>
<p>而旁邊的 type 有</p>
<ul>
<li>ACM 全對才給分</li>
<li>OI 對測資就給分，有部分給分。</li>
</ul>
<h2 id="建立競賽"><a href="#建立競賽" class="headerlink" title="建立競賽"></a>建立競賽</h2><p>點擊左邊的資訊欄中的 contest，再點擊 creat contest，過程相信大家都懂不需要我在說，create contest 完畢後，在點擊資訊欄中的 contest list，</p>
<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1UqxZCUNfNnGeHUXbJvHkFY80GYACAtaW&export=download" alt=""></p>
</blockquote>
<p>點擊此按鈕就可以加入題目，開始放入題目八！不管是公開的題目還是私有的題目都可以，而加入題目的方式就跟我們前面說的<strong>加入題目</strong>一樣啦。</p>
<h2 id="現在來到最後一個問題，如何讓外網連到我的-judge-呢"><a href="#現在來到最後一個問題，如何讓外網連到我的-judge-呢" class="headerlink" title="現在來到最後一個問題，如何讓外網連到我的 judge 呢?"></a>現在來到最後一個問題，如何讓外網連到我的 judge 呢?</h2><p>這裡我們使用 ngrok 來幫我們代理伺服器，提供我們網址。</p>
<p>教學如下 <a href="https://theriseofdavid.github.io/2020/07/24/ngrok-experience/" target="_blank" rel="noopener">透過 ngrok 來讓自己的電腦成為 server by 大衛的筆記</a></p>
<p>port 可以隨意設定，之後產生的網址我們就可以對外發布，讓他人連線了！</p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://github.com/QingdaoU/OnlineJudgeDeploy/tree/2.0" target="_blank" rel="noopener">QDUOJ 佈署 by 中國青島大學</a><br><a href="https://docs.onlinejudge.me/" target="_blank" rel="noopener">QDUOJ 教學說明 by 中國青島大學</a><br><a href="https://blog.techbridge.cc/2020/03/20/build-your-own-online-judge/" target="_blank" rel="noopener">自己架一個 Online Judge 系統 by TechBrige</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>QDUOJ 真的是很方便，讓我可以在短短幾個小時內學會並且運用此軟體，真的是太感動了QQ，希望我以後也有一天可以將自己所學到的技術分享給他人。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>linux</tag>
        <tag>online judge</tag>
      </tags>
  </entry>
  <entry>
    <title>電影觀後感 - 哥吉拉大戰金剛 (4/5)</title>
    <url>/2021/04/05/movie/Godzilla-vs.-Kong/</url>
    <content><![CDATA[<h2 id="前情概要"><a href="#前情概要" class="headerlink" title="前情概要"></a>前情概要</h2><blockquote>
<p>1973年骷髏島探勘事件過後的50多年，骷髏島的氣候巨變使島上的原住民伊維族幾乎全數罹難，只留下小孤女吉雅。與此同時，根據挖掘所發現的史前壁畫及後續研究，君主組織得知了哥吉拉與金剛的世仇，故此君主在骷髏島建立了基地以保護金剛。吉雅的養母，艾琳·安德魯博士多年來一直試圖與金剛進行溝通但不果。自五年前的泰坦混戰後，哥吉拉與人類一直和平共處，但此刻卻多次襲擊高科技公司「頂極神經機械企業」（Apex）的工廠，一名潛入頂極臥底的播客柏尼·海斯不僅目睹了過程，更意外地發現頂極似乎在秘密研製不明裝置。</p>
<div class="video-container"><iframe src="https://www.youtube.com/embed/s1DUC_wBUvY" frameborder="0" loading="lazy" allowfullscreen></iframe></div>
<p><a href="https://zh.wikipedia.org/wiki/%E5%93%A5%E5%90%89%E6%8B%89%E5%A4%A7%E6%88%B0%E9%87%91%E5%89%9B" target="_blank" rel="noopener">資料來源</a></p>
</blockquote>
<a id="more"></a>

<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>整體對於這部片得打鬥感，算是蠻不賴得，就是中間的劇情零散了些。</p>
<p>我全部的記憶點只圍繞者打鬥XD。</p>
<h3 id="金剛與哥吉拉在海上的打鬥"><a href="#金剛與哥吉拉在海上的打鬥" class="headerlink" title="金剛與哥吉拉在海上的打鬥"></a>金剛與哥吉拉在海上的打鬥</h3><p>打得好爽，可是我真的覺得哥吉拉有夠強欸，哥吉拉整個腳色就是強於金剛阿，金剛似乎有種被馴服的感覺，願意與人類和平共處，而哥吉拉是海上的霸主比較內向不太喜歡與人們互動，但一直很喜歡跟金剛打鬥，金剛在這次的戰鬥中輸了。</p>
<p>原因主要是因為哥吉拉在海中可以像魚一般游泳，而金剛不可以，加上哥吉拉有那強大的破壞死光，遠程傷害來說根本 MAX 八XDDDD。</p>
<p>還有金剛的毛被海弄濕的畫面感很讚，只是有點太多毛好噁心QQQQ。</p>
<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1ZkjAVPLWIO-AaxVLWfx1RxEydnjUyd1f&export=download" alt=""></p>
</blockquote>
<h3 id="金剛回到地心中的地球"><a href="#金剛回到地心中的地球" class="headerlink" title="金剛回到地心中的地球"></a>金剛回到地心中的地球</h3><p>回到地心地球時有遇到泰坦翌守龍</p>
<p>金剛回到地心中的地球時，拿到了他的武器，而尖端科技也取得了他們所需要的能源，把能源送回地球表面給尖端科技使用。</p>
<p>這邊有很多盲點QQQ，到底為甚麼尖端科技採集到的石頭可以直接傳回地球表面拉XDDD，那邊又沒有網路而且理論上衛星也沒有辦法可以接受到阿。</p>
<p>但後來這邊壞主角的女兒死掉真的是大快人心，不得不說，要是他這邊有平安回到地球我真的會氣得牙癢癢的，他們這邊刻畫得很讚。</p>
<h3 id="金剛與哥吉拉在香港大戰"><a href="#金剛與哥吉拉在香港大戰" class="headerlink" title="金剛與哥吉拉在香港大戰"></a>金剛與哥吉拉在香港大戰</h3><p>香港，辛苦你了。最近怎麼大家都喜歡摧殘你們QQQQ。</p>
<p>感覺哥吉拉跟金剛踩死了一堆人類阿QQQ，在地心地球時金剛有用他的斧頭進行充能，對抗哥吉拉的破壞死光時，則用斧頭擋住。<br>最後金剛則打輸，被哥吉拉在胸前用爪子留下爪痕來表示戰勝的痕跡。</p>
<p>後來女博士跟男博士透過能通往地心地球的飛機，透過那飛機大量傳輸電力來讓金剛復活，有種 AED 的概念XDDD。</p>
<p>男博士那邊特別好笑，女博士跟小女孩那時候一起欺騙男博士，讓男博士認為膽小鬼的手語是勇敢的意思，這個真的有好笑到</p>
<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1xCvd5E2hs25H08QrCRW13KpZhOm3uRLi&export=download" alt=""></p>
</blockquote>
<h3 id="兩隻泰坦與機械哥吉拉的戰鬥"><a href="#兩隻泰坦與機械哥吉拉的戰鬥" class="headerlink" title="兩隻泰坦與機械哥吉拉的戰鬥"></a>兩隻泰坦與機械哥吉拉的戰鬥</h3><p>老實講，這裡超讚的，我原本其實超級害怕機械哥吉拉會把哥吉拉給擊敗成為世界的王，那樣我會覺得哥吉拉很可憐，尖端科技超壞。<br>幸好不是像我預料的那樣，而是尖端科技的哥吉拉成為了一個新巨獸，後來小女孩跟金剛溝通表示敵人是機械哥吉拉，金剛與哥吉拉一起聯手打敗他。</p>
<p>其中最後一擊哥吉拉將她的死亡白光充能給金剛的斧頭，真的不是我想說XDDD，金剛的斧頭如果可以充能的話，那前面的戰鬥金剛幹嘛都只拿斧頭擋攻擊阿，順便充能RRRR，這樣不就贏了嗎XD。</p>
<p>機械哥吉拉有夠強，他加速度有引擎可以衝刺，近距離的爪子則改為鑽頭，連揮爪子都不用，只須要往前一刺，可能沒有一個泰坦扛得住QQQ。</p>
<p>然後特別好笑的是，這裡面的泰坦死法是，一定要將它們的頭給抓下來才表示死亡，不然大家都有復活的機會欸XDDD，某種類型來說也蠻像僵屍的XD。</p>
<h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>其中另外一個有黑人的支線這次很奇怪扮演著一個關鍵的角色，但感覺卻被輕描淡寫，黑人與尖端科技總理的小女孩都保持著大膽的作法，而在最後機械哥吉拉站起來時卻是胖胖的男生拯救，理論上胖胖男生應該可以得個甚麼和平獎八XD。</p>
<p>胖胖男生感覺就很聰明，而且又很喜歡尖端科技總理的小女孩，會不會在一起R，可是感覺尖端科技總理的小女孩就會喜歡上那些一樣大膽的男孩，可能不會喜歡喝自來水的小胖男孩QQQ。</p>
<p>支線劇情讓我覺得似乎沒有很重要，但又不可以缺乏他，否則最後的片段我們會不知道在演甚麼XD。</p>
<p>我是哥吉拉派的，我覺得哥吉拉也是很聰明而且他從一開始就知道自己最需要解決的對手是誰，才會進行戰鬥，後面也都沒有將金剛直接做一個擊殺，雖然殺掉那打機械哥吉拉那可能就是一場災難了QQ。</p>
<p>金剛只是剛好被人馴服，才會顯得它忠厚老實八(?，否則我認為哥吉拉她其實也是用著他的方法在保全他的周遭，不能很確定他有沒有想要保全人類的心，但可以知道只少牠對人類沒有敵意，不然破壞死光一下去似乎大家都沒轍八XD。<br>所以人們才需要金剛，不然也會害怕沒有對手可以將哥吉拉牽制或打敗。</p>
<p>而原住民小孩則當起了訓獸師，讓人類與金剛有著可以溝通的橋樑。</p>
<p>難得這次的電影反派不是中國人，可是好像也沒有中國人出場，怎麼講，感覺偶爾少了個帶入感XD。沒有那種阿華人又被當成反派，我又要被別人打輸的感覺了XD。</p>
<p>而且這次的反派我覺得演得剛剛好，有他的理想，他也願意努力去實現，只是手段比較激進，但我認為也沒有錯，只是作風不同。<br>但確實在現實世界或是電影中，大膽追求革新的人們總是不容易獲得幸福與理想實現化的可能，總是需要一步一步的改革，不可以讓太多的保守派因為反感他們而採取行動，而是像溫水煮青蛙那樣讓保守派的人們認為這件事情不會很<strong>可怕</strong>。</p>
<p>改革與保守都有其相對應的好處，在團隊下保守、在個人下改革，我認為應該是目前比較不會造成大量爭議性的方法(?，不過我才大二，其實也還不太懂甚麼是團隊，畢竟也沒有真的在一個超過 1000 人的大團隊下工作過，可能會被很多人認為是菜鳥八XD。</p>
]]></content>
      <categories>
        <category>電影心得</category>
      </categories>
      <tags>
        <tag>人生旅途</tag>
        <tag>電影心得</tag>
        <tag>戰鬥類電影心得</tag>
      </tags>
  </entry>
  <entry>
    <title>R 推薦的 json 套件</title>
    <url>/2021/04/06/R/Rjson/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>R 有著很多不穩定的套件，我在 R 使用有關於 json 的套件時，發現讀 json 有著許多問題，特地在這邊留下紀錄</p>
</blockquote>
<a id="more"></a>

<h2 id="讀網路上的-json-資料"><a href="#讀網路上的-json-資料" class="headerlink" title="讀網路上的 json 資料"></a>讀網路上的 json 資料</h2><p>當初很認真的去解決此問題，但沒有留下紀錄，很感謝那些讓我可以學習到知識的人。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="keyword">library</span>(jsonlite)</span><br><span class="line">domino_api &lt;- GET(<span class="string">"https://youtube.com"</span> , timeout(<span class="number">40</span>) , encode = <span class="string">"multipart"</span>,  accept_json())</span><br><span class="line">domino_json &lt;- fromJSON(content(domino_api,type=<span class="string">"text"</span>,encoding = <span class="string">"UTF8"</span>))</span><br></pre></td></tr></table></figure>

<h2 id="讀本地上的-json"><a href="#讀本地上的-json" class="headerlink" title="讀本地上的 json"></a>讀本地上的 json</h2><p>這邊十分推薦 rjson 此套件包，他在讀本地 json 檔案，不容易有格式問題。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="keyword">library</span>(rjson)</span><br><span class="line"></span><br><span class="line">before_data &lt;- rjson::fromJSON(file =<span class="string">"dominoV2.json"</span>)</span><br></pre></td></tr></table></figure>

<p>如果使用 <code>read_json</code>，讀進來 R 時容易有此問題。</p>
<ul>
<li>原本的 json 資料，尚未使用 <code>read_json</code> and <code>write_json</code><br><img src="https://drive.google.com/u/2/uc?id=1RNGiKk3mj1Bel74_MBFDppmtcGoKOucG&export=download" alt=""></li>
<li>經過 R 並且執行  <code>read_json</code> and <code>write_json</code><br><img src="https://drive.google.com/u/2/uc?id=1D4nMYBHpf0nWLNalblF8DsAskh3dAB9J&export=download" alt=""></li>
</ul>
<p>可以明顯知道，裡面的每一個欄位又都被包了一個 list，這樣非常不好，但我們使用套件的人員沒辦法解決此問題，因此只能夠換另一個套件包啦。</p>
<p><a href="https://stackoverflow.com/questions/2617600/importing-data-from-a-json-file-into-r" target="_blank" rel="noopener">參考連結</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>R 真的好難RRR，這邊這個真的會弄得亂糟糟。太多套件太混亂了，加上中文資源並不多，所以大部分都從國外或是中國學資源。</p>
<p>希望我可以做一個轉發，讓大家知道國外資源，也可以透過中文字來讓大家更快的解決問題。</p>
<p>我解決這個問題花了 8 小時，很累QQ。</p>
<p>期望 R 可以統整功能相似的包在一起，再有一個完整的說明文件，那就更棒了！</p>
]]></content>
      <categories>
        <category>R語言</category>
      </categories>
      <tags>
        <tag>R語言</tag>
        <tag>學習筆記</tag>
        <tag>json</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces 1483D - Playlist(Disjoint Set 並查集)</title>
    <url>/2020/08/31/Codeforces/Codeforces%201483D/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>有一個數列可以被一種方式移除，只要當前的數值與下一個數值是 \(gcd = 1\) 的情況就將後面的數值取出並記錄 index。</p>
<p>請輸出有幾個數值被取出，並且那些 index 為何。</p>
<p><a href="https://codeforces.com/contest/1483/problem/B" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li>了解 GCD</li>
<li>減少重複比對</li>
<li><a href="https://theriseofdavid.github.io/2021/02/02/Explain_Algorithm/disjoint-set/" target="_blank" rel="noopener">熟悉並查集</a></li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>我們可以先稍微進行分析</p>
<ul>
<li>只要 <code>gcd == 1</code> 就是移除後面的數值</li>
<li>重複的比對相同數值是題目絕對不允許的</li>
</ul>
<p>這時我們可以用一種方式來進行思考，如果我們將 <code>gcd == 1</code> 後不將後者數值刪除，而是告訴前者數值的下一個數值是哪個的時候是不是可以解決問題？</p>
<p>舉例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">index: 1 2 3</span><br><span class="line">value: 1 2 3</span><br><span class="line">merge: 1 2 3</span><br></pre></td></tr></table></figure>

<p>其中前兩項 <code>gcd = 1</code>，這時我們只修改 merge 為</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">index: 1 2 3</span><br><span class="line">value: 1 2 3</span><br><span class="line">merge: 2 2 3</span><br></pre></td></tr></table></figure>

<p>表示我們現在只要到 index 1 的時候就直接到 index 3，跳過被合併的 2，這樣我們可以減少大量的刪<br>除動作。</p>
<p>現在我們可以知道一件事 merge 中相同數值的第一個 index 必定是尚未被消除過的數值，其他的 index 一定有被消除過且最後一個 index 必定等同於 merge 的數值。<br>這裡我們寫程式方便，會有一個 <code>del</code> 陣列來記錄被消除的 index。</p>
<p>再來我們要減少重複比對，這時候就需要一個 <code>queue</code> 了，由於我們知道 <code>gcd(x,y)</code> 與 <code>gcd(y,x)</code>，一定相同，因此我們可以降低重複比對。</p>
<p>假如現在有三個值 x,y,z，且都 \(gcd != 1\)，那我們只要做三遍 gcd 就可以知道這三個數值保證 \(gcd != 1\)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcd(x,y)</span><br><span class="line">gcd(y,z)</span><br><span class="line">gcd(z,x)</span><br></pre></td></tr></table></figure>

<p>這時我們就又知道了一件事情，每個數值都只會跟自己的下一個數值做 <code>gcd</code>，因此我們的 <code>queue</code> 只要記錄 gcd 的前項就好，後項不需要紀錄。</p>
<p>那有沒有可能後項會被 gcd 的操作給移除掉? 不可能。<br>用上面的舉例，如果 <code>gcd(x,y)</code>，y 沒有被移除，那 y 在下次的 <code>gcd(y,z)</code> 不可能會被移除。</p>
<p>因此我們可以得出結論</p>
<ul>
<li>使用並查集來 merge 消除的數值</li>
<li>我們用 queue 紀錄 gcd 的第一項</li>
<li>如果 <code>gcd(x,y) == 1</code>，那就讓 vector 紀錄 y，並且 <code>queue.push(x)</code>，因為 x 的下一個數值不在是 y，我們沒辦法保證 <code>gcd(x,z) == 1</code>，需要重做才知道。</li>
</ul>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://zhuanlan.zhihu.com/p/359628701" target="_blank" rel="noopener">Codeforces Round #709 (Div. 1, based on Technocup 2021 Final Round) by 一只蒟蒻</a><br><a href="https://www.cnblogs.com/-Wallace-/p/cf-709.html" target="_blank" rel="noopener">Codeforces Round #709 (Div. 1, based on Technocup 2021 Final Round) by <em>Wallace</em></a><br><a href="https://codeforces.com/blog/entry/88944" target="_blank" rel="noopener">Codeforces Round #709 / Technocup 2021 Final Round — Unofficial Editorial by Geothermal’s blog</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>這題學到很多，第一次意識到 disjoint set 也可以這樣操作，學了很多啊。</p>
<p>希望自己透過這樣子的學習可以讓自己變得更強，並且更加靈活地應用在生活上！</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e6</span>;</span><br><span class="line"><span class="keyword">int</span> a[MAXN], fa[MAXN], del[MAXN]; <span class="comment">//a 是數值，fa 是 merge，del 是那些 index 被消除過</span></span><br><span class="line"><span class="keyword">int</span> t, n;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; record; <span class="comment">//紀錄答案</span></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_root</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="comment">//並查集</span></span><br><span class="line">    <span class="keyword">return</span> fa[x] == x ? x : fa[x] = find_root(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        q.clear(); <span class="comment">//清空，避免影響此次答案</span></span><br><span class="line">        record.clear();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123; <span class="comment">//輸入資料</span></span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">            fa[i] = i;</span><br><span class="line">            del[i] = <span class="number">0</span>; <span class="comment">//清空</span></span><br><span class="line">            q.push_back(i); <span class="comment">//將未比對的 gcd 的數值放入 q</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123; <span class="comment">//如果空了表示，全部都有比對過</span></span><br><span class="line">            <span class="keyword">int</span> u = q.front(); q.pop_front(); <span class="comment">//</span></span><br><span class="line">            <span class="keyword">if</span>(del[u]) <span class="keyword">continue</span>; <span class="comment">//如果這邊之前有被消除過，就不需要比對</span></span><br><span class="line">            <span class="keyword">int</span> v = (find_root(u)+<span class="number">1</span>) % n; <span class="comment">//下一個未被消除的位置</span></span><br><span class="line">            <span class="keyword">if</span>(v == <span class="number">0</span>) v = n; <span class="comment">//如果是 0 是因為 mod 的問題，因此改回 n</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(__gcd(a[u], a[v]) == <span class="number">1</span>)&#123; <span class="comment">//可以被消除</span></span><br><span class="line">                record.push_back(v); <span class="comment">//紀錄消除的 index</span></span><br><span class="line">                <span class="keyword">int</span> fu = find_root(u); <span class="comment">//合併</span></span><br><span class="line">                <span class="keyword">int</span> fv = find_root(v);</span><br><span class="line">                fa[fu] = fv; <span class="comment">//讓 fv 的值給到 fu，f 表示 father</span></span><br><span class="line">                del[v] = <span class="number">1</span>; <span class="comment">//v 被移除</span></span><br><span class="line">                q.push_back(u); <span class="comment">//u 被放入，因為 gcd 的 v 被移除掉，他接下來還會匹配到新的 v</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; record.size(); <span class="comment">//輸出答案</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it: record) <span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; it;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>Disjoint Set 並查集</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>北科通識課 國際關係 - 比較 G20 與台灣</title>
    <url>/2021/04/07/NTUT_note/NTUT_national_relation/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用來記錄大衛在台北科技大學通識課 - 國際關係，何揚老師上課的作業。</p>
<p>G20 與台灣的關係比較圖</p>
<p>其資料都來自於 wiki</p>
</blockquote>
<a id="more"></a>

<h2 id="參考來源"><a href="#參考來源" class="headerlink" title="參考來源"></a>參考來源</h2><p><a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8D%81%E5%9C%8B%E9%9B%86%E5%9C%98" target="_blank" rel="noopener">二十國集團 by wiki</a><br><a href="https://zh.wikipedia.org/wiki/%E4%BA%BA%E9%A1%9E%E7%99%BC%E5%B1%95%E6%8C%87%E6%95%B8%E5%88%97%E8%A1%A8" target="_blank" rel="noopener">人類發展指數列表 by wiki</a><br><a href="https://zh.wikipedia.org/wiki/%E4%B8%96%E7%95%8C%E5%90%84%E5%9B%BD%E5%92%8C%E5%9C%B0%E5%8C%BA%E9%9D%A2%E7%A7%AF%E5%88%97%E8%A1%A8" target="_blank" rel="noopener">世界各國和地區面積列表 by wiki</a><br><a href="https://en.wikipedia.org/wiki/Military#Capability_development" target="_blank" rel="noopener">Military by wiki</a><br><a href="https://en.wikipedia.org/wiki/List_of_countries_by_life_expectancy" target="_blank" rel="noopener">List of countries by life expectancy by wiki</a></p>
<h2 id="內容"><a href="#內容" class="headerlink" title="內容"></a>內容</h2><p>我將我自己統整的資料放在網路中，供大家學習使用，但禁止抄襲。</p>
<p><a href="https://drive.google.com/file/d/139cfMuF2MAoBYvDrmMv-1mdyJVei6wLp/view?usp=sharing" target="_blank" rel="noopener">圖表</a><br><a href="https://drive.google.com/file/d/1qcidPJModDkUJSdJ2pA726xpM3b0INi0/view?usp=sharing" target="_blank" rel="noopener">附註說明</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>有些東西可以用爬蟲爬資料，真的是非常好用！</p>
<p>但是有很多資料是不同的網頁，且對 G20 並沒有完全支援。<br>原本有打算要寫一個程式互相 link，但後來想想可能會更花時間就停下來了。</p>
<p>總之，整理資料真的好累，文書作業感好重，又好想睡覺RRR。</p>
]]></content>
      <categories>
        <category>北科上課筆記</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>國際關係</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa11565 - Simple Equations (數論 Math theorm、暴力搜尋 Brute force)</title>
    <url>/2020/04/07/UVa/UVa11565/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>你必須找出 x,y,z 三個數字符合下面的公式，其中 x,y,z 數字不可以相同</p>
<ul>
<li>\(x+y+z = A\)</li>
<li>\(xyz=B\)</li>
<li>\(x^2 + y^2 + z^2 = C\)</li>
</ul>
<p>給你 A,B,C 求出 x,y,z，如果有多組答案，請輸出依序最小的</p>
<p><a href="https://onlinejudge.org/external/115/11565.pdf" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li>對於暴力搜尋進行優化<ul>
<li>反推 z</li>
<li>了解題目數值最大上限</li>
<li>得知題目可以負整數</li>
</ul>
</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>其實蠻水的XDDD，但是我花了蠻久才看的出來QQQ。</p>
<p>理論上其實我們可以透過題目的三個公式得出一些想法</p>
<ul>
<li>由於 \(x^2 + y^2 + z^2 = C\)，且 \(C &lt;= 10000\)，因此理論上 x,y,z 不會超過 100。</li>
<li>\(x+y+z = A\) x,y,z 有可能會是負整數，只要最後 A 是正就好</li>
<li>\(xyz=B\) 基本上 x,y,z 如果要有負整數的情況，那一定是 x,y,z 中有兩個負整數</li>
</ul>
<p>判斷時間複雜度 \(O(100 (100))\)，不大，最後的 z 再進行反推就能夠求出答案。</p>
<p>OK，那可以寫了對八！讓 x,y 從 -100 ~ 100，不斷嘗試。<br>注意：如果 x,y,z 其中有兩個數字一樣則不被視為答案。</p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://sayaurobuchi.github.io/cmusu/2017/06/10/UVa_11565.html" target="_blank" rel="noopener">[題解] UVa 11565 - Simple Equations by 巫術社的使魔群</a><br><a href="https://louisfghbvc.pixnet.net/blog/post/324071947-uva-11565-simple-equations" target="_blank" rel="noopener">Uva 11565 Simple Equations by louisfghbvc</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>難度不高，稍微動點腦就可以解出來。<br>用來增加大家信心的題目XD。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> A, B, C;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">-100</span>; x &lt; <span class="number">100</span>; x++)&#123; <span class="comment">//brute fouce</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> y = <span class="number">-100</span>; y &lt; <span class="number">100</span>; y++)&#123;</span><br><span class="line">            <span class="keyword">int</span> z = A - x -y; <span class="comment">//反推 z</span></span><br><span class="line">            <span class="keyword">if</span>(x - y == <span class="number">0</span> || y - z == <span class="number">0</span> || x - z == <span class="number">0</span>) <span class="keyword">continue</span>; <span class="comment">//判斷有沒有數值相同</span></span><br><span class="line">            <span class="keyword">if</span>(B != z * x * y) <span class="keyword">continue</span>; <span class="comment">//判斷是否符合題目公式</span></span><br><span class="line">            <span class="keyword">if</span>(C != (x*x + y*y + z*z)) <span class="keyword">continue</span>;  <span class="comment">//判斷是否符合題目公式</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">' '</span> &lt;&lt; y &lt;&lt; <span class="string">' '</span> &lt;&lt; z &lt;&lt; <span class="string">'\n'</span> ; <span class="comment">//通過挑戰，可以輸出答案</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"out.txt"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; A &gt;&gt; B &gt;&gt; C;</span><br><span class="line">        <span class="keyword">if</span>(solve() == <span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">"No solution.\n"</span>; <span class="comment">//如果是 0 就輸出此文字。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>數論 Math theorm</tag>
        <tag>暴力搜尋 Brute force</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa12249 - Overlapping Scenes (數論 Math theorm、暴力搜尋 Brute force)</title>
    <url>/2021/04/17/UVa/UVa11249/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>有個惡劣的電影製片商，習慣性剪接合併電影來讓電影戲份更長。</p>
<p>而我們就是要幫助他XD，他會給我們影片的片段，而我們可以將片段進行合併，條件是片段 A 的 prefix 與片段 B 的 suffix 相同就可以合併，請告訴我們，如何合併可以讓我們的電影最省經費(也就是合併後長度最短)。</p>
<p><a href="https://onlinejudge.org/external/122/12249.pdf" target="_blank" rel="noopener">參考連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li>暴力搜尋</li>
<li>時間複雜度的確定</li>
<li>了解符合題目的規定即可，在題目可以允許的範圍內再好的演算法都一樣</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>我們先來算算時間複雜度，\(6!=720\)，字串長度也不會超過 10 字元，因此 \(720(10) = 7200\)，怎麼算都綽綽有餘，可以供我們寫暴力的 code XDDD。</p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>嗚嗚，我在耍笨，一開始判斷<strong>片段 A 的 prefix 與片段 B 的 suffix 相同就可以合併</strong>，應該直接用 <code>string.substr</code> 就好，我還在那邊用迴圈慢慢判斷，花了一大堆時間，最後還寫錯QQQQ。</p>
<p>思考的不夠清楚，腦袋反應不夠好，希望自己可以透過訓練來自己的反應、思考都達到最高水準。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">15</span>;</span><br><span class="line"><span class="keyword">int</span> t, n, kase=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">string</span> scenes[MAXN]; <span class="comment">//儲存題目的電影片段</span></span><br><span class="line"><span class="keyword">int</span> used[MAXN]; <span class="comment">//判斷電影片段是否被使用過</span></span><br><span class="line"><span class="keyword">int</span> ans; <span class="comment">//合併最短長度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span> merge_scene, <span class="keyword">int</span> count_recursive)</span></span>&#123; <span class="comment">//排列組合</span></span><br><span class="line">    <span class="keyword">if</span>(count_recursive &gt;= n)&#123; <span class="comment">//如果所有的電影片段都被用過</span></span><br><span class="line">        <span class="comment">//cout &lt;&lt; merge_scene &lt;&lt; '\n';</span></span><br><span class="line">        <span class="keyword">int</span> len = merge_scene.length(); </span><br><span class="line">        ans = min(len, ans); <span class="comment">//選出最小的字串長度</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123; <span class="comment">//排列組合</span></span><br><span class="line">        <span class="keyword">if</span>(used[i]) <span class="keyword">continue</span>; <span class="comment">//之前有被用過的，就不用</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> k = min(scenes[i].length(), merge_scene.length()); </span><br><span class="line">        <span class="comment">//從兩個字串中選出最小長度，因為他們的合併片段**最大**只能到此長度</span></span><br><span class="line">        <span class="keyword">while</span>(k &gt; <span class="number">0</span>)&#123; <span class="comment">//不斷嘗試</span></span><br><span class="line">            <span class="built_in">string</span> substrA = merge_scene.substr(merge_scene.length()-k,k); <span class="comment">//擷取字串</span></span><br><span class="line">            <span class="built_in">string</span> substrB = scenes[i].substr(<span class="number">0</span>,k); <span class="comment">//擷取字串</span></span><br><span class="line">            <span class="keyword">if</span>(substrA == substrB)&#123; <span class="comment">//只要找到可以合併的，就退出。</span></span><br><span class="line">            <span class="comment">//由於 k 從最大開始，因此只要**第一個** substrA == substrB 就可以退出</span></span><br><span class="line">                <span class="comment">//cout &lt;&lt; substrA &lt;&lt; ' ' &lt;&lt; substrB &lt;&lt; '\n';</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line">        used[i] = <span class="number">1</span>; <span class="comment">//表示此電影片段已被用過</span></span><br><span class="line">        <span class="built_in">string</span> temp = merge_scene + scenes[i].substr(k, scenes[i].length()-k); <span class="comment">//indice 0</span></span><br><span class="line">        <span class="comment">//temp 是合併字串</span></span><br><span class="line">        dfs(temp, count_recursive+<span class="number">1</span>); <span class="comment">//向下排列組合</span></span><br><span class="line">        used[i] = <span class="number">0</span>; <span class="comment">//回到當前遞迴，所以當前電影片段不再被使用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"out.txt"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123; <span class="comment">//輸入資料</span></span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; scenes[i];</span><br><span class="line">            used[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="number">0x3f3f3f</span>; <span class="comment">//表示長度一開始 infinite</span></span><br><span class="line">        dfs(<span class="string">""</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Case "</span> &lt;&lt; ++kase &lt;&lt; <span class="string">": "</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>; <span class="comment">//輸出答案</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>數論 Math theorm</tag>
        <tag>暴力搜尋 Brute force</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa11742 - Social Constraints (數論 Math theorm、暴力搜尋 Brute force)</title>
    <url>/2021/04/17/UVa/UVa11742/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>青少年的社交是件很麻煩的事情，每個人都有喜歡與不喜歡的人，喜歡的人要坐在一起、不熟的人要分開坐、討厭的人要坐在對邊，給你 n 個人，m 個表示 x 與 y 要相隔 c 個位置。請輸出所有的可能性</p>
<p>其中 \(n \leq 8\)、\(0 \leq m \leq 20\)</p>
<p><a href="https://onlinejudge.org/external/117/11742.pdf" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li>暴力搜尋</li>
<li>時間複雜度的確定</li>
<li>了解符合題目的規定即可，在題目可以允許的範圍內再好的演算法都一樣</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>出了這題，讓我覺得我不會寫程式…，我一開始是想要把全部的排列組合進行優化在來解，但卻發現這題有點太難…。</p>
<p>我們可以得知 \(8! = 40320\)，用暴力解的複雜度才這麼大，肯定可以暴力解八XDD。<br>後來查詢網路上後得知，只需要暴力，最後在檢查是否有符合規定，就可以。</p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://blog.csdn.net/mobius_strip/article/details/77504772" target="_blank" rel="noopener">UVa 11742 - Social Constraints by 小白菜又菜</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>可惡RRRR，原本這題應該對我來說很簡單R，怎麼會解不出來呢QQ。</p>
<p>現在慢慢了解到時間複雜度的重要性，並不是想要把全部都做到最好，而是只要符合題目的要求就好，不需要自己拿劍逼自己做到最好。</p>
<p>但我們只是根據題目進行分析，如果以後有比這時間複雜度更嚴格的題目，理所當然的需要更好的程式碼。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, a, b, c;</span><br><span class="line"><span class="keyword">int</span> peoples[MAXN]; <span class="comment">//index 是人們，value 是座位</span></span><br><span class="line"><span class="keyword">int</span> position[MAXN]; <span class="comment">//index 是座位，value 是判斷此位置是否有被占用</span></span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>; <span class="comment">//計算答案</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">relation</span>&#123;</span> </span><br><span class="line">    <span class="keyword">int</span> x,y,v;</span><br><span class="line">    relation()&#123;&#125;</span><br><span class="line">    relation(<span class="keyword">int</span> _x, <span class="keyword">int</span> _y, <span class="keyword">int</span> _v)&#123;</span><br><span class="line">        x = _x;</span><br><span class="line">        y = _y;</span><br><span class="line">        v = _v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;relation &gt; listed; <span class="comment">//紀錄 m 個關係</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">islegal</span><span class="params">(relation concern)</span></span>&#123; <span class="comment">//判斷位置是否有合法</span></span><br><span class="line">    <span class="keyword">if</span>(concern.v &lt; <span class="number">0</span>)&#123; <span class="comment">//由於是至少要隔 c 個位置，所以是大於等於</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(peoples[concern.x] - peoples[concern.y]) &gt;= <span class="built_in">abs</span>(concern.v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(concern.v &gt;= <span class="number">0</span>)&#123; <span class="comment">//由於是要彼此坐在 c 個位置內，所以是小於等於</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(peoples[concern.x] - peoples[concern.y]) &lt;= concern.v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> people)</span></span>&#123; <span class="comment">//排列組合</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; "people " &lt;&lt; people &lt;&lt; '\n';</span></span><br><span class="line">    <span class="keyword">if</span>(people &gt;= n)&#123; <span class="comment">//這次的排列組合完成後</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; listed.size(); i++)&#123; <span class="comment">//判斷有沒有都符合 m 個條件</span></span><br><span class="line">            <span class="keyword">if</span>(!islegal(listed[i])) <span class="keyword">return</span>; <span class="comment">//不符合就 return</span></span><br><span class="line">        &#125;</span><br><span class="line">        cnt++; <span class="comment">//有符合就紀錄</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123; <span class="comment">//排列組合核心</span></span><br><span class="line">        <span class="keyword">if</span>(position[i]) <span class="keyword">continue</span>; <span class="comment">//如果這位置有被坐到就換下個</span></span><br><span class="line">        peoples[people] = i; <span class="comment">//紀錄人的位置</span></span><br><span class="line">        position[i] = <span class="number">1</span>; <span class="comment">//紀錄位置是否有被占用</span></span><br><span class="line">        dfs(people+<span class="number">1</span>); <span class="comment">//進行 dfs</span></span><br><span class="line">        position[i] = <span class="number">0</span>; <span class="comment">//此位置不再被坐</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &amp;&amp; (n+m) != <span class="number">0</span>)&#123; <span class="comment">//輸入資料</span></span><br><span class="line">        listed.clear(); <span class="comment">//清除 m 個條件</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123; <span class="comment">//輸入 m 個條件</span></span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">            <span class="function">relation <span class="title">temp</span><span class="params">(a,b,c)</span></span>;</span><br><span class="line">            listed.push_back(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123; <span class="comment">//清空資料</span></span><br><span class="line">            position[i] = <span class="number">0</span>;</span><br><span class="line">            peoples[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        dfs(<span class="number">0</span>); <span class="comment">//進行排列組合</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; cnt &lt;&lt; <span class="string">'\n'</span>; <span class="comment">//輸出答案</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>數論 Math theorm</tag>
        <tag>暴力搜尋 Brute force</tag>
      </tags>
  </entry>
  <entry>
    <title>北科通識大二國際關係 期中考出題重點</title>
    <url>/2021/04/21/NTUT_note/NTUTgec_inernational_relations/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學通識大二國際關係 期中考出題重點<br><font color="#dd0000">並非所有人都適用，部分對我而言稍加容易的內容並不會寫在此內。</font><br><strong>這是學習後心得的筆記，可能不太適用會未來的學生</strong></p>
<p>由於是我自己進行統整，不一定百分之百都全對，如果有錯誤的部分還請提出，提供我修正</p>
</blockquote>
<a id="more"></a>

<h2 id="QUESTION-十大人口國亞洲有幾國"><a href="#QUESTION-十大人口國亞洲有幾國" class="headerlink" title="QUESTION: 十大人口國亞洲有幾國"></a>QUESTION: 十大人口國亞洲有幾國</h2><p>中國、印度、印尼、孟加拉、俄羅斯、巴基斯坦、日本，共七國。</p>
<h2 id="QUESTION-APEC、OPEC、IMF-其設立目標"><a href="#QUESTION-APEC、OPEC、IMF-其設立目標" class="headerlink" title="QUESTION: APEC、OPEC、IMF 其設立目標"></a>QUESTION: APEC、OPEC、IMF 其設立目標</h2><ul>
<li>APEC<br>APEC的三大重點為「貿易暨投資自由化」（Trade and Investment Liberalization）、「商業便捷化」（Business Facilitation）及「經濟暨技術合作」（Economic and Technical Cooperation），其決策過程以「共識決」及「自願性」為基礎，經由各成員間相互尊重及開放性政策對話，達成尋求區域內共享經濟繁榮之目標。</li>
<li>OPEC<br>OPEC的既定使命是「協調統一成員國的石油政策與價格、確保石油市場的穩定，以確保為石油消費國提供有效、經濟而穩定的石油供給，為產油國提供適度的尊重和穩定的所得，為石油業投資人提供公平的報酬。」</li>
<li>IMF<br>致力於促進全球貨幣合作，確保金融穩定，促進國際貿易。職責是監察貨幣匯率和各國貿易情況、提供技術和資金協助，確保全球金融制度運作正常。</li>
</ul>
<p><a href="https://subsite.mofa.gov.tw/igo/cp.aspx?n=21595FA41A9EE70A" target="_blank" rel="noopener">APEC 簡介 by 參與國際組織</a><br><a href="https://zh.wikipedia.org/wiki/%E7%9F%B3%E6%B2%B9%E8%BE%93%E5%87%BA%E5%9B%BD%E7%BB%84%E7%BB%87" target="_blank" rel="noopener">石油輸出國組織 by wiki </a><br><a href="https://zh.wikipedia.org/wiki/%E5%9C%8B%E9%9A%9B%E8%B2%A8%E5%B9%A3%E5%9F%BA%E9%87%91%E7%B5%84%E7%B9%94" target="_blank" rel="noopener">國際貨幣基金組織 by wiki</a></p>
<h2 id="QUESTION-東北亞石油生命線"><a href="#QUESTION-東北亞石油生命線" class="headerlink" title="QUESTION: 東北亞石油生命線"></a>QUESTION: 東北亞石油生命線</h2><p>東北亞石油生命線，波斯灣 to 阿拉伯海 to 印度洋 to 麻六甲海峽 to 南海 to 台灣海峽 - 各國</p>
<h2 id="QUESTION-日本新保守主義"><a href="#QUESTION-日本新保守主義" class="headerlink" title="QUESTION: 日本新保守主義"></a>QUESTION: 日本新保守主義</h2><ul>
<li>不承認侵華 and 侵亞的歷史</li>
<li>否定東京大審判結果</li>
<li>參與 U.N. 之維和行動</li>
<li>爭取為 U.N. 常任理事國</li>
<li>USA 退出亞太地區後，接替此角色</li>
<li>刪除第九條憲法，保有戰爭權力</li>
</ul>
<h2 id="QUESTION-全球五大石油儲存國與出口國"><a href="#QUESTION-全球五大石油儲存國與出口國" class="headerlink" title="QUESTION: 全球五大石油儲存國與出口國"></a>QUESTION: 全球五大石油儲存國與出口國</h2><ul>
<li>石油儲存量前五大<br>委內瑞拉、沙烏地阿拉伯、加拿大、伊朗、伊拉克</li>
<li>前五大石油出口量<br>沙烏地阿拉伯、俄羅斯、伊拉克、美國、加拿大</li>
</ul>
<p><a href="https://zh.wikipedia.org/wiki/%E5%90%84%E5%9B%BD%E7%9F%B3%E6%B2%B9%E5%87%BA%E5%8F%A3%E9%87%8F%E5%88%97%E8%A1%A8" target="_blank" rel="noopener">各國石油出口量列表 by wiki</a><br><a href="https://zh.wikipedia.org/wiki/%E5%90%84%E5%9B%BD%E7%9F%B3%E6%B2%B9%E5%82%A8%E9%87%8F%E5%88%97%E8%A1%A8" target="_blank" rel="noopener">各國石油儲量列表 by wiki</a></p>
<h2 id="QUESTION-衡量一國國力大小之標準"><a href="#QUESTION-衡量一國國力大小之標準" class="headerlink" title="QUESTION: 衡量一國國力大小之標準"></a>QUESTION: 衡量一國國力大小之標準</h2><ul>
<li>科技總體水準 (科技研發經費 + 科技研究人力 + 科技產出)</li>
<li>立即可用之兵力 (不包括動員力量、生產創新貿易額 )有效嚇阻力量等。除戰略武器外，包括長程作能力。</li>
<li>行動可信力：國家在國際事務上之信用程度，對外承諾實踐力 (含條約 )</li>
<li>物質要素 \((C+E+M)*(S+W)\) 精神要素<ul>
<li>C：critical mass critical mass 領土、人口   </li>
<li>E：economic capacity  經濟能量、源礦產工農力對外貿易額 …</li>
<li>M：military capacity 軍事能力、 核武、常規軍力</li>
<li>S：strategy 戰略目標、策略</li>
<li>W：willing 意志力、對政府的信心</li>
</ul>
</li>
</ul>
<h2 id="QUESTION-國際關係理想主義之主張為何，我有何評論"><a href="#QUESTION-國際關係理想主義之主張為何，我有何評論" class="headerlink" title="QUESTION: 國際關係理想主義之主張為何，我有何評論"></a>QUESTION: 國際關係理想主義之主張為何，我有何評論</h2><p>由美國第 28 任總統 Wilson 主導提倡</p>
<ul>
<li>人性本善，可塑高。 </li>
<li>國際秩序應予制度化並成立國際組織加以管理 </li>
<li>應放棄權力平衡之追求 </li>
<li>以集體安全制度取代權力平衡以避免軍備競爭</li>
<li>注意利益和諧、民族自決、杜絕秘密外交</li>
</ul>
<p>不容易實現，這必須大家都採取溫和且鴿派的做法，但在現今語言、價值觀、文化、宗教都尚未融合的前提下，要實現此目標這有其一定的難度。</p>
<p>共產主義與資本主義的價值衝突，從二戰後延續至今，表示我們離國際關係理想主義還有一段路要走。</p>
<h2 id="QUESTION-東北亞地區各國領土糾紛？各國近日重要動態"><a href="#QUESTION-東北亞地區各國領土糾紛？各國近日重要動態" class="headerlink" title="QUESTION: 東北亞地區各國領土糾紛？各國近日重要動態"></a>QUESTION: 東北亞地區各國領土糾紛？各國近日重要動態</h2><ul>
<li>俄羅斯：北方四島之爭</li>
<li>韓國：竹島(獨島)之爭</li>
<li>中國：釣魚台問題、台灣問題</li>
<li>朝鮮半島：南北韓問題</li>
</ul>
<p>各國重要動態</p>
<ul>
<li><a href="https://news.ltn.com.tw/news/world/breakingnews/3506397" target="_blank" rel="noopener">俄羅斯封鎖黑海，進行軍演</a></li>
<li><a href="https://news.ltn.com.tw/news/world/breakingnews/3506462" target="_blank" rel="noopener">南韓對中國敵對感不斷增加</a></li>
<li><a href="https://news.ltn.com.tw/news/world/breakingnews/3506494" target="_blank" rel="noopener">3月中國與北韓關係緊密</a></li>
</ul>
<h2 id="QUESTION-ASEAN-發展過程？未來展望"><a href="#QUESTION-ASEAN-發展過程？未來展望" class="headerlink" title="QUESTION: ASEAN 發展過程？未來展望"></a>QUESTION: ASEAN 發展過程？未來展望</h2><p>發展過程</p>
<ul>
<li>1993 東協成立</li>
<li>2005 中國加入</li>
<li>2007 南韓加入</li>
<li>2010 與澳紐簽訂協議</li>
<li>2018 日本加入</li>
</ul>
<p>未來展望</p>
<ul>
<li>人力資源年輕化</li>
<li>薪資成長幫助經濟發展</li>
<li>天然資源豐富，經濟成長潛力高</li>
<li><strong>南海爭議解決與民主化開放皆為變數</strong></li>
</ul>
<h2 id="QUESITON-二戰後全球情勢變化如何"><a href="#QUESITON-二戰後全球情勢變化如何" class="headerlink" title="QUESITON: 二戰後全球情勢變化如何"></a>QUESITON: 二戰後全球情勢變化如何</h2><ul>
<li>國家數量大幅度增加</li>
<li>國際組織大量增加</li>
<li>全球化效應</li>
<li>區域性組織</li>
<li>美國獨強，多軸心型態形成，1990 蘇聯瓦解後，美國成為全球唯一強權</li>
</ul>
<h2 id="QUESTION-文明作用為何"><a href="#QUESTION-文明作用為何" class="headerlink" title="QUESTION: 文明作用為何"></a>QUESTION: 文明作用為何</h2><ul>
<li>不同文明其政治、經濟、文化、社會發展 不同</li>
<li>不同文明利益、敵對性結盟亦不同</li>
<li>不同文明間易產生衝突，文明同質性越高不易有衝突 . </li>
<li>文明與意識型態之同異，亦將產生國家凝聚或分裂</li>
<li>不同文明開始呈現以核心國家為首之型態，進而產生集團</li>
<li>每一文明皆自以為世界核心 ，自我中心、幻覺而表現出偏狹與傲慢</li>
</ul>
<h2 id="QUESTION-ASEAN-國家共同特性"><a href="#QUESTION-ASEAN-國家共同特性" class="headerlink" title="QUESTION: ASEAN 國家共同特性"></a>QUESTION: ASEAN 國家共同特性</h2><ul>
<li>1950-1960 的新興國家，泰國除外</li>
<li>首要目標是掃平分離主義，建立中央政府權威</li>
<li>追求政治穩定經濟發展，社會和諧生活改善，收入提高鞏固向心力</li>
<li>族群衝突避免檯面化、擴大化</li>
<li>建立內向式安全觀因應國際事務</li>
</ul>
<h2 id="QUESTION-CPTPP-RCEP-發展近況，對我國有何影響"><a href="#QUESTION-CPTPP-RCEP-發展近況，對我國有何影響" class="headerlink" title="QUESTION: CPTPP? RCEP? 發展近況，對我國有何影響"></a>QUESTION: CPTPP? RCEP? 發展近況，對我國有何影響</h2><ul>
<li>CPTPP 跨太平洋夥伴全面進步協定</li>
<li>RCEP 區域全面經濟夥伴協定</li>
</ul>
<p>由於台灣尚未加入此二協定，因此當大家都經濟結盟後，使台灣產業斷鍊、不公平競爭。降低台灣競爭力、經濟發展，且遇到大量關稅問題。</p>
<p><a href="https://www.nonwoven.org.tw/userupload/files/TPP%20RCEP%E6%8A%95%E5%BD%B1%E7%89%87.pdf" target="_blank" rel="noopener">TPP / RCEP的現況與未來發展 by 經濟部國貿局</a></p>
]]></content>
      <categories>
        <category>北科上課筆記</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>國際關係</tag>
        <tag>北科大通識</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa11659 - Informants (數論 Math theorm、暴力搜尋 Brute force)</title>
    <url>/2021/04/23/UVa/UVa11659/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>ACM 是一家間諜公司，裡面有很多的線民，但這些線民認為某部分線民講的不是實話、某些是實話。</p>
<p>我們的目的是要找出最多的線民數量，且這些線民不會不信任彼此。</p>
<p><a href="https://onlinejudge.org/external/116/11659.pdf" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li>透過二進制進行效率優化</li>
<li>理解 C++ 運算優先順序</li>
</ul>
<h2 id="分析與心得"><a href="#分析與心得" class="headerlink" title="分析與心得"></a>分析與心得</h2><p>一道好題。<br>只要是二進制的題目，我都認為他是好題，因為它打破了大部分的人的思考常規，可以讓我深刻的了解到當遇到大量關於是或否、對或錯時，都應該想到用二進制來解決這種問題。</p>
<p>主要想法是對每一個線民所信任的線民、不信任的做紀錄(or 運算)，之後再暴力搜尋即可找出。<br>線民可以用此方式表示 \(011100\)，表示有 3 位線民，分別是 C、D、E。(從右至左開始字典序)</p>
<p>這樣在記錄信任、不信任的線民時可以使用 or 運算。舉例：</p>
<ul>
<li>信任 A 線民 \(0001\)</li>
<li>信任 B 線民 \(0010\)</li>
<li>結果 (or 運算)  \(0011\)</li>
</ul>
<p>最壞時間複雜度大約是 \(2^20*20=20971520\)，基本上只要 judge 是有名的 judge 基本上能夠忍受的時間複雜度是 2000 萬 ~ 3000 萬，都可以去試試看。<del>能 AC 就是對的，效率優化在 AC 面前都沒有用</del></p>
<p>主要大家要稍微注意，C++ 的二進制運算比起邏輯運算(or、and…) 優先順序更為後面，因此要善用括號。<br>沒想到，我就因為一直以為二進制的括號比邏輯運算優先度更高，讓我在 debug 一直抓錯想法…。</p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://docs.microsoft.com/zh-tw/cpp/cpp/cpp-built-in-operators-precedence-and-associativity?view=msvc-160" target="_blank" rel="noopener">C + + 內建運算子、優先順序和關聯性 by Microsoft</a><br><a href="https://hackmd.io/@txya900619/Uva11659" target="_blank" rel="noopener">Uva11659 Informants by txya900619</a></p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">25</span>;</span><br><span class="line"><span class="keyword">int</span> n, a, x, y;</span><br><span class="line"><span class="keyword">int</span> say_wrong[MAXN], say_correct[MAXN];</span><br><span class="line"><span class="comment">// say_wrong 判斷 index 線民不信任那些人。二進制表示 0010，表示不喜歡 B 線民</span></span><br><span class="line"><span class="comment">// say_correct 判斷 index 線民信任那些人。二進制表示 0010，表示喜歡 B 線民</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bit_count</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="comment">//判斷其最大長度，也就是可以信任的線民數量</span></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>; <span class="comment">//此數字最大有幾個 1(幾個線民)</span></span><br><span class="line">    <span class="keyword">while</span>(x)&#123; <span class="comment">//不斷除2，然後判斷最尾數的位元是不是為 1，是就 cnt+1</span></span><br><span class="line">        <span class="keyword">if</span>(x &amp; <span class="number">1</span>) cnt += <span class="number">1</span>; </span><br><span class="line">        x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt; <span class="comment">//回傳線民</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"out.txt"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; a &amp;&amp; (n+a!=<span class="number">0</span>))&#123;</span><br><span class="line">        <span class="built_in">memset</span>(say_correct, <span class="number">0</span>, <span class="keyword">sizeof</span>(say_correct)); <span class="comment">//清空資料</span></span><br><span class="line">        <span class="built_in">memset</span>(say_wrong, <span class="number">0</span>, <span class="keyword">sizeof</span>(say_wrong)); <span class="comment">//清空資料</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a; i++)&#123; <span class="comment">//輸入信任與不信任</span></span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">            <span class="keyword">if</span>(y &gt; <span class="number">0</span>) say_correct[x] |= <span class="number">1</span> &lt;&lt; y<span class="number">-1</span>; <span class="comment">//進行記錄，並且合併過去資料</span></span><br><span class="line">            <span class="keyword">if</span>(y &lt; <span class="number">0</span>) say_wrong[x] |= <span class="number">1</span> &lt;&lt; -y<span class="number">-1</span>; <span class="comment">//進行記錄，並且合併過去資料</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> limit = <span class="number">1</span> &lt;&lt; n; <span class="comment">//最大的排列組合數量</span></span><br><span class="line">        <span class="keyword">int</span> max1 = <span class="number">0</span>; <span class="comment">//最多的線民數量，且這些線民不會不信任彼此</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; limit; i++)&#123; <span class="comment">//開始進行暴力搜尋 </span></span><br><span class="line">            <span class="keyword">int</span> necessary_informants = i; <span class="comment">//每一種線民們的組合方式，EX: 0110，有 B、C 線民</span></span><br><span class="line">            <span class="keyword">int</span> flag = <span class="number">1</span>; <span class="comment">//判斷這組合有沒有互相不信任的線民</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123; <span class="comment">//對 j 線民找出信任與不信任的關聯</span></span><br><span class="line">                <span class="keyword">int</span> necessary_informant = necessary_informants &amp; (<span class="number">1</span> &lt;&lt; j<span class="number">-1</span>);</span><br><span class="line">                <span class="comment">//判斷這個組合的線民，第 j 個有沒有在這組合裡面。</span></span><br><span class="line">                <span class="comment">//如果有，那在做 &amp; 運算會大於 1，反之則是零。</span></span><br><span class="line">                <span class="comment">//(1 &lt;&lt; j-1) 讓第 j 位 bit 為 1，表示第 j 位有線民</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> is_wrong = ( ((say_wrong[j] &amp; i) != <span class="number">0</span>) || ((say_correct[j] &amp; i) != say_correct[j]));</span><br><span class="line">                <span class="comment">//判斷 j 號村民不信任的線民是否有在此組合內</span></span><br><span class="line">                <span class="comment">//((say_wrong[j] &amp; i) != 0) </span></span><br><span class="line">                <span class="comment">//如果不信任的線民與我們這次的組合有關聯則表示此組合並不正確</span></span><br><span class="line">                <span class="comment">//((say_correct[j] &amp; i) != say_correct[j])</span></span><br><span class="line">                <span class="comment">//信任的線民必須完全重疊於我們這次的組合，反之表示有些線民沒有被信任到，</span></span><br><span class="line">                <span class="comment">//那之後暴力搜尋會搜尋到，這裡先判斷為錯誤</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(necessary_informant &amp;&amp; is_wrong)&#123;</span><br><span class="line">                <span class="comment">//如果 necessary_informant 為否表示此組合沒有 j 號村民，因此不用在意他不信任誰</span></span><br><span class="line">                <span class="comment">// is_wrong 如果為否表示此組合有符合 j 號線民的想法。</span></span><br><span class="line">                <span class="comment">//如果上面兩個其中一個為 yes，則跳出組合，表示此組合不會是正確的組合。</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">//debug 用</span></span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    cout &lt;&lt; "i is " &lt;&lt; i &lt;&lt; '\n';</span></span><br><span class="line"><span class="comment">                    cout &lt;&lt; "necessary_informant " &lt;&lt; necessary_informant &lt;&lt; '\n';</span></span><br><span class="line"><span class="comment">                    cout &lt;&lt; "j is " &lt;&lt; j &lt;&lt; '\n';</span></span><br><span class="line"><span class="comment">                    cout &lt;&lt; "debug " &lt;&lt; say_wrong[j] &lt;&lt; ' ' &lt;&lt; say_correct[j] &lt;&lt; '\n';</span></span><br><span class="line"><span class="comment">                    cout &lt;&lt; "info " &lt;&lt; ((say_wrong[j] &amp; i) != 0) &lt;&lt; ' ' &lt;&lt; ((say_correct[j] &amp; i) != say_correct[j]) &lt;&lt; '\n';</span></span><br><span class="line"><span class="comment">                    cout &lt;&lt; "is_wrong " &lt;&lt; is_wrong &lt;&lt; '\n';</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line"></span><br><span class="line">                    flag = <span class="number">0</span>; <span class="comment">//表示此組合絕對不會是答案</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag)&#123; <span class="comment">//如果 flag 有可能是答案，那就跟 max1 比較誰有最大的線民數量</span></span><br><span class="line">                <span class="comment">//cout &lt;&lt; "i is " &lt;&lt; i &lt;&lt; '\n';</span></span><br><span class="line">                max1 = max(bit_count(necessary_informants), max1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; max1 &lt;&lt; <span class="string">'\n'</span>; <span class="comment">//輸出答案</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="用紙筆去-Debug"><a href="#用紙筆去-Debug" class="headerlink" title="用紙筆去 Debug"></a>用紙筆去 Debug</h2><p>因為只是自己在思考過程中隨手做的筆記，覺得不是對讀者這麼有幫助，因此放在文章最下面。</p>
<p>有時候用想或用看的可能不太能夠懂這演算法，那就用寫的吧！這是大衛我自己學習的手稿，紀錄者我的學習過程。</p>
<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1Vz3egH5lJec1U1gBHfWgcLd1JF5zD02C&export=download" alt=""></p>
</blockquote>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>數論 Math theorm</tag>
        <tag>暴力搜尋 Brute force</tag>
      </tags>
  </entry>
  <entry>
    <title>在訓練 Kmeans 遇到問題，valueerror cannot take a larger sample than population when &#39;replace=false&#39;，是甚麼原因？</title>
    <url>/2021/04/25/Python/Python_ValueError%20Cannot%20take%20a%20larger%20sample%20than%20population%20when%20&#39;replace=False&#39;/</url>
    <content><![CDATA[<h2 id="內容說明"><a href="#內容說明" class="headerlink" title="內容說明"></a>內容說明</h2><blockquote>
<p>碰到 valueerror: cannot take a larger sample than population when ‘replace=false’</p>
</blockquote>
<a id="more"></a>

<h2 id="Valueerror-cannot-take-a-larger-sample-than-population-when-‘replace-false’-遇到這種錯誤時該怎麼辦呢？"><a href="#Valueerror-cannot-take-a-larger-sample-than-population-when-‘replace-false’-遇到這種錯誤時該怎麼辦呢？" class="headerlink" title="Valueerror: cannot take a larger sample than population when ‘replace=false’ 遇到這種錯誤時該怎麼辦呢？"></a>Valueerror: cannot take a larger sample than population when ‘replace=false’ 遇到這種錯誤時該怎麼辦呢？</h2><p>通常是一種情況，你丟入 kmenas 的 np.array 特徵數並沒有大於等於 k，而是小於 k 時會發生此錯誤。</p>
<h3 id="舉例："><a href="#舉例：" class="headerlink" title="舉例："></a>舉例：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">descriptors = sift[<span class="number">0</span>] <span class="comment">#圖片</span></span><br><span class="line"><span class="keyword">for</span> it <span class="keyword">in</span> sift[<span class="number">1</span>:]:</span><br><span class="line">  descriptors = np.vstack((descriptors, it))  </span><br><span class="line"></span><br><span class="line">print(len(descriptors))</span><br><span class="line"><span class="keyword">if</span>(len(descriptors) &lt; k): <span class="comment">#如果圖片特徵數小於你要求的 k 就會出現此問題。因此在下方用 raise 處理掉即可。</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">raise</span> Exception(<span class="string">"無法辨識，因為此圖片特徵數小於 k"</span>)</span><br><span class="line">voc, train_variance = kmeans(descriptors,k,<span class="number">1</span>) <span class="comment">##出錯的程式碼</span></span><br></pre></td></tr></table></figure>

<h2 id="問題解決："><a href="#問題解決：" class="headerlink" title="問題解決："></a>問題解決：</h2><p>也許這不是問題解決，但這可以在你每次遇到問題時，你可以馬上知道是哪裡出問題，而不是還要思考很久卻還想不出方法QQ。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">descriptors = sift[<span class="number">0</span>] <span class="comment">#圖片</span></span><br><span class="line"><span class="keyword">for</span> it <span class="keyword">in</span> sift[<span class="number">1</span>:]:</span><br><span class="line">  descriptors = np.vstack((descriptors, it))  </span><br><span class="line"></span><br><span class="line">print(len(descriptors))</span><br><span class="line"><span class="keyword">if</span>(len(descriptors) &lt; k): <span class="comment">#如果圖片特徵數小於你要求的 k 就會出現此問題。因此在下方用 raise 處理掉即可。</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">raise</span> Exception(<span class="string">"無法辨識，因為此圖片特徵數小於 k"</span>) <span class="comment">#並加入此行，在遇到錯誤前</span></span><br><span class="line">  <span class="comment">#我們先描述此錯誤並拋出 error，方便 debug</span></span><br><span class="line"></span><br><span class="line">voc, train_variance = kmeans(descriptors,k,<span class="number">1</span>) <span class="comment">#出錯的程式碼</span></span><br></pre></td></tr></table></figure>

<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>…，我想了超級久，我才知道有這個問題….。之前是因為並不是每次都會發生這個問題，只有我在選取特徵數過少的圖片對 svc sift model 進行預測時才會遇到，我就以為說可能是我那份程式碼的 <code>random.choise</code> 與 <code>np.random.choise</code> 混淆了，才會遇到此問題QQ。</p>
<p>現在這樣，我就知道沒有甚麼問題了！百分之 100% 搞懂了。</p>
<p>題外話：有時候太底層的錯誤，真的不好找，建議可以把底層錯誤寫得更明顯點，讓使用套件的人更好排錯QQ，不過寫套件又願意分享的人真的很偉大，辛苦了！</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>2021/04/25 電腦維修紀錄</title>
    <url>/2021/04/25/life_experence/computer_repair_20210425/</url>
    <content><![CDATA[<h2 id="說明"><a href="#說明" class="headerlink" title="說明"></a>說明</h2><blockquote>
<p>記錄我在 2021/04/24 電腦壞掉並拿去維修</p>
</blockquote>
<a id="more"></a>

<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>23 號的晚上，由於我睡不著覺，我就起來想要來寫程式，結果在打開電腦的過程後，不到 10 分鐘，電腦的老毛病 C 槽 sata 線又接觸不良，導致我的電腦死當住了QQ。</p>
<p>接下來我把電腦外殼拆開，去重新插拔 sata 線，完成並檢查沒有問題後，我就要將電腦機殼放回去，途中電腦機殼一直沒有辦法順利地放回去，我就對關鍵處進行強烈敲打，迫使機殼的關節可以成功鎖住。</p>
<p>結果在我強烈敲打的過程中，電腦突然關機，再也打不開了。</p>
<p>起初我啟動電腦後，風扇還會做動，綠燈不亮。<br>24 號早上醒來後，風扇不會動了，綠燈也不亮。</p>
<h2 id="解決"><a href="#解決" class="headerlink" title="解決"></a>解決</h2><p>早上的我感到憤怒，因為這是老毛病了！在原價屋組電腦時就知道這次幫忙我組的維修電腦人員技術並不好，有一堆問題。EX: C 槽 SATA 線爛掉，之前電源供應器壞掉，但因為還在保固期，因此可以順利替換，且機殼讓我不太滿意，用了太低廉的機殼。</p>
<p>後來我媽媽記得他之前修理腳踏車的兒子有維修電腦，所以我就打電話給媽媽推薦的維修工程師，跟他進行一陣交談後，就與我媽媽騎車把電腦交付給他拉XD。</p>
<p>交付完畢後，回到家中，我才發現我沒有把電腦硬碟給拔掉QQQQ。這樣會讓我的資料外洩RRRRR，抱持著很沮喪的心情…。希望維修工程師不要把我的資料都看光光RR，抱持著這種想法，原本想要回去拿硬碟，但後來又想想，拿硬碟要花多少時間，我還有一堆作業沒有做。這樣在浪費時間真的好嗎？</p>
<p>在猶豫的過程中，維修工程師就打電話給我，告知我已經知道問題在哪裡</p>
<ul>
<li>電源供應器</li>
<li>電源配線問題，需要換掉機殼</li>
</ul>
<p>其中維修工程師也對我不錯，一開始是推薦我用 450W 的電源供應器(2500)，我一直希望可以用 550W 的電源供應器(3500)，並且殺了 500 元的價格。</p>
<p>於是我就答應維修工程師，花 3000 請他幫我維修電源供應器、1100 維修電源配線並更換機殼</p>
<h2 id="媽媽溝通"><a href="#媽媽溝通" class="headerlink" title="媽媽溝通"></a>媽媽溝通</h2><p>跟媽媽說維修費用是 4100 後，媽媽非常生氣，一直朗朗著電腦就是要用一小時就要關機，不然壞掉是很正常，買東西是要靠保養的，不是靠維修的。不斷強調著這兩句話。</p>
<p>我感到很無奈，電腦用一小時就要關機，那全部的維修工程師都會忙翻了，都有一堆電腦要來維修。<br>買東西要靠保養，不是要靠維修的。所以我要怎麼保養電源供應器？他有機油要換嗎？</p>
<p>總之，習慣了我媽總是會對不擅長的東西說三道四，並且他也不尊重我的知識，我就對他生氣以及透過道理跟他說明後。她的嘴巴終於停下。</p>
<p>如果可以，我還真希望有天可以好好尊重一下我，有夠不尊重我的所有權利。</p>
<p>經過一翻論戰後，我媽還是給了我 4100。</p>
<h2 id="拿回電腦"><a href="#拿回電腦" class="headerlink" title="拿回電腦"></a>拿回電腦</h2><p>去維修工程師那拿電腦後，因為他們家住西園國宅，比較老舊髒亂了些，但其實我認為看起來並沒有很差，就是整個環境看起來很像 1970 年代的台北XDDD，但他們家的內裝是好看的。(標準說明台灣人只喜歡裝潢內部、外部放著爛XDDD)。</p>
<p>進去後，他詳細地對我說明我的電腦問題、並幫我清潔電腦，我很感謝他，他對我用心的講解電腦的硬體知識，把我認真的當作一個客戶在對待而不是隨意乎弄我，完整介紹了剛剛維修的過程，讓我清楚了解他做了甚麼事，並且幫我將電腦的壞毛病都通通排除，並不收錢。<br>解決了：C 槽 SATA 線爛掉、機殼太爛的問題。</p>
<p>跟他聊天一番後，維修工程師給了我紙箱與保麗龍方便我騎車帶他回家，而且我也稍微確認，他應該沒有把電腦的資料看過一遍XD，應該拉，只能說我自己笨笨QQ。</p>
<p>回家的過程中違停買飲料，警察看到我的違停沒有開單，對不起，我下次一定會好好地停車QQQQQ。</p>
<h2 id="檢查更換設備"><a href="#檢查更換設備" class="headerlink" title="檢查更換設備"></a>檢查更換設備</h2><p>回到家後，我檢查下更換的設備有哪些，應該裝備如下</p>
<ul>
<li><a href="https://www.autobuy.tw/3c/prod_82523" target="_blank" rel="noopener">CyberSLIM VECTOR 雷克特 550W 電源供應器(3年保) 990元 by autobuy</a></li>
<li><a href="https://24h.pchome.com.tw/prod/DRAE0W-A900AALWY?fq=/S/DRAE0W" target="_blank" rel="noopener">松聖 奇異果 電腦機殼 890元 by pchome </a></li>
</ul>
<p>我覺得價格有點偏貴，但是我能體會檢修的麻煩(畢竟類似於 debug 嘛)，加上檢測完問題後還必須要在組回去，如果讓我來做我可能會受不了QQ，所以還是可以接受啦。而且或許他還要跑去買貨品，也辛苦他了QQ。</p>
<p>只是希望可以再降 1000 拉QQ，這樣我就不用被罵。</p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>換完之後感覺心情超好XDDD，電腦那些老毛病終於都修好了QQQQ，雖然說價格有點小貴，但是可以當天就能領到維修好的電腦又能將老毛病都修好，真的好開心XDDDD。</p>
<p>下次我應該也會想要找此維修工程師維修，他對我的電腦很友善，或是我下次去原價屋維修看看，就可以比較這兩家的差距，並且打下紀錄。供未來的我或朋友觀看。</p>
<p>這次花了 4100，要破產拉拉拉拉啦。</p>
]]></content>
      <categories>
        <category>人生旅途</category>
      </categories>
      <tags>
        <tag>大學Life</tag>
        <tag>人生旅途</tag>
        <tag>電腦維修紀錄</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces 1513D - GCD and MST(設計解題)</title>
    <url>/2020/04/27/Codeforces/Codeforces%201513D/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>我們要生成出一個最小生成樹，設節點為 \(a_i\)，只要 \(a_i , a_i+1\) 就是 p 成本，但有一種情況下兩個點連接不是 p，，\(GCD(a_i, a_{i+1} , … , a_{j}) = min(a_i, a_{i+1} , … , a_{j}) \)，此時 \(a_i , a_j\) 也構成一條 edge。</p>
<p>請輸出最小的成本。</p>
<p>註：下面有時會將 \(GCD(a_i, a_{i+1} , … , a_{j}) = min(a_i, a_{i+1} , … , a_{j}) \) 省略講為 \(GCD = min\)</p>
<p><a href="https://codeforces.com/contest/1513/problem/D" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li>了解 Kruskal 演算法</li>
<li>依照 Kruskal 進行優化</li>
<li>了解如何擴展左右數列的程式碼</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>我們知道 Kruskal 是怎麼運作的，現在我們來看看這題，這題的 edge 比較簡單，只有 \(a_i , a_i+1\) 與 \(GCD = min\)的情況，剩下的就是降低成本。</p>
<p>首先我們可以找到題目裡的一個重大線索，\(GCD(a_i, a_{i+1} , … , a_{j}) = min(a_i, a_{i+1} , … , a_{j}) \)，這表示 \(a_i, a_{i+1} , … , a_{j}\) 每個結點都有跟 \(a_i\) 連接，因此權重都是相同，如果要生成最小生成樹，我們可以讓每個點都連接且 cose 都是 \(min(a_i)\)。</p>
<p>而其他不符合 \(GCD = min\) 的全部 cost 都是 p，並且他們都只有一條 edge  \(a_i , a_i+1\) 連接。</p>
<p>因此我們只要對每個 \(a_i\) 進行排序，從最小的 \(a_i\) 開始向數列左右邊進行擴增直到 \(a_i\) 大於 p 為止，如果可以符合 \(GCD(a_i, a_{i+1} , … , a_{j}) = min(a_i, a_{i+1} , … , a_{j}) \)，就繼續擴增。</p>
<p>我們可以用此方式來優化我們對邊的計算，由於我們有 n 個節點，因此 edge 會是 n-1，在前面我們推出無論是 \(gcd = min\) or 成本 p，我們都可以讓每個點都連接；因此我們只要記錄有幾個邊是 \(gcd = min\)，剩下的 edge cost 就是 p。</p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://blog.csdn.net/qq_43597036/article/details/115707240" target="_blank" rel="noopener">Codeforces Round #714 (Div. 2) D. GCD and MST by 渴望成为大佬菜鸡</a>，獲益良多，很感謝QQQ<br><a href="https://blog.csdn.net/weixin_44178736/article/details/116052427" target="_blank" rel="noopener">Codeforces1513 D. GCD and MST（思维，MST） by live4m</a><br><a href="https://blog.csdn.net/tlyzxc/article/details/115795341" target="_blank" rel="noopener">CodeForces 1504E : GCD and MST 思维 by 匿枫 </a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>太棒了，這題目…QQQQ。把我考得落花流水，我一開始都是往實踐 Kruskal 的方式去實作，一直想不通要怎麼去解決 \(gcd = min\) 的問題。</p>
<p>現在看到後才被打通自己的思路，其實不需要去想邊要怎麼連接，因為每一種連接方式(p , \(gcd = min\))的 edge cost 都相同，我們只需要去紀錄每種連接方式裡有幾個邊、cost 多少就好。</p>
<p>總之，寫 codeforces 的題目常常能夠讓自己的思考邏輯更加發散，透過發散來讓自己的思考能力變得更好，更加寬廣，然後進行收斂，得到最好答案。<br>希望在任何地方我都能運用此技巧。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">300000</span>;</span><br><span class="line"><span class="keyword">int</span> t, n, p, temp;</span><br><span class="line"><span class="built_in">deque</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; nodes; <span class="comment">//first 為 a[i] 值，second 為 index，是為了方便後面排序而這樣設計</span></span><br><span class="line"><span class="keyword">int</span> a[MAXN], visit[MAXN]; <span class="comment">//visit 判斷此節點有沒有與其他邊連接</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(visit, <span class="number">0</span>, <span class="keyword">sizeof</span>(visit)); <span class="comment">//清除，以避免資料被干擾</span></span><br><span class="line">        nodes.clear();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; p; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">            nodes.push_back(&#123;a[i], i&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(nodes.begin(), nodes.end());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, remain_edge = n<span class="number">-1</span>; <span class="comment">//ans 答案，remain_edge 剩餘的邊數量</span></span><br><span class="line">        <span class="keyword">while</span>(nodes.size())&#123; <span class="comment">//開始進行擴展</span></span><br><span class="line">            pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; node = nodes.front();</span><br><span class="line">            <span class="comment">//cout &lt;&lt; node.first &lt;&lt; ' ' &lt;&lt; node.second &lt;&lt; '\n';</span></span><br><span class="line">            nodes.pop_front();</span><br><span class="line">            <span class="keyword">if</span>(node.first &gt; p) <span class="keyword">break</span>; <span class="comment">//如果 a[i] 值大於 p，則沒必要改變邊的 cost</span></span><br><span class="line">            <span class="keyword">if</span>(visit[node.second]) <span class="keyword">continue</span>; <span class="comment">//此節點已經與其他邊連結</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> l = node.second, r = node.second;</span><br><span class="line">            <span class="keyword">while</span>(l &gt; <span class="number">1</span> &amp;&amp; !visit[l] &amp;&amp; a[l<span class="number">-1</span>] % node.first == <span class="number">0</span>) l--; <span class="comment">//向左擴展</span></span><br><span class="line">            <span class="keyword">while</span>(r &lt; n &amp;&amp; !visit[r] &amp;&amp; a[r+<span class="number">1</span>] % node.first == <span class="number">0</span>) r++; <span class="comment">//向右擴展</span></span><br><span class="line">            <span class="comment">//while(不超過左邊邊界 &amp;&amp; r 並沒有被其他 gcd = min 使用 &amp;&amp;</span></span><br><span class="line">            <span class="comment">// gcd(a[i] , a[r-1]) == 0 )，向左擴展邏輯也是如此</span></span><br><span class="line">            <span class="comment">//需要特別注意的是，!visit[r] 是驗證此節點是否有沒有與其他 min = gcd 連通，有的話就不行</span></span><br><span class="line">            <span class="comment">// a[r+1] % node.first == 0 則是判斷是否可以延伸，如果 a[r+1] 小於 node.first 則不可能符合此邏輯式，也表示下個點不可能可以連通，直接將 r 停留在此就好。</span></span><br><span class="line">            <span class="comment">// l 邏輯也是相同</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//we sum edge, not node.</span></span><br><span class="line">            <span class="comment">//so we consider visit[i] used or not,</span></span><br><span class="line">            <span class="comment">//if visit[i] is true, then node[i] small than node.first</span></span><br><span class="line">            <span class="comment">//then don't be extend (left or right) sequence.</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = l; i &lt;= r; i++) visit[i] = <span class="number">1</span>; <span class="comment">//將此區間表示已用過</span></span><br><span class="line">            ans += node.first * (r-l); <span class="comment">//紀錄區間內的所有邊成本</span></span><br><span class="line">            remain_edge -= (r-l); <span class="comment">//剩下的邊減去區間的所有邊數量</span></span><br><span class="line">            <span class="comment">//cout &lt;&lt; "l r " &lt;&lt; l &lt;&lt; ' ' &lt;&lt; r &lt;&lt; '\n';</span></span><br><span class="line">            <span class="comment">//cout &lt;&lt; "ans " &lt;&lt; ans &lt;&lt; '\n';</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; "remain_edge " &lt;&lt; remain_edge &lt;&lt; '\n';</span></span><br><span class="line">        ans += remain_edge * p; <span class="comment">//ans +  p * 剩餘邊長數量</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>; <span class="comment">//輸出答案</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>設計解題</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa12694 - Meeting Room Arrangement (數論 Math theorm)</title>
    <url>/2021/04/26/UVa/UVa12694/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>有一個討論室每天開放 10 小時(0~10)，我們會給你每個會議的開始與結束時間，想請你幫我們在此會議室中塞入多的會議。</p>
<p><a href="https://onlinejudge.org/external/126/12694.pdf" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li>思考到效率提升 </li>
<li>意識到可以用排序解決</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>通常比較直覺的寫法是直接對會議的開始與結束時間進行排序，先排序開始在排序結束，從最早的結束時間進行 greedy。</p>
<p>這裡提供一種寫法，我們<strong>只需要排序結束時間即可</strong>，並且我們用一個變數紀錄討論室最後結束時間(定義 end)。</p>
<p>接下來用 end 去跟每一個會議開始時間做比較，如果會議開始時間比討論室結束時間晚就將答案加一。</p>
<p>原因是由於我們對結束時間排序，因此結束時間越早的則會在越前面，並且我們紀錄了討論室結束時間。如果遇到這種測資也可以避免</p>
<ul>
<li>當前討論室結束時間為 3</li>
<li>兩筆資料<ul>
<li>2 點開始 4 點結束</li>
<li>3 點開始 4 點結束</li>
</ul>
</li>
<li>結論<br>我們可以得出討論室結束時間為 3，其中第一筆資料開始時間為 2 點並不符合，而另一筆剛好從 3 點開始因此符合！</li>
</ul>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://chucs.github.io/Meeting-Room-Arrangement/" target="_blank" rel="noopener">UVA 12694 by chucs</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>可惡，我沒辦法在 5 分鐘內寫完RRRR，好難過QQQ。一開始沒有想到這麼好的寫法，而是想到最直接的貪心解，但程式碼確實沒有比 chucs 大大還好看，因此就進行學習與修改。</p>
<p>希望我未來遇到這種問題我都可以寫出漂亮且乾淨的程式碼。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, s, f; <span class="comment">//題目資料</span></span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; meet; <span class="comment">//輸入題目會議用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; x, pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; y)</span></span>&#123; <span class="comment">//從結束時間開始由小到大排序</span></span><br><span class="line">    <span class="keyword">return</span> x.second &lt; y.second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> end = <span class="number">0</span>, ans = <span class="number">0</span>; <span class="comment">//end 會議開始時間, ans 答案時間</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it: meet)&#123; <span class="comment">//開始 greedy</span></span><br><span class="line">        <span class="keyword">if</span>(end &lt;= it.first)&#123; <span class="comment">//討論室可以加入此會議</span></span><br><span class="line">            <span class="comment">//cout &lt;&lt; it.first &lt;&lt; ' ' &lt;&lt; it.second &lt;&lt; '\n';</span></span><br><span class="line">            end = it.second; <span class="comment">//紀錄討論室結束時間</span></span><br><span class="line">            ans++; <span class="comment">//答案加一</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans; <span class="comment">//回傳答案</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123; </span><br><span class="line">        meet.clear(); <span class="comment">//需要清除，以免資料被干擾</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; s &gt;&gt; f &amp;&amp; (s+f!=<span class="number">0</span>)) meet.push_back(&#123;s,f&#125;); <span class="comment">//不斷讀入資料</span></span><br><span class="line">        sort(meet.begin(), meet.end(), compare); <span class="comment">//排序</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; solve() &lt;&lt; <span class="string">'\n'</span>; <span class="comment">//輸出答案</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>數論 Math theorm</tag>
      </tags>
  </entry>
  <entry>
    <title>R 檢測子字串與正規表達式是否存在此字串</title>
    <url>/2021/05/03/R/Rstr_detect/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>有時候需要在一個 dataframe 中尋找某些字串，但字串又不像數字一樣可以用大於、小於等條件來找出數字，只能透過子字串方式來找？此時那該怎麼辦呢。</p>
</blockquote>
<a id="more"></a>

<h2 id="str-detect-語法"><a href="#str-detect-語法" class="headerlink" title="str_detect 語法"></a><code>str_detect</code> 語法</h2><p>此語法需要安裝 <code>stringr</code> 套件包。</p>
<p>安裝語法 <code>install.packages(&quot;stringr&quot;)</code><br>使用套件 <code>library(stringr)</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">str_detect(string, pattern)</span><br></pre></td></tr></table></figure>

<p>其中 string 為被字串<br>而 pattern 則是我們要查詢的字串，支援正規表達式</p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://www.rdocumentation.org/packages/stringr/versions/1.4.0/topics/str_detect" target="_blank" rel="noopener">str_detect: Detect the presence or absence of a pattern in a string. by rdocumentation</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>老實講 R 真的蠻香的XDD，雖然之前一直嫌棄她不好用。但最近有點被調教成功了XD，多元的套件包就有多元的支持，讚啦！</p>
]]></content>
      <categories>
        <category>R語言</category>
      </categories>
      <tags>
        <tag>R語言</tag>
        <tag>學習筆記</tag>
        <tag>json</tag>
      </tags>
  </entry>
  <entry>
    <title>centOS6 安裝 nginx、安裝 SSL 憑證、進行反向代理、發布網頁</title>
    <url>/2021/05/03/linux/centOS-nginx/</url>
    <content><![CDATA[<h2 id="內容說明"><a href="#內容說明" class="headerlink" title="內容說明"></a>內容說明</h2><blockquote>
<p>記錄我在 linux 上學習安裝 nginx 以及反向代理 https to http時遇到的困難，自學真的好麻煩呀 QQ<br>教學示範作業系統 centOS6</p>
</blockquote>
<a id="more"></a>

<h2 id="centOS6-如何安裝-nginx"><a href="#centOS6-如何安裝-nginx" class="headerlink" title="centOS6 如何安裝 nginx"></a>centOS6 如何安裝 nginx</h2><ul>
<li>安裝依賴套件 <code>sudo yum install epel-release</code></li>
<li>安裝 nginx <code>sudo yum install nginx</code></li>
</ul>
<h2 id="nginx-安裝-ssl-憑證"><a href="#nginx-安裝-ssl-憑證" class="headerlink" title="nginx 安裝 ssl 憑證"></a>nginx 安裝 ssl 憑證</h2><p>我們先產生出 ssl 憑證，這邊我則是在 godaddy 的 ssl 憑證中下載 crt and key。<br>先對 <a href="https://www.sslshopper.com/ssl-checker.html#hostname=https://arch-backend.com/" target="_blank" rel="noopener">url 進行 ssl 檢查，來確定 ssl 是否正確</a>。</p>
<p>複製好 crt 之後，我們先透過<a href="https://www.sslshopper.com/certificate-decoder.html" target="_blank" rel="noopener">網頁進行 crt 檢查</a>，如果檢查成功就沒問題啦</p>
<blockquote>
<p>檢查 ok 示意圖<br><img src="https://drive.google.com/u/2/uc?id=1ShDw31VtIqAiafrKZA62wIvI_EgYuQm-&export=download" alt=""></p>
</blockquote>
<p>如果沒有成功比對可以試試看<a href="https://tw.piliapp.com/text-diff/#diff" target="_blank" rel="noopener">文本比較器</a>，來找出哪些有錯誤。</p>
<p>也可以在 linux 進行檢查</p>
<ul>
<li>檢查 csr <code>openssl req -text -noout -verify -in CSR.csr</code></li>
<li>檢查 key <code>openssl rsa -in privateKey.key -check</code></li>
<li>檢查 crt <code>openssl x509 -in certificate.crt -text -noout</code></li>
<li>然後再 <code>sudo vim /etc/nginx/conf.d/ssl.conf</code> 加入紅筆中的這些<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1vVN1QJfOCsReSGsQCWa1IsScTIR0JB0L&export=download" alt=""></p>
</blockquote>
</li>
</ul>
<h2 id="發布網頁"><a href="#發布網頁" class="headerlink" title="發布網頁"></a>發布網頁</h2><ul>
<li>首先我們有一個資料夾，存放要 show 給全部人的資料，例如 index.html….。</li>
<li>檢查網域位置<ul>
<li>我們可以進去 <code>sudo vim /etc/nginx/conf.d/ssl.conf</code>，可以看到 root 的位置在 <code>/usr/share/nginx/html</code><blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1-k1NJqIZnFBLcp0GxtFG5URePp7ctSXa&export=download" alt=""></p>
</blockquote>
</li>
<li>因此當我們打 <code>https://localhost</code> 時是進到  <code>/usr/share/nginx/html</code> 這個資料夾</li>
<li>再來我們如果打 <code>https://localhost/david</code> 時是進到  <code>/usr/share/nginx/html/david</code> 這個資料夾</li>
<li>如果沒有這個資料夾 <code>/usr/share/nginx/html/david</code> ，這時 nginx 會判斷下面你的 local 是否有此網域，如果有就轉過去，沒有就輸出 404。</li>
</ul>
</li>
<li>修改網域位置<ul>
<li>假如我們有個網域位置在 <code>/home/david/public_html</code>，我們想讓 <code>https://localhost</code> 指到此網域</li>
<li>那我們針對 <code>sudo vim /etc/nginx/conf.d/ssl.conf</code> 修改，修改如下<ul>
<li>將 root 進行註解<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1TuVwcVCiU-wNs3V7ftr8O-sQKyUKVEbY&export=download" alt=""></p>
</blockquote>
</li>
<li>增加 location，並且預設如果指到資料夾位置時，會自動開啟 index.html、index.php<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1qM8CT_68CMBiY0xyJNRDWXBW2xEComAy&export=download" alt=""></p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li>啟動 nginx 輸入 <code>sudo service nginx start</code></li>
<li>這樣你再輸入 <code>https://localhost</code>，則會打開 <code>/home/david/public_html/index.html</code>，前提是你資料夾下必須有此檔案拉XD。</li>
</ul>
<h3 id="權限問題-forbidden-13-Permission-denied-、靜態網頁-403-forbidden"><a href="#權限問題-forbidden-13-Permission-denied-、靜態網頁-403-forbidden" class="headerlink" title="權限問題  forbidden (13: Permission denied)、靜態網頁 403 forbidden"></a>權限問題  forbidden (13: Permission denied)、<strong>靜態網頁</strong> 403 forbidden</h3><ul>
<li>問題描述<ul>
<li>我們打開 localhost 網頁中的某一個資料夾(包含初始位置資料夾)，不管怎麼打開都會出現 403 forbidden 訊息，這該怎麼辦呢？</li>
<li>我們先檢查 error_log 輸入指令 <code>vim /var/log/nginx/error.log</code></li>
<li>往下滑，檢查最後一個錯誤，發現內容大致上寫著 forbidden (13: Permission denied)</li>
<li>該怎麼辦呢？</li>
</ul>
</li>
<li>解決方法<ul>
<li>通常遇到這種問題，表示設定為 root 的資料夾 or 子資料夾權限不足，因此我們修改資料夾的權限，提供 nginx 來使用。</li>
<li>提供方式如下，假設我們的 root <code>/home/david/public_html/</code>，權限不足，那我們就打指令 ```chmod 777 /home/david/public_html/``</li>
<li>之後 啟動 nginx 輸入 <code>sudo service nginx restart</code></li>
</ul>
</li>
<li>參考連結<ul>
<li><a href="https://www.arthurtoday.com/2014/12/how-to-quickly-fix-a-nginx-403-forbidden-error.html" target="_blank" rel="noopener">快速排除 Nginx 出現 403 Forbidden 錯誤 by 阿舍的隨手記記</a></li>
<li><a href="https://www.huaweicloud.com/articles/0bfc32c8f7cd4f21f71523e378c088a1.html" target="_blank" rel="noopener">Nginx报错403 forbidden (13: Permission denied)的解决办法 by 華為雲</a></li>
<li><a href="http://learn-web-hosting-domain-name.mygreatname.com/chmod-tutorial.html" target="_blank" rel="noopener">檔案或目錄的權限設定 (chmod files and directory) by learn web hosting</a></li>
</ul>
</li>
</ul>
<h3 id="靜態網頁-405-Not-Allow，且靜態網頁有使用-POST-request"><a href="#靜態網頁-405-Not-Allow，且靜態網頁有使用-POST-request" class="headerlink" title="靜態網頁 405 Not Allow，且靜態網頁有使用 POST request"></a><strong>靜態網頁</strong> 405 Not Allow，且靜態網頁有使用 POST request</h3><ul>
<li>問題描述<ul>
<li>在一些靜態網頁中有使用 POST request，我們的 nginx 會跳出 405 Not Allow，此時該怎麼辦比較好呢？</li>
</ul>
</li>
<li>解決方法<ul>
<li>使用 hack 技巧XD。</li>
<li>由於絕大多數的 web server(Apache、IIS、nginx) 都不允許靜態網頁使用 POST request，因此我們這邊的做法是<strong>當 nginx 要將頁面轉為 405 時，我們再轉回來當前網址，如此一來就可以使用 POST 了！</strong></li>
<li>解決方法如下，修改 <code>sudo vim /etc/nginx/conf.d/ssl.conf</code>，在最後加入這行指令<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1bIWwTL4LYOjzK8xUt-0CtfCBXl3jnAgp&export=download" alt=""></p>
</blockquote>
</li>
<li>之後 啟動 nginx 輸入 <code>sudo service nginx restart</code></li>
</ul>
</li>
<li>參考連結<ul>
<li><a href="https://stackoverflow.com/questions/24415376/post-request-not-allowed-405-not-allowed-nginx-even-with-headers-included" target="_blank" rel="noopener">POST request not allowed - 405 Not Allowed - nginx, even with headers included by stackoverflow</a></li>
<li><a href="https://www.jianshu.com/p/9ede80f2b876" target="_blank" rel="noopener">nginx 解决 405 not allowed错误 by 簡書</a></li>
</ul>
</li>
</ul>
<h2 id="開始進行反向代理"><a href="#開始進行反向代理" class="headerlink" title="開始進行反向代理"></a>開始進行反向代理</h2><ul>
<li>先對那文件進行編輯 <code>sudo vim /etc/nginx/conf.d/ssl.conf</code></li>
<li><code>location  + /url/</code>，就是我們 <a href="https://example.com/url/" target="_blank" rel="noopener">https://example.com/url/</a></li>
<li><code>proxy_pass api</code>，就是我們要請 nginx 將 http 代理成 https，讓外網透過 https 連入 http api<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1mG5yNnUajyQBcA698vU0zAFKPVLKj7k4&export=download" alt=""></p>
</blockquote>
</li>
<li>加入 <code>upstream</code> 綠色區塊，然後 server 那邊放入我們需要的 api<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1Kg2frI4ELLPr8J3qq4LDhu4LA19UQyM0&export=download" alt=""></p>
</blockquote>
</li>
</ul>
<h2 id="啟動-nginx"><a href="#啟動-nginx" class="headerlink" title="啟動 nginx"></a>啟動 nginx</h2><p>輸入語法，不過需要記住 nginx 需要分號，剛剛在打的時候要注意分號優 <code>sudo service nginx start</code></p>
<h3 id="啟動-nginx-錯誤：-nginx-emerg-bind-to-80-failed-98-Address-already-in-use"><a href="#啟動-nginx-錯誤：-nginx-emerg-bind-to-80-failed-98-Address-already-in-use" class="headerlink" title="啟動 nginx 錯誤： nginx: [emerg] bind() to [::]:80 failed (98: Address already in use)"></a>啟動 nginx 錯誤： nginx: [emerg] bind() to [::]:80 failed (98: Address already in use)</h3><blockquote>
<p>錯誤圖片如下<br><img src="https://drive.google.com/u/2/uc?id=14F1FmFspxAIITm83_DPnEhbZgFPC4yDy&export=download" alt=""></p>
</blockquote>
<p>通常這時後要怎麼辦呢？</p>
<p>有一種處理方式是將 443/tcp 全部清除後，再重新開啟一次 nginx 就可以順利完成</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo fuser -k 443&#x2F;tcp</span><br><span class="line">service nginx restart</span><br></pre></td></tr></table></figure>

<h3 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h3><p><a href="https://stackoverflow.com/questions/14972792/nginx-nginx-emerg-bind-to-80-failed-98-address-already-in-use" target="_blank" rel="noopener">nginx - nginx: [emerg] bind() to [::]:80 failed (98: Address already in use) by stackoverflow</a></p>
<h2 id="nginx-如何開啟-Cross-Origin-Resource-Sharing-CORS"><a href="#nginx-如何開啟-Cross-Origin-Resource-Sharing-CORS" class="headerlink" title="nginx 如何開啟 Cross-Origin Resource Sharing (CORS)"></a>nginx 如何開啟 Cross-Origin Resource Sharing (CORS)</h2><p>在一些服務上，有時候必須開啟 CORS 服務，通常 nginx 預設是關閉，那要怎麼打開比較好呢？</p>
<ul>
<li>打開 <code>sudo vim /etc/nginx/conf.d/ssl.conf</code></li>
<li>在 <code>location</code> 加入 <code>add_header Access-Control-Allow-Origin *;</code></li>
<li>示意圖如下：<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1ZisdV0KnBdTKk7j4hCXkDpdNatUmFVLM&export=download" alt=""></p>
</blockquote>
</li>
</ul>
<h3 id="CORS-跨來源資源共享-是甚麼？"><a href="#CORS-跨來源資源共享-是甚麼？" class="headerlink" title="CORS(跨來源資源共享) 是甚麼？"></a>CORS(跨來源資源共享) 是甚麼？</h3><ul>
<li>平常 API 中 CORS 預設為關閉，因此瀏覽器中你的 domain(網域) 資源只能在你的 domain 下使用，其他 domain 都不行。</li>
<li>當 CORS 開啟，則你的 domain 資源則可以在任意地方做使用。</li>
</ul>
<p>舉個例子：<br>現在你要在你的 blog 放入一張 FB 的圖片。</p>
<ul>
<li>如果 FB 的 CORS 是開啟，則我們可以順利獲得 FB(<a href="https://www.facebook.com/" target="_blank" rel="noopener">https://www.facebook.com/</a>) 的圖片崁入在 Blog 上。</li>
<li>如果 FB 的 CORS 是關閉，那我們就無法獲得 FB(<a href="https://www.facebook.com/" target="_blank" rel="noopener">https://www.facebook.com/</a>) 上的圖片。</li>
</ul>
<p>為甚麼會需要 CORS 通常會關閉呢？ 我們把放入 FB(<a href="https://www.facebook.com/" target="_blank" rel="noopener">https://www.facebook.com/</a>) 的圖片稍微改下<br>現在你要在你的 blog 放入一張 FB(<a href="https://www.facebook.com/" target="_blank" rel="noopener">https://www.facebook.com/</a>) 的私人訊息。</p>
<ul>
<li>如果 FB 的 CORS 是開啟，則我們可以順利獲得 FB(<a href="https://www.facebook.com/" target="_blank" rel="noopener">https://www.facebook.com/</a>) 的私人訊息崁入在 Blog 上。</li>
<li>如果 FB 的 CORS 是關閉，那我們就無法獲得 FB(<a href="https://www.facebook.com/" target="_blank" rel="noopener">https://www.facebook.com/</a>) 上的私人訊息。</li>
</ul>
<p>由於我們要保護我們的資料並不被惡意擷取，因此就產生了 CORS(跨來源資源共享)，願意共享才能共享。</p>
<h3 id="參考連結-1"><a href="#參考連結-1" class="headerlink" title="參考連結"></a>參考連結</h3><p><a href="https://serverfault.com/questions/162429/how-do-i-add-access-control-allow-origin-in-nginx" target="_blank" rel="noopener">How do I add Access-Control-Allow-Origin in NGINX? by stackexchange</a><br><a href="https://developer.mozilla.org/zh-TW/docs/Web/HTTP/CORS" target="_blank" rel="noopener">跨來源資源共用（CORS） by MDN </a></p>
<h2 id="參考連結-2"><a href="#參考連結-2" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://www.digitalocean.com/community/tutorials/how-to-install-nginx-on-centos-6-with-yum" target="_blank" rel="noopener">How To Install nginx on CentOS 6 with yum by digitalocean</a><br><a href="https://www.sslshopper.com/ssl-checker.html" target="_blank" rel="noopener">SSL Checker by sslshopper</a><br><a href="https://www.sslshopper.com/certificate-decoder.html" target="_blank" rel="noopener">crt check by sslshopper</a><br><a href="https://oranwind.org/-devops-ubuntu-shang-nginx-an-zhuang-yu-she-ding/" target="_blank" rel="noopener">[ DevOps ] Nginx 設定 Proxy Server 及 Load balance by oranwind</a><br><a href="https://www.opencli.com/linux/nginx-setup-ssl" target="_blank" rel="noopener">Nginx 設定 SSL 網頁加密 by opencli</a><br><a href="https://junhanli.blogspot.com/2017/04/ubuntu-nginx-https-godaddy-ssl.html" target="_blank" rel="noopener">Ubuntu Nginx 設定HTTPS建立網頁加密連線 (Godaddy SSL憑證) by junhanli</a><br><a href="https://serverfault.com/questions/1021242/4562605504error0909006cpem-routinesget-nameno-start-linecrypto-pem-pem-lib" target="_blank" rel="noopener">4562605504:error:0909006C:PEM routines:get_name:no start line:crypto/pem/pem_lib.c:745:Expecting: TRUSTED CERTIFICATE by stackexchange</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>好棒! 我終於把它寫出來了 centOS6 真的好難用QQQ，花了花多時間去把它學習，從不了解反向代理到理解反向代理，然後得知 ssl 是必須要去申請憑證，而非做一個假的 ssl 上線就可以讓 nginx 變成 https。</p>
<p>之後找到 nginx 管理 https，原本是使用 redirect 307 發現會出現錯誤為 https 中有 http，再來使用 proxy_pass 成功代理了。</p>
<p>一路上都是心血與痛苦，也謝謝網路上的大大願意寫 blog 分享資源，謝謝各位。</p>
<p>現在目前比較傾向將錯誤寫在安裝的 blog 日誌上而非在創新的日誌來寫，不知道這樣會不會幫助到大家與我。</p>
<p>目前也還在嘗試，還在努力，好希望可以成功。</p>
<h2 id="紀錄"><a href="#紀錄" class="headerlink" title="紀錄"></a>紀錄</h2><p>記錄我在採坑時，用到的那些 linux 指令，也許對未來的我或讀者有幫助</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> vim &#x2F;etc&#x2F;httpd&#x2F;conf&#x2F;httpd.conf</span><br><span class="line"> service httpd restart</span><br><span class="line"></span><br><span class="line">MEU8UD3PE67H57U6BLOEPLOZK8DGLLX9</span><br><span class="line"></span><br><span class="line">openssl req -new -newkey rsa:2048 -nodes -keyout arch-backend.com&#x2F;.key -out arch-backend.com&#x2F;.csr</span><br><span class="line"></span><br><span class="line">sudo service nginx restart</span><br><span class="line"></span><br><span class="line"> sudo vim &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;ssl.conf</span><br><span class="line"> sudo fuser -k 443&#x2F;tcp</span><br><span class="line"></span><br><span class="line"> ssl_certificate &#x2F;etc&#x2F;ssl&#x2F;certs&#x2F;nginx-ssl.crt;</span><br><span class="line"> ssl_certificate &#x2F;etc&#x2F;ssl&#x2F;certs&#x2F;web.crt;</span><br><span class="line">    ssl_certificate_key &#x2F;etc&#x2F;ssl&#x2F;private&#x2F;nginx-ssl.key;</span><br><span class="line">ssl_certificate_key &#x2F;etc&#x2F;ssl&#x2F;private&#x2F;web.key;</span><br><span class="line"></span><br><span class="line">openssl x509 -in &#x2F;etc&#x2F;ssl&#x2F;certs&#x2F;nginx-ssl.crt -text -noout</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">openssl x509 -in &#x2F;etc&#x2F;ssl&#x2F;certs&#x2F;web.crt -text -noout</span><br><span class="line">openssl x509 -in &#x2F;etc&#x2F;ssl&#x2F;certs&#x2F;nginx-ssl.crt -text -noout</span><br><span class="line"></span><br><span class="line">openssl rsa -in &#x2F;etc&#x2F;ssl&#x2F;private&#x2F;web.key -check</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>linux</tag>
        <tag>centOS</tag>
        <tag>nignx</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 nignx 時遇到 ERROR! Mixed Content The page at &#39;https://example.com/&#39; was loaded over HTTPS, but requested an insecure script &#39;http://example.com2/&#39;. This request has been blocked; the content must be served over HTTPS.</title>
    <url>/2021/05/03/linux/centOS-Error-Mixed-Content/</url>
    <content><![CDATA[<h2 id="內容說明"><a href="#內容說明" class="headerlink" title="內容說明"></a>內容說明</h2><blockquote>
<p>記錄我在 linux 上學習遇到 the content must be served over HTTPS. 困難，自學真的好麻煩呀 QQ<br>教學示範作業系統 centOS6</p>
</blockquote>
<a id="more"></a>

<h2 id="QUESTION-使用-nignx-時遇到-ERROR-Mixed-Content-The-page-at-‘https-example-com-39-was-loaded-over-HTTPS-but-requested-an-insecure-script-‘http-example-com2-39-This-request-has-been-blocked-the-content-must-be-served-over-HTTPS"><a href="#QUESTION-使用-nignx-時遇到-ERROR-Mixed-Content-The-page-at-‘https-example-com-39-was-loaded-over-HTTPS-but-requested-an-insecure-script-‘http-example-com2-39-This-request-has-been-blocked-the-content-must-be-served-over-HTTPS" class="headerlink" title="QUESTION: 使用 nignx 時遇到 ERROR! Mixed Content The page at ‘https://example.com/&#39; was loaded over HTTPS, but requested an insecure script ‘http://example.com2/&#39;. This request has been blocked; the content must be served over HTTPS."></a>QUESTION: 使用 nignx 時遇到 ERROR! Mixed Content The page at ‘<a href="https://example.com/&#39;" target="_blank" rel="noopener">https://example.com/&#39;</a> was loaded over HTTPS, but requested an insecure script ‘<a href="http://example.com2/&#39;" target="_blank" rel="noopener">http://example.com2/&#39;</a>. This request has been blocked; the content must be served over HTTPS.</h2><blockquote>
<p>在使用 nignx 反向代理時，遇到一個問題是在 call api 時發現原本使用 nginx 引導至 server 內的 http api，會發生這種問題</p>
<p>這邊的作業系統為 centOS6</p>
</blockquote>
<!-- more -->

<h2 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h2><ul>
<li>對 ssl 檔案進行編輯 <code>sudo vim /etc/nginx/conf.d/ssl.conf</code></li>
<li>在 location 中將原本是使用 <code>redirect http://example.com</code> 改為 <code>proxy_pass http://example.com</code><ul>
<li>示意圖<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1N8R8nyWy80mzyHcGE7vpmsmRLOxCKmsD&export=download" alt=""></p>
</blockquote>
</li>
</ul>
</li>
<li>這樣就可以了!</li>
</ul>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://oranwind.org/-devops-ubuntu-shang-nginx-an-zhuang-yu-she-ding/" target="_blank" rel="noopener">[ DevOps ] Nginx 設定 Proxy Server 及 Load balance</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>這個對我來說終於是個簡單的問題了QQ，我在弄 nginx 中一直遇到一些奇怪的問題(CentOS6) 環境QQQ，這次終於有輕鬆完成了。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>linux</tag>
        <tag>nignx</tag>
      </tags>
  </entry>
  <entry>
    <title>centOS6 yum 停止維護後，讓 yum 繼續可以使用</title>
    <url>/2021/05/03/linux/centOS6-yum/</url>
    <content><![CDATA[<h2 id="內容說明"><a href="#內容說明" class="headerlink" title="內容說明"></a>內容說明</h2><blockquote>
<p>記錄我在 linux 上學習安裝 nginx 以及反向代理 https to http時遇到的困難，自學真的好麻煩呀 QQ</p>
<p>教學示範作業系統 centOS6</p>
</blockquote>
<a id="more"></a>

<h2 id="如何讓-yum-繼續可以使用"><a href="#如何讓-yum-繼續可以使用" class="headerlink" title="如何讓 yum 繼續可以使用"></a>如何讓 yum 繼續可以使用</h2><p>只要輸入此指令即可拿來使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -o update-centos6yum.sh https:&#x2F;&#x2F;gitee.com&#x2F;usmile&#x2F;jenkinslibrary&#x2F;raw&#x2F;master&#x2F;update-centos6yum.sh</span><br><span class="line">chmod +x update-centos6yum.sh</span><br><span class="line">.&#x2F;update-centos6yum.sh</span><br></pre></td></tr></table></figure>

<h2 id="資料來源"><a href="#資料來源" class="headerlink" title="資料來源"></a>資料來源</h2><p><a href="https://www.cnblogs.com/skymyyang/p/14108100.html" target="_blank" rel="noopener">centos6 yum源失效 by skymyyang</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>在 google 中花了很多時間找這個的解決方式，只有這網頁能給予我最快速的解決方式且還這麼簡單！真的太感謝他了QQQ。</p>
<p>老實講，有時候網路上太多無用的資訊了，真希望 google search 可以有類似於 stackoverflow 可以讓網友對網頁進行按讚或倒讚，越少的讚放越後面，越多的讚則放前面。</p>
<p>然後把農場文章都刪掉，農場文章會讓寫 blog 的人越來越沒有動力…。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>linux</tag>
        <tag>centOS</tag>
        <tag>nignx</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa10346 - Peter’s Smokes(水題)</title>
    <url>/2021/05/09/UVa/UVa10346/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>Peter 有 n 個大麻，每抽 k 個大麻後剩下的殘渣可以再捲成一個新大麻，Peter 總共可以抽幾個大麻</p>
<p><a href="https://onlinejudge.org/external/103/10346.pdf" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li>英文理解</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>理論我們都知道，我們只需要紀錄 n 個香菸，然後剩下的殘渣也進行紀錄，再把超過 k 的殘渣捲成大麻，直到不能夠再組成大麻為止。</p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>不是欸，大麻不可以寫在題目上八wwww。</p>
<p>練習手感的一題</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, k, ans, component;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k)&#123; <span class="comment">//輸入資訊</span></span><br><span class="line">        ans = <span class="number">0</span>; <span class="comment">//總共有幾個香菸 peter 可以抽</span></span><br><span class="line">        component = <span class="number">0</span>; <span class="comment">//還有幾個殘渣可以抽</span></span><br><span class="line">        <span class="keyword">while</span>(n)&#123; <span class="comment">//現在有 n 個大麻</span></span><br><span class="line">            ans += n; <span class="comment">//peter 又有更多大麻可以抽了！</span></span><br><span class="line">            component += n; <span class="comment">//這些大麻抽完了，多了 n 個殘渣</span></span><br><span class="line">            n = component / k; <span class="comment">//這些殘渣可以組成新的 n 個香菸</span></span><br><span class="line">            component %= k; <span class="comment">//還剩下幾個殘渣</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>; <span class="comment">//輸出總共有幾個香菸</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>水題</tag>
        <tag>UVa</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa10908 - Largest Square(DFS)</title>
    <url>/2021/05/08/UVa/UVa10908/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>有一個長方形地圖，會給你一個正方形中心點，此中心點為對角線交叉點，請以此中心點找出最大的正方形，並輸出邊長。</p>
<p><a href="https://onlinejudge.org/external/109/10908.pdf" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li>如何找到最大邊長</li>
<li>搜尋是否為正方形</li>
<li>英文理解</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>概念其實很簡單，主要是對中心點向上下延伸伸展出最大的正方形，那要怎麼樣伸展才是最好寫得呢？</p>
<p>可以用一個方式來寫會很好寫，從正方形中心點的左上角開始繞一圈進行搜尋，如果這一圈都是相同字元，那就可以在對下一圈進行搜尋。</p>
<p>直到不能再對下一圈進行搜尋時就輸出最大正方形長度</p>
<blockquote>
<p>舉例來說：<br>紅色點為中心點，而藍色為第一圈、螢光黃色為起頭圍著中心點繞一圈(藍色線段)，只要能夠成功繞一圈那就可以將正方形擴展長度，再從更外面一圈(綠色線條)對中心點圍繞。<br><img src="https://drive.google.com/u/2/uc?id=1gwRyQKUG7tbgA7eH_T7DLVYsoFLDwqTd&export=download" alt=""></p>
</blockquote>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>這是一個很酷的題目，其實不難但是程式要寫的簡單、概念好懂卻是一個大工夫，我對這題研究大概 40mins，想出了這種最簡單又好寫的程式邏輯。</p>
<p>透過此程式邏輯來寫出此題就快了很多，希望我可以將這些邏輯都應用在未來。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">120</span>;</span><br><span class="line"><span class="keyword">int</span> t, q, n, m;</span><br><span class="line"><span class="keyword">int</span> direct[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;+<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;&#125;; <span class="comment">//依序是左、下、右、上，圍繞一圈的方向</span></span><br><span class="line"><span class="built_in">string</span> graph[MAXN]; <span class="comment">//儲存地圖</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isValid</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123; <span class="comment">//判斷這個位置是否非法</span></span><br><span class="line">    <span class="keyword">if</span>(x &gt;= <span class="number">0</span> &amp;&amp; x &lt; m &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; n) <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">//判斷此位置是否超出邊界</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_square</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;<span class="comment">//position distance</span></span><br><span class="line">    <span class="keyword">int</span> d = <span class="number">1</span>; <span class="comment">//繞圓心一圈的邊長</span></span><br><span class="line">    <span class="keyword">int</span> root_char = graph[x][y]; <span class="comment">//圓心的字元</span></span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">1</span>; <span class="comment">//判斷這圈是否可以成功繞圓心一圈，1 表示可以、0 表示不行</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(flag)&#123;</span><br><span class="line">        d += <span class="number">2</span>; <span class="comment">//邊長增加兩個丹薇</span></span><br><span class="line">        <span class="keyword">int</span> nowX = x-(d/<span class="number">2</span>), nowY = y-(d/<span class="number">2</span>); <span class="comment">//找出此圈的左上角點</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123; <span class="comment">//四個方向，共繞行一圈</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; d<span class="number">-1</span>; j++)&#123; <span class="comment">//每一個方向走 d 步</span></span><br><span class="line">                nowX += direct[i][<span class="number">0</span>]; <span class="comment">//計算當前位置</span></span><br><span class="line">                nowY += direct[i][<span class="number">1</span>];</span><br><span class="line">                <span class="comment">//cout &lt;&lt; "nowX nowY " &lt;&lt; nowX &lt;&lt; ' ' &lt;&lt; nowY &lt;&lt; ' ' &lt;&lt; isValid(nowX,nowY) &lt;&lt; '\n';</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(!isValid(nowX,nowY) || graph[nowX][nowY] != root_char)&#123; <span class="comment">//如果是非法位置 || 現在的 now 字元與 root_char 不同</span></span><br><span class="line">                    flag = <span class="number">0</span>; <span class="comment">//表示無法通行</span></span><br><span class="line">                    <span class="keyword">break</span>; </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//cout &lt;&lt; "graph char " &lt;&lt; graph[nowX][nowY] &lt;&lt; '\n';</span></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag == <span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">//如果無法通行則離開</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d<span class="number">-2</span>; <span class="comment">//由於是 d 圈沒辦法繞完，因此 d-2 的距離那圈一定可以繞完。</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"out.txt"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n &gt;&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) <span class="built_in">cin</span> &gt;&gt; graph[i]; <span class="comment">//輸入地圖</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; m &lt;&lt; <span class="string">' '</span> &lt;&lt; n &lt;&lt; <span class="string">' '</span> &lt;&lt; q &lt;&lt; <span class="string">'\n'</span>; <span class="comment">//輸出地圖資訊</span></span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line">        <span class="keyword">while</span>(q--)&#123; <span class="comment">//讀入資訊</span></span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y; <span class="comment">//給予圓心點 x,y</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; find_square(x, y) &lt;&lt; <span class="string">'\n'</span>; <span class="comment">//尋找圓心最大邊長</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>數論 Math theorm</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa1225 - Digit Counting(數論 Math theorm)</title>
    <url>/2021/05/08/UVa/UVa1225/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>給你一個數字，產生一組字串資料有 0 to n，請紀錄此字串 0 到 9 個出現幾次。</p>
<p>舉例： n = 5，那字串為 “12345”</p>
<p><a href="https://onlinejudge.org/external/12/1225.pdf" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li>預處理概念</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>我們稍微可以進行分析，我們可以發現 \(n = 100\) 是最長的字串，但 \(n = 20\) 的字串則是 \(n = 100\) 的子字串，只要是 \(n &lt; 100\) 的都是 \(n = 100\) 的子字串</p>
<p>然後又發現一件事情，這題的查詢基本上都是 \(n = 100\) 的子字串，因此我們可以預處理，從 n = 1 開始不斷紀錄 0 到 9 個出現幾次，然後用一個陣列紀錄，之後將字串再增加長度(\(n+1\)) 就可以紀錄每一種 n 的 0 到 9 個出現幾次，在題目要查詢 n 時就可以直接輸出。</p>
<p>透過預處理的方式，來省略每次的查詢時間。</p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>這題主要是要給你預處理的概念，你要能夠在寫題目時想到裡面的資料大都具由重疊性抑或是向上、向下延伸，就可以想到預處理。</p>
<p>希望我可以將這些概念應用在生活上，讓我可以變得更優秀。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">10000</span>; <span class="comment">//最大的字串長度</span></span><br><span class="line"><span class="keyword">int</span> record[MAXN][<span class="number">10</span>];  <span class="comment">//用來記錄 record[字串為 q 時][i] = i 數字的出現次數 </span></span><br><span class="line"><span class="keyword">int</span> n, t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pretreatment</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10000</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> num = i; <span class="comment">//表示增加了一個字串為 num</span></span><br><span class="line">        <span class="keyword">while</span>(num)&#123; <span class="comment">//將字串進行拆解，把每個數字放到 record 中</span></span><br><span class="line">            record[i][num % <span class="number">10</span>]++; <span class="comment">//字串為 i 時，[ num 的尾數] 出現次數加一</span></span><br><span class="line">            num /= <span class="number">10</span>; <span class="comment">//將 num 的尾數去掉</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把 n = i-1 的紀錄傳給 n = i，</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) record[i][j] += record[i<span class="number">-1</span>][j]; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="comment">//freopen("out.txt", "w", stdout);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    pretreatment(); <span class="comment">//進行預處理</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123; <span class="comment">//輸入資料</span></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; t; <span class="comment">//輸入查詢的字串 n，輸出答案</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//嚴格比對</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; record[t][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) <span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; record[t][i];</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>數論 Math theorm</tag>
      </tags>
  </entry>
  <entry>
    <title>R plumber 套件在解析 json 時的問題(plumber invalid json)</title>
    <url>/2021/05/11/R/R-error-invaild-json/</url>
    <content><![CDATA[<h2 id="問題描述"><a href="#問題描述" class="headerlink" title="問題描述"></a>問題描述</h2><blockquote>
<p>R plumber 製作 api 後，如果要 post json 會出現 invalid json 的時候該怎麼辦呢？</p>
</blockquote>
<a id="more"></a>

<h2 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h2><h3 id="先確定是否有拆解正確"><a href="#先確定是否有拆解正確" class="headerlink" title="先確定是否有拆解正確"></a>先確定是否有拆解正確</h3><p>由於傳送 json 的時候是 raw，因此我們要將解析出 postbody，裡面那包才是真正的 json，其他都是附帶資訊</p>
<p>示意圖如下</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="keyword">library</span>(plumber)</span><br><span class="line"><span class="keyword">library</span>(jsonlite)</span><br><span class="line"><span class="comment">#* parse JSON</span></span><br><span class="line"><span class="comment">#* @param req  the request object</span></span><br><span class="line"><span class="comment">#* @get /json_echo</span></span><br><span class="line"><span class="comment">#* @post /json_echo</span></span><br><span class="line">json_echo &lt;- <span class="keyword">function</span>(req)&#123; <span class="comment">#req post 的所有資訊</span></span><br><span class="line">  json_content &lt;- req$postBody <span class="comment">#req$postBody 為 post 中 user 傳送的資料</span></span><br><span class="line">  <span class="keyword">return</span>(json_content) <span class="comment">#回傳 user post 的 json</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="如果確認是正確，那我們必須要檢查-plumber-套件版本是否大於-0-4-6"><a href="#如果確認是正確，那我們必須要檢查-plumber-套件版本是否大於-0-4-6" class="headerlink" title="如果確認是正確，那我們必須要檢查 plumber 套件版本是否大於 0.4.6"></a>如果確認是正確，那我們必須要檢查 plumber 套件版本是否大於 0.4.6</h3><p>在我搜尋資料的過程中發現 plumber 小於等於 0.4.6 的版本再傳送 json 時都有此問題，而在後面的版本都有解決此問題，因此我們就要將 plumber 包更新。</p>
<p>如何更新呢？</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">install.packages(<span class="string">"plumber"</span>)</span><br></pre></td></tr></table></figure>

<h2 id="參考來源"><a href="#參考來源" class="headerlink" title="參考來源"></a>參考來源</h2><p><a href="https://github.com/rstudio/plumber/issues/270" target="_blank" rel="noopener">Unnecessary warning when POST (JSON) body has multiple lines by jnolis</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>希望我能夠完全熟用 R，現在還有很多都不太懂，還需要花時間去慢慢解決呢！</p>
]]></content>
      <categories>
        <category>R語言</category>
      </categories>
      <tags>
        <tag>R語言</tag>
        <tag>學習筆記</tag>
        <tag>json</tag>
      </tags>
  </entry>
  <entry>
    <title>R 效率提升經驗紀錄，盡量使用向量、不對龐大 dataframe 進行修改</title>
    <url>/2021/05/11/R/R-dataframe_edit_and_for_faster/</url>
    <content><![CDATA[<h2 id="問題描述"><a href="#問題描述" class="headerlink" title="問題描述"></a>問題描述</h2><blockquote>
<p>如果發現自己寫的 R 跑得太慢時，應該要怎麼樣解決會比較好呢？</p>
<p>標題已經有大概講述怎麼解決了XD</p>
</blockquote>
<a id="more"></a>

<h2 id="舉例："><a href="#舉例：" class="headerlink" title="舉例：　"></a>舉例：　</h2><p>透過我自己製作的 PPT 來舉例，如果 R 如果大量使用 for，不使用向量，都針對大量的 dataframe 進行修改會怎麼樣。</p>
<p>以及解決後的效率提升有多快。</p>
<p><a href="https://drive.google.com/file/d/13roU8hs7_CBsxRwH5BdyxyrrIofsDoYG/view?usp=sharing" target="_blank" rel="noopener">20210511_R_dataframe回測資料過大問題</a></p>
]]></content>
      <categories>
        <category>R語言</category>
      </categories>
      <tags>
        <tag>R語言</tag>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>回測</tag>
        <tag>R dataframe</tag>
      </tags>
  </entry>
  <entry>
    <title>台灣財富管理規劃顧問認證協會 - 2021 全國大專院校第十一屆財富管理競賽</title>
    <url>/2021/05/10/contest_experence/WMPCCA2021/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>僅此紀錄 2021/05 月所製作的財富管理競賽<br>「紀錄每個時刻，讓未來的自己不遺忘過去的自己」<br>只有自己才能體會自己的過去</p>
<p>每一次的努力都證明著自己的光輝</p>
</blockquote>
<a id="more"></a>

<h2 id="報名參加"><a href="#報名參加" class="headerlink" title="報名參加"></a>報名參加</h2><p>在北科大大二財富金融實習中，老師希望我們去參加財富管理競賽，於是請了兩位台灣財富管理規劃顧問認證協會顧問，我們坐在那邊強制聽了兩個小時後的洗腦後….，恩！參加這個競賽吧，感覺對我很有用呢！</p>
<p>班上同學彭元俊 and 許閔修 來找我一組後，我想他們都對金融有興趣那做起來一定會很順利吧！</p>
<h2 id="第十一屆財富管理競賽題目"><a href="#第十一屆財富管理競賽題目" class="headerlink" title="第十一屆財富管理競賽題目"></a>第十一屆財富管理競賽題目</h2><blockquote>
<p><a href="https://drive.google.com/file/d/1soapYdnTVuxWSvZdbGgA4JdFK8alOisl/view?usp=sharing" target="_blank" rel="noopener">檔案連結</a></p>
</blockquote>
<p>大概知道了題目，發現報名完後只剩下一個月時間可以做了！</p>
<h2 id="意見分歧-時間看法"><a href="#意見分歧-時間看法" class="headerlink" title="意見分歧 - 時間看法"></a>意見分歧 - 時間看法</h2><p>我認為只剩下一個月有點太趕，應該要早點做，但閔修認為應該等顧問來了再做，稍微有一些意見紛歧，不過我這邊還是有在緩速進行。</p>
<h2 id="報名"><a href="#報名" class="headerlink" title="報名"></a>報名</h2><p>報名交給元俊負責，這比較沒有甚麼問題，簡單的順利繳費就完成報名了。</p>
<h2 id="操作系統-題目方案"><a href="#操作系統-題目方案" class="headerlink" title="操作系統 - 題目方案"></a>操作系統 - 題目方案</h2><p>操作系統讓元俊負責 Key-In 資料，基本上題目方案沒有甚麼太大問題</p>
<h2 id="意見分歧-德宏規劃"><a href="#意見分歧-德宏規劃" class="headerlink" title="意見分歧 - 德宏規劃"></a>意見分歧 - 德宏規劃</h2><p>我們在對德宏規劃有一些很大想法不同，我比較偏向砍孝親費，從父母的支出減少，而元俊與閔修則是比較偏好刪掉孩子教育費的部分。</p>
<p>我個人認為小孩是家庭未來的主人翁，基本上我都不太願意進行刪減，只願意增加。</p>
<h2 id="只剩下我的意見"><a href="#只剩下我的意見" class="headerlink" title="只剩下我的意見"></a>只剩下我的意見</h2><p>由於我對於我的看法具有堅持性，而另外兩人則不太能夠順利說服我，因此我就不太願意改變我的想法；但在有些部分我不熟就不會進行針對，例如：投資與保險</p>
<p>但時間久了發現他們的想法沒了反而充斥者我大量的想法，不再是想法交流，而是我命令。</p>
<p>我很不喜歡這樣，我會堅持我的想法是因為我認為這樣是對的，理論上他們應該要能夠說服我，改變我的思考方式，而不是直接選擇閉口不說，這樣我做起來怎麼會有踏實感？</p>
<p>我不確定大家需不需要踏實感，但我很需要，如果沒有踏實感那怎麼對自己做出的作品有信心呢？</p>
<p>沒有踏實感的作品就不是自己的作品。</p>
<p>其實我也很歡迎大家跟我討論，只是我覺得他們可能也不太確定怎麼表達才會讓我改觀吧！</p>
<h2 id="寫文本"><a href="#寫文本" class="headerlink" title="寫文本"></a>寫文本</h2><p>由於時間只剩下兩個禮拜，且截止日那天剛好又是段考周，因此我決定要趕快寫出文本，做好分配後就開始寫文本，其中我覺得閔修的排版並不好，會給予我一種他並沒有再認真做得感覺，就會讓我有灰心感。</p>
<p>總之，我可能也沒有達到有效溝通，他們也不想要欺負我才會這樣吧，我也很苦惱我應該怎麼做比較好。</p>
<p>中間我也有再分配內容時，對他比較苛刻、口氣比較差點，我確實也要說聲抱歉，這是我的 blog，但我也不會全都只講我的優點，畢竟這是我寫給未來的自己看的鴨。</p>
<p><a href="https://hackmd.io/@VPjv3cgTSymc7fcZHA3GjQ/rygC1hWLu" target="_blank" rel="noopener">文本規劃</a></p>
<h2 id="顧問"><a href="#顧問" class="headerlink" title="顧問"></a>顧問</h2><p>顧問在倒數第二周終於來到我們學校，來告訴我們應該怎麼做，其中最重要的資訊就是<strong>德宏 38 歲，公司大量賺錢卻沒有分利，是否可以考慮跳槽</strong>，這我覺得非常好啊。</p>
<p>不過顧問太晚才來跟我們分享資訊導致我們前面做的東西都必須要修改，我覺得顧問那麼晚來並不好:(<br>認為協會聘請的顧問理應要早點來，讓大家有時間用心做，而不是匆匆的兩個禮拜就做完。</p>
<p>再來顧問在 Line 中回覆我們的訊息比較慢，這點比較難過，但顧問都有提出不合理的問題，舉例：保險缺口計算問題、資料來源修改、110 現況收入與支出計算錯誤</p>
<p>理論上是個很好的顧問，就是有時候回得比較慢，滿腔的熱忱隨著時間過去就會變得無所謂，我都在盡力避免讓我的熱情消逝。</p>
<p><a href="https://hackmd.io/@VPjv3cgTSymc7fcZHA3GjQ/SJY6C-hUO" target="_blank" rel="noopener">紀錄顧問的建議</a></p>
<h2 id="統整意見"><a href="#統整意見" class="headerlink" title="統整意見"></a>統整意見</h2><p><a href="https://hackmd.io/@VPjv3cgTSymc7fcZHA3GjQ/rkLaEYxEu" target="_blank" rel="noopener">統整意見</a></p>
<p>經過大戰後，終於定下來了！</p>
<p>雖然一開始我很反對用跳槽來讓德宏加薪，但因為時間真的不夠了沒有辦法再改了…，被時間威脅同意了。</p>
<h2 id="排版"><a href="#排版" class="headerlink" title="排版"></a>排版</h2><p>這是一件很痛苦的事情呢！</p>
<p>老實講，我們這組的人對於 word 排版、美觀都比我還要差…，所以這些事情都我來做，不然我看到他們的排版真的會發瘋，然後我請閔修幫我弄封面，這邊我就有點生氣了，閔修說他 mac 沒有 ps 所以就說要用我的電腦做，就把事情放在那邊了！我認為這是一個很不對的事情，我這邊就有一堆事情在趕工了，基本上這時候組員要分擔這些工作，不是說等我這邊的事情做完了在來讓他做，這樣直接讓我來做就好了啊！</p>
<p>由於必須很快速地進行排版，另外兩人根本沒有任何排版、美觀可言，於是我只好先拿著高中備審資料的格式去排版，我在這邊又有一個新體悟，有一個屬於自己的排版真的很重要，如果在時間過趕的情況下才可以迅速生成一個漂亮的 word。</p>
<p>至於首頁與封底也都是直接修改我的高中備審資料，我其實很難過，因為我認為這些應該要是我們用心做的，但是因為旁邊兩人對這問題都不擅長，也不好好去學習，趁我在忙碌的情況，一直討論研究所話題，真的會讓人很不爽。</p>
<p>畢竟這些事情並不是我的事情，明明是團隊的事情可是竟然都只有我在做。</p>
<p>雖然他們有關心我，但老實講聽到那些話題真的會讓我生氣。</p>
<h2 id="等等，元俊將-keys-系統搞錯了！"><a href="#等等，元俊將-keys-系統搞錯了！" class="headerlink" title="等等，元俊將 keys 系統搞錯了！"></a>等等，元俊將 keys 系統搞錯了！</h2><p>在我排版完後，元俊說 keys 系統他有些東西並沒有設對，我們將第一版資料傳給顧問看後，顧問提出來的，後來我們才知道我們的算法並不對！</p>
<p>我記得是星期六的早上看到，當下的我雖然很不爽，但我明白，錯誤的東西有提出來比起不提更重要，因此我不會進行責怪，但讓我很不開心的地方是，他們提出來的政策也太不讓人接受了八。<br>調薪起伏變更大…，我當下看到已經不想再說甚麼，這看起來就有點像是小學生想出的辦法，一點都不大學生。簡直就是想要草草了事。</p>
<p>總之，我很不開心，不過我還是秉持著團隊的精神接受了這個方案，畢竟我永遠都被時間綁架，根本事情就做不完。<br>如果我不接受，那取而代之的就是文章胎死腹中。</p>
<h2 id="寄信"><a href="#寄信" class="headerlink" title="寄信"></a>寄信</h2><p>寄信的時候真的非常寂寞，那天是禮拜五，我那天有演算法以及一堆事情要忙，體育課完後，另外兩人直接跑去找女朋友、跳舞，沒有人關心我們的家長通知書問題，這讓我感覺到非常難過，我認為我們是個團隊應該要互相追進度，而不是自己在做事情QQ，自己一個人在寄資料的時候還真的是滿滿的辛酸感呢！忙著要交資料又得要忙著去買晚餐。</p>
<p>結果買晚餐的時候才發現我沒有寫 WMPCCA 中文名稱，趕緊跑回去郵局一趟！幸好郵局人都很有善、信也還沒寄出，我才可以順利填補收件人。<br>總之也是一個驚魂夜，每天都在上演這種生活的話，我哪受的了。</p>
<blockquote>
<p>最終成果<br><img src="https://drive.google.com/u/2/uc?id=1i3UWdxz68R1BdFJLJpj3Kl33lE8BIn5z&export=download" alt=""></p>
</blockquote>
<p>當我寄完後，也沒有人對我說一聲感謝，我也是感覺百般無奈，沒有得到愛。</p>
<h2 id="改版與送出"><a href="#改版與送出" class="headerlink" title="改版與送出"></a>改版與送出</h2><p>我們將檔案做完後，我請另外兩人幫我檢查是否哪裡有錯字、語意不順的地方，第一次有抓出一個邏輯上的錯，接下來就從未抓錯，我傳給他們正式的版本，不知道他們有沒有好好閱讀過，他們都沒有報出錯誤，而我這邊卻一直不斷地發現錯誤，還真不知道是我的國中太強，還是他們有點不認真看。</p>
<p>每次抓錯字都很麻煩，心也很累啦唉，不過沒有比遇到爛隊友累。</p>
<p>總之最後改到第八版後，我就將資料送出了。 希望可以拿到佳作八。</p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>以上都是我的心得，我的觀點提出XD。 沒有任何公正、公開的言論，只有偏頗。</p>
<p>我覺得閔修感覺在這件事情上面不知道是很不用心 or 很沒想法，我認為很多地方他能夠提出來當一個指揮者，畢竟我不是一個理財規劃大師，我其實並沒有很擅長這種東西，所以我覺得我應該要拿出我的熱情給大家看，但是我感覺閔修一直再持消極態度，我很不喜歡消極態度，我做甚麼事情基本上都很積極，我每一件事情都希望是讓我滿意地交出去，這也導致有很多人在跟我當團隊時，會很受不了我的原因。</p>
<p>但反過來想，如果那不是團隊滿意的東西，我們就將資料丟出去。那能夠是你滿意的作品嗎？我要的是問心無愧，不是甚麼特優、第一名。<br>總之我認為閔修的缺點是過於消極、沒有想法，只局限於做團隊報告中，畢竟考試入學的，你不可以說他沒有能力，只是沒有發揮 or 這裡剛好是他的短處。<br>元俊的缺點就是不擅長抓錯，基本上很多東西都可以用 excel 數字去推導，但他似乎都沒有去注意這些問題。</p>
<p>而兩者共同的最大缺點就是都沒有創意，我覺得他們都沒有辦法發揮自己的創意，他們只是將自己的身體灌入別人訓練好的知識而已。</p>
<p>講講我的缺點好了<br>過於自信、過分要求，其實我並不是一個很棒的人，我也有很多的壞毛病，我的壞毛病都具有可視型，我的優點基本上不具有可視性，這也是有很多人都看不起我的原因，覺得我沒有很優秀，那是因為大家沒有體會過我的優點，我的能力基本上都是在關鍵時刻才可以發揮或是隱藏在一些細微的角落。</p>
<p>我並不覺得我做的事情是錯的，如果有人要我剎車，那就必須點出我的缺點來讓我信服，但是現在的人基本上根本不願意點出他人缺點，其實我很願意點出他人缺點，只是沒人喜歡聽，後來就不太喜歡講了。<br>這也是為甚麼我想要用文字表達的原因。</p>
<p>不太擅長安排時間，基本上對我而言，只有相對時間而沒有絕對時間，我其實根本不在乎一件事情要花多少時間，我只在乎這件事情我能不能做完，因此這會讓我的任何事情完成度很高，但缺點是我學到知識就比別人少，或是我的其他時間就比別人少，因為我只在意把事情完成，而不是讓自己的知識最大化、完成的事項最多。<br>這其實並不是一個很好的習慣，但我其實也不太想改變，我認為每件事情都要打破砂鍋問到底，才有學習的意義。</p>
<h2 id="作品"><a href="#作品" class="headerlink" title="作品"></a>作品</h2><p>最後，這是我們團隊的作品，希望大家會喜歡。</p>
<p>此檔案著作權保護，此財富管理競賽之理財規劃書嚴禁抄襲，僅供使用者參考。<br>轉發需標明出處<br><a href="https://drive.google.com/file/d/1FuF29rymUS6iqJ_m2vdW1ceByhHtA4Bd/view?usp=sharing" target="_blank" rel="noopener">左手希望右手毀滅 - 理財規劃案例書面審查資料</a></p>
]]></content>
      <categories>
        <category>競賽心得</category>
      </categories>
      <tags>
        <tag>競賽心得</tag>
        <tag>人生旅途</tag>
        <tag>金融競賽</tag>
      </tags>
  </entry>
  <entry>
    <title>linux 刪除後台工作</title>
    <url>/2021/05/12/linux/jobs-kill/</url>
    <content><![CDATA[<h2 id="問題描述"><a href="#問題描述" class="headerlink" title="問題描述"></a>問題描述</h2><blockquote>
<p>我們都知道，只要將運行的程式搬到後臺去執行，只需要在 <code>command &amp;</code> 即可，那我們要怎麼樣去刪除後台正在運行的程式呢？</p>
</blockquote>
<a id="more"></a>

<h2 id="查詢指令-jobs"><a href="#查詢指令-jobs" class="headerlink" title="查詢指令 jobs"></a>查詢指令 jobs</h2><p>先來介紹查詢指令 <code>jobs -l</code>，能夠將正在後臺運行的程式都展示出來，並會出現一個 4,5 位數字，為工作 ID。</p>
<h2 id="刪除後台執行-kill"><a href="#刪除後台執行-kill" class="headerlink" title="刪除後台執行 kill"></a>刪除後台執行 kill</h2><p>而如果要刪除後台工作指令則是透過 <code>kill XXXXX</code>，其中 XXXX 是工作 ID，只要我們將他刪除就可以將工作刪掉了！</p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://serverfault.com/questions/240155/how-can-i-kill-all-stopped-jobs" target="_blank" rel="noopener">How can I kill all stopped jobs? by stackExchange</a></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>R installation of package ‘sodium’ had non-zero exit status 解決方法</title>
    <url>/2021/05/11/R/R-sodium-non-zero-exit/</url>
    <content><![CDATA[<h2 id="問題描述"><a href="#問題描述" class="headerlink" title="問題描述"></a>問題描述</h2><blockquote>
<p>在 centOS6 作業系統中在安裝 R plumber，卻發生此問題那該怎麼辦呢？</p>
</blockquote>
<a id="more"></a>

<h2 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h2><p>在我的 server 中，主要是缺乏 libsodium-devel 此套件，因此我們要去安裝此套件就能解決此問題。</p>
<p>以下是每一種 os 中如果要安裝 sodium 一定需要的套件</p>
<ul>
<li>ubuntu 安裝 libsodium-dev</li>
<li>Fedora、EPEL 安裝 libsodium-devel </li>
<li>Solaris 安裝 libsodium_dev</li>
<li>OSX 安裝 libsodium</li>
</ul>
<h2 id="centOS-安裝-libsodium-出錯，內容為-error-‘crypto-auth-hmacsha512-BYTES’-undeclared-first-use-in-this-function-did-you-mean-‘crypto-auth-hmacsha512256-BYTES’"><a href="#centOS-安裝-libsodium-出錯，內容為-error-‘crypto-auth-hmacsha512-BYTES’-undeclared-first-use-in-this-function-did-you-mean-‘crypto-auth-hmacsha512256-BYTES’" class="headerlink" title="centOS 安裝 libsodium 出錯，內容為 error: ‘crypto_auth_hmacsha512_BYTES’ undeclared (first use in this function); did you mean ‘crypto_auth_hmacsha512256_BYTES’"></a>centOS 安裝 libsodium 出錯，內容為 error: ‘crypto_auth_hmacsha512_BYTES’ undeclared (first use in this function); did you mean ‘crypto_auth_hmacsha512256_BYTES’</h2><p>根據前面，於是我開始安裝 libsodium，但卻發生此錯誤 </p>
<p>先確認 libsodium 的版本，因為如果是早期 libsodium 的版本則有此漏洞，必須有新版本來改進此漏洞。</p>
<p>而在 R 語言中使用 libsodium 的版本必須是要 1.0.3 才不會遇到此漏洞，因此我們要更新 libsodium </p>
<p>安裝語法如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install libsodium #安裝 libsodium </span><br><span class="line"></span><br><span class="line">yum update libsodium  #如果之前有安裝，那麼更新就好</span><br></pre></td></tr></table></figure>

<h3 id="解決方法-centOS6"><a href="#解決方法-centOS6" class="headerlink" title="解決方法 - centOS6"></a>解決方法 - centOS6</h3><p>可能是虛擬機服務商的 libsodium-level 最高版本就是 0.4.5，並不符合 R 的要求，因此我們必須要去有更新的 libsodium-level 的網站下載。</p>
<p>stackoverflow 建議的版本為 lux<br><a href="https：//pkgs.org/download/libsodium-devel">此網頁很香，所有的套件都有</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo rpm -Uvh http:&#x2F;&#x2F;repo.iotti.biz&#x2F;CentOS&#x2F;6&#x2F;noarch&#x2F;lux-release-6-3.noarch.rpm</span><br><span class="line">sudo rpm --import &#x2F;etc&#x2F;pki&#x2F;rpm-gpg&#x2F;RPM-GPG-KEY-LUX</span><br></pre></td></tr></table></figure>

<p>再來我們去更改 repo 的位置<br>先 <code>vim /etc/yum.repos.d/lux.repo</code> 然後將內容修改為</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[lux]</span><br><span class="line">name&#x3D;CentOS $releasever - $basearch - Lux</span><br><span class="line">baseurl&#x3D;http:&#x2F;&#x2F;repo.iotti.biz&#x2F;CentOS&#x2F;6</span><br><span class="line">enabled&#x3D;1</span><br><span class="line">gpgcheck&#x3D;1</span><br><span class="line">gpgkey&#x3D;file:&#x2F;&#x2F;&#x2F;etc&#x2F;pki&#x2F;rpm-gpg&#x2F;RPM-GPG-KEY-LUX</span><br></pre></td></tr></table></figure>

<p>再來我們重新安裝 <code>sudo yum install libsodium-devel</code></p>
<p>之後我們 R 安裝 <code>install.packages(&quot;sodium&quot;)</code> 我就再也沒遇到問題。</p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://community.rstudio.com/t/installation-of-package-sodium-had-non-zero-exit-status/63624" target="_blank" rel="noopener">installation of package ‘sodium’ had non-zero exit status by Rstudio Community</a><br><a href="https://github.com/jeroen/sodium/issues/4" target="_blank" rel="noopener">Error installing on RHEL6 by github</a><br><a href="https://cran.r-project.org/web/packages/sodium/index.html" target="_blank" rel="noopener">sodium: A Modern and Easy-to-Use Crypto Library by cran-r</a></p>
]]></content>
      <categories>
        <category>R語言</category>
      </categories>
      <tags>
        <tag>R語言</tag>
        <tag>學習筆記</tag>
        <tag>RESTAPI</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 安裝 pip.py (for windows)</title>
    <url>/2021/05/18/Python/Python_install_pip/</url>
    <content><![CDATA[<h2 id="內容說明"><a href="#內容說明" class="headerlink" title="內容說明"></a>內容說明</h2><blockquote>
<p>我們都知道 python 安裝套件時，是使用 <code>pip install package</code> 的指令，那假如一開始沒有 pip 那應該要怎麼辦呢？</p>
</blockquote>
<a id="more"></a>

<h2 id="檢查電腦是否有-Python-and-pip"><a href="#檢查電腦是否有-Python-and-pip" class="headerlink" title="檢查電腦是否有 Python and pip"></a>檢查電腦是否有 Python and pip</h2><ul>
<li>先檢查 python 是否有安裝，在 cmd 輸入 <code>python -v</code><br>如果有成功安裝則會輸出當前在你電腦的版本</li>
<li>再來我們檢查 pip 是否有安裝，在 cmd 輸入 <code>pip help</code><br>如果有安裝成功則會輸出一些指令如何使用</li>
</ul>
<p>如果電腦一開始沒有安裝 python，必須先安裝 python </p>
<h2 id="安裝-pip"><a href="#安裝-pip" class="headerlink" title="安裝 pip"></a>安裝 pip</h2><ul>
<li><a href="https://bootstrap.pypa.io/get-pip.py" target="_blank" rel="noopener">下載 get-pip.py</a> 使用 ctrl+s 儲存</li>
<li>完成後將 get-pip.py 移到桌面</li>
<li>再來我們在 cmd 中輸入 <code>python get-pip.py</code></li>
</ul>
<p>然後我們就安裝成功了！</p>
<h2 id="確認-pip-是否有成功被安裝"><a href="#確認-pip-是否有成功被安裝" class="headerlink" title="確認 pip 是否有成功被安裝"></a>確認 pip 是否有成功被安裝</h2><p>如果 pip 有成功被安裝，那我們在 cmd 打 <code>pip help</code>，則應該會輸出 pip 的版本</p>
<h2 id="參考來源"><a href="#參考來源" class="headerlink" title="參考來源"></a>參考來源</h2><p><a href="https://phoenixnap.com/kb/install-pip-windows" target="_blank" rel="noopener">How To Install PIP to Manage Python Packages On Windows by phoenixnap </a><br><a href="https://phoenixnap.com/kb/install-pip-windows" target="_blank" rel="noopener">如何在 Windows 環境下安裝 pip by 傑瑞窩在這</a></p>
<h2 id="參考來源-1"><a href="#參考來源-1" class="headerlink" title="參考來源"></a>參考來源</h2><p>老了…，有些事情之前都知道怎麼做但是因為太久沒有做而忘記了QQ，希望我可以都不要忘記這些知識，讓我可以順利應用他們！</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>R dataframe 使用兩個條件去找出特定的資料</title>
    <url>/2021/05/18/R/R-dataframe-two-condition-search/</url>
    <content><![CDATA[<h2 id="問題描述"><a href="#問題描述" class="headerlink" title="問題描述"></a>問題描述</h2><blockquote>
<p>如果 dataframe 使用兩個條件去找出特定的資料想不到怎麼做？ 那就來看我這篇 blog 就對了！</p>
<p>標題已經有大概講述怎麼解決了XD</p>
</blockquote>
<a id="more"></a>

<h2 id="問題解決與舉例："><a href="#問題解決與舉例：" class="headerlink" title="問題解決與舉例："></a>問題解決與舉例：</h2><p>我們先產生出一個 dataframe，定義語法如下</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">df &lt;- data.frame(a = c(<span class="number">1</span>:<span class="number">5</span>), b = c(<span class="number">6</span>:<span class="number">10</span>), c = c(<span class="number">11</span>:<span class="number">15</span>))</span><br></pre></td></tr></table></figure>

<p>出來的資料如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  a  b  c</span><br><span class="line">1 1  6 11</span><br><span class="line">2 2  7 12</span><br><span class="line">3 3  8 13</span><br><span class="line">4 4  9 14</span><br><span class="line">5 5 10 15</span><br></pre></td></tr></table></figure>

<h3 id="塞選出-dataframe-中-b-的值要-gt-7-and-lt-9，要怎麼做呢"><a href="#塞選出-dataframe-中-b-的值要-gt-7-and-lt-9，要怎麼做呢" class="headerlink" title="塞選出 dataframe 中 b 的值要 &gt;= 7 and &lt;= 9，要怎麼做呢"></a>塞選出 dataframe 中 b 的值要 &gt;= 7 and &lt;= 9，要怎麼做呢</h3><p>那麼我們使用的語法如下</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">df[which(df$b &gt;= <span class="number">7</span> &amp; df$b &lt;= <span class="number">9</span>), ]</span><br><span class="line"><span class="comment">#which 塞選出特定的值，中間的 and 與 or 則使用 2 進位塞選，後面的 , 則是表示輸出所有欄位</span></span><br></pre></td></tr></table></figure>

<p>因此執行完此語法後應該如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  a b  c</span><br><span class="line">2 2 7 12</span><br><span class="line">3 3 8 13</span><br><span class="line">4 4 9 14</span><br></pre></td></tr></table></figure>

<p>漂亮，成功解決我們的問題</p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://stackoverflow.com/questions/4935479/how-to-combine-multiple-conditions-to-subset-a-data-frame-using-or" target="_blank" rel="noopener">How to combine multiple conditions to subset a data-frame using “OR”? by stackoverflow</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>R 是一種玄學，只需要抱持著盡量向量化、少用迴圈，你一定也可以寫出很 R 風格的程式！</p>
]]></content>
      <categories>
        <category>R語言</category>
      </categories>
      <tags>
        <tag>R語言</tag>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>回測</tag>
        <tag>R dataframe</tag>
      </tags>
  </entry>
  <entry>
    <title>R 檔案路徑用法教學 (檢查路徑、新增路徑)</title>
    <url>/2021/05/18/R/R-dir_using/</url>
    <content><![CDATA[<h2 id="內容說明"><a href="#內容說明" class="headerlink" title="內容說明"></a>內容說明</h2><blockquote>
<p>在寫 R 語言時有時要輸出檔案時則會遇到一些要新增資料夾或是檢查此路徑是否存在之類的，那應該要怎麼辦才好呢？</p>
<p>內容大概講述 R 對於一些路徑的使用方法</p>
</blockquote>
<a id="more"></a>

<h2 id="setwd-設定路徑"><a href="#setwd-設定路徑" class="headerlink" title="````setwd()``` 設定路徑"></a>````setwd()``` 設定路徑</h2><p>有時候必須要在同個資料夾中讀取大量檔案，但卻又不想每一個都設絕對路徑時，<code>setwd</code> 可以幫助你</p>
<h3 id="舉例：假如你現在有-3-個-csv-要打開，資料在-C-User-user-下"><a href="#舉例：假如你現在有-3-個-csv-要打開，資料在-C-User-user-下" class="headerlink" title="舉例：假如你現在有 3 個 csv 要打開，資料在 C:/User/user 下"></a>舉例：假如你現在有 3 個 csv 要打開，資料在 C:/User/user 下</h3><p>那我們可以透過 setwd() 來加速</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">setwd(<span class="string">"C:/Users/user/Desktop"</span>)</span><br><span class="line">a1 &lt;- read.csv(<span class="string">"./1.csv"</span>)</span><br><span class="line">a2 &lt;- read.csv(<span class="string">"./2.csv"</span>)</span><br><span class="line">a3 &lt;- read.csv(<span class="string">"./3.csv"</span>)</span><br></pre></td></tr></table></figure>

<p>這樣 a1, a2, a3 就可以直接用相對路徑了！</p>
<h2 id="getwd-查看當前設定的路徑位置"><a href="#getwd-查看當前設定的路徑位置" class="headerlink" title="getwd() 查看當前設定的路徑位置"></a><code>getwd()</code> 查看當前設定的路徑位置</h2><p>我們可以透過 getwd() 來找出現在 R 語言的路徑位置</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">getwd()</span><br><span class="line"><span class="comment">#[1] "C:/Users/user/Documents"</span></span><br></pre></td></tr></table></figure>

<h3 id="參考來源"><a href="#參考來源" class="headerlink" title="參考來源"></a>參考來源</h3><p><a href="https://stackoverflow.com/questions/38902954/how-can-i-use-the-command-pwd-in-r-to-load-data" target="_blank" rel="noopener">How can I use the command “pwd” in R to load data? by stackoverflow</a></p>
<h2 id="file-exists-檢查路徑是否存在"><a href="#file-exists-檢查路徑是否存在" class="headerlink" title="file.exists() 檢查路徑是否存在"></a><code>file.exists()</code> 檢查路徑是否存在</h2><p>我們可以透過 <code>file.exists()</code> 來知道路徑是否有被存在。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">file.exists(<span class="string">"C:/Users/user/Desktop"</span>) <span class="comment">#true</span></span><br><span class="line">file.exists(<span class="string">"D:/Desktop"</span>) <span class="comment">#false</span></span><br></pre></td></tr></table></figure>

<h3 id="參考來源-1"><a href="#參考來源-1" class="headerlink" title="參考來源"></a>參考來源</h3><p><a href="https://stackoverflow.com/questions/4216753/check-existence-of-directory-and-create-if-doesnt-exist" target="_blank" rel="noopener">Check existence of directory and create if doesn’t exist by stackoverflow</a></p>
<h2 id="dir-create-新增資料夾"><a href="#dir-create-新增資料夾" class="headerlink" title="dir.create() 新增資料夾"></a><code>dir.create()</code> 新增資料夾</h2><p>我們可以透過 <code>file.create()</code> 來新增資料夾。</p>
<h3 id="舉例：我們可以檢查桌面是否有-folder，如果沒有我們就新增資料夾"><a href="#舉例：我們可以檢查桌面是否有-folder，如果沒有我們就新增資料夾" class="headerlink" title="舉例：我們可以檢查桌面是否有 folder，如果沒有我們就新增資料夾"></a>舉例：我們可以檢查桌面是否有 folder，如果沒有我們就新增資料夾</h3><figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(!file.exists(<span class="string">"C:/Users/user/Desktop/folder"</span>)) dir.create(<span class="string">"./folder"</span>)</span><br></pre></td></tr></table></figure>

<h2 id="file-path-合併路徑"><a href="#file-path-合併路徑" class="headerlink" title="file.path() 合併路徑"></a><code>file.path()</code> 合併路徑</h2><p>其實大致上可以用 string 來合併路徑，但是如果這份程式碼會給不同的 os 系統使用時，那使用 file.path() 可以避免 string 合併路徑時，因為路徑的樣式不同(例如 mac 與 os 路徑就不相同) 等狀況。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(!file.exists( file.path(<span class="string">"C:/Users/user/Desktop"</span>, <span class="string">"folder"</span>)) dir.create(<span class="string">"folder"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#如果當前的 R console 路徑就在桌面，那可以考慮使用 getwd 替換 "C:/Users/user/Desktop"</span></span><br></pre></td></tr></table></figure>

<h3 id="參考來源-2"><a href="#參考來源-2" class="headerlink" title="參考來源"></a>參考來源</h3><p><a href="https://stackoverflow.com/questions/51533664/file-path-function-in-r" target="_blank" rel="noopener">file.path function in R by stackoverflow</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>紀錄我之前遇到的所有困難，這樣我之後就能夠在自己的 blog 中找到問題，避免再 google 搜尋卻遇到大量農場文章或是不相干的資料。</p>
]]></content>
      <categories>
        <category>R語言</category>
      </categories>
      <tags>
        <tag>R語言</tag>
        <tag>學習筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>北科資財二資料探勘研究與實務 期中專題 - 利用 Data Mining 分析學生在學業上的表現</title>
    <url>/2021/05/17/NTUT_note/NTUT_dataMinging_midternPPT/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊與財金管理系大二下資料探勘研究與實務專題紀錄<br><font color="#dd0000">並非所有人都適用，此為老師所給予的題目。</font><br><strong>這是個人心得的筆記，可能不太適用會未來的學生</strong></p>
<p>（謝謝林湘霖老師的指導）<br>資料來源：<a href="https://www.kaggle.com/aljarah/xAPI-Edu-Data" target="_blank" rel="noopener">Students’ Academic Performance Dataset by kaggle</a></p>
</blockquote>
<a id="more"></a>

<h2 id="期中專案報告"><a href="#期中專案報告" class="headerlink" title="期中專案報告"></a>期中專案報告</h2><p>以下是我們這組的期中報告，供大家學習與閱讀。<br><a href="https://drive.google.com/file/d/1xyiycVzRT1qlkHLixaWsmxrzjKK20Ql1/view?usp=sharing" target="_blank" rel="noopener">利用 Data Mining 分析學生在學業上的表現</a></p>
<p>此備審資料嚴禁抄襲，僅供使用者參考。</p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>老師透過 Weka 來教導我們如何做資料探勘，讓我們了解到關聯規則、決策樹、KNN，以及判定其是否有效的方法，老師在教導我們的過程中非常詳細，讓我們非常清楚的知道每一個步驟，我是資料探勘的初學者，老師的教導方式讓我獲益良多！</p>
<p>老師是系上比較年輕的老師，講話蠻有趣的XDDD，會開系上的一些玩笑，學習過程中歡樂而不失其專業性，是一位好老師，我從他的課程中學習到許多知識，也大概知道處理資料時最重要的是資料前處理、解讀資料，我很感謝老師的教導。</p>
<p>題外話：可以請老師當我的指導教授嘛XD，我覺得我會獲益良多；怎麼感覺我的心得都是在講老師很好www。</p>
<p>不過透過這次的專題，讓我明顯知道 Weka 如何使用，如何透過 Weka 來解讀資料。希望可以供我在未來遇到需要用此技術的問題時都能夠順利地想起且成功應用。</p>
]]></content>
      <categories>
        <category>北科上課筆記</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>北科大資料探勘研究與實務筆記</tag>
        <tag>資料探勘 Data Mining</tag>
      </tags>
  </entry>
  <entry>
    <title>R 尋找前 n 筆的 dataframe 或是後 n 筆的 dataframe</title>
    <url>/2021/05/18/R/R-search-tail-or-head/</url>
    <content><![CDATA[<h2 id="內容說明"><a href="#內容說明" class="headerlink" title="內容說明"></a>內容說明</h2><blockquote>
<p>有時候我們會想要找出 dataframe 從上找 n 筆或是由下往上找 n 筆資料，R 有沒有甚麼好語法提供呢？</p>
</blockquote>
<a id="more"></a>

<h2 id="解決方法"><a href="#解決方法" class="headerlink" title="解決方法"></a>解決方法</h2><h3 id="找-dataframe-前-n-筆資料"><a href="#找-dataframe-前-n-筆資料" class="headerlink" title="找 dataframe 前 n 筆資料"></a>找 dataframe 前 n 筆資料</h3><p>可以這樣子寫</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">head(dataframe, n) <span class="comment"># n 是 interger</span></span><br></pre></td></tr></table></figure>

<h3 id="找-dataframe-後-n-筆資料"><a href="#找-dataframe-後-n-筆資料" class="headerlink" title="找 dataframe 後 n 筆資料"></a>找 dataframe 後 n 筆資料</h3><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">tail(dataframe, n) <span class="comment"># n 是 interger</span></span><br></pre></td></tr></table></figure>

<h2 id="進階操作：例如我們有一個迴圈每次的-row-都需要前一筆-row-的資料來計算那該怎麼辦呢？"><a href="#進階操作：例如我們有一個迴圈每次的-row-都需要前一筆-row-的資料來計算那該怎麼辦呢？" class="headerlink" title="進階操作：例如我們有一個迴圈每次的 row 都需要前一筆 row 的資料來計算那該怎麼辦呢？"></a>進階操作：例如我們有一個迴圈每次的 row 都需要前一筆 row 的資料來計算那該怎麼辦呢？</h2><p>這時候我們就可以使用 <code>head</code> 來幫忙</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">dataframe$last_row &lt;- c(<span class="number">0</span>, head(dataframe$row, nrow(dataframe)-<span class="number">1</span>))</span><br><span class="line"><span class="comment">#由於我們都需要前一筆的資料，但是第一筆資料則沒有前一個 row，因此我們放零。</span></span><br><span class="line"><span class="comment"># head 則是因為我們都需要前一筆的，因此後面我們用 head 拼接</span></span><br></pre></td></tr></table></figure>

<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://stackoverflow.com/questions/28008177/r-language-how-to-print-the-first-or-last-rows-of-a-data-set/28008180" target="_blank" rel="noopener">R Language: How to print the first or last rows of a data set? [duplicate]<br> by stackoverflow</a></p>
]]></content>
      <categories>
        <category>R語言</category>
      </categories>
      <tags>
        <tag>R語言</tag>
        <tag>學習筆記</tag>
        <tag>R dataframe</tag>
      </tags>
  </entry>
  <entry>
    <title>R dataframe 增加新的 column</title>
    <url>/2021/05/18/R/R-dataframe_append_column/</url>
    <content><![CDATA[<h2 id="問題描述"><a href="#問題描述" class="headerlink" title="問題描述"></a>問題描述</h2><blockquote>
<p>如果 dataframe 想要在中途增加 column 時，那該怎麼辦呢？</p>
</blockquote>
<a id="more"></a>

<h2 id="解決方法"><a href="#解決方法" class="headerlink" title="解決方法"></a>解決方法</h2><p>增加新的 column 要怎麼做呢？看我示範八：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">df &lt;- data.frame(a=c(<span class="number">1</span>:<span class="number">5</span>), b=c(<span class="number">6</span>:<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#兩種方式都可以增加 column</span></span><br><span class="line">new_column &lt;- <span class="string">"david"</span></span><br><span class="line"></span><br><span class="line">df[[new_column]] &lt;- <span class="number">0</span> <span class="comment">#透過變數命名，增加新的 column</span></span><br><span class="line">df[[<span class="string">"david"</span>]] &lt;- <span class="number">0</span> <span class="comment">#透過字串，增加新的 column</span></span><br></pre></td></tr></table></figure>








]]></content>
      <categories>
        <category>R語言</category>
      </categories>
      <tags>
        <tag>R語言</tag>
        <tag>學習筆記</tag>
        <tag>R dataframe</tag>
      </tags>
  </entry>
  <entry>
    <title>演算法知識 - Josephus problem 約瑟夫問題 遞迴公式說明與應用</title>
    <url>/2021/05/21/Explain_Algorithm/josephus/</url>
    <content><![CDATA[<h2 id="Josephus-problem-約瑟夫問題介紹"><a href="#Josephus-problem-約瑟夫問題介紹" class="headerlink" title="Josephus problem 約瑟夫問題介紹"></a>Josephus problem 約瑟夫問題介紹</h2><blockquote>
<p>約瑟夫問題是一個非常黑暗的問題XD，主要是殘兵們不想被對方軍團俘虜，而想出一種自殺方式，其內容大概如下</p>
<ul>
<li>全部人圍成一個圓圈，編號 \(1,2,3,…,n\)</li>
<li>定義一個數字 \(k\)，只要數到第 k 個數字，那麼那個人就自殺。</li>
<li>接下來，從死掉的那個人開始在數 k 個數字，再來第 \(2k\) 的人自殺。</li>
<li>不斷數著 k、不斷地自殺，不斷循環，直到最後只剩下一個人為止。</li>
</ul>
<p>而我們的主角 Josephus 則不想要自殺，於是他必須找到一個位置，並且是最後剩下的那個人。</p>
<p>表達大致上的意思，並沒有全部完整表達。</p>
<p>下方我的證明可能並沒有很好閱讀，因此不懂的讀者可以參考<a href="https://blog.csdn.net/u011500062/article/details/72855826" target="_blank" rel="noopener">约瑟夫环——公式法（递推公式） by 陈浅墨</a></p>
</blockquote>
<a id="more"></a>

<h2 id="模擬操作解法"><a href="#模擬操作解法" class="headerlink" title="模擬操作解法"></a>模擬操作解法</h2><p>時間複雜度為 \(O(nm)\)，當 n,m 大於一百萬時，必會耗時許久。</p>
<p>但如果題目有說必須<strong>依序</strong>輸出被殺死的人時，那我們就必須使用此方法。</p>
<h2 id="遞迴公式-求出最後一位生還者"><a href="#遞迴公式-求出最後一位生還者" class="headerlink" title="遞迴公式 - 求出最後一位生還者"></a>遞迴公式 - 求出最後一位生還者</h2><p>時間複雜度為 \(O(n)\)，快了超級多！ 但我們只能夠求出最後一位生還者。</p>
<blockquote>
<p>詳細的說明請看 YT<br><a href="https://drive.google.com/file/d/1wQ9f0vNXI4OrJpl0ZPaEWn1CIom0AeuP/view?usp=sharing" target="_blank" rel="noopener">上面影片中約瑟夫問題 說明的 excel 文件 pdf 檔案</a><br><a href="https://drive.google.com/file/d/1z8DM3huddD8P5I2VoD7PdKs9jVos7JMO/view?usp=sharing" target="_blank" rel="noopener">上面影片中約瑟夫問題 說明的 excel 文件 excel 檔案</a></p>
<div class="video-container"><iframe src="https://www.youtube.com/embed/WYSyNanl7s0" frameborder="0" loading="lazy" allowfullscreen></iframe></div>
</blockquote>
<h2 id="程式碼說明"><a href="#程式碼說明" class="headerlink" title="程式碼說明"></a>程式碼說明</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">josephus</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>; <span class="comment">//一開始的編號</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) s = (s+k) % i; <span class="comment">//第 i 輪中，他的位置是第 s </span></span><br><span class="line">    <span class="keyword">return</span> s+<span class="number">1</span>; <span class="comment">//如果題目的編號一開始是 1，那我們就加一</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="相關題目"><a href="#相關題目" class="headerlink" title="相關題目"></a>相關題目</h2><ul>
<li><a href="https://theriseofdavid.github.io//2021/05/21/UVa/UVa10774/" target="_blank" rel="noopener">UVa10774 - Repeated Josephus(數論 Math theorm、Josephus problem 約瑟夫問題) by 大衞的筆記 </a></li>
<li><a href="https://theriseofdavid.github.io//2021/05/21/UVa/UVa11531/" target="_blank" rel="noopener">UVa11531 - Last Man Standing(數論 Math theorm、Josephus problem 約瑟夫問題) by 大衞的筆記</a></li>
</ul>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://blog.csdn.net/u011500062/article/details/72855826" target="_blank" rel="noopener">约瑟夫环——公式法（递推公式） by 陈浅墨</a><br><a href="https://zh.wikipedia.org/wiki/%E7%BA%A6%E7%91%9F%E5%A4%AB%E6%96%AF%E9%97%AE%E9%A2%98#%E6%95%B0%E5%AD%A6%E6%8E%A8%E5%AF%BC%E8%A7%A3%E6%B3%95" target="_blank" rel="noopener">約瑟夫斯問題 by wiki</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>其實這題我學習很久…，主要是他的證明比較抽象化，不太好在腦內思考，後來是找到一篇很棒的文章！幫助了我思考XD。</p>
<p><a href="https://blog.csdn.net/u011500062/article/details/72855826" target="_blank" rel="noopener">约瑟夫环——公式法（递推公式） by 陈浅墨</a>這篇文章非常好懂，大力推！<br>只是他的 Q1 必須看留言會更好懂些。不愧是大佬，可以用文字敘述就表達此題！我這次想要用文字敘述來表達都表達不出來QQQ。</p>
<p>有稍微讓自己的腦袋運動了一下，希望腦袋經過這次的摧殘後又變得越來越聰明XD。</p>
<p>不過有時候還是會覺得，花了這麼多時間在讓自己證明這些東西，結果以後如果要是忘記了就覺得好可惜QQ。</p>
<p>總之，希望我可以在這份證明學習到的知識，應用在任何一個可以應用的地方上。<br>我最怕的就學會卻不會應用。</p>
<h2 id="學習紀錄"><a href="#學習紀錄" class="headerlink" title="學習紀錄"></a>學習紀錄</h2><p>我有用紙筆來進行學習，現在拍下照片來記錄！</p>
<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1JEGCrPHKVfWqm9rWEA8aqbYaqVrLmkge&export=download" alt=""><br><img src="https://drive.google.com/u/2/uc?id=1SismCacNxlsP7IzQyhUq1yv3AcwnrFc6&export=download" alt=""></p>
</blockquote>
<h1 id="這邊為我之前原本想要用文字進行說明，卻發現我沒辦法很明顯用文字進行說明，但我這邊留下來進行紀錄"><a href="#這邊為我之前原本想要用文字進行說明，卻發現我沒辦法很明顯用文字進行說明，但我這邊留下來進行紀錄" class="headerlink" title="這邊為我之前原本想要用文字進行說明，卻發現我沒辦法很明顯用文字進行說明，但我這邊留下來進行紀錄"></a>這邊為我之前原本想要用文字進行說明，卻發現我沒辦法很明顯用文字進行說明，但我這邊留下來進行紀錄</h1><h3 id="我們來舉個例：有-8-個人，依序並且不斷循環，只要數到第-3-個人，那他則必須自殺，最後存活下來的人是誰？"><a href="#我們來舉個例：有-8-個人，依序並且不斷循環，只要數到第-3-個人，那他則必須自殺，最後存活下來的人是誰？" class="headerlink" title="我們來舉個例：有 8 個人，依序並且不斷循環，只要數到第 3 個人，那他則必須自殺，最後存活下來的人是誰？"></a>我們來舉個例：有 8 個人，依序並且不斷循環，只要數到第 3 個人，那他則必須自殺，最後存活下來的人是誰？</h3><ul>
<li>來個想法，我們可以簡單的看的出來 \(n=8, k=3\) 的情況下，最後存活的人是誰嗎？</li>
<li>我們來把題目稍微簡單化<ul>
<li>在 \(n = 1, k = 3\) 的情況下，會有人死掉嗎？<br>不會，因為她是倖存的最後一位，因此存活的會是 1。</li>
<li>在 \(n = 2, k = 3\) 的情況下，哪一個人可以活到最後呢？<br>2，因為數到 3 剛好是 1。</li>
<li>在 \(n = 3, k = 3\) 的情況下，哪一個人可以活到最後呢？<br>2，第一次數到 3 時位置在第 3、第二次數到 3 時位置在 1。</li>
</ul>
</li>
<li>在剛剛的應用中，我們大概知道一些規則，這時候我們用 \(n = 3, k = 3\) 來舉例<ul>
<li>定義隊伍為 \(1,2,3,…\)，且不斷循環，因此可以寫成 \(1,2,3,1,2,3,…\)</li>
<li>由於是循環排序，因此前面的數字會被移到隊伍最後方，我們永遠只需要從數列第一個開始計算第 k 個</li>
<li>如果我們移除了數字 a，那們我們的隊伍則不可以再有數字 a</li>
<li>因此順序是<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pos: 1 2 3 4 5 6 7 8 9</span><br><span class="line">val: 1 2 3 1 2 3 1 2 3</span><br></pre></td></tr></table></figure></li>
<li>當我們數到第三個位置時， 3 必須被移除，不再排序中，因此我們將隊伍中所有的 3 移除<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">        ^</span><br><span class="line">pos:1 2 3 4 5 6</span><br><span class="line">val:1 2 1 2 1 2</span><br><span class="line">#我們將 pos 3 的數字全部刪除，並且將空缺位置補上。</span><br><span class="line"># ^ 為下一次數列的開始位置</span><br></pre></td></tr></table></figure></li>
<li>我們再來數到第三個位置時，將他移除，這邊我們會移除的則是 1，因此我們將隊伍中所有的 1 移除<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">        ^</span><br><span class="line">pos:1 2 3 </span><br><span class="line">val:2 2 2</span><br><span class="line"># 我們將 pos 3 的數字全部刪除，並且將空缺位置補上。</span><br><span class="line"># ^ 為下一次數列的開始位置</span><br></pre></td></tr></table></figure></li>
<li>現在隊伍裡面只剩下一個數字了，那就是 2。</li>
</ul>
</li>
<li>剛剛我們舉例了 n 從 3 -&gt; 1，發現這是一種模擬操作對吧？現在我們換個角度來看，來算算看 n 從 1 -&gt; 3 <ul>
<li>定義存活的數字為 2，英文為 alive。</li>
<li>\(n = 1\)的隊伍是 \(2(alive),2,2,…,2\)，我們並不需要移除，因為只剩下一個數字</li>
<li>剛剛我們是將<strong>前面的數字移到隊伍最後方，現在我們則將後面的數字移到隊伍最前方，還原操作</strong></li>
<li>\(n = 2\)的隊伍是 \(1(k = 1),2(k = 2),1(被移除的數字, k = 3),2(alive),…,1,2\)</li>
<li>\(n = 3\)的隊伍是 \(1(k=1),2(k=2),3(被移除的數字,k=3),1(n=2,k=1),2(n=2,k=2),3(n= 2, 數字被移除),1(被移除的數字, n = 2,k = 3,),2,,…,1,2,3\)</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>演算法知識</category>
      </categories>
      <tags>
        <tag>程式解題</tag>
        <tag>演算法知識</tag>
        <tag>數論 Math theorm</tag>
        <tag>Josephus problem 約瑟夫問題</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa10774 - Repeated Josephus(數論 Math theorm、Josephus problem 約瑟夫問題)</title>
    <url>/2021/05/21/UVa/UVa10774/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>我不想浪費你的時間在讀題目，這裡有 n 個人要約瑟夫問題，其中 k = 2，倖存者的位置為 x，如果 \(x != n\)，那我們將讓 \(n = x\)，n 等於 x，重新進行一次約瑟夫問題，而新的倖存者位置如果等於 n，那我們就輸出，這是第幾次執行約瑟夫問題(不包含第一次)，第 n 個人的位置是多少？</p>
<p>舉例：n = 5 時的約瑟夫問題為 3，\(5 != 3\)，將 \(n =3\) 執行約瑟夫問題，這次 \(n = 3, x = 3\)，重複執行了 1 次約瑟夫問題，最後一次的約瑟夫問題的 x 是 3。<br>因此輸出 “1 3”</p>
<p><a href="https://onlinejudge.org/external/107/10774.pdf" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li>能了解此題題目，不誇張，我看了 30min</li>
<li><a href="https://theriseofdavid.github.io/2021/05/21/Explain_Algorithm/josephus/" target="_blank" rel="noopener">約瑟夫問題</a></li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>其實這題並沒有太大的難度，只要你了解約瑟夫問題。</p>
<p>之後就是判斷有沒有與 n 相同，沒有就重做，有就繼續做。</p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://hackmd.io/@txya900619/Uva10774" target="_blank" rel="noopener">Uva10774 - Repeated Josephus by txya900619</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>謝謝力瑋的詳解QQQQ。<br>我寫這個寫得好痛苦。</p>
<p>我之前是有學過約瑟夫問題，但是年代久遠後似乎就忘記了，現在要重學一遍發現自己都忘得差不多，快跟一個初學者差不多了…。</p>
<p>我不想忘記我所學過的事物阿。</p>
<p>不過謝謝力瑋，我看他的程式碼才了解他的英文…。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> t, repeat, kase;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">josephus</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span></span>&#123; <span class="comment">//約瑟夫問題 請直接點選 重點觀念-約瑟夫問題 來了解相關知識</span></span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) s = (s+k) % i;</span><br><span class="line">    <span class="keyword">return</span> s+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        kase++;</span><br><span class="line">        <span class="keyword">int</span> n, survivor=<span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        repeat = <span class="number">0</span>; <span class="comment">//判斷總共做了幾次約瑟夫問題(不包含第一次)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            survivor = josephus(n,<span class="number">2</span>); <span class="comment">//表示這次的倖存者位置</span></span><br><span class="line">            <span class="keyword">if</span>(survivor == n) <span class="keyword">break</span>; <span class="comment">//如果倖存者位置與 n 相同就跳出</span></span><br><span class="line">            n = survivor; <span class="comment">//將 n 設定為倖存者位置</span></span><br><span class="line">            repeat++; <span class="comment">//約瑟夫問題將會重做一次</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Case "</span> &lt;&lt; kase &lt;&lt; <span class="string">": "</span> &lt;&lt; repeat &lt;&lt; <span class="string">" "</span> &lt;&lt; n &lt;&lt; <span class="string">'\n'</span>; <span class="comment">//輸出答案</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>數論 Math theorm</tag>
        <tag>Josephus problem 約瑟夫問題</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa11531 - Last Man Standing(數論 Math theorm、Josephus problem 約瑟夫問題)</title>
    <url>/2021/05/21/UVa/UVa11351/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p><a href="https://theriseofdavid.github.io/2021/05/21/Explain_Algorithm/josephus/" target="_blank" rel="noopener">約瑟夫問題</a>，給你 n,k，總共有 n 個人，數到第 k 個人，那人則必須離開。</p>
<p>試問，最後一個人會是離開的人是誰？</p>
<p><a href="https://onlinejudge.org/external/113/11351.pdf" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li><a href="https://theriseofdavid.github.io/2021/05/21/Explain_Algorithm/josephus/" target="_blank" rel="noopener">約瑟夫問題</a></li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>只要你了解約瑟夫問題，這題基本上小學生都會寫。</p>
<p>實現約瑟夫問題的遞迴公式即可。</p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>我學約瑟夫問題學了 4hr，現在來一題簡單的，有點開心嗎(? XD。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> t, n, k, kase;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">        <span class="keyword">int</span> survivor = <span class="number">0</span>;  <span class="comment">//約瑟夫問題 請直接點選 重點觀念-約瑟夫問題 來了解相關知識</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) survivor = (survivor + k) % i;</span><br><span class="line">        survivor++;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Case "</span> &lt;&lt; ++kase &lt;&lt; <span class="string">": "</span> &lt;&lt; survivor &lt;&lt; <span class="string">'\n'</span>; <span class="comment">//輸出答案</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>數論 Math theorm</tag>
        <tag>Josephus problem 約瑟夫問題</tag>
      </tags>
  </entry>
  <entry>
    <title>演算法知識 - insertion sort 插入排序</title>
    <url>/2021/05/24/Explain_Algorithm/Insertion_sort/</url>
    <content><![CDATA[<h2 id="Insertion-sort-插入排序-介紹與實作原理"><a href="#Insertion-sort-插入排序-介紹與實作原理" class="headerlink" title="Insertion sort 插入排序 介紹與實作原理"></a>Insertion sort 插入排序 介紹與實作原理</h2><blockquote>
<p>插入排序是最簡單的一種排序法之一，以遞減排序為例。</p>
<ul>
<li>先給定一陣列，index 1 是最大，之後的陣列數值遞減</li>
<li>透過雙重迴圈<ul>
<li>第一層迴圈，決定第 i 大的位置的數字</li>
<li>第二層迴圈，判斷從第 i 以後的的位置，哪個數字最大就放置後面</li>
</ul>
</li>
</ul>
<p>時間複查度為 \(O(n^2)\)，雖然不實用，但對初學者直觀</p>
</blockquote>
<a id="more"></a>

<h2 id="Insertion-Sort-程式碼說明與應用"><a href="#Insertion-Sort-程式碼說明與應用" class="headerlink" title="Insertion Sort 程式碼說明與應用"></a>Insertion Sort 程式碼說明與應用</h2><p>主要核心是</p>
<ul>
<li>i 迴圈，數列 i 要被放置哪個位置</li>
<li>j 迴圈，找出第 (i+1)~n 的數值中，哪個數字最大</li>
</ul>
<p>由於我們 i 從 0 開始，只要我們每一個 i 都放入 i~n 的最大值，那麼第 i 的數值一定會比 i+1 還大，以此類推，證明這是有效的排序。</p>
<p>下面主要示範由大到小排序</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> num[] = &#123;<span class="number">4</span>,<span class="number">96</span>,<span class="number">1546</span>,<span class="number">13</span>,<span class="number">48</span>,<span class="number">34</span>,<span class="number">77</span>,<span class="number">48</span>,<span class="number">31</span>&#125;; <span class="comment">//要交換的數列</span></span><br><span class="line"><span class="keyword">int</span> num_size; <span class="comment">//要排序的數列大小</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_sort</span><span class="params">()</span></span>&#123;</span><br><span class="line">    num_size = <span class="keyword">sizeof</span>(num) / <span class="keyword">sizeof</span>(num[<span class="number">0</span>]); <span class="comment">//判斷數列長度</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num_size; i++)&#123; <span class="comment">//判斷第 i 個位置，要放哪個數值，</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; num_size; j++)&#123; <span class="comment">//判斷從 i~n，哪個數字最大</span></span><br><span class="line">            <span class="keyword">if</span>(num[i] &lt; num[j]) swap(num[i], num[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">()</span></span>&#123; <span class="comment">//輸出資料用</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num_size; i++) <span class="built_in">cout</span> &lt;&lt; num[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    insert_sort();</span><br><span class="line">    output();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<!-- 
## 心得
我們北科資財教資料結構的老師，我很不喜歡他的教法，他的教法就是把資料結構當作國文課在上，完全沒有教學生怎麼做，讓學生動手寫，就是照 ppt 宣科，根本沒有讓學生學習到東西，就像是通識課一樣，學過就忘了。

明明演算法是非常不適合忘記的資料。

總之，幸好我終於快逃離這堂課了，這堂課讓我活得很痛苦阿！高中教導我的演算法老師比大學老師還認真、還仔細教QQQQ。

我真的要哭了...。
 -->

<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>由於 C++ 已經有很多 sort 套件了，因此我在高中學會後我就再也沒有去複習這些知識。</p>
<p>剛好現在上課有用到那就來複習，順便把它寫出邏輯八！</p>
<h2 id="程式執行結果"><a href="#程式執行結果" class="headerlink" title="程式執行結果"></a>程式執行結果</h2><blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1Hs2w4JRj0Wh9lT6uazLpP2WvqBnTPCZP&export=download" alt=""></p>
</blockquote>
]]></content>
      <categories>
        <category>演算法知識</category>
      </categories>
      <tags>
        <tag>程式解題</tag>
        <tag>演算法知識</tag>
        <tag>數論 Math theorm</tag>
      </tags>
  </entry>
  <entry>
    <title>演算法知識 - 快速排序 quick sort</title>
    <url>/2021/05/24/Explain_Algorithm/quick_sort/</url>
    <content><![CDATA[<h2 id="quick-sort-快速排序-介紹與實作原理"><a href="#quick-sort-快速排序-介紹與實作原理" class="headerlink" title="quick sort 快速排序 介紹與實作原理"></a>quick sort 快速排序 介紹與實作原理</h2><blockquote>
<p>快速排序顧名思義就是快的排序嘛XD。平均時間複雜度為 \(O(n log n\)，算是平常大家會用的演算法之一</p>
<p>實作原理如下：</p>
<ul>
<li>定義 L 與 R，分別是當前數列的最左邊 index 與最右邊的 index</li>
<li>standard 為每次 quick_sort 的第一值，每個人可以定義如何選擇此數字。<ul>
<li>定義：x 為數值，數堆為 standard 左 or 右 邊的數值</li>
<li>我們主要是想讓陣列從原本的 <code>standard x x x x x x</code>，透過程式碼運算後改成 <code>x x x standard x x x</code>，再讓 standard 的左右邊再進行一次 quick_sort。</li>
<li>而我們交換的方式就是使用兩個指針 L and R，從 L 開始不斷往右找直到找出第一個值比 standard 還大；從 R 開始不斷往左找直到找出第一個值比 standard 還大</li>
<li>找到後進行交換，之後重複上一點，直到 L、R 指針相遇</li>
<li>其中 standard 的左邊一定比 standard 還小，standard 的右邊一定比 standard 還大</li>
<li>因此要找出最適合此排序的 standard 會讓排序變得更輕鬆，否則如果選出過大的 standard 會使的分好的兩堆數量過於偏頗，如： ```x x x x x standard x ``，</li>
</ul>
</li>
<li>之後將 standard 隔開的兩數堆在進行 quick_sort，直到 standard 的左右沒辦法在分堆(遇到邊界)</li>
</ul>
</blockquote>
<a id="more"></a>

<h2 id="Insertion-Sort-程式碼說明與應用"><a href="#Insertion-Sort-程式碼說明與應用" class="headerlink" title="Insertion Sort 程式碼說明與應用"></a>Insertion Sort 程式碼說明與應用</h2><p>透過程式碼來進行說明相信會更好理解，以下我們示範從小到大排序</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"><span class="keyword">int</span> num[] = &#123;<span class="number">4</span>,<span class="number">96</span>,<span class="number">1546</span>,<span class="number">13</span>,<span class="number">48</span>,<span class="number">34</span>,<span class="number">77</span>,<span class="number">48</span>,<span class="number">31</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> num_size;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">()</span></span>&#123; <span class="comment">//輸出排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; num_size ; i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; num[i] &lt;&lt; <span class="string">' '</span> ;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> L , <span class="keyword">int</span> R  )</span></span>&#123; <span class="comment">//快速排序，L、R 此堆的左邊界、右邊界</span></span><br><span class="line">    <span class="keyword">if</span>(L &gt; R) <span class="keyword">return</span> ; <span class="comment">//如果 L &gt; R 表示這邊沒有數堆</span></span><br><span class="line">    <span class="comment">//standard 分堆的標準， l，r 當前數堆的左邊界、右邊界</span></span><br><span class="line">    <span class="keyword">int</span> standard = num[L] , l = L , r = R+<span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123; </span><br><span class="line">        <span class="comment">//如果左邊界的數值，比 standard 大就跳出迴圈，因為我們找到要交換的 l，注意左右指針不可相遇 </span></span><br><span class="line">        <span class="keyword">while</span>(standard &gt; num[++l] &amp;&amp; R &gt; l  ); </span><br><span class="line">        <span class="comment">//如果右邊界的數值，比 standard 大就跳出迴圈，因為我們找到要交換的 r，注意左右指針不可相遇 </span></span><br><span class="line">        <span class="keyword">while</span>(standard &lt; num[--r] &amp;&amp; L &lt; r );</span><br><span class="line">        <span class="keyword">if</span>(l &gt;= r ) <span class="keyword">break</span>; <span class="comment">//如果左右指針相遇就離開迴圈</span></span><br><span class="line">        swap(num[l] , num[r]); <span class="comment">//對我們找到的 l 與 r 進行交換</span></span><br><span class="line">        output();</span><br><span class="line">    &#125;</span><br><span class="line">    swap(num[L] , num[r]); <span class="comment">//我們會發現 num[L] 就是 standard，我們要將他換到兩數堆的中間，</span></span><br><span class="line">    <span class="comment">//也就是兩堆數值的交界點</span></span><br><span class="line">    output(); <span class="comment">//輸出排序</span></span><br><span class="line">    quick_sort( L , r<span class="number">-1</span> ); <span class="comment">//將左數堆進行 quick_sort</span></span><br><span class="line">    quick_sort( r+<span class="number">1</span> , R); <span class="comment">//將右數堆進行 quick_sort</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    num_size = <span class="keyword">sizeof</span>(num) / <span class="keyword">sizeof</span>(num[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    output();</span><br><span class="line">    quick_sort(<span class="number">0</span>, num_size<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>由於 C++ 已經有很多 sort 套件了，因此我在高中學會後我就再也沒有去複習這些知識。</p>
<p>剛好現在上課有用到那就來複習，順便把它寫出邏輯八！</p>
<h2 id="程式執行結果"><a href="#程式執行結果" class="headerlink" title="程式執行結果"></a>程式執行結果</h2><blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1kt6hLJ5CwQDML1FJf1-eysbnLBbaNThr&export=download" alt=""></p>
</blockquote>
]]></content>
      <categories>
        <category>演算法知識</category>
      </categories>
      <tags>
        <tag>程式解題</tag>
        <tag>演算法知識</tag>
        <tag>數論 Math theorm</tag>
        <tag>快速排序 quick sort</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa12190 - Electric Bill(Binary Search 二分搜尋 )</title>
    <url>/2021/05/24/UVa/UVa12190/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>在 2100 年，電變得非常昂貴，電力公司的累進費率如下</p>
<ul>
<li>1~10CHw 2元</li>
<li>101~10000 3元</li>
<li>10001~1000000 5元</li>
<li>1000000 7元</li>
</ul>
<p>電力公司為了賺更多錢想出一種方法，電力公司會給你 A、B 兩個數字，其中</p>
<ul>
<li>A 是你的用電量與鄰居用電量的總和，如果合在一起的電費帳單</li>
<li>B 是你的電費與鄰居電費的差額</li>
</ul>
<p>如果想知道自己的電費，則必須付給電力公司計算費，但你想要省下這筆錢，所以來寫程式計算八！<br>我們可以保證的是，我們一定比鄰居的用電量還少！<br>注意：在這題中，每組題目都答案只會有一組解。不必擔心多組解問題</p>
<p><a href="https://onlinejudge.org/external/121/12190.pdf" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li>如何計算電費</li>
<li>如何找出 鄰居、你 的用電量</li>
<li>想到使用二分搜尋來找出鄰居、你的用電量</li>
<li>在有兩種未知數，並且有一定的線性規律時可以透過二分搜尋來確認此未知數。</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>我們可以透過一些簡單的數學公式找出一些邏輯，定義我的帳單是 billA 用電量為 chwA、鄰居的帳單是 billB、用電量是 chwB。<br>加上題目 A、B </p>
<ul>
<li>用 A 推出 (chwA + chwB)，總和的電費我們稱為 chwAll</li>
<li>再來我們要如何推出我們的電費、鄰居的電費呢？</li>
</ul>
<p>由於我們知道 B，但是現在我們還是有兩個未知數 chwA、chwB 阿，我們總不能夠用 <code>for(int chwA = 0; i &lt; chwAll; i++)</code>，再讓 chwAll - chwA 推出 chwB 後，再用 chwA、chwB 計算帳單費用，比較差額是否與 B 相同。</p>
<p>但是我們可以做些小優化，我們知道，如果 chwA、chwB 越相近，則電費差額會越低，如果越遠則電費差額會越高。<br>那我們原本是用 for 一個一個慢慢找，可不可以改成用二分搜尋，只要電費差額 &gt; B，我們就讓鄰居跟我們的電費差額變小，直到完全一樣。<br>如果電費差額 &lt; B，那我們就讓電費差額變大，直到完全一樣。</p>
<p>當然，偶爾會有變大又變小的時候，畢竟二分搜尋有可能不小心變更大嘛。</p>
<p>如果不懂二分搜尋，可以參考此文章<a href="https://theriseofdavid.github.io/2020/11/15/Explain_Algorithm/binary_search/" target="_blank" rel="noopener">演算法知識 - Binary Search 二分搜尋 by 大衛的筆記</a></p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://hackmd.io/@txya900619/Uva12190" target="_blank" rel="noopener">Uva12190 - Electric Bill by txya900619</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>QQ，我再搞清楚這題為甚麼要用二分搜尋時花了一堆時間…，有時候想要用數學去推論一題的 UVa 並不是那麼容易的事情呀，唉。</p>
<p>現在大概清楚，在哪些狀況怎麼做比較好！</p>
<p>我的功力還不足，還需要繼續努力。</p>
<p>還有就是，我的英文真的好菜阿！需要找時間好好多準備英文單字，讓自己的英文能力變得更強，閱讀更快！</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN_quota = <span class="number">1e18</span>; <span class="comment">//最終的額度，由於題目限度是 1e9</span></span><br><span class="line"><span class="keyword">int</span> price[] = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>&#125;; <span class="comment">//電的價格分類</span></span><br><span class="line"><span class="keyword">int</span> quota[] = &#123;<span class="number">100</span>,<span class="number">9900</span>,<span class="number">990000</span>, MAXN_quota&#125;; <span class="comment">//電的額度分類</span></span><br><span class="line"><span class="keyword">int</span> a, b;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bill_convert_to_cwh</span><span class="params">(<span class="keyword">int</span> bill)</span></span>&#123; <span class="comment">//電價轉換成用電量</span></span><br><span class="line">    <span class="keyword">int</span> chw = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123; </span><br><span class="line">        <span class="keyword">if</span>(bill &gt; <span class="number">0</span>)&#123; <span class="comment">//如果帳單還沒有歸零</span></span><br><span class="line">            <span class="comment">//判斷在當前的價格中，是剩下的帳單費用 / 當前價格是否有將額度用完，</span></span><br><span class="line">            <span class="comment">//如果有，那讓用電家 += 額度</span></span><br><span class="line">            <span class="comment">//如果沒，就讓用電量 += 帳單費用 / 當前用電量</span></span><br><span class="line">            chw += min(bill/price[i], quota[i]); <span class="comment">//紀錄在這個費用下，增加多少的用電量</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//帳單扣掉在此額度下用掉的費用</span></span><br><span class="line">            bill -= min(bill/price[i], quota[i]) * price[i];  </span><br><span class="line">            <span class="comment">//cout &lt;&lt; "now_bill " &lt;&lt; bill &lt;&lt; '\n';</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> chw; <span class="comment">//回傳用電量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chw_convert_to_bill</span><span class="params">(<span class="keyword">int</span> chw)</span></span>&#123; <span class="comment">//用電量轉換帳單</span></span><br><span class="line">    <span class="keyword">int</span> bill = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(chw &gt; <span class="number">0</span>)&#123; <span class="comment">//還有用電量</span></span><br><span class="line">            <span class="comment">//判斷在當前的價格中，是剩下的用電量是否有將額度用完，</span></span><br><span class="line">            <span class="comment">//如果有，那讓價格 * 額度</span></span><br><span class="line">            <span class="comment">//如果沒，就讓用電量 * 額度</span></span><br><span class="line">            bill += min(chw, quota[i]) * price[i]; </span><br><span class="line"></span><br><span class="line">            <span class="comment">//用電量扣掉在此額度下用掉的電量</span></span><br><span class="line">            chw -= min(chw, quota[i]);</span><br><span class="line">            <span class="comment">//cout &lt;&lt; "now_chw " &lt;&lt; chw &lt;&lt; '\n';</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bill; <span class="comment">//回傳電量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果不懂，可以看 演算法知識 - Binary Search 二分搜尋 by 大衛的筆記，在分析的最下方。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_serach</span><span class="params">(<span class="keyword">int</span> chw)</span></span>&#123; <span class="comment">//二分搜尋，找出 billB - billA = B</span></span><br><span class="line">    <span class="keyword">int</span> billA, billB;</span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">0</span>, right=chw; <span class="comment">//chw 總用電量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(right &gt; left)&#123; <span class="comment">//二分搜尋</span></span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        billA = chw_convert_to_bill(mid); </span><br><span class="line">        billB = chw_convert_to_bill(chw - mid);</span><br><span class="line">        <span class="comment">//cout &lt;&lt; "bill " &lt;&lt; billA &lt;&lt; ' ' &lt;&lt; billB &lt;&lt; '\n';</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> diff = billB - billA; <span class="comment">//找出差額</span></span><br><span class="line">        <span class="keyword">if</span>(diff == b) <span class="keyword">break</span>; <span class="comment">//如果差額 == b，表示找到答案</span></span><br><span class="line">        <span class="keyword">if</span>(diff &lt; b) right = mid; <span class="comment">//如果差額小於 b，則表示要找右區間、擴大差額</span></span><br><span class="line">        <span class="keyword">if</span>(diff &gt; b) left = mid+<span class="number">1</span>; <span class="comment">//如果差額大於 b，則表示要找左區間、縮小差額</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> billA; <span class="comment">//回傳帳單</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"out.txt"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">int</span> chwAll, chwA;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &amp;&amp; a+b != <span class="number">0</span>)&#123;</span><br><span class="line">        chwAll = bill_convert_to_cwh(a); <span class="comment">//找出總店輛</span></span><br><span class="line">        <span class="comment">//cout &lt;&lt; chwAll &lt;&lt; '\n';</span></span><br><span class="line">        <span class="keyword">int</span> chwA = binary_serach(chwAll); <span class="comment">//進行二分搜尋</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; chwA &lt;&lt; <span class="string">'\n'</span>; <span class="comment">//輸出我們的用電量</span></span><br><span class="line">        <span class="comment">//cout &lt;&lt; chw_convert_to_bill(chwA) &lt;&lt; '\n';</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>Binary Search 二分搜尋</tag>
      </tags>
  </entry>
  <entry>
    <title>演算法知識 - 合併排序 merge sort</title>
    <url>/2021/05/24/Explain_Algorithm/merge_sort/</url>
    <content><![CDATA[<h2 id="合併排序-merge-sort-介紹與實作原理"><a href="#合併排序-merge-sort-介紹與實作原理" class="headerlink" title="合併排序 merge sort 介紹與實作原理"></a>合併排序 merge sort 介紹與實作原理</h2><blockquote>
<p>合併排序主要是透過 divide 的方式將每一個數列不斷分割成兩數堆(將數列進行分割)，平均時間複雜度為 \(O(n log n\)，是目前時間穩定、效率優質的演算法之一。<br>也是目前大家會選擇的排序演算法之一。</p>
<p>實作原理如下：</p>
<ul>
<li>以下舉例是由小到大</li>
<li>準備一個暫存的數列 temp</li>
<li>先不斷進行遞迴，將數列分割成兩個子數列</li>
<li>處理程序：<ul>
<li>如果不能夠再分割，直接回傳數字</li>
<li>將先前遞迴好的兩子數列，定義 A、B，分別給於這兩個子數列一個指針，定義 start_l、start_r</li>
<li>將 start_l、start_r 指針指定的數字進行比較，如果 start_l 比較小就放入 temp，並將 start_;+1，反之 start_r 比較小就反入 temp，並將 start_r+1，</li>
<li>上面此點主要是將兩個已經排序好的子數列，再依照順序放入 temp 中，因為我們可以知道 A、B 一開始一定是最小的數值，後面都是更大的數值，所以我們可以透過此操作來進行優化</li>
<li>如果已經有一邊的子數列用完，而另一邊沒有用完，則將剩下的另一邊依照順序放入 temp</li>
<li>之後將 temp 的數列放回原本的數列</li>
</ul>
</li>
</ul>
<p>最後就可以輸出答案！ </p>
</blockquote>
<a id="more"></a>

<h2 id="參考來源"><a href="#參考來源" class="headerlink" title="參考來源"></a>參考來源</h2><p><a href="https://zh.wikipedia.org/wiki/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">合併排序 by wiki</a></p>
<h2 id="合併排序-merge-sort-程式碼說明與應用"><a href="#合併排序-merge-sort-程式碼說明與應用" class="headerlink" title="合併排序 merge sort 程式碼說明與應用"></a>合併排序 merge sort 程式碼說明與應用</h2><p>透過程式碼來進行說明相信會更好理解，以下我們示範從小到大排序</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span>;</span><br><span class="line"><span class="keyword">int</span> num[] = &#123;<span class="number">4</span>,<span class="number">96</span>,<span class="number">1546</span>,<span class="number">13</span>,<span class="number">48</span>,<span class="number">34</span>,<span class="number">77</span>,<span class="number">48</span>,<span class="number">31</span>&#125;; <span class="comment">//要排序的數字</span></span><br><span class="line"><span class="keyword">int</span> temp[MAXN]; <span class="comment">//暫存用</span></span><br><span class="line"><span class="keyword">int</span> num_size; <span class="comment">//要排序的數字大小</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">()</span></span>&#123; <span class="comment">//輸出排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; num_size ; i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; num[i] &lt;&lt; <span class="string">' '</span> ;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span>&#123; <span class="comment">//進行合併搜尋</span></span><br><span class="line">    <span class="keyword">if</span>(L &gt;= R) <span class="keyword">return</span> ; <span class="comment">//表示沒有子數列，所以 return</span></span><br><span class="line">    <span class="comment">//m 表示兩邊的分割點</span></span><br><span class="line">    <span class="keyword">int</span> m=(L+R)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> start_l = L, end_l = m; <span class="comment">//start_l 為指針，end_l 為子數列的長度</span></span><br><span class="line">    <span class="keyword">int</span> start_r = m+<span class="number">1</span>, end_r = R; <span class="comment">//與上方相同</span></span><br><span class="line"></span><br><span class="line">    merge_sort(start_l, end_l); <span class="comment">//將左子數列進行 merge_sort</span></span><br><span class="line">    merge_sort(start_r, end_r); <span class="comment">//與上方相同</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> index = l; <span class="comment">//我們用於紀錄 temp 資料放入哪些哪邊</span></span><br><span class="line">    <span class="keyword">while</span>(start_l &lt;= end_l &amp;&amp; start_r &lt;= end_r) <span class="comment">//如果 A、B 兩數列的指針並還沒到子數列的最大長度</span></span><br><span class="line">        <span class="comment">//判斷是 start_l 此指針的數值是否有比 start_r 小，如果有，</span></span><br><span class="line">        <span class="comment">//則將 start_l 指針的值放入 temp，並讓 start_l+1，反之亦同</span></span><br><span class="line">        <span class="comment">//注意：這邊有很多++ 的動作請進行留意</span></span><br><span class="line">        temp[index++] = num[start_l] &lt; num[start_r] ? num[start_l++] : num[start_r++];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果 A 數列還沒用完，就將 A 數列的值依序放入 temp，判斷的標準則是 start_l 是否已經到 end_l，下方相同</span></span><br><span class="line">    <span class="keyword">while</span>(start_l &lt;= end_l) temp[index++] = num[start_l++]; </span><br><span class="line">    <span class="keyword">while</span>(start_r &lt;= end_r) temp[index++] = num[start_r++];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//將這次 merge_sort 好的值放入原本的 num，因為我們是要對 num 進行排序，而非 temp</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = L; i &lt;= R; i++) num[i] = temp[i]; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    num_size = <span class="keyword">sizeof</span>(num) / <span class="keyword">sizeof</span>(num[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    merge_sort(<span class="number">0</span>, num_size<span class="number">-1</span>);</span><br><span class="line">    output(); <span class="comment">//輸出答案</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>由於 C++ 已經有很多 sort 套件了，因此我在高中學會後我就再也沒有去複習這些知識。</p>
<p>剛好現在上課有用到那就來複習，順便把它寫出邏輯八！</p>
<h2 id="程式執行結果"><a href="#程式執行結果" class="headerlink" title="程式執行結果"></a>程式執行結果</h2><blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1z3BiITZyFRgY03M8Eg5tZq022YIpBDib&export=download" alt=""></p>
</blockquote>
]]></content>
      <categories>
        <category>演算法知識</category>
      </categories>
      <tags>
        <tag>程式解題</tag>
        <tag>演算法知識</tag>
        <tag>合併排序 merge sort</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa11052 - Economic phone calls(動態規劃 Dynamic programming )</title>
    <url>/2021/05/24/UVa/UVa11052/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>我有一台很老的手機，他的 RAM 並不大，最近我們遇上了 RAM 用滿的問題，我們現在必須刪除一些電話紀錄，但有一些規則要遵守</p>
<ul>
<li>最後一次電話紀錄一定是今年的紀錄</li>
<li>格式為 <code>mm:dd:HH:MM phone +\-</code>，前面為時間，電話名稱，是否為重要紀錄</li>
<li>我們只能夠刪除非重要紀錄</li>
<li>手機並不會記錄年份，因此我們判斷年份是使用相對時間，也就是如果前一筆的時間 &lt; 下一筆的時間，我們可以定義這兩筆資料在同年份；如果前一筆的時間 &gt;= 下一筆的時間 我們則定義這兩筆資料的年份不一樣，前一筆的資料年份比較遠、後一筆資料年份比較近。</li>
<li>我們可以透過上一點來判斷年份，也就是每年至少都要用一筆資料。</li>
</ul>
<p>請告訴我們最少需要保存幾個資料，就可以將重要資料全部保存並且可以判斷每通紀錄的年份。</p>
<p><a href="https://onlinejudge.org/external/110/11052.pdf" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li>動態規劃的時機 (當資料並不能延續狀態，而是會需要前面資料輔助時就用動態規劃)</li>
<li>了解時間可以用字串比較</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>這題是我認為算是非常麻煩的問題，我學習他花了將近 4 小時。</p>
<p>由於我們要保存最少的資料，但完整性、一樣能辨識年份，我們主要會遇到一些困難點</p>
<ul>
<li>找出最後一年的重要紀錄，如果沒有就直接隨便找一筆紀錄</li>
<li>假如兩筆重要紀錄分別是 2001, 2003 年，那我們要留下 2002 的<strong>一筆</strong>不重要紀錄</li>
<li>舉例如下，那我們是不是這三筆資料都必須留下，否則年份辨識不正確<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">01:10:11 1234 + </span><br><span class="line">01:02:23 2345 -</span><br><span class="line">01:12:11 3456 +</span><br></pre></td></tr></table></figure></li>
<li>所有的重要紀錄都必須被留下</li>
</ul>
<p>根據這些困難點，會發現如果我們使用 greedy 會很難寫，因為例如第三點的情況，我們的 greedy 就必須根據過去資料去判斷，如果第一筆資料與第二筆資料中間又塞入很多的非重要紀錄那就更麻煩了。</p>
<p>因此這邊我們就使用可以提取過去資料與當前資料判斷的動態規劃。</p>
<p>主要的動態規劃則是</p>
<ul>
<li><code>dp[i]</code> 保留至第 i 個紀錄中最少要保存幾個紀錄</li>
<li><code>在重要紀錄中的那些不重要紀錄我只紀錄一筆</code>，<code>dp[i] = min(dp[i], dp[j]+1、i &lt; j &lt; n，j 表示同年份的資料</code>，如果直接提取 <code>dp[j]+1</code>，+1 則是紀錄 i</li>
<li>如果碰到重要紀錄，則直接跳出 <code>for j</code> 迴圈，因為重要紀錄不可省略</li>
</ul>
<p>主要架構如上述所說，如果有些不清楚則建議查看下方<a href="#題目程式碼">題目程式碼</a></p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://hackmd.io/@txya900619/Uva11052" target="_blank" rel="noopener">Uva11052 - Economic phone calls by txya900619</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>這題好難QQQ，而且好複雜！ 我原本是想要用 greedy 去做，做到一半才發現第三點用 greedy 去做並不好做。</p>
<p>但是也沒有想到 dp 要怎麼做比較好，就看力瑋的程式碼，不斷思考怎麼運作，後來詢問力瑋程式碼意思才逐漸開竅。</p>
<p>能想出這份程式碼的人真的太聰明了，我的缺點是遇到太多大問題時不擅長拆解，但我擅長將小問題解決，可能跟我的個性有關吧，喜歡注重細節，但常常忽略大局。</p>
<p>總之，中庸之道我也需要攝取攝取。<br>但我想要成為一位優秀的人，住在漂亮的房子、給小孩好的教育，幸福的人生。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1020</span>;</span><br><span class="line"><span class="keyword">int</span> n, dp[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">record</span>&#123;</span> <span class="comment">//用於記錄每筆資訊</span></span><br><span class="line">    <span class="built_in">string</span> time, phone, mark;</span><br><span class="line">    <span class="keyword">int</span> year;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//constructor </span></span><br><span class="line">    record(<span class="built_in">string</span> _time, <span class="built_in">string</span> _phone, <span class="built_in">string</span> _mark, <span class="keyword">int</span> _year)&#123;</span><br><span class="line">        time = _time;</span><br><span class="line">        phone = _phone;</span><br><span class="line">        mark = _mark;</span><br><span class="line">        year = _year;</span><br><span class="line">    &#125;;</span><br><span class="line">    record(): time(<span class="string">""</span>), phone(<span class="string">""</span>), mark(<span class="string">""</span>), year(<span class="number">0</span>)&#123;&#125; <span class="comment">//一開 year 始預設為 0</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">deque</span>&lt;record&gt; info; <span class="comment">//用於紀錄題目每筆紀錄</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">()</span></span>&#123; <span class="comment">//debug 無意義</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; info[i].time &lt;&lt; <span class="string">' '</span> &lt;&lt; info[i].phone &lt;&lt; <span class="string">' '</span> &lt;&lt; info[i].mark &lt;&lt; <span class="string">' '</span> &lt;&lt; info[i].year &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="comment">//freopen("out.txt", "w", stdout);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n &amp;&amp; n)&#123; <span class="comment">//輸入資料</span></span><br><span class="line">        <span class="built_in">string</span> time, phone, mark;</span><br><span class="line">        info.clear(); <span class="comment">//清空，避免影響到其他測資</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123; <span class="comment">//輸入資料</span></span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; time &gt;&gt; phone &gt;&gt; mark;</span><br><span class="line">            info.push_back( record(time, phone, mark, <span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> year = <span class="number">0</span>; <span class="comment">//先對題目的資料做辨識年份</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(info[i].time &lt;= info[i<span class="number">-1</span>].time) info[i].year = ++year; <span class="comment">//年份不同， year 因此加一</span></span><br><span class="line">            <span class="keyword">else</span> info[i].year = year;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//debug();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//first_mark 為年份最久的重要記錄，因為在遠的紀錄我們不須留下</span></span><br><span class="line">        <span class="comment">// flag 判斷是否已經讀取到年份最新的重要紀錄</span></span><br><span class="line">        <span class="comment">//last_mark 年份最新的重要紀錄</span></span><br><span class="line">        <span class="keyword">int</span> first_mark = n, flag = <span class="number">1</span>, last_mark;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(info[i].mark == <span class="string">"+"</span>) first_mark = i; <span class="comment">//最後一次讀取就是年份最久的重要紀錄</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//我們必須把最新的年份直到出現今年的重要紀錄時都讓 dp[i] = 1，</span></span><br><span class="line">            <span class="comment">//因為這些紀錄，我們只需要紀錄一筆即可</span></span><br><span class="line">            dp[i] = flag &amp;&amp; info[i].year == year ? <span class="number">1</span> : n-i; </span><br><span class="line">            <span class="keyword">if</span>(flag &amp;&amp; (info[i].mark == <span class="string">"+"</span> || info[i].year != year))&#123; <span class="comment">//更新最近紀錄</span></span><br><span class="line">                flag = <span class="number">0</span>;</span><br><span class="line">                last_mark = i;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//dp 動態規劃，由最近年份至最遠年份</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = last_mark; i &gt;= first_mark; i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; n; j++)&#123; <span class="comment">//不斷的往最近年份推</span></span><br><span class="line">                <span class="comment">//由於我們動態規劃的核心是想要做成 重要紀錄、一筆非重要紀錄、重要紀錄</span></span><br><span class="line">                <span class="comment">//重要紀錄、非重要紀錄，視為一個區塊</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//但中間的一筆非重要紀錄，不一定只有一筆，所以我們就透過下方 if 來 dp</span></span><br><span class="line">                <span class="comment">//我們選擇*哪一個*非重要紀錄可以讓我們的 dp[i] 最小，下方的 dp[j] 則是上一個區塊，我們從上一個區塊中哪一個 dp[j] 可以使 dp[i] 最小</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//如果年份相同 or (前一年的資料，但離第 i 份資料不差超過一年)</span></span><br><span class="line">                <span class="keyword">if</span>(info[i].year == info[j].year || \</span><br><span class="line">                   (info[i].year + <span class="number">1</span> == info[j].year &amp;&amp; info[i].time &gt;= info[j].time))</span><br><span class="line">                    <span class="comment">//判斷 dp[i] 的資料是否比較少 or 省略 j~i 的紀錄，直接 dp[j]+1 誰少</span></span><br><span class="line">                    dp[i] = min(dp[i], dp[j]+<span class="number">1</span>); </span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>; <span class="comment">//當前區塊結束，跳出迴圈，原因是並非同區塊的資料</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(info[j].mark == <span class="string">"+"</span>) <span class="keyword">break</span>; <span class="comment">//當前區塊結束，跳出迴圈，原因是遇到重要紀錄</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//for(int i = 0; i &lt; n; i++) cout &lt;&lt; dp[i] &lt;&lt; ' ';</span></span><br><span class="line">        <span class="comment">//cout &lt;&lt; '\n';</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; dp[first_mark] &lt;&lt; <span class="string">'\n'</span>; <span class="comment">//輸出保留至第一個紀錄中最少要保存幾個紀錄</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>動態規劃 Dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title>統計學(一) 筆記 - 第四章</title>
    <url>/2020/10/27/statistics/statistcs-ch4A/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊與財金管理系大二上統計學重點整理<br><font color="#dd0000">並非所有人都適用，部分對我而言稍加容易的內容並不會寫在此內。</font><br><strong>這是觀看影片心得後的筆記，老師上課可能不太適用會忘記抄到</strong></p>
</blockquote>
<a id="more"></a>

<h2 id="4A-介紹-Introduction-to-Probability-機率導論"><a href="#4A-介紹-Introduction-to-Probability-機率導論" class="headerlink" title="4A 介紹 - Introduction to Probability(機率導論)"></a>4A 介紹 - Introduction to Probability(機率導論)</h2><p>一共介紹</p>
<ul>
<li>Random Experiments(隨機時間)、Counting Rules(技術法則)、Assigning Probabilities(指派機率)</li>
<li>Event and Their Probability(事件與事件機率)</li>
<li>Bayes’ Theorem </li>
<li>Conditional Probability(條件機率)</li>
</ul>
<h3 id="Probability-機率值"><a href="#Probability-機率值" class="headerlink" title="Probability 機率值"></a>Probability 機率值</h3><ul>
<li>當機率越接近 \(1\) 表示發生越高，接近\(0\) 則代表發生機率越低</li>
</ul>
<h3 id="Statistcal-Experiments-統計實驗"><a href="#Statistcal-Experiments-統計實驗" class="headerlink" title="Statistcal Experiments(統計實驗)"></a>Statistcal Experiments(統計實驗)</h3><p>我們知道他的結果發生可能，但我們沒辦法知道下次的結果是甚麼。</p>
<ul>
<li>Random Experiment(隨機實驗)<br>可以清楚知道他的實驗結果可能</li>
<li>Sample Space(樣本空間)<br>此實驗所有可能性結果的集合</li>
<li>Sample Point(樣本點)<br><strong>這一次</strong>實驗發生的結果</li>
</ul>
<h3 id="Counting-Rule-for-Multiple-Step-Experiments-多重步驟實驗"><a href="#Counting-Rule-for-Multiple-Step-Experiments-多重步驟實驗" class="headerlink" title="Counting Rule for Multiple-Step Experiments(多重步驟實驗)"></a>Counting Rule for Multiple-Step Experiments(多重步驟實驗)</h3><p>簡單說就是用 \(C_{n}^{m}\) or \(P_{n}^{m} \) 的應用。</p>
<h3 id="Assigning-Probabilities-指派結果"><a href="#Assigning-Probabilities-指派結果" class="headerlink" title="Assigning Probabilities(指派結果)"></a>Assigning Probabilities(指派結果)</h3><ul>
<li>實驗結果機率必須介在\(0~1\)之間，\(E_{i}\)為第幾次的結果。</li>
<li>假如有 n 種不同的實驗結果，加總起來必等於 \(1\)</li>
</ul>
<h4 id="Classical-Method-古典法"><a href="#Classical-Method-古典法" class="headerlink" title="Classical Method(古典法)"></a>Classical Method(古典法)</h4><p>每一個實驗結果發生可能性都相同時使用，每一個 sample point 機率都是 \(\frac{1}{n}\)。</p>
<h4 id="Relative-Frequency-Method-相對次數法"><a href="#Relative-Frequency-Method-相對次數法" class="headerlink" title="Relative Frequency Method(相對次數法)"></a>Relative Frequency Method(相對次數法)</h4><p>根據實驗結果的歷史資料來決定機率多少，設實驗總次數為 n，x 實驗結果為 y，則機率是\(\frac{y}{n}\。</p>
<h4 id="Subjective-Method-主觀法"><a href="#Subjective-Method-主觀法" class="headerlink" title="Subjective Method(主觀法)"></a>Subjective Method(主觀法)</h4><p>用主觀判斷、經驗來判斷機率。<br><strong>有資料一定要盡量引用資料</strong></p>
<h3 id="Event-and-Their-Probability-事件與事件機率"><a href="#Event-and-Their-Probability-事件與事件機率" class="headerlink" title="Event and Their Probability(事件與事件機率)"></a>Event and Their Probability(事件與事件機率)</h3><p>在實驗裡面找出所有樣本點並對所有的樣本點指出機率，就可以找出此實驗的機率。</p>
<h4 id="Some-Relationships-of-Probability"><a href="#Some-Relationships-of-Probability" class="headerlink" title="Some Relationships of Probability"></a>Some Relationships of Probability</h4><ul>
<li>\(A^c\) Complement(餘集)</li>
<li>\(A \cup B \) Union(聯集)</li>
<li>Mutually Exclusive Event(互斥)，即 \(P(A \cup B) = 0 \)</li>
</ul>
<h3 id="Conditional-Probability-條件機率"><a href="#Conditional-Probability-條件機率" class="headerlink" title="Conditional Probability(條件機率)"></a>Conditional Probability(條件機率)</h3><p>在 B 已發生的情況中 A 發生的情況機率是多少，數學符號則是用 \(P(A|B) \)，公式則是 <br>(P(A|B) = \frac{P(A \cap B)}{P(B)}\)</p>
<ul>
<li>Multiplication Law(乘法律)<br>\(P(A \cup B) = P(B)P(A|B) \) or \(P(A \cup B) = P(A)P(B|A) \)</li>
</ul>
<h3 id="Independent-Events-獨立事件"><a href="#Independent-Events-獨立事件" class="headerlink" title="Independent Events(獨立事件)"></a>Independent Events(獨立事件)</h3><p>A 事件發生跟 B 事件會不會發生無關，反之也是。<br>用邏輯式來說就是 \(P(A|B) = P(A) \) or \(P(B|A) = P(B) \)</p>
<h3 id="Mutual-Exclusiveness-and-Independence-互斥事件"><a href="#Mutual-Exclusiveness-and-Independence-互斥事件" class="headerlink" title="Mutual Exclusiveness and Independence(互斥事件)"></a>Mutual Exclusiveness and Independence(互斥事件)</h3><p>假如 A 發生則 B 不發生，反之也是，但因為他們有反向關係，所以他們有相依關係。</p>
<h3 id="Bayes’-Theorem-貝氏定理"><a href="#Bayes’-Theorem-貝氏定理" class="headerlink" title="Bayes’ Theorem (貝氏定理)"></a>Bayes’ Theorem (貝氏定理)</h3><p>在已知的一些條件下，某事件的發生機率。</p>
<h4 id="Bayes’-Theorem-貝氏定理-公式"><a href="#Bayes’-Theorem-貝氏定理-公式" class="headerlink" title="Bayes’ Theorem (貝氏定理) 公式"></a>Bayes’ Theorem (貝氏定理) 公式</h4><blockquote>
<p><img src="/images/statistics-ch4A/2.PNG" alt=""></p>
</blockquote>
<h4 id="Example-A"><a href="#Example-A" class="headerlink" title="Example A"></a>Example A</h4><p>\(A_1 = True = 0.7 \), \(A_2 = False = 0.3 \)<br>\(P(B|A_1) = 0.2 \) and \(P(B|A_2) = 0.9 \)</p>
<h5 id="Hence"><a href="#Hence" class="headerlink" title="Hence"></a>Hence</h5><p>\(P(B^c|A_1) = 0.2 \) and \(P(B|A_2) = 0.9 \)<br>\(P(B|A_1) = 0.8 \) and \(P(B^c|A_2) = 0.1 \)</p>
<blockquote>
<p><img src="/images/statistics-ch4A/1.PNG" alt=""></p>
</blockquote>
<h5 id="Example-apply-Bayes’-Theorem"><a href="#Example-apply-Bayes’-Theorem" class="headerlink" title="Example apply Bayes’ Theorem"></a>Example apply Bayes’ Theorem</h5><blockquote>
<p><img src="/images/statistics-ch4A/3.PNG" alt=""></p>
</blockquote>
<h5 id="表格表示貝氏定理與結論"><a href="#表格表示貝氏定理與結論" class="headerlink" title="表格表示貝氏定理與結論"></a>表格表示貝氏定理與結論</h5><blockquote>
<p><img src="/images/statistics-ch4A/4.PNG" alt=""></p>
</blockquote>
<h5 id="Example-B"><a href="#Example-B" class="headerlink" title="Example B"></a>Example B</h5><p>\(A_1\) 與 \(A_2\) 是互斥事件</p>
<blockquote>
<p><img src="/images/statistics-ch4A/6.PNG" alt=""></p>
</blockquote>
]]></content>
      <categories>
        <category>北科上課筆記</category>
        <category>統計 statistics</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>統計學筆記</tag>
        <tag>北科大二上統計學筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>統計學(一) 筆記 - 第三章B</title>
    <url>/2020/10/15/statistics/statistcs-ch3B/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊與財金管理系大二上統計學重點整理<br><font color="#dd0000">並非所有人都適用，部分對我而言稍加容易的內容並不會寫在此內。</font><br><strong>這是觀看影片心得後的筆記，老師上課可能不太適用會忘記抄到</strong></p>
</blockquote>
<a id="more"></a>

<h2 id="3B-介紹-Descriptive-Statistics-Numerical-Measures-數值方式"><a href="#3B-介紹-Descriptive-Statistics-Numerical-Measures-數值方式" class="headerlink" title="3B 介紹 - Descriptive Statistics: Numerical Measures(數值方式)"></a>3B 介紹 - Descriptive Statistics: Numerical Measures(數值方式)</h2><p>敘述統計,too。</p>
<h3 id="Measures-of-Distribution-Shape-分配形狀度量"><a href="#Measures-of-Distribution-Shape-分配形狀度量" class="headerlink" title="Measures of Distribution Shape 分配形狀度量"></a>Measures of Distribution Shape 分配形狀度量</h3><h4 id="Skewness-偏態"><a href="#Skewness-偏態" class="headerlink" title="Skewness 偏態"></a>Skewness 偏態</h4><p>公式如下:</p>
<blockquote>
<p><img src="/images/statistics-ch3B/1.PNG" alt=""></p>
</blockquote>
<p>如果圖片剛好是具有左右對稱性則 \(Skewness = 0 \)，往右偏則 \(Skewness &gt; 0 \) ，往左偏則是 \(Skewness &lt; 0 \)，負數表如下圖：</p>
<blockquote>
<p><img src="/images/statistics-ch3B/2.PNG" alt=""></p>
</blockquote>
<ul>
<li>Highly Skewed Right<br>右偏 &gt; 1，通常平均數會比中位數來的更高。</li>
<li>關於 Skewness 的平均數、中位數的比較如下：<blockquote>
<p><img src="/images/statistics-ch3B/3.PNG" alt=""></p>
</blockquote>
</li>
</ul>
<h5 id="QUESTION-左偏的意思是甚麼？"><a href="#QUESTION-左偏的意思是甚麼？" class="headerlink" title="QUESTION: 左偏的意思是甚麼？"></a>QUESTION: 左偏的意思是甚麼？</h5><p>就是左邊的資料比較少，重心在右邊則叫左偏。</p>
<h4 id="Z-Scores-Z-分數"><a href="#Z-Scores-Z-分數" class="headerlink" title="Z-Scores Z 分數"></a>Z-Scores Z 分數</h4><p>某一數值離母體平均值差幾個標準差，標準差公式如下：</p>
<blockquote>
<p><img src="/images/statistics-ch3B/4.PNG" alt=""></p>
</blockquote>
<ul>
<li>Z-Score &gt; 0 表示數值比平均數大，Z-Score 則代表離幾個標準差遠</li>
<li>Z-Score &lt; 0 表示數值比平均數小，Z-Score 則代表離幾個標準差遠</li>
</ul>
<h4 id="Chebyshev’s-Theorem-柴比雪夫定理"><a href="#Chebyshev’s-Theorem-柴比雪夫定理" class="headerlink" title="Chebyshev’s Theorem 柴比雪夫定理"></a>Chebyshev’s Theorem 柴比雪夫定理</h4><p>用於知道資料分布位置，<strong>用心看圖片裡面文字XD</strong>。</p>
<blockquote>
<p><img src="/images/statistics-ch3B/5.PNG" alt=""></p>
</blockquote>
<h5 id="Chebyshev’s-Theorem-舉例"><a href="#Chebyshev’s-Theorem-舉例" class="headerlink" title="Chebyshev’s Theorem 舉例"></a>Chebyshev’s Theorem 舉例</h5><blockquote>
<p><img src="/images/statistics-ch3B/6.PNG" alt=""></p>
</blockquote>
<p>可以得知 Chebyshev’s Theorem 預估有 509 ~ 673 裡面有百分之 56% 的資料，但事實上有 86% 的資料在 509 ~ 673 之間，Chebyshev’s Theorem 屬於比較保守的知道資料分布位置。</p>
<h4 id="Empirical-Rule-經驗法則"><a href="#Empirical-Rule-經驗法則" class="headerlink" title="Empirical Rule 經驗法則"></a>Empirical Rule 經驗法則</h4><p>當資料大約是鐘型分布時可以用 Empirical Rule 來查看有有多少資料分布在某個特定的標準差裡面，此原理是用常態分配推算出。</p>
<p>看圖說故事拉XD</p>
<blockquote>
<p><img src="/images/statistics-ch3B/7.PNG" alt=""></p>
</blockquote>
<h4 id="Detecting-Outliers-離群值"><a href="#Detecting-Outliers-離群值" class="headerlink" title="Detecting Outliers 離群值"></a>Detecting Outliers 離群值</h4><p>找出極端數值使用離群值，也可用於找出資料錯誤，看圖說明：</p>
<blockquote>
<p><img src="/images/statistics-ch3B/8.PNG" alt=""></p>
</blockquote>
<h4 id="Five-Number-Summary-and-Box-Plox-五數彙整-和-箱型圖"><a href="#Five-Number-Summary-and-Box-Plox-五數彙整-和-箱型圖" class="headerlink" title="Five-Number Summary and Box Plox 五數彙整 和 箱型圖"></a>Five-Number Summary and Box Plox 五數彙整 和 箱型圖</h4><h5 id="QUESTION-Five-Number-Summary-哪五數"><a href="#QUESTION-Five-Number-Summary-哪五數" class="headerlink" title="QUESTION: Five-Number Summary 哪五數?"></a>QUESTION: Five-Number Summary 哪五數?</h5><ul>
<li>Smallest Value 最小值</li>
<li>First Quartile 第一分位(25%)</li>
<li>Median 中位數</li>
<li>Thrid Quartile 第三分位(75%)</li>
<li>Larget Value 最大值</li>
</ul>
<h5 id="Box-Plox-箱型圖"><a href="#Box-Plox-箱型圖" class="headerlink" title="Box Plox 箱型圖"></a>Box Plox 箱型圖</h5><p>基礎是 Five-Number Summary，也可看出離群值的圖。<br>箱型圖怎麼畫，在這裡！</p>
<blockquote>
<p><img src="/images/statistics-ch3B/9.PNG" alt=""></p>
</blockquote>
<h3 id="Measures-of-Association-Between-Two-Variables-兩個變數的關係"><a href="#Measures-of-Association-Between-Two-Variables-兩個變數的關係" class="headerlink" title="Measures of Association Between Two Variables 兩個變數的關係"></a>Measures of Association Between Two Variables 兩個變數的關係</h3><p>把散佈圖切成4塊，如果散佈圖數值集中在一、三象限代表有線性關係，二、四象限也是，如果數值散步則代表沒有線性關系。</p>
<h3 id="Covariance-共變異數"><a href="#Covariance-共變異數" class="headerlink" title="Covariance 共變異數"></a>Covariance 共變異數</h3><p>當共變異數為負時表示當一方正成長另一方則會反向成長，反之亦同。</p>
<p>公式如下：</p>
<blockquote>
<p><img src="/images/statistics-ch3B/10.PNG" alt=""></p>
</blockquote>
<p>舉例如下：</p>
<blockquote>
<p><img src="/images/statistics-ch3B/11.PNG" alt=""></p>
</blockquote>
<h3 id="Correlation-Coefficient-相關係數"><a href="#Correlation-Coefficient-相關係數" class="headerlink" title="Correlation Coefficient 相關係數"></a>Correlation Coefficient 相關係數</h3><p>只能說兩變數有相關性，不可以說哪個變數影響誰。<br>公式如下：</p>
<blockquote>
<p><img src="/images/statistics-ch3B/12.PNG" alt=""></p>
</blockquote>
<p>Correlation Coefficient 介於 1 與 -1 之間，越接近 -1 代表有很強烈的負相關、接近 1 代表有強烈的正相關，如果是 0 代表沒關係，<del>與我無關</del>。</p>
<p>舉例：</p>
<blockquote>
<p><img src="/images/statistics-ch3B/13.PNG" alt=""><br><img src="/images/statistics-ch3B/14.PNG" alt=""></p>
</blockquote>
<h2 id="Data-Dashboards-資料儀表板"><a href="#Data-Dashboards-資料儀表板" class="headerlink" title="Data Dashboards 資料儀表板"></a>Data Dashboards 資料儀表板</h2><p>把圖表或是數值分析放在同一塊螢幕上。</p>
]]></content>
      <categories>
        <category>北科上課筆記</category>
        <category>統計 statistics</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>統計學筆記</tag>
        <tag>北科大二上統計學筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>統計學(一) 筆記 - 初次介紹</title>
    <url>/2020/09/16/statistics/statistics-begin/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊與財金管理系大二上統計學重點整理<br><font color="#dd0000">並非所有人都適用，部分對我而言稍加容易的內容並不會寫在此內。</font></p>
</blockquote>
<a id="more"></a>

<h2 id="Bloomberg"><a href="#Bloomberg" class="headerlink" title="Bloomberg"></a>Bloomberg</h2><h3 id="QUESTION-and-SOLUTION"><a href="#QUESTION-and-SOLUTION" class="headerlink" title="QUESTION and SOLUTION"></a>QUESTION and SOLUTION</h3><blockquote>
<p>Bloomberg 如何利用資料</p>
</blockquote>
<ul>
<li>分析股市</li>
<li>觀察使用者消費習慣</li>
<li>程式設計</li>
<li>行業系類資訊</li>
</ul>
<blockquote>
<p>這些資料可以帶來甚麼價值</p>
</blockquote>
<ul>
<li>平台隨時更新資訊</li>
<li>透明的資訊來源</li>
<li>幫客戶降低風險</li>
<li>投資決策</li>
</ul>
<blockquote>
<p>除了影片所述，Bloomberg 還可以如何進一步使用資料</p>
</blockquote>
<ul>
<li>預測未來經濟走勢</li>
<li>賣資料給其他需要客戶</li>
<li>預測股市趨勢</li>
</ul>
<h2 id="QUESTION-SET"><a href="#QUESTION-SET" class="headerlink" title="QUESTION SET"></a>QUESTION SET</h2><h3 id="甚麼是統計？"><a href="#甚麼是統計？" class="headerlink" title="甚麼是統計？"></a>甚麼是統計？</h3><p>透過數值表達，蒐集、分析、表現並解釋結果。</p>
<h3 id="找一份統計分析資料"><a href="#找一份統計分析資料" class="headerlink" title="找一份統計分析資料"></a>找一份統計分析資料</h3><p>手機電量，長條圖</p>
<h3 id="統計在商業與經濟的應用"><a href="#統計在商業與經濟的應用" class="headerlink" title="統計在商業與經濟的應用"></a>統計在商業與經濟的應用</h3><ul>
<li>會計<ul>
<li>本益比</li>
</ul>
</li>
<li>經濟<ul>
<li>就業</li>
<li>GDP</li>
</ul>
</li>
<li>金融<ul>
<li>股票</li>
<li>投資分析</li>
</ul>
</li>
<li>行銷<ul>
<li>同業資訊</li>
<li>通路</li>
<li>廣告</li>
<li>消費者喜愛</li>
</ul>
</li>
<li>產品<ul>
<li>產能</li>
<li>良率 </li>
</ul>
</li>
<li>資訊系統<ul>
<li>資料庫</li>
</ul>
</li>
<li><a href="https://tradingvalley.com" target="_blank" rel="noopener"><strong>機器人理財</strong></a><br>詢問妳問題，之後給你最好的組合。</li>
</ul>
<h3 id="DataSet-名詞介紹"><a href="#DataSet-名詞介紹" class="headerlink" title="DataSet 名詞介紹"></a>DataSet 名詞介紹</h3><ul>
<li>Elements 單位名稱，如:公司名稱</li>
<li>Variables  想查看的變數，如:公司盈餘<ul>
<li>變數歸類，如：「種類」、「數字」、「有無」</li>
</ul>
</li>
<li>Observations 單筆元素的變數資料</li>
<li>DataSet 全部元素的變數資料，不包含 Elements and Variables</li>
</ul>
<h3 id="Scales-of-Measurement-衡量此度-必考"><a href="#Scales-of-Measurement-衡量此度-必考" class="headerlink" title="Scales of Measurement 衡量此度 *必考 "></a><strong><font color="#dd0000">Scales of Measurement 衡量此度 *必考 </font></strong></h3><ul>
<li>Nominal 名目尺度，歸類用。<br>  只能計算次數，不能做其他使用。</li>
<li>Ordinal 順序尺度，歸類用<br>  只能知道相對程度。</li>
<li>Interval 等距尺度，可進行分析<br>  加減可以進行分析。</li>
<li>Ratio 等比尺度，可進行分析<br>  加減乘除都可以進行分析。</li>
</ul>
<h2 id="Time-Series-Data-時間序列"><a href="#Time-Series-Data-時間序列" class="headerlink" title="Time Series Data 時間序列"></a>Time Series Data 時間序列</h2><p>透過時間的變化做成的統計</p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>第一周的統計課就讓我覺得好難的感覺呀！我希望我能夠不被當，開學新希望XD。人生好難，讀書、比賽、工作都要兼顧，希望我能兼顧好 QwQ，統計的報告與測驗都能順利。</p>
]]></content>
      <categories>
        <category>北科上課筆記</category>
        <category>統計 statistics</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>統計學筆記</tag>
        <tag>北科大二上統計學筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>統計學(二) 筆記 - 第十章 推論兩個平均數或是母體參數(Inference About Means and Proportions with Two Population)</title>
    <url>/2021/03/20/statistics/statistics-ch10/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊與財金管理系大二下統計學重點整理<br><font color="#dd0000">並非所有人都適用，部分對我而言稍加容易的內容並不會寫在此內。</font><br><strong>這是觀看影片心得後的筆記，老師上課可能不太適用會忘記抄到</strong></p>
</blockquote>
<a id="more"></a>

<h2 id="此章有四個重點，分別為"><a href="#此章有四個重點，分別為" class="headerlink" title="此章有四個重點，分別為"></a>此章有四個重點，分別為</h2><ul>
<li>推論兩個不一樣的已知母體平均數 (Inference About the Difference Between Two Population Known Means)</li>
<li>推論兩個不一樣的已知母體平均數 (Inference About the Difference Between Two Population Known Means)</li>
<li>推論兩個不一樣的已知母體平均數樣本 (Inference About the Difference Between Two Population Means: Matched Sample)</li>
<li>推論兩個不一樣的母體參數 (Inference About the Difference Between Two Population Proportions)</li>
<li>可點擊右邊的 menu 選擇要看的重點</li>
</ul>
<h1 id="推論兩個不一樣的已知母體平均數-Inference-About-the-Difference-Between-Two-Population-Known-Means"><a href="#推論兩個不一樣的已知母體平均數-Inference-About-the-Difference-Between-Two-Population-Known-Means" class="headerlink" title="推論兩個不一樣的已知母體平均數 (Inference About the Difference Between Two Population Known Means)"></a>推論兩個不一樣的已知母體平均數 (Inference About the Difference Between Two Population Known Means)</h1><h2 id="估計兩個不一樣的已知母體平均數-Estimating-the-Difference-Between-Two-Population-Means"><a href="#估計兩個不一樣的已知母體平均數-Estimating-the-Difference-Between-Two-Population-Means" class="headerlink" title="估計兩個不一樣的已知母體平均數 (Estimating the Difference Between Two Population Means)"></a>估計兩個不一樣的已知母體平均數 (Estimating the Difference Between Two Population Means)</h2><p>直接透過重點進行說明</p>
<ul>
<li>兩個不同母體的平均數分別為 \(\mu_1, \mu_2\)</li>
<li>兩個平均數的差異就是 \(\mu_1 - \mu_2\)</li>
<li>估計 \(\mu_1 - \mu_2\)，我們先選擇隨機樣本 \(n_1\) 從母體 1，在選擇隨機樣本 \(n_2\) 從母體 2</li>
<li>定義 \(\bar{x_1}\) 等於 sample1 mean，\(\bar{x_2}\) 等於 sample2 mean</li>
<li>母體平均數的點估計差值就是 \(\bar{x_1} - \bar{x_2}\)，此公式的計算方式將在下點介紹，名稱為 Sample Distritubion。</li>
<li>不懂區間估計可看<a href="https://theriseofdavid.github.io/2020/12/29/NTUT_note/statistics-ch8/" target="_blank" rel="noopener">統計學(一) 筆記 - 第八章 區間估計(Interval Estimation)</a></li>
</ul>
<h3 id="抽樣分配公式-Sample-Distritubion"><a href="#抽樣分配公式-Sample-Distritubion" class="headerlink" title="抽樣分配公式 (Sample Distritubion)"></a>抽樣分配公式 (Sample Distritubion)</h3><ul>
<li>期望值 \(E(\bar{x_1} - \bar{x_2}) = \mu_1 - \mu_2\)</li>
<li>標準差 \(\sigma_{\bar{x_1} - \bar{x_2}} = \sqrt{\frac{\sigma_1^2}{n_1} + \frac{\sigma_2^2}{n_2}}\)<ul>
<li>\(\sigma_1, \sigma_2\) 分別是母體 1,2 的標準差</li>
<li>\(n_1, n_2\) 分別是母體  1,2 的抽樣大小</li>
</ul>
</li>
<li>區間估計 \(\bar{x_1} - \bar{x_2} \pm z_{a/2} \sqrt{\frac{\sigma_1^2}{n_1} + \frac{\sigma_2^2}{n_2}}\)<ul>
<li>\(1-a\) 則是信心水準</li>
</ul>
</li>
</ul>
<h4 id="舉例-A-高爾夫球設備製造商開發出了新球桿可以將高爾夫球打得更遠，而同時-B-也開發了一個新球桿，A-公司-population-size-120balls-population-mean-275yards-standard-error-15yards-B-公司-population-size-80balls-mean-258yards-standard-error-20yards，詢問在-95-的信心水準之中，這兩家公司的平均擊球差異是多少"><a href="#舉例-A-高爾夫球設備製造商開發出了新球桿可以將高爾夫球打得更遠，而同時-B-也開發了一個新球桿，A-公司-population-size-120balls-population-mean-275yards-standard-error-15yards-B-公司-population-size-80balls-mean-258yards-standard-error-20yards，詢問在-95-的信心水準之中，這兩家公司的平均擊球差異是多少" class="headerlink" title="舉例: A 高爾夫球設備製造商開發出了新球桿可以將高爾夫球打得更遠，而同時 B 也開發了一個新球桿，A 公司 population size 120balls, population mean 275yards, standard error = 15yards, B 公司 population size 80balls,mean 258yards, standard error = 20yards，詢問在 95% 的信心水準之中，這兩家公司的平均擊球差異是多少"></a>舉例: A 高爾夫球設備製造商開發出了新球桿可以將高爾夫球打得更遠，而同時 B 也開發了一個新球桿，A 公司 population size 120balls, population mean 275yards, standard error = 15yards, B 公司 population size 80balls,mean 258yards, standard error = 20yards，詢問在 95% 的信心水準之中，這兩家公司的平均擊球差異是多少</h4><ul>
<li>定義 population1 為 A 公司，population2 為 B 公司，我們透過抽取樣本的方式(用點估計)來算出 \(\mu_1 - \mu_2\)，但因為是樣本所以會有誤差的問題。</li>
<li>因此先算出點估計量 \(\mu_1 - \mu_2 = \bar{x_1} - \bar{x_2} = 275-258 = 17\)</li>
<li>再來我們帶抽樣分配公式，\(\bar{x_1} - \bar{x_2} \pm z_{a/2} \sqrt{\frac{\sigma_1^2}{n_1} + \frac{\sigma_2^2}{n_2}} = 17 \pm 1.96 \sqrt{\frac{(15)^2}{120} + \frac{(20)^2}{80}} = 17 \pm 5.14\)，也就是平均擊球差異會落在 11.86yards to 22.14yards. </li>
</ul>
<h2 id="假設檢定兩個不一樣的已知母體平均數-Hypothesis-Tests-About-mu-1-mu-2"><a href="#假設檢定兩個不一樣的已知母體平均數-Hypothesis-Tests-About-mu-1-mu-2" class="headerlink" title="假設檢定兩個不一樣的已知母體平均數 Hypothesis Tests About \(\mu_1 - \mu_2\)"></a>假設檢定兩個不一樣的已知母體平均數 Hypothesis Tests About \(\mu_1 - \mu_2\)</h2><p>先定義下左、右、雙尾的假設檢定，下方的 \(D_0\) 為數值</p>
<ul>
<li>左尾<ul>
<li>\(H_0: \mu_1 - \mu_2 \geq D_0\)</li>
<li>\(H_1: \mu_1 - \mu_2 &lt; D_0\)</li>
</ul>
</li>
<li>右尾<ul>
<li>\(H_0: \mu_1 - \mu_2 \leq D_0\)</li>
<li>\(H_1: \mu_1 - \mu_2 &gt; D_0\)</li>
</ul>
</li>
<li>雙尾<ul>
<li>\(H_0: \mu_1 - \mu_2 = D_0\)</li>
<li>\(H_1: \mu_1 - \mu_2 &lt;&gt; D_0\)</li>
</ul>
</li>
<li>而公式為 \(z = (\bar{x_1} - \bar{x_2})-D_0 / \sqrt{\frac{\sigma_1^2}{n_1} + \frac{\sigma_2^2}{n_2}}\)，注意已知的檢定量要用 z，未知的才有 t。</li>
<li>不懂假設統計可看<a href="https://theriseofdavid.github.io/2021/02/27/NTUT_note/statistics-ch9/" target="_blank" rel="noopener">統計學(二) 筆記 - 第九章 假說檢定(hypothesis testing)</a></li>
</ul>
<h3 id="舉例-A-高爾夫球設備製造商開發出了新球桿可以將高爾夫球打得更遠，而同時-B-也開發了一個新球桿，A-公司-population-size-120balls-population-mean-275yards-standard-error-15yards-B-公司-population-size-80balls-population-mean-258yards-standard-error-20yards，詢問在-1-的顯著性測試下是不是-A-公司大於-B-公司。"><a href="#舉例-A-高爾夫球設備製造商開發出了新球桿可以將高爾夫球打得更遠，而同時-B-也開發了一個新球桿，A-公司-population-size-120balls-population-mean-275yards-standard-error-15yards-B-公司-population-size-80balls-population-mean-258yards-standard-error-20yards，詢問在-1-的顯著性測試下是不是-A-公司大於-B-公司。" class="headerlink" title="舉例:  A 高爾夫球設備製造商開發出了新球桿可以將高爾夫球打得更遠，而同時 B 也開發了一個新球桿，A 公司 population size 120balls, population mean 275yards, standard error = 15yards, B 公司 population size 80balls, population mean 258yards, standard error = 20yards，詢問在 1% 的顯著性測試下是不是 A 公司大於 B 公司。"></a>舉例:  A 高爾夫球設備製造商開發出了新球桿可以將高爾夫球打得更遠，而同時 B 也開發了一個新球桿，A 公司 population size 120balls, population mean 275yards, standard error = 15yards, B 公司 population size 80balls, population mean 258yards, standard error = 20yards，詢問在 1% 的顯著性測試下是不是 A 公司大於 B 公司。</h3><ul>
<li>定義 population1 為 A 公司，population2 為 B 公司</li>
<li>因此定義對立假設與虛無假設<ul>
<li>\(H_0: \mu_1 - \mu_2 \leq 0\)</li>
<li>\(H_1: \mu_1 - \mu_2 &gt; 0\)</li>
</ul>
</li>
<li>設定顯著性測試 0.01</li>
<li>收集樣本，計算 z<br>\(z = ((\bar{x_1} - \bar{x_2})-D_0) / \sqrt{\frac{\sigma_1^2}{n_1} + \frac{\sigma_2^2}{n_2}} = ((235-218)-0) / \sqrt{\frac{(15^2)}{120} + \frac{(20)^2}{80}} = \frac{17}{2.62} = 6.49\)</li>
<li>使用方法<ul>
<li>p-Value Approach<ul>
<li>\(z = 6.49, p = 0.000007\)，\(1-p-value = 1 - 0.000007) = 0.999993\)</li>
<li>因為 \(p-value = 0.000007 &lt; \alpha = 0.01\)，因此我們拒絕 \(H_0\)</li>
<li>因此在百分之一的顯著性測試下，A 公司的球桿擊球距離大於 B</li>
</ul>
</li>
<li>Critical Value Approach<ul>
<li>\(a  = 0.01， z_{0.01} = 2.33\)，因此 Reject \(H_0\) if \(z \geq 2.33 \)</li>
<li>\(z = 6.49 \geq 2.33\)，因此我們拒絕 \(H_0\)</li>
<li>因此在百分之一的顯著性測試下，A 公司的球桿擊球距離大於 B</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="推論兩個不一樣的未知母體平均數-Inference-About-the-Difference-Between-Two-Population-unKnown-Means"><a href="#推論兩個不一樣的未知母體平均數-Inference-About-the-Difference-Between-Two-Population-unKnown-Means" class="headerlink" title="推論兩個不一樣的未知母體平均數 (Inference About the Difference Between Two Population unKnown Means)"></a>推論兩個不一樣的未知母體平均數 (Inference About the Difference Between Two Population unKnown Means)</h1><h1 id="區間估計來推估兩個不一樣的未知母體平均數"><a href="#區間估計來推估兩個不一樣的未知母體平均數" class="headerlink" title="區間估計來推估兩個不一樣的未知母體平均數"></a>區間估計來推估兩個不一樣的未知母體平均數</h1><ul>
<li>區間估計的公式為<br>\(\bar{x_1} - \bar{x_2} \pm t_{a/2} \sqrt{\frac{s_1^2}{n_1} + \frac{s_2^2}{n_2}}\)，s 為樣本標準差，其中 t 為自由度，但遇到兩個母體樣本因此公式變得比較麻煩，其中 \(t_{a/2} = (\frac{s_1^2}{n_1} + \frac{s_2^2}{n_2})^2 / (\frac{1}{n_1-1}(\frac{s_1^2}{n_1})^2 + \frac{1}{n_2-1}(\frac{s_2^2}{n_2})^2)  \)</li>
</ul>
<h3 id="舉例-A-公司生產出一種新車款想與-B-公司的最新車款就比較，在百分之-90-的信賴區間想要知道兩家平均油耗差異，其中-A-公司-sample-size-24cars-sample-mean-29-8mpg-sample-stdandard-2-56mpg-B-公司為-sample-size-28cars-sample-mean-27-3mpg-sample-stdandard-1-81mpg。"><a href="#舉例-A-公司生產出一種新車款想與-B-公司的最新車款就比較，在百分之-90-的信賴區間想要知道兩家平均油耗差異，其中-A-公司-sample-size-24cars-sample-mean-29-8mpg-sample-stdandard-2-56mpg-B-公司為-sample-size-28cars-sample-mean-27-3mpg-sample-stdandard-1-81mpg。" class="headerlink" title="舉例: A 公司生產出一種新車款想與 B 公司的最新車款就比較，在百分之 90 的信賴區間想要知道兩家平均油耗差異，其中 A 公司 sample size 24cars, sample mean 29.8mpg, sample stdandard 2.56mpg, B 公司為 sample size 28cars, sample mean 27.3mpg, sample stdandard 1.81mpg。"></a>舉例: A 公司生產出一種新車款想與 B 公司的最新車款就比較，在百分之 90 的信賴區間想要知道兩家平均油耗差異，其中 A 公司 sample size 24cars, sample mean 29.8mpg, sample stdandard 2.56mpg, B 公司為 sample size 28cars, sample mean 27.3mpg, sample stdandard 1.81mpg。</h3><ul>
<li>定義 population1 為 A 公司，population2 為 B 公司</li>
<li>因此先算出點估計量 \(\mu_1 - \mu_2 = \bar{x_1} - \bar{x_2} = 29.8-27.3 = 2.5\)</li>
<li>設定顯著性測試 0.1，\(a/2=0.5\)</li>
<li>計算 t \(t_{a/2} = (\frac{s_1^2}{n_1} + \frac{s_2^2}{n_2})^2 / (\frac{1}{n_1-1}(\frac{s_1^2}{n_1})^2 + \frac{1}{n_2-1}(\frac{s_2^2}{n_2})^2)  \)，帶入數字後就是 \((\frac{(2.56)^2}{24} + \frac{(1.81)^2}{28})^2 / (\frac{1}{24-1}(\frac{(2.56^2)}{24}^2) + \frac{1}{28-1} (\frac{(1.81)^2}{28})^2) = 40.585 \)，大約等於 40，這裡通常會判斷 40 與 41 的 t 哪個比較大，為了符合百分之 90 的信賴區間，因此選擇偏差較大的 40，如果這裡選 41 那有可能會小於百分之 90 的信賴區間，保險起見用 40，\(t_{a/2} = 1.684\)</li>
<li>帶入區間估計公式 \(\bar{x_1} - \bar{x_2} \pm t_{a/2} \sqrt{\frac{s_1^2}{n_1} + \frac{s_2^2}{n_2}} = 29.8-27.3 \pm 1.684 \sqrt{\frac{(2.56)^2}{24} + \frac{(1.81)^2}{28}} = 2.5 \pm 1.052\)，因此在百分之 90% 的信心水準之下，兩家平均油耗差異大約會在 1.448 to 3.552 mpg。</li>
</ul>
<h2 id="假設檢定來推估兩個不一樣的未知母體平均數"><a href="#假設檢定來推估兩個不一樣的未知母體平均數" class="headerlink" title="假設檢定來推估兩個不一樣的未知母體平均數"></a>假設檢定來推估兩個不一樣的未知母體平均數</h2><p>先定義下左、右、雙尾的假設檢定，下方的 \(D_0\) 為數值</p>
<ul>
<li>左尾<ul>
<li>\(H_0: \mu_1 - \mu_2 \geq D_0\)</li>
<li>\(H_1: \mu_1 - \mu_2 &lt; D_0\)</li>
</ul>
</li>
<li>右尾<ul>
<li>\(H_0: \mu_1 - \mu_2 \leq D_0\)</li>
<li>\(H_1: \mu_1 - \mu_2 &gt; D_0\)</li>
</ul>
</li>
<li>雙尾<ul>
<li>\(H_0: \mu_1 - \mu_2 = D_0\)</li>
<li>\(H_1: \mu_1 - \mu_2 &lt;&gt; D_0\)</li>
</ul>
</li>
<li>而公式為 \(t = (\bar{x_1} - \bar{x_2})-D_0 / \sqrt{\frac{s_1^2}{n_1} + \frac{s_2^2}{n_2}}\)，注意已知的檢定量要用 z，未知的才有 t。</li>
</ul>
<h3 id="舉例-A-公司生產出一種新車款想與-B-公司的最新車款就比較，在-5-的顯著性測試中，我們想知道-A-公司是不是平均油耗比-B-公司好，其中-A-公司-sample-size-24cars-sample-mean-29-8mpg-sample-stdandard-2-56mpg-B-公司為-sample-size-28cars-sample-mean-27-3mpg-sample-stdandard-1-81mpg。"><a href="#舉例-A-公司生產出一種新車款想與-B-公司的最新車款就比較，在-5-的顯著性測試中，我們想知道-A-公司是不是平均油耗比-B-公司好，其中-A-公司-sample-size-24cars-sample-mean-29-8mpg-sample-stdandard-2-56mpg-B-公司為-sample-size-28cars-sample-mean-27-3mpg-sample-stdandard-1-81mpg。" class="headerlink" title="舉例: A 公司生產出一種新車款想與 B 公司的最新車款就比較，在 5% 的顯著性測試中，我們想知道 A 公司是不是平均油耗比 B 公司好，其中 A 公司 sample size 24cars, sample mean 29.8mpg, sample stdandard 2.56mpg, B 公司為 sample size 28cars, sample mean 27.3mpg, sample stdandard 1.81mpg。"></a>舉例: A 公司生產出一種新車款想與 B 公司的最新車款就比較，在 5% 的顯著性測試中，我們想知道 A 公司是不是平均油耗比 B 公司好，其中 A 公司 sample size 24cars, sample mean 29.8mpg, sample stdandard 2.56mpg, B 公司為 sample size 28cars, sample mean 27.3mpg, sample stdandard 1.81mpg。</h3><ul>
<li>定義 population1 為 A 公司，population2 為 B 公司</li>
<li>因此定義對立假設與虛無假設<ul>
<li>\(H_0: \mu_1 - \mu_2 \leq 0\)</li>
<li>\(H_1: \mu_1 - \mu_2 &gt; 0\)</li>
</ul>
</li>
<li>設定顯著性測試 0.05</li>
<li>收集樣本，計算 t<br>\(t = (\bar{x_1} - \bar{x_2})-D_0 / \sqrt{\frac{s_1^2}{n_1} + \frac{s_2^2}{n_2}} =  \frac{(29.8-27.3) -0}{\sqrt{\frac{(2.56)^2}{24} + \frac{(1.81)^2}{28}}} = 4.003\)</li>
<li>使用方法<ul>
<li>p-Value Approach<ul>
<li>先計算自由度<br>計算 \(t_{a} = (\frac{s_1^2}{n_1} + \frac{s_2^2}{n_2})^2 / (\frac{1}{n_1-1}(\frac{s_1^2}{n_1})^2 + \frac{1}{n_2-1}(\frac{s_2^2}{n_2})^2)  \)，帶入數字後就是 \((\frac{(2.56)^2}{24} + \frac{(1.81)^2}{28})^2 / (\frac{1}{24-1}(\frac{(2.56^2)}{24}^2) + \frac{1}{28-1} (\frac{(1.81)^2}{28})^2) = 40.585 \)，大約等於 40，這裡通常會判斷 40 與 41 的 t 哪個比較大，為了符合百分之 90 的信賴區間，因此選擇偏差較大的 40，如果這裡選 41 那有可能會小於百分之 90 的信賴區間，保險起見用 40，\(t_{a} = 1.684\)</li>
<li>\(t=4.003, p = 0.00013\)，\(1-p-value = 1 - 0.00013 = 0.99987\)</li>
<li>\(p-value = 0.00013 &lt; 0.05 = \alpha \)，因此我們拒絕 \(H_0\)</li>
<li>因此在百分之五的顯著性測試下，A 公司車款的平均油耗比 B 公司車款好</li>
</ul>
</li>
<li>Critical Value Approach<ul>
<li>\(a  = 0.05， t_{0.05} = 1.684\)，因此 Reject \(H_0\) if \(t \geq 1.684 \)</li>
<li>\(z = 4.003 \geq 1.684\)，因此我們拒絕 \(H_0\)</li>
<li>因此在百分之五的顯著性測試下，A 公司車款的平均油耗比 B 公司車款好</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="推論兩個不一樣的已知母體平均數樣本，配對樣本情況-Inference-About-the-Difference-Between-Two-Population-Means-Matched-Sample"><a href="#推論兩個不一樣的已知母體平均數樣本，配對樣本情況-Inference-About-the-Difference-Between-Two-Population-Means-Matched-Sample" class="headerlink" title="推論兩個不一樣的已知母體平均數樣本，配對樣本情況 (Inference About the Difference Between Two Population Means: Matched Sample)"></a>推論兩個不一樣的已知母體平均數樣本，配對樣本情況 (Inference About the Difference Between Two Population Means: Matched Sample)</h1><p>定義配對樣本情況，相同的樣本但在兩次的測試中有不一樣的結果，通常是實驗前跟實驗後的對照。</p>
<p>由於這種樣本會比其前兩種方式的樣本差來的更小很多，因為並不是獨立關係，而是<strong>改變</strong>了甚麼。</p>
<p>這邊直接透過舉例來進行說明。</p>
<!-- 通常不會用區間估計，而是用假設檢定，因為實驗的問題用區間估計比較沒有意義。 -->

<h2 id="舉例-A-公司要將文件送至各地的子公司，她們有兩家快遞公司可以選擇，在百分之-95-的信心水準中，他們想知道這兩家快遞公司送到子公司的時間是不是不一樣？"><a href="#舉例-A-公司要將文件送至各地的子公司，她們有兩家快遞公司可以選擇，在百分之-95-的信心水準中，他們想知道這兩家快遞公司送到子公司的時間是不是不一樣？" class="headerlink" title="舉例:A 公司要將文件送至各地的子公司，她們有兩家快遞公司可以選擇，在百分之 95 的信心水準中，他們想知道這兩家快遞公司送到子公司的時間是不是不一樣？"></a>舉例:A 公司要將文件送至各地的子公司，她們有兩家快遞公司可以選擇，在百分之 95 的信心水準中，他們想知道這兩家快遞公司送到子公司的時間是不是不一樣？</h2><p>樣本資料如下</p>
<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1ncHoj7CIjFrd3QtKflbcrLDdZ_KDaudz&export=download" alt=""></p>
</blockquote>
<ul>
<li>定義 UPX 為 A 公司，INTEX 為 B 公司</li>
<li>因此定義對立假設與虛無假設<ul>
<li>\(H_0: \mu_d = 0\)</li>
<li>\(H_1: \mu_d &lt;&gt; 0\)</li>
<li>\(\mu_d\) 為兩家公司的送的時間差別</li>
</ul>
</li>
<li>設定顯著性測試 0.05</li>
<li>計算假設檢定的所有值，標準差、平均數、t <ul>
<li>\(\bar{d} = \frac{\sum d_i}{n} = \frac{(7+6+…+5)}{10} = 2.7\)</li>
<li>\(s_d = \frac{\sum (d_i - \bar{d})^2}{n-1} = \sqrt{\frac{76.1}{9}} = 2.9\)</li>
<li>\(t = \frac{\bar{d} - \mu_d}{s_d / \sqrt{n}} = \frac{2.7-0}{2.9 / \sqrt{10}} = 2.94 \)，\(\mu_d\) 則是 \(H_0\) 的狀態(通常是等於)。</li>
</ul>
</li>
<li>使用方法<ul>
<li>p-Value Approach<ul>
<li>先計算自由度<br>\(t=2.94, df =9\)，df = 自由度，雙尾的機率則是落在 0.01649</li>
<li>\(p = 0.01649\)，\(1-p-value = 1 - 0.01649 = 0.98351\)</li>
<li>\(p-value = 0.01649 &lt; 0.05 = \alpha \)，因此我們拒絕 \(H_0\)</li>
<li>在百分之 95% 的信心水準中，我們可以知道這兩家送文件到子公司時有時間差。</li>
</ul>
</li>
<li>Critical Value Approach<ul>
<li>\(a  = 0.05， t_{0.025} = 2.262\)，因此 Reject \(H_0\) if \(t \geq 2.262 \)</li>
<li>\(t=2.94 \geq 2.262\)，因此 Reject \(H_0\) </li>
<li>在百分之 95% 的信心水準中，我們可以知道這兩家送文件到子公司時有時間差。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="當兩個母體平均數的變異數相同時"><a href="#當兩個母體平均數的變異數相同時" class="headerlink" title="當兩個母體平均數的變異數相同時"></a>當兩個母體平均數的變異數相同時</h1><ul>
<li>此時我們的 t 檢定可以優化成 \(t = (\bar{x_1} - \bar{x_2}) / (s_p \sqrt{\frac{1}{n_1} + \frac{1}{n_2}} ) \)</li>
<li>而其中的 \(s_p\) 可以優化為 \(s_p = \sqrt{\frac{(n_1-1) s_1^2 + (n_2-1) s_2^2}{n_1 + n_2 -2}}\)</li>
</ul>
<h1 id="推論兩個不一樣的母體參數-Inference-About-the-Difference-Between-Two-Population-Proportions"><a href="#推論兩個不一樣的母體參數-Inference-About-the-Difference-Between-Two-Population-Proportions" class="headerlink" title="推論兩個不一樣的母體參數 (Inference About the Difference Between Two Population Proportions)"></a>推論兩個不一樣的母體參數 (Inference About the Difference Between Two Population Proportions)</h1><p>先來定義一些必要資訊</p>
<ul>
<li>區間估計  \(p_1 - p_2\)</li>
<li>假設檢定則是  \(p_1 - p_2\)</li>
<li>Expected Value<br>\(E(\bar{p_1} - \bar{p_2}) = p_1 - p_2\)</li>
<li>Standard Deviation(Standard Error)<br>\(\sigma_{p_1 - p_2} = \sqrt{\frac{p_1 ( 1- p_1)}{n_1}+\frac{p_2(1-p_2)}{n_2}}\)<ul>
<li>\(n_1\) 母體 A 的樣本大小</li>
<li>\(n_2\) 母體 B 的樣本大小</li>
</ul>
</li>
<li>必須要符合此四條件，才能夠用常態分配推論兩個不一樣的母體參數<ul>
<li>\(n_1 p_1 \geq 5\) and \(n_1(1-p_1) \geq 5\)</li>
<li>\(n_2 p_2 \geq 5\) and \(n_2(1-p_2) \geq 5\)</li>
</ul>
</li>
<li>\(z = \frac{\bar{p_1} - \bar{p_2}}{\sigma_{\bar{p_1} - \bar{p_2}}}\)</li>
</ul>
<p>用圖片來表示的畫如下</p>
<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1bUJTFi7ScFqqXI9sRMDTIj0OyuYaoMVg&export=download" alt=""></p>
</blockquote>
<p>因此我們就可以推出區間估計公式為 \(\bar{p_1} - \bar{p_2} \pm z_{a/2} \sqrt{\frac{\bar{p_1} ( 1- \bar{p_1)}}{n_1}+\frac{\bar{p_2}(1-\bar{p_2})}{n_2}} \)</p>
<h2 id="舉例：行銷協會想要評估這次的行銷活動有沒有效，先進行市話調查，想知道有多少人知道這個商品，分為前測與後測，前測是在還沒開始此行銷活動，後測則是開始；前測得知在-150-人中有-60-位知道此商品，後測則是-250-人中有-120-人知道此商品，我們想知道這些資料能否證明此行銷活動前後有多少人知道的差異"><a href="#舉例：行銷協會想要評估這次的行銷活動有沒有效，先進行市話調查，想知道有多少人知道這個商品，分為前測與後測，前測是在還沒開始此行銷活動，後測則是開始；前測得知在-150-人中有-60-位知道此商品，後測則是-250-人中有-120-人知道此商品，我們想知道這些資料能否證明此行銷活動前後有多少人知道的差異" class="headerlink" title="舉例：行銷協會想要評估這次的行銷活動有沒有效，先進行市話調查，想知道有多少人知道這個商品，分為前測與後測，前測是在還沒開始此行銷活動，後測則是開始；前測得知在 150 人中有 60 位知道此商品，後測則是 250 人中有 120 人知道此商品，我們想知道這些資料能否證明此行銷活動前後有多少人知道的差異"></a>舉例：行銷協會想要評估這次的行銷活動有沒有效，先進行市話調查，想知道有多少人知道這個商品，分為前測與後測，前測是在還沒開始此行銷活動，後測則是開始；前測得知在 150 人中有 60 位知道此商品，後測則是 250 人中有 120 人知道此商品，我們想知道這些資料能否證明此行銷活動前後有多少人知道的差異</h2><ul>
<li>先來定義參數<ul>
<li>\(p_1\) 為後測後，知道商品的數量</li>
<li>\(p_2\) 為前測後，知道商品的數量</li>
<li>\(\bar{p_1}\) 為後測的樣本參數</li>
<li>\(\bar{p_2}\) 為前測的樣本參數</li>
</ul>
</li>
<li>所以 \(p_1 - p_2 = \frac{120}{250} - \frac{60}{150} = 0.48-0.40=0.08\)</li>
<li>區間估計<ul>
<li>顯著性測試 0.05</li>
<li>因此 \(z_{0.025} = 1.96\)</li>
<li>\(0.48 - 0.40 \pm 1.96 \sqrt{\frac{0.48(0.52)}{250} + \frac{0.40(0.60)}{150}} = 0.08 \pm 1.96(0.510) = 0.08 \pm 0.10\)</li>
<li>因此在百分之 95% 的信心，在宣傳前與宣傳後的差異會落在 0 to 0.18</li>
</ul>
</li>
</ul>
<h2 id="假設檢定-Hypothesis-Tests-about-p-1-p-2"><a href="#假設檢定-Hypothesis-Tests-about-p-1-p-2" class="headerlink" title="假設檢定 Hypothesis Tests about \(p_1 - p_2\)"></a>假設檢定 Hypothesis Tests about \(p_1 - p_2\)</h2><p>先定義下左、右、雙尾的假設檢定</p>
<ul>
<li>左尾<ul>
<li>\(H_0: p_1 - p_2 \geq D_0\)</li>
<li>\(H_1: p_1 - p_2 &lt; D_0\)</li>
</ul>
</li>
<li>右尾<ul>
<li>\(H_0: p_1 - p_2 \leq D_0\)</li>
<li>\(H_1: p_1 - p_2 &gt; D_0\)</li>
</ul>
</li>
<li>雙尾<ul>
<li>\(H_0: p_1 - p_2 = D_0\)</li>
<li>\(H_1: p_1 - p_2 &lt;&gt; D_0\)</li>
</ul>
</li>
</ul>
<p>再來定義假設檢定中需要的標準差、點估計、z 值</p>
<ul>
<li>標準差 \(\bar{p_1} - \bar{p_2}\) 當 \(p_1 = p_2 = p\)<br>公式為 \(\sigma_{\bar{p_1} - \bar{p_2}} = \sqrt{p(1-p) (\frac{1}{n_1}+\frac{1}{n_2})}\)</li>
<li>混和估計量 pooled Estimator 當 \(p_1 = p_2 = p\)，為兩個樣本混合的點估計量，能夠更方便的計算<br>公式為 \(\bar{p} = \frac{n_1 \bar{p_1} + n_2 \bar{p_2}}{n_1 + n_2}\)</li>
<li>假設檢定中的 z 值則是 \(z=\frac{(\bar{p_1} - \bar{p_2})}{\sqrt{p(1-p) (\frac{1}{n_1}+\frac{1}{n_2})}}\)</li>
</ul>
<h3 id="舉例：行銷協會想要評估這次的行銷活動有沒有效，先進行市話調查，想知道有多少人知道這個商品，分為前測與後測，前測是在還沒開始此行銷活動，後測則是開始；前測得知在-150-人中有-60-位知道此商品，後測則是-250-人中有-120-人知道此商品，再百分之-95-的信心水準中，我們想知道這些資料能否證明此行銷活動可以提高商品知名度"><a href="#舉例：行銷協會想要評估這次的行銷活動有沒有效，先進行市話調查，想知道有多少人知道這個商品，分為前測與後測，前測是在還沒開始此行銷活動，後測則是開始；前測得知在-150-人中有-60-位知道此商品，後測則是-250-人中有-120-人知道此商品，再百分之-95-的信心水準中，我們想知道這些資料能否證明此行銷活動可以提高商品知名度" class="headerlink" title="舉例：行銷協會想要評估這次的行銷活動有沒有效，先進行市話調查，想知道有多少人知道這個商品，分為前測與後測，前測是在還沒開始此行銷活動，後測則是開始；前測得知在 150 人中有 60 位知道此商品，後測則是 250 人中有 120 人知道此商品，再百分之 95 的信心水準中，我們想知道這些資料能否證明此行銷活動可以提高商品知名度"></a>舉例：行銷協會想要評估這次的行銷活動有沒有效，先進行市話調查，想知道有多少人知道這個商品，分為前測與後測，前測是在還沒開始此行銷活動，後測則是開始；前測得知在 150 人中有 60 位知道此商品，後測則是 250 人中有 120 人知道此商品，再百分之 95 的信心水準中，我們想知道這些資料能否證明此行銷活動可以提高商品知名度</h3><p><strong>此舉例是將 \(p_1\) and \(p_2\) 混和</strong></p>
<ul>
<li>定義 \(p_1\) 是後測，定義 \(p_2\) 是前測</li>
<li>因此定義對立假設與虛無假設<ul>
<li>\(H_0: p_1 - p_2 \leq 0\)</li>
<li>\(H_1: p_1 - p_2 &gt; 0\)</li>
</ul>
</li>
<li>設定顯著性測試 0.05</li>
<li>計算 z 檢定<ul>
<li>\(\bar{p} = \frac{250(0.48) + 150(0.40)}{250+150} = \frac{180}{400} = 0.45\)</li>
<li>\(\sigma_{\bar{p_1} - \bar{p_2}} = \sqrt{p(1-p) (\frac{1}{n_1}+\frac{1}{n_2})} = \sqrt{0.45(0.55)(\frac{1}{250}+\frac{1}{150})} = 0.514\)</li>
<li>\(z=\frac{(\bar{p_1} - \bar{p_2})}{\sqrt{p(1-p) (\frac{1}{n_1}+\frac{1}{n_2})}} = \frac{(0.48-0.40)-0}{0.0514} = \frac{0.08}{0.0514} = 1.56\)，其中的 \(\frac{(0.48-0.40)-0}{0.0514}\)，為甚麼要減零是指前面 \(H_0: p_1 - p_2 \leq 0\) 的意思</li>
<li>要特別注意，母體參數不需要用 t 檢定，前面有提到必須符合四條件(其中兩個是\(n_1 p_1 \geq 5\) and \(n_1(1-p_1) \geq 5\))就可以用常態分配</li>
</ul>
</li>
<li>使用方法<ul>
<li>p-Value Approach<ul>
<li>\(z=1.56, p-value=0.0594\)</li>
<li>\(p-value &gt; a = 0.05\)，因此我們不拒絕 \(H_0\)</li>
<li>因此我們不能肯定在此行銷活動後，我們的商品知名度會提高</li>
</ul>
</li>
<li>Critical Value Approach<ul>
<li>\(a=0.05, z_{0.05} = 1.645\)，因此 Reject \(H_0\) if \(t \geq 1.645\)</li>
<li>\(1.56 &lt; 1.645\)，因此我們不拒絕 \(H_0\)</li>
<li>因此我們不能肯定在此行銷活動後，我們的商品知名度會提高</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h1><ul>
<li>北科大丁秀儀老師教學</li>
<li><a href="https://libguides.library.kent.edu/spss/independentttest" target="_blank" rel="noopener">SPSS TUTORIALS: INDEPENDENT SAMPLES T TEST</a></li>
</ul>
]]></content>
      <categories>
        <category>北科上課筆記</category>
        <category>統計 statistics</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>統計學筆記</tag>
        <tag>北科大二下統計學筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>統計學(二) 筆記 - 第十一章 推論母體變異數(Inference About Population Variances)</title>
    <url>/2021/03/27/statistics/statistics-ch11/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊與財金管理系大二下統計學重點整理<br><font color="#dd0000">並非所有人都適用，部分對我而言稍加容易的內容並不會寫在此內。</font><br><strong>這是觀看影片心得後的筆記，老師上課可能不太適用會忘記抄到</strong></p>
</blockquote>
<a id="more"></a>

<h1 id="推論一組母體變異數-Inference-About-a-Population-Variances"><a href="#推論一組母體變異數-Inference-About-a-Population-Variances" class="headerlink" title="推論一組母體變異數(Inference About a Population Variances)"></a>推論一組母體變異數(Inference About a Population Variances)</h1><p>前一章我們對母體參數與平均數進行推論，但還需要判斷變異數是否有過大的問題，如果變異數最大有可能表示其實分布很廣，在某些情況下不太可能夠接受變異數過大的問題，例如大量製造的螺絲釘寬度假如時太大、太小，但平均數出來的值卻是剛剛好，但實際上這樣是不可行的。</p>
<p>因此要用變異數來判斷資料分布是否會過廣。</p>
<h2 id="卡方分配-Chi-Square-Distribution"><a href="#卡方分配-Chi-Square-Distribution" class="headerlink" title="卡方分配 Chi-Square Distribution"></a>卡方分配 Chi-Square Distribution</h2><p>是標準常態隨機變數次方的總和值。</p>
<p>我們可以用簡單抽樣的方式來找出變異數，變異數公式如右 \((n-1) s^2 /  \sigma^2\)，其中 \((n-1)\) 就是自由度。<br>之後我們再利用變異數(卡方分配得出)跟區間估計來做假設檢定。</p>
<ul>
<li>不懂假設統計可看<a href="https://theriseofdavid.github.io/2021/02/27/NTUT_note/statistics-ch9/" target="_blank" rel="noopener">統計學(二) 筆記 - 第九章 假說檢定(hypothesis testing)</a></li>
</ul>
<blockquote>
<p>自由度的卡方分配，越左越小<br><img src="https://drive.google.com/u/2/uc?id=1xHzXpmjrJLw8IspGsf6qzOV1fjHFFsdS&export=download" alt=""></p>
</blockquote>
<h2 id="Interval-Estimation-of-sigma-2"><a href="#Interval-Estimation-of-sigma-2" class="headerlink" title="Interval Estimation of \(\sigma^2 \)"></a>Interval Estimation of \(\sigma^2 \)</h2><blockquote>
<p>區間估計的示意圖<br><img src="https://drive.google.com/u/2/uc?id=16gKYJqMMApIvAQ3QGoYIE-yiB3DeT6Ue&export=download" alt=""></p>
</blockquote>
<ul>
<li>下面所有的 \(X^2\) 指的都是方分配的變異數</li>
<li>因此我們會有 \(1-a\) 的機率 \(X^2\) 的值會落在 \(X^2_{1-a/2} \leq X^2 \leq X^2_{a/2}\)</li>
<li>再來我們把變異數公式 \((n-1) s^2 /  \sigma^2\) 帶入 \(X^2\) 就變成 \(X^2_{1-a/2} \leq \frac{(n-1) s^2}{\sigma^2} \leq  X^2_{a/2}\)</li>
<li>稍微移項(倒數)後就變成 \(\frac{(n-1) s^2}{X^2_{a/2}} \leq \sigma^2 \leq \frac{(n-1) s^2}{X^2_{1-a/2}} \)</li>
<li>因此母體變異數區間估計就是 \(\frac{(n-1) s^2}{X^2_{a/2}} \leq \sigma^2 \leq \frac{(n-1) s^2}{X^2_{1-a/2}} \)，其中\(n-1\)就是自由度</li>
</ul>
<p>那如果我們要找出母體標準差的區間估計呢？<br>就將剛剛的最後的式子開根號即可 \(\sqrt{\frac{(n-1) s^2}{X^2_{a/2}}} \leq \sigma \leq \sqrt{\frac{(n-1) s^2}{X^2_{1-a/2}}} \)</p>
<h3 id="舉例：我們想要購買-A-廠商的恆溫器，我們在一個調查中得知，當在一個房間裡面設定-68度F-時，10-個恆溫器的實際數值如下，我們想要知道在百分之-95-的信心水準中母體變異數的區間估計是多少？"><a href="#舉例：我們想要購買-A-廠商的恆溫器，我們在一個調查中得知，當在一個房間裡面設定-68度F-時，10-個恆溫器的實際數值如下，我們想要知道在百分之-95-的信心水準中母體變異數的區間估計是多少？" class="headerlink" title="舉例：我們想要購買 A 廠商的恆溫器，我們在一個調查中得知，當在一個房間裡面設定 68度F 時，10 個恆溫器的實際數值如下，我們想要知道在百分之 95% 的信心水準中母體變異數的區間估計是多少？"></a>舉例：我們想要購買 A 廠商的恆溫器，我們在一個調查中得知，當在一個房間裡面設定 68度F 時，10 個恆溫器的實際數值如下，我們想要知道在百分之 95% 的信心水準中母體變異數的區間估計是多少？</h3><blockquote>
<p>資料如下<br><img src="https://drive.google.com/u/2/uc?id=1kZeoMsm26Zd8zxvZIwEmFX_81I_wuDEc&export=download" alt=""></p>
</blockquote>
<p>因此我們的自由度是 \(n-1=10-1=9, a = 0.05\)</p>
<ul>
<li>查表如下，注意是從右尾開始算<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1euYFYmMeZNZiZKdailEkQt2s68Mux6uB&export=download" alt=""></p>
</blockquote>
</li>
<li>用手機 Probability Distribution App 查找如下，注意是從右尾開始算<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1XLaH6uCL1juNtBevPBgQONToJ4GdUx-O&export=download" alt=""></p>
</blockquote>
</li>
<li>因此我們可以得出 \(X^{0.975}\) 值是 2.700，再來我們要找 \(X^{0.025}\) 的值，下面用圖表示<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1VRXVCsQHQ6a2SZCgVAceaM2XFcPlZbKl&export=download" alt=""></p>
</blockquote>
</li>
<li>跟上面用的方法一樣，用手機 Probability Distribution App 查找\(X^{0.025}\) 的值是 19.023</li>
<li>用圖表來所示<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1OylgZXuphkNJq1GESeKZcHom2eeKmVT4&export=download" alt=""></p>
</blockquote>
</li>
<li>再來我們算樣本標準差平方 \(s^2=\frac{\sum (x_i - \bar{x})^2}{n-1} = \frac{6.3}{9} = 0.70\)</li>
<li>接著我們把算好的卡方值拿出來用，因此在 95% 的信賴區間中 \(\frac{(10-1) 0.70}{19.023} \leq \sigma^2 \leq \frac{(10-1) 0.70}{2.700}\)，也就是 \(0.33 \leq \sigma^2 \leq 2.33\)</li>
</ul>
<h2 id="Hypothesis-Testing"><a href="#Hypothesis-Testing" class="headerlink" title="Hypothesis Testing"></a>Hypothesis Testing</h2><ul>
<li>定義對立假設與虛無假設<ul>
<li>左尾<ul>
<li>\(H_0: \sigma^2 \geq \sigma_0^2\)</li>
<li>\(H_1: \sigma^2 &lt; \sigma_0^2\)</li>
<li>其中 \(\sigma_0^2\) 是我們假設檢定中假設的母體變異數</li>
</ul>
</li>
<li>右尾<ul>
<li>\(H_0: \sigma^2 \leq \sigma_0^2\)</li>
<li>\(H_1: \sigma^2 &gt; \sigma_0^2\)</li>
<li>其中 \(\sigma_0^2\) 是我們假設檢定中假設的母體變異數</li>
</ul>
</li>
<li>雙尾<ul>
<li>\(H_0: \sigma^2 = \sigma_0^2\)</li>
<li>\(H_1: \sigma^2 != \sigma_0^2\)</li>
<li>其中 \(\sigma_0^2\) 是我們假設檢定中假設的母體變異數</li>
</ul>
</li>
</ul>
</li>
<li>T 檢定的公式為 \(X^2 = \frac{(n-1)s^2}{\sigma_0^2}\)</li>
<li>拒絕法則 Rejection Rule<ul>
<li>左尾<ul>
<li>p-value approach<br>Reject \(H_0\) if \(p-value \leq a\)</li>
<li>Critical Value approach<br>Reject \(H_0\) if \(X^2 \leq X_{1-a}^2\)</li>
</ul>
</li>
<li>右尾<ul>
<li>p-value approach<br>Reject \(H_0\) if \(p-value \leq a\)</li>
<li>Critical Value approach<br>Reject \(H_0\) if \(X^2 \leq X_{a}^2\)</li>
</ul>
</li>
<li>雙尾<ul>
<li>p-value approach<br>Reject \(H_0\) if \(p-value \leq a\)</li>
<li>Critical Value approach<br>Reject \(H_0\) if \(X^2 \leq X_{1-a/2}^2\) or \(X^2 \geq X_{a}^2\)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="舉例：我們想要購買-A-廠商的恆溫器，我們在一個調查中得知，當在一個房間裡面設定-68度F-時，10-個恆溫器的實際數值如下，我們想要知道在百分之-90-的信心水準中母體變異數要小於等於-0-5-題目設定，但沒有在圖片說"><a href="#舉例：我們想要購買-A-廠商的恆溫器，我們在一個調查中得知，當在一個房間裡面設定-68度F-時，10-個恆溫器的實際數值如下，我們想要知道在百分之-90-的信心水準中母體變異數要小於等於-0-5-題目設定，但沒有在圖片說" class="headerlink" title="舉例：我們想要購買 A 廠商的恆溫器，我們在一個調查中得知，當在一個房間裡面設定 68度F 時，10 個恆溫器的實際數值如下，我們想要知道在百分之 90% 的信心水準中母體變異數要小於等於 0.5(題目設定，但沒有在圖片說)"></a>舉例：我們想要購買 A 廠商的恆溫器，我們在一個調查中得知，當在一個房間裡面設定 68度F 時，10 個恆溫器的實際數值如下，我們想要知道在百分之 90% 的信心水準中母體變異數要小於等於 0.5(題目設定，但沒有在圖片說)</h3><p>圖片所示</p>
<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=19LkXBKWQNeLCPkTMspXs3D6uVrQZvZ2w&export=download" alt=""></p>
</blockquote>
<p>其中 Buyer’s Digest 為 A 廠商</p>
<ul>
<li><p>因此定義對立假設與虛無假設</p>
<ul>
<li>\(H_0: \sigma^2 \leq 0.5\)</li>
<li>\(H_1: \sigma^2 &gt; 0.5\)</li>
</ul>
</li>
<li><p>右尾檢定，透過 Probability Distribution App 查找，\(v=9, P(X&gt;x) =0.1 \) 時，\(X_{1-a}^2 = 14.864\)，因此值要大於 \(X^2 \geq 14.864\)，才能證明 \(H_1\) 是對的。</p>
</li>
<li><p>計算 t 檢定的公式 \(X^2 = \frac{(n-1)s^2}{\sigma_0^2} =\frac{9(0.7)}{0.5} = 12.6\)</p>
</li>
<li><p>用圖表來表示</p>
<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=169KEeNO4n37q1KlT5lyvnQhUvspZakMa&export=download" alt=""></p>
</blockquote>
</li>
<li><p>p-Value Approach<br>卡方值的 12.6 機率為 0.18156，比我們的顯著性水準 0.1 還高，因此沒有證據顯示他們的恆溫器有變異數過大的問題。</p>
</li>
<li><p>Critical Value Approach<br>根據前一個舉例我們有計算過的樣本變異數 \(s^2 =0.7\)，\(X^2=\frac{9(0.7)}{5} = 12.6\)<br>\(12.6 \leq 14.864\)，因此我們拒絕 \(H_0\)，因此我們沒有證據顯示他們的恆溫器有變異數過大的問題。</p>
</li>
</ul>
<h1 id="推論兩組母體變異數-Inference-About-Two-Population-Variances"><a href="#推論兩組母體變異數-Inference-About-Two-Population-Variances" class="headerlink" title="推論兩組母體變異數(Inference About Two Population Variances)"></a>推論兩組母體變異數(Inference About Two Population Variances)</h1><p>蒐集兩個獨立母體的樣本，透過這兩個母體樣本就可以對這兩個母體進行推論。</p>
<ul>
<li>左尾的假設檢定<ul>
<li>\(H_0: \sigma_1^2 \geq \sigma_2^2\)</li>
<li>\(H_1: \sigma_1^2 &lt; \sigma_2^2\)</li>
<li>通常會將比較大的樣本變異數設定為 population1</li>
</ul>
</li>
<li>右尾的假設檢定<ul>
<li>\(H_0: \sigma_1^2 \leq \sigma_2^2\)</li>
<li>\(H_1: \sigma_1^2 &gt; \sigma_2^2\)</li>
<li>通常會將比較大的樣本變異數設定為 population1</li>
</ul>
</li>
<li>雙尾的假設檢定<ul>
<li>\(H_0: \sigma_1^2 = \sigma_2^2\)</li>
<li>\(H_1: \sigma_1^2 != \sigma_2^2\)</li>
<li>通常會將比較大的樣本變異數設定為 population1</li>
</ul>
</li>
<li>F 檢定公式為 \(F = \frac{s_1^2}{s_2^2}\)<br>此公式會有兩個自由度，因為有兩個母體。第一個母體為分子\(s_1\)、第二個母體為分母\(s_2\)。</li>
<li>拒絕法則 Rejection Rule<ul>
<li>左尾<ul>
<li>p-value approach<br>Reject \(H_0\) if \(p-value \leq a\)</li>
<li>Critical Value approach<br>Reject \(H_0\) if \(F \geq F_a\)</li>
</ul>
</li>
<li>右尾<ul>
<li>p-value approach<br>Reject \(H_0\) if \(p-value \leq a\)</li>
<li>Critical Value approach<br>Reject \(H_0\) if \(F \geq F_a\)</li>
</ul>
</li>
<li>雙尾<ul>
<li>p-value approach<br>Reject \(H_0\) if \(p-value \leq a\)</li>
<li>Critical Value approach<br>Reject \(H_0\) if \(F \geq F_{a/2}\)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="舉例：我們想要購買恆溫器，有-A、B-公司兩家，在顯著性水準為-0-1-時，我們想要知道他們的變異數是不是一樣，資料在下方"><a href="#舉例：我們想要購買恆溫器，有-A、B-公司兩家，在顯著性水準為-0-1-時，我們想要知道他們的變異數是不是一樣，資料在下方" class="headerlink" title="舉例：我們想要購買恆溫器，有 A、B 公司兩家，在顯著性水準為 0.1 時，我們想要知道他們的變異數是不是一樣，資料在下方"></a>舉例：我們想要購買恆溫器，有 A、B 公司兩家，在顯著性水準為 0.1 時，我們想要知道他們的變異數是不是一樣，資料在下方</h2><p>圖片所示</p>
<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1aWlaP0afdYMF4mviGq5sWaOfVo39rv3W&export=download" alt=""></p>
</blockquote>
<p>其中 thermoRite 為 B 公司、TempKing 為 A 公司，因為 B 公司的樣本變異數比較大(1.768)，A 公司約 0.7</p>
<ul>
<li>因此定義對立假設與虛無假設<ul>
<li>\(H_0: \sigma_1^2 = \sigma_2^2\)</li>
<li>\(H_1: \sigma_1^2 != \sigma_2^2\)</li>
</ul>
</li>
<li>拒絕法則 Rejection Rule<ul>
<li>由於是雙尾，因此 顯著性水準為 \(0.1 / 2 = 0.05\)，兩個都是 9 自由度。</li>
<li>用 Probability Distribution App 計算如下<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1t9KilhfMGm59ekfVPpRUZTSHnLJKXB5i&export=download" alt=""></p>
</blockquote>
</li>
<li>用查表的方式<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=18BdfbAATxmWCpjw3xDMCNaV_MhH8OLyi&export=download" alt=""></p>
</blockquote>
</li>
<li>第一個是 A 公司的自由度，第二是 B 公司的自由度，p 的機率是 0.05，我們可以得出\(F_{0.05} = 3.18\)，因此如果要 reject \(H_0\) if \(F \geq 3.18 \)</li>
</ul>
</li>
<li>t 檢定公式為 \(F = \frac{s_1^2}{s_2^2}\)，其中 A 公司的數值為 1.768，B 公司的數值為 0.7，因此 \(F = 1.768 / 0.7 = 2.53\)</li>
<li>p-value Approach<ul>
<li>透過 Probability Distribution App 計算 \(F=2.53 \) 時機率為 0.09，但因為是雙尾，因此我們要將機率乘二變為 0.18，\(a = 0.05 &lt; p-value = 0.18\)，因此我們不拒絕 \(H_0\)</li>
<li>因此我們沒有辦法證明兩家公司恆溫器的變異數是不同的。</li>
</ul>
</li>
<li>Critical Value Approach<ul>
<li>因此我們不可以拒絕 \(H_0\)，因為 \(F=2.53 &lt; F_{0.05} = 3.18\)</li>
<li>因此我們沒有辦法證明兩家公司恆溫器的變異數是不同的。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>北科上課筆記</category>
        <category>統計 statistics</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>統計學筆記</tag>
        <tag>北科大二下統計學筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>統計學(一) 筆記 - 大二上第二次段考 (L4-L6)</title>
    <url>/2020/12/04/statistics/statistics-1081-mid/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊與財金管理系大二上統計學重點整理<br><font color="#dd0000">並非所有人都適用，部分對我而言稍加容易的內容並不會寫在此內。</font><br><strong>這是觀看影片心得後的筆記，老師上課可能不太適用會忘記抄到</strong></p>
</blockquote>
<a id="more"></a>

<h1 id="Chapter-4-Introduction-to-Probability-介紹機率"><a href="#Chapter-4-Introduction-to-Probability-介紹機率" class="headerlink" title="Chapter 4 Introduction to Probability (介紹機率)"></a>Chapter 4 Introduction to Probability (介紹機率)</h1><h2 id="名詞介紹"><a href="#名詞介紹" class="headerlink" title="名詞介紹"></a>名詞介紹</h2><ul>
<li>Random Experiments 隨機實驗</li>
<li>Counting Rules 計數規則</li>
<li>Assigning Probabilities 分配機率</li>
<li>Event 事件</li>
<li>Conditional Probability 條件機率</li>
<li>Bayes’ Theorem 貝式定理</li>
</ul>
<h2 id="Uncertainties-不確定性"><a href="#Uncertainties-不確定性" class="headerlink" title="Uncertainties 不確定性"></a>Uncertainties 不確定性</h2><p>管理人員對於不確定性的選擇進行分析，如</p>
<ul>
<li>提高物品售價時，銷售機會減少?</li>
<li>透過新的組裝方式會不會增加生產率</li>
<li>新投資獲利的機會會多少</li>
</ul>
<h2 id="Probability-機率"><a href="#Probability-機率" class="headerlink" title="Probability 機率"></a>Probability 機率</h2><ul>
<li>用數字表示事件發生的可能性</li>
<li>機率的值只會在 0 - 1 之間</li>
<li>機率值越靠近零表示越不容易發生</li>
<li>機率值越靠近一表示越容易發生</li>
</ul>
<h2 id="Statistical-Experiments-統計實驗"><a href="#Statistical-Experiments-統計實驗" class="headerlink" title="Statistical Experiments 統計實驗"></a>Statistical Experiments 統計實驗</h2><ul>
<li>統計學中的實驗概念與物理實驗不同</li>
<li>在統計實驗中，機率表示結果</li>
<li>即使實驗完全相同，出來的結果也有可能完全不同</li>
<li>統計實驗有時候又被稱為隨機實驗</li>
</ul>
<h2 id="Random-Experiment-and-Its-Sample-Space-隨機實驗與樣本空間"><a href="#Random-Experiment-and-Its-Sample-Space-隨機實驗與樣本空間" class="headerlink" title="Random Experiment and Its Sample Space 隨機實驗與樣本空間"></a>Random Experiment and Its Sample Space 隨機實驗與樣本空間</h2><ul>
<li>隨機實驗<br>產生一個明顯的實驗結果</li>
<li>樣本空間<br>所有實驗結果的集合(set)</li>
<li>樣本點<br>其中一個實驗結果的集合(set)的一個元素為 sample point(樣本點)</li>
</ul>
<h2 id="A-Counting-Rule-for-Multiple-Step-Experiments-多步驟的實驗技術"><a href="#A-Counting-Rule-for-Multiple-Step-Experiments-多步驟的實驗技術" class="headerlink" title="A Counting Rule for Multiple-Step Experiments 多步驟的實驗技術"></a>A Counting Rule for Multiple-Step Experiments 多步驟的實驗技術</h2><p>如果實驗中需要 k 個步驟，那假設第一步可能有 \(n_1\) 個結果，第二步有 \(n_2\) 個結果，依此類推，那實驗結果的總數為 \(n_1 * n_2 * … * n_k \)。</p>
<p>多步驟實驗的圖形表示大都是<strong>樹狀圖</strong></p>
<h3 id="舉例"><a href="#舉例" class="headerlink" title="舉例"></a>舉例</h3><blockquote>
<p><img src="/images/statistics-1081-mid/1.PNG" alt=""><br><img src="/images/statistics-1081-mid/2.PNG" alt=""></p>
</blockquote>
<h3 id="Counting-Rule-for-Combinations-計數規則的組合"><a href="#Counting-Rule-for-Combinations-計數規則的組合" class="headerlink" title="Counting Rule for Combinations 計數規則的組合"></a>Counting Rule for Combinations 計數規則的組合</h3><p>使用 Combinations 進行計數，在 \(N\) 個實驗中拿出 \( n \) 個結果，則使用 \(C_n^N = \frac{N!}{n!(N-n)!}\)</p>
<p><strong>組合是沒有注意順序的，即 1,2,3 與 1,3,2 視為相同</strong></p>
<h3 id="Counting-Rule-for-Permutations-計數規則的排列"><a href="#Counting-Rule-for-Permutations-計數規則的排列" class="headerlink" title="Counting Rule for Permutations 計數規則的排列"></a>Counting Rule for Permutations 計數規則的排列</h3><p>使用 Permutations 進行計數，在 \(N\) 個實驗中拿出 \(n\) 個結果，使用 \(P_n^N = \frac{N!}{(N-n)!}\)</p>
<p><strong>組合是有注意順序的，即 1,2,3 與 1,3,2 不相同</strong></p>
<h2 id="Assigning-Probabilities-指派機率"><a href="#Assigning-Probabilities-指派機率" class="headerlink" title="Assigning Probabilities 指派機率"></a>Assigning Probabilities 指派機率</h2><h3 id="Basic-Requirements-for-Assigning-Probabilities"><a href="#Basic-Requirements-for-Assigning-Probabilities" class="headerlink" title="Basic Requirements for Assigning Probabilities"></a>Basic Requirements for Assigning Probabilities</h3><ul>
<li>每一個實驗結果機率都必須介於 0-1 之間</li>
<li>所有的實驗結果相加起來必等於 1 </li>
</ul>
<h3 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h3><ul>
<li>Classical Method<br>將所有的實驗結果機率<strong>平均</strong>分配，分配為 \(1 \ n \)</li>
<li>Relative Frequency Method<br>根據<strong>實驗或歷史數據</strong>分配機率，通常是用百分比進行分配</li>
<li>Subjective Method 主觀方法<br>透過<strong>主觀方式</strong>分配機率，爽，想怎麼分配就怎麼分配</li>
<li>通常會結合上面三種方法，來找到最正確的實驗結果機率</li>
</ul>
<h2 id="Events-and-Their-Probabilities-事件與他們的機率"><a href="#Events-and-Their-Probabilities-事件與他們的機率" class="headerlink" title="Events and Their Probabilities 事件與他們的機率"></a>Events and Their Probabilities 事件與他們的機率</h2><ul>
<li>事件是樣本點的集合</li>
<li>每一個事件的機率等同於此事件總和的樣本點機率，如：事件 A 發生機率是 40%，那 A 事件中的每個樣本點發生機率總和一定等於 40%</li>
<li>如果我們可以識別實驗中的每個樣本點並幫她分配機率，就可以算出此事件的機率</li>
<li>事件 = 樣本空間每一個元素分配到的機率</li>
</ul>
<h2 id="Some-Basic-Relationships-of-Probability-機率的基本觀念"><a href="#Some-Basic-Relationships-of-Probability-機率的基本觀念" class="headerlink" title="Some Basic Relationships of Probability 機率的基本觀念"></a>Some Basic Relationships of Probability 機率的基本觀念</h2><ul>
<li>Complement (餘集)<blockquote>
<p><img src="/images/statistics-1081-mid/3.PNG" alt=""></p>
</blockquote>
</li>
<li>Union 聯集<ul>
<li>Addition Law(加法律)<br>\(P(A \cup B) = P(A) + P(B) - P(A \cap B) \)<blockquote>
<p><img src="/images/statistics-1081-mid/4.PNG" alt="">  </p>
</blockquote>
</li>
</ul>
</li>
<li>Intersection 交集<ul>
<li>Multiplication Law(乘法律)<br>\(P(A \cap B) = P(B)P(A|B) = P(A)P(B|A) \)，其中 \(P(A|B)\)為<a href="#Conditional-Probability-條件機率">條件機率</a><blockquote>
<p><img src="/images/statistics-1081-mid/6.PNG" alt=""></p>
</blockquote>
</li>
</ul>
</li>
<li>Mutually Exclusive 互斥<ul>
<li>如果一個事件發生，那另外一個事件就一定無法發聲</li>
<li>Addition Law(加法律)<br>\(P(A \cup B ) = P(A) + P(B) \)<blockquote>
<p><img src="/images/statistics-1081-mid/7.PNG" alt=""></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="Conditional-Probability-條件機率"><a href="#Conditional-Probability-條件機率" class="headerlink" title="Conditional Probability 條件機率"></a>Conditional Probability 條件機率</h2><p>一個事件(A)中又發生另外一個事件(B)的機率稱為條件機率，例如選出撲克牌為偶數(A)且大於 6 (B)的機率是多少</p>
<p>條件機率符號通常用 \(P(A|B) \)，計算方式為 \(P(A|B) = \frac{P(A \cap B)}{P(B)}\)</p>
<h3 id="Joint-Probability-Table-聯合機率表"><a href="#Joint-Probability-Table-聯合機率表" class="headerlink" title="Joint Probability Table 聯合機率表"></a>Joint Probability Table 聯合機率表</h3><ul>
<li>Joint Probabilities 出現在表格的主體，即 1 處</li>
<li>Marginal Probabilties(邊際機率，即單獨只看某事件的機率)通常在表格的邊界，即 2 處<blockquote>
<p><img src="/images/statistics-1081-mid/8.PNG" alt=""></p>
</blockquote>
</li>
</ul>
<h3 id="Independent-Events-獨立事件"><a href="#Independent-Events-獨立事件" class="headerlink" title="Independent Events 獨立事件"></a>Independent Events 獨立事件</h3><p>如果 A 事件不會影響到 B 事件，我們就說 A 跟 B 是獨立事件，因此可以這樣表達 \(P(A|B) = P(A) \) or \(P(B|A) = P(B) \)</p>
<ul>
<li>multiplication law 乘法律 <ul>
<li>此 Law 也可以用來驗證這兩個事件是不是獨立事件</li>
<li>如果是獨立事件則乘法律出來的答案應該是 \(P(A \cap B ) = P(A)P(B) \)<br><a href="#Some-Basic-Relationships-of-Probability-機率的基本觀念">multiplication law 乘法律</a>公式可以點擊此連結並移到下方的<strong>Intersection 交集</strong></li>
</ul>
</li>
</ul>
<h3 id="Mutual-Exclusiveness-and-Independence-互斥與獨立"><a href="#Mutual-Exclusiveness-and-Independence-互斥與獨立" class="headerlink" title="Mutual Exclusiveness and Independence 互斥與獨立"></a>Mutual Exclusiveness and Independence 互斥與獨立</h3><ul>
<li>互斥事件與獨立事件<strong>不同</strong></li>
<li>機率大於 0 的兩個事件不會<strong>同時</strong>有互斥與獨立，即兩個事件只要機率 \(&gt; 0\)，就表示一定有關係</li>
<li>如果知道事件 A , B 是互斥事件，當 A 發生時 B 不會發生，因此他們是有相關的，並不是<strong>獨立事件</strong>，因為會互相影響</li>
<li>如果事件 A , B 不是互斥事件，那他們<strong>有可能是</strong>獨立事件</li>
</ul>
<h2 id="Bayes’-Theorem-貝式定理"><a href="#Bayes’-Theorem-貝式定理" class="headerlink" title="Bayes’ Theorem 貝式定理"></a>Bayes’ Theorem 貝式定理</h2><h3 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h3><blockquote>
<p><img src="/images/statistics-1081-mid/11.PNG" alt=""></p>
</blockquote>
<h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><p>根據已知的 A 機率推出 B 機率</p>
<p>流程圖如下：</p>
<blockquote>
<p><img src="/images/statistics-1081-mid/9.PNG" alt=""></p>
</blockquote>
<h3 id="舉例-1"><a href="#舉例-1" class="headerlink" title="舉例"></a>舉例</h3><p>在鎮上興建購物中心是一個很好的主意，可以帶來不錯的收益，但必須通過鎮公所的允許，否則不能建照。規畫委員會要向鎮公所提出建議，來獲得支持或反對興建購物中心</p>
<p>\(A_1 \) = 支持興建 , 機率為 0.7<br>\(A_2 \) = 反對興建 , 機率為 0.3</p>
<h4 id="situlation-A"><a href="#situlation-A" class="headerlink" title="situlation A"></a>situlation A</h4><p>目前規畫委員會建議不要興建購物中心(B)，此事件的發生會不會影響到鎮公所支持或反對興建購物中心的機率?</p>
<p>根據過去歷史 \(P(B|A_1)=0.2\) and \(P(B|A_2)=0.9\)</p>
<p>我們可以透過歷史推出 \(P(B_C | A_1) = 0.8 \) and \(P(B_C | A_2) = 0.1 \)</p>
<p>樹狀圖則如下：</p>
<blockquote>
<p><img src="/images/statistics-1081-mid/10.PNG" alt=""></p>
</blockquote>
<p>根據我們規畫委員會的建議後，我們可以得出<br>\(P(A_1 |B) = \frac{P(A_1)P(B|A_1)}{P(A_1)P(B|A_1) + P(A_2)P(B|A_2)} \\ = \frac{(0.7)(0.2)}{(0.7)(0.2) + (0.3)(0.9)} = 0.34 \)</p>
<p>其中 \(P(B) = P(A_1 \cap B) + P(A_2 \cap B) \)</p>
<h4 id="conclusion-A-1"><a href="#conclusion-A-1" class="headerlink" title="conclusion A-1"></a>conclusion A-1</h4><p>這對不想要興建購物中心的人認為是一個好消息，因為從原本支持興建的機率 0.7 降至 0.34</p>
<p>透過表來解讀則是</p>
<ul>
<li>(4) 是表示在歷史資料中遇到的情況去乘這次的情況，來說明這次有可能成功的機率，但必須注意的是小數相乘會越來越小，因此不可以透過 14% 去算，分母已經不再是 1 了</li>
<li>P(B) 則表示這兩種可能總共的機率</li>
<li>(5) 再來則是透過 P(B) 來找出每一個 \(P(A_i)\) 的機率<blockquote>
<p><img src="/images/statistics-1081-mid/11.PNG" alt=""><br><img src="/images/statistics-1081-mid/12.PNG" alt=""></p>
</blockquote>
</li>
</ul>
<h1 id="Chapter-5-Discrete-Probability-Distributions-離散機率分配"><a href="#Chapter-5-Discrete-Probability-Distributions-離散機率分配" class="headerlink" title="Chapter 5 Discrete Probability Distributions 離散機率分配"></a>Chapter 5 Discrete Probability Distributions 離散機率分配</h1><p>Discrete random variable(離散隨機變數) 為有限數量或無限數量的序列值，且可以透過圖表、公式、表格來描述離散的機率分布</p>
<h2 id="甚麼時機用-Discrete-Probability-Distributions，進行舉例"><a href="#甚麼時機用-Discrete-Probability-Distributions，進行舉例" class="headerlink" title="甚麼時機用 Discrete Probability Distributions，進行舉例"></a>甚麼時機用 Discrete Probability Distributions，進行舉例</h2><ul>
<li>一個家庭有多少個小孩，Infinite Sequence</li>
<li>家裡有沒有狗或貓，有這四種結果，有狗、有貓、沒有狗貓、有狗貓， finite Sequences</li>
<li><strong>在此時則不可以使用 Discrete Probability Distributions</strong><br>詢問台北到高雄的距離，此時要使用 Continuous </li>
</ul>
<h2 id="Random-Variables"><a href="#Random-Variables" class="headerlink" title="Random Variables"></a>Random Variables</h2><p>隨機變數是透過數值描述實驗結果，類似樣本空間隨機抽樣本點 </p>
<h2 id="Type-Of-discrete-probability-distributions"><a href="#Type-Of-discrete-probability-distributions" class="headerlink" title="Type Of discrete probability distributions"></a>Type Of discrete probability distributions</h2><ul>
<li>First Type<br>透過規則將實驗結果的機率指定並確定給每一個隨機變數</li>
<li>Second Type<br>透過數學公式給予每一個隨機變數值的機率</li>
</ul>
<h2 id="probability-function-機率函數"><a href="#probability-function-機率函數" class="headerlink" title="probability function 機率函數"></a>probability function 機率函數</h2><p><strong>機率分布</strong>透過<strong>機率函數 \(f(x) \)</strong>定義，為該函數的隨機變數每一個值提供機率，並且 \(f(x) \geq 0 \) and \(\Sigma f(x) = 1\)</p>
<p>通常透過三種方式來指派機率給予隨機變數，<a href="#Method">古典法、主觀法、頻率關聯法</a>，透過頻率關聯法的稱為 empirical discrete distribution (實證離散分布)</p>
<h2 id="discrete-probability-distributions-specified-by-formulas-離散機率分布公式"><a href="#discrete-probability-distributions-specified-by-formulas-離散機率分布公式" class="headerlink" title="discrete probability distributions specified by formulas (離散機率分布公式)"></a>discrete probability distributions specified by formulas (離散機率分布公式)</h2><p>除了圖表與表格外，通常會有公式來給予機率函數的每一個值(x)指定機率，來描述離散分布</p>
<h3 id="下面是機率公式，適合的應用範圍"><a href="#下面是機率公式，適合的應用範圍" class="headerlink" title="下面是機率公式，適合的應用範圍"></a>下面是機率公式，適合的應用範圍</h3><table>
<thead>
<tr>
<th>機率公式</th>
<th>應用情況</th>
</tr>
</thead>
<tbody><tr>
<td><a href="#discrete-uniform-離散均勻">離散均勻</a></td>
<td>發生n次 則每一次的機率就是1/n</td>
</tr>
<tr>
<td><a href="#binomial-二項">二項</a></td>
<td>求在 n 是實驗中 x 次成功才能達到期望結果的機率</td>
</tr>
<tr>
<td><a href="#negative-binomial-負二項">負二項</a></td>
<td>需要x 次實驗才能夠達到期望結果的機率</td>
</tr>
<tr>
<td><a href="#geometric-幾何">幾何</a></td>
<td>在第一次成功的次數</td>
</tr>
<tr>
<td><a href="#Poisson-卜瓦松">卜瓦松</a></td>
<td>在特定的空間(或單點)內發生次數(離散)的機率</td>
</tr>
<tr>
<td><a href="#hypergeometric-超幾何">超幾何</a></td>
<td>N次試驗中成功的機率(但取後不放回)</td>
</tr>
<tr>
<td><a href="#Exponential-Probability-Distribution-指數機率分配">指數機率</a></td>
<td>詢問區間中的<strong>連續</strong>變數機率</td>
</tr>
<tr>
<td><a href="#Normal-Probability-Distribution-常態機率分布">常態機率分布</a></td>
<td>最常用的機率分布之一，通常題目會告訴要用此公式</td>
</tr>
</tbody></table>
<h3 id="期望值-E-x"><a href="#期望值-E-x" class="headerlink" title="期望值 \(E(x) \)"></a>期望值 \(E(x) \)</h3><ul>
<li>在離散機率分布中，期望值與平均值為一樣，公式為 \(E(x) = \mu = \Sigma x f(x) \)</li>
<li>期望值是隨機變數的加權平均，權重則是隨機變數的機率</li>
<li>期望值<strong>不是隨機變數可以設定的值</strong></li>
</ul>
<h3 id="Variance-and-Standard-Deviation-變異數與標準差"><a href="#Variance-and-Standard-Deviation-變異數與標準差" class="headerlink" title="Variance and Standard Deviation 變異數與標準差"></a>Variance and Standard Deviation 變異數與標準差</h3><ul>
<li>變異數公式為 \(Var(x) = \sigma^2 = \Sigma(x-\mu)^2 f(x) \)</li>
<li>變異數是隨機變數值減去平均值(期望值)次方在乘機率的加權平均，權重則是隨機變數的機率</li>
<li>標準差 \(\sigma \)，是變異數開平方的值</li>
</ul>
<h2 id="discrete-uniform-離散均勻"><a href="#discrete-uniform-離散均勻" class="headerlink" title="discrete-uniform 離散均勻"></a>discrete-uniform 離散均勻</h2><ul>
<li>The discrete uniform probability distributionis 是數學公式中最簡單的離散機率分布</li>
<li>公式為 \(f(x) = 1 / n \)，n = 隨機變數的總和 </li>
<li>基本上每一個隨機變數的值都很有可能相同</li>
<li><blockquote>
<p><img src="/images/statistics-1081-mid/13.PNG" alt=""></p>
</blockquote>
</li>
</ul>
<h2 id="Bivariate-二元"><a href="#Bivariate-二元" class="headerlink" title="Bivariate 二元"></a>Bivariate 二元</h2><ul>
<li>涉及兩個隨機變數的機率分配時可以使用 bivariate probability distribution</li>
<li>每一個實驗結果都有兩個值，一個隨機變數</li>
<li>通常我們在使用此機率分布時，我們會對於<strong>隨機變數與另一隨機變數的關聯性</strong>產生興趣</li>
</ul>
<h3 id="舉例-A-員工滿意度"><a href="#舉例-A-員工滿意度" class="headerlink" title="舉例 A - 員工滿意度"></a>舉例 A - 員工滿意度</h3><p>舉例有 200 位員工對他的工作滿意度與福利待遇進行調查，如下圖</p>
<blockquote>
<p><img src="/images/statistics-1081-mid/14.PNG" alt=""><br><img src="/images/statistics-1081-mid/15.PNG" alt=""><br><img src="/images/statistics-1081-mid/16.PNG" alt=""><br><img src="/images/statistics-1081-mid/18.PNG" alt=""><br><img src="/images/statistics-1081-mid/19.PNG" alt=""></p>
</blockquote>
<h3 id="Covariance-共變異數"><a href="#Covariance-共變異數" class="headerlink" title="Covariance 共變異數"></a>Covariance 共變異數</h3><p>公式：\(\sigma_{xy} = [ Var(x+y) - Var(x) - Var(y)] /2 \) or \(\sigma_{xy} =  \Sigma_{i,j} [ x_i - E(x_i) ] [y_i - E(y_i) ] f(x_i,y_i)\)</p>
<h3 id="Correlation-Coefficient-相關係數"><a href="#Correlation-Coefficient-相關係數" class="headerlink" title="Correlation Coefficient 相關係數"></a>Correlation Coefficient 相關係數</h3><p>公式 \(\rho_{xy} = \frac{\sigma_{xy}}{\sigma_x \sigma_y}\)</p>
<ul>
<li>延續剛剛的舉例，如圖：<blockquote>
<p><img src="/images/statistics-1081-mid/21.PNG" alt=""></p>
</blockquote>
</li>
</ul>
<h3 id="舉例-B-金融資產配置"><a href="#舉例-B-金融資產配置" class="headerlink" title="舉例 B - 金融資產配置"></a>舉例 B - 金融資產配置</h3><p>透過金融資產分配進行舉例</p>
<blockquote>
<p><img src="/images/statistics-1081-mid/22.PNG" alt=""></p>
</blockquote>
<ul>
<li><p>其中 a = 0.5 and b = 0.5 為我們資產配置各一半，其中共變異數將在下頁說明</p>
<blockquote>
<p><img src="/images/statistics-1081-mid/23.PNG" alt=""></p>
</blockquote>
</li>
<li><p>共變異數</p>
<blockquote>
<p><img src="/images/statistics-1081-mid/24.PNG" alt=""></p>
</blockquote>
</li>
<li><p>結果</p>
<blockquote>
<p><img src="/images/statistics-1081-mid/25.PNG" alt=""></p>
</blockquote>
</li>
<li><p>標準差為其投資組合風險，期望值為投資應能得到的報酬，實際獲利範圍應為\(期望值  * \pm 標準差 \)</p>
</li>
</ul>
<h2 id="binomial-二項"><a href="#binomial-二項" class="headerlink" title="binomial 二項"></a>binomial 二項</h2><ul>
<li>此公式可以找出在 y 次實驗中 x 次成功的機率分布</li>
<li>透過 n 個相同實驗組成</li>
<li>每一次的實驗都有兩個結果，成功或失敗</li>
<li>平穩性假設 (stationarity assumption)<br>成功的機率(p)，在每一項實驗都是獨立，亦即不會受到其他實驗影響</li>
<li>Probability Distributions APP - binomial<ul>
<li>n 實驗的次數</li>
<li>p 實驗的成功機率</li>
<li>x 我們想要知道的實驗成功次數<h3 id="舉例-員工離職"><a href="#舉例-員工離職" class="headerlink" title="舉例 - 員工離職"></a>舉例 - 員工離職</h3><blockquote>
<p><img src="/images/statistics-1081-mid/26.PNG" alt=""><br><img src="/images/statistics-1081-mid/27.PNG" alt=""></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p>需要注意的是員工<strong>只可以</strong>離職一次，因此我們找出員工的離職機率只可以是<strong>離職一次</strong>的機率</p>
<blockquote>
<p><img src="/images/statistics-1081-mid/28.PNG" alt=""><br><img src="/images/statistics-1081-mid/29.PNG" alt=""></p>
</blockquote>
<h3 id="Expected-Value-and-Variance-and-Standarad-Deviation"><a href="#Expected-Value-and-Variance-and-Standarad-Deviation" class="headerlink" title="Expected Value and Variance and Standarad Deviation"></a>Expected Value and Variance and Standarad Deviation</h3><ul>
<li>Excpected Value<br>\(E(x) = np = \mu \)</li>
<li>Variance<br>\(Var(x) = np(1-p) = \sigma^2 \)</li>
<li>Standard Deviation<br>\(\sigma = \sqrt{np(1-p)}\)</li>
<li>p 為我們想要得到的實驗結果機率</li>
</ul>
<h4 id="QUESTION-A-此-3-個員工明年會有一個人想要離職的機率是多少"><a href="#QUESTION-A-此-3-個員工明年會有一個人想要離職的機率是多少" class="headerlink" title="QUESTION A: 此 3 個員工明年會有一個人想要離職的機率是多少"></a>QUESTION A: 此 3 個員工明年會有一個人想要離職的機率是多少</h4><p>設 n = 3 , p = 0.1 , x = 1 再透過 Probability Distributions APP 可以得出 0.243 </p>
<blockquote>
<p><img src="/images/statistics-1081-mid/30.jpg" alt=""></p>
</blockquote>
<h2 id="negative-binomial-負二項"><a href="#negative-binomial-負二項" class="headerlink" title="negative binomial 負二項"></a>negative binomial 負二項</h2><ul>
<li>需要多少次的實驗才能達到我們的期望結果</li>
<li>每一次的實驗都有兩個結果，成功或失敗</li>
<li>透過 n 個相同實驗組成</li>
<li>平穩性假設 (stationarity assumption)<br>成功的機率(p)，在每一項實驗都是獨立，亦即不會受到其他實驗影響</li>
<li>實驗只會進行到<strong>第一次</strong>我們期望結果，就結束</li>
<li>Probability Distributions APP - <strong>binomial(2)</strong><ul>
<li>r 實驗成功的次數</li>
<li>p 實驗的成功機率</li>
<li>x 我們想要知道可以符合我們的實驗次數</li>
</ul>
</li>
</ul>
<h3 id="舉例-我們想要知道擲五次硬幣，有兩次正面的機率是多少，投擲正反面的機率都是-0-5"><a href="#舉例-我們想要知道擲五次硬幣，有兩次正面的機率是多少，投擲正反面的機率都是-0-5" class="headerlink" title="舉例 - 我們想要知道擲五次硬幣，有兩次正面的機率是多少，投擲正反面的機率都是 0.5"></a>舉例 - 我們想要知道擲五次硬幣，有兩次正面的機率是多少，投擲正反面的機率都是 0.5</h3><p>設 r = 2 , p = 0.5 , x = 5 再透過 Probability Distributions APP 可以得出 0.125</p>
<blockquote>
<p><img src="/images/statistics-1081-mid/31.jpg" alt=""></p>
</blockquote>
<h3 id="Expected-Value-and-Variance"><a href="#Expected-Value-and-Variance" class="headerlink" title="Expected Value and Variance"></a>Expected Value and Variance</h3><ul>
<li>Expected Value<br>\(E(x) = \mu = \frac{r}{p} \)</li>
<li>Variance<br>\(Var(x) = \sigma^2 = \frac{r(1-p)}{p^2}\)</li>
</ul>
<h2 id="geometric-幾何"><a href="#geometric-幾何" class="headerlink" title="geometric 幾何"></a>geometric 幾何</h2><ul>
<li>每一次的實驗都有兩個結果，成功或失敗</li>
<li>平穩性假設 (stationarity assumption)<br>成功的機率(p)，在每一項實驗都是獨立，亦即不會受到其他實驗影響</li>
<li>geometric 是 negative binomial 的特例</li>
<li>需要一次我們想要的期望結果的成功次數</li>
<li>如果將 negative binomial r = 1，即變成了 geometric</li>
<li>Probability Distributions APP - <strong>Geometric(2)</strong><ul>
<li>x 實驗 x 後第一次我們想要的結果出現</li>
<li>p 實驗的成功機率</li>
</ul>
</li>
</ul>
<h3 id="舉例-擲四次硬幣，前面三次都是反面，最後一次為正面的機率是多少，投擲正反面的機率都是-0-5"><a href="#舉例-擲四次硬幣，前面三次都是反面，最後一次為正面的機率是多少，投擲正反面的機率都是-0-5" class="headerlink" title="舉例 - 擲四次硬幣，前面三次都是反面，最後一次為正面的機率是多少，投擲正反面的機率都是 0.5"></a>舉例 - 擲四次硬幣，前面三次都是反面，最後一次為正面的機率是多少，投擲正反面的機率都是 0.5</h3><p>設 p = 0.5 , x = 4，再透過 Probability Distributions APP 可以得出 0.0625</p>
<blockquote>
<p><img src="/images/statistics-1081-mid/32.jpg" alt=""></p>
</blockquote>
<h3 id="Expected-Value-and-Variance-1"><a href="#Expected-Value-and-Variance-1" class="headerlink" title="Expected Value and Variance"></a>Expected Value and Variance</h3><ul>
<li>Expected Value<br>\(E(x) = \mu = \frac{1}{p} \)</li>
<li>Variance<br>\(Var(x) = \sigma^2 = \frac{(1-p)}{p^2}\)</li>
</ul>
<h2 id="Poisson-卜瓦松"><a href="#Poisson-卜瓦松" class="headerlink" title="Poisson 卜瓦松"></a>Poisson 卜瓦松</h2><ul>
<li>Poisson 通常用於一段區間或時間內發生的次數，為離散的隨機變數，可以是無限的序列，即 x 趨近於無限</li>
<li>Poisson 的二個性質<ul>
<li>在兩個相同長度但<strong>並不是同一個區間</strong>，發生的機率可能相同</li>
<li>發生與不發生為獨立事件，兩者沒有任何關係</li>
</ul>
</li>
<li>一個應用舉例關於 Poisson <ul>
<li>一小時內到達收費站的車輛數量</li>
</ul>
</li>
<li>Probability Distributions APP - <strong>Poisson</strong><ul>
<li>\(\lambda \) 平均值 or 期望值</li>
<li>x 一個區間發生的次數</li>
</ul>
</li>
</ul>
<h3 id="舉例-周末晚上通常每小時會有-6-個病人到急診室，想請問-30-分鐘內會有-4-個人到達的機率是多少"><a href="#舉例-周末晚上通常每小時會有-6-個病人到急診室，想請問-30-分鐘內會有-4-個人到達的機率是多少" class="headerlink" title="舉例 - 周末晚上通常每小時會有 6 個病人到急診室，想請問 30 分鐘內會有 4 個人到達的機率是多少"></a>舉例 - 周末晚上通常每小時會有 6 個病人到急診室，想請問 30 分鐘內會有 4 個人到達的機率是多少</h3><p>設 \(\lambda \) = 3 , x = 4 ，再透過 Probability Distributions APP 可以得出 0.16803</p>
<blockquote>
<p><img src="/images/statistics-1081-mid/33.jpg" alt=""></p>
</blockquote>
<h3 id="Expected-Value-and-Variance-2"><a href="#Expected-Value-and-Variance-2" class="headerlink" title="Expected Value and Variance"></a>Expected Value and Variance</h3><ul>
<li>Expected Value = Mean = \(\mu = \sigma^2 \)</li>
<li>Variance \(Var(x) = \sigma^2\)</li>
</ul>
<h2 id="hypergeometric-超幾何"><a href="#hypergeometric-超幾何" class="headerlink" title="hypergeometric 超幾何"></a>hypergeometric 超幾何</h2><ul>
<li>hypergeometric 可以找出 n 次實驗中成功的機率但實驗結果並不具有獨立性，且 x 趨近於無限</li>
<li>hypergeometric 的兩個性質<ul>
<li>與 binomial 相似</li>
<li><strong>但實驗不獨立</strong>，也就是前面做的實驗會影響到下一次的實驗</li>
</ul>
</li>
<li>Probability Distributions APP - <strong>hypergeometric</strong> <ul>
<li>x 為實驗成功次數</li>
<li>n 為我們希望發生的實驗次數</li>
<li>N 為實際上會有的實驗結果</li>
<li>M 為我們想知道的成功次數</li>
</ul>
</li>
<li>hypergeometric 限制<ul>
<li>我們想知道的成功次數不可以大於我們想知道的成功次數，即 \(x \leq M\)</li>
<li>\(n-x \leq N - M \)，即我們不想知道的失敗次數一定要<strong>大於或等於</strong>會失敗的次數</li>
<li>沒有滿足上面兩條件則機率必定是 0 </li>
</ul>
</li>
<li><strong>當母體極大時，可以使用 binomial 來近似</strong></li>
<li>hypergeometric 的其他變數，<strong>透過 binomial 來算出的變數</strong><ul>
<li>\(p = \frac{M}{N}\) 為第一次發生實驗成功的機率</li>
<li>如果母體值極大，也就表示 \((N-n) / (N-1) = 1 \)，極限的概念</li>
<li>Expect Value = \( E(x) = np\)</li>
<li>Variance = \(Var(x) = np(1-p) \)</li>
</ul>
</li>
</ul>
<h3 id="舉例-手中有兩顆沒電的電池與全新電池，現在隨機選擇兩顆電池，能拿到全新的電池機率是多少"><a href="#舉例-手中有兩顆沒電的電池與全新電池，現在隨機選擇兩顆電池，能拿到全新的電池機率是多少" class="headerlink" title="舉例 - 手中有兩顆沒電的電池與全新電池，現在隨機選擇兩顆電池，能拿到全新的電池機率是多少"></a>舉例 - 手中有兩顆沒電的電池與全新電池，現在隨機選擇兩顆電池，能拿到全新的電池機率是多少</h3><ul>
<li>x = 2 我們想知道選到兩顆好電池的機率</li>
<li>n = 2 我們隨機選擇兩顆電池</li>
<li>N = 4 這四顆電池我們都有機會拿到，因此我們的實驗結果會有 4 個</li>
<li>M = 2 其中成功的機率最高為 2 次，因為好電池只有兩顆</li>
<li>透過 Probability Distributions APP 可以得出 0.1667<blockquote>
<p><img src="/images/statistics-1081-mid/34.jpg" alt=""></p>
</blockquote>
</li>
</ul>
<h3 id="Expected-Value-and-Variance-3"><a href="#Expected-Value-and-Variance-3" class="headerlink" title="Expected Value and Variance"></a>Expected Value and Variance</h3><ul>
<li>Expected Value = Mean = \(\mu = n \frac{M}{N} \)</li>
<li>Variance \(Var(x) = \sigma^2 = n(\frac{M}{N})(1- \frac{M}{N})(\frac{N-n}{N-1})\)</li>
</ul>
<h1 id="Chapter-6-Continuous-Probability-Distributions-連續機率分布"><a href="#Chapter-6-Continuous-Probability-Distributions-連續機率分布" class="headerlink" title="Chapter 6 Continuous Probability Distributions 連續機率分布"></a>Chapter 6 Continuous Probability Distributions 連續機率分布</h1><p>Continuous random variable(連續隨機變數) 為一個區間的任何數值，特質為下</p>
<ul>
<li>沒辦法去討論特定的值，每一個點的機率都為零</li>
<li>連續機率分布討論隨機變量在區間中取值的機率</li>
<li>透過兩個點連線(\(x_1 , x_2 \))的區間為機率圖下的面積<ul>
<li>Uniform <blockquote>
<p><img src="/images/statistics-1081-mid/30.PNG" alt=""></p>
</blockquote>
</li>
<li>Normal <blockquote>
<p><img src="/images/statistics-1081-mid/31.PNG" alt=""></p>
</blockquote>
</li>
<li>Exponential <blockquote>
<p><img src="/images/statistics-1081-mid/32.PNG" alt=""></p>
</blockquote>
</li>
</ul>
</li>
<li>連續機率分布的變數，個人認為不太會用到，如果看之後的 ppt 會用到我在修正<ul>
<li>Probability density function</li>
</ul>
</li>
</ul>
<h2 id="Uniform-Probability-Distribution-均勻機率分配"><a href="#Uniform-Probability-Distribution-均勻機率分配" class="headerlink" title="Uniform Probability Distribution 均勻機率分配"></a>Uniform Probability Distribution 均勻機率分配</h2><ul>
<li>根據上方 Uniform 的圖 y 軸為 \(1/(b-a) \)，x 軸為單位刻度。</li>
<li>只要區間與機率成為正比，隨機變量就會均勻分布</li>
<li>公式<ul>
<li>\(f(x) = 1 / (b-a) , for \ a \leq x \leq b \\ = 0 , elsewhere \)</li>
<li>a 為最小的變數刻度</li>
<li>b 為最大的變數刻度</li>
</ul>
</li>
<li>Expected Value<ul>
<li>\(E(x) = (a+b) / 2\)</li>
<li>\(Var(x) = (b-a)^2 / 12 \)</li>
</ul>
</li>
</ul>
<h3 id="舉例-顧客通常測取沙拉的分量在-5-ounces-and-15-ounces-之間，在平均機率分布下客人拿取-12-ounces-15-ounces-機率多少"><a href="#舉例-顧客通常測取沙拉的分量在-5-ounces-and-15-ounces-之間，在平均機率分布下客人拿取-12-ounces-15-ounces-機率多少" class="headerlink" title="舉例 - 顧客通常測取沙拉的分量在 5 ounces and 15 ounces 之間，在平均機率分布下客人拿取 12 ounces ~ 15 ounces 機率多少"></a>舉例 - 顧客通常測取沙拉的分量在 5 ounces and 15 ounces 之間，在平均機率分布下客人拿取 12 ounces ~ 15 ounces 機率多少</h3><ul>
<li>畫圖如下<blockquote>
<p><img src="/images/statistics-1081-mid/33.PNG" alt=""></p>
</blockquote>
</li>
<li>現在要取 12 ounces ~ 15 ounces <blockquote>
<p><img src="/images/statistics-1081-mid/34.PNG" alt=""></p>
</blockquote>
</li>
<li>期望值就為 \((5+15)/2 = 10 \)</li>
<li>變異數就為 \((15-5)^2 / 12 = 8.33\)</li>
</ul>
<h2 id="Normal-Probability-Distribution-常態機率分布"><a href="#Normal-Probability-Distribution-常態機率分布" class="headerlink" title="Normal Probability Distribution 常態機率分布"></a>Normal Probability Distribution 常態機率分布</h2><ul>
<li>Normal Probability Distribution 是 Continuous Probability Distributions 的最重要理論</li>
<li>常被廣泛用於統計推論中，如：降雨量、成績</li>
<li>常態分配為對稱，沒有 skewness</li>
<li>圖形中的最高點為，mean、median、mode，圖形寬度隨著標準差拉大或拉小</li>
<li>經驗法則<ul>
<li>68.26% 的值會落在正負一個標準差</li>
<li>95.44% 的值會落在正負兩個標準差</li>
<li>99.72% 的值會落在正負三個標準差</li>
</ul>
</li>
<li>Probability Distributions APP - <strong>Normal</strong> <ul>
<li>\(\mu \) 平均值</li>
<li>\(\sigma \) 標準差</li>
<li>x 我們所要詢問的值</li>
</ul>
</li>
</ul>
<h3 id="Standard-Normal-Probability-Distribution-標準常態機率分布"><a href="#Standard-Normal-Probability-Distribution-標準常態機率分布" class="headerlink" title="Standard Normal Probability Distribution 標準常態機率分布"></a>Standard Normal Probability Distribution 標準常態機率分布</h3><p>當平均值等於零且標準差為一時，則是 Standard Normal Probability Distribution</p>
<ul>
<li>將常態機率分配轉換成標準常態機率分配，透過 z 來轉換<br>\(z = \frac{x-\mu }{\sigma}\)，</li>
<li>z 的值介於 1 ~ -1 之間，是標準常態分配的 x 軸</li>
</ul>
<h3 id="舉例-商店銷售機油，當機油庫存少於-20-gallons-時要補貨，經理不希望有缺貨的時機，目前確定標準差為-6、平均值為-15、使用常態分布，想詢問當需求訂單超過-20-gallons-時機率為多少"><a href="#舉例-商店銷售機油，當機油庫存少於-20-gallons-時要補貨，經理不希望有缺貨的時機，目前確定標準差為-6、平均值為-15、使用常態分布，想詢問當需求訂單超過-20-gallons-時機率為多少" class="headerlink" title="舉例 - 商店銷售機油，當機油庫存少於 20 gallons 時要補貨，經理不希望有缺貨的時機，目前確定標準差為 6、平均值為 15、使用常態分布，想詢問當需求訂單超過 20 gallons 時機率為多少"></a>舉例 - 商店銷售機油，當機油庫存少於 20 gallons 時要補貨，經理不希望有缺貨的時機，目前確定標準差為 6、平均值為 15、使用常態分布，想詢問當需求訂單超過 20 gallons 時機率為多少</h3><ul>
<li>畫圖<blockquote>
<p><img src="/images/statistics-1081-mid/35.PNG" alt=""></p>
</blockquote>
</li>
<li>透過 Probability Distributions APP 可以得出 0.2033<ul>
<li>\(\sigma = 6 \)</li>
<li>\(\mu = 15 \)</li>
<li>\(x &gt; 20 \)</li>
<li>圖片<blockquote>
<p><img src="/images/statistics-1081-mid/36.jpg" alt=""></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="舉例-承上一個舉例，經理希望缺貨的可能性不超過-0-05，那應該甚麼時候補貨"><a href="#舉例-承上一個舉例，經理希望缺貨的可能性不超過-0-05，那應該甚麼時候補貨" class="headerlink" title="舉例 - 承上一個舉例，經理希望缺貨的可能性不超過 0.05，那應該甚麼時候補貨"></a>舉例 - 承上一個舉例，經理希望缺貨的可能性不超過 0.05，那應該甚麼時候補貨</h3><p>我們可以透過標準常態機率分配，來找出適合的補貨點，需要使用到 <strong>z</strong>，來轉換成標準常態機率分配，因為經理已經說了希望缺貨的可能性不超過 0.05，透過查表的方式可以找出。<br>如果是透過手機，就用二分搜尋逼近 x 值即可</p>
<ul>
<li>查完表後，找到適合的 z 值，在帶回 z 函數，可以推出 \( x = \mu + z_0.05 * \sigma \)<blockquote>
<p><img src="/images/statistics-1081-mid/36.PNG" alt=""></p>
</blockquote>
</li>
</ul>
<h3 id="Normal-Approximation-of-Binomial-Probabilities-常態近似二項機率分配"><a href="#Normal-Approximation-of-Binomial-Probabilities-常態近似二項機率分配" class="headerlink" title="Normal Approximation of Binomial Probabilities 常態近似二項機率分配"></a>Normal Approximation of Binomial Probabilities 常態近似二項機率分配</h3><p>當實驗次數增加後，很難手動或使用計算機來計算二項式機率函數，常態近似二項機率分配可以幫助我們快速計算二項機率分布的值近似值，下面說說一些限制要求與條件。</p>
<ul>
<li>\(np \geq 5 \) </li>
<li>\(n(1-p) \geq 5 \)</li>
<li>\(\mu = np \)</li>
<li>\(\sigma = \sqrt{np(1-p)}\)</li>
<li>因為是使用連續分布來近似離散分布，所以要透過加減來校正因子<br>舉例，如果是要問 x = 12 時且單位量為 1 時，我們使用常態近似二項機率分配則要 \(P(11.5 &lt; x &lt; 12.5) \)，因為區間對於單位點的機率都是零</li>
</ul>
<h3 id="舉例-公司有-10-的發票記錄錯誤，隨機選了-100-張發票，試問裡面會有-12-張發票記錄錯誤的機率，使用常態近似二項機率分配"><a href="#舉例-公司有-10-的發票記錄錯誤，隨機選了-100-張發票，試問裡面會有-12-張發票記錄錯誤的機率，使用常態近似二項機率分配" class="headerlink" title="舉例 - 公司有 10% 的發票記錄錯誤，隨機選了 100 張發票，試問裡面會有 12 張發票記錄錯誤的機率，使用常態近似二項機率分配"></a>舉例 - 公司有 10% 的發票記錄錯誤，隨機選了 100 張發票，試問裡面會有 12 張發票記錄錯誤的機率，使用常態近似二項機率分配</h3><ul>
<li>先判斷是否有超過限制<ul>
<li>\( np = 100(0.1) = 10 \geq 5  \)，有符合</li>
<li>\(n(1-p) = 100(0.9) = 90 \geq 5 \)，有符合</li>
<li>\(\mu = np = 100(0.1) = 10 \))</li>
<li>\(\sigma = \sqrt{np(1-p)} = [100(0.1)(0.9)]^(\frac{1}{2}) = 3 \)</li>
</ul>
</li>
<li>透過 Probability Distributions APP 可以得出 0.1052<ul>
<li>\(mu = 10\)</li>
<li>\(\sigma = 3 \)</li>
<li>\(x &lt; 11.5 = 0.7967 \)</li>
<li>\(x &lt; 12.5 = 0.6915 \)</li>
<li>\(0.7967 - 0.6915 = 0.1052 \)</li>
</ul>
</li>
</ul>
<h2 id="Exponential-Probability-Distribution-指數機率分配"><a href="#Exponential-Probability-Distribution-指數機率分配" class="headerlink" title="Exponential Probability Distribution 指數機率分配"></a>Exponential Probability Distribution 指數機率分配</h2><ul>
<li>Exponential Probability Distribution 用來描述完成任務所需要的時間，應用如<ul>
<li>車輛到達收費站德時間</li>
<li>完成問卷需要的時間</li>
</ul>
</li>
<li>指數機率分佈的標準差與平均值皆相等</li>
<li>指數機率分佈向右偏(即圖形主要面積在左邊)，偏度為二</li>
<li>Probability Distributions APP - <strong>Exponential</strong> <ul>
<li>\(\lambda = \frac{1}{\mu}\)</li>
<li>x 為我們所期望得到的目標，如找出一段時間內 x 次紅綠燈為紅燈的次數</li>
</ul>
</li>
</ul>
<h3 id="舉例-從家裡到火車站平均開車時間為-3-分鐘，透過指數機率分布，想找出連續兩次到達時間不大於兩分鐘的機率是多少"><a href="#舉例-從家裡到火車站平均開車時間為-3-分鐘，透過指數機率分布，想找出連續兩次到達時間不大於兩分鐘的機率是多少" class="headerlink" title="舉例 - 從家裡到火車站平均開車時間為 3 分鐘，透過指數機率分布，想找出連續兩次到達時間不大於兩分鐘的機率是多少"></a>舉例 - 從家裡到火車站平均開車時間為 3 分鐘，透過指數機率分布，想找出連續兩次到達時間不大於兩分鐘的機率是多少</h3><ul>
<li>透過 Probability Distributions APP 可以得出 0.4862<ul>
<li>\(\lambda = 0.3333 = \frac{1}{\mu} \)</li>
<li>\(x &lt;= 2 \)</li>
<li>圖片<blockquote>
<p><img src="/images/statistics-1081-mid/37.jpg" alt=""></p>
</blockquote>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>北科上課筆記</category>
        <category>統計 statistics</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>統計學筆記</tag>
        <tag>北科大二上統計學筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>統計學(二) 筆記 - 第十四章 簡單線性迴歸(Simple Linear Regression)</title>
    <url>/2021/05/02/statistics/statistics-ch14/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊與財金管理系大二下統計學重點整理<br><font color="#dd0000">並非所有人都適用，部分對我而言稍加容易的內容並不會寫在此內。</font><br><strong>這是觀看影片心得後的筆記，老師上課可能不太適用會忘記抄到</strong></p>
</blockquote>
<a id="more"></a>

<h1 id="簡單線性迴歸-Simple-Linear-Regression-Model"><a href="#簡單線性迴歸-Simple-Linear-Regression-Model" class="headerlink" title="簡單線性迴歸 Simple Linear Regression Model"></a>簡單線性迴歸 Simple Linear Regression Model</h1><ul>
<li>功能<ul>
<li>了解變數與變數的關聯性</li>
<li>透過獨立變數(independent variable)去預測因變數(dependent variable)，定義 y</li>
<li>透過 x 去預測 y</li>
</ul>
</li>
<li>說明<ul>
<li>簡單線性迴歸<strong>只有一個獨立變數去預測因變數</strong></li>
<li>因此關聯圖應該是一條直線</li>
<li>如果需要多個獨立變數去預測因變數則使用<strong>複迴歸(multiple regression)</strong></li>
</ul>
</li>
<li>公式<ul>
<li>簡單線性迴歸模型(model) \(y = \beta_0 + \beta_1 x + \mathcal{E} \)<ul>
<li>\(\beta_0\) and \(\beta_1\) 是模型的參數</li>
<li>\(\mathcal{E}\) 則是隨機變數的誤差項(error term)</li>
</ul>
</li>
<li>期望值的 y \(E(y) = \beta_0 + \beta_1 x\)，在此 \(\mathcal{E} = 0\)<ul>
<li>\(\beta_0 \) 為迴歸線的截距</li>
<li>\(\beta_1 \) 為迴歸線的斜率</li>
<li>\(E(y)\) 是當 x 為多少時 y 的期望值</li>
<li>正相關示意圖<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1U667lCV8MqEfyYHtro5LwSkPrDUlL2vR&export=download" alt=""></p>
</blockquote>
</li>
<li>負相關示意圖<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1cL1rX99D34gakdwqyF_xpZOrMeQIQuUJ&export=download" alt=""></p>
</blockquote>
</li>
<li>無相關示意圖<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1SoN3ZEoPN76wrJqx0BUvF7-5qY6zOqOV&export=download" alt=""></p>
</blockquote>
</li>
</ul>
</li>
<li>估計(estimated) 線性迴歸 \(\hat{y} = b_0 + b_1 x\)<ul>
<li>\(b_0 \) 為迴歸線的截距</li>
<li>\(b_1 \) 為迴歸線的斜率</li>
<li>\(\hat{y}\) 是當 x 為多少時 y 的期望值</li>
</ul>
</li>
</ul>
</li>
<li>估計程序 Estimation Process<ul>
<li>由於我們不能確定期望值方程式中的 \(\beta_0 + \beta_1 x\)，因此我們透過樣本資料與估計線性迴歸方程式得出 \(b_0, b_1\)，再透過 \(b_0, b_1\) 去估計 \(\beta_0 , \beta_1 x\)<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1GJ7Tbeuby5jxwdS3sGXVqfDbCFPCwwEU&export=download" alt=""></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h1 id="最小平方法-Least-Squares-Method"><a href="#最小平方法-Least-Squares-Method" class="headerlink" title="最小平方法 Least Squares Method"></a>最小平方法 Least Squares Method</h1><p>最小平方法用於判斷模型的誤差方式</p>
<ul>
<li>公式 Least Squares Criterion <ul>
<li>標準公式 \(min \sum (y_i - \hat{y_i})^2\)</li>
<li>\(y_i\) 實際的因變數</li>
<li>\(\hat{y_i}\) 推估的因變數</li>
</ul>
</li>
<li>估計迴歸方程式斜率 Slope for the Estimated Regression Equation <ul>
<li>公式 \(b_1 = \frac{\sum (x_i - \bar{x}) (y_i - \bar{y})}{\sum (x_i - \bar{x})^2 }\)</li>
<li>\(x_i\) 獨立變數的數值</li>
<li>\(y_i\) 因變數的數值</li>
<li>\(\bar{x}\) 獨立變數的平均值</li>
<li>\(\bar{y}\) 因變數的平均值</li>
</ul>
</li>
<li>y 截距 for 估計迴歸方程式斜率為 \(b_0 = \bar{y} - b_{1}\bar{x}\)</li>
</ul>
<h2 id="舉例：車車銷售商，有一個禮拜的促銷方案，會在電視上投放廣告，這裡則有前-5-次的銷售資料"><a href="#舉例：車車銷售商，有一個禮拜的促銷方案，會在電視上投放廣告，這裡則有前-5-次的銷售資料" class="headerlink" title="舉例：車車銷售商，有一個禮拜的促銷方案，會在電視上投放廣告，這裡則有前 5 次的銷售資料"></a>舉例：車車銷售商，有一個禮拜的促銷方案，會在電視上投放廣告，這裡則有前 5 次的銷售資料</h2><blockquote>
<p>資料如下<br><img src="https://drive.google.com/u/2/uc?id=1uFeLzj9CJd0uWBR1ThInMV9AM1qAU54x&export=download" alt=""></p>
</blockquote>
<h3 id="作答"><a href="#作答" class="headerlink" title="作答"></a>作答</h3><blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1I4vkFQn7plXMeye6JcKQVJYFAe_Oie5s&export=download" alt=""></p>
</blockquote>
<h1 id="判定係數-Cofficient-of-Determination"><a href="#判定係數-Cofficient-of-Determination" class="headerlink" title="判定係數 Cofficient of Determination"></a>判定係數 Cofficient of Determination</h1><ul>
<li>複習 ANOVA 公式 \(\sum (y_i - \bar{y})^2 = \sum (\hat{y_i}- \bar{y})^2 + \sum (y_i - \hat{y_i})^2 \)<ul>
<li>其中 \(SST = \sum (y_i - \bar{y})^2\) 總平方和 total sum of squares</li>
<li>其中 \(SSR = \sum (\hat{y_i}- \bar{y})^2\) 迴歸平方和</li>
<li>其中 \(SSE = \sum (y_i - \hat{y_i})^2 \) 誤差平方和</li>
</ul>
</li>
<li>透過圖表來進行描述，如果以單點來看，則紅色部分為 SSR，藍色部分為 SSE，而中間綠色的點則是 SST<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=16abqF3e8bShtixeIVBikFzMQ1JY5D1C8&export=download" alt=""></p>
</blockquote>
</li>
<li>判定係數公式  \(r^2 = SSR / SST \)<ul>
<li>其中 SSR 迴歸平方和</li>
<li>SST 誤差平方和</li>
<li>當 \(r^2\) 越大時則表示此迴歸方程式能夠解讀資料的能力越好</li>
</ul>
</li>
</ul>
<h2 id="舉例：根據車車銷售商那題，求他的判定係數多少"><a href="#舉例：根據車車銷售商那題，求他的判定係數多少" class="headerlink" title="舉例：根據車車銷售商那題，求他的判定係數多少"></a>舉例：<a href="#舉例：車車銷售商，有一個禮拜的促銷方案，會在電視上投放廣告，這裡則有前-5-次的銷售資料">根據車車銷售商那題</a>，求他的判定係數多少</h2><p>\(r^2 = SSR / SST = 100 / 114 = 0.8772\)<br>因此我們可以知道此迴歸方程式可以很好的解釋這筆資料，有 87.72% 可以透過此方程式解讀電視廣告與汽車銷售數量。</p>
<h2 id="樣本相關係數-Sample-Correlation-Coefficient"><a href="#樣本相關係數-Sample-Correlation-Coefficient" class="headerlink" title="樣本相關係數 Sample Correlation Coefficient"></a>樣本相關係數 Sample Correlation Coefficient</h2><ul>
<li>如果相關係數為 1 表示正相關，如果是 -1 則是負相關</li>
<li>定義 \(r_{xy}\) 為 x,y 變數相關係數</li>
<li>\(r_{xy} = (\text{sign of} b_1) \sqrt{\text{Coefficient of Determination}}\)</li>
<li>\(r_{xy} = (\text{sign of} b_1) \sqrt{r^2}\)</li>
<li>\(b_1\) 則是迴歸估計方程式的斜率 \(\hat{y} = b_0 + b_1 x\)</li>
</ul>
<h3 id="舉例：根據車車銷售商那題，我們想知道電視廣告與銷售車車的相關係數"><a href="#舉例：根據車車銷售商那題，我們想知道電視廣告與銷售車車的相關係數" class="headerlink" title="舉例：根據車車銷售商那題，我們想知道電視廣告與銷售車車的相關係數"></a>舉例：根據車車銷售商那題，我們想知道電視廣告與銷售車車的相關係數</h3><ul>
<li>\(r_{xy} = (\text{sign of} b_1) \sqrt{r^2}\)</li>
<li>迴歸估計方程式為 \(\hat{y} = 10 + 5x \)，由於是 ‘+’ 號因此一定是正相關</li>
<li>\(r_{xy} = + \sqrt{0.8772}\)</li>
<li>\(r_{xy} = + 0.9366\)</li>
</ul>
<h1 id="假設模型下的誤差項-Model-Assumptions-About-the-Error-Term-mathcal-E"><a href="#假設模型下的誤差項-Model-Assumptions-About-the-Error-Term-mathcal-E" class="headerlink" title="假設模型下的誤差項 Model Assumptions About the Error Term \(\mathcal{E}\)"></a>假設模型下的誤差項 Model Assumptions About the Error Term \(\mathcal{E}\)</h1><p>定義 \(\mathcal{E} = y_i - \hat{y_i}\)</p>
<p>我們對於 \(\mathcal{E}\) 有以下假設</p>
<ul>
<li>我們假設 \(\mathcal{E}\) 是平均數為零的隨機變數<ul>
<li>因此我們可以表示 \(E(\mathcal{E}) = 0\)</li>
<li>所以 \(y = \beta_0 + \beta_1 x + \mathcal{E}\)，才可以省略 \(\mathcal{E}\)</li>
</ul>
</li>
<li>\(\mathcal{E}\) 的變異數定義為 \(\sigma^2\)，因此迴歸線裡面的所有的獨立變數中的 \(\mathcal{E}\) 變異數為 都是 \(\sigma^2\)</li>
<li>\(\mathcal{E}\) 為獨立變數，每一個變數的 \(\mathcal{E}\) 都不同，互相獨立</li>
<li>\(\mathcal{E}\) 是常態分配的隨機變數</li>
</ul>
<h2 id="圖表解釋如下"><a href="#圖表解釋如下" class="headerlink" title="圖表解釋如下"></a>圖表解釋如下</h2><blockquote>
<p>其中我們可以看到當 \(x=0\) 後，綠線(我們的期望線性迴歸模型)一路 x 遞增。<br>此時再 \(x=10\)，我們可以看到藍點的部分為綠線與紅線(實際情況的 y 因變數)的交接處，理論上我們期望線性迴歸模型是預估此點<br>而  \(\mathcal{E}\) 就是偏離藍點，並只出現在\(x=10\)紅線中的某一點，因此 \(y = \beta_0 + \beta_1 x + \mathcal{E}\)，才會是使用 ‘+’ 號<br>其中 \(x=10\) 也可以改成 20,30<br><img src="https://drive.google.com/u/2/uc?id=1YxI7RcEvPVTEOGFYNsFr6aw3m3BlChyF&export=download" alt=""></p>
</blockquote>
<h1 id="顯著性測試-Testing-for-Significance"><a href="#顯著性測試-Testing-for-Significance" class="headerlink" title="顯著性測試 Testing for Significance"></a>顯著性測試 Testing for Significance</h1><ul>
<li>顯著性測試檢定 \(\beta_1\) 是否為零，來檢測獨立變數與因變數是否有關聯<br>主要透過簡單迴歸分析公式 \(y = \beta_0 + \beta_1 x + \mathcal{E} \)，當 \(\beta_1\) 為 0 時，我們可以得知那 x 跟 y 並沒有關係</li>
<li>主要是使用 t 檢定 or f 檢定來假設測試顯著性測試</li>
<li>t 檢定與 f 檢定變異數則是 \(\sigma^2\)，也就是 \(\mathcal{E} \) </li>
<li>估計變異數 \(\sigma^2\)<ul>
<li>公式 \(s^2 = MSE = SSE / (n-2)\)</li>
<li>其中 \(SSE = \sum (y_i - \hat{y_i})^2 = \sum (y_i - b_0 - b_1 x_i)^2 \)</li>
<li>因此估計標準差就為 \(s = \sqrt{MSE} = \sqrt{\frac{SSE}{n-2}}\)</li>
</ul>
</li>
</ul>
<h2 id="t-檢定-t-Test"><a href="#t-檢定-t-Test" class="headerlink" title="t 檢定 t Test"></a>t 檢定 t Test</h2><ul>
<li>假設檢定<ul>
<li>\(H_0: \beta_1 = 0 \)</li>
<li>\(H_1: \beta_1 != 0\)</li>
</ul>
</li>
<li>Test Statistic<ul>
<li>公式 \(t = \frac{b_1}{s_{b_1}}\)</li>
<li>其中 \(s_{b_1} = \frac{s}{\sqrt{\sum (x_i - \bar{x})^2}}\)</li>
</ul>
</li>
<li>Rejcetion Rule <ul>
<li>Reject \(H_0\) if \(p-value \leq \alpha \) or \(t \leq -t_{a/2} \) or \(t \geq t_{a/2}\)</li>
<li>其中 \(t_{a/2}\) 為 t 描述</li>
<li>\(n-2\) 為自由度，主要是因為減掉獨立變數與因變數</li>
</ul>
</li>
</ul>
<h3 id="舉例：根據車車銷售商那題，我們想知道投放電視廣告與銷售車輛是否有關聯"><a href="#舉例：根據車車銷售商那題，我們想知道投放電視廣告與銷售車輛是否有關聯" class="headerlink" title="舉例：根據車車銷售商那題，我們想知道投放電視廣告與銷售車輛是否有關聯"></a>舉例：<a href="#舉例：車車銷售商，有一個禮拜的促銷方案，會在電視上投放廣告，這裡則有前-5-次的銷售資料">根據車車銷售商那題</a>，我們想知道投放電視廣告與銷售車輛是否有關聯</h3><blockquote>
<p>資料如下<br><img src="https://drive.google.com/u/2/uc?id=1J0B8QmN2FK-QRakCm_2si5sTIzerPuf7&export=download" alt=""></p>
</blockquote>
<ul>
<li><p>假設檢定</p>
<ul>
<li>\(H_0: \beta_1 = 0 \)</li>
<li>\(H_1: \beta_1 != 0\)</li>
</ul>
</li>
<li><p>顯著性水準為 \(\alpha = 0.05\)</p>
</li>
<li><p>Rejcetion Rule </p>
<ul>
<li>Reject \(H_0\) if \(p-value \leq \alpha \)  or \( |t| \geq t_{a/2} = 3.182\)，注意 \(a / 2 = 0.05\)</li>
<li>其中 \(t_{a/2}\) 為 t 描述</li>
<li>\(n-2\) 為自由度，主要是因為減掉獨立變數與因變數</li>
<li>使用 probability distribution app 計算<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1GYHjzgZJtP6KBqPKX7gGv4ahBO4LdEim&export=download" alt=""></p>
</blockquote>
</li>
</ul>
</li>
<li><p>Test Statistic<br>公式 \(t = \frac{b_1}{s_{b_1}} = \frac{5}{1.08} = 4.63\)，老師已經把 \(s_{b_1}\) 已經做完。</p>
</li>
<li><p>確認並拒絕 \(H_0\)<br>if \(p-value=0.01 \leq \alpha=0.05 \)  or \( 4.63=|t| \geq t_{a/2} = 3.182\)，因此拒絕 \(H_0\)，我們可以確認電視廣告與汽車銷售數量是有關聯的。</p>
</li>
</ul>
<h2 id="對-beta-1-做信賴區間"><a href="#對-beta-1-做信賴區間" class="headerlink" title="對 \(\beta_1\) 做信賴區間"></a>對 \(\beta_1\) 做信賴區間</h2><ul>
<li>我們可以透過百分之 95 的信賴區間對 \(\beta_1\) 做假設檢定，如果要 reject \(H_0\)，那 \(\beta_1\) 就不能在信賴區間內。 </li>
<li>信賴區間公式<ul>
<li>公式為 \(\beta+1 \pm t_{a/2} s_{b_1}\)</li>
<li>其中 \(t_{a/2}\) 為 t 描述</li>
<li>\(n-2\) 為自由度，主要是因為減掉獨立變數與因變數</li>
</ul>
</li>
<li>Reject Rule<br>reject \(H_0\)，那 \(\beta_1\) 就不能在信賴區間內。 </li>
</ul>
<h3 id="舉例：延續根據車車銷售商那題，請使用信賴區間做假設檢定"><a href="#舉例：延續根據車車銷售商那題，請使用信賴區間做假設檢定" class="headerlink" title="舉例：延續根據車車銷售商那題，請使用信賴區間做假設檢定"></a>舉例：延續<a href="#舉例：根據車車銷售商那題，我們想知道投放電視廣告與銷售車輛是否有關聯">根據車車銷售商那題</a>，請使用信賴區間做假設檢定</h3><ul>
<li>百分之 95 的信賴區間計算<br>\(\beta_1 \pm t_{a/2} s_{b_1} = 5 \pm 3.182(1.08) = 5 \pm 3.44 \)</li>
<li>結論<br>0 並沒有在 \(5 \pm 3.44\)，因此拒絕 \(H_0\)，我們可以確認電視廣告與汽車銷售數量是有關聯的。</li>
</ul>
<h2 id="F-檢定"><a href="#F-檢定" class="headerlink" title="F 檢定"></a>F 檢定</h2><ul>
<li>假設檢定<ul>
<li>\(H_0: \beta_1 = 0 \)</li>
<li>\(H_1: \beta_1 != 0\)</li>
</ul>
</li>
<li>F test Statisitic<br>\(F = MSR / MSE \)</li>
<li>Rejection Rule <ul>
<li>Reject \(H_0\) if \(p-value \leq \alpha \) or \(F \geq F_\alpha\)</li>
<li>其中 \(F_a\) 為我們計算的 f 描述</li>
<li>分子自由度為 1、分母自由度為 \(n-2\)</li>
<li>\(n-2\) 為自由度，主要是因為減掉獨立變數與因變數</li>
</ul>
</li>
</ul>
<h3 id="舉例：延續根據車車銷售商那題，請使用-F檢定做假設檢定"><a href="#舉例：延續根據車車銷售商那題，請使用-F檢定做假設檢定" class="headerlink" title="舉例：延續根據車車銷售商那題，請使用 F檢定做假設檢定"></a>舉例：延續<a href="#舉例：根據車車銷售商那題，我們想知道投放電視廣告與銷售車輛是否有關聯">根據車車銷售商那題</a>，請使用 F檢定做假設檢定</h3><ul>
<li>假設檢定<ul>
<li>\(H_0: \beta_1 = 0 \)</li>
<li>\(H_1: \beta_1 != 0\)</li>
</ul>
</li>
<li>顯著性測試 \(\alpha = 0.05\)</li>
<li>Rejection rule<ul>
<li>Reject \(H_0\) if \(p-value \leq 0.05 \) or \(F \geq 10.13\)，分子自由度為 1、分母自由度為 3</li>
<li>使用 probability distribution app 計算<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1vmJlPBRWyMHqR0bGUukoN5B8cs9mUapy&export=download" alt=""></p>
</blockquote>
</li>
</ul>
</li>
<li>F test Statisitic<br>\(F = MSR / MSE = 100 / 4.667 = 21.43 \) </li>
<li>Conclusion<ul>
<li>Reject \(H_0\) if \(0.019 \leq \alpha \) or \(21.43 =F \geq F_\alpha = 10.13\)，都有符合；因此拒絕 \(H_0\)，我們可以確認電視廣告與汽車銷售數量是有關聯的。</li>
</ul>
</li>
</ul>
<h2 id="顯著性水準的重要解釋-Some-Cautions-about-the-Interpreatation-of-Significance-Tests"><a href="#顯著性水準的重要解釋-Some-Cautions-about-the-Interpreatation-of-Significance-Tests" class="headerlink" title="顯著性水準的重要解釋 Some Cautions about the Interpreatation of Significance Tests"></a>顯著性水準的重要解釋 Some Cautions about the Interpreatation of Significance Tests</h2><p>我們上面有進行假設檢定，如果成功 Reject \(H_0\)，我們必須注意<strong>我們並不能說 x 與 y 有因果關係，只能說有統計關係</strong>，因為我們不能夠確定這件事情的變數就只有這兩個。<br>也許其實這件事情應該要有 3 個變數，但我們的簡單迴歸模型則只有用 2 個變數，也許這兩個變數都是因變數，而那個沒有用的才是獨立變數。</p>
<blockquote>
<p>我們在做好假設檢定的顯著性水準後，我們必須說我們是<strong>針對模型的最小 x 值 to 最大 x 值去做假設檢定</strong>，因為我們沒有辦法肯定超出此範圍的 x,y 關係是如何；舉例：Largest x value 右邊之後就跟先前的線條不同，也就表示 Largest x value 右邊後的 y 會因為 x 而快速成長。<br><img src="https://drive.google.com/u/2/uc?id=14cBUNdzIjph9NRhiiBjbdNRjizoknd4L&export=download" alt=""></p>
</blockquote>
<h1 id="使用估計迴歸方程式來預測或預估-Using-the-Estimated-Regression-Equation-for-Estimation-and-Prediction"><a href="#使用估計迴歸方程式來預測或預估-Using-the-Estimated-Regression-Equation-for-Estimation-and-Prediction" class="headerlink" title="使用估計迴歸方程式來預測或預估 Using the Estimated Regression Equation for Estimation and Prediction"></a>使用估計迴歸方程式來預測或預估 Using the Estimated Regression Equation for Estimation and Prediction</h1><p>主要用途</p>
<ul>
<li>採用<strong>信心區間</strong>，給定 x 推出 y 的平均值為多少</li>
<li>採用<strong>預測區間</strong>，給定 x 的值我們想知道在 x 的情況下 y 值(特定數值)為多少</li>
<li>在使用預測區間時，其範圍會比信心區間來的更大</li>
</ul>
<h2 id="區間估計公式"><a href="#區間估計公式" class="headerlink" title="區間估計公式"></a>區間估計公式</h2><p>通常回歸方程式做完後預測出來的值不一定完全準確，因為我們的回歸預測方程式是 \(y = \beta_0 + \beta_1 x \)，我們忽略是 \(\mathcal{E} \)，因此我們要預估 \( \mathcal{E} \) 因此才需要此估計公式進行計算 </p>
<ul>
<li>信心區間估計 Confidence Interval Estimate of \(E(y^*) \)<ul>
<li>\(\hat{y}^* \pm t_{a/2} s_{\hat{y}^*} \)</li>
<li>其中信賴係數為 \(1-\alpha\)，自由度為 \(n-2\)，其中 2 為獨立變數與因變數的總和</li>
<li>\(s = \sqrt{MSE} = SSE / (n-2) \)</li>
<li>\(s_{\hat{y}^*} = s \sqrt{\frac{1}{n} + \frac{( x^* - \bar{x} )^2}{\sum (x_i - \bar{x})^2}}\)</li>
</ul>
</li>
<li>預測區間估計 Prediction Interval Estimate of \(y*\)<ul>
<li>\(\hat{y}^* \pm t_{a/2} s_{\text{pred}}\)</li>
<li>其中信賴係數為 \(1-\alpha\)，自由度為 \(n-2\)</li>
<li>\(s = \sqrt{MSE} \)</li>
<li>\(s_{\text{pred}} =  s \sqrt{1 + \frac{1}{n} + \frac{( x^* - \bar{x} )^2}{\sum (x_i - \bar{x})^2}} \) </li>
</ul>
</li>
<li>圖片說明信心區間、預估區間<ul>
<li>我們可以看到中間的信賴區間與預估區間最小，則是因為當 \(x^* = \bar{x}\)，那項會變成零，因此中間的範圍就變小</li>
<li>我們可以看到預估區間的範圍比信賴區間大則是因為預估區間在 \(s_{\text{pred}} \) 多了一個 1<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1SY9oUioHwtdJOw83hs-PU3OysG2_dqPx&export=download" alt=""></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="舉例：延續根據車車銷售商那題，再有-3-個電視廣告的情況下，我們透過信賴區間、預測區間可以得知平均汽車銷售數量為？"><a href="#舉例：延續根據車車銷售商那題，再有-3-個電視廣告的情況下，我們透過信賴區間、預測區間可以得知平均汽車銷售數量為？" class="headerlink" title="舉例：延續根據車車銷售商那題，再有 3 個電視廣告的情況下，我們透過信賴區間、預測區間可以得知平均汽車銷售數量為？"></a>舉例：延續<a href="#舉例：延續根據車車銷售商那題，請使用信賴區間做假設檢定">根據車車銷售商那題</a>，再有 3 個電視廣告的情況下，我們透過信賴區間、預測區間可以得知平均汽車銷售數量為？</h3><ul>
<li>\(\hat{y} = 10 + 5(3) = 25\) cars，通過前面的資料可以推出</li>
<li>\(E(y^*) \) 的信賴區間<ul>
<li>\(E(y^*) \) 估計的標準差<ul>
<li>\(s = \sqrt{MSE} = \sqrt{4.667}\)</li>
<li>\(s_{\hat{y}^*} = s \sqrt{\frac{1}{n} + \frac{( x^* - \bar{x} )^2}{\sum (x_i - \bar{x})^2}}\)</li>
<li>\(s_{\hat{y}^*} = 2.16025 \sqrt{\frac{1}{5} + \frac{(3-2)^2}{(1-2)^2+(3-2)^2+(2-2)^2+(1-2)^2+(3-2)^2}}\)</li>
<li>\(s_{\hat{y}^*}  = 2.16025 \sqrt{\frac{1}{5} + \sqrt{1}{4}} = 1.4491\)</li>
</ul>
</li>
<li>因此根據信心區間估計 \(\hat{y}^* \pm t_{a/2} s_{\hat{y}^*} \)<br>\(25 \pm 3.1824(1.4491) = 25 \pm 4.61\)，因此我們預估 3 個電視廣告，銷售汽車數量大約在 20.39 to 29.61 </li>
</ul>
</li>
<li>\(y^* \) 的預估區間<ul>
<li>\(y^* \) 估計的標準差<ul>
<li>\(s_{\text{pred}} =  s \sqrt{1 + \frac{1}{n} + \frac{( x^* - \bar{x} )^2}{\sum (x_i - \bar{x})^2}} \) </li>
<li>\(s_{\text{pred}} = 2.16025 \sqrt{1 + \frac{1}{5} + \frac{1}{4}}\)</li>
<li>\(s_{\text{pred}} = 2.16025(1.20416) = 2.6013\)</li>
</ul>
</li>
<li>因此根據預測區間估計 \(\hat{y}^* \pm t_{a/2} s_{\text{pred}}\)<ul>
<li>\(25 \pm 3.1824(2.6013) = 25 \pm 8.28\)，因此我們預估 3 個電視廣告，銷售汽車數量大約在 16.72 to 33.28</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="使用電腦計算-Computer-Solution"><a href="#使用電腦計算-Computer-Solution" class="headerlink" title="使用電腦計算 Computer Solution"></a>使用電腦計算 Computer Solution</h1><p>根據上面文章我們可以知道如果使用手工去推估迴歸分析時非常麻煩，因此我們這邊則是使用電腦軟體來計算迴測。</p>
<p>下面我們則是延續<a href="#舉例：延續根據車車銷售商那題，再有-3-個電視廣告的情況下，我們可以預期平均汽車銷售數量為？">根據車車銷售商那題</a>，使用 minitab 與 excel 分析</p>
<ul>
<li>Minitab，使用圖片進行說明，我目前也沒有操作過此軟體並不太熟，可以開兩個分頁來確認答案是否正確<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=19hV5m394zOHwPT79VHUwTski6GYCZ1Cv&export=download" alt=""></p>
</blockquote>
</li>
<li>Excel 進行迴歸分析<ul>
<li>操作方式 資料 &gt; 資料分析 &gt; 迴歸，對 x 輸入獨立變數、y 輸入因變數，檢查是否需要標記後按確定應該能產生此圖</li>
<li>截距是 \(b_0\)</li>
<li>我們可以用 #TV Ads(x) 對 x,y 是否有相關進行假設檢定，其中我們可以知道 1.5626 to 8.4374 並無包含 0，因此 reject \(H_0\)</li>
<li>圖片說明<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1jU-s3U-92QoXUAIibjwNxiIk8pwWNcsl&export=download" alt=""></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h1 id="殘差分析-合法模型假設-Residual-Analysis-Validating-Model-Assumptions"><a href="#殘差分析-合法模型假設-Residual-Analysis-Validating-Model-Assumptions" class="headerlink" title="殘差分析: 合法模型假設 Residual Analysis: Validating Model Assumptions"></a>殘差分析: 合法模型假設 Residual Analysis: Validating Model Assumptions</h1><ul>
<li>我們之前在<a href="#假設模型下的誤差項-Model-Assumptions-About-the-Error-Term-mathcal-E">假設模型下的誤差項</a> 提到<ul>
<li>我們假設 \(\mathcal{E}\) 是平均數為零且常態分配的隨機變數</li>
<li>因此我們可以表示 \(E(\mathcal{E}) = 0\)</li>
<li>所以 \(y = \beta_0 + \beta_1 x + \mathcal{E}\)，才可以省略 \(\mathcal{E}\)</li>
<li>\(\mathcal{E}\) 的變異數定義為 \(\sigma^2\)，因此迴歸線裡面的所有的獨立變數都是 \(\sigma^2\)<ul>
<li>如果此假設成立，那理論上每個點的殘差應該都非常靠近此虛線<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1pv9K5eRM_ULog6zHHsAvdmJlraQbZ5EF&export=download" alt=""></p>
</blockquote>
</li>
<li>如果假設不成立，那每點殘差應該會非常離散<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1hFaPczK0DWBgSEPtzQldUhgGpBgFYned&export=download" alt=""></p>
</blockquote>
</li>
<li>還有一種情況，是我們的線並不適合此模型，但理論上我們可以根據殘差畫出區間，那表示我們的獨立變數可能並不適用<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1ZbZSzV-6gsIqPvj79CVTMMH4KBddL5pi&export=download" alt=""></p>
</blockquote>
</li>
</ul>
</li>
<li>\(\mathcal{E}\) 為獨立變數，每一個變數的 \(\mathcal{E}\) 都不同，互相獨立</li>
<li>\(\mathcal{E}\) 為常態分配<ul>
<li>殘差標準化公式為 <ul>
<li>\(\frac{y_i - \hat{y_i}}{s_{y_i - \hat{y_i}}}\)</li>
<li>其中 \(s_{y_i - \hat{y_i}} = s \sqrt{1-h_i}\)</li>
<li>\( h_i = \frac{1}{n} + \frac{( x_i - \bar{x} )^2}{\sum (x_i - \bar{x})^2} \)</li>
</ul>
</li>
<li>只要殘差標準化公式為 -2 to 2 之間，那我們就認定 \(\mathcal{E}\) 是常態分配</li>
</ul>
</li>
</ul>
</li>
<li>而我們這邊則是要對 \(\mathcal{E}\) 來判斷是否符合我們上面的假設<ul>
<li>符合則表示有適用</li>
<li>不符合我們的假設表示此模型並不適用</li>
</ul>
</li>
<li>每一筆資料的殘差值公式為 \(y_i - \hat{y_i}\)</li>
</ul>
<h2 id="我們直接透過舉例來進行說明，一樣是車車銷售商"><a href="#我們直接透過舉例來進行說明，一樣是車車銷售商" class="headerlink" title="我們直接透過舉例來進行說明，一樣是車車銷售商"></a>我們直接透過舉例來進行說明，一樣是<a href="#舉例：延續根據車車銷售商那題，再有-3-個電視廣告的情況下，我們可以預期平均汽車銷售數量為？">車車銷售商</a></h2><blockquote>
<p>資料如下，其中 \(\hat{y}\) 就是 Predicted y、\(y_i\) 是 number of Cars Sold、\(y_i - \hat{y_i}\) Residuals<br><img src="https://drive.google.com/u/2/uc?id=1agzOQ4mj58BstcoqOK_GUyRHDcoYOiuA&export=download" alt=""></p>
</blockquote>
<p>我們可以得知上面每一個 \(x_i\) 標準化殘差公式中都沒有數值超過 -2 or 2，因此我們可以認定 \(\mathcal{E}\) 是常態分配</p>
<h2 id="Normal-Probability-Plot"><a href="#Normal-Probability-Plot" class="headerlink" title="Normal Probability Plot"></a>Normal Probability Plot</h2><p>在標準差為 1，平均數為 0 的標準常態機率分配中，我們使用機率隨機抽取出 x，定義 order_x 為隨機抽取出 x 並由小到大排序，再來我們與資料中每一個 \(x_i\) 標準化殘差公式進行畫圖。</p>
<ul>
<li>X 軸為 order_x</li>
<li>Y 軸為 資料中每一個 \(x_i\) 標準化殘差公式</li>
<li>再來我們以 45 度畫一條線，如果每一個紅點都離 45 度線非常近那我們一樣可以認定 \(\mathcal{E}\) 是常態分配</li>
<li>畫圖如下<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1hCQ6DqoeJOc7zS6-GdrnkkFXvKh4fP76&export=download" alt=""></p>
</blockquote>
</li>
</ul>
<h1 id="殘差分析-離群值與能透過一個點就使線圖改變的值-Residual-Analysis-Outliers-and-Influential-Observations"><a href="#殘差分析-離群值與能透過一個點就使線圖改變的值-Residual-Analysis-Outliers-and-Influential-Observations" class="headerlink" title="殘差分析: 離群值與能透過一個點就使線圖改變的值 Residual Analysis: Outliers and Influential Observations"></a>殘差分析: 離群值與能透過一個點就使線圖改變的值 Residual Analysis: Outliers and Influential Observations</h1><p>在<a href="#Normal-Probability-Plot">Normal Probability Plot</a> 中，我們可以發現幾種情況</p>
<ul>
<li>Outier，其中有一個紅點離其他資料過遠<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1h91rqIrV_3AD8cUf2LBHq9tMRQYQv8c0&export=download" alt=""></p>
</blockquote>
</li>
<li>Influential Observations，只因為 Influential Observations value 就讓綠線圖原本應該跟隨藍線的圖，畫成了綠色<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1-fgJ8t6-BXe5CXC129D19KPZT9z2IZj6&export=download" alt=""></p>
</blockquote>
</li>
</ul>
<p>我們為了要避免這兩種狀況，我們則有一些方法</p>
<ul>
<li>將離群值大於 2 and 小於 2 刪除，但假如大量殘差都是 1.5 時，此種方法並不適用</li>
<li>將殘差值的最大與最小前 5 % 刪除。</li>
</ul>
<p>謝謝大家把他看完，我也打了好久QQQQQ，學習的心得總是覺得很麻煩，但又一定要做。<br>我認為沒有留下紀錄的人生就是沒有存在過。</p>
]]></content>
      <categories>
        <category>北科上課筆記</category>
        <category>統計 statistics</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>統計學筆記</tag>
        <tag>北科大二下統計學筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>統計學(二) 筆記 - 第十二章 比較多種比例，適合性檢定與適宜性檢定(Comparing Multiple Proportions, Test of Independence and Goodness Fit)</title>
    <url>/2021/04/11/statistics/statistics-ch12/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊與財金管理系大二下統計學重點整理<br><font color="#dd0000">並非所有人都適用，部分對我而言稍加容易的內容並不會寫在此內。</font><br><strong>這是觀看影片心得後的筆記，老師上課可能不太適用會忘記抄到</strong></p>
</blockquote>
<a id="more"></a>

<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>此章節都必須使用假設檢定，因此如果不熟假設檢定可以先看 <a href="https://theriseofdavid.github.io/tags/%E5%8C%97%E7%A7%91%E5%A4%A7%E4%BA%8C%E4%B8%8B%E7%B5%B1%E8%A8%88%E5%AD%B8%E7%AD%86%E8%A8%98/" target="_blank" rel="noopener">北科大二下統計學筆記 by 大衛的筆記</a></p>
<p>建議複習完後，再來看此章節。</p>
<p><strong>全部的資料都是使用卡方分配，且全部的資料都是使用類別型的資料</strong></p>
<h1 id="測試是否母體相等-Testing-the-Equality-of-Population-Proportions"><a href="#測試是否母體相等-Testing-the-Equality-of-Population-Proportions" class="headerlink" title="測試是否母體相等 Testing the Equality of Population Proportions"></a>測試是否母體相等 Testing the Equality of Population Proportions</h1><ul>
<li>定義名詞<ul>
<li>\(p_1\) 母體 1 的母體比例</li>
<li>\(p_2\) 母體 2 的母體比例</li>
<li>\(p_3\) 母體 3 的母體比例</li>
<li>\(k \geq 3\)，至少要有三種母體</li>
<li>\(H_0 = p_1 = p_2 = p_3\) 全部母體都一樣</li>
<li>\(H_1\) 其中有一個或多個母體比例不一樣</li>
</ul>
</li>
<li>結論<ul>
<li>如果 <strong>不</strong>拒絕 \(H_0\)表示，我們不能確認可能其中有一個或多個母體比例不同</li>
<li>如果 拒絕 \(H_0\)表示，我們可以確認其中一定有一個或多個母體比例不同，之後還可以用更多分析來得知是哪個母體比例與其他不同</li>
</ul>
</li>
</ul>
<h2 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h2><ul>
<li>期望公式是 \(e_{ij} = \frac{\text{(Row i Total)} \text{(Column j Total)} }{\text{Total Sample Size}}\)</li>
<li>卡方分配敘述統計 chi-square test statistic<ul>
<li>公式 \(x^2 = \sum_i \sum_j \frac{(f_{ij} - e_{ij})^2}{e_{ij}}\)</li>
<li>\(f_{ij}\) 我們實際資料所計算出來的機率</li>
<li>\(e_{ij}\) 我們透過預期公式計算出來的機率</li>
<li>注意：卡方分配的自由度必須是 \(k-1\)，k 等於分類的母體，每一個欄位值(cell)都必須要大於 5</li>
</ul>
</li>
<li>拒絕法則 Rejection Rule<ul>
<li>p-value 方法 Reject \(H_0 \) if \(p-value \leq \alpha\)</li>
<li>Critical Value approach Reject \(H_0\) if \(x^2 \geq x_{\alpha}^2\) </li>
<li>其中自由度 \(k-1\)</li>
</ul>
</li>
</ul>
<h2 id="舉例：建商有三種類型的房子，為了規劃生產線，因此建商想要了解顧客對於這三種類型的房子的滿意度如何，然後比較是否這些房子滿意度都相同"><a href="#舉例：建商有三種類型的房子，為了規劃生產線，因此建商想要了解顧客對於這三種類型的房子的滿意度如何，然後比較是否這些房子滿意度都相同" class="headerlink" title="舉例：建商有三種類型的房子，為了規劃生產線，因此建商想要了解顧客對於這三種類型的房子的滿意度如何，然後比較是否這些房子滿意度都相同"></a>舉例：建商有三種類型的房子，為了規劃生產線，因此建商想要了解顧客對於這三種類型的房子的滿意度如何，然後比較是否這些房子滿意度都相同</h2><ul>
<li>定義名詞<ul>
<li>\(p_1\) 第一種房子的母體比例</li>
<li>\(p_2\) 第二種房子的母體比例</li>
<li>\(p_3\) 第三種房子的母體比例</li>
</ul>
</li>
<li>現在我們進行抽樣，每一個樣本包含分類資料，表示消費者會不會再購買他們之前所買的房子類型</li>
<li>資料如下，其中 Colonial 是第一種、log 是第二種、A-frame 是第三類<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1DJlMzbrW6ZQmEFlt1LWazpjVt0hYwLu6&export=download" alt=""></p>
</blockquote>
</li>
<li>我們想知道，這三種房屋回購率比例是不是一樣</li>
<li>進行假設測試<ul>
<li>我們現在定義 \(H_0\) 就是全部母體比例相同，因此期望公式是 \(e_{ij} = \frac{\text{(Row i Total)} \text{(Column j Total)} }{\text{Total Sample Size}}\)，記住，<strong>這是預期符合比例計算出來的值</strong></li>
<li>如果我們計算出來的假設檢定值小於顯著型測試就 reject \(H_0\)</li>
<li>其中計算完如下，裡面的 97.50 則是透過 \((260)(135)/360 = 97.50\)，以此類推   <blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1k3Luo-Fdkr4LwTy3cWeScaz-mnwvupem&export=download" alt=""></p>
</blockquote>
</li>
<li>直接透過表格告訴你卡方敘述測試統計<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1-dlbjaCu__47wc2fIUOXqYhhek-tB9Ii&export=download" alt=""></p>
</blockquote>
</li>
</ul>
</li>
<li>拒絕法則 Rejection Rule<ul>
<li>p-value<ul>
<li>p-value 方法 Reject \(H_0 \) if \(p-value \leq \alpha\)</li>
<li>Critical Value approach Reject \(H_0\) if \(x^2 \geq x_{\alpha}^2\) </li>
<li>其中自由度 \(k-1\)，k 等於分類的母體</li>
<li>圖表資料如下<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1feyZcN4IR0F34R1DxUz12s32RbxnNIh9&export=download" alt=""></p>
</blockquote>
</li>
<li>我們計算出來的卡方分配，透過 probability Distrubution app 計算如下，機率為 0.98690<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1U97DRuqpoQqBhARxw4QrqHm9IIdxI6lE&export=download" alt=""></p>
</blockquote>
</li>
<li>因此 \(p-value = 1- 0.98690 = 0.0131 \leq 0.05 = \alpha\)，所以拒絕 \(H_0\)</li>
<li>所以這三種比例不完全相同</li>
</ul>
</li>
<li>cirtical value<ul>
<li>由於 \(\alpha = 0.05 \) 的 \(x^2 = 5.991\)，而我們計算出來的 \(x_k^2 =  8.67\)，因此拒絕 \(H_0\)。 </li>
<li>因此這三種比例不完全相同</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="多重比較程序-Multiple-Comparisons-Procedure"><a href="#多重比較程序-Multiple-Comparisons-Procedure" class="headerlink" title="多重比較程序 Multiple Comparisons Procedure"></a>多重比較程序 Multiple Comparisons Procedure</h2><p>但我們接受 \(H_1\) 時，勢必我們要找出到底是哪個比例不一樣，此時就需要用到多重比較程序。<br>我們計算 critical value，如果兩者房屋的差異大於 critical value，就表示他們有顯著差異。</p>
<p>這邊我們延續上面的舉例，找出哪個母體比例與其他不同</p>
<ul>
<li>計算比例<ul>
<li>第一種房子為 \(\bar{p_1} = \frac{100}{135} = 0.741\)</li>
<li>第二種房子為 \(\bar{p_2} = \frac{81}{101} = 0.802\)</li>
<li>第三種房子為 \(\bar{p_3} = \frac{83}{124} = 0.669\)</li>
</ul>
</li>
<li>進行比較<ul>
<li>第一種與第二種房屋差異為 \(| \bar{p_1} - \bar{p_2}| = |0.741- 0.802| = 0.061\)</li>
<li>第一種與第三種房屋差異為 \(| \bar{p_1} - \bar{p_3}| = |0.741- 0.669| = 0.072\)</li>
<li>第二種與第三種房屋差異為 \(| \bar{p_2} - \bar{p_3}| = |0.802- 0.669| = 0.133\)</li>
</ul>
</li>
<li>計算臨界值 Critical Value<ul>
<li>\(CV_{ij} = \sqrt{x_{\alpha ; k-1}^2} \sqrt{\frac{\bar{p_i}(1-\bar{p_i})}{n_i} + \frac{\bar{p_j}(1-\bar{p_j})}{n_j }} \)</li>
<li>透過圖表顯示差異，其中第二種房屋與第三種房屋的明顯差異<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1dzMXIzhTBF9AQhxnW99xG2wVyoJa7jLd&export=download" alt=""></p>
</blockquote>
</li>
<li>於是我們現在回去看例子，是哪種房屋的回購比例比較高，回去看<strong>計算比例</strong>，現在我們可以得知，購買第二種房屋的比例較高有 0.802</li>
</ul>
</li>
</ul>
<h1 id="獨立性測試-Test-of-Independence"><a href="#獨立性測試-Test-of-Independence" class="headerlink" title="獨立性測試 Test of Independence"></a>獨立性測試 Test of Independence</h1><p>計算兩個類別變數是否相互獨立，使用此測試的 step 如下：</p>
<ul>
<li>建立虛無與對立假設<ul>
<li>\(H_0\) 變數是相互獨立</li>
<li>\(H_1\) 變數不獨立</li>
</ul>
</li>
<li>紀錄樣本</li>
<li>計算預期頻率，\(e_{ij}\)<br>\(e_{ij} = \frac{\text{(Row i Total)} \text{(Column j Total)} }{\text{Total Sample Size}}\)</li>
<li>計算測試檢定<br>\(x^2= \sum_i \sum_j \frac{f_{ij} - e_{ij}^2}{e_ij}\)</li>
<li>確認拒絕法則<ul>
<li>Reject \(H_0\) if \(p-value \leq \alpha\) or \(x^2 \geq x_{\alpha}^2\)</li>
<li>其中 \(\alpha\) 為顯著性水準，其中自由度為 \((r-1)(c-1)\)，r 為 rows and m is columns</li>
</ul>
</li>
</ul>
<h2 id="舉例：建商想要知道不同的種類房子與房價是否獨立的嗎？下面有資料，然後我們現在要測試下列這四種分類是否為獨立變數"><a href="#舉例：建商想要知道不同的種類房子與房價是否獨立的嗎？下面有資料，然後我們現在要測試下列這四種分類是否為獨立變數" class="headerlink" title="舉例：建商想要知道不同的種類房子與房價是否獨立的嗎？下面有資料，然後我們現在要測試下列這四種分類是否為獨立變數"></a>舉例：建商想要知道不同的種類房子與房價是否獨立的嗎？下面有資料，然後我們現在要測試下列這四種分類是否為獨立變數</h2><p>資料如下，其中資料分類成四種分類與兩種價格</p>
<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1ZpPcpsh1AQdzcV8H_5uhBK5yWGsgYk_p&export=download" alt=""></p>
</blockquote>
<ul>
<li>建立虛無與對立假設<ul>
<li>\(H_0\) 房價與房屋類型是相互獨立</li>
<li>\(H_1\) 房價與房屋類型不獨立</li>
</ul>
</li>
<li>計算預期頻率如下<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=185BuZMMJ5ywweVS9aZQACJJD_iwzSUOc&export=download" alt=""></p>
</blockquote>
</li>
<li>計算自由度<br>由於價格分兩類，房屋分四類，所以就是 \((2-1)(4-1) = 3\)</li>
<li>Rejection Rule<br>在 \(\alpha = 0.05 \)，與自由度為 3 時， \(X_{0.05}^2 = 7.815\)，因此 Reject \(H_0\) if \(p-value \leq \alpha = 0.05 \) or \(X^2 \geq 7.815\)<ul>
<li>計算卡方分配<br>\(X^2 = \frac{(18-16.5)^2}{16.5} + \frac{(6-11)^2}{11} + … + \frac{(3-6.75)^2}{6.75} = 0.1364+2.2727+…+2.0833 = 9.149\)</li>
<li>p-value<br>當自由度為 3 時，用 probability distribution app 計算出來的值為 0.02737<ul>
<li>圖片表示<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1HIcHS64zaeFjyicLxQ26XOOQnFnnLe6c&export=download" alt=""></p>
</blockquote>
</li>
<li>因此 \(a = 0.05 \geq 0.0274 = p-value\)，reject \(H_0\)    </li>
</ul>
</li>
<li>Critical Value<br>在自由度為 3 時，機率 0.05 為 \(X^2 =7.815\)，我們計算出來的卡方分配 \(9.149 \geq 7.815\)，所以拒絕 \(H_0\) </li>
</ul>
</li>
<li>總結<br>在百分之 95 的信心水準中，我們可以知道房價與房屋類型不獨立</li>
</ul>
<h1 id="適合度檢定-Goodness-of-Fit-Test"><a href="#適合度檢定-Goodness-of-Fit-Test" class="headerlink" title="適合度檢定 Goodness of Fit Test"></a>適合度檢定 Goodness of Fit Test</h1><h2 id="檢定卡方分配-Goodness-of-Fit-Test-Chi-Square"><a href="#檢定卡方分配-Goodness-of-Fit-Test-Chi-Square" class="headerlink" title="檢定卡方分配 Goodness of Fit Test: Chi-Square"></a>檢定卡方分配 Goodness of Fit Test: Chi-Square</h2><p>檢定所有類型的資料是否符合我們預期的卡方分配，使用此測試的 step 如下：</p>
<ul>
<li>建立虛無與對立假設<ul>
<li>\(H_0\) 母體每一種分類符合我們所設定的機率分配</li>
<li>\(H_1\) 母體每一種分類<strong>一個或多個不</strong>符合我們所設定的機率分配</li>
</ul>
</li>
<li>蒐集樣本，並計算出觀察頻率 \(f_{i}\)</li>
<li>假設 \(H_0\) 是對的，計算期望頻率 \(e_i\)，對於樣本的每一種分類</li>
<li>計算卡方檢定，公式為 \(X^2= \sum_{i=1}^k \frac{(f_i - e_i )^2}{e_i}\)，其中<ul>
<li>\(f_i\) 觀察頻率</li>
<li>\(e_i\) 期望頻率</li>
<li>\(k\) 分類總數，其中 \(k-1\) 為自由度，且裡面每項數值(cell)都要大於 5</li>
<li>此公式只適用在卡方(chi-square)分配</li>
</ul>
</li>
<li>拒絕法則<ul>
<li>p-value apporach: Reject \(H_0\) if \(p-value \leq \alpha\)</li>
<li>Critical value approach: Reject \(H_0\) if \(X^2 \geq X_{\alpha}^2\)</li>
</ul>
</li>
</ul>
<h3 id="舉例：建商有-colonial-log-capin-split-level-A-frame，這四種類型房子，規劃人員想知道這四種房子哪些會引起之前的消費者才重新購買"><a href="#舉例：建商有-colonial-log-capin-split-level-A-frame，這四種類型房子，規劃人員想知道這四種房子哪些會引起之前的消費者才重新購買" class="headerlink" title="舉例：建商有 colonial, log capin, split-level, A-frame，這四種類型房子，規劃人員想知道這四種房子哪些會引起之前的消費者才重新購買"></a>舉例：建商有 colonial, log capin, split-level, A-frame，這四種類型房子，規劃人員想知道這四種房子哪些會引起之前的消費者才重新購買</h3><p>資料如下:</p>
<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=19C63msfjHbavEU2jJkRh18kYgn4ImIpV&export=download" alt=""></p>
</blockquote>
<ul>
<li>建立虛無與對立假設<ul>
<li>\(H_0: p_C = p_L = p_S = p_A = 0.25\)</li>
<li>\(H_1\) 讓上面的等式不成立</li>
<li>\(p_C\) 購買 colonial 的母體比例</li>
<li>\(p_L\) 購買 log capin 的母體比例</li>
<li>\(p_S\) 購買 split-level 的母體比例</li>
<li>\(p_A\) 購買 A-frame 的母體比例</li>
</ul>
</li>
<li>Rejection Rule<ul>
<li>自由度為 3，機率為 0.95，用 probability distribution app 計算出來的值為 7.815</li>
<li>透過圖表表示<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1UDamL0rEhHLlxc_Bn46tPKINnL8FA3DE&export=download" alt=""></p>
</blockquote>
</li>
</ul>
</li>
<li>Expected Frequencies<ul>
<li>\(e_C = 0.25(100) = 25\)</li>
<li>\(e_L = 0.25(100) = 25\)</li>
<li>\(e_S = 0.25(100) = 25\)</li>
<li>\(e_A = 0.25(100) = 25\)</li>
</ul>
</li>
<li>計算卡方值<br>\(x^2 = \frac{(30-25)^2}{25} + \frac{(20-25)^2}{25} + \frac{(35-25)^2}{25}+ \frac{(15-25)^2}{25} = 1+1+4+4 = 10\)</li>
<li>使用方法<ul>
<li>p-value approach<ul>
<li>自由度為 3，x = 10，用 probability distribution app 計算出來的機率為 0.01857</li>
<li>因此 \(p-value = 0.01857 \leq 0.05 = \alpha\)，拒絕 \(H_0\)</li>
</ul>
</li>
<li>critical value approach<ul>
<li>\(X^2 = 10 \geq 7.815\)，拒絕 \(H_0\)</li>
</ul>
</li>
</ul>
</li>
<li>結論<br>在百分之 95 的信心水準中，我們可以知道購買此四種房屋比例並不同</li>
</ul>
<h2 id="檢定常態分配-Goodness-of-Fit-Test-Normal-Distribution"><a href="#檢定常態分配-Goodness-of-Fit-Test-Normal-Distribution" class="headerlink" title="檢定常態分配 Goodness of Fit Test: Normal Distribution"></a>檢定常態分配 Goodness of Fit Test: Normal Distribution</h2><p>檢定所有類型的資料是否符合我們預期的常態分配，使用此測試的 step 如下：</p>
<ul>
<li>建立虛無與對立假設<ul>
<li>\(H_0\) 母體每一種分類符合常態機率分配</li>
<li>\(H_1\) 母體每一種分類<strong>一個或多個不</strong>合常態機率分配</li>
</ul>
</li>
<li>蒐集樣本<ul>
<li>計算 mean and standard </li>
<li>確定區間裡面每個值，並計算預期頻率，至少區間都不小於 5</li>
<li>紀錄其觀察區間</li>
</ul>
</li>
<li>計算期望頻率 \(e_i\)，對於樣本的每一種分類</li>
<li>計算常態分配公式 \(X^2 = \sum_{i=1}^k \frac{(f_i - e_i )^2}{e_i}\)</li>
<li>拒絕法則<ul>
<li>\(X_a^2\) 為顯著性測試的值</li>
<li>\(X^2\) 為題目的實際數值</li>
<li>Reject \(H_0\) if \(X^2 \geq X_a^2\) or \(p-value &lt; \alpha\)，且自由度必須是 \(k-p-1\)，而 k 表示區間，其中 p 為我們在樣本中用到的統計參數(例如: 平均數、標準差)</li>
</ul>
</li>
</ul>
<h3 id="舉例：電腦製造商要評估銷售員績效，查看她們年銷售量，在-0-05-的顯著水準中，想看業務員是否都遵守常態機率分配"><a href="#舉例：電腦製造商要評估銷售員績效，查看她們年銷售量，在-0-05-的顯著水準中，想看業務員是否都遵守常態機率分配" class="headerlink" title="舉例：電腦製造商要評估銷售員績效，查看她們年銷售量，在 0.05 的顯著水準中，想看業務員是否都遵守常態機率分配"></a>舉例：電腦製造商要評估銷售員績效，查看她們年銷售量，在 0.05 的顯著水準中，想看業務員是否都遵守常態機率分配</h3><p>資料如下，表示三十位銷售員銷售的數量</p>
<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1tys-9TuNllqLrBSKmKBHUYslMMNkYxIz&export=download" alt=""></p>
</blockquote>
<ul>
<li>建立虛無與對立假設<ul>
<li>\(H_0\) 母體銷售量符合常態分配且平均數 71 標準差 18.54</li>
<li>\(H_1\) 與 \(H_0\) 不同</li>
</ul>
</li>
<li>符合檢定常態分配要求，每個區間的值要大於 5，因此 \(30/5=6\)，我們將常態分配分成 6 個區間，因此我們要讓常態分配的每塊區間機率都是 \(1 / 6 = 0.1667\)，圖表如下。(其中 z 值不同的原因是要使每塊區間機率都是 0.1667，公式轉換則是 \(\text{mean} + (\text{每個區間的機率分界點}\text{standard deviation}) \))，此題目分界點為 0.97, 0.81 … 等。<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1uX-yFHcT3Hfs4vWRFZmSf1PWXN5IEVXa&export=download" alt=""></p>
</blockquote>
</li>
<li>樣本觀察頻率與預期頻率如下<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1mb0u74Cy9ybNmqNjJ-mnmJd1Gte-WR-t&export=download" alt=""></p>
</blockquote>
</li>
<li>計算常態分配<br>\(X^2 = \frac{(1)^2}{5} + \frac{(-2)^2}{5} +\frac{(1)^2}{5} + \frac{(0)^2}{5} + \frac{(-1)^2}{5} + \frac{(1)^2}{5} = 1.600\)</li>
<li>Rejection Rule    <ul>
<li>\(\alpha = 0.05 \) and 自由度 (k-p-1=6-2-1=3\)， p 為平均數與標準差。</li>
<li>自由度為 3，機率等於 0.05，用 probability distribution app 計算出來的\(X_a^2\) 7.815</li>
<li>自由度為 3，\(X^2=1.600\)，用 probability distribution app 計算出來的機率為 0.6594</li>
</ul>
</li>
<li>使用方法<ul>
<li>p-value<br>\(p-value = 0.6594 \geq 0.05 = \alpha\)，not rejected \(H_0\)</li>
<li>critical value<br>\(X_a^2 = 7.815 \geq 1.6 = X^2\)，not rejected \(H_0\)</li>
</ul>
</li>
<li>結論<br>沒有證據可以表示，他們並不符合常態分配。</li>
</ul>
<p>辛苦大衛了。</p>
]]></content>
      <categories>
        <category>北科上課筆記</category>
        <category>統計 statistics</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>統計學筆記</tag>
        <tag>北科大二下統計學筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>統計學(二) 筆記 - 第十六章 迴歸分析 - 模型建立(Regression Analysis - Model Building)</title>
    <url>/2021/05/24/statistics/statistics-ch16/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊與財金管理系大二下統計學重點整理<br><font color="#dd0000">並非所有人都適用，部分對我而言稍加容易的內容並不會寫在此內。</font><br><strong>這是觀看影片心得後的筆記，老師上課可能不太適用會忘記抄到</strong></p>
</blockquote>
<a id="more"></a>

<h1 id="一般線性模型與二階模型-General-Linear-Model-and-a-second-order-model"><a href="#一般線性模型與二階模型-General-Linear-Model-and-a-second-order-model" class="headerlink" title="一般線性模型與二階模型 General Linear Model and a second-order model"></a>一般線性模型與二階模型 General Linear Model and a second-order model</h1><ul>
<li>在<a href="https://theriseofdavid.github.io/2021/05/15/NTUT_note/statistics-ch15/" target="_blank" rel="noopener">統計學(二) 筆記 - 第十五章 複迴歸(Multiple Regression) by 大衞的筆記</a>中，我們知道所有的回歸線性方程式中所有自變數都是一次項。</li>
<li>我們的自變數用 \(p\) 來表示，因此線性模型方程式的表達會是<br>\(y = \beta_0 + \beta_1 z_1 + \beta_2 z_2 + … + \beta_p z_p +  \mathcal{E}  \)，原本在第 15 章中，\(z\) 的位置是 \(x\)，但在這邊，\(z\) 可以是許多 \(x\) 的組合，如： \(z_1 = x_1 * x_2 * x_3 \)</li>
<li>我們進行舉例，\(y = \beta_0 + \beta_1 z_1 + \beta_2 z_2 + … + \beta_p z_p +  \mathcal{E}  \) 的變化<ul>
<li>staright-line relationship<ul>
<li>當 \(z_1 = x_1\)</li>
<li>則 \(y = \beta_0 + \beta_1 x_1 +  \mathcal{E}\)，</li>
</ul>
</li>
<li>曲線型模型 curvilinear realtionship <ul>
<li>當 \(z_1 = x_1, z_2 = x_1^2\)</li>
<li>則 \(y = \beta_0 + \beta_1 x_1 + \beta_2 x_1^2 \mathcal{E}\)</li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- 
## 舉例：在 2011年許多城市的房屋租金比房屋每月繳還貸款更便宜，我們蒐集了 10 個程式的中位數資料，來討論一些問題
* Question A: 請將租金設定為自變數，貸款為應變數，並劃出散佈圖
* Question B: 使用簡單線性回歸模型，透過租金去預估貸款；並且在想透過殘差圖來判斷此模型適不適合
* Question C: 我們使用 second-order model(二階模型，方程式中有二次方)，透過租金去預估貸款
* Question D: 用簡單線性回歸模型比較好，還是用 second-order model 比較好 
-->

<h2 id="自變數內交互作用-Interaction"><a href="#自變數內交互作用-Interaction" class="headerlink" title="自變數內交互作用 Interaction"></a>自變數內交互作用 Interaction</h2><p>我們想要觀察原始資料中的兩個自變數(分別為 \(x_1, x_2\))，是否有關連性，我們可以使用 a second-order model with two predictor vaiables(透過二階模型預測兩遍數)</p>
<p>公式為：\(y = \beta_0 + \beta_1 x_1 + \beta_2 x_2 + \beta_3 x_1^2 + \beta_4 x_2^2 + \beta_5 x_1 x_2 +  \mathcal{E}  \)，而 \(\beta\) 後面的項目則是我們的 \(z\)，舉例：\(z_5 = x_1 x_2\) </p>
<h3 id="舉例"><a href="#舉例" class="headerlink" title="舉例"></a>舉例</h3><blockquote>
<p>在這張圖中，可以明顯看出來在 Selling Prices 是 2.00 時，投入越多的廣告費用則獲益越大，但 Selling Prices 是 2.50 時，投入越多的廣告費用沒有比 2.00 大，在 Selling Prices 是 3.00 時，廣告的效益幾乎沒有了。<br>Difference of 是原始資料在相同的銷售價額中，投入最少的廣告費用與最多的廣告費用差額<br><img src="https://drive.google.com/u/2/uc?id=1vOb6M0tNzaAt302D5B6WliNvRpvxwbqi&export=download" alt=""></p>
</blockquote>
<blockquote>
<p>在這張圖中，上面的公式的 \(\beta_3 x_1 x_2\) 是 PriceAdv，可以看出銷售價格與廣告費用有負相關<br>我們對 PriceAdv 做假設檢定，也可以得出 \(p = 0.000\)，表示拒絕 \(H_0\)，此變數與 y 有關係<br>\(adj(R^2)\) 也表現良好，來到 97.5%，很棒的結果<br>F 檢定也判定出所有的自變數都與 y 有關聯，\(p = 0.000\)<br><img src="https://drive.google.com/u/2/uc?id=1pEVj0EAxKVtE38tW_w6bGdT2ogWXv69V&export=download" alt=""></p>
</blockquote>
<h2 id="關於應變數的轉換-Transformations-Involving-the-Dependent-Variable"><a href="#關於應變數的轉換-Transformations-Involving-the-Dependent-Variable" class="headerlink" title="關於應變數的轉換 Transformations Involving the Dependent Variable"></a>關於應變數的轉換 Transformations Involving the Dependent Variable</h2><ul>
<li>在有時候我們會遇到有些自變數沒有變異數的狀況(EX: 交互作用)，遇到這些問題我們要怎麼解決呢？<ul>
<li>方法 A: 將回歸方程式的 \(\mathcal{E} \) 改為 \(e = 2.71828 \) 也就是 \(ln_{10}\)</li>
<li>方法 B: 將 y 變成 \(1/y\) 後，我們的回歸方程式改成去預測 \(1/y\)</li>
</ul>
</li>
</ul>
<h2 id="有些非線型的模型可以透過數學轉換為線性模型-Nonlinear-Models-That-are-Intrinsically-Linear"><a href="#有些非線型的模型可以透過數學轉換為線性模型-Nonlinear-Models-That-are-Intrinsically-Linear" class="headerlink" title="有些非線型的模型可以透過數學轉換為線性模型 Nonlinear Models That are Intrinsically Linear"></a>有些非線型的模型可以透過數學轉換為線性模型 Nonlinear Models That are Intrinsically Linear</h2><ul>
<li>假設我們模型中有 \(\beta_0, \beta_1, …, \beta_p\)，且她們的 z 有些有 \(x^n\)，大於或等於 a second-order model</li>
<li>這時候我們可以進行一些數學的轉換來讓他們變成線性模型<ul>
<li>EX: 原本的非線性方程式 \(E(y) = \beta_0 \beta_1^x\)</li>
<li>我們可以透過 log 進行轉換， \(ln \ E(y) = ln \beta_0 + x ln \beta_1\)，把前面的公式每項變數改為 \(y’ = \beta_0’ + beta_1’ x\)，這樣就成為了一個線性模型！</li>
</ul>
</li>
</ul>
<h1 id="確認何時進行刪除與增加變數-Determining-When-to-Add-or-Delete-Variables"><a href="#確認何時進行刪除與增加變數-Determining-When-to-Add-or-Delete-Variables" class="headerlink" title="確認何時進行刪除與增加變數 Determining When to Add or Delete Variables"></a>確認何時進行刪除與增加變數 Determining When to Add or Delete Variables</h1><ul>
<li>我們有時候沒有辦法確定現在模型中的所有應變數都是適合預測</li>
<li>刪除 A 應變數，我們能保證刪除她更好預測嗎？</li>
<li>增加 B 應變數，我們能保證有加入他更適合預測嗎？</li>
<li>此時我們使用 F 檢定來進行判斷<ul>
<li>公式概念：\(F = \frac{(SSE(\text{增加 or 缺少的應變數})) / \text{number of extra terms}}{MSE(\text{增加 or 缺少的應變數})}\)</li>
<li>不懂 SSE、MSE 則可以看 <a href="https://theriseofdavid.github.io/2021/05/02/statistics/statistics-ch14/#%E5%88%A4%E5%AE%9A%E4%BF%82%E6%95%B8-Cofficient-of-Determination" target="_blank" rel="noopener">判定係數 by 大衛的筆記</a></li>
<li>公式：\(F = \frac{(SSE(x_1) - SSE(x_1, x_2)) / 1 }{(SSE(x_1, x_2)) / (n-p-1)}\)<ul>
<li>這邊我們假設，全部的應變數最多有兩個，我們刪除 \(x_2\) 的情況</li>
<li>因此 \(\text{number of extra terms} = 1\) 移除了 \(x_2\)</li>
<li>\(p=1\)，因為我們使用的參數只剩下 \(x_1\)</li>
</ul>
</li>
<li>接下來我們透過 F 檢定計算出 \(p-value\) 後去對 \(\alpha\) 比較<ul>
<li>Reject \(H_0\) 就可以執行此命令</li>
<li>如果沒有，就不進行改動</li>
</ul>
</li>
</ul>
</li>
<li>除了使用 F 檢定我們也可以用 t 檢定進行刪除或增加變數，還記得我們之前有在<a href="https://theriseofdavid.github.io/2021/05/15/statistics/statistics-ch15/#%E9%A1%AF%E8%91%97%E6%80%A7%E6%B8%AC%E8%A9%A6-Testing-for-Significance" target="_blank" rel="noopener">複回歸做顯著性測試嗎?</a>，<ul>
<li>我們會找出所有應變數的 t，如果 t not reject \(H_0\) 我們就可以移除此變數</li>
<li>如果沒有，那我們可以將 t 值最小的進行移除，<strong>記住，每移除一個變數就必須重做一次回歸</strong>，因為我們沒有辦法保證移除一個變數後，整個回歸方程式的線依然不變，有可能我們移除此變數後，其他變數的 t 值就改變。 </li>
</ul>
</li>
</ul>
<h1 id="選擇變數的程序-Variable-Selection-Procedures"><a href="#選擇變數的程序-Variable-Selection-Procedures" class="headerlink" title="選擇變數的程序 Variable Selection Procedures"></a>選擇變數的程序 Variable Selection Procedures</h1><h2 id="變數選擇：逐步回歸-Variable-Selection-Stepwise-Regression"><a href="#變數選擇：逐步回歸-Variable-Selection-Stepwise-Regression" class="headerlink" title="變數選擇：逐步回歸 Variable Selection: Stepwise Regression"></a>變數選擇：逐步回歸 Variable Selection: Stepwise Regression</h2><ul>
<li>一開始我們先只有一個自變數在回歸方程式，然後跑一遍</li>
<li>再來我們進行疊代<ul>
<li>移除疊代<ul>
<li>設定 \(\alpha\) 值</li>
<li>移除一個應變數</li>
<li>判斷移除後的回歸方程式的 F 檢定 p-value 是否有大於 \(\alpha\)</li>
<li>如果有，可以移除；如果沒有，不可以移除</li>
</ul>
</li>
<li>增加疊代<ul>
<li>如果已經不能再做移除疊代，則做增加疊代</li>
<li>設定 \(\alpha\) 值，必須<strong>小於</strong>移除疊代的 \(\alpha\) 不同，不可以等於，這樣則會無窮迴圈</li>
<li><strong>增加</strong>一個應變數</li>
<li>判斷移除後的回歸方程式的 F 檢定 p-value 是否有小於 \(\alpha\)</li>
<li>如果有，可以增加，並<strong>重新進行移除疊代</strong>；如果沒有，不可以增加</li>
</ul>
</li>
</ul>
</li>
<li>如此來找出最好的回歸方程式</li>
<li>流層圖如下<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1eq2MkP8onnyc1-Vx4rn0US9UQtGPb7kg&export=download" alt=""></p>
</blockquote>
</li>
</ul>
<h2 id="變數選擇：-不斷消除-Variable-Selection-Backward-Elimination"><a href="#變數選擇：-不斷消除-Variable-Selection-Backward-Elimination" class="headerlink" title="變數選擇： 不斷消除 Variable Selection: Backward Elimination"></a>變數選擇： 不斷消除 Variable Selection: Backward Elimination</h2><ul>
<li>一開始我們<strong>所有</strong>自變數在回歸方程式，然後跑一遍</li>
<li>再來我們進行疊代<ul>
<li>移除疊代<ul>
<li>設定 \(\alpha\) 值</li>
<li>移除一個應變數</li>
<li>判斷移除後的回歸方程式的 F 檢定 p-value 是否有小於 \(\alpha\)</li>
<li>如果有，可以移除，並重複此步驟；如果沒有，就不在需要進行疊代</li>
</ul>
</li>
</ul>
</li>
<li>如此來找出最好的回歸方程式</li>
<li>流層圖如下<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1oWTjVxAiLR38fO5_q7QqNrKhhTCUrAPA&export=download" alt=""></p>
</blockquote>
</li>
</ul>
<h3 id="舉例：房地產公司想針對-A-地區做房價預測，於是他找出-25-筆當地房屋成交資料，我們透過-Backward-Elimination-找出迴歸分析需要的自變數，-alpha-0-05"><a href="#舉例：房地產公司想針對-A-地區做房價預測，於是他找出-25-筆當地房屋成交資料，我們透過-Backward-Elimination-找出迴歸分析需要的自變數，-alpha-0-05" class="headerlink" title="舉例：房地產公司想針對 A 地區做房價預測，於是他找出 25 筆當地房屋成交資料，我們透過 Backward Elimination 找出迴歸分析需要的自變數，\(alpha = 0.05\)"></a>舉例：房地產公司想針對 A 地區做房價預測，於是他找出 25 筆當地房屋成交資料，我們透過 Backward Elimination 找出迴歸分析需要的自變數，\(alpha = 0.05\)</h3><blockquote>
<p>資料如下<br><img src="https://drive.google.com/u/2/uc?id=1rRF7ismKXpsZJs6wVF7flOrw5P3veNpD&export=download" alt=""></p>
</blockquote>
<ul>
<li>現在我們有四個自變數(House Size, Bedrooms, Bathrooms, Cars)，與一個因變數(price)，開始進行迴歸分析中的變數選擇： 不斷消除<ul>
<li>我們可以發現 Cars 的 p-value 最大並且大於 0.05(\(\alpha\))，因此我們進行移除。<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1dXapSPVrbYmp89baD__6P0BVzd2gJTTP&export=download" alt=""></p>
</blockquote>
</li>
<li>我們可以發現 Bedrooms 的 p-value 最大並且大於 0.05(\(\alpha\))，因此我們進行移除。<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1b4gQgYowplFFnORL6V5kR1gbQyzbVCXr&export=download" alt=""></p>
</blockquote>
</li>
<li>我們可以發現 Bathrooms 的 p-value 最大並且大於 0.05(\(\alpha\))，因此我們進行移除。<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=10SNPQ5NU3MRXWRPVg6gwbQyfoGUT6B5w&export=download" alt=""></p>
</blockquote>
</li>
<li>我們可以發現 Bathrooms 的 p-value 最大，可是<strong>小於</strong> 0.05(\(\alpha\))，因此我們<strong>無法</strong>移除。<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=11vBT4IPyTdnWDb7w73XAMotJUm6WqUEhH&export=download" alt=""></p>
</blockquote>
</li>
<li>因此我們到這邊就好，不需要再做改變</li>
</ul>
</li>
<li>接下來我們根據只有 house size 做回歸方程式，預測的回歸方程式為 \(\hat{y} = -9.8669 + 11.3383(\text{House Size})\)</li>
</ul>
<h2 id="變數選擇：-不斷增加-Variable-Selection-Forward-Elimination"><a href="#變數選擇：-不斷增加-Variable-Selection-Forward-Elimination" class="headerlink" title="變數選擇： 不斷增加 Variable Selection: Forward Elimination"></a>變數選擇： 不斷增加 Variable Selection: Forward Elimination</h2><ul>
<li>一開始我們先只有一個自變數在回歸方程式，然後跑一遍</li>
<li>再來我們進行疊代<ul>
<li>增加疊代<ul>
<li>設定 \(\alpha\) 值</li>
<li><strong>增加</strong>一個應變數</li>
<li>判斷移除後的回歸方程式的 F 檢定 p-value 是否有小於 \(\alpha\)</li>
<li>如果有，增加此自變數；如果沒有，就不在需要進行疊代</li>
</ul>
</li>
</ul>
</li>
<li>如此來找出最好的回歸方程式</li>
<li>流層圖如下<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1sZQMdb3uxYpfUm2ecUEuV6UAksLA01bw&export=download" alt=""></p>
</blockquote>
</li>
</ul>
<h2 id="變數選擇：-最佳子集合-Variable-Selection-Best-Subest-Regression"><a href="#變數選擇：-最佳子集合-Variable-Selection-Best-Subest-Regression" class="headerlink" title="變數選擇： 最佳子集合 Variable Selection: Best-Subest Regression"></a>變數選擇： 最佳子集合 Variable Selection: Best-Subest Regression</h2><ul>
<li>由於變數選擇： 不斷增加、變數選擇： 不斷消除、變數選擇：逐步回歸，這三種變數選擇方式都不一定可以找出最好的結果，但一定可以找出離最佳解最近的組合。</li>
<li>那我們要找出最佳解，怎麼找呢？<strong>排列組合</strong></li>
<li>我們可以定義我們要用幾個自變數進行迴歸分析，之後進行排列組合，並且每種組合輸出他的回歸方程式。</li>
<li>再來我們在每種組合中找出最棒的組合回歸方程式，也就是 \(\text{adjust} R^2\) 最高。</li>
<li>我們就使用她進行回歸方程式。</li>
<li>當然，我們也不一定要限定<strong>幾個</strong>，我們可以全部都來，從 1 個自變數到 n 個自變數都差不多。</li>
</ul>
<h3 id="舉例：我們想要預測高爾夫球比賽分數結果，下面會顯示我們的變數有哪些，請使用變數選擇：-最佳子集合找出迴歸分析需要的自變數，-alpha-0-05"><a href="#舉例：我們想要預測高爾夫球比賽分數結果，下面會顯示我們的變數有哪些，請使用變數選擇：-最佳子集合找出迴歸分析需要的自變數，-alpha-0-05" class="headerlink" title="舉例：我們想要預測高爾夫球比賽分數結果，下面會顯示我們的變數有哪些，請使用變數選擇： 最佳子集合找出迴歸分析需要的自變數，\(alpha = 0.05\)"></a>舉例：我們想要預測高爾夫球比賽分數結果，下面會顯示我們的變數有哪些，請使用變數選擇： 最佳子集合找出迴歸分析需要的自變數，\(alpha = 0.05\)</h3><ul>
<li>變數名稱與內容如下<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1BRF1y9xvZ5H21QLv6Sdqy8z1XZdSYxP5&export=download" alt=""></p>
</blockquote>
</li>
<li>資料有 Part1、Part2、Part3 由於這是舉例，因此就不類舉完整資料給大家看<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1JKo05nYzEW5Phi2jOW6WAAx4Hm8P5tqH&export=download" alt=""></p>
</blockquote>
</li>
</ul>
<ul>
<li>我們先用共線性進行判斷，看看哪兩個變數有共線性，看起來沒有<strong>明顯共線性</strong>，圖表如下<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1u95jVz_dPqCCh5MnX6UBd9CSUsQRTJKZ&export=download" alt=""></p>
</blockquote>
</li>
<li>再來我們進行排列組合，這裡只印出在使用 n 種自變數下，前兩個最好的\(\text{adjust} R^2\)<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=19IuLuaos5Dq2auK4EkB37dcYXojhZLRB&export=download" alt=""></p>
</blockquote>
</li>
<li>再來我們使用最好的\(\text{adjust} R^2\) 進行迴歸分析(也就是上面圖片中倒數第三個, n=4, \(\text{adjust} R^2 = 66.8\))<ul>
<li>其中我們可以看到 p-value 都有達顯著性水準(三顆星)</li>
<li>其中三顆星的標準如下，0.01、0.005、0.001</li>
<li><blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1z7_Tq7BoS_ysYdFoDCNx6MrXahermE-M&export=download" alt=""></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h1 id="針對虛擬變數做實驗設計複回歸方法-Multiple-Regression-Approach-to-Experimental-of-dummy-variable"><a href="#針對虛擬變數做實驗設計複回歸方法-Multiple-Regression-Approach-to-Experimental-of-dummy-variable" class="headerlink" title="針對虛擬變數做實驗設計複回歸方法 Multiple Regression Approach to Experimental of dummy variable"></a>針對虛擬變數做實驗設計複回歸方法 Multiple Regression Approach to Experimental of dummy variable</h1><ul>
<li><a href="https://theriseofdavid.github.io/2021/05/15/statistics/statistics-ch15/#%E9%A1%9E%E5%88%A5%E5%9E%8B%E8%AE%8A%E6%95%B8%E5%9C%A8%E8%A4%87%E8%BF%B4%E6%AD%B8%E4%B8%8B%E7%9A%84%E6%87%89%E7%94%A8-Categorical-Independent-Variables" target="_blank" rel="noopener">我們在第 15 章時有提到類別型變數在複迴歸下的應用，這邊則進行範例。</a></li>
<li>我們也可已針對虛擬變數做 ANOVA</li>
<li>當然也可以進行顯著性測試。</li>
<li>透過舉例來讓大家知道</li>
</ul>
<h2 id="舉例：製造商想要知道-Buffalo-Pittsburgh-Detroit-三個地方的工廠經理工時是否一樣，因此我們透過簡單隨機抽樣抽取樣本後，透過平均工時得知是哪地方的工廠經理，我們再針對這三個地方做回歸方程式、顯著性測試"><a href="#舉例：製造商想要知道-Buffalo-Pittsburgh-Detroit-三個地方的工廠經理工時是否一樣，因此我們透過簡單隨機抽樣抽取樣本後，透過平均工時得知是哪地方的工廠經理，我們再針對這三個地方做回歸方程式、顯著性測試" class="headerlink" title="舉例：製造商想要知道 Buffalo, Pittsburgh, Detroit 三個地方的工廠經理工時是否一樣，因此我們透過簡單隨機抽樣抽取樣本後，透過平均工時得知是哪地方的工廠經理，我們再針對這三個地方做回歸方程式、顯著性測試"></a>舉例：製造商想要知道 Buffalo, Pittsburgh, Detroit 三個地方的工廠經理工時是否一樣，因此我們透過簡單隨機抽樣抽取樣本後，透過平均工時得知是哪地方的工廠經理，我們再針對這三個地方做回歸方程式、顯著性測試</h2><blockquote>
<p>資料如下<br><img src="https://drive.google.com/u/2/uc?id=1w7DkGfq_vrvU9Sb8Aw-SbPSo27pA4Fee&export=download" alt=""></p>
</blockquote>
<ul>
<li>定義類別至虛擬變數<ul>
<li>\(A=0, B=0\) 為 Buffalo </li>
<li>\(A=1, B=0\) 為 Pittsburgh</li>
<li>\(A=0, B=1\) 為 Detroit</li>
</ul>
</li>
<li>因此將資料分類後，如下圖<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=17gRlhCekF3VNOe0G_yCyaIUZEkZ60O0G&export=download" alt=""></p>
</blockquote>
</li>
<li>因此我們的期望值計算為 \(E(y) = \beta_0 + \beta_1 A + beta_2 B\)<ul>
<li>For Buffalo: \(E(y) = \beta_0 + \beta_1 (0) + beta_2 (0) = \beta_0\)</li>
<li>For Pittsburgh: \(E(y) = \beta_0 + \beta_1 (1) + beta_2 (0) = \beta_1\)</li>
<li>For Detroit: \(E(y) = \beta_0 + \beta_1 (0) + beta_2 (1) = \beta_2\)</li>
</ul>
</li>
<li>因此，我們透過電腦計算好的回歸方程式如下。<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1eMGuMfgl8Jz-WRzavlFs1aHHWQW9tVRS&export=download" alt=""></p>
</blockquote>
</li>
<li>變數對於母體之顯著性測試<ul>
<li>首先，我們可以知道，在一般的母體顯著性測試中，\(H_0\) 都假設 y 與自變數沒有關係，這裡也是如此。<br>原因：如果 y 與自變數沒有任何關係，則理論上我用所有的自變數來預測 y 時，那 y 應該都要保持一樣的數字，才合理。</li>
<li>因此我們的假設檢定如下<ul>
<li>\(H_0: \beta_1 = \beta_2 = 0\)</li>
<li>\(H_1:\) 不符合上面公式</li>
</ul>
</li>
<li>進行 F 檢定，根據 ANOVA 公式計算，可以發現 \(0.003 = p-value &lt; 0.05 = \alpha\)，因此拒絕 \(H_0\)</li>
<li>結論：可以透過工廠的場地此變數來推估工廠經理的工作時數。</li>
</ul>
</li>
</ul>
<h1 id="資料序列相關與-Durbin-Watson-Test-Autocorrelation-and-the-Durbin-Watson-Test"><a href="#資料序列相關與-Durbin-Watson-Test-Autocorrelation-and-the-Durbin-Watson-Test" class="headerlink" title="資料序列相關與 Durbin-Watson Test,  Autocorrelation and the Durbin-Watson Test"></a>資料序列相關與 Durbin-Watson Test,  Autocorrelation and the Durbin-Watson Test</h1><ul>
<li>當 y 預測值會隨著時間的週期、順序，而有著不一樣的可能時，就不適用我們一般的複回歸方程式。</li>
<li>通常如果與時間有相關的 data 我們會稱為 autocorrelation: 序列相關、時間相關<ul>
<li>Positive Autocorrelation，前一期的殘差會使下一期殘差為正<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1gM5pDw2e2fis04VQzYfBfNHOT6XWyGw1&export=download" alt=""></p>
</blockquote>
</li>
<li>Negative Autocorrelation，前一期的殘差會使下一期殘差為負<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1OrvMc_hXutnf2YLVNH4S8P-v7CSpNSMP&export=download" alt=""></p>
</blockquote>
</li>
</ul>
</li>
<li>如果資料擁有此現象時，則違反了<a href="https://theriseofdavid.github.io/2021/05/02/statistics/statistics-ch14/#%E5%81%87%E8%A8%AD%E6%A8%A1%E5%9E%8B%E4%B8%8B%E7%9A%84%E8%AA%A4%E5%B7%AE%E9%A0%85-Model-Assumptions-About-the-Error-Term-mathcal-E" target="_blank" rel="noopener">假設模型下的誤差項 Model Assumptions About the Error Term E</a> </li>
<li><em>\(\mathcal{E}\) 為獨立變數，每一個變數的 \(\mathcal{E}\) 都不同，互相獨立*</em>，因為 \(\mathcal{E} \) 不在是獨立變數了</li>
</ul>
<h2 id="Durbin-Watson-Test"><a href="#Durbin-Watson-Test" class="headerlink" title="Durbin-Watson Test"></a>Durbin-Watson Test</h2><ul>
<li>由於我們的 \(\mathcal{E}\) 不再符合我們的假設模型，因此我們幫他建立新公式</li>
<li>\( \mathcal{E}_t = \rho \mathcal{E}_{t-1} + z_t\)<ul>
<li>\(\rho \) 上一期有多少的資訊會留給當前資料，此數值介於 \(-1 - 1\)，-1 表示負相關、1 表示正相關、0 表示無相關</li>
<li>\(\mathcal{E}_{t-1}\) 前一期的殘差項</li>
<li>\( z_t\) 原先<a href="https://theriseofdavid.github.io/2021/05/02/statistics/statistics-ch14/#%E5%81%87%E8%A8%AD%E6%A8%A1%E5%9E%8B%E4%B8%8B%E7%9A%84%E8%AA%A4%E5%B7%AE%E9%A0%85-Model-Assumptions-About-the-Error-Term-mathcal-E" target="_blank" rel="noopener">假設模型下的誤差項 Model Assumptions About the Error Term E</a>中 <strong>\(\mathcal{E}\)  是常態分配的隨機變數</strong></li>
</ul>
</li>
<li>Durbin-Watson Test 假設檢定<ul>
<li>我們的 Durbin-Watson Test 假設檢定就是要檢定我們的資料是否有 Autocorrelation。</li>
<li>\(H_0: \rho = 0 \)</li>
<li>\(H_1: \rho &gt; 0, \rho &lt; 0, \rho != 0\)，都可以分別代表，正相關、負相關、有相關；再適合的時機使用就好。</li>
</ul>
</li>
<li>Durbin-Watson Test Statistic 的公式則為 <ul>
<li>\(d = \frac{\sum_{t=2}^n \ (e_t - e_{t-1} \ )^2 }{ \sum_{t=1}^n \  (e_t^2)}\)，通常都透過電腦去計算</li>
<li>其中 \(e_t = y_t - \hat{y}_t\)，實際資料減去估計資料，也就是殘差</li>
</ul>
</li>
<li>Durbin-Watson Test 公式判讀<ul>
<li>我們可以觀察此公式 \(d = \frac{\sum_{t=2}^n \ (e_t - e_{t-1} \ )^2 }{ \sum_{t=1}^n \  (e_t^2)}\)</li>
<li>我們假設，完全<strong>正</strong>相關時則 \( e_t - e_{t-1} = 0\)<br>如果是完全<strong>正</strong>相關，那每一個殘差值則必須完全相同，因此 \(d = 0\)</li>
<li>我們假設，完全<strong>負</strong>相關時則 \( e_t - e_{t-1} = -2 \ \text{or} \ 2 \)，這裡我們將每個 \(e_t\) 都假設只會有 1,-1 兩種結果。<br>如果是完全<strong>負</strong>相關，那每一個殘差值則必須完全不相同，因此 \(d = 4\)</li>
<li>因此我們可以知道<ul>
<li>當 \(d = 0\) 資料正相關</li>
<li>當 \(d = 4\) 資料負相關</li>
<li>因此我們可透過前面兩點推出，當 \(d = 2\) 資料無相關</li>
</ul>
</li>
</ul>
</li>
<li>Durbin-Watson Test Statistic 檢定結果<ul>
<li>當資料筆數大於 15 時，才能進行解釋，當資料筆數大於 50 時，才有解釋的準確度</li>
<li>通常我們做 \(\alpha\) 後，Durbin-Watson Test Statistic 會給予 \(d_L\)、\(d_U\)，分別是檢定的上下界線。<ul>
<li>如果我們計算出來的 Durbin-Watson Test Statistic 洛在此上下界線則無法進行判讀。</li>
<li>這是因為這個地方過於模糊，無法肯定是有關係還是沒關係；類似於 Type 2 Error</li>
</ul>
</li>
<li>假設檢定<ul>
<li>正相關判讀<ul>
<li>\(H_0: \rho = 0 \) 資料不相關</li>
<li>\(H_1: \rho &gt; 0 \) 資料正相關</li>
<li>用數線表示；英文補充說明 Inconclusive: 無法下結論、No evidence of positive autocorrelation: 資料不相關<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1fCK1_45Llx-ffs8rNO2KRtXs1D-mQL0r&export=download" alt=""></p>
</blockquote>
</li>
</ul>
</li>
<li>負相關判讀<ul>
<li>\(H_0: \rho = 0 \) 資料不相關</li>
<li>\(H_1: \rho &lt; 0 \) 資料負相關</li>
<li>由於剛剛的公式判讀，因此我們得知完全負相關時必須接近於 4，因此我們會直接將 \(d_L\)、\(d_U\) 同乘 4，此區間則是無法判讀，而比 \(4-d_L\) 大的就是資料負相關</li>
<li>用數線表示；英文補充說明 Inconclusive: 無法下結論、No evidence of positive autocorrelation: 資料不相關<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=16CIDRjywGuuxZr-_KFZlubsaJ7pzFW5k&export=download" alt="">        </p>
</blockquote>
</li>
</ul>
</li>
<li><strong>資料相關判讀</strong><ul>
<li>\(H_0: \rho = 0 \) 資料不相關</li>
<li>\(H_1: \rho != 0 \) 資料 (正 or 負) 相關</li>
<li>由於剛剛的公式判讀，因此我們得知完全負相關時必須接近於 4，因此我們會直接將 \(d_L\)、\(d_U\) 同乘 4，此區間則是無法判讀，而比 \(4-d_L\) 大的就是資料負相關</li>
<li>用數線表示；英文補充說明 Inconclusive: 無法下結論、No evidence of positive autocorrelation: 資料不相關<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1JhB1z1srTW5kI7yurEUT-XQDjI3237_H&export=download" alt="">        </p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="舉例：這裡有一份透過-minitab-產生的資訊，請針對-Durbin-Watson-Test-進行解讀"><a href="#舉例：這裡有一份透過-minitab-產生的資訊，請針對-Durbin-Watson-Test-進行解讀" class="headerlink" title="舉例：這裡有一份透過 minitab 產生的資訊，請針對 Durbin-Watson Test 進行解讀"></a>舉例：這裡有一份透過 minitab 產生的資訊，請針對 Durbin-Watson Test 進行解讀</h3><blockquote>
<p>資料如下<br><img src="https://drive.google.com/u/2/uc?id=1YDAXzNpxdAfltKip28Mk7nHh4Iiu1g1s&export=download" alt=""><br><img src="https://drive.google.com/u/2/uc?id=1KrgqE6GgxjT8egQjgE3kcP488ntFjgb_&export=download" alt="">   </p>
</blockquote>
<ul>
<li>我們可以透過 ANOVA 表(Analysis of Variance) 得知這邊資料總數有 19 個</li>
<li>解釋能力高達 93.94%，非常不賴</li>
<li>我們可以從第二張圖看到，minital 的 Durbin-Watson Test 為 0.7981</li>
<li>我們進行查表，由於表中的 n = 20，我們的資料總數有 19，19 與 20 非常相近，因此我們直接看 n=20 的 Durbin-Watson Test<ul>
<li><blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1sBiJOUxI_Laqj22pOBkU1uKn5j3Jgstl&export=download" alt="">   </p>
</blockquote>
</li>
</ul>
</li>
<li>結論與分析<ul>
<li>再 0.5 的顯著性測試中，\(d_L = 1.20, d_U = 1.41\)，\(d &lt;= d_L\) 因此資料呈現於正相關。</li>
<li>由於經過 Durbin-Watson Test 可以得知這份資料有強烈的序列相關，因此我們應該要加入一個時間變數來降低 Durbin-Watson Test 使回測具有可用性、可靠性</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>北科上課筆記</category>
        <category>統計 statistics</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>統計學筆記</tag>
        <tag>北科大二下統計學筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>統計學(一) 筆記 - 第二章A</title>
    <url>/2020/09/28/statistics/statistics-ch2A/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊與財金管理系大二上統計學重點整理<br><font color="#dd0000">並非所有人都適用，部分對我而言稍加容易的內容並不會寫在此內。</font><br><strong>這是觀看影片心得後的筆記，老師上課可能不太適用會忘記抄到</strong></p>
</blockquote>
<a id="more"></a>

<h2 id="2A-介紹"><a href="#2A-介紹" class="headerlink" title="2A 介紹"></a>2A 介紹</h2><h3 id="類別型變數-Categorical-Data"><a href="#類別型變數-Categorical-Data" class="headerlink" title="類別型變數 Categorical Data"></a>類別型變數 Categorical Data</h3><p>類別型變數可以用符號、名稱來界定不同類別</p>
<h4 id="可呈現的表"><a href="#可呈現的表" class="headerlink" title="可呈現的表"></a>可呈現的表</h4><ul>
<li>次數分配</li>
<li>相對次數分配</li>
<li>百分比次數分配</li>
<li>長條圖</li>
<li>圓餅圖</li>
</ul>
<blockquote>
<p><img src="/images/statistics-ch2B/1.PNG" alt=""></p>
</blockquote>
<p>圖片當中</p>
<ul>
<li>\( \text{Relative Frequency} = \frac{\text{Frequency}}{\text{total Frequency}} \)</li>
<li><strong>Relative Frequency 總和一定會是1。</strong></li>
<li>\( \text{Percent Frequency} = \text{Relative Frequency} * 100 \)</li>
</ul>
<h4 id="Bar-Chart-長條圖"><a href="#Bar-Chart-長條圖" class="headerlink" title="Bar Chart 長條圖"></a>Bar Chart 長條圖</h4><p>他長這個樣子</p>
<blockquote>
<p><img src="/images/statistics-ch2A/1.PNG" alt=""></p>
</blockquote>
<ul>
<li>適合呈現 qualitative data(定值型資料)</li>
<li>通常 bar(長條) 都會是固定長度</li>
<li>每條 bar 必須要分開</li>
</ul>
<h4 id="Pareto-Chart-柏拉圖"><a href="#Pareto-Chart-柏拉圖" class="headerlink" title="Pareto Chart 柏拉圖"></a>Pareto Chart 柏拉圖</h4><p>一個長條圖配上百分比線，通常用在顯示產品品質管理。</p>
<h4 id="Pie-Chart-圓餅圖"><a href="#Pie-Chart-圓餅圖" class="headerlink" title="Pie Chart 圓餅圖"></a>Pie Chart 圓餅圖</h4><p>通常元素不可以太多，<strong>絕對</strong>不可以超過 10 個。</p>
<h3 id="數值型變數-Quantitative-Data"><a href="#數值型變數-Quantitative-Data" class="headerlink" title="數值型變數 Quantitative Data"></a>數值型變數 Quantitative Data</h3><h4 id="可呈現的表-1"><a href="#可呈現的表-1" class="headerlink" title="可呈現的表"></a>可呈現的表</h4><ul>
<li>次數分配</li>
<li>相對次數分配</li>
<li>百分比次數分配</li>
<li>點圖</li>
<li>直方圖</li>
<li>枝葉圖</li>
</ul>
<h4 id="Dot-Plot-點圖"><a href="#Dot-Plot-點圖" class="headerlink" title="Dot Plot 點圖"></a>Dot Plot 點圖</h4><p>一個點代表一筆資料，越多點代表越多資料。</p>
<blockquote>
<p><img src="/images/statistics-ch2A/2.PNG" alt=""></p>
</blockquote>
<h3 id="Frequency-Distribution-次數分配"><a href="#Frequency-Distribution-次數分配" class="headerlink" title="Frequency Distribution 次數分配"></a>Frequency Distribution 次數分配</h3><ul>
<li>決定類別、分類，分類不可以重疊還要包跨全部資料<ul>
<li>介於 5 到 20 組</li>
<li>每一組基本上都要有資料，並要看出分布，可能需要進行嘗試沒辦法一次到位。</li>
</ul>
</li>
<li>組距<ul>
<li>採用同樣寬度</li>
<li>寬度決定 = \( \frac{\text{最大值} - \text{最小值}}{組數}\)</li>
</ul>
</li>
<li>上下限<ul>
<li><strong>每一筆資料只能屬於某一組之間</strong></li>
<li>下限必須要涵蓋資料最小值，上限反之</li>
<li>通常最小或是最大可以是 *<em>open end *</em><br>open end 舉例：小於 x 值 or 大於 x 值</li>
</ul>
</li>
</ul>
<h3 id="資料頗析"><a href="#資料頗析" class="headerlink" title="資料頗析"></a>資料頗析</h3><p>我懶得打，直接看圖</p>
<blockquote>
<p><img src="/images/statistics-ch2A/3.PNG" alt=""></p>
</blockquote>
<h3 id="Histogram-直方圖"><a href="#Histogram-直方圖" class="headerlink" title="Histogram 直方圖"></a>Histogram 直方圖</h3><p>由於資料是數值並針對類別型資料，所以他們的 <strong>bar 必須黏在一起</strong></p>
<blockquote>
<p><img src="/images/statistics-ch2A/4.PNG" alt=""></p>
</blockquote>
<h4 id="Showing-Skewness-偏態"><a href="#Showing-Skewness-偏態" class="headerlink" title="Showing Skewness 偏態"></a>Showing Skewness 偏態</h4><p>通常只資料分布著重在某處。</p>
<ul>
<li>對稱 Symmetric<ul>
<li>資料對稱，舉例:身高分布</li>
</ul>
</li>
<li>左偏 Moderately Skewed Left<ul>
<li>資料左偏，舉例:分數</li>
</ul>
</li>
<li>右偏 Moderately Right Skewed <ul>
<li>資料右偏，舉例:房價</li>
</ul>
</li>
<li>Highly Skewed Right 右邊幾乎只有一點點<ul>
<li>資料極端左偏，舉例:管理階層薪水</li>
</ul>
</li>
</ul>
<h3 id="Stem-and-Leaf-Display"><a href="#Stem-and-Leaf-Display" class="headerlink" title="Stem-and-Leaf Display"></a>Stem-and-Leaf Display</h3><p>就長這樣</p>
<blockquote>
<p><img src="/images/statistics-ch2A/5.PNG" alt=""></p>
</blockquote>
<ul>
<li>會有排序與資料分布的型態</li>
<li>跟直方圖相似，但會呈現資料真正數值</li>
<li>葉子<ul>
<li>單位可調整</li>
<li>通常單位是 1，但可調整</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>北科上課筆記</category>
        <category>統計 statistics</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>統計學筆記</tag>
        <tag>北科大二上統計學筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>統計學(一) 筆記 - 第二章B</title>
    <url>/2020/09/20/statistics/statistics-ch2B/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊與財金管理系大二上統計學重點整理<br><font color="#dd0000">並非所有人都適用，部分對我而言稍加容易的內容並不會寫在此內。</font><br><strong>這是觀看影片心得後的筆記，老師上課可能不太適用會忘記抄到</strong></p>
</blockquote>
<a id="more"></a>


<h2 id="2B-介紹"><a href="#2B-介紹" class="headerlink" title="2B 介紹"></a>2B 介紹</h2><p>著重在兩個變數關係。</p>
<h3 id="Crosstabulation-交叉表"><a href="#Crosstabulation-交叉表" class="headerlink" title="Crosstabulation 交叉表"></a>Crosstabulation 交叉表</h3><p>可以用交叉表來看兩個變數的關係。<br>不管是數值型資料或是類別型資料都可以用交叉表來表示。</p>
<h3 id="名詞解釋"><a href="#名詞解釋" class="headerlink" title="名詞解釋"></a>名詞解釋</h3><p>aggregated crosstabulation 已彙整的表<br>simpsons’s Paradox 辛普森悖論<br>aggregated 收集<br>Scatter Diagram and Trendline 散佈圖</p>
<h3 id="simpsons’s-Paradox-辛普森悖論"><a href="#simpsons’s-Paradox-辛普森悖論" class="headerlink" title="simpsons’s Paradox 辛普森悖論"></a>simpsons’s Paradox 辛普森悖論</h3><p>在分組比較中都佔優勢的一方，在總評(全部一起考量)有時會是劣勢的一方。<br>為了避免此勃論則需要斟酌各分組權重，並乘以一定係數消除分組數據差造成的影響</p>
<h3 id="Scatter-Diagram-and-Trendline-散佈圖"><a href="#Scatter-Diagram-and-Trendline-散佈圖" class="headerlink" title="Scatter Diagram and Trendline 散佈圖"></a>Scatter Diagram and Trendline 散佈圖</h3><blockquote>
<p><strong>散佈圖的 x,y 都必須是數值變數</strong><br>假如 x 變動很大但趨勢線卻沒有變動表示 x 與 y 沒有甚麼關係。如下圖：<br><img src="/images/statistics-ch2B/2.PNG" alt=""></p>
</blockquote>
<h3 id="Side-by-Side-Bar-Chart-長條圖"><a href="#Side-by-Side-Bar-Chart-長條圖" class="headerlink" title="Side-by-Side Bar Chart 長條圖"></a>Side-by-Side Bar Chart 長條圖</h3><p>可同時比較很多 Elements </p>
<h4 id="Stacked-Bar-Chart-堆疊長條圖"><a href="#Stacked-Bar-Chart-堆疊長條圖" class="headerlink" title="Stacked Bar Chart 堆疊長條圖"></a>Stacked Bar Chart 堆疊長條圖</h4><blockquote>
<p>將要比較的變數全部堆疊在一起，所以長度都會達到 100%，如下圖：<br>通常是要查看同個 elements 的 variables 誰比較高</p>
</blockquote>
<p><img src="/images/statistics-ch2B/3.PNG" alt=""></p>
<h3 id="Data-Visualization-資料視覺化"><a href="#Data-Visualization-資料視覺化" class="headerlink" title="Data Visualization 資料視覺化"></a>Data Visualization 資料視覺化</h3><ul>
<li>明確標題</li>
<li>簡潔表單</li>
<li>清楚標示 x,y 軸</li>
<li>顏色要明確，不可過度模糊。假如是黑白報表的話，建議使用符號來表示</li>
</ul>
<h3 id="建議圖表"><a href="#建議圖表" class="headerlink" title="建議圖表"></a>建議圖表</h3><h4 id="QEUSTION-想要兩個變數之間比較"><a href="#QEUSTION-想要兩個變數之間比較" class="headerlink" title="QEUSTION: 想要兩個變數之間比較"></a>QEUSTION: 想要兩個變數之間比較</h4><p>Side-by-Side Bar Chart or Stacked Bar Chart </p>
<h4 id="QEUSTION-想要看兩個變數之間的關係"><a href="#QEUSTION-想要看兩個變數之間的關係" class="headerlink" title="QEUSTION: 想要看兩個變數之間的關係"></a>QEUSTION: 想要看兩個變數之間的關係</h4><h5 id="solution-A-Scatter-Diagram-散佈圖"><a href="#solution-A-Scatter-Diagram-散佈圖" class="headerlink" title="solution A: Scatter Diagram 散佈圖"></a>solution A: Scatter Diagram 散佈圖</h5><p>但請記住，變數只能是數值變數</p>
<h5 id="solution-B-Trendline-趨勢線"><a href="#solution-B-Trendline-趨勢線" class="headerlink" title="solution B: Trendline 趨勢線"></a>solution B: Trendline 趨勢線</h5><p>來看在散佈圖上面的關聯行如何</p>
<h3 id="Data-Dashboards-資料儀表板"><a href="#Data-Dashboards-資料儀表板" class="headerlink" title="Data Dashboards 資料儀表板"></a>Data Dashboards 資料儀表板</h3><p>通常查看 KPI(關鍵績效指標)，能讓使用者方便閱讀了解。</p>
<h4 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h4><ul>
<li>盡量讓圖不要下拉或上移，可以完整呈現</li>
<li>減少不必要的視覺效果</li>
<li>圖要有明顯邊界<br>如下圖：<br><img src="/images/statistics-ch2B/4.PNG" alt=""></li>
</ul>
]]></content>
      <categories>
        <category>北科上課筆記</category>
        <category>統計 statistics</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>統計學筆記</tag>
        <tag>北科大二上統計學筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>統計學(二) 筆記 - 第十三章 實驗設計與變異數分析(Experimental Design and Analysis of Variance)</title>
    <url>/2021/04/19/statistics/statistics-ch13/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊與財金管理系大二下統計學重點整理<br><font color="#dd0000">並非所有人都適用，部分對我而言稍加容易的內容並不會寫在此內。</font><br><strong>這是觀看影片心得後的筆記，老師上課可能不太適用會忘記抄到</strong></p>
</blockquote>
<a id="more"></a>

<h1 id="介紹實驗設計與變異數分析-An-Introduction-to-Experimental-Design-and-Analysis-of-Variance"><a href="#介紹實驗設計與變異數分析-An-Introduction-to-Experimental-Design-and-Analysis-of-Variance" class="headerlink" title="介紹實驗設計與變異數分析 An Introduction to Experimental Design and Analysis of Variance"></a>介紹實驗設計與變異數分析 An Introduction to Experimental Design and Analysis of Variance</h1><p>主要還是對平均數做檢定，只是透過變異數去進行。</p>
<h2 id="統計學研究主要分成實驗型或觀察型"><a href="#統計學研究主要分成實驗型或觀察型" class="headerlink" title="統計學研究主要分成實驗型或觀察型"></a>統計學研究主要分成實驗型或觀察型</h2><ul>
<li>實驗型 Experimental study<br>將控制一個或多個因素，然後觀察因素如何去影響變異數。EX:一群人吃早餐、另一群不吃早餐</li>
<li>觀察型 Observational study<br>不去對因素進行控制。EX:我們沒辦法叫一群人都吸毒、另一組都不吸毒</li>
<li>因果關係 Cause-and-effect relationships<br>實驗型比觀察型更能夠找出因果關係(關聯)。EX: A 跟 B 有正相關</li>
<li>ANOVA (Analysis of variance)<br>此算法可用來分析資料，無論是實驗型或是觀察型</li>
</ul>
<h2 id="主要介紹這三種實驗設計"><a href="#主要介紹這三種實驗設計" class="headerlink" title="主要介紹這三種實驗設計"></a>主要介紹這三種實驗設計</h2><ul>
<li>完全隨機設計 a Completely Randomized Design</li>
<li>隨機集區設計 a Randomized Block Design </li>
<li>因子實驗 a Factorial Experiment</li>
</ul>
<h2 id="名詞介紹"><a href="#名詞介紹" class="headerlink" title="名詞介紹"></a>名詞介紹</h2><ul>
<li>因子 factor<br>EX:綠茶類型就是 factor</li>
<li>treatment<br>factor 中的選項</li>
<li>實驗單位 Experimental units<br>對每位接受實驗的 object 就是實驗</li>
<li>完全隨機分配 completely randomized design<br>將 teatment 隨機平均分配給每個 Experimental units</li>
</ul>
<p>舉例：<br>綠茶是 factor，其中有 50 嵐綠茶、清心綠茶、comebuy 綠茶，這些則叫做 treatment。<br>其中有 30 位成年人要喝裡面的綠茶，來表示他們是否喜歡，而這 30 位成年人則是 Experimental units<br>再來我們將 50 嵐綠茶、清心綠茶、comebuy 綠茶 隨機分給尚未分配到飲料的實驗單位，這樣就是 completely randomized design</p>
<h2 id="ANOVA-Analysis-of-variance"><a href="#ANOVA-Analysis-of-variance" class="headerlink" title="ANOVA (Analysis of variance)"></a>ANOVA (Analysis of variance)</h2><ul>
<li>測試三個或以上的母體平均數，請不要被名子給誤導</li>
<li>資料獲得可以從觀察型或是實驗型</li>
<li>我們可以對樣本結果進行假設測試<ul>
<li>\(H_0: \mu_1 = \mu_2 = … = \mu_k \)</li>
<li>\(H_1: \text{Not all population means are equal}\)，只要其中一個不一樣即可。</li>
<li>如果拒絕 \(H_0\)，我們沒辦法得出所有的母體平均數都相同</li>
<li>拒絕 \(H_0\) 表示我們至少有兩組或以上的母體平均數不同</li>
</ul>
</li>
<li>每個母體的觀察值(變數)都必須是常態分配</li>
<li>我們是檢測每個母體的<strong>變異數</strong>來得知 \(H_0\) 是否為 true</li>
<li>每個觀察值都是互相獨立</li>
</ul>
<h3 id="用圖表進行解釋"><a href="#用圖表進行解釋" class="headerlink" title="用圖表進行解釋"></a>用圖表進行解釋</h3><ul>
<li>當樣本母體平均數都非常靠近時，\(H_0\)為真，\(\sigma_{\bar{x}}^2 = \frac{\sigma^2}{x}\)，這裡的 x 為樣本平均數，\(\mu\) 為母體平均數<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1s3QSgXSAN07Ob1gjaO24VXy62NhDB4kA&export=download" alt=""></p>
</blockquote>
</li>
<li>當樣本母體平均數距離相差過大時，則拒絕\(H_0\)，\(\sigma_{\bar{x}}^2 != \frac{\sigma^2}{x}\)，這裡的 x 為樣本平均數，\(\mu\) 為母體平均數<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1YIxqdOqGAAMvmfhpPHroe5aPlTsI3NrR&export=download" alt=""></p>
</blockquote>
</li>
<li>因此 ANOVA 可以比較母體之間 treatments 變異數，也可以比較母體內 treatments 變異數，下方進行解釋</li>
</ul>
<h1 id="分析變異數與完全隨機變數-Analysis-of-Variance-and-the-Completely-Randomized-Design"><a href="#分析變異數與完全隨機變數-Analysis-of-Variance-and-the-Completely-Randomized-Design" class="headerlink" title="分析變異數與完全隨機變數 Analysis of Variance and the Completely Randomized Design"></a>分析變異數與完全隨機變數 Analysis of Variance and the Completely Randomized Design</h1><ul>
<li><a href="#比較母體之間-treatments-變異數-Between-Treatments-Estimate-of-Population-Variance">比較母體之間 treatments 變異數 Between-Treatments Estimate of Population Variance</a></li>
<li><a href="#比較母體內-treatments-變異數-Within-Treatments-Estimate-of-Population-Variance">比較母體內 treatments 變異數 Within-Treatments Estimate of Population Variance</a> </li>
<li><a href="#比較變異數的估計：F-檢定-Comparing-the-Variance-Estimates-The-F-test">比較變異數的估計：F 檢定 Comparing the Variance Estimates: The \(F\) test</a></li>
<li><a href="#ANOVA-Table">ANOVA Table</a></li>
<li><a href="#測試-k-個母體平均值是否相同-Test-for-the-Equality-of-k-Population-Means">測試 k 個母體平均值是否相同 Test for the Equality of k Population Means</a></li>
</ul>
<h2 id="比較母體之間-treatments-變異數-Between-Treatments-Estimate-of-Population-Variance"><a href="#比較母體之間-treatments-變異數-Between-Treatments-Estimate-of-Population-Variance" class="headerlink" title="比較母體之間 treatments 變異數 Between-Treatments Estimate of Population Variance"></a>比較母體之間 treatments 變異數 Between-Treatments Estimate of Population Variance</h2><ul>
<li>我們要估計 \(\sigma^2\)，如果 \(H_0\)為真，則變異數差異不大，反之就會大。</li>
<li>公式 \(MSTR = \frac{\sum_{j=1}^k n_j (\bar{x_j}-\bar{\bar{x}})^2}{k-1}\)<ul>
<li>其中 x 表示平均數，\(\bar{\bar{x}}\) 為總平均數，\(\bar{x_j}\) 是 factor 中的每一個 treatment，n 為母體數量</li>
<li>\(k-1\) 是自由度，k 是母體數量</li>
<li>\( (\bar{x_j}-\bar{\bar{x}})^2 \) 是 SSTR，sum of square due to treatments，中文意思為處理間平方和</li>
</ul>
</li>
<li>MSTR = mean square due to treatments，中文意思為處理間均方</li>
</ul>
<h2 id="比較母體內-treatments-變異數-Within-Treatments-Estimate-of-Population-Variance"><a href="#比較母體內-treatments-變異數-Within-Treatments-Estimate-of-Population-Variance" class="headerlink" title="比較母體內 treatments 變異數 Within-Treatments Estimate of Population Variance"></a>比較母體內 treatments 變異數 Within-Treatments Estimate of Population Variance</h2><ul>
<li>我們要估計 \(\sigma^2\)，如果 \(H_0\)為真，則變異數差異不大，反之就會大。</li>
<li>公式 \(MSE = \frac{\sum_{j=1}^k (n_j-1)s^2_j}{\bar{n_T}-k}\)<ul>
<li>k 為母體數量、\(\bar{n_T}\)樣本個數、\((n_j-1)\) 第 j 組的數量、\(s^2_j\) 第 j 組的標準差</li>
<li>\(\sum_{j=1}^k (n_j-1)s^2_j\) 是 SSE，sum of squares due to error，誤差平方和</li>
<li>\(\bar{n_T}-k\) 是自由度，k 是母體數量</li>
</ul>
</li>
<li>MSE = mean square error 中文為均方誤差</li>
</ul>
<h2 id="比較變異數的估計：F-檢定-Comparing-the-Variance-Estimates-The-F-test"><a href="#比較變異數的估計：F-檢定-Comparing-the-Variance-Estimates-The-F-test" class="headerlink" title="比較變異數的估計：F 檢定 Comparing the Variance Estimates: The \(F\) test"></a>比較變異數的估計：F 檢定 Comparing the Variance Estimates: The \(F\) test</h2><p>如果 \(H_0\) 成立，ANOVA 假設是有效，樣本描述是使用 \(MSTR / MSE\)，則 F 檢定的自由度在 MSTR 時\(k-1\) 是自由度，MSE \(\bar{n_T}-k\) 是自由度</p>
<p>如果 k 母體的平均數不相等，則 \(MSTR / MSE\) 的值將會膨脹，因為 MSTR 有 \(\sigma^2\)</p>
<p>因此我們可以得出，如果我們使用 F test，如果 F test 過大時，則拒絕 \(H_0\)，表示 \(MSTR / MSE\) 將出現過大的數值</p>
<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1-YnKscFFPaP8NBpobEE8tJMfFSsu0HWd&export=download" alt=""></p>
</blockquote>
<ul>
<li>\(H_0\) 所有母體平均數相同</li>
<li>\(H_1\) 有兩個或以上的母體平均數不同</li>
</ul>
<h3 id="用表格來說明"><a href="#用表格來說明" class="headerlink" title="用表格來說明"></a>用表格來說明</h3><blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1C8P4YsQTUGq8bgDGksqL7vZotZl1vtjQ&export=download" alt=""> </p>
</blockquote>
<h2 id="ANOVA-Table"><a href="#ANOVA-Table" class="headerlink" title="ANOVA Table"></a>ANOVA Table</h2><p>SST 為 data set 中全部的 treatmeat ，並表示自由度為 \(n_T -1\) 後的總樣本變異量<br>假如將整個資料做為一個樣本，則計算全部的總和平方(total sum of squares, SST)<br>公式為 \(SST = \sum_{j=1}^k \sum_{i=1}^{n_j} (\bar{x_ij}-\bar{\bar{x}})^2 = SSTR+SSE\)，其中 \(\bar{\bar{x}}\) 為樣本總平均數</p>
<p>ANOVA 整個過程中可以視為將整個平方和與自由度分給 treatments and error。</p>
<p>將整個平方和並使用適合的自由度、提供變異數估計與 F 值，來進行假設檢定判斷是否所有母體平均都等於。</p>
<h2 id="測試-k-個母體平均值是否相同-Test-for-the-Equality-of-k-Population-Means"><a href="#測試-k-個母體平均值是否相同-Test-for-the-Equality-of-k-Population-Means" class="headerlink" title="測試 k 個母體平均值是否相同 Test for the Equality of k Population Means"></a>測試 k 個母體平均值是否相同 Test for the Equality of k Population Means</h2><ul>
<li>Hypotheses <ul>
<li>\(H_0: \mu_1 = \mu_2 = … = \mu_k \)</li>
<li>\(H_1: \text{Not all population means are equal}\)，只要其中一個不一樣即可。</li>
</ul>
</li>
<li>Test Statistic<br>\(F = MSTR / MSE \)</li>
<li>Rejection Rule<ul>
<li>p-value Approach: Reject \(H_0\) if \(p-value \leq \alpha\)</li>
<li>Critical Value Approach: Reject \(H_0\) if \(F \geq F_a\)</li>
<li>\(F_a\) numerator(分子) 自由度為 \(k-1\)、denominator(分母) 自由度為 \(n_T - k\)，\(n_T\) 是全部的樣本總數量，k 為母體數量</li>
</ul>
</li>
</ul>
<h3 id="舉例：專門幫車子打蠟公司，將考慮三種打蠟材質，他們想知道這三種打蠟材質的持久性，15-輛車平均分配給-3-種打蠟材質，之後進行一次洗車，如果蠟還沒有脫落就再次洗車，直到沒有蠟為止，我們想知道這三種打蠟材質是否洗車次數都一樣"><a href="#舉例：專門幫車子打蠟公司，將考慮三種打蠟材質，他們想知道這三種打蠟材質的持久性，15-輛車平均分配給-3-種打蠟材質，之後進行一次洗車，如果蠟還沒有脫落就再次洗車，直到沒有蠟為止，我們想知道這三種打蠟材質是否洗車次數都一樣" class="headerlink" title="舉例：專門幫車子打蠟公司，將考慮三種打蠟材質，他們想知道這三種打蠟材質的持久性，15 輛車平均分配給 3 種打蠟材質，之後進行一次洗車，如果蠟還沒有脫落就再次洗車，直到沒有蠟為止，我們想知道這三種打蠟材質是否洗車次數都一樣?"></a>舉例：專門幫車子打蠟公司，將考慮三種打蠟材質，他們想知道這三種打蠟材質的持久性，15 輛車平均分配給 3 種打蠟材質，之後進行一次洗車，如果蠟還沒有脫落就再次洗車，直到沒有蠟為止，我們想知道這三種打蠟材質是否洗車次數都一樣?</h3><h4 id="名詞定義"><a href="#名詞定義" class="headerlink" title="名詞定義"></a>名詞定義</h4><ul>
<li>Factor: 車蠟</li>
<li>Treatments: Type1, Type2, Type3</li>
<li>Experimental units: Cars</li>
<li>Reesponse variable: 經過幾次的洗車</li>
</ul>
<h4 id="資料"><a href="#資料" class="headerlink" title="資料"></a>資料</h4><blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1R39if8Wa6WWMbzguAc2aAK-ee3oKYMbm&export=download" alt=""> </p>
</blockquote>
<h4 id="進行判斷"><a href="#進行判斷" class="headerlink" title="進行判斷"></a>進行判斷</h4><ul>
<li>Hypotheses<ul>
<li>\(H_0: \mu_1 = \mu_2 = \mu_3 \)</li>
<li>\(H_1: \text{Not all population means are equal}\)，只要其中一個不一樣即可。</li>
<li>\(\mu_1\) 第 1 種材質的蠟</li>
<li>\(\mu_2\) 第 2 種材質的蠟</li>
<li>\(\mu_3\) 第 3 種材質的蠟</li>
</ul>
</li>
<li>Mean Square Between Treatments<ul>
<li>\(\bar{\bar{x}} = (\bar{x_1} + \bar{x_2} + \bar{x_3}) / 3 = (29+30.4+30)/3 = 29.8\)</li>
<li>\(SSTR = 5(29-29.8)^2 + 5(30.4-29.8)^2 + 5(30-29.8)^2 = 5.2\)</li>
<li>\(MSTR = 5.2/(3-1) = 2.6\)</li>
</ul>
</li>
<li>Mean Square Error <ul>
<li>\(SSE = 4(2.5) + 4(3.3) + 4(2.5) = 33.2\)</li>
<li>\(MSE = 33.2 / (15-3) = 2.77\)</li>
</ul>
</li>
<li>Rejection Rule<ul>
<li>p-value approach: Reject \(H_0\) if \(p-value \leq 0.05 \)</li>
<li>Critical value approach: Reject \(H_0\) if \(F \geq 3.89\)</li>
<li>其中 numerator 自由度是 2、denominator 自由度是 12</li>
<li>其中是透過 probability distribution app 計算得出<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1xCSIP4-Auz3QUjBMMzhnYV7D-0LPeE1B&export=download" alt=""> </p>
</blockquote>
</li>
</ul>
</li>
<li>Test Statistic<br>\(F = MSTR / MSE = 2.60 / 2.77 = 0.939\)</li>
<li>ANOVA Table <blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1cXFjSgx2UaGUe__CNNlyKlglBIsTR5jl&export=download" alt=""> </p>
</blockquote>
</li>
<li>Conclusion <ul>
<li>其中是透過 probability distribution app 計算得出<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1J3760RoSKgkTbrJUI-7paoI31OcSKg_f&export=download" alt=""> </p>
</blockquote>
</li>
<li>p-value approach: Reject \(H_0\) if \(p-value = 0.42 \leq 0.05 \)，並不符合</li>
<li>Critical value approach: Reject \(H_0\) if \(F=0.939 \geq 3.89\)，並不符合</li>
<li>因此不可以拒絕 \(H_0\)</li>
<li>因此我們不能得出這三種不同的蠟材質是否洗車次數並不一樣</li>
</ul>
</li>
</ul>
<h3 id="舉例：老闆想要知道不同工廠經理工作時數是否不一樣，總共有三個工廠-B、P、D-、每個工廠-5-個經理，顯著性水準為-0-05"><a href="#舉例：老闆想要知道不同工廠經理工作時數是否不一樣，總共有三個工廠-B、P、D-、每個工廠-5-個經理，顯著性水準為-0-05" class="headerlink" title="舉例：老闆想要知道不同工廠經理工作時數是否不一樣，總共有三個工廠(B、P、D)、每個工廠 5 個經理，顯著性水準為 0.05"></a>舉例：老闆想要知道不同工廠經理工作時數是否不一樣，總共有三個工廠(B、P、D)、每個工廠 5 個經理，顯著性水準為 0.05</h3><h4 id="名詞定義-1"><a href="#名詞定義-1" class="headerlink" title="名詞定義"></a>名詞定義</h4><ul>
<li>Factor: 公司</li>
<li>Treatments: 三個工廠(B、P、D)</li>
<li>Experimental units: 工廠經理</li>
<li>Reesponse variable: 工作時數</li>
</ul>
<h4 id="資料-1"><a href="#資料-1" class="headerlink" title="資料"></a>資料</h4><blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1_H2WuP_zWNzbApdGEllZoH_Fa2RgJ9T6&export=download" alt=""> </p>
</blockquote>
<h4 id="進行判斷-1"><a href="#進行判斷-1" class="headerlink" title="進行判斷"></a>進行判斷</h4><ul>
<li>Hypotheses<ul>
<li>\(H_0: \mu_1 = \mu_2 = \mu_3 \)</li>
<li>\(H_1: \text{Not all population means are equal}\)，只要其中一個不一樣即可。</li>
<li>\(\mu_1\) B 工廠</li>
<li>\(\mu_2\) P 工廠</li>
<li>\(\mu_3\) D 工廠</li>
</ul>
</li>
<li>顯著性水準 0.05</li>
<li>Mean Square Between Treatments<ul>
<li>\(\bar{\bar{x}} = (\bar{x_1} + \bar{x_2} + \bar{x_3}) / 3 = (55+68+57)/3 = 60\)</li>
<li>\(SSTR = 5(55-60)^2 + 5(68-60)^2 + 5(57-60)^2 = 490\)</li>
<li>\(MSTR = 490/(3-1) = 245\)</li>
</ul>
</li>
<li>Mean Square Error <ul>
<li>\(SSE = 4(26.0) + 4(26.5) + 4(24.5) = 308\)</li>
<li>\(MSE = 308 / (15-3) = 25.667\)</li>
</ul>
</li>
<li>Rejection Rule<ul>
<li>p-value approach: Reject \(H_0\) if \(p-value \leq 0.05 \)</li>
<li>Critical value approach: Reject \(H_0\) if \(F \geq 3.89\)</li>
<li>其中 numerator 自由度是 2、denominator 自由度是 12</li>
<li>其中是透過 probability distribution app 計算得出<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1xCSIP4-Auz3QUjBMMzhnYV7D-0LPeE1B&export=download" alt=""> </p>
</blockquote>
</li>
</ul>
</li>
<li>Test Statistic<br>\(F = MSTR / MSE = 245 / 25.667 = 9.55\)</li>
<li>ANOVA Table <blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1-yvcbHdpxqHIe7GsAIi148-m85QDZCDS&export=download" alt=""> </p>
</blockquote>
</li>
<li>Conclusion <ul>
<li>其中是透過 probability distribution app 計算得出<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1xF-683si1j4i4vNRcJ-NFiZ5xAX-h05M&export=download" alt=""> </p>
</blockquote>
</li>
<li>p-value approach: Reject \(H_0\) if \(p-value = 0.0033 \leq 0.05 \)，符合</li>
<li>Critical value approach: Reject \(H_0\) if \(F=9.55 \geq 3.89\)，符合</li>
<li>因此可以拒絕 \(H_0\)</li>
<li>因此我們知道三個工廠的工廠經理工作時數並不相同</li>
</ul>
</li>
</ul>
<h1 id="多重比較-Multiple-Comparison-Procedures"><a href="#多重比較-Multiple-Comparison-Procedures" class="headerlink" title="多重比較 Multiple Comparison Procedures"></a>多重比較 Multiple Comparison Procedures</h1><p>當我們前面拒絕 \(H_0\) 時，我們則需要再找出是那些母體平均數不同時，則可以使用 Fishers’s least significant difference(LSD, 最低顯著差異) 來確認哪些母體平均數不同</p>
<h2 id="最低顯著差異-Fishers’s-least-significant-difference-LSD"><a href="#最低顯著差異-Fishers’s-least-significant-difference-LSD" class="headerlink" title="最低顯著差異 Fishers’s least significant difference(LSD)"></a>最低顯著差異 Fishers’s least significant difference(LSD)</h2><ul>
<li>Hypotheses<ul>
<li>\(H_0: \mu_i = \mu_j \)</li>
<li>\(H_1: \mu_i != \mu_j\)</li>
<li>如果有 3 個變數，理論上就應該要做 3 次 LSD；如果有 4 個那就需要做 10 次。<br>EX: 有 a,b,c 三變數，則 LSD 要做的有 ab, ac, bc。</li>
</ul>
</li>
<li>Test Statistic \(t = \frac{\bar{x_i} - \bar{x_j}}{\sqrt{MSE (1/n_i + 1/n_j)}}\)<ul>
<li>其中 MSE 是誤差均方</li>
</ul>
</li>
<li>Rejection Rule<ul>
<li>p-value approach: Reject \(H_0\) if \(p-value \leq \alpha\)</li>
<li>Critical Value approach: Reject \(H_0\) if \(t \leq -t_{a/2} \) or \(t \geq t_{a/2}\)</li>
<li>其中 \(t_{a/2}\) 的自由度為 \(n_T - k\)，\(n_T\)  是全部的樣本總數量，k 為母體數量</li>
</ul>
</li>
</ul>
<h3 id="進行移項優化的，更方便計算的最低顯著差異-Fishers’s-least-significant-difference-LSD"><a href="#進行移項優化的，更方便計算的最低顯著差異-Fishers’s-least-significant-difference-LSD" class="headerlink" title="進行移項優化的，更方便計算的最低顯著差異 Fishers’s least significant difference(LSD)"></a>進行移項優化的，更方便計算的最低顯著差異 Fishers’s least significant difference(LSD)</h3><ul>
<li>Hypotheses<ul>
<li>\(H_0: \mu_i = \mu_j \)</li>
<li>\(H_1: \mu_i != \mu_j\)</li>
<li>如果有 3 個變數，理論上就應該要做 3 次 LSD；如果有 4 個那就需要做 10 次。<br>EX: 有 a,b,c 三變數，則 LSD 要做的有 ab, ac, bc。</li>
</ul>
</li>
<li>Test Statistic \(t = \bar{x_i} - \bar{x_j}\)<ul>
<li>其中 MSE 是誤差均方</li>
</ul>
</li>
<li>Rejection Rule<ul>
<li>Critical Value approach: Reject \(H_0\) if \( |\bar{x_i} - \bar{x_j} | \geq LSD \)</li>
<li>其中 LSD 是將 t 統計的分母移項至 \(t_{a/2}\) 那邊，因此 \(LSD = t_{a/2} \sqrt{MSE (1/n_i + 1/n_j)}  \)</li>
<li>其中 \(t_{a/2}\) 的自由度為 \(n_T - k\)，\(n_T\)  是全部的樣本總數量，k 為母體數量</li>
</ul>
</li>
</ul>
<h3 id="舉例：前面我們知道-工廠裡的經理工作時數不一致，因此我們要進行分析-LSD-來找出是哪個工廠的平均工作時數與其他工廠不同"><a href="#舉例：前面我們知道-工廠裡的經理工作時數不一致，因此我們要進行分析-LSD-來找出是哪個工廠的平均工作時數與其他工廠不同" class="headerlink" title="舉例：前面我們知道 工廠裡的經理工作時數不一致，因此我們要進行分析 LSD 來找出是哪個工廠的平均工作時數與其他工廠不同"></a>舉例：<a href="#舉例：老闆想要知道不同工廠經理工作時數是否不一樣，總共有三個工廠-B、P、D-、每個工廠-5-個經理，顯著性水準為-0-05">前面我們知道</a> 工廠裡的經理工作時數不一致，因此我們要進行分析 LSD 來找出是哪個工廠的平均工作時數與其他工廠不同</h3><ul>
<li>compute <ul>
<li>\(\alpha = 0.05\)</li>
<li>自由度為 \(n_T - k = 15 - 3 = 12\)、\(t_{0.025} =2.179\)<br>\(n_T - k\)，\(n_T\)  是全部的樣本總數量，k 為母體數量</li>
<li>\(LSD = t_{a/2} \sqrt{MSE(1/n_i + 1/n_j)}\)</li>
<li>\(LSD = 2.179 \sqrt{25.667(1/5 + 1/5 )} = 6.98\)</li>
<li>其中 25.667 是前面有進行計算，可以點舉例的 link 回去</li>
</ul>
</li>
<li>LSD 對工廠 B 和工廠 P，求方便定義，下面數學公式工廠 B 為 1、工廠 P 為 2、工廠 D 為 3<ul>
<li>Hypotheses<ul>
<li>\(H_0 : \mu_1 = \mu_2 \)</li>
<li>\(H_1: \mu_1 != \mu_2\)</li>
</ul>
</li>
<li>Rejection Rule<br>Reject \(H_0\) if \(|\bar{x_1} - \bar{x_2}| \geq 6.98\)</li>
<li>Test Statistic<br>\(|\bar{x_1} - \bar{x_2}| = |55-68| = 13\)</li>
<li>Conclusion<br>我們可以知道工廠 B 和工廠 P 的平均工作時數並不同。</li>
</ul>
</li>
<li>LSD 對工廠 B 和工廠 D，求方便定義，下面數學公式工廠 B 為 1、工廠 P 為 2、工廠 D 為 3<ul>
<li>Hypotheses<ul>
<li>\(H_0 : \mu_1 = \mu_3 \)</li>
<li>\(H_1: \mu_1 != \mu_3\)</li>
</ul>
</li>
<li>Rejection Rule<br>Reject \(H_0\) if \(|\bar{x_1} - \bar{x_3}| \geq 6.98\)</li>
<li>Test Statistic<br>\(|\bar{x_1} - \bar{x_3} |= |55-57| = 2\)</li>
<li>Conclusion<br>我們可以知道工廠 B 和工廠 D 的平均工作時數相同，無法拒絕 \(H_0\)。</li>
</ul>
</li>
<li>LSD 對工廠 P 和工廠 D，求方便定義，下面數學公式工廠 B 為 1、工廠 P 為 2、工廠 D 為 3<ul>
<li>Hypotheses<ul>
<li>\(H_0 : \mu_2 = \mu_3 \)</li>
<li>\(H_1: \mu_2 != \mu_3\)</li>
</ul>
</li>
<li>Rejection Rule<br>Reject \(H_0\) if \(|\bar{x_2} - \bar{x_3}| \geq 6.98\)</li>
<li>Test Statistic<br>\(|\bar{x_2} - \bar{x_3}| = |68-57| = 11\)</li>
<li>Conclusion<br>我們可以知道工廠 P 和工廠 D 的平均工作時數並不同。</li>
</ul>
</li>
<li>過去資料<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1utNGDHbDxRFU9HLu4EBrc5ttsNV1xnE8&export=download" alt=""></p>
</blockquote>
</li>
<li>Conclusion<br>我們可以知道工廠 P 的工作時數與其他並不同，且工時來的更長更高；其他兩家則沒有明顯差異。</li>
</ul>
<h2 id="型一誤差-Type1-I-Error-Rates"><a href="#型一誤差-Type1-I-Error-Rates" class="headerlink" title="型一誤差 Type1 I Error Rates"></a>型一誤差 Type1 I Error Rates</h2><ul>
<li>比較型一誤差率 comparison-wise Type 1 error rate<ul>
<li>假設此兩個變數母體相同，但我們卻拒絕 \(H_0\)，的誤判機率是 0.05。 </li>
</ul>
</li>
<li>實驗型一誤差率 experiment-wise Type 1 error rate<ul>
<li>由於我們上面 LSD 會做多次的假設檢定也就會產生多次的比較型一誤差率，我們要確保我們從未發生過 Type 1 error，因此我們可以透過數學公式進行驗證</li>
<li>\(a_{EW} = 1 - (1-a)^k\)，k 是進行得比較次數，a 則是顯著性水準</li>
</ul>
</li>
<li>如果 \(a_{EW} \) 太大時，我們可以在一開始就將在<a href="#介紹實驗設計與變異數分析-An-Introduction-to-Experimental-Design-and-Analysis-of-Variance">ANOVA</a>將顯著性水準設定更小，即可避免此問題；但要注意，在固定樣本情況時，如果將顯著性水準過低則有可能考慮造成 Type2 Error 錯誤機率提高。</li>
<li>可透過 Bonferroni adjstment 對顯著性水準進行調整，調整公式為 \(\alpha / k \)，這樣就可以將 \(a_{EW} \) 降低。</li>
</ul>
<h1 id="隨機區組設計-Randomized-Block-Design"><a href="#隨機區組設計-Randomized-Block-Design" class="headerlink" title="隨機區組設計 Randomized Block Design"></a>隨機區組設計 Randomized Block Design</h1><ul>
<li>如果使用 Excel 資料分析<strong>雙因子變數分析：無重複試驗</strong></li>
<li>實驗單位 Experimental units<br>對每位接受實驗的 object 就是實驗</li>
<li>完全隨機分配 completely randomized design<br>將 teatment 隨機平均分配給每個 Experimental units</li>
</ul>
<p>主要是為了避免在每個實驗單位有異質性的可能，而導致得出結果不一樣，而產生出的一種隨機選擇方法。<br>EX: 評測小孩子喜不喜歡喝牛奶，但可能裡面有些小孩本身對牛奶過敏(異質性)，就有機會導致我們的結果出錯。</p>
<p>因此後來為了防止異質性的問題，我們將同質性的資料組成 BLOCK，之後再使用 ANOVA 算法。(但 ANOVA 的公式因為 block，而改變，下方則有提到。)</p>
<h2 id="ANOVA-Procedure"><a href="#ANOVA-Procedure" class="headerlink" title="ANOVA Procedure"></a>ANOVA Procedure</h2><ul>
<li>我們將總和平方(SST, sum of squares total)分成部分，由選項平方和(sum of squares due to treatments)、由集區的平方和(sum of squares due to blocks)、誤差平方和(sum of squares due to error)。</li>
<li>因此公式為 \(SST = SSTR + SSBL + SSE\)<ul>
<li>其中 SSTR 自由度為 \(n_T - k\)，\(n_T\)  是全部的樣本總數量，k 為母體數量</li>
<li>SSBL 自由度為 \(k-1\)</li>
<li>SSE 為 \((k-1)(b-1)\)，b 則是 block。</li>
</ul>
</li>
<li>ANOVA table 如下。<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=13ZhZ_Glmwv1wYq3fCY2seQyuxgFAC6Kr&export=download" alt=""></p>
</blockquote>
</li>
<li>F 計算方式為 \(F = MSTR / MSE \)</li>
</ul>
<h3 id="舉例：石油公司研發出三種新的混合方式，他們想確認每加侖的油可以跑多少英里？會不會不同。這邊找了五台汽車進行測試。資料如下："><a href="#舉例：石油公司研發出三種新的混合方式，他們想確認每加侖的油可以跑多少英里？會不會不同。這邊找了五台汽車進行測試。資料如下：" class="headerlink" title="舉例：石油公司研發出三種新的混合方式，他們想確認每加侖的油可以跑多少英里？會不會不同。這邊找了五台汽車進行測試。資料如下："></a>舉例：石油公司研發出三種新的混合方式，他們想確認每加侖的油可以跑多少英里？會不會不同。這邊找了五台汽車進行測試。資料如下：</h3><blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1RiqR0flhsGw3LtxeBQ6wXwhDrM09DLnE&export=download" alt=""></p>
</blockquote>
<p>由於我們不能確定，每台車的耗油量(異質型)，因此我們就要記錄每一台車(block, 內容全部同執行)所使用的油量。</p>
<p>我們可以確定名詞了</p>
<ul>
<li>Factor 混和油 (Gasoline blend)</li>
<li>Treatments 選項 (blend X, blend Y, blend Z)</li>
<li>Blocks 車子 (automobiles)</li>
<li>Response variable 每加侖跑多少英里(Mile per gallon) </li>
</ul>
<p>計算 ANOVA table</p>
<ul>
<li>compute<ul>
<li>\(SST = (31-29)^2 + (30-29)^2 + … + (26-29)^2 = 62\)</li>
<li>Mean Square of Treatment 為 29，因此 SSTR 計算如下<ul>
<li>\(SSTR = 5[ (29.8-29)^2 + (28.8-29)^2 + (28.4-29)^2 ] = 5.2 \)，主要是因為我們 treatments 都有 5 筆資料，因此我們優化，將 5 提出來最後再做乘法。</li>
<li>\(MSTR = 5.2 /  (3-1) = 2.6 \)</li>
</ul>
</li>
<li>Mean Square Due to Blocks<ul>
<li>\(SSBL = 3[(30.333-29)^2 + … + (25.667-29)^2] = 51.33\)，主要是因為我們 treatments 都有 3 筆資料，因此我們優化，將 3 提出來最後再做乘法。</li>
<li>\(MSBL = 51.33/ (5-1) = 12.8\)</li>
</ul>
</li>
<li>Mean Square Due to Error <ul>
<li>\(SSE = 62 - 5.2 - 51.33 = 5.47\)</li>
<li>\(MSE = 5.47 / [ (3-1) (5-1)] = 0.68\)</li>
</ul>
</li>
</ul>
</li>
<li>畫成表格如下<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1ONi5CBegb-ikQW8ur86eHkiSNLXNWaN7&export=download" alt=""></p>
</blockquote>
</li>
<li>F 計算方式為 \(F = MSTR / MSE \)<ul>
<li>其中 F 是透過 \(2.60 / 0.68 = 3.82\)，自由度分子(x1) 則是 2、分母則是(x2) 8，因此機率算出為 0.07</li>
<li>用 probability distribution app 計算如下<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1ZMM2Ak7l9Ve8jrYeMuc2uWOrLcZSwXgl&export=download" alt=""></p>
</blockquote>
</li>
</ul>
</li>
<li>Rejection Rule <ul>
<li>p-value approach: Reject \(H_0\) if \(p-value \leq 0.05 \)</li>
<li>critical value approach: Reject \(H_0\) if \(F \geq 4.46\)</li>
<li>在分子自由度為 2、分母自由度為 8 時，\(F_{0.05} = 4.46\)</li>
</ul>
</li>
<li>conclusion<ul>
<li>p-value approach: Reject \(H_0\) if \(0.07 \leq 0.05 \)，不符合  </li>
<li>critical value approach: 由於 F 為 3.82， Reject \(H_0\) if \(3.82 \geq 4.46\)，不符合 </li>
<li>並沒有符合。因此我們沒有辦法拒絕 \(H_0\)，因此我們沒有辦法表示油的混和方式對汽車每加侖的英里數有不同。</li>
</ul>
</li>
</ul>
<h1 id="因子實驗-Factorial-Experiment"><a href="#因子實驗-Factorial-Experiment" class="headerlink" title="因子實驗 Factorial Experiment"></a>因子實驗 Factorial Experiment</h1><ul>
<li>如果使用 Excel 資料分析<strong>雙因子變數分析：重複試驗</strong></li>
<li>上述之前我們都是只針對一個 Factor 來進行探討，現在我們要針對多個 Factor來進行探討，但一樣是使用 ANOVA 來計算，但也會有些計算不同。</li>
<li>舉例：如果 a factor 有 \(\alpha\) 個 treatment，b factor 有 \(\beta\) 個 treatment，那我們蒐集的資料就是有 \(\alpha \beta\) 個組合。</li>
<li>主要用來判斷兩個因子是否有交互作用，也可以檢查到兩因子對變數的假設檢定</li>
</ul>
<h2 id="Two-Factor-Factorial-Experiment"><a href="#Two-Factor-Factorial-Experiment" class="headerlink" title="Two-Factor Factorial Experiment"></a>Two-Factor Factorial Experiment</h2><h3 id="ANOVA"><a href="#ANOVA" class="headerlink" title="ANOVA"></a>ANOVA</h3><ul>
<li>公式為 \(SST = SSA + SSB + SSAB + SSE\)<ul>
<li>其中 SST 為 sum of squares total，自由度為 \(n_T -1 \)是全部的樣本總數量。</li>
<li>SSA sum of squares A，自由度為 \(n_a-1\)，為 a 樣本總數量</li>
<li>SSB sum of squares B，自由度為 \(n_b-1\)，為 b 樣本總數量</li>
<li>SSAB sum of squares A and B，自由度為 \((n_a-1)(n_b-1)\)<br>SAB 為 A 與 B 的關聯組合，其中 SSAB 與 SSA、SSB 不同，SSAB <strong>表示 A 中 treatment 與 B 中 treatment 的組合</strong></li>
<li>SSE sum of squares error，自由度為 \(ab(r-1)\)，r 表示一個 a 的 treatment 與一個 b 的 treatment 中有幾筆資料</li>
</ul>
</li>
<li>ANOVA table<ul>
<li>我們可以透過 F 檢定來知道，SSA、SSB、SSAB、SSE、SST 有沒有都 reject \(H_0\)</li>
<li><blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1w8dbocu-B_VVePQeuQ8p9DzKh8TrES3i&export=download" alt=""></p>
</blockquote>
</li>
</ul>
</li>
<li>計算步驟如下<ul>
<li>\(\alpha\) 表示 a 的所有 treatment</li>
<li>\(\beta\) 表示 b 的所有 treatment</li>
<li>\(r\) 表示有幾筆資料</li>
<li>\(\bar{\bar{x}} \) 為總資料數量</li>
<li>\(\sum_{i=1}^a\) 則是有幾個 treatment</li>
<li>\(\bar{x_i.}\) 則是平均，這裡每一個 tretmnet 的平均值</li>
<li><blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1w8dbocu-B_VVePQeuQ8p9DzKh8TrES3i&export=download" alt=""></p>
</blockquote>
</li>
<li><blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1eEpSydPE6E__BakIidIWmm4WqArH5vbn&export=download" alt=""></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="舉例：薪資調查公司，調查兩個產業與三個地點，我們想知道產業與地點是否會影響到他們的薪資，資料如下"><a href="#舉例：薪資調查公司，調查兩個產業與三個地點，我們想知道產業與地點是否會影響到他們的薪資，資料如下" class="headerlink" title="舉例：薪資調查公司，調查兩個產業與三個地點，我們想知道產業與地點是否會影響到他們的薪資，資料如下"></a>舉例：薪資調查公司，調查兩個產業與三個地點，我們想知道產業與地點是否會影響到他們的薪資，資料如下</h3><p>x 軸為地點、Y 軸為產業</p>
<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1p6jTIVIm_16Ub46CDXkpuGW5b-09ANPP&export=download" alt=""></p>
</blockquote>
<ul>
<li>Factors<ul>
<li>Factors A: 產業(2 treatment)</li>
<li>Factor B: 地點 (3 treatment)</li>
</ul>
</li>
<li>Replications<br>每一個實驗的情景 3 次。</li>
<li>ANOVA Table 計算<ul>
<li>可以使用 excel 中的資料分析，<strong>雙因子試驗</strong>計算，並選擇<strong>重複試驗</strong>，因為我們的 ANOVA 公式有 SSAB。有交互作用時則需要選擇<strong>重複試驗</strong><blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1MnG9Mp19IeoH8ErS-UnaOvZCEG87_YVu&export=download" alt=""></p>
</blockquote>
</li>
</ul>
</li>
<li>conclusions<ul>
<li>ctitical value approach<ul>
<li>產業： \(F=4.19 \leq F_a = 4.75\)<br>不同的產業，薪水並不會有差別</li>
<li>地點： \(F= 4.69 &gt; F_a = 3.89\)<br>不同的地點，薪水並<strong>會有差別</strong></li>
<li>交互作用： \(F=1.55 &lt; F_a = 3.89\)<br>此二因素並沒有關聯</li>
</ul>
</li>
<li>p-value approach <ul>
<li>產業： \(p-value=0.06 &gt; a = 0.05\)<br>不同的產業，薪水並不會有差別</li>
<li>地點： \(p-value = 0.03 \leq a = 0.05\)<br>不同的地點，薪水<strong>會有差別</strong></li>
<li>交互作用： \(p-value=0.25 &gt; a = 0.05\)<br>此二因素並沒有關聯</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>我打到快死掉了QQQ，大二下怎麼那麼忙啦…。也謝謝丁秀儀老師的線上教學可以讓我將資料彙整並供我學習。</p>
]]></content>
      <categories>
        <category>北科上課筆記</category>
        <category>統計 statistics</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>統計學筆記</tag>
        <tag>北科大二下統計學筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>統計學(二) 筆記 - 第十五章 複迴歸(Multiple Regression)</title>
    <url>/2021/05/15/statistics/statistics-ch15/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊與財金管理系大二下統計學重點整理<br><font color="#dd0000">並非所有人都適用，部分對我而言稍加容易的內容並不會寫在此內。</font><br><strong>這是觀看影片心得後的筆記，老師上課可能不太適用會忘記抄到</strong></p>
</blockquote>
<a id="more"></a>

<h1 id="複迴歸模型-Multiple-Regression-Model"><a href="#複迴歸模型-Multiple-Regression-Model" class="headerlink" title="複迴歸模型 Multiple Regression Model"></a>複迴歸模型 Multiple Regression Model</h1><p>在<a href="https://theriseofdavid.github.io/2021/05/02/NTUT_note/statistics-ch14/" target="_blank" rel="noopener">第十四章 簡單線性迴歸(Simple Linear Rejression)</a>提到的獨立變數，就是這邊的自變數。<br>因為獨立變數是表示只有此變數可以在簡單迴歸方程式中，但可以有多個<strong>自變數</strong>在複迴歸方程式中</p>
<ul>
<li>功能<ul>
<li>考慮兩個或兩個以上的自變數的迴歸為複迴歸，如果只有一個為<a href="https://theriseofdavid.github.io/2021/05/02/NTUT_note/statistics-ch14/" target="_blank" rel="noopener">第十四章 簡單線性迴歸(Simple Linear Rejression)</a></li>
<li>通常複迴歸比簡單線性迴歸的預測能力好<strong>更多</strong>，<del>廢話</del></li>
</ul>
</li>
<li>Model 公式 <ul>
<li>複迴歸公式為 \(y = \beta_0 + \beta_1 x_1 + \beta_2 x_2 + … + \beta_p x_p +  \mathcal{E}  \)<ul>
<li>其中 \(\beta\) 為自變數的係數</li>
<li>\(p\) 表示總共的自變數數量</li>
<li>\(\mathcal{E} \) 為隨機變數誤差項</li>
</ul>
</li>
<li>Expect 公式 \(E(y) = \beta+0 + \beta_1 x_1 +  \beta_2 x_2 + … + \beta_p x_p \)<ul>
<li>其中 \(\beta\) 為自變數的係數</li>
<li>\(p\) 表示自變數數量</li>
<li>\(\mathcal{E} = 0 \)，由於此自變數是期望值的誤差項，因此在計算期望值時並不需用到。</li>
</ul>
</li>
</ul>
</li>
<li>估計複迴歸模型 Estimation Multiple Regression Equation<ul>
<li>由於我們不能確定期望值方程式中的 \(\beta_0 + \beta_1 x + \beta_2 x_2 + … + \beta_p x_p \)，因此我們透過樣本資料與估計線性迴歸方程式得出 \(b_0, b_1, b_2, … , b_p\)，再透過 \(b_0, b_1, b_2, … , b_p\) 去估計 \(\beta_0 , \beta_1 ,  \beta_2  , … , \beta_p  \)</li>
<li>其中我們的資料不可以有任意<strong>自變數</strong> 遺失，有遺失就必須刪除。<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1BgjNBOzhvHz-qTHEQ5WSNe8TdB7mF8JW&export=download" alt=""></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h1 id="最小平方法-Least-Squares-Method"><a href="#最小平方法-Least-Squares-Method" class="headerlink" title="最小平方法 Least Squares Method"></a>最小平方法 Least Squares Method</h1><ul>
<li>使用最小平方法來推複迴歸公式</li>
<li>Least Squares Criterion 公式為 \(min \sum (y_i - \hat{y_i})^2\)</li>
<li>由於我們有大量的的 \(b\) 要運算，且常會使用到矩陣運算，因此我們使用電腦進行運算</li>
<li>因此主要重點為解讀資料，並非如何去計算複迴歸模型公式</li>
</ul>
<h2 id="舉例：程式設計師薪水調查，有-20-位程式設計師的資料，其中資料有-年資、程式能力、薪水，我們想要想確認年資是否與程式能力、年資有關係？"><a href="#舉例：程式設計師薪水調查，有-20-位程式設計師的資料，其中資料有-年資、程式能力、薪水，我們想要想確認年資是否與程式能力、年資有關係？" class="headerlink" title="舉例：程式設計師薪水調查，有 20 位程式設計師的資料，其中資料有 年資、程式能力、薪水，我們想要想確認年資是否與程式能力、年資有關係？"></a>舉例：程式設計師薪水調查，有 20 位程式設計師的資料，其中資料有 年資、程式能力、薪水，我們想要想確認年資是否與程式能力、年資有關係？</h2><blockquote>
<p>資料如下：<br><img src="https://drive.google.com/u/2/uc?id=1SJeEBDR9TUxas8cI82ntr7LRuOV3CLme&export=download" alt=""></p>
</blockquote>
<ul>
<li>訂出迴歸模型公式<ul>
<li>\(y = \beta_0 + \beta_1 x_1 + \beta_2 x_2 + \mathcal{E}\)</li>
<li>其中 \(y = 薪水\)，1000 美金為一單位</li>
<li>\(x_1 = 年資\)</li>
<li>\(x_2 = 程式能力\)</li>
<li>每個自變數定義都必須寫出來</li>
</ul>
</li>
<li>透過程式進行運算，推出 \(b_0, b_1, b_2, R^2\)<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1LvXZvwYUjEI6sctCScznfIrr0d5SCmUV&export=download" alt=""></p>
</blockquote>
</li>
<li>運算結果如下<ul>
<li>其中我們可以知道 常數 constant 3.17394</li>
<li>經驗 \(x_1\) 的係數為 1.404</li>
<li>程式能力 \(x_2\) 的係數為 0.251</li>
<li>因此公式為 \(y = 3.174 + 1.404 x_1 + 0.251 x_2\)，其中 y 則是 1000 美金為一單位</li>
<li><blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1LY622aygxLFrRMg9zh1kr0Nwl-M6kbD3&export=download" alt=""></p>
</blockquote>
</li>
</ul>
</li>
<li>解釋相關係數 Interpreting the Coefficients<ul>
<li>其中我們可以知道在其他數字不變，只有 \(b_i\) 改變的情況下，會給 y 帶來多少的改變</li>
<li>舉例<ul>
<li>在其他係數不變，年資每增加一單位，薪水則增加 1.404 單位。</li>
<li>在其他係數不變，程式設計能力增加一單位，薪水增加 0.251 單位。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="複判定係數-Multiple-Cofficient-of-Determination"><a href="#複判定係數-Multiple-Cofficient-of-Determination" class="headerlink" title="複判定係數 Multiple Cofficient of Determination"></a>複判定係數 Multiple Cofficient of Determination</h1><ul>
<li>判定係數：用來表示此迴歸模型可以解釋百分之 \(r^2\)的資料</li>
<li>複習 ANOVA 公式 \(\sum (y_i - \bar{y})^2 = \sum (\hat{y_i}- \bar{y})^2 + \sum (y_i - \hat{y_i})^2 \)<ul>
<li>其中 \(SST = \sum (y_i - \bar{y})^2\) 總平方和 total sum of squares</li>
<li>其中 \(SSR = \sum (\hat{y_i}- \bar{y})^2\) 迴歸平方和</li>
<li>其中 \(SSE = \sum (y_i - \hat{y_i})^2 \) 誤差平方和</li>
</ul>
</li>
<li>我們透過電腦計算時 ANOVA 表則會有 SST 與 SSR，圖表如下<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1Fy7lpnsn1vwt6KA0nDGSk_Rq-oR1KD41&export=download" alt=""></p>
</blockquote>
</li>
<li>判定係數公式 \(r^2 = SSR / SST \)<ul>
<li>其中 SSR 迴歸平方和</li>
<li>SST 誤差平方和</li>
<li>當 \(r^2\) 越大時則表示此迴歸方程式能夠解讀資料的能力越好</li>
</ul>
</li>
<li>調整複判定係數公式 Adjusted Multiple Coefficient of Determination <ul>
<li>其中在複迴歸判定係數中，只要我們增加更多的自變數進入複迴歸，那 SSE 必定會減少，SST 不變，SSR 就會增加，因此 R 平方係數一定會增加，因此我們解釋資料一定會更好</li>
<li>即使假如此自變數與 y 沒有關聯，但多一個變數勢必可以對誤差降低帶來影響。</li>
<li>雖然只要增加新的自變數就可以讓 \(r^2\) 越高，但是如果我們增加更多的自變數，則我們的自由度會將低，(自由度是取決於資料筆數 - 自變數與因變數)，這樣我們在做顯著性測試、區間預測時則會因為自由度降低帶來負面效果。</li>
<li>因此並不是追求增加變數就是好的 \(r^2\)，因此我們就調整判定係公式來推估在複迴歸</li>
<li>調整後複判定係數公式 \(R_a^2 = 1 - (1- r^2) \frac{n-1}{n-p-1}\)<ul>
<li>其中 \(r^2 \) 為<strong>未調整</strong>的判定係數</li>
<li>\(n\) 資料筆數</li>
<li>\(p\) 自變數與因變數的總和</li>
</ul>
</li>
<li><a href="http://web.nchu.edu.tw/~finmyc/stat13p.pdf" target="_blank" rel="noopener">調整複判定係數公式 Adjusted Multiple Coefficient of Determination 資料來源為此連結 ppt 第 15 頁</a></li>
</ul>
</li>
</ul>
<h2 id="舉例：根據先前程式設計師的舉例，請告訴我調整後判定係數的數值是多少"><a href="#舉例：根據先前程式設計師的舉例，請告訴我調整後判定係數的數值是多少" class="headerlink" title="舉例：根據先前程式設計師的舉例，請告訴我調整後判定係數的數值是多少"></a>舉例：<a href="#舉例：程式設計師薪水調查，有-20-位程式設計師的資料，其中資料有-年資、程式能力、薪水，我們想要想確認年資是否與程式能力、年資有關係？">根據先前程式設計師的舉例</a>，請告訴我調整後判定係數的數值是多少</h2><ul>
<li>答：\(R_a^2 = 1 - (1- 0.834179) \frac{20-1}{20-2-1} = 0.814671\)</li>
<li>透過圖片進行解釋<ul>
<li>其中紅色線條就是我們的方程式，而其標示的米黃色亮面為 \(x_1, x_2\) 為任意數值情況下，所在的區域</li>
<li>藍色線條為當 \(x_1, x_2 \) 為一固定值時，其位置在哪裡</li>
<li>綠色圈圈則是我們預測的數值，透過紅色線條公式去計算後，所對應的點，且一定會在米黃色亮面上。</li>
<li>紫色圈圈為實際的數值，紫色圈圈往下則有 \(\mathcal{E}\)，那就是針對此點的誤差範圍。</li>
<li><blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1FuTSOJRTQjxUlF4Wp2MJ91j1hK2oedTP&export=download" alt=""></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h1 id="複迴歸模型假設-Model-Assumptions"><a href="#複迴歸模型假設-Model-Assumptions" class="headerlink" title="複迴歸模型假設 Model Assumptions"></a>複迴歸模型假設 Model Assumptions</h1><p>定義 \(\mathcal{E} = y_i - \hat{y_i}\)</p>
<p>我們對於 \(\mathcal{E}\) 有以下假設</p>
<ul>
<li>我們假設 \(\mathcal{E}\) 是平均數為零的隨機變數<ul>
<li>因此我們可以表示 \(E(\mathcal{E}) = 0\)</li>
<li>所以 \(y = \beta_0 + \beta_1 x_1 + \beta_2 x_2 + … + \beta_p x_p + \mathcal{E}\)，才可以省略 \(\mathcal{E}\)</li>
</ul>
</li>
<li>\(\mathcal{E}\) 的變異數定義為 \(\sigma^2\)，因此迴歸線裡面的所有的自變數中的 \(\mathcal{E}\) 變異數為 都是 \(\sigma^2\)</li>
<li>\(\mathcal{E}\) 為獨立變數，每一個變數的 \(\mathcal{E}\) 都不同，互相獨立</li>
<li>\(\mathcal{E}\) 是常態分配的隨機變數</li>
</ul>
<h1 id="顯著性測試-Testing-for-Significance"><a href="#顯著性測試-Testing-for-Significance" class="headerlink" title="顯著性測試 Testing for Significance"></a>顯著性測試 Testing for Significance</h1><ul>
<li>在簡單線性迴歸方程式中，使用 F 檢定與 T 檢定都可以</li>
<li>在複迴歸方程式中，F 檢定與 T 檢定則有不同意義<ul>
<li>F 檢定是檢定<strong>所有的自變數是否跟 y 有關係</strong></li>
<li>T 檢定是檢定<strong>單一自變數是否跟 y 有關係</strong></li>
</ul>
</li>
</ul>
<h2 id="F-test"><a href="#F-test" class="headerlink" title="F test"></a>F test</h2><ul>
<li>假設檢定<ul>
<li>\(H_0: \beta_1 = \beta_2 = … = \beta_p = 0 \)</li>
<li>\(H_1: \) 上面公式不符合，表示並沒有全部自變數與 y 沒有關聯</li>
</ul>
</li>
<li>F test Statisitic<br>\(F = MSR / MSE \)</li>
<li>Rejection Rule <ul>
<li>Reject \(H_0\) if \(p-value \leq \alpha \) or \(F \geq F_\alpha\)</li>
<li>其中 \(F_a\) 為我們計算的 f 描述</li>
<li>分子自由度為 \(p\)，使用的自變數總數、分母自由度為 \(n-p-1\)，資料總數 - 自變數 - 1</li>
</ul>
</li>
</ul>
<h3 id="舉例：根據先前程式設計師的舉例，我們想確定這些自變數是否與-y-有關聯"><a href="#舉例：根據先前程式設計師的舉例，我們想確定這些自變數是否與-y-有關聯" class="headerlink" title="舉例：根據先前程式設計師的舉例，我們想確定這些自變數是否與 y 有關聯"></a>舉例：<a href="#舉例：根據先前程式設計師的舉例，請告訴我調整後判定係數的數值是多少">根據先前程式設計師的舉例</a>，我們想確定這些自變數是否與 y 有關聯</h3><ul>
<li>假設檢定<ul>
<li>\(H_0: \beta_1 = \beta_2 = 0 \)</li>
<li>\(H_1: \) 上面公式不符合</li>
</ul>
</li>
<li>\(\alpha \) 為 0.05 </li>
<li>Rejection Rule <ul>
<li>Reject \(H_0\) if \(p-value \leq 0.05 \) or \(F \geq F_{0.05} = 3.59\)</li>
<li>其中 \(F_a\) 為我們計算的 f 描述</li>
<li>分子自由度為 \(p = 2\)，使用的自變數總數、分母自由度為 \(n-p-1 = 17\)，資料總數 - 自變數 - 1，其中 1 是因變數</li>
</ul>
</li>
<li>F test Statisitic<br>\(F = MSR / MSE \)</li>
<li>透過電腦計算 F 與 p-value，由於都是透過電腦計算，因此不需要使用 probability distribution app 計算<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1wRfnC9CMK02Uemoa87CE1-qBMJXrN5k8&export=download" alt=""></p>
</blockquote>
</li>
<li>colclusion<br>由於我們計算出來的 \(F = 42.76 \geq F_{0.05} = 3.59\)，因此我們拒絕 \(H_0\)，表示並沒有全部自變數與 y 沒有關聯，因此我們需要做 t 檢定去看哪個自變數與 y 沒有關聯。</li>
</ul>
<h2 id="T-test"><a href="#T-test" class="headerlink" title="T test"></a>T test</h2><ul>
<li>假設檢定<ul>
<li>\(H_0: \beta_i = 0 \)</li>
<li>\(H_1: \beta_i != 0\)</li>
</ul>
</li>
<li>Test Statistic<ul>
<li>公式 \(t = \frac{b_i}{s_{b_i}}\)</li>
</ul>
</li>
<li>Rejcetion Rule <ul>
<li>Reject \(H_0\) if \(p-value \leq \alpha \) or \(t \leq -t_{a/2} \) or \(t \geq t_{a/2}\)</li>
<li>其中 \(t_{a/2}\) 為 t 描述</li>
<li>自由度為 \(n-p-1\)，資料總數 - 自變數 - 1，其中 1 是因變數</li>
</ul>
</li>
</ul>
<h3 id="舉例：根據先前程式設計師的舉例，我們想知道年資、程式能力是否與-y-有關聯"><a href="#舉例：根據先前程式設計師的舉例，我們想知道年資、程式能力是否與-y-有關聯" class="headerlink" title="舉例：根據先前程式設計師的舉例，我們想知道年資、程式能力是否與 y 有關聯"></a>舉例：<a href="#舉例：根據先前程式設計師的舉例，我們想確定這些自變數是否與-y-有關聯">根據先前程式設計師的舉例</a>，我們想知道年資、程式能力是否與 y 有關聯</h3><ul>
<li>假設檢定<ul>
<li>\(H_0: \beta_i = 0 \)</li>
<li>\(H_1: \beta_i != 0\)</li>
</ul>
</li>
<li>Test Statistic<ul>
<li>公式 \(t = \frac{b_i}{s_{b_i}}\)</li>
</ul>
</li>
<li>\(\alpha \) 為 0.05 </li>
<li>Rejcetion Rule <ul>
<li>Reject \(H_0\) if \(p-value \leq \alpha = 0.05 \) or \(t \leq -t_{a/2} = 2.11\) or \(t \geq t_{a/2} = 2.11\)</li>
<li>其中 \(t_{a/2}\) 為 t 描述</li>
<li>自由度為 \(n-p-1 = 17\)，資料總數 - 自變數 - 1，其中 1 是因變數</li>
</ul>
</li>
<li>透過電腦計算 T 與 p-value，由於都是透過電腦計算，因此不需要使用 probability distribution app 計算<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1HFTnpfKziq988vmjqLDi-3XoWckd5DSn&export=download" alt=""></p>
</blockquote>
</li>
<li>年資<ul>
<li>Reject \(H_0\) if \(p-value = 0.00000 \leq \alpha = 0.05 \)</li>
<li>拒絕 \(H_0\) 因此工作年資與薪資有關聯且正相關，因為迴歸方程式為 \(+ b_0\)</li>
</ul>
</li>
<li>程式能力<ul>
<li>Reject \(H_0\) if \(p-value = 0.00478 \leq \alpha = 0.05 \)</li>
<li>拒絕 \(H_0\) 因此程式能力與薪資有關聯且正相關，因為迴歸方程式為 \(+ b_1\)</li>
</ul>
</li>
</ul>
<h2 id="Multicollinearity-共線性"><a href="#Multicollinearity-共線性" class="headerlink" title="Multicollinearity 共線性"></a>Multicollinearity 共線性</h2><ul>
<li>由於我們會有兩個以上的自變數，這時候我們沒有辦法保證自變數們沒有相關性，例如：有 A,B,C 三個自變數，其中 A,B 有大量相關性。</li>
<li>比較寬鬆的方法是排列組合每一個自變數，兩個自變數為一組(定義 pair 自變數)，只要 pair 自變數的相關係數大於 0.7 (\(|r| &gt; 0.7\))，就必須將 pair 自變數中其中一個自變數做刪除。<a href="https://theriseofdavid.github.io/2020/10/15/NTUT_note/statistcs-ch3B/#Correlation-Coefficient-%E7%9B%B8%E9%97%9C%E4%BF%82%E6%95%B8" target="_blank" rel="noopener">相關係數說明 by 大衛的筆記</a></li>
<li>引發甚麼問題？<ul>
<li>由於我們只預測 y 值，如果兩個自變數\(x_1, x_2\) 相關係數高，舉例： \(y = 1 + 0.4 x_1 + 0.5 x_2 \)，那在實際應用上 \(x_1, x_2\) 都會呈同向或反向變動，此時這樣就會對 y 造成失真的問題。</li>
<li>假設 \(x_1, x_2\) 分別是月收入，年收入、\(y\) 為生活支出花費，如果月收入降低，年收入也會降低，那麼在實際資料上兩者會同時降低或增加，\(y\) 就會大量劇動，導致失真。</li>
<li><a href="https://zh.wikipedia.org/wiki/%E5%A4%9A%E9%87%8D%E5%85%B1%E7%BA%BF%E6%80%A7" target="_blank" rel="noopener">資料來源 by wiki</a></li>
</ul>
</li>
<li>因此建議我們在跑回歸方程式時，先確定自變數(\(x\)) 是否有共線性問題，以避免我們回歸做太多次。</li>
</ul>
<h1 id="使用估計迴歸方程式來預測或預估-Using-the-Estimated-Regression-Equation-for-Estimation-and-Prediction"><a href="#使用估計迴歸方程式來預測或預估-Using-the-Estimated-Regression-Equation-for-Estimation-and-Prediction" class="headerlink" title="使用估計迴歸方程式來預測或預估 Using the Estimated Regression Equation for Estimation and Prediction"></a>使用估計迴歸方程式來預測或預估 Using the Estimated Regression Equation for Estimation and Prediction</h1><p>主要用途</p>
<ul>
<li>採用<strong>信心區間</strong>，給定 x 推出 y 的平均值為多少</li>
<li>採用<strong>預測區間</strong>，給定 x 的值我們想知道在 x 的情況下 y 值(特定數值)為多少</li>
<li>在使用預測區間時，其範圍會比信心區間來的更大</li>
<li>複迴歸計算較為麻煩，因此<strong>全部都用軟體運算，因此就不講了QQ</strong>，如果不清楚上面名詞則可以透過簡單線性迴歸中的估計迴歸方程式來預測或預估，來了解這些知識。</li>
</ul>
<p>我們可以看 <a href="https://theriseofdavid.github.io/2021/05/02/NTUT_note/statistics-ch14/#%E4%BD%BF%E7%94%A8%E4%BC%B0%E8%A8%88%E8%BF%B4%E6%AD%B8%E6%96%B9%E7%A8%8B%E5%BC%8F%E4%BE%86%E9%A0%90%E6%B8%AC%E6%88%96%E9%A0%90%E4%BC%B0-Using-the-Estimated-Regression-Equation-for-Estimation-and-Prediction" target="_blank" rel="noopener">第十四章 簡單線性迴歸(Simple Linear Rejression) - 使用估計迴歸方程式來預測或預估 Using the Estimated Regression Equation for Estimation and Prediction by 大衞的筆記</a> 來知道信心區間、預測區間是甚麼，為甚麼預測區間會比信心區間來的大。</p>
<h1 id="類別型變數在複迴歸下的應用-Categorical-Independent-Variables"><a href="#類別型變數在複迴歸下的應用-Categorical-Independent-Variables" class="headerlink" title="類別型變數在複迴歸下的應用 Categorical Independent Variables"></a>類別型變數在複迴歸下的應用 Categorical Independent Variables</h1><p>在建立回歸模型時，有一些是類別型的變數，例如我們現在加入一個變數 \(x_2\)，只要他是男生就是 1、女生就是 0。這種作法，我們稱之為 虛擬或表示變數 dummy or indicator variable</p>
<h2 id="舉例：根據先前程式設計師的舉例"><a href="#舉例：根據先前程式設計師的舉例" class="headerlink" title="舉例：根據先前程式設計師的舉例"></a>舉例：<a href="#舉例：根據先前程式設計師的舉例，我們想確定這些自變數是否與-y-有關聯），原本自變數是年資、程式能力，我們現在加入是否有碩士學歷來預估薪資">根據先前程式設計師的舉例</a></h2><ul>
<li>因此我們現在的預估方程式改為 \(\hat{y} = \beta_0 + \beta_1 x_1 + \beta_2 x_2 + \beta_3 x_3 + \mathcal{E}\)<ul>
<li>其中 \(\hat{y}\) 是薪水</li>
<li>\(x_1\) 是年資</li>
<li>\(x_2\) 是程式能力</li>
<li>\(x_3\) 是否有碩士學歷，0 表示沒有、1 表示有，此變數為 dummy or indicator variable</li>
</ul>
</li>
<li>計算出來的 ANOVA 表如下，其中在這次的回歸測試中，調整後 \(R^2\) 比沒有加入碩士學歷此變數的回歸模型調整後 \(R^2 \) 更好<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1Ey7Ivr8RruTr1PFdoq9OiWVzLx_wkfxy&export=download" alt=""></p>
</blockquote>
</li>
<li>我們現在看 t test，針對每一個變數進行假設檢定<ul>
<li>可以發現 \(x_3\) 是否有碩士學歷與 y 並沒有關係。註： test score 為程式能力</li>
<li><blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1nf5VD0ABhlLjeWZJjTREM6iyZjgXjk5Y&export=download" alt=""></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="複雜的類別變數-More-Complex-Categorical-Variables"><a href="#複雜的類別變數-More-Complex-Categorical-Variables" class="headerlink" title="複雜的類別變數 More Complex Categorical Variables"></a>複雜的類別變數 More Complex Categorical Variables</h2><ul>
<li>在某些情況下，類別型變數會有超過 2 個以上的類別型變數，舉例：信用卡的銀行</li>
<li>在這種情況，我們是增加自變數的變數量<ul>
<li>舉例：某一類別型變數有 3 個分類，分類的 level 為 A、B、C</li>
<li>答：那我們則需要新增兩個自變數 \(x_1, x_2\)，其中 \(A = (0,0),B = (1,0),C = (0,1)\)，\((i,j)\) 分別是 \(x_1, x_2\)</li>
</ul>
</li>
<li>如果我們有更多的 level 要進行分類，那就需要更多的自變數表示，如果有 \(k-level\) 那我們的自變數就需要 \(k-1\)<br>每一個 \(k-level\) 只能在一個 dummy variable 中表示 1，除了有一個 \(level\) 可以再全部的 dummy variable 表示零</li>
</ul>
<h1 id="殘差分析-Residual-Analysis"><a href="#殘差分析-Residual-Analysis" class="headerlink" title="殘差分析 Residual Analysis"></a>殘差分析 Residual Analysis</h1><ul>
<li>在<a href="https://theriseofdavid.github.io/2021/05/02/NTUT_note/statistics-ch14/#%E6%AE%98%E5%B7%AE%E5%88%86%E6%9E%90-%E5%90%88%E6%B3%95%E6%A8%A1%E5%9E%8B%E5%81%87%E8%A8%AD-Residual-Analysis-Validating-Model-Assumptions" target="_blank" rel="noopener">統計學(二) 筆記 - 第十四章 簡單線性迴歸(Simple Linear Regression) 中 殘差分析: 合法模型假設 Residual Analysis: Validating Model Assumptions by 大衞的筆記</a>有提到關於誤差項的假設，那這邊我們一樣要對殘差分析進行驗證</li>
<li>檢查標準化殘差(通常使用電腦計算)是否 \(residuals &lt;= |2|\)，resuduals 就是殘差，來判斷是否為常態分配</li>
<li>我們將 \(y, residuals\) 畫出散佈圖後，則可以明顯發現圖中有離群值</li>
<li>舉例<ul>
<li>舉例資料如下<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1GQFhQq9-dQnbbaKS78WyCjiQw94MxkN_&export=download" alt=""></p>
</blockquote>
</li>
<li>舉例的散佈圖如下，可以發現有一點離群值<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1JZvEiwyxERbqIDuMVQqHEI0FESDAON8E&export=download" alt=""></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h1 id="羅吉斯迴歸-Logistic-Regression"><a href="#羅吉斯迴歸-Logistic-Regression" class="headerlink" title="羅吉斯迴歸 Logistic Regression"></a>羅吉斯迴歸 Logistic Regression</h1><ul>
<li>有一些自變數是屬於類別變數，那我們要怎麼拿來回測呢？如果這個類別變數只有二元的關係時，可以將變數設定為 0、1。EX: 要不要來上課，\(不上課 = 0\)、\(上課 = 1\)</li>
<li>如果 \(y\) 變數是類別型變數時，那麼我們的模型回歸方程式也會跟著改變，羅吉斯回歸方程式</li>
<li>羅吉斯回歸方程式如下：(blog 的 bug mathjax 在次方項太長時，顯示效果並不好)<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1hYJ_dxIDa-mjV9FN58oAdd3Oe7bd3JC-&export=download" alt=""></p>
</blockquote>
</li>
<li>因此我們在解釋羅吉斯回歸方程式，我們會這樣解釋 \(E(y) = \text{estimate of } P(y=1| x_1, x_2, …, x_p)\)，在 \( x_1, x_2, …, x_p\) 都是特定值的情況下，那我們會做 \(y\) 的機率是多少？<ul>
<li>由於我們要預測類別型變數時，我們沒辦法接受 y 值為負，因為 y 也是類別型函數，因此變數只有 0、1，如果有負值或大於 1 就表示超出合理範圍內，舉例示意圖如下<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1PjEAwJxc0ul3OkCFaj--KdcqnZEfwxhb&export=download" alt=""></p>
</blockquote>
</li>
</ul>
</li>
<li>因此我們的預估羅吉斯回歸方程式如下：(blog 的 bug mathjax 在次方項太長時，顯示效果並不好) <blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1SGa76UUNJygvVwpjFBfnPZ_gFzVDE1rw&export=download" alt=""></p>
</blockquote>
<ul>
<li>其中 \(b\) 是預估 \(\beta\)參數</li>
</ul>
</li>
</ul>
<h2 id="舉例：西門公司想要發行型錄，型錄裡面都會附上-200-元的折扣卷，由於型錄成本過高，所以主管想透過顧客是否為使用折價卷來判定是否需要給此顧客型錄，因此西門管理部門想要透過回歸來判斷我們應該要給那些顧客型錄，這樣就能降低折扣卷成本，我們用來預測的自變數有西門聯名信用卡公司、顧客去年花費"><a href="#舉例：西門公司想要發行型錄，型錄裡面都會附上-200-元的折扣卷，由於型錄成本過高，所以主管想透過顧客是否為使用折價卷來判定是否需要給此顧客型錄，因此西門管理部門想要透過回歸來判斷我們應該要給那些顧客型錄，這樣就能降低折扣卷成本，我們用來預測的自變數有西門聯名信用卡公司、顧客去年花費" class="headerlink" title="舉例：西門公司想要發行型錄，型錄裡面都會附上 200 元的折扣卷，由於型錄成本過高，所以主管想透過顧客是否為使用折價卷來判定是否需要給此顧客型錄，因此西門管理部門想要透過回歸來判斷我們應該要給那些顧客型錄，這樣就能降低折扣卷成本，我們用來預測的自變數有西門聯名信用卡公司、顧客去年花費"></a>舉例：西門公司想要發行型錄，型錄裡面都會附上 200 元的折扣卷，由於型錄成本過高，所以主管想透過顧客是否為使用折價卷來判定是否需要給此顧客型錄，因此西門管理部門想要透過回歸來判斷我們應該要給那些顧客型錄，這樣就能降低折扣卷成本，我們用來預測的自變數有西門聯名信用卡公司、顧客去年花費</h2><ul>
<li>其中我們找了 100 份樣本<ul>
<li>50 份發給有西門聯名的信用卡客戶</li>
<li>50 份則是發給沒有西門聯名信用卡的客戶</li>
</ul>
</li>
<li>我們會記錄以下資訊<ul>
<li>此顧客去年花多少錢在我們公司上</li>
<li>此顧客是否使用西門聯名信用卡消費</li>
<li>此顧客是否有使用型錄中的 200 元折扣卷</li>
</ul>
</li>
</ul>
<ul>
<li>其中我們將 \(x_1, x_2\) 分別為年花費、是否有聯名信用卡，\(y\) 則是我們要預測的是否有使用 200 元折扣卷，其中我們這邊擷取 10 筆資料，作為示意圖<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1Pvj8CKMMg3DD5TlEirqMBD3pCV6NopH1&export=download" alt=""></p>
</blockquote>
</li>
<li>其中預估羅吉斯回歸方程式請看圖片，通常都透過電腦進行計算 (blog 的 bug mathjax 在次方項太長時，顯示效果並不好) <blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1-lth9LlMGs2-cWxLsNHZ2fQVQp20SE6T&export=download" alt=""></p>
</blockquote>
</li>
<li>因此我們可以進行推估<ul>
<li>消費 2000 元、沒有使用西門聯名信用卡，那使用折價卷的機率則是 0.1880　(blog 的 bug mathjax 在次方項太長時，顯示效果並不好) </li>
<li>消費 2000 元、<strong>有</strong>使用西門聯名信用卡，那使用折價卷的機率則是 0.4099　(blog 的 bug mathjax 在次方項太長時，顯示效果並不好) </li>
<li>計算如下<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1nGqgIpOGiT6pDRSkLv2wZnlLE5fqooBT&export=download" alt=""></p>
</blockquote>
</li>
</ul>
</li>
<li>我們將資料彙成表，公司則是決定在 \(\hat{y} &gt;= 0.4\) 的才進行發行<ul>
<li>因此如果有聯名信用卡，年花費必須大於等於 2000 來給予型錄</li>
<li>因此如果<strong>沒有</strong>聯名信用卡，年花費必須大於等於 6000 來給予型錄<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1xA0u8OAOkERM3fgKmSpVzsJ5kC8TTZUS&export=download" alt=""></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="顯著性測試-Testing-for-Signifcance"><a href="#顯著性測試-Testing-for-Signifcance" class="headerlink" title="顯著性測試 Testing for Signifcance"></a>顯著性測試 Testing for Signifcance</h2><p>在羅吉斯回歸中，我們也有的顯著性測試</p>
<h3 id="整體的顯著性測試"><a href="#整體的顯著性測試" class="headerlink" title="整體的顯著性測試"></a>整體的顯著性測試</h3><ul>
<li>Hypotheses<ul>
<li>\(H_0: \beta_1 = \beta_2 = … = 0 \)</li>
<li>\(H_1:\) 不符合上面方程式</li>
</ul>
</li>
<li>Test Statistics 使用 Statistic G，這邊我們暫時不對 G 做解釋，<del>因為老師沒有教</del></li>
<li>Rejection Rule: Reject \(H_0\) if \(p-value \leq \alpha\)</li>
</ul>
<h3 id="單體顯著性測試"><a href="#單體顯著性測試" class="headerlink" title="單體顯著性測試"></a>單體顯著性測試</h3><ul>
<li>Hypotheses<ul>
<li>\(H_0: \beta_1 = 0 \)</li>
<li>\(H_1:\) 不符合上面方程式</li>
</ul>
</li>
<li>Test Statistics 使用 Statistic z，\(z = b_i / s_{b_i}\)</li>
<li>Rejection Rule: Reject \(H_0\) if \(p-value \leq \alpha\)</li>
</ul>
<h3 id="舉例：根據先前西門公司的舉例，我們想知道整體顯著性測試是否拒絕-H-0-，如果沒有，那我們要找出哪個自變數沒有拒絕-H-0"><a href="#舉例：根據先前西門公司的舉例，我們想知道整體顯著性測試是否拒絕-H-0-，如果沒有，那我們要找出哪個自變數沒有拒絕-H-0" class="headerlink" title="舉例：根據先前西門公司的舉例，我們想知道整體顯著性測試是否拒絕 \(H_0\)，如果沒有，那我們要找出哪個自變數沒有拒絕 \(H_0\)"></a>舉例：<a href="#舉例：西門公司想要發行型錄，型錄裡面都會附上-200-元的折扣卷，由於型錄成本過高，所以主管想透過顧客是否為使用折價卷來判定是否需要給此顧客型錄，因此西門管理部門想要透過回歸來判斷我們應該要給那些顧客型錄，這樣就能降低折扣卷成本，我們用來預測的自變數有西門聯名信用卡公司、顧客去年花費">根據先前西門公司的舉例</a>，我們想知道整體顯著性測試是否拒絕 \(H_0\)，如果沒有，那我們要找出哪個自變數沒有拒絕 \(H_0\)</h3><ul>
<li>可以看出整體的顯著性測試(G) 的 p-value = 0.001，因此全部都有符合</li>
<li>可以看到截距、花費、是否有信用卡的顯著性測試(Z) 的 p-value 分別為 0.000、0.008、0.013，因此都有符合單體顯著性測試<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1tl6RTK3HrUGizUiJx5zZz9TuDavagZc9&export=download" alt=""></p>
</blockquote>
</li>
</ul>
<h2 id="勝算比-Odds-Ration"><a href="#勝算比-Odds-Ration" class="headerlink" title="勝算比 Odds Ration"></a>勝算比 Odds Ration</h2><ul>
<li>我們有時候會好奇，在 \(x_1, x_2 , … , x_p \) 都是固定的狀態下時，那我們能獲得 \(y\) 的機率是多少？這就是勝算比。注意：\(y=1\) 是我們期望的結果、\(y=0\) 則是我們不希望的結果。<br>勝算公式： \(odds = \frac{P(1| x_1, x_2,…,x_p)}{P(0| x_1, x_2,…,x_p)} = \frac{P(1| x_1, x_2,…,x_p)}{1 - P(1| x_1, x_2,…,x_p)}\)</li>
<li>那們如果我們想要比較兩種 \(x_1, x_2 , … , x_p \) 不一樣的狀態時分別定義 A、B，這時就是用到 Odds Rations 勝算比，我們是比較<strong>但 B 勝出一次時 A 會勝出幾次</strong><ul>
<li>因此勝算比公式： \(Odds Ratio = \frac{odd_A}{odd_B} = e^{\beta_i}\)</li>
<li>舉例<br>假如 A 狀態是 \(x_1 = 1, x_2 = 2\)、B 狀態為 \(x_1 = 2, x_2 = 1\)，那 \(odds_A = \frac{0.4}{0.6} = 0.67\)、\(odds_B = \frac{0.6}{0.4} = 1.5\)，那麼 \(\text{Odds Ratio} = \frac{0.67}{1.5} = 0.45\)，因此但 B 勝出一次時 A 會勝出 0.45 次。</li>
<li>資料參考：<a href="https://chungyizhen.medium.com/%E7%82%BA%E4%BB%80%E9%BA%BC%E9%83%BD%E7%94%A8-%E5%8B%9D%E7%AE%97%E6%AF%94-odds-ratio-or-%E8%80%8C%E4%B8%8D%E6%98%AF-%E7%9B%B8%E5%B0%8D%E9%A2%A8%E9%9A%AA-rr-%E5%91%A2-5c62fe84787c" target="_blank" rel="noopener">為什麼都用「勝算比」odds ratio(OR) 而不是「相對風險」 (RR)呢？ by Kevin Tseng</a></li>
</ul>
</li>
</ul>
<h3 id="舉例：根據先前西門公司的舉例，我們想要知道有用信用卡進行消費會比沒有用信用卡消費的人的勝算比"><a href="#舉例：根據先前西門公司的舉例，我們想要知道有用信用卡進行消費會比沒有用信用卡消費的人的勝算比" class="headerlink" title="舉例：根據先前西門公司的舉例，我們想要知道有用信用卡進行消費會比沒有用信用卡消費的人的勝算比"></a>舉例：<a href="#舉例：根據先前西門公司的舉例，我們想知道整體顯著性測試是否拒絕-H-0-，如果沒有，那我們要找出哪個自變數沒有拒絕-H-0">根據先前西門公司的舉例</a>，我們想要知道有用信用卡進行消費會比沒有用信用卡消費的人的勝算比</h3><blockquote>
<p>答案如下：<br><img src="https://drive.google.com/u/2/uc?id=1GL20uZeUo3_oZc9GWZPssXplMvh7u84s&export=download" alt=""></p>
</blockquote>
]]></content>
      <categories>
        <category>北科上課筆記</category>
        <category>統計 statistics</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>統計學筆記</tag>
        <tag>北科大二下統計學筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>統計學(一) 筆記 - 第三章A</title>
    <url>/2020/10/05/statistics/statistics-ch3A/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊與財金管理系大二上統計學重點整理<br><font color="#dd0000">並非所有人都適用，部分對我而言稍加容易的內容並不會寫在此內。</font><br><strong>這是觀看影片心得後的筆記，老師上課可能不太適用會忘記抄到</strong></p>
</blockquote>
<a id="more"></a>

<h2 id="3A-介紹-Descriptive-Statistics-Numerical-Measures-數值方式"><a href="#3A-介紹-Descriptive-Statistics-Numerical-Measures-數值方式" class="headerlink" title="3A 介紹 - Descriptive Statistics: Numerical Measures(數值方式)"></a>3A 介紹 - Descriptive Statistics: Numerical Measures(數值方式)</h2><p>敘述統計。</p>
<h4 id="名詞解釋"><a href="#名詞解釋" class="headerlink" title="名詞解釋"></a>名詞解釋</h4><p>sample statistics 從資料中找出的某些資料<br>population parameters 母體參數，從母體的資料取得<br>point estimator 點估計量</p>
<h4 id="Measures-of-Location-位置量數如何"><a href="#Measures-of-Location-位置量數如何" class="headerlink" title="Measures of Location 位置量數如何"></a>Measures of Location 位置量數如何</h4><ul>
<li><p>mean 平均數<br>  平均數為資料中央量數，如果是樣本平均數則符號為 \(\bar{x}\)，母體平均數用 \(μ\)</p>
<blockquote>
<p><img src="/images/statistics-ch3A/1.PNG" alt=""></p>
</blockquote>
<p>  但如果有極端值時，平均數不適用。</p>
<ul>
<li>trimmed mean<br>刪掉極端值的平均數，常用方法，將最小 \(5\% \) 與最大 \(5\% \)去掉後算平均數。</li>
<li>標準差會變小</li>
</ul>
</li>
<li><p>median 中位數<br>  如果資料裡有極端值時試用 median，<del>例如白鳥麗次、中川圭一</del>。<br>  如果資料量是偶數就將最中間兩個數字加起來除以二</p>
</li>
<li><p>mode 眾數<br>  眾數不一定只有一個，可以有很多的</p>
</li>
<li><p>Weighted Mean 加權平均數<br>  根據重要性來加權重，例如根據學分數來判斷權重<br>  加權平均公式</p>
<blockquote>
<p><img src="/images/statistics-ch3A/2.PNG" alt=""><br><img src="/images/statistics-ch3A/3.PNG" alt=""></p>
</blockquote>
</li>
<li><p>Geometric Mean 幾何平均數<br>算法</p>
<blockquote>
<p><img src="/images/statistics-ch3A/4.PNG" alt=""></p>
</blockquote>
</li>
</ul>
<p>通常用在算財務報表成長率</p>
<p>舉例:</p>
<blockquote>
<p><img src="/images/statistics-ch3A/5.PNG" alt=""></p>
</blockquote>
<ul>
<li><p>Percentiles 百分位數<br>通常用第 p 的百分位數表示，至少有 p percent 比你差，其他比你好。<br>公式:\(L_{p} = (p/100)(n+1)\)<br>如果出來的數值是有小數點則將左右兩邊數字相減乘以小數位數即可</p>
</li>
<li><p>Quartiles 四分位數<br>用百分位數表示就是分成 25% , 50% , 75% 來區分公式一樣用百分位數公式，如果出來的數值有小數點也是如此。</p>
</li>
</ul>
<h3 id="Measures-of-Variability-變異程度"><a href="#Measures-of-Variability-變異程度" class="headerlink" title="Measures of Variability 變異程度"></a>Measures of Variability 變異程度</h3><ul>
<li><p>Range<br>\( \text{Range} = \text{Largest Value} - \text{Smallest Value} \)，<strong>對極端值敏感</strong></p>
</li>
<li><p>Interquartile Range (四分位距)<br>用 75% 的值與 25% 的值設為範圍，<strong>對極端值不敏感</strong></p>
</li>
<li><p>Variance (變異數)<br>數字大代表變異大，數字小代表變異小。公式如下：</p>
<blockquote>
<p><img src="/images/statistics-ch3A/6.PNG" alt=""></p>
</blockquote>
<ul>
<li>Degrees of Freedom 自由度 縮寫 df<br>如果是等比數列或是等差數列自由度為零。<br>樣本變數  \(n-1\)<br>母體變數  \(n\)<blockquote>
<p><img src="/images/statistics-ch3A/7.PNG" alt=""></p>
</blockquote>
</li>
</ul>
</li>
<li><p>Standard Deviation 標準差<br>標準差越小離散程度越小，標準差越大離散程度越大<br>把變異數開根號，所以值一定為正</p>
<blockquote>
<p><img src="/images/statistics-ch3A/8.PNG" alt=""></p>
</blockquote>
</li>
<li><p>Coefficient of Variation (變異系數)<br>標準差相較於平均數差距多大</p>
<blockquote>
<p><img src="/images/statistics-ch3A/9.PNG" alt=""></p>
</blockquote>
</li>
<li><p>Mean Absolute error 平均絕對誤差 MAE<br>數字越大代表離平均數遠，如果不是就離平均數近。公式如下</p>
<blockquote>
<p><img src="/images/statistics-ch3A/11.PNG" alt=""></p>
</blockquote>
</li>
</ul>
<h4 id="統整練習"><a href="#統整練習" class="headerlink" title="統整練習"></a>統整練習</h4><blockquote>
<p><img src="/images/statistics-ch3A/10.PNG" alt=""></p>
</blockquote>
]]></content>
      <categories>
        <category>北科上課筆記</category>
        <category>統計 statistics</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>統計學筆記</tag>
        <tag>北科大二上統計學筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>統計學(一) 筆記 - 第五章 離散機率分配(Discrete Probability Distributions)</title>
    <url>/2020/11/04/statistics/statistics-ch5/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊與財金管理系大二上統計學重點整理<br><font color="#dd0000">並非所有人都適用，部分對我而言稍加容易的內容並不會寫在此內。</font><br><strong>這是觀看影片心得後的筆記，老師上課可能不太適用會忘記抄到</strong></p>
</blockquote>
<a id="more"></a>

<h2 id="Random-Variables-隨機變數"><a href="#Random-Variables-隨機變數" class="headerlink" title="Random Variables 隨機變數"></a>Random Variables 隨機變數</h2><h3 id="使用哪一個機率分配的用法教學"><a href="#使用哪一個機率分配的用法教學" class="headerlink" title="使用哪一個機率分配的用法教學"></a>使用哪一個機率分配的用法教學</h3><p>離散均勻 發生n次 則每一次的機率就是1/n<br>二項         N次試驗中成功的次數<br>負二項     N次試驗中r次成功的次數<br>幾何         在第一次成功的次數<br>卜瓦松     在特定的空間內發生的次數<br>超幾何     N次試驗中成功的機率(但取後不放回)</p>
<p>隨機變數共有三種，如下圖：</p>
<h3 id="Discrete-Random-Variable-離散隨機變數"><a href="#Discrete-Random-Variable-離散隨機變數" class="headerlink" title="Discrete Random Variable 離散隨機變數"></a>Discrete Random Variable 離散隨機變數</h3><ul>
<li>Finite Number of Values<br>在已知的集合中隨機抽出的元素。</li>
<li>Infinite Sequence of Values<br>在<strong>無限</strong>的集合中隨機抽出的元素，此集合大小為<strong>Infinite</strong>。</li>
</ul>
<h3 id="Continuous-Random-Variable-連續隨機變數"><a href="#Continuous-Random-Variable-連續隨機變數" class="headerlink" title="Continuous Random Variable 連續隨機變數"></a>Continuous Random Variable 連續隨機變數</h3><ul>
<li>元素是取區間，類似此概念 \([a,b]\)</li>
<li>或數值無法一一列舉，例如關於小數點的實驗</li>
</ul>
<h3 id="Discrete-Probability-Distributions-離散機率"><a href="#Discrete-Probability-Distributions-離散機率" class="headerlink" title="Discrete Probability Distributions 離散機率"></a>Discrete Probability Distributions 離散機率</h3><ul>
<li>用指派來指派每一個元素的機率</li>
<li>用<strong>公式</strong>推出，且要符合此公式 \(f(x) \geq 0\) and \( \sum_{}^{} f(x) = 1 \)</li>
</ul>
<h4 id="Expected-Value-期望值"><a href="#Expected-Value-期望值" class="headerlink" title="Expected Value 期望值"></a>Expected Value 期望值</h4><p>期望值不一定是集中中的元素，通常時多次實驗結果將其加權平均，平均的結果即是期望值。<br>期望值公式如下：</p>
<blockquote>
<p><img src="/images/statistics-ch5/2.PNG" alt=""></p>
</blockquote>
<h4 id="Variance-and-Standard-Deviation-變異程度與標準差"><a href="#Variance-and-Standard-Deviation-變異程度與標準差" class="headerlink" title="Variance and Standard Deviation 變異程度與標準差"></a>Variance and Standard Deviation 變異程度與標準差</h4><p>變異數公式如下：</p>
<blockquote>
<p><img src="/images/statistics-ch5/3.PNG" alt=""></p>
</blockquote>
<p>再將變異程度開根號即是標準差，圖片說明如下：</p>
<blockquote>
<p><img src="/images/statistics-ch5/4.PNG" alt=""></p>
</blockquote>
<h4 id="Discrete-Uniform-Probability-Distribution-離散均勻分配"><a href="#Discrete-Uniform-Probability-Distribution-離散均勻分配" class="headerlink" title="Discrete Uniform Probability Distribution 離散均勻分配"></a>Discrete Uniform Probability Distribution 離散均勻分配</h4><p>表示他的每一種實驗結果機率分配都一樣</p>
<h3 id="Bivariate-Distributions-二元分配"><a href="#Bivariate-Distributions-二元分配" class="headerlink" title="Bivariate Distributions 二元分配"></a>Bivariate Distributions 二元分配</h3><p>用兩種實驗，來找出他們的關係。</p>
<p>這兩次實驗我用 x,y 來代稱，先算出 x 的變異數與期望值，再算出 y 的變異數與期望值。</p>
<p>用圖片進行解釋，圖片說明如下：</p>
<blockquote>
<p><img src="/images/statistics-ch5/5.PNG" alt=""></p>
</blockquote>
<p>其中的 Covariance(共變異數) 怎麼算呢？</p>
<blockquote>
<p><img src="/images/statistics-ch5/6.PNG" alt=""></p>
</blockquote>
<p>透過範例投資組合結果如下表：</p>
<blockquote>
<p><img src="/images/statistics-ch5/7.PNG" alt=""></p>
</blockquote>
<p><strong>通常共變異數比變異數更重要</strong></p>
<h3 id="Binomial-Probability-Distribution-二項機率分配"><a href="#Binomial-Probability-Distribution-二項機率分配" class="headerlink" title="Binomial Probability Distribution 二項機率分配"></a>Binomial Probability Distribution 二項機率分配</h3><ul>
<li>包含 n 次試驗，這裡用 X 表示成功、Y 表示失敗</li>
<li>實驗結果不會因為時間而改變</li>
<li>每次的試驗是獨立的</li>
</ul>
<p>公式如下：</p>
<blockquote>
<p><img src="/images/statistics-ch5/10.PNG" alt=""></p>
</blockquote>
<p>舉例實驗如下：</p>
<blockquote>
<p><img src="/images/statistics-ch5/8.PNG" alt=""><br><img src="/images/statistics-ch5/9.PNG" alt=""><br><img src="/images/statistics-ch5/11.PNG" alt=""><br><img src="/images/statistics-ch5/12.PNG" alt=""><br><img src="/images/statistics-ch5/13.PNG" alt=""></p>
</blockquote>
<h3 id="Negative-Binomial-Probability-Distribution-負二項機率分配"><a href="#Negative-Binomial-Probability-Distribution-負二項機率分配" class="headerlink" title="Negative Binomial Probability Distribution 負二項機率分配"></a>Negative Binomial Probability Distribution 負二項機率分配</h3><ul>
<li>此實驗包括 n 次相同試驗</li>
<li>實驗獨立</li>
<li>只有成功與失敗</li>
<li>通常是找出在第 r 次時，失敗與成功的機率與多少</li>
</ul>
<p>公式如下：</p>
<blockquote>
<p><img src="/images/statistics-ch5/14.PNG" alt=""></p>
</blockquote>
<p>假設我們要找出可以兩次的正面實驗機率，圖表如下：<br>注意：你可能會有一個疑問是應該擲越多次機率越高阿？假設在第二次就擲成功時，那就是在第二次成功，往上的每次都不會紀錄</p>
<blockquote>
<p><img src="/images/statistics-ch5/15.PNG" alt=""><br><img src="/images/statistics-ch5/16.PNG" alt=""></p>
</blockquote>
<h3 id="Geometric-Probability-Distribution-幾何機率分配"><a href="#Geometric-Probability-Distribution-幾何機率分配" class="headerlink" title="Geometric Probability Distribution 幾何機率分配"></a>Geometric Probability Distribution 幾何機率分配</h3><ul>
<li>此實驗包括 n 次相同試驗</li>
<li>實驗獨立</li>
<li>只有成功與失敗</li>
<li>找出<strong>第一次成功</strong>的機率分配</li>
</ul>
<p>公式如下：</p>
<blockquote>
<p><img src="/images/statistics-ch5/17.PNG" alt=""></p>
</blockquote>
<p>舉例如下：</p>
<blockquote>
<p><img src="/images/statistics-ch5/18.PNG" alt=""><br><img src="/images/statistics-ch5/19.PNG" alt=""></p>
</blockquote>
<h4 id="統整負二項機率分配-and-幾何機率分配"><a href="#統整負二項機率分配-and-幾何機率分配" class="headerlink" title="統整負二項機率分配 and 幾何機率分配"></a>統整負二項機率分配 and 幾何機率分配</h4><blockquote>
<p><img src="/images/statistics-ch5/20.PNG" alt=""></p>
</blockquote>
<h3 id="Poisson-Probability-Distribution-卜瓦松機率分配"><a href="#Poisson-Probability-Distribution-卜瓦松機率分配" class="headerlink" title="Poisson Probability Distribution 卜瓦松機率分配"></a>Poisson Probability Distribution 卜瓦松機率分配</h3><p>在一個時段內找出有 x 個一樣結果的機率為和，例如在一個期間有多少車子通過高速公路收費站</p>
<h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ul>
<li>任一個長度區間兩個發生事件的機率相同</li>
<li>在各個區間發生的事件都是獨立</li>
</ul>
<p>公式如下：</p>
<blockquote>
<p><img src="/images/statistics-ch5/21.PNG" alt=""></p>
</blockquote>
<h4 id="舉例："><a href="#舉例：" class="headerlink" title="舉例："></a>舉例：</h4><p>在 30 分鐘來 4 個病人的機率是多少，且平均一小時會來 6 個病人</p>
<blockquote>
<p><img src="/images/statistics-ch5/22.PNG" alt=""></p>
</blockquote>
<h3 id="Hypergeometric-Probability-Distribution-超幾何機率分配"><a href="#Hypergeometric-Probability-Distribution-超幾何機率分配" class="headerlink" title="Hypergeometric Probability Distribution 超幾何機率分配"></a>Hypergeometric Probability Distribution 超幾何機率分配</h3><p>在 n 個試驗中成功的機率。</p>
<ul>
<li>實驗並不獨立</li>
<li>只要做完一個實驗就會影響到其他機率</li>
</ul>
<p>公式如下：</p>
<blockquote>
<p><img src="/images/statistics-ch5/23.PNG" alt=""><br><img src="/images/statistics-ch5/24.PNG" alt=""></p>
</blockquote>
<h4 id="舉例：-1"><a href="#舉例：-1" class="headerlink" title="舉例："></a>舉例：</h4><blockquote>
<p><img src="/images/statistics-ch5/25.PNG" alt=""><br><img src="/images/statistics-ch5/26.PNG" alt=""></p>
</blockquote>
]]></content>
      <categories>
        <category>北科上課筆記</category>
        <category>統計 statistics</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>統計學筆記</tag>
        <tag>北科大二上統計學筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>統計學(一) 筆記 - 第六章 均勻機率分配(Continuous Probability Distributions)</title>
    <url>/2020/11/23/statistics/statistics-ch6/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊與財金管理系大二上統計學重點整理<br><font color="#dd0000">並非所有人都適用，部分對我而言稍加容易的內容並不會寫在此內。</font><br><strong>這是觀看影片心得後的筆記，老師上課可能不太適用會忘記抄到</strong></p>
</blockquote>
<a id="more"></a>
<h1 id="Continuous-Probability-Distributions"><a href="#Continuous-Probability-Distributions" class="headerlink" title="Continuous Probability Distributions"></a>Continuous Probability Distributions</h1><p>給定一個區間，在此發生的機率是多少，下圖則是透過圖片介紹：</p>
<blockquote>
<p><img src="/images/statistics-ch6/1.PNG" alt=""></p>
</blockquote>
<h3 id="Continuous-Random-Variable"><a href="#Continuous-Random-Variable" class="headerlink" title="Continuous Random Variable"></a>Continuous Random Variable</h3><p>公式如下：</p>
<blockquote>
<p><img src="/images/statistics-ch6/2.PNG" alt=""></p>
</blockquote>
<h2 id="Uniform-Probability-Distribution-均勻機率分配"><a href="#Uniform-Probability-Distribution-均勻機率分配" class="headerlink" title="Uniform Probability Distribution (均勻機率分配)"></a>Uniform Probability Distribution (均勻機率分配)</h2><p>公式如下：</p>
<blockquote>
<p><img src="/images/statistics-ch6/3.PNG" alt=""><br><img src="/images/statistics-ch6/4.PNG" alt=""></p>
</blockquote>
<h3 id="Area"><a href="#Area" class="headerlink" title="Area"></a>Area</h3><p>我們再算均勻機率分配時要注意，如果不是區間的時機率值都是 0，因為沒有面積 </p>
<h2 id="Normal-Probability-Distribution-常態機率分配"><a href="#Normal-Probability-Distribution-常態機率分配" class="headerlink" title="Normal Probability Distribution (常態機率分配)"></a>Normal Probability Distribution (常態機率分配)</h2><p>最重要的一種機率分配之一，舉例可以用在身高、考試成績。</p>
<h3 id="Normal-Probability-Density-Function"><a href="#Normal-Probability-Density-Function" class="headerlink" title="Normal Probability Density Function"></a>Normal Probability Density Function</h3><p>公式如下：</p>
<blockquote>
<p><img src="/images/statistics-ch6/5.PNG" alt=""></p>
</blockquote>
<h3 id="Characterustucs-特點"><a href="#Characterustucs-特點" class="headerlink" title="Characterustucs (特點)"></a>Characterustucs (特點)</h3><ul>
<li>從中間切開後，左右機率各 0.5</li>
<li>68.26% 會落在正負一個標準差</li>
<li>95.44% 會落在正負兩個標準差 </li>
<li>99.72% 或落在正負三個標準差<h3 id="Standard-Normal-Probability-Distribution-標準常態隨機變數"><a href="#Standard-Normal-Probability-Distribution-標準常態隨機變數" class="headerlink" title="Standard Normal Probability Distribution (標準常態隨機變數)"></a>Standard Normal Probability Distribution (標準常態隨機變數)</h3>當平均數等於 0、標準差等於 1 時才符合條件，此時 z 表示標準常態隨機分配。</li>
</ul>
<p>公式如下：</p>
<blockquote>
<p><img src="/images/statistics-ch6/6.PNG" alt=""></p>
</blockquote>
<h2 id="Normal-Approximation-of-Binomial-Probabilities-二項機率的常態分配近似值"><a href="#Normal-Approximation-of-Binomial-Probabilities-二項機率的常態分配近似值" class="headerlink" title="Normal Approximation of Binomial Probabilities (二項機率的常態分配近似值)"></a>Normal Approximation of Binomial Probabilities (二項機率的常態分配近似值)</h2><p>其實本身是<strong>離散時機率分配</strong>，但在實驗次數增加後，要計算相對不容易就可以使用二項機率的常態分配近似值，條件如下：</p>
<ul>
<li>\(成功機率(n) * 實驗次數(p) \geq 5  \) </li>
<li>\(實驗次數(n) * (1-成功機率(p)) \geq 5 \)</li>
<li>因為二項機率通常是找某一個特定值，但是 ormal Approximation of Binomial Probabilities 則是區間，於是就盡量用，與此 \( (特定值 + 特定值前一個元素) / 2 \) and \( (特定值 + 特定值後一個元素) / 2 \)，設定為區間即可。</li>
</ul>
<p>公式如下：</p>
<blockquote>
<p><img src="/images/statistics-ch6/7.PNG" alt=""></p>
</blockquote>
<h2 id="Expeonential-Probability-Distribution-指數機率分配"><a href="#Expeonential-Probability-Distribution-指數機率分配" class="headerlink" title="Expeonential Probability Distribution (指數機率分配)"></a>Expeonential Probability Distribution (指數機率分配)</h2><p>獨立隨機事件發生的時間間隔，舉例：完成一個實驗的時間之類等。</p>
<p>公式如下:</p>
<blockquote>
<p><img src="/images/statistics-ch6/8.PNG" alt=""></p>
</blockquote>
<h3 id="Relationship-between-the-Poisson-and-Exponential-Distributions-指數機率分配與卜瓦松的關係"><a href="#Relationship-between-the-Poisson-and-Exponential-Distributions-指數機率分配與卜瓦松的關係" class="headerlink" title="Relationship between the Poisson and Exponential Distributions (指數機率分配與卜瓦松的關係)"></a>Relationship between the Poisson and Exponential Distributions (指數機率分配與卜瓦松的關係)</h3><ul>
<li>兩個方法的 x 互為<strong>倒數關係</strong><blockquote>
<p><img src="/images/statistics-ch6/9.PNG" alt=""></p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>北科上課筆記</category>
        <category>統計 statistics</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>統計學筆記</tag>
        <tag>北科大二上統計學筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>統計學(一) 筆記 - 第七章 抽樣與抽樣分配(Sampling and Sampling Distributions)</title>
    <url>/2020/12/01/statistics/statistics-ch7/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊與財金管理系大二上統計學重點整理<br><font color="#dd0000">並非所有人都適用，部分對我而言稍加容易的內容並不會寫在此內。</font><br><strong>這是觀看影片心得後的筆記，老師上課可能不太適用會忘記抄到</strong></p>
</blockquote>
<a id="more"></a>

<h2 id="名詞介紹"><a href="#名詞介紹" class="headerlink" title="名詞介紹"></a>名詞介紹</h2><ul>
<li>element<br>我們收集到的每一個資料</li>
<li>population 母體<br>我們資料整體，樣本(sample)則是資料裡面的其中一個集合</li>
<li>target population (目標母體)<br>我們想要選擇的母體</li>
<li>sampled population 抽樣母體<br>我們抽樣的整體資料</li>
<li>frame 抽樣清單<br>從 sampled population 抽取的清單</li>
</ul>
<h2 id="Selecting-Sample-選擇樣本"><a href="#Selecting-Sample-選擇樣本" class="headerlink" title="Selecting Sample 選擇樣本"></a>Selecting Sample 選擇樣本</h2><h3 id="Sampling-from-a-Finite-Population-有限母體"><a href="#Sampling-from-a-Finite-Population-有限母體" class="headerlink" title="Sampling from a Finite Population (有限母體)"></a>Sampling from a Finite Population (有限母體)</h3><p>舉例，信用卡名單、倉庫存貨、公司股東。</p>
<ul>
<li>簡單隨機樣本<br>每一個元素被抽出的機率相同</li>
<li>sampling with replacement 歸還抽樣<br>抽完放回去</li>
<li>sampling without replacement 不歸還抽樣<br>抽完不放回去</li>
</ul>
<h3 id="Sampling-from-a-Infinite-Population-無限母體"><a href="#Sampling-from-a-Infinite-Population-無限母體" class="headerlink" title="Sampling from a Infinite Population (無限母體)"></a>Sampling from a Infinite Population (無限母體)</h3><p>在無限母體中沒有 frame，因為 frame 會等於無限。<br>舉例：銀行產生的交易，因為會不斷產生因此不確定性很高。</p>
<ul>
<li>random sample <ul>
<li>每一個元素都是從相同母題抽出來</li>
<li>每一個元素都是獨立，即抽完不放回</li>
</ul>
</li>
</ul>
<h2 id="Point-Estimation-點估計量"><a href="#Point-Estimation-點估計量" class="headerlink" title="Point Estimation 點估計量"></a>Point Estimation 點估計量</h2><p>推測母體參數中某個數值</p>
<ul>
<li>\( \bar{x} \) 的點估計量就是平均值</li>
<li>s 點估計量為母體標準差</li>
<li>\( \bar{p} \) 為母體比例 p 的點估計量</li>
</ul>
<h3 id="舉例-St-Andrew’s-College"><a href="#舉例-St-Andrew’s-College" class="headerlink" title="舉例 - St. Andrew’s College"></a>舉例 - St. Andrew’s College</h3><p>Recall that St. Andrew’s College received 900 applications from prospective students. The application form contains a variety of information including the individual’s Scholastic Aptitude Test (SAT) score and whether or not the individual desires on-campus housing.</p>
<p>回想一下，聖安德魯學院收到了來自潛在學生的900份申請。 申請表包含各種信息，包括個人的學業能力測驗（SAT）分數以及個人是否希望在校內住宿。</p>
<p>P.S. 這裡的資料是在影片前面的抽樣資料為虛擬且抽樣數為 30，因此數字看看就好</p>
<ul>
<li>20 為申請住宿的量</li>
<li>50520 為分數總合</li>
<li>210512 則是透過公式與原始資料得出</li>
</ul>
<blockquote>
<p><img src="/images/statistics-ch7/2.PNG" alt=""></p>
</blockquote>
<p>下面這張圖片則是透過<strong>完整原始資料</strong>來進行計算</p>
<blockquote>
<p><img src="/images/statistics-ch7/3.PNG" alt=""></p>
</blockquote>
<h4 id="比較："><a href="#比較：" class="headerlink" title="比較："></a>比較：</h4><blockquote>
<p><img src="/images/statistics-ch7/4.PNG" alt=""></p>
</blockquote>
<h2 id="Introduction-to-Sampling-Distributions-抽樣分配"><a href="#Introduction-to-Sampling-Distributions-抽樣分配" class="headerlink" title="Introduction to Sampling Distributions 抽樣分配"></a>Introduction to Sampling Distributions 抽樣分配</h2><p><strong>每一次的抽樣計算出來的值都有可能不一樣</strong>，因為選擇的樣本不同。</p>
<p>但透過抽樣分配的次數越多，根據抽樣分配的次數會發現圖形長得像常態分配，即越偏差母體標準差的抽樣分配機率越小，越靠近的越大。</p>
<h3 id="舉例-關於公司管理職"><a href="#舉例-關於公司管理職" class="headerlink" title="舉例 - 關於公司管理職"></a>舉例 - 關於公司管理職</h3><p>公司總共有 2500 位管理職(母體)，我們想要知道下面以下問題：</p>
<ul>
<li>母體的平均年薪</li>
<li>母體的年薪標準差</li>
<li>母體中有完成教育訓練的值(母體參數)</li>
</ul>
<h4 id="答案-透過點估計量"><a href="#答案-透過點估計量" class="headerlink" title="答案 - 透過點估計量"></a>答案 - 透過點估計量</h4><ul>
<li><p>抽樣資料如下，有 30 筆</p>
<blockquote>
<p><img src="/images/statistics-ch7/5.PNG" alt=""></p>
</blockquote>
</li>
<li><p>Point estimation</p>
<ul>
<li>\(\bar{x} = \frac{\Sigma X_i}{n} = \frac{1,554,420}{30} = 51,814 \)</li>
<li>\(s = \sqrt{\frac{\Sigma (X_i - \bar{x})^2 }{n-1}} = \sqrt{\frac{325,009,260}{29}} = 3348 \)</li>
<li>\(\bar{p} = \frac{x}{n} = \frac{19}{30} = 0.63 \)</li>
</ul>
</li>
<li><p>為甚麼樣本標準差分母是？ n-1 觀念說明</p>
<ul>
<li><a href="https://www.researchmfg.com/2016/07/sigma-n-1/" target="_blank" rel="noopener">為什麼統計的樣本標準差計算要除(n-1)而母體標準差則除n？ - 電子製造，工作狂人 </a></li>
<li><a href="https://mathcenter.ck.tp.edu.tw/Resources/Ctrl/ePaper/eArticleDetail.aspx?id=c4181f30-955f-4063-87ea-576b0f318c73" target="_blank" rel="noopener">淺談自由度 (樣本標準差公式中的分母為什麼要採用 n-1 ) - 教育部高中數學學科電子報</a></li>
</ul>
</li>
</ul>
<h4 id="比對-原始資料"><a href="#比對-原始資料" class="headerlink" title="比對 - 原始資料"></a>比對 - 原始資料</h4><blockquote>
<p><img src="/images/statistics-ch7/6.PNG" alt=""></p>
</blockquote>
<h2 id="Sampling-Distribution-of-bar-x"><a href="#Sampling-Distribution-of-bar-x" class="headerlink" title="Sampling Distribution of \(\bar{x} \)"></a>Sampling Distribution of \(\bar{x} \)</h2><p>就是要找出母體平均數。</p>
<ul>
<li>Expected Value of \(\bar{x} \)<br>公式為 \(E(\bar{x})=\mu \)，其中 \(\mu \) 為母體平均值</li>
<li>Standard Deviation of \(\bar{x} \) <ul>
<li>\(\sigma_{\bar{x}} \) 為<strong>樣本</strong>標準差，也稱為<strong>標準誤(standard error)</strong></li>
<li>\(\sigma \) 為<strong>母體</strong>標準差</li>
<li>\(n \) 為樣本大小</li>
<li>\(N \) 為母體大小</li>
<li>Finite Population 有限母體公式<ul>
<li>\(\sigma_x = \sqrt{\frac{N-n}{N-1}}(\frac{\sigma}{\sqrt{n}})\)</li>
<li>其中前項為校正因子(\(\sqrt{\frac{N-n}{N-1}}\))用來修正數值，但當 N 的數量趨近無限大時，校正因子幾乎會被視為零。</li>
<li>當 \(n/N \leq 0.05 \) 時，就可以使用無限母體公式會更好計算，校正因子也幾乎變為零</li>
<li>當 \(\frac{n}{N} &gt; 0.05 \) 時，\(\bar{x} \) 為常態分配</li>
</ul>
</li>
<li>Infinite Population 無限母體公式<br>\(\sigma_x = \frac{\sigma}{\sqrt{n}}\) 且 \(\bar{x} \) 為常態分配</li>
</ul>
</li>
<li>\(\bar{x} \) 服從常態分配有以下情況<ul>
<li>樣本資料大於等於 30 筆資料時</li>
<li>如果有高度偏態(skew)或是 outliers(離群值)太多時，只要樣本資料大於 50 筆也會是常態分配</li>
</ul>
</li>
<li>透過機率來說明 \(\bar{x} \) 有多靠近母體平均值</li>
</ul>
<h2 id="Central-Limit-Theorem-中央極限定理"><a href="#Central-Limit-Theorem-中央極限定理" class="headerlink" title="Central Limit Theorem (中央極限定理)"></a>Central Limit Theorem (中央極限定理)</h2><p>中央極限定理提出越是大量的樣本抽取數量其圖形會逐漸變成常態分佈的形狀</p>
<h3 id="透過圖形來證明"><a href="#透過圖形來證明" class="headerlink" title="透過圖形來證明"></a>透過圖形來證明</h3><ul>
<li>Population 2 的圖形通常稱為兔耳型圖圖</li>
</ul>
<blockquote>
<p><img src="/images/statistics-ch7/7.PNG" alt=""><br><img src="/images/statistics-ch7/8.PNG" alt=""></p>
</blockquote>
<p>我們透過上面的圖可以推出無論是什麼樣的圖都可以推出常態分布的樣本分配，只要樣本資料夠多</p>
<h3 id="舉例-我們想找出離母體平均數加減-10-分有多少數量，也就是我們想要找-1687-1707-間的母體數量"><a href="#舉例-我們想找出離母體平均數加減-10-分有多少數量，也就是我們想要找-1687-1707-間的母體數量" class="headerlink" title="舉例 - 我們想找出離母體平均數加減 10 分有多少數量，也就是我們想要找 1687 ~ 1707 間的母體數量"></a>舉例 - 我們想找出離母體平均數加減 10 分有多少數量，也就是我們想要找 1687 ~ 1707 間的母體數量</h3><p>我們在先前的舉例中算出 \(\sigma_x = \frac{\sigma}{\sqrt{n}} = \frac{87.4}{\sqrt{30}} = 15.96 \)</p>
<blockquote>
<p><img src="/images/statistics-ch7/9.PNG" alt=""></p>
</blockquote>
<p>現在我們先計算 z 值來轉換成標準常態機率分配，\(z = (1707 - 1697) / 15.96 = 0.63 \)，查表可以看到 z = 0.63 時機率為 0.7357，再來 \(z = (1687 - 1697) / 15.96 = -0.63 \)，查表可以得出 0.2643，兩個相減就等於 0.4714</p>
<h3 id="舉例-根據上面的例子，我們現在抽樣-100-樣本，我們想要找-1687-1707-間的母體數量"><a href="#舉例-根據上面的例子，我們現在抽樣-100-樣本，我們想要找-1687-1707-間的母體數量" class="headerlink" title="舉例 - 根據上面的例子，我們現在抽樣 100 樣本，我們想要找 1687 ~ 1707 間的母體數量"></a>舉例 - 根據上面的例子，我們現在抽樣 100 樣本，我們想要找 1687 ~ 1707 間的母體數量</h3><p>這時候 \(E(x)\) 不變，母體平均值還是 1697。</p>
<p>但因為我們的抽取樣本數量改變，因此標準差改變，透過標準差公式也就變成，\(\sigma_x = \sqrt{\frac{N-n}{N-1}}(\frac{\sigma}{\sqrt{n}}) = \frac{900-100}{900-1}(\frac{87.4}{\sqrt{100}}) = 0.9433(8.74) = 8.2\)</p>
<p>跟上一個舉例進行比較，可以得證當樣本數量變大時，會符合中央極限定理</p>
<blockquote>
<p><img src="/images/statistics-ch7/10.PNG" alt=""></p>
</blockquote>
<p>因為圖形不同，因此區間面積也不同需要再重新計算，當 n = 100 時，\(P(1687 \leq \bar{x} \leq 1707 ) = 0.7776\)</p>
<h2 id="Sampling-Distribution-of-bar-p"><a href="#Sampling-Distribution-of-bar-p" class="headerlink" title="Sampling Distribution of \(\bar{p} \)"></a>Sampling Distribution of \(\bar{p} \)</h2><p>透過抽取 n 個元素的隨機樣本，計算\(\bar{p} \)之後再推論 \(p\)。</p>
<ul>
<li>Expected Value of \(\bar{p} \)<br>公式為 \(E(\bar{p}) = p \)</li>
<li>Standard Deviation of \(\bar{p} \) <ul>
<li>\(\sigma_{\bar{p}} \) 為<strong>樣本</strong>標準差，也稱為<strong>標準誤(standard error)</strong></li>
<li>\(\sigma \) 為<strong>母體</strong>標準差</li>
<li>\(n \) 為樣本大小</li>
<li>\(N \) 為母體大小</li>
<li>當 \(np &gt; 5 \) 時，\(n(1-p) \geq 5 \) 為常態分配</li>
<li>Finite Population 有限母體公式<ul>
<li>\(\sigma_p = \sqrt{\frac{N-n}{N-1}}(\sqrt{\frac{p(1-p)}{n}})\)</li>
<li>其中前項為校正因子(\(\sqrt{\frac{N-n}{N-1}}\))用來修正數值，但當 N 的數量趨近無限大時，校正因子幾乎會被視為零。</li>
<li>當 \(n/N \leq 0.05 \) 時，就可以使用無限母體公式會更好計算，校正因子也幾乎變為零</li>
</ul>
</li>
<li>Infinite Population 無限母體公式<br>公式為 \(\sigma_p =(\sqrt{\frac{p(1-p)}{n}})\)</li>
</ul>
</li>
</ul>
<h3 id="舉例-有-72-的學生申請宿舍，我們抽樣-30-學生，想請問在此樣本中學生申請宿舍的在-72-加減-0-05-的機率是多少"><a href="#舉例-有-72-的學生申請宿舍，我們抽樣-30-學生，想請問在此樣本中學生申請宿舍的在-72-加減-0-05-的機率是多少" class="headerlink" title="舉例 - 有 72 % 的學生申請宿舍，我們抽樣 30 學生，想請問在此樣本中學生申請宿舍的在 72% 加減 0.05 的機率是多少"></a>舉例 - 有 72 % 的學生申請宿舍，我們抽樣 30 學生，想請問在此樣本中學生申請宿舍的在 72% 加減 0.05 的機率是多少</h3><p>我們先檢查是否有常態分配，n=30, p=0.72，因此 \(np = 30(0.72) = 21.6 \geq 5 \) and \(n(1-p) = 30(0.28) = 8.4 \geq 5 \)，都有大於 5，因此符合使用常態分配條件。</p>
<p>由於這裡我們並不確定母體有多少學生，因此是 Infinite Population，計算就是 \(\sigma_{\bar{p}} = \sqrt{\frac{0.72(1-0.72)}{30}} = 0.082\)</p>
<p>一樣先轉換成 z 值成為標準常態機率分配，\(z = (0.77-0.72)/0.082 =0.61\)，查表發現 \(0.61z = 0.7291 \)，再來查另外一個值 \(z = (0.67-0.72)/0.082 =-0.61\)，查表發現 \(-0.61z = 0.2709 \)，兩個相減就得出常態分配面積區間，答案為 0.4582。</p>
<p>因此在這樣本中有 \((0.67 * 30) \) ~ \( (0.77 * 30)\) 機率的學生要申請宿舍的機率為 0.4582。</p>
<h3 id="舉例-主管的抽樣分配，題目如下，想詢問抽樣值為平均值-pm-500-的機率為多少"><a href="#舉例-主管的抽樣分配，題目如下，想詢問抽樣值為平均值-pm-500-的機率為多少" class="headerlink" title="舉例 - 主管的抽樣分配，題目如下，想詢問抽樣值為平均值 \(\pm 500\) 的機率為多少"></a>舉例 - 主管的抽樣分配，題目如下，想詢問抽樣值為平均值 \(\pm 500\) 的機率為多少</h3><blockquote>
<p><img src="/images/statistics-ch7/11.PNG" alt=""></p>
</blockquote>
<p>也就是我們要找出 \(P(51300 \leq \bar{x} \leq 52300) \)，的機率是多少，如果用手算的話則需要用到 Z，\(z = \frac{51300-51800}{730.30} = -0.68 \)、\(z = \frac{52300-51800}{730.30} = 0.68 \)</p>
<p>\(P(51300 \leq \bar{x} \leq 52300) \\<br>= P(-0.68 \leq z \leq 0.68 ) \\<br>= P(z \leq 0.68 ) - P(z \leq -0.68 )  \\<br>= 0.7517 - 0.2484 = 0.5034 \)</p>
<h4 id="compare-between-n-30-and-n-100"><a href="#compare-between-n-30-and-n-100" class="headerlink" title="compare between n = 30 and n = 100"></a>compare between n = 30 and n = 100</h4><blockquote>
<p><img src="/images/statistics-ch7/12.PNG" alt=""><br>作法與先前相同，就不贅述</p>
</blockquote>
<h3 id="舉例-承上題，當抽樣數為-100-n-100-，抽樣主管有成功完成教育訓練的標準誤"><a href="#舉例-承上題，當抽樣數為-100-n-100-，抽樣主管有成功完成教育訓練的標準誤" class="headerlink" title="舉例 - 承上題，當抽樣數為 100 (n = 100)，抽樣主管有成功完成教育訓練的標準誤"></a>舉例 - 承上題，當抽樣數為 100 (n = 100)，抽樣主管有成功完成教育訓練的<strong>標準誤</strong></h3><p>旁邊的公式為答案。</p>
<blockquote>
<p><img src="/images/statistics-ch7/13.PNG" alt=""></p>
</blockquote>
<p>60 % 的人會完成員工訓練，因此期望值為 0.6，再來透過公式計算。<br>\(\sigma_{p} = \sqrt{\frac{p(1-p)}{n}} = \sqrt{\frac{0.6(1-0.6)}{30}} = 0.894 \)</p>
<h3 id="舉例-承上題，抽樣主管有成功完成教育訓練的值在期望至-pm-0-05"><a href="#舉例-承上題，抽樣主管有成功完成教育訓練的值在期望至-pm-0-05" class="headerlink" title="舉例 - 承上題，抽樣主管有成功完成教育訓練的值在期望至 \(\pm 0.05 \)"></a>舉例 - 承上題，抽樣主管有成功完成教育訓練的值在期望至 \(\pm 0.05 \)</h3><p>先透過 Z 轉換，之後即可，題目大同小異，透過圖片附上答案。</p>
<blockquote>
<p><img src="/images/statistics-ch7/14.PNG" alt=""></p>
</blockquote>
<h2 id="Propertires-of-Point-Estimators-點估計量的特性"><a href="#Propertires-of-Point-Estimators-點估計量的特性" class="headerlink" title="Propertires of Point Estimators 點估計量的特性"></a>Propertires of Point Estimators 點估計量的特性</h2><ul>
<li>點估計量的符號為 \(\hat{\theta}\)</li>
<li>Unbiased 不偏性<ul>
<li>期望值等於要估計的母體參數  </li>
<li>圖舉例，右邊是 Biased 有偏誤<blockquote>
<p><img src="/images/statistics-ch7/15.PNG" alt=""></p>
</blockquote>
</li>
</ul>
</li>
<li>Efficiency 有效性<ul>
<li>在有兩個抽樣分配的 \(\hat{\theta}\)，且兩個的\(\hat{\theta}\) 位置一樣時，則先取標準差(x 軸)比較少的值</li>
<li>圖舉例 <blockquote>
<p><img src="/images/statistics-ch7/16.PNG" alt=""></p>
</blockquote>
</li>
</ul>
</li>
<li>Consistency 一致性<ul>
<li>當樣本數(n)變大時，標準差則會越來越小，當樣本數越大時則優先使用此點估計量</li>
</ul>
</li>
</ul>
<h2 id="Other-Sampling-Methods-其他抽樣方法"><a href="#Other-Sampling-Methods-其他抽樣方法" class="headerlink" title="Other Sampling Methods 其他抽樣方法"></a>Other Sampling Methods 其他抽樣方法</h2><ul>
<li>機率抽樣<br>每一個母體元素都有一個特定的機率被選為抽樣樣本</li>
<li>非機率抽樣<br>由於我們沒辦法預估每一個母體元素機率為多少，因此稱為<strong>非機率抽樣</strong>。</li>
<li>找出最適合的抽樣方法<strong>最重要</strong>。</li>
</ul>
<h3 id="機率抽樣-Stratified-Random-Sampling-分層隨機抽樣"><a href="#機率抽樣-Stratified-Random-Sampling-分層隨機抽樣" class="headerlink" title="機率抽樣 - Stratified Random Sampling 分層隨機抽樣"></a>機率抽樣 - Stratified Random Sampling 分層隨機抽樣</h3><ul>
<li>strata<br>將母體分成好幾組</li>
<li>母體的每一個元素都必須被使用分組，且只能使用一次</li>
<li>每一組的元素同質性越高越好<br>可以根據年齡、工作部門、產業來區分 </li>
<li>有符合上述條件時，精準度會集高且抽樣資料不須太多</li>
<li>圖表<blockquote>
<p><img src="/images/statistics-ch7/17.PNG" alt=""></p>
</blockquote>
</li>
</ul>
<h3 id="機率抽樣-Cluster-Sampling-叢式-集群抽樣"><a href="#機率抽樣-Cluster-Sampling-叢式-集群抽樣" class="headerlink" title="機率抽樣 - Cluster Sampling 叢式/集群抽樣"></a>機率抽樣 - Cluster Sampling 叢式/集群抽樣</h3><ul>
<li>clusters<br>將母體分組，每組<strong>同質性極低</strong>，小生態圈</li>
<li>接下來抽出幾群，那些就是我們的抽樣資料</li>
<li>Sampling<br>透過市區、學校來抽樣</li>
<li>Advantage<br>節省成本</li>
<li>Disadvantage<br>抽樣資料比分成抽樣的資料需要更大些，才符合真實性</li>
<li>圖表<blockquote>
<p><img src="/images/statistics-ch7/18.PNG" alt=""></p>
</blockquote>
</li>
</ul>
<h3 id="機率抽樣-Systematic-Sampling-系統抽樣"><a href="#機率抽樣-Systematic-Sampling-系統抽樣" class="headerlink" title="機率抽樣 - Systematic Sampling 系統抽樣"></a>機率抽樣 - Systematic Sampling 系統抽樣</h3><ul>
<li>先將母體資料打亂後再進行編號</li>
<li>從母體(N)抽出樣本(n)，那我們就是 \(y = N/n\) 為我們要抽出的元素量(y)</li>
<li>再透過母體資料編號，<code>for(i = 0 ; i&lt;= y ; i++)</code>，找出我們的抽樣元素</li>
<li>Advantage<br>簡單</li>
</ul>
<h3 id="非機率抽樣-Convenience-Sampling-便利抽樣"><a href="#非機率抽樣-Convenience-Sampling-便利抽樣" class="headerlink" title="非機率抽樣 - Convenience Sampling 便利抽樣"></a>非機率抽樣 - Convenience Sampling 便利抽樣</h3><ul>
<li>透過非機率抽樣</li>
<li>Sampling<br>如發傳單，因為沒辦法得知收到傳單與沒收到傳單的機率。</li>
<li>Advantage<br>抽樣很方便</li>
<li>Disadvantage<br>沒辦法很精準的代表母體</li>
</ul>
<h3 id="非機率抽樣-Judgment-Sampling-判斷抽樣"><a href="#非機率抽樣-Judgment-Sampling-判斷抽樣" class="headerlink" title="非機率抽樣 - Judgment Sampling 判斷抽樣"></a>非機率抽樣 - Judgment Sampling 判斷抽樣</h3><ul>
<li>透過個人的知識去推斷出母體那些值可以被參考</li>
<li>例如記者想詢問立委對環保的意見<br>記者可以找出對比較熟悉環保的立委進行尋問</li>
<li>Advantage<br><del>可以造謠，</del>比較簡單。</li>
<li>Disadvantage<br>很看記者素質</li>
</ul>
]]></content>
      <categories>
        <category>北科上課筆記</category>
        <category>統計 statistics</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>統計學筆記</tag>
        <tag>北科大二上統計學筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>統計學(二) 筆記 - 第九章 假說檢定(hypothesis testing)</title>
    <url>/2021/02/27/statistics/statistics-ch9/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊與財金管理系大二下統計學重點整理<br><font color="#dd0000">並非所有人都適用，部分對我而言稍加容易的內容並不會寫在此內。</font><br><strong>這是觀看影片心得後的筆記，老師上課可能不太適用會忘記抄到</strong></p>
</blockquote>
<a id="more"></a>

<h2 id="假說檢定-hypothesis-testing-介紹"><a href="#假說檢定-hypothesis-testing-介紹" class="headerlink" title="假說檢定(hypothesis testing) 介紹"></a>假說檢定(hypothesis testing) 介紹</h2><p>決定一個數值透過母體參數產生的是否可以信任。</p>
<p>信任就是對立假設，反之虛無假設。</p>
<ul>
<li>虛無假設 null hypothesis<br>表示這個人是亂猜的，就是虛無假設，透過 \(H_0\) 表示。</li>
<li><strong>拒絕</strong>虛無假設 reject null hypothesis<br>通常拒絕虛無假設以機率來進行計算，常見的有 \(1 \%\)、\(5 \%\)、\(10 \%\)，也就是當虛無假設機率低於一定值時就是對立假設。</li>
<li>對立假設 alternative hypothesis<br>透過 boolean 來想虛無假設是 false，對立假設就是 true，透過 \(H_1 \) or \(H_A \) 表示。</li>
</ul>
<h2 id="在-Probability-Distribution-APP-上計算-z-值的方法"><a href="#在-Probability-Distribution-APP-上計算-z-值的方法" class="headerlink" title="在 Probability Distribution APP 上計算 z 值的方法"></a>在 Probability Distribution APP 上計算 z 值的方法</h2><ul>
<li>在母體平均值已知的情況下打開 APP，點 <code>normal</code><ul>
<li>算出 z 後，將 z 的值放入 x</li>
<li>決定左尾、右尾、雙尾，在紅色格子的 \(P(X&gt;x)\) 這邊可以選擇，第一個是右尾、第二左尾、第三雙尾</li>
<li>圖片說明<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1mfPzfLCmLPsrfex4bcFUsSf-8g0tQpnj&export=download" alt=""></p>
</blockquote>
</li>
</ul>
</li>
<li>在母體平均值已知的情況下打開 APP，點 <code>t</code><ul>
<li>算出 z 後，將 z 的值放入 x</li>
<li>t 為樣本數量 -1</li>
<li>決定左尾、右尾、雙尾，在紅色格子的 \(P(X&gt;x)\) 這邊可以選擇，第一個是右尾、第二左尾、第三雙尾</li>
<li>圖片說明<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1VkQccUO68-RR_LnC2FDKlUZVEbMnUKTu&export=download" alt=""></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="如何決定虛無假設與對立假設"><a href="#如何決定虛無假設與對立假設" class="headerlink" title="如何決定虛無假設與對立假設"></a>如何決定虛無假設與對立假設</h3><ul>
<li>對立假設就是我們研究論點<br>也就是決定好甚麼是 TRUE 甚麼是 FALSE，通常對立假設就是我們研究論點，透過對立假設來證明我們的論點是對的，先設定 \(H_1\) 在設定 \(H_0 \)。<ul>
<li>舉例：九點上課會不會讓學生有精神？<ul>
<li>\(H_1 \) 九點上課比較好</li>
<li>\(H_0\)  九點上課並不會讓學生比較好。</li>
</ul>
</li>
</ul>
</li>
<li>用假設檢定挑戰別人的論點<br>此時我們的目標是讓別人的論點 false，以否定別人論點為目標，因此先設定 \(H_0\) 在設定 \(H_1 \)<ul>
<li>舉例：當前政策內車道禁行機車會比較好嗎?<ul>
<li>\(H_0 \) 不會比較好</li>
<li>\(H_1\)  是好的沒錯</li>
</ul>
</li>
</ul>
</li>
<li>統整，使用方法<ul>
<li>利用樣本統計量驗證的假設 \(H_1\)</li>
<li>他人主張 \(H_0\)</li>
<li>會造成負面結果的 \(H_0\)，正面放 \(H_1\)</li>
<li>反面主張 \(H_0\)，</li>
<li>通常正面放 \(H_1\)，反面 \(H_0\)</li>
</ul>
</li>
</ul>
<h1 id="母體平均數假設檢定-Summary-of-Forms-for-Null-and-Alternative-Hypotheses-about-a-Population-Mean"><a href="#母體平均數假設檢定-Summary-of-Forms-for-Null-and-Alternative-Hypotheses-about-a-Population-Mean" class="headerlink" title="母體平均數假設檢定 Summary of Forms for Null and Alternative Hypotheses about a Population Mean"></a>母體平均數假設檢定 Summary of Forms for Null and Alternative Hypotheses about a Population Mean</h1><p>使用此檢定時，有一定義<strong>如果母體平均數相等時，則永遠都表示虛無假設</strong>，因為如果驗證一樣時，那就並不是我們研究的論點所支持，還是他人的論點相同，無法推翻。</p>
<p>在此檢定中用來判斷假設的標準通常是者幾種</p>
<ul>
<li>Lower-tail 左尾<ul>
<li>\(H_0 = \mu \geq u_0 \) </li>
<li>\(H_1 = \mu &lt; u_0 \) </li>
</ul>
</li>
<li>Upper-tail 右尾<ul>
<li>\(H_0 = \mu \leq u_0 \) </li>
<li>\(H_1 = \mu &lt; u_0 \) </li>
</ul>
</li>
<li>Two-tailed 兩尾<ul>
<li>\(H_0 = \mu = u_0 \) </li>
<li>\(H_1 = \mu != u_0 \) </li>
</ul>
</li>
</ul>
<h3 id="舉例：某一城市有-20-個醫療人員，平均只需要-12-分鐘就可以服務，決定虛無假設與對立假設，如果沒有達到-12-分鐘就要進行改善。"><a href="#舉例：某一城市有-20-個醫療人員，平均只需要-12-分鐘就可以服務，決定虛無假設與對立假設，如果沒有達到-12-分鐘就要進行改善。" class="headerlink" title="舉例：某一城市有 20 個醫療人員，平均只需要 12 分鐘就可以服務，決定虛無假設與對立假設，如果沒有達到 12 分鐘就要進行改善。"></a>舉例：某一城市有 20 個醫療人員，平均只需要 12 分鐘就可以服務，決定虛無假設與對立假設，如果沒有達到 12 分鐘就要進行改善。</h3><p>這邊我們要判斷是否達到目標，沒有則要進行改善，因此這邊我們認為是需要改善所以對立假設就會是 \(H_1 = \mu &gt; 12 \)<br>虛無假設就是 \(H_0 = \mu \leq 12 \)<br>對立假設就是 \(H_1 = \mu &gt; 12 \)</p>
<p><strong>要特別注意我們的檢定資料是使用母體還是抽測樣本</strong></p>
<h2 id="型一錯誤-Type1-Error-or-顯著性檢定-significance-tests"><a href="#型一錯誤-Type1-Error-or-顯著性檢定-significance-tests" class="headerlink" title="型一錯誤 Type1 Error or 顯著性檢定 significance tests"></a>型一錯誤 Type1 Error or 顯著性檢定 significance tests</h2><p>我們認為 \(H_0\) 是錯誤的，但其實是對的。</p>
<p>透過樣本資料推出的假設檢定是對的，但是樣本資料明顯與母體資料偏差。</p>
<p>型一錯誤 Type1 Error 也稱為 顯著性檢定 significance tests </p>
<h2 id="型二錯誤-Type2-Error"><a href="#型二錯誤-Type2-Error" class="headerlink" title="型二錯誤 Type2 Error"></a>型二錯誤 Type2 Error</h2><p>我們認為 \(H_0\) 是對的，但其實並不是正確的。</p>
<p>由於這種錯誤通常沒有辦法發現，需要等到再次驗證時才有機率發現(類似於 bug)，因此為了避免一開始說錯的風險，所以會用比較保守的說法，我們<strong>不反對 \(H_0\)</strong>，而不是我們<strong>相信 \(H_0\)</strong>。</p>
<p>通常在沒有足夠信心時使用。</p>
<blockquote>
<p>統整<br><img src="https://drive.google.com/u/2/uc?id=1c6CvvbRpAqi86sUR5N9NyXmAWnK761bQ&export=download" alt=""></p>
</blockquote>
<h2 id="p-Value-Approach-to-One-Tailed-Hypothesis-Testing-p-值法單尾假設檢定"><a href="#p-Value-Approach-to-One-Tailed-Hypothesis-Testing-p-值法單尾假設檢定" class="headerlink" title="p-Value Approach to One-Tailed Hypothesis Testing p 值法單尾假設檢定"></a>p-Value Approach to One-Tailed Hypothesis Testing p 值法單尾假設檢定</h2><p>p 本身的意思是 probability 也就是要找機率(可能性)，根據樣本結果可以支持虛無假設的機率是多少？</p>
<p>如果 p-value 越小且小於顯著姓測試 \(\alpha \)，我們就可以拒絕虛無假設。</p>
<p>因此公式就是：拒絕 \(H_0 \) if the \(p-value \leq \alpha \)</p>
<p>透過標準差 z，我們去設定顯著性測試的 \(z_a\)，與結果的 z 來判斷是否支持虛無假設</p>
<h3 id="Lower-Tailed-Test-About-a-Population-Mean-左尾-p-value-檢定法"><a href="#Lower-Tailed-Test-About-a-Population-Mean-左尾-p-value-檢定法" class="headerlink" title="Lower-Tailed Test About a Population Mean 左尾 p-value 檢定法"></a>Lower-Tailed Test About a Population Mean 左尾 p-value 檢定法</h3><p>透過常態分配的方法，只要我們的 z 值小於顯著性測試的 \(z_a\) 值時我們就可以拒絕此虛無假設</p>
<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1LvvtPA1gAe1rcFKeKQHMAFEvBaur1zqb&export=download" alt=""></p>
</blockquote>
<h3 id="Upper-Tailed-Test-About-a-Population-Mean-右尾-p-value-檢定法"><a href="#Upper-Tailed-Test-About-a-Population-Mean-右尾-p-value-檢定法" class="headerlink" title="Upper-Tailed Test About a Population Mean 右尾 p-value 檢定法"></a>Upper-Tailed Test About a Population Mean 右尾 p-value 檢定法</h3><p>與上方類似，只要我們的 z 值<strong>大於</strong>顯著性測試的 \(z_a\) 值時我們就可以拒絕此虛無假設</p>
<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1DAOfWZqgz2C3kZv2M8p9vCVSDCB111RM&export=download" alt=""></p>
</blockquote>
<h2 id="Critical-Value-Approach-to-One-Tailed-Hypothesis-Testing-臨界值檢定法"><a href="#Critical-Value-Approach-to-One-Tailed-Hypothesis-Testing-臨界值檢定法" class="headerlink" title="Critical Value Approach to One-Tailed Hypothesis Testing 臨界值檢定法"></a>Critical Value Approach to One-Tailed Hypothesis Testing 臨界值檢定法</h2><p>一樣透過標準常態機率分配的 \(z_a\) 值來判斷，設定一個面積，只要我們的檢測值落在 \(z_a\) 面積上就可以拒絕此假設</p>
<ul>
<li>Lower tail: Reject \(H_0\) if \(z \leq - z_a\)</li>
<li>Upper tail: Reject \(H_0\) if \(z \geq - z_a\)</li>
</ul>
<h3 id="Lower-Tailed-Test-About-a-Population-Mean-左尾臨界值檢定法"><a href="#Lower-Tailed-Test-About-a-Population-Mean-左尾臨界值檢定法" class="headerlink" title="Lower-Tailed Test About a Population Mean 左尾臨界值檢定法"></a>Lower-Tailed Test About a Population Mean 左尾臨界值檢定法</h3><p>設定 \(z_a\) 的值，以下圖來看如果檢測結果 z 值落在<strong>藍色面積</strong>，就拒絕，沒有就不拒絕</p>
<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1RJeKWXMcuanfhh9cb42JgEiYNJZXVcyP&export=download" alt=""></p>
</blockquote>
<h3 id="Upper-Tailed-Test-About-a-Population-Mean-右尾臨界值檢定法"><a href="#Upper-Tailed-Test-About-a-Population-Mean-右尾臨界值檢定法" class="headerlink" title="Upper-Tailed Test About a Population Mean 右尾臨界值檢定法"></a>Upper-Tailed Test About a Population Mean 右尾臨界值檢定法</h3><p>設定 \(z_a\) 的值，以下圖來看如果檢測結果 z 值落在<strong>藍色面積</strong>，就拒絕，沒有就不拒絕</p>
<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1cUqgMdoQJl0sQCdCqx711Fm1auBfc5ND&export=download" alt=""></p>
</blockquote>
<h2 id="Steps-of-Hypoththesis-Testing-假設檢定的步驟，母體平均數已知的情況"><a href="#Steps-of-Hypoththesis-Testing-假設檢定的步驟，母體平均數已知的情況" class="headerlink" title="Steps of Hypoththesis Testing 假設檢定的步驟，母體平均數已知的情況"></a>Steps of Hypoththesis Testing 假設檢定的步驟，母體平均數已知的情況</h2><ul>
<li>建立虛無假設與對立假設</li>
<li>設定顯著性測試</li>
<li>收集樣本資料，計算 z</li>
<li>使用方法<ul>
<li>p-Value Approach<ul>
<li>計算 p-value</li>
<li>根據 p-value 判斷是否拒絕虛無假設</li>
</ul>
</li>
<li>Critical Value Approach<ul>
<li>設定顯著型測試的區間</li>
<li>根據樣本的 z 值判斷是否落在拒絕區間</li>
</ul>
</li>
</ul>
</li>
<li>透過這兩種方法檢測答案都必須相同</li>
</ul>
<h3 id="舉例-抽取-40-筆樣本資料，平均回應緊急時間為-13-25-min，母體標準差為-3-2，做一假設檢定，0-05-的顯著性測試，能不能在-12-分鐘以內回應緊急事件，不行則進行改善"><a href="#舉例-抽取-40-筆樣本資料，平均回應緊急時間為-13-25-min，母體標準差為-3-2，做一假設檢定，0-05-的顯著性測試，能不能在-12-分鐘以內回應緊急事件，不行則進行改善" class="headerlink" title="舉例 - 抽取 40 筆樣本資料，平均回應緊急時間為 13.25 min，母體標準差為 3.2，做一假設檢定，0.05 的顯著性測試，能不能在 12 分鐘以內回應緊急事件，不行則進行改善"></a>舉例 - 抽取 40 筆樣本資料，平均回應緊急時間為 13.25 min，母體標準差為 3.2，做一假設檢定，0.05 的顯著性測試，能不能在 12 分鐘以內回應緊急事件，不行則進行改善</h3><ul>
<li>建立虛無假設與對立假設<ul>
<li>\(H_0: \mu \leq 12 \)</li>
<li>\(H_1: \mu &gt; 12\)，由於我們的觀點是想要進行改善，因此設定 \(H_1: \mu &gt; 12\)</li>
</ul>
</li>
<li>設定顯著性測試 0.5</li>
<li>收集樣本，計算 z<br>\(z = \frac{\bar{x} - \mu_0}{\sigma / \sqrt{n}} = \frac{13.25 - 12}{3.2 / \sqrt{40}} = 2.47\)</li>
<li>使用方法<ul>
<li>p-Value Approach<ul>
<li>計算 p-value<br>\(z = 2.47\)，算出 0.9932，\(p-value = 1 - 0.9932 = 0.0068\)</li>
<li>根據 p-value 判斷是否拒絕虛無假設<br>\(\alpha = 0.05 \geq 0.0068 = p-value\)，因此拒絕 \(H_0\)。因此我們沒有辦法在 12 分鐘內緊急回應</li>
</ul>
</li>
<li>Critical Value Approach<ul>
<li>設定顯著型測試的區間<br>\(\alpha = 0.05, z_{0.05} = 1.645\)，因此拒絕 \(H_0 \geq 1.645\)</li>
<li>根據樣本的 z 值判斷是否落在拒絕區間<br>\(z = 2.47 &gt; 1.645 \)落在拒絕區間，因此拒絕 \(H_0\)。因此我們沒有辦法在 12 分鐘內緊急回應</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Two-Tailed-Hypothesis-雙尾假設檢定"><a href="#Two-Tailed-Hypothesis-雙尾假設檢定" class="headerlink" title="Two-Tailed Hypothesis 雙尾假設檢定"></a>Two-Tailed Hypothesis 雙尾假設檢定</h2><h3 id="p-Value-Approach-to-Two-Tailed-Hypothesis-Testing-p-值法雙尾假設檢定"><a href="#p-Value-Approach-to-Two-Tailed-Hypothesis-Testing-p-值法雙尾假設檢定" class="headerlink" title="p-Value Approach to Two-Tailed Hypothesis Testing p 值法雙尾假設檢定"></a>p-Value Approach to Two-Tailed Hypothesis Testing p 值法雙尾假設檢定</h3><ul>
<li>計算標準常態分配的 z 值</li>
<li>計算 z 的機率</li>
<li>將機率<strong>乘二</strong></li>
<li>Reject \(H_0\) if the \(p-value \leq \alpha\)</li>
</ul>
<h3 id="Critival-Value-Approach-to-Two-Tailed-Hypothesis-Testing-臨界值法雙尾假設檢定"><a href="#Critival-Value-Approach-to-Two-Tailed-Hypothesis-Testing-臨界值法雙尾假設檢定" class="headerlink" title="Critival Value Approach to Two-Tailed Hypothesis Testing 臨界值法雙尾假設檢定"></a>Critival Value Approach to Two-Tailed Hypothesis Testing 臨界值法雙尾假設檢定</h3><p>透過標準常態機率分配找出 \(z_{a/2}\) 的面積</p>
<p>因此 Reject \(H_0\) if the \(z \leq -z_{a/2}\) or \(z \geq z_{a/2}\)</p>
<h3 id="舉例-牙膏平均重量是-6oz，進行假設檢定，如果大於或小於-6oz-就改善，抽-30-隻牙膏為樣本資料，樣本平均值是-6-1oz，標準差是-0-2oz，顯著性測試為-0-03"><a href="#舉例-牙膏平均重量是-6oz，進行假設檢定，如果大於或小於-6oz-就改善，抽-30-隻牙膏為樣本資料，樣本平均值是-6-1oz，標準差是-0-2oz，顯著性測試為-0-03" class="headerlink" title="舉例: 牙膏平均重量是 6oz，進行假設檢定，如果大於或小於 6oz 就改善，抽 30 隻牙膏為樣本資料，樣本平均值是 6.1oz，標準差是 0.2oz，顯著性測試為 0.03"></a>舉例: 牙膏平均重量是 6oz，進行假設檢定，如果大於或小於 6oz 就改善，抽 30 隻牙膏為樣本資料，樣本平均值是 6.1oz，標準差是 0.2oz，顯著性測試為 0.03</h3><ul>
<li>建立虛無假設與對立假設<ul>
<li>\(H_0: \mu = 6\)</li>
<li>\(H_1: \mu &lt;&gt; 6 \)</li>
</ul>
</li>
<li>設定顯著性測試 0.03</li>
<li>收集樣本，計算 z<br>\(z = \frac{\bar{x} - \mu_0}{\sigma / \sqrt{n}} = \frac{6.1 - 6}{0.2 / \sqrt{30}} = 2.74\)</li>
<li>使用方法<ul>
<li>p-Value Approach<ul>
<li>計算 p-value<br>\(z = 2.74\)，算出 0.9969，\(p-value = 2(1 - 0.9932) = 0.0062\)</li>
<li>根據 p-value 判斷是否拒絕虛無假設<br>\(\alpha = 0.03 \geq 0.0062 = p-value\)，因此拒絕 \(H_0\)。因此需要進行改善</li>
<li>用圖進行解釋<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1T22SDb3Q8g6nCS9H1-_3hUb1b1uRQ7lJ&export=download" alt=""></p>
</blockquote>
</li>
</ul>
</li>
<li>Critical Value Approach<ul>
<li>設定顯著型測試的區間<br>\(\alpha / 2 = 0.03 / 2 = 0.015 , z_{0.015} = 2.17\)，因此拒絕 \(H_0 \geq 2.17\)</li>
<li>根據樣本的 z 值判斷是否落在拒絕區間<br>\(z = 2.47 &gt; 2.17 \)落在拒絕區間，因此拒絕 \(H_0\)。因此我們沒有辦法在 12 分鐘內緊急回應</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Confidence-Interval-Approach-to-Two-Tailed-Hypothesis-Testing-信賴區間法雙尾假設檢定"><a href="#Confidence-Interval-Approach-to-Two-Tailed-Hypothesis-Testing-信賴區間法雙尾假設檢定" class="headerlink" title="Confidence Interval Approach to Two-Tailed Hypothesis Testing 信賴區間法雙尾假設檢定"></a>Confidence Interval Approach to Two-Tailed Hypothesis Testing 信賴區間法雙尾假設檢定</h3><p>計算信賴區間的公式為 \(\bar{x} \pm z_{a/2} \frac{\sigma}{\sqrt{n}}\)，如果假設檢定的值在信賴區間內時我們就<strong>不拒絕零 (to reject)</strong>，但如果在<strong>等於的情況時必須拒絕</strong>。</p>
<h4 id="透過剛剛舉例算信賴區間法雙尾假設檢定法"><a href="#透過剛剛舉例算信賴區間法雙尾假設檢定法" class="headerlink" title="透過剛剛舉例算信賴區間法雙尾假設檢定法"></a>透過剛剛舉例算信賴區間法雙尾假設檢定法</h4><p>顯著性測試為 0.03，因此有百分之 97 的信賴區間，因此 \(\mu \) 要是 \(\bar{x} \pm z_{a/2} \frac{\sigma}{\sqrt{n}} = 6.1 \pm 2.17(0.2 / \sqrt{30}) = 6.1 \pm 0.07924\)，也就是 6.02076 to 6.17924，因此 \( \mu_0 = 6 \) 不再此區間，因此拒絕 \(H_0\)。</p>
<h2 id="Steps-of-Hypoththesis-Testing-假設檢定的步驟，母體平均數未知的情況"><a href="#Steps-of-Hypoththesis-Testing-假設檢定的步驟，母體平均數未知的情況" class="headerlink" title="Steps of Hypoththesis Testing 假設檢定的步驟，母體平均數未知的情況"></a>Steps of Hypoththesis Testing 假設檢定的步驟，母體平均數未知的情況</h2><p>這時候就需要用到 t 了XD，公式為 \(t = \frac{\bar{x} - \mu_0}{s / \sqrt{n}}\)，其中 \(n - 1\) 就是自由度</p>
<ul>
<li>p-Value Approach<br>Reject \(H_0\) if \(\alpha \geq p-value\)</li>
<li>Critical Value Approach<ul>
<li>\(H_0: \mu \geq \mu_0 \) Reject \(H_0\) if \(t \leq -t_{a}\)</li>
<li>\(H_0: \mu \leq \mu_0 \) Reject \(H_0\) if \(t \geq t_{a}\)</li>
<li>\(H_0: \mu = \mu_0\) Reject \(H_0\) if \(t \leq -t_{a/2} \ or t \geq t_{a/2} \ \)</li>
</ul>
</li>
<li>p-Value and the t Distribution<br>如果用統計書的附錄算 t 值，大多不太精準，因此盡量使用軟體上的來計算。</li>
</ul>
<h3 id="舉例：高速公路常常會超速，因此我們要設測速照相機，測速的速度我們想假設為-65，進行假設檢定，在-64-筆的樣本資料，平均速度是-66-2，標準差-4-2，顯著性測試為-0-05"><a href="#舉例：高速公路常常會超速，因此我們要設測速照相機，測速的速度我們想假設為-65，進行假設檢定，在-64-筆的樣本資料，平均速度是-66-2，標準差-4-2，顯著性測試為-0-05" class="headerlink" title="舉例：高速公路常常會超速，因此我們要設測速照相機，測速的速度我們想假設為 65，進行假設檢定，在 64 筆的樣本資料，平均速度是 66.2，標準差 4.2，顯著性測試為 0.05"></a>舉例：高速公路常常會超速，因此我們要設測速照相機，測速的速度我們想假設為 65，進行假設檢定，在 64 筆的樣本資料，平均速度是 66.2，標準差 4.2，顯著性測試為 0.05</h3><ul>
<li>建立虛無假設與對立假設<ul>
<li>\(H_0: \mu \leq 65 \)</li>
<li>\(H_1: \mu &gt; 65 \)</li>
</ul>
</li>
<li>設定顯著性測試 0.05</li>
<li>收集樣本，計算 z<br>\(z = \frac{\bar{x} - \mu_0}{\sigma / \sqrt{n}} = \frac{66.2 - 65}{4.2 / \sqrt{64}} = 2.286\)<ul>
<li>p-Value Approach<ul>
<li>計算 p-value<br>\(t = 2.286\)，算出 0.01281</li>
<li>根據 p-value 判斷是否拒絕虛無假設<br>\(\alpha = 0.05 \geq 0.01281 = p-value\)，因此拒絕 \(H_0\)。因此大部分這邊人都會超速，可以設測速照相</li>
</ul>
</li>
<li>Critical Value Approach<ul>
<li>設定顯著型測試的區間<br>\(\alpha  = 0.05 , d.f. = 64 - 1 = 63, t_{0.005} = 1.669\)，因此 reject \(h_0\) if \(t \geq 1.669\)</li>
<li>根據樣本的 z 值判斷是否落在拒絕區間<br>\(t = 2.286 &gt; 1.669 \)落在拒絕區間，因此拒絕 \(H_0\)。因此大部分這邊人都會超速，可以設測速照相</li>
</ul>
</li>
</ul>
</li>
<li>圖片解釋<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1lbc1gj5E5u0ZGL90IrvbfTe7TELQkAc0&export=download" alt=""></p>
</blockquote>
</li>
</ul>
<h1 id="A-Summary-of-Forms-for-Null-and-Alternaitve-Hypotheses-About-a-Population-Proportion-母體參數假設檢定"><a href="#A-Summary-of-Forms-for-Null-and-Alternaitve-Hypotheses-About-a-Population-Proportion-母體參數假設檢定" class="headerlink" title="A Summary of Forms for Null and Alternaitve Hypotheses About a Population Proportion 母體參數假設檢定"></a>A Summary of Forms for Null and Alternaitve Hypotheses About a Population Proportion 母體參數假設檢定</h1><ul>
<li>等號永遠都在 \(H_0\)</li>
<li>以 p 表示母體比例</li>
<li>\(p_0\) 就是虛無假設</li>
<li>Lower-tail 左尾<ul>
<li>\(H_0 = p \geq p_0 \) </li>
<li>\(H_1 = p &lt; p_0 \) </li>
</ul>
</li>
<li>Upper-tail 右尾<ul>
<li>\(H_0 = p \leq p_0 \) </li>
<li>\(H_1 = p &lt; p_0 \) </li>
</ul>
</li>
<li>Two-tailed 兩尾<ul>
<li>\(H_0 = p = p_0 \) </li>
<li>\(H_1 = p != p_0 \) </li>
</ul>
</li>
</ul>
<h2 id="計算會用到的數值"><a href="#計算會用到的數值" class="headerlink" title="計算會用到的數值"></a>計算會用到的數值</h2><ul>
<li>z 的公式為 \(z = \frac{\bar{p} - p_0}{\sigma_\bar{p}}\)，用到的 p 為假設檢定所設定 \(H_0\)的 p 值</li>
<li>\(\sigma_\bar{p}\) 為 \(\sigma_\bar{p} = \frac{\sqrt{p_0(1-p_0)}}{n}\)</li>
<li>其中在使用 z 公式時，\(np \geq 5\) and \(n(1-p) \geq 5\)</li>
</ul>
<h2 id="P-Value-Approach-and-Critical-Value-Approach-Rejection-Rule-p-值法與臨界值法拒絕法則"><a href="#P-Value-Approach-and-Critical-Value-Approach-Rejection-Rule-p-值法與臨界值法拒絕法則" class="headerlink" title="P-Value Approach and Critical Value Approach Rejection Rule p 值法與臨界值法拒絕法則"></a>P-Value Approach and Critical Value Approach Rejection Rule p 值法與臨界值法拒絕法則</h2><ul>
<li>p-value<br>Reject \( H_0\) if \(p-value \leq \alpha\)</li>
<li>Critical Value<ul>
<li>\(H_0: p \leq p_0\) Reject \(H_0 \) if \(z \leq z_a\)</li>
<li>\(H_0: p \geq p_0\) Reject \(H_0 \) if \(z \geq z_a\)</li>
<li>\(H_0: p = p_0\) Reject \(H_0 \) if \(z \leq -z_{a/2} \ or \ z \geq z_{a/2}\)</li>
</ul>
</li>
</ul>
<h3 id="舉例-在新年期間中，國道車禍有-500-人死亡，其中有-50-是酒駕造成，樣本資料中-120-筆有-67-筆是酒駕，使用假設檢定，並且顯著性測試為-0-05，我們想要推翻其推論"><a href="#舉例-在新年期間中，國道車禍有-500-人死亡，其中有-50-是酒駕造成，樣本資料中-120-筆有-67-筆是酒駕，使用假設檢定，並且顯著性測試為-0-05，我們想要推翻其推論" class="headerlink" title="舉例: 在新年期間中，國道車禍有 500 人死亡，其中有 50 % 是酒駕造成，樣本資料中 120 筆有 67 筆是酒駕，使用假設檢定，並且顯著性測試為 0.05，我們想要推翻其推論"></a>舉例: 在新年期間中，國道車禍有 500 人死亡，其中有 50 % 是酒駕造成，樣本資料中 120 筆有 67 筆是酒駕，使用假設檢定，並且顯著性測試為 0.05，我們想要推翻其推論</h3><ul>
<li>設定假設<ul>
<li>\(H_0: p = 0.5 \)</li>
<li>\(H_1: p != 0.5 \)</li>
</ul>
</li>
<li>設定顯著性測試 0.05</li>
<li>收集樣本，計算 z and \(\sigma_\bar{p}\)，<strong>其中下面的 \(p_0\) 就是 \(H_0: p\)，也就是 0.5</strong><ul>
<li>\(\sigma_{\bar{p}} = \sqrt{\frac{p_0 (1-p_0)}{n}} = \frac{0.5(1-0.5)}{120} = 0.045644\)，注意是要用 \(H_0\) 的值</li>
<li>\(z = \frac{\bar{p} - p_0 }{\sigma_\bar{p}} = \frac{(67/120)-0.5}{0.045644} = 1.28\)</li>
</ul>
</li>
<li>兩方法計算<ul>
<li>p-Value Approach<ul>
<li>\(z = 1.28, p = 0.8997\)，\(1-p-value = 2(1 - 0.8997) = 0.2006\)</li>
<li>因為 \(p-value = 0.2006 &gt; \alpha = 0.05\)，因此我們不能拒絕 \(H_0\)</li>
</ul>
</li>
<li>Critical Value Approach<ul>
<li>\(a / 2 = 0.05/2 = 0.025， z_{0.025} = 1.96\)，因此 Reject \(H_0\) if \(z \leq -1.96 \ or \ z \geq 1.96 \)</li>
<li>1.278 介於 -1.96 與 1.96 之間，因此我們不能拒絕 \(H_0\)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="Hypothesis-Testing-and-Decision-Making-假設檢定的決策"><a href="#Hypothesis-Testing-and-Decision-Making-假設檢定的決策" class="headerlink" title="Hypothesis Testing and Decision Making 假設檢定的決策"></a>Hypothesis Testing and Decision Making 假設檢定的決策</h1><ul>
<li>如果答案是拒絕 \(H_0\)，就必須修改決策</li>
<li>如果答案是不拒絕 \(H_0\)，就不用修改決策</li>
</ul>
<h1 id="Calculating-the-Probability-of-a-Type-2-Error-in-Hypothesis-Tests-About-a-Population-Mean-母體平均值計算-Type-2-Error"><a href="#Calculating-the-Probability-of-a-Type-2-Error-in-Hypothesis-Tests-About-a-Population-Mean-母體平均值計算-Type-2-Error" class="headerlink" title="Calculating the Probability of a Type 2 Error in Hypothesis Tests About a Population Mean 母體平均值計算 Type 2 Error"></a>Calculating the Probability of a Type 2 Error in Hypothesis Tests About a Population Mean 母體平均值計算 Type 2 Error</h1><ul>
<li>列出 \(H_0\) and \(H_1\)</li>
<li>使用 Critical Value Approach 與顯著型測試，確認是否符合拒絕法則(Reject \(H_0\))</li>
<li>找出 z 在甚麼情況會接受 \(H_0\)，我們將此定義為 \(\bar{x}\)</li>
<li>給定 \(\mu \) 是大於顯著型測試的範圍，</li>
</ul>
<h2 id="舉例-EMS-隨機抽取-40-筆資料，平均數-13-25-分鐘，母體標準差是-3-2-分鐘，顯著性測試為-0-05，我們想知道緊急服務抵達會不會小於-12-分鐘，不會就改善。"><a href="#舉例-EMS-隨機抽取-40-筆資料，平均數-13-25-分鐘，母體標準差是-3-2-分鐘，顯著性測試為-0-05，我們想知道緊急服務抵達會不會小於-12-分鐘，不會就改善。" class="headerlink" title="舉例: EMS 隨機抽取 40 筆資料，平均數 13.25 分鐘，母體標準差是 3.2 分鐘，顯著性測試為 0.05，我們想知道緊急服務抵達會不會小於 12 分鐘，不會就改善。"></a>舉例: EMS 隨機抽取 40 筆資料，平均數 13.25 分鐘，母體標準差是 3.2 分鐘，顯著性測試為 0.05，我們想知道緊急服務抵達會不會小於 12 分鐘，不會就改善。</h2><ul>
<li>設定假設<ul>
<li>\(H_0: mu \leq  12 \)</li>
<li>\(H_1: \mu &gt; 12 \)</li>
</ul>
</li>
<li>Reject rule is: Reject \(H_0\) if \(z \geq 1.645\)</li>
<li>計算樣本平均值拒絕的區域<ul>
<li>\(z = \frac{\bar{x}-12}{3.2 / \sqrt{40}} \geq 1.645\)</li>
<li>\(\bar{x} \geq 12 + 1.645 (\frac{3.2}{\sqrt{40}}) = 12.8323\)</li>
</ul>
</li>
<li>因此我們接受 \(H_0\) 必須在 \(\bar{x} &lt; 12.8323\)</li>
<li>計算 Type2 Error  <ul>
<li>我們先假設一個值，此值要是符合 \(H_1\)，這裡假設為 14，因此 \(\mu = 14\)</li>
<li>計算樣本標準差 \(\sigma_\bar{x} = \frac{3.2}{\sqrt{40}} = 0.5060 \)</li>
<li>計算 z 值為 \(z = \frac{\bar{x} - \mu}{\sigma / \sqrt{n}} = \frac{12.8323 - 14}{3.2 / \sqrt{40}} = -2.31 \) </li>
<li>再來我們找出 \(z = -2.31 \) 的機率為 0.0104，就是 \(\beta \)</li>
<li>圖片解釋<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1qhP93dQujI_jGQcsgiCWLs32KJ7-VZZS&export=download" alt=""></p>
</blockquote>
</li>
<li>算出每個 value of mu 的 beta 係數，其中的 \(1-\beta\) 的值就是正確率，如果離 \(H_0\) 越近有很高機率會做出錯誤判斷<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1TUD1SA4j3AjLAsmtuM2GnlHBQytttqp3&export=download" alt=""></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="Power-of-the-Test-假設檢定正確率"><a href="#Power-of-the-Test-假設檢定正確率" class="headerlink" title="Power of the Test 假設檢定正確率"></a>Power of the Test 假設檢定正確率</h2><p>就是剛剛舉例中的 \(1-\beta\)，越大表示我們的正確率越高。</p>
<p>透過剛剛的例子畫成圖表表示 </p>
<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1-keA5OCOB_h-O_IAWFYsVuXbIWlw-k2i&export=download" alt=""></p>
</blockquote>
<h2 id="在一個單尾-左尾-舉例"><a href="#在一個單尾-左尾-舉例" class="headerlink" title="在一個單尾(左尾)舉例"></a>在一個單尾(左尾)舉例</h2><ul>
<li>題目一些資訊，\( \sigma = 12, n = 36, \mu = 120\)</li>
<li>設定假設<ul>
<li>\(H_0: \mu \geq  120 \)</li>
<li>\(H_1: \mu &lt; 120 \)</li>
</ul>
</li>
<li>Reject rule is: Reject \(H_0\) if \(z \leq -1.645\)</li>
<li>計算樣本平均值拒絕的區域<ul>
<li>\(z = \frac{\bar{x}-120}{12 / \sqrt{36}} \leq -1.645\)</li>
<li>\(\bar{x} \leq  - 1.645 (\frac{12}{\sqrt{36}} ) = 116.71\)</li>
</ul>
</li>
<li>因此我們接受 \(H_0\) 必須在 \(\bar{x} &gt; 116.71\)</li>
<li>計算 Type2 Error  <ul>
<li>我們先假設一個值，此值要是符合 \(H_1\)，這裡假設為 112，因此 \(\mu = 112\)</li>
<li>計算樣本標準差 \(\sigma_\bar{x} = \frac{12}{\sqrt{36}} = 2 \)</li>
<li>計算 z 值為 \(z = \frac{\bar{x} - \mu}{\sigma / \sqrt{n}} = \frac{116.71 - 112}{12 / \sqrt{36}} = 2.36 \) </li>
<li>再來我們找出 \(z = 2.36 \) 的機率為 0.0091，就是 \(\beta \)</li>
<li>圖片解釋<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=19fmdAfQql-zh8nnhPE6A5gk7xoMO6x9h&export=download" alt=""></p>
</blockquote>
</li>
<li>算出每個 value of mu 的 beta 係數，其中的 \(1-\beta\) 的值就是正確率，如果離 \(H_0\) 越近有很高機率會做出錯誤判斷<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1Jb0c1osleRhpEvtxNWV7MnzOIhKFdTdY&export=download" alt=""></p>
</blockquote>
</li>
<li>畫成圖表則是<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1cWn1hDljGIflcVOT1gyuB9YZZ1P06TV0&export=download" alt=""></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h1 id="Determining-the-Sample-Suze-for-a-Hypothesis-Test-About-a-Population-Mean-確認樣本大小來進行母體平均值假設測試"><a href="#Determining-the-Sample-Suze-for-a-Hypothesis-Test-About-a-Population-Mean-確認樣本大小來進行母體平均值假設測試" class="headerlink" title="Determining the Sample Suze for a Hypothesis Test About a Population Mean 確認樣本大小來進行母體平均值假設測試"></a>Determining the Sample Suze for a Hypothesis Test About a Population Mean 確認樣本大小來進行母體平均值假設測試</h1><p>我們先設定好型一誤差與型二誤差後，找出適合的樣本大小數量來進行假設測試 </p>
<p>用圖來進行說明，我們說些重點</p>
<ul>
<li>在這張圖中，是右尾檢定，因為 \(\mu &gt; \mu_0\)</li>
<li>左邊是 Type1 Error，右邊是 Type2 Error，c 是臨界值，兩張圖藍色的部分就是誤差區</li>
<li>因此我們可以知道兩張圖的 C 是相同</li>
<li><blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1bYpgRmwnGNVaCt01WjQ5v0ezdXn9XzL8&export=download" alt=""></p>
</blockquote>
</li>
</ul>
<p>再來我們將公式進行合併，公式計算如下</p>
<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1diujZTQvgqNnDdYUBB1yAE3IsRfkAATv&export=download" alt=""></p>
</blockquote>
<p>因此我們可以知道當我們要設定 n 的大小時的公式為 \(n = \frac{(z_a + z_b )^2 \sigma^2}{(\mu_0 - \mu_a)^2}\)</p>
<ul>
<li>\(z_a\) 是 z value 提供 \(\alpha\) 的面積</li>
<li>\(z_b\) 是 z value 提供 \(\beta\) 的面積</li>
<li>\(\sigma\) 是母體標準差</li>
<li>\(\mu_0\) 是\(H_0\)母體平均值</li>
<li>\(\mu_a\) 是母體平均值，再用於檢測 Type2 Error 的值</li>
<li>在雙尾時，\(z_{a/2} \) 而不是使用 \(z_a \)</li>
</ul>
<h2 id="舉例-平均回應緊急時間為-13-25-min，母體標準差為-3-2，期望能在-12-分鐘內回應，那-Type1-Error-0-05，如果超過-0-75-分鐘的機率不可以大於-0-1，也就是-Type2-Error-0-1，求樣本大小"><a href="#舉例-平均回應緊急時間為-13-25-min，母體標準差為-3-2，期望能在-12-分鐘內回應，那-Type1-Error-0-05，如果超過-0-75-分鐘的機率不可以大於-0-1，也就是-Type2-Error-0-1，求樣本大小" class="headerlink" title="舉例: 平均回應緊急時間為 13.25 min，母體標準差為 3.2，期望能在 12 分鐘內回應，那 Type1 Error = 0.05，如果超過 0.75 分鐘的機率不可以大於 0.1，也就是 Type2 Error = 0.1，求樣本大小"></a>舉例: 平均回應緊急時間為 13.25 min，母體標準差為 3.2，期望能在 12 分鐘內回應，那 Type1 Error = 0.05，如果超過 0.75 分鐘的機率不可以大於 0.1，也就是 Type2 Error = 0.1，求樣本大小</h2><p>因此我們這邊可以先統整資訊</p>
<ul>
<li>\(\alpha = 0.05 \)</li>
<li>\(\beta = 0.1\)</li>
<li>\(z_a = 1.645\)，\(a = 0.05\)</li>
<li>\(z_b = 1.28\)，\(b = 0.1\)</li>
<li>\(\mu_0 = 12, \mu_1 = 12.75\)</li>
<li>\(\sigma = 3.2\)</li>
</ul>
<p>計算 \(n = \frac{(z_a + z_b )^2 \sigma^2}{(\mu_0 - \mu_a)^2} = \frac{(1.645+1.28)^2 (3.2)^2}{(12-12.75)^2} = 155.75 \)，約等於 156。<strong>如果數字有小數點時必須 +1，樣本沒辦法分割所以就直接加一</strong></p>
<p>一旦我們有了 \(\alpha, \beta, n\)，其中兩項，我們就可以算出另一項，透過公式我們可以提出一些重點。</p>
<ul>
<li>當 n 固定時，\(\alpha\) 變小，則 \(\beta\)變大，反之亦同。</li>
</ul>
<p><strong>謝謝大家的努力拉</strong></p>
]]></content>
      <categories>
        <category>北科上課筆記</category>
        <category>統計 statistics</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>統計學筆記</tag>
        <tag>北科大二下統計學筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>統計學(一) 筆記 - 第八章 區間估計(Interval Estimation)</title>
    <url>/2020/12/29/statistics/statistics-ch8/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊與財金管理系大二上統計學重點整理<br><font color="#dd0000">並非所有人都適用，部分對我而言稍加容易的內容並不會寫在此內。</font><br><strong>這是觀看影片心得後的筆記，老師上課可能不太適用會忘記抄到</strong></p>
</blockquote>
<a id="more"></a>

<h2 id="Margin-of-Error-and-the-Interval-Estimate-邊際誤差與區間估計"><a href="#Margin-of-Error-and-the-Interval-Estimate-邊際誤差與區間估計" class="headerlink" title="Margin of Error and the Interval Estimate 邊際誤差與區間估計"></a>Margin of Error and the Interval Estimate 邊際誤差與區間估計</h2><ul>
<li>點估計值基本上不會完全相等母體參數，也就是母體的正確答案</li>
<li>透過 Interval Estimate 區間估計可以幫助我們推出正確的點估計值<br>區間估計公式：\(\text{Point Estimate } \pm \text{Margin of Error }\)，其中點估計量通常會用 \(\bar{x}\) 代替</li>
<li>區間估計可以告訴我們 Point Estimate 多靠近母體參數。</li>
<li>母體參數<br>我們要詢問母體的某一件事，每一個人都必須適用，且通常都是判斷有或沒有，例如判斷所有的學生們有沒有統計都及格。</li>
</ul>
<h3 id="Margin-error-邊際誤差"><a href="#Margin-error-邊際誤差" class="headerlink" title="Margin error 邊際誤差"></a>Margin error 邊際誤差</h3><ul>
<li>通常設 \(E\) 來表示邊際誤差 </li>
<li>邊際誤差公式為 \(E = z_{a/2} \frac{\sigma}{\sqrt{n}}\)<ul>
<li>其中 n 為我們必要的樣本估計大小<br>將邊際誤差公式移項就可以得到 \(n = \frac{(z_{a/2}^2 \  \ \sigma^2)}{E^2}\)</li>
</ul>
</li>
<li>標準差未知的情況<ul>
<li>如果一開始不知道標準差就看<a href="https://theriseofdavid.github.io/2020/12/29/NTUT_note/statistics-ch8/#Interval-Estimate-of-a-Population-Mean-sigma-Unknown-%E6%AF%8D%E9%AB%94%E6%A8%99%E6%BA%96%E5%B7%AE%E6%9C%AA%E7%9F%A5%E7%9A%84%E9%BB%9E%E4%BC%B0%E8%A8%88%E9%87%8F" target="_blank" rel="noopener">母體標準差未知的點估計量</a></li>
<li>再抽測之前，先進行前側，這樣就知道標準差。</li>
<li><strong>預估</strong> <del>猜測</del></li>
</ul>
</li>
<li>如果知道標準差的估計量就看<a href="https://theriseofdavid.github.io/2020/12/29/NTUT_note/statistics-ch8/#Interval-Estimate-of-a-Population-Mean-sigma-Known-%E6%AF%8D%E9%AB%94%E6%A8%99%E6%BA%96%E5%B7%AE%E5%B7%B2%E7%9F%A5%E7%9A%84%E9%BB%9E%E4%BC%B0%E8%A8%88%E9%87%8F" target="_blank" rel="noopener">母體標準差已知的點估計量</a></li>
</ul>
<h4 id="舉例-公司想要知道各戶在-outlet-消費的平均花費是多少，在信心水準有-95-的情況下邊際誤差是-500-或是更小，請問我們應該要蒐集多少樣本，公司認為標準差為-4500。"><a href="#舉例-公司想要知道各戶在-outlet-消費的平均花費是多少，在信心水準有-95-的情況下邊際誤差是-500-或是更小，請問我們應該要蒐集多少樣本，公司認為標準差為-4500。" class="headerlink" title="舉例 - 公司想要知道各戶在 outlet 消費的平均花費是多少，在信心水準有 95% 的情況下邊際誤差是 500 或是更小，請問我們應該要蒐集多少樣本，公司認為標準差為 4500。"></a>舉例 - 公司想要知道各戶在 outlet 消費的平均花費是多少，在信心水準有 95% 的情況下邊際誤差是 500 或是更小，請問我們應該要蒐集多少樣本，公司認為標準差為 4500。</h4><p>先透過公式進行推導，\(z_{a/2}\frac{\sigma }{\sqrt{n}} = 500 \)<br>接著進行查表，當 \(z_{0.025} = 1.96 \)，因此標準差為 4500，就可以推出公式 \(n = \frac{(1.96)^2(4500)^2}{(500)^2} = 311.17 = 312 \)<br>因此我們就可以推出至少要有 312 個樣本才可以符合題目的要求。</p>
<h2 id="Interval-Estimate-of-a-Population-Mean-sigma-Known-母體標準差已知的點估計量"><a href="#Interval-Estimate-of-a-Population-Mean-sigma-Known-母體標準差已知的點估計量" class="headerlink" title="Interval Estimate of a Population Mean \(\sigma \) Known 母體標準差已知的點估計量"></a>Interval Estimate of a Population Mean \(\sigma \) Known 母體標準差<strong>已知</strong>的點估計量</h2><ul>
<li>要符合下面條件<ul>
<li>透過母體 \(\sigma \) 來計算</li>
<li>通常沒有辦法很精確的來找出母體 \(\sigma \)，但可以透過歷史資料來得出，這時我們就稱之為已知。</li>
<li>抽樣樣本 n 要大於 30</li>
<li>如果母體與常態分布相似則 n 大於 15 即可。</li>
<li>如果有高偏態或離群值很多時， n 至少要大於 50 </li>
</ul>
</li>
<li>樣本平均值分布為常態分布</li>
<li>點估計量 \(\mu \)<ul>
<li>公式 \(\bar{x} \pm Z_{a/2} \frac{\sigma}{\sqrt{n}}\)</li>
<li>\(\bar{x}\) 為樣本平均數</li>
<li>\(1-a \) 信賴係數</li>
<li>\(Z_{a/2} \) 為常態分布的信賴區間</li>
<li>\(\sigma\) 母體標準差</li>
<li>\(n\) 樣本大小</li>
</ul>
</li>
<li>常用的信賴區間、與信賴水準，信賴水準就是常態分配的 \(平均值 \pm 標準差 \)<ul>
<li>\( a / 2 \)，非信賴區間的面積</li>
<li>查表時，是先看 \(a / 2 \) 的值後進行查表，透過右邊的標準差來找出 Z 值是多少<blockquote>
<p><img src="/images/statistics-ch8/4.PNG" alt=""></p>
</blockquote>
</li>
</ul>
</li>
<li>舉例 - 透過上面那張圖可以知道在 \(\bar{x} \pm 1.645 \sigma_{\bar{x}}\) 有 90 % 的機率會包含母體平均數。<ul>
<li>因此 90 % 稱為信賴水準 (confidence level )</li>
<li>0.9 也被稱為信賴係數(confidence coefficient)，信賴水準的小數表示就稱為信賴係數。</li>
</ul>
</li>
</ul>
<h4 id="舉例-百貨公司想知道消費者消費金額，抽出-100-份，並透過此知道點估計量"><a href="#舉例-百貨公司想知道消費者消費金額，抽出-100-份，並透過此知道點估計量" class="headerlink" title="舉例 - 百貨公司想知道消費者消費金額，抽出 100 份，並透過此知道點估計量"></a>舉例 - 百貨公司想知道消費者消費金額，抽出 100 份，並透過此知道點估計量</h4><p>由於母體 \(\sigma \) 已經給出 20，且母體極大才能夠這樣算。</p>
<p><strong>這裡主要是要讓讀者知道點估計量也會是常態分配</strong> </p>
<blockquote>
<p><img src="/images/statistics-ch8/1.PNG" alt=""></p>
</blockquote>
<p>因此我們可以知道樣本標準差為 2。</p>
<h3 id="Normal-Probability-Distribution"><a href="#Normal-Probability-Distribution" class="headerlink" title="Normal Probability Distribution"></a>Normal Probability Distribution</h3><ul>
<li>複習一下常態分配中的經驗法則<ul>
<li>\(平均值 \pm 一個標準差 = 68.26 \% \)</li>
<li>\(平均值 \pm 兩個標準差 = 95.44 \% \)</li>
<li>\(平均值 \pm 三個標準差 = 99.72 \% \)</li>
</ul>
</li>
<li>在樣本平均值 \(\bar{x} \) 值中，我們推算出來的樣本標準差將會是信心區間，也就是每次的抽樣樣本平均值會落在樣本標準差裡面的機率會是多少。<ul>
<li>舉例，樣本標準差為 2，那下次抽樣樣本的平均值會落差標準差 2 的機率是多少<br>根據上面講的經驗法則，\(平均值 \pm 兩個標準差 = 95.44 \% \)，因此機率則會是 95.44%</li>
</ul>
</li>
<li>圖解<ul>
<li>\(\bar{x_1 }\) and \(\bar{x_3 }\)<br>這兩次的抽樣樣本中數值則有落在母體平均值當中</li>
<li>\(\bar{x_2 }\)<br>這次的抽樣樣本中數值則<strong>沒有</strong>落在母體平均值當中</li>
<li>z 則是在手算時會使用到，<a href="https://theriseofdavid.github.io/2020/12/01/NTUT_note/statistics-ch7/" target="_blank" rel="noopener">第七章</a>常用到</li>
<li>a (藍色區塊) 則是在抽樣樣本不會落在\(平均值 \pm 標準差 \) 的其他機率，除以 2 是因為左右一半都有面積</li>
<li><blockquote>
<p><img src="/images/statistics-ch8/3.PNG" alt=""></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="舉例-承上題，我們想知道-mu-pm-3-92-的值差幾個標準差並有多少機率母體平均數會落在此區間"><a href="#舉例-承上題，我們想知道-mu-pm-3-92-的值差幾個標準差並有多少機率母體平均數會落在此區間" class="headerlink" title="舉例 - 承上題，我們想知道 \(\mu \pm 3.92 \) 的值差幾個標準差並有多少機率母體平均數會落在此區間"></a>舉例 - 承上題，我們想知道 \(\mu \pm 3.92 \) 的值差幾個標準差並有多少機率母體平均數會落在此區間</h4><p>我們剛剛已經算是樣本標準差為 2，因此是 95.44% ，因此只需要 \(3.92 / 2 = 1.96 \)，因此落在 \(1.96 \sigma{\bar{x}}\)</p>
<blockquote>
<p><img src="/images/statistics-ch8/2.PNG" alt=""></p>
</blockquote>
<h4 id="舉例-Discounr-Sounds-在美國有-260-家的店，還想要開新的店，於是他先去調查新店-不是地名-地區的年收入，樣本-n-36，且年收入平均值為-41-100，母體沒有高偏態，標準差為-4-500-且信賴區間為-0-95，算出一個範圍在隨機抽樣中有-95-的機會有包含母體平均數"><a href="#舉例-Discounr-Sounds-在美國有-260-家的店，還想要開新的店，於是他先去調查新店-不是地名-地區的年收入，樣本-n-36，且年收入平均值為-41-100，母體沒有高偏態，標準差為-4-500-且信賴區間為-0-95，算出一個範圍在隨機抽樣中有-95-的機會有包含母體平均數" class="headerlink" title="舉例 - Discounr Sounds 在美國有 260 家的店，還想要開新的店，於是他先去調查新店(不是地名)地區的年收入，樣本 n = 36，且年收入平均值為 41,100，母體沒有高偏態，標準差為 4,500 且信賴區間為 0.95，算出一個範圍在隨機抽樣中有 95 % 的機會有包含母體平均數"></a>舉例 - Discounr Sounds 在美國有 260 家的店，還想要開新的店，於是他先去調查新店(不是地名)地區的年收入，樣本 n = 36，且年收入平均值為 41,100，母體沒有高偏態，標準差為 4,500 且信賴區間為 0.95，算出一個範圍在隨機抽樣中有 95 % 的機會有包含母體平均數</h4><p>因為抽樣會比起直接將整個母體查詢會更快一些，且母體沒有高偏態，因此可以進行常態分配。</p>
<p>往上數第四張圖已經說明 95% 的信心水準是 \(\bar{x} \pm 1.96 \sigma_{\bar{x}}\) 區間會包含母體平均數。</p>
<p>因此邊際誤差(margin of error) \(Z_{a/2} \frac{\sigma}{\sqrt{n}} = 1.96(\frac{4500}{\sqrt{36}}) = 1,470\)，因此在 95% 的信賴水準下邊際誤差會是 1,470。</p>
<p>再將母體平均值 \( 41,100 \pm 1,470 \) 也就是 \(39,630 \ to \ 42,570\)，就是我們的區間估計且有 95% 的信賴水準</p>
<p>在其他信賴區間時的邊際誤差與區間估計</p>
<blockquote>
<p><img src="/images/statistics-ch8/5.PNG" alt=""></p>
</blockquote>
<h2 id="Interval-Estimate-of-a-Population-Mean-sigma-Unknown-母體標準差未知的點估計量"><a href="#Interval-Estimate-of-a-Population-Mean-sigma-Unknown-母體標準差未知的點估計量" class="headerlink" title="Interval Estimate of a Population Mean \(\sigma \) Unknown 母體標準差未知的點估計量"></a>Interval Estimate of a Population Mean \(\sigma \) Unknown 母體標準差<strong>未知</strong>的點估計量</h2><ul>
<li>沒辦法透過過去歷史資料來推出 \(\sigma \) 時，透過隨機樣本來找出 \(\sigma \)，這個時候要使用 t 分配(Distribution)</li>
</ul>
<h3 id="t-Distribution"><a href="#t-Distribution" class="headerlink" title="t Distribution"></a>t Distribution</h3><ul>
<li>由一群相似的機率分配組合</li>
<li>依照參數來決定自由度 (degrees of freedom)</li>
<li>Degrees of freedom<br>再算樣本標準差有多少獨立的個數，在減掉 \(\bar{x}\)，就是自由度</li>
<li>自由度越大圖形越瘦長且會接近常態分配，如下圖<blockquote>
<p><img src="/images/statistics-ch8/6.PNG" alt=""></p>
</blockquote>
</li>
<li>t 值概念類似於標準常態機率分布的 z</li>
<li>當自由度大於 100 時，t 與 z 值接近相同</li>
<li>當 t 變成無限大時則與 z 相同 </li>
<li>Adequate Sample Size 足夠樣本數量 <ul>
<li>樣本數必須要大於 30 才可以使用</li>
<li>在母體高度偏態或有很多離群值時，樣本數量要高於 50 才可以使用</li>
<li>母體並不是常態分配，但有對稱性時則樣本數只需要 15 筆即可</li>
<li>母體分配與常態分配相同，那樣本數低於 15 也可以</li>
</ul>
</li>
<li>區間估計公式<ul>
<li>基本上類似於常態分配，但在一些非常態分布時也可以使用</li>
<li>\(\bar{x} \pm t_{a/2} \frac{s}{\sqrt{n}}\)</li>
<li>\(1-a\) 信賴係數</li>
<li>\(t_{a/2}\) 為 t 值的區域，為 \(n-1\) 的自由度， t 要查表</li>
<li>\(s\) 樣本標準差</li>
</ul>
</li>
</ul>
<h4 id="舉例-記者想要知道學生花多少錢在校外住宿，在離學校半英里裡面隨機抽樣出-16-筆雅房租金資料，平均租金-750-元、標準差-55，想要建立百分之-95-的信賴區間，來求出母體的平均租金與標準差"><a href="#舉例-記者想要知道學生花多少錢在校外住宿，在離學校半英里裡面隨機抽樣出-16-筆雅房租金資料，平均租金-750-元、標準差-55，想要建立百分之-95-的信賴區間，來求出母體的平均租金與標準差" class="headerlink" title="舉例 - 記者想要知道學生花多少錢在校外住宿，在離學校半英里裡面隨機抽樣出 16 筆雅房租金資料，平均租金 750 元、標準差 55，想要建立百分之 95% 的信賴區間，來求出母體的平均租金與標準差"></a>舉例 - 記者想要知道學生花多少錢在校外住宿，在離學校半英里裡面隨機抽樣出 16 筆雅房租金資料，平均租金 750 元、標準差 55，想要建立百分之 95% 的信賴區間，來求出母體的平均租金與標準差</h4><p>在 95 % 的信心區間中， \(\alpha = 0.05 \) and \(\alpha / 2 = 0.025 \)，因此可以找出\(t_{0.025}\)與在自由度為 \(n-1 = 16 - 1 = 15\)的 t 值，因此我們可以說明 \(t_{0.025} =2.131 \)</p>
<p>下方為查表</p>
<blockquote>
<p><img src="/images/statistics-ch8/7.PNG" alt=""></p>
</blockquote>
<p>根據區間估計公式 \(\bar{x} \pm t_{a/2} \frac{s}{\sqrt{n}} = 750 \pm 2.131 \frac{55}{\sqrt{16}} = 750 \pm 29.30 \)，透過此公式我們可以肯定在 95% 的信賴區間，母體的平均值會介於 720.70 to 779.30 。</p>
<h2 id="Summary-of-Interval-Estimate-Procedures-for-a-Population-Mean-區間估計的計算統整"><a href="#Summary-of-Interval-Estimate-Procedures-for-a-Population-Mean-區間估計的計算統整" class="headerlink" title="Summary of Interval Estimate Procedures for a Population Mean 區間估計的計算統整"></a>Summary of Interval Estimate Procedures for a Population Mean 區間估計的計算統整</h2><blockquote>
<p><img src="/images/statistics-ch8/8.PNG" alt=""></p>
</blockquote>
<h2 id="Interval-Estimate-of-a-Population-Proportion-母體比例的區間估計"><a href="#Interval-Estimate-of-a-Population-Proportion-母體比例的區間估計" class="headerlink" title="Interval Estimate of a Population Proportion 母體比例的區間估計"></a>Interval Estimate of a Population Proportion 母體比例的區間估計</h2><ul>
<li>公式為 \(\bar{p} \pm \text{Margin of Error}\)，將邊際誤差拆開就是<ul>
<li>等同於 \(\bar{p} \pm z_{a/2} \sqrt{\frac{\bar{p} (1-\bar{p}) }{n}}\)</li>
<li>\(1-a\) 為信心係數</li>
<li>\(z_{a/2}\) 為常態分配中，非信心水準的區塊</li>
<li>\(bar{p}\) 樣本母體</li>
</ul>
</li>
<li>在計算區間估計時，\(\bar{p}\) 會決定區間估計的距離</li>
<li>\(\bar{p} \) 要能夠使用常態分配時，必須要符合兩個條件<ul>
<li>\(n(1-p) \geq 5 \)</li>
<li>\(np \geq 5 \)</li>
</ul>
</li>
<li>用圖表來看<blockquote>
<p><img src="/images/statistics-ch8/9.PNG" alt=""></p>
</blockquote>
</li>
</ul>
<h4 id="舉例-民意公司想要調查投票者的薪資，因此進行調查，他調查-500-位選民有-220-位會投給-A，PSI-有-95-的信心水準，想要知道會支持-A-候選人的比例有多少。"><a href="#舉例-民意公司想要調查投票者的薪資，因此進行調查，他調查-500-位選民有-220-位會投給-A，PSI-有-95-的信心水準，想要知道會支持-A-候選人的比例有多少。" class="headerlink" title="舉例 - 民意公司想要調查投票者的薪資，因此進行調查，他調查 500 位選民有 220 位會投給 A，PSI 有 95% 的信心水準，想要知道會支持 A 候選人的比例有多少。"></a>舉例 - 民意公司想要調查投票者的薪資，因此進行調查，他調查 500 位選民有 220 位會投給 A，PSI 有 95% 的信心水準，想要知道會支持 A 候選人的比例有多少。</h4><p>因此透過公式 \(\bar{p} \pm z_{a/2} \sqrt{\frac{\bar{p} (1-\bar{p}) }{n}}\)，並將其值帶入</p>
<ul>
<li>\(n = 500 \)</li>
<li>\(\bar{p} = 220 / 500 = 0.44 \)</li>
<li>\(z_{a/2} = 1.96 \)</li>
</ul>
<p>帶入後則會得到 \(0.44 \pm 1.96 \sqrt{\frac{0.44-(1-0.44)}{500}} = 0.44 \pm 0.0435 \)</p>
<p>因此民意公司在 95% 的信心水準之下，會投給 A 候選人的比例在於 0.3965 to 0.4835。</p>
<h3 id="Sample-Size-for-an-Interval-Estimate-of-a-Population-Proportion-決定母體比例的區間估計的樣本大小"><a href="#Sample-Size-for-an-Interval-Estimate-of-a-Population-Proportion-決定母體比例的區間估計的樣本大小" class="headerlink" title="Sample Size for an Interval Estimate of a Population Proportion 決定母體比例的區間估計的樣本大小"></a>Sample Size for an Interval Estimate of a Population Proportion 決定母體比例的區間估計的樣本大小</h3><p>找出邊際誤差的公式為 \(E = z_{a/2} \sqrt{\frac{\bar{p} (1-\bar{p}) }{n}}\) ，<strong>其中，\(\bar{p}\)</strong>因為我們還沒抽樣還不知道，因此我們這邊用\(\star{p}\) 表示還不知道樣本大小的 p</p>
<p>因此公式就是 \(n = \frac{(z_{a/2} \ )^2 \ \star{p} (1-\star{p})}{E^2}\)</p>
<ul>
<li>\(\star{p}\) 怎麼得出<ul>
<li>透過過去歷史資料得出</li>
<li>前側，先簡單抽樣一次</li>
<li>判斷，<del>猜測</del></li>
<li>使用 0.5 當參考，但這是最後手段。 </li>
</ul>
</li>
</ul>
<h4 id="舉例-民意公司希望有-99-的機率樣本比例離平均數為正負-0-03-邊際誤差-，需要多少的樣本才能達到這個目標？根據過去資料通常樣本比例必須要是-0-44"><a href="#舉例-民意公司希望有-99-的機率樣本比例離平均數為正負-0-03-邊際誤差-，需要多少的樣本才能達到這個目標？根據過去資料通常樣本比例必須要是-0-44" class="headerlink" title="舉例 - 民意公司希望有 99% 的機率樣本比例離平均數為正負 0.03(邊際誤差)，需要多少的樣本才能達到這個目標？根據過去資料通常樣本比例必須要是 0.44"></a>舉例 - 民意公司希望有 99% 的機率樣本比例離平均數為正負 0.03(邊際誤差)，需要多少的樣本才能達到這個目標？根據過去資料通常樣本比例必須要是 0.44</h4><p>因此根據邊際誤差公式 \(z_{a/2} \sqrt{\frac{p(1-p)}{n}} = 0.03 \)<br>在 99% 的信心水準中，\(z_{0.005} = 2.576\)，\(\bar{p} = 0.44 \)<br>因此將公式寫出就是 \(n = \frac{(z_{a/2} \ )^2 \ p* (1-p*)}{E^2} = \frac{(2.576)^2(0.44)(0.56)}{(0.03)^2} \approx 1817  \)</p>
<p>也就是樣本大小至少要大於 1817，才可以符合離平均數誤差為 0.03 之間且信心水準為 0.99。</p>
<p>如果題目沒有給出樣本比例時，則就用 0.5 來計算。</p>
]]></content>
      <categories>
        <category>北科上課筆記</category>
        <category>統計 statistics</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>統計學筆記</tag>
        <tag>北科大二上統計學筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>北科資工二多媒體技術與應用 第三周作業-利用霍夫線分辨出磁磚邊緣</title>
    <url>/2021/03/26/Media_with_Image_recognition/NTUTcs_MediaHW03-2/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊工程系大二下多媒體技術與應用作業紀錄<br><font color="#dd0000">並非所有人都適用，部分對我而言稍加容易的內容並不會寫在此內。</font><br><strong>這是學習後心得的筆記，可能不太適用會未來的學生</strong></p>
<p>由於我沒有學習過裡面的理論，因此這是資工大二學生透過網路與自身理解的筆記，學習價值並不高、且可能擁有大量錯誤。</p>
</blockquote>
<a id="more"></a>

<h2 id="題目如下，用圖片"><a href="#題目如下，用圖片" class="headerlink" title="題目如下，用圖片"></a>題目如下，用圖片</h2><blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1BEt75y-ClQaLMbyNiR8GJgRgBWDDiJaq&export=download" alt=""></p>
</blockquote>
<h2 id="此題作法"><a href="#此題作法" class="headerlink" title="此題作法"></a>此題作法</h2><p>考倒我了，嗚嗚。<br>我對於圖學的知識過少，還需要增加自己對於多媒體的思考能力R。</p>
<p>由於此題已經有告訴你需要用的步驟與規則如下</p>
<ul>
<li>二值化 <code>cv2.threshold</code><br>給予一數值 x，圖片中大於 x 的點都變成白色，小於的則變成黑色</li>
<li>濾波 <code>cv2.medianBlur</code><br>先進行濾波，讓縮小的圖片雜訊被模糊掉，進而讓邊緣線更清楚</li>
<li>膨脹 <code>cv2.dilate</code><br>先給予一個矩陣，如果此矩陣裡有白色的點，那所有點都變為<strong>白色</strong>，要搭配二值化此用</li>
<li>侵蝕 <code>cv2.erode</code><br>先給予一個矩陣，如果此矩陣裡有白色的點，那所有點都變為<strong>黑色</strong>，要搭配二值化此用</li>
<li>模糊 <code>cv2.medianBlur</code><br>由於有大量的反光，加上磁磚並不是完整統一顏色，難免會在縮小後造成雜訊過多，此時我們用濾波讓雜訊模糊，進而讓我們的邊緣清晰。</li>
<li>霍夫線 <code>cv2.HoughLines</code><br>他不需要一個完整的線，它可以將零碎的片段組成一條線。由於圖片擁有大量的反光，會使得磁磚邊緣不清晰，使用他就可以避免此問題，此函式有四個參數，建議一開始可以將極座標先預設為初始值<ul>
<li>image 影像</li>
<li>rho 極座標的線長度</li>
<li>theta 極座標的角度</li>
<li>threshold 超過此長度的線，才會視為是一條線，通常建議從 100 開始慢慢調整</li>
</ul>
</li>
<li>對磁磚邊緣劃線 ````cv2.line``` 進行</li>
</ul>
<p>現在我們有了這些資訊，就比較好寫程式了。</p>
<p>將資料統整後，可以得出一個結論</p>
<ul>
<li>圖片大小不可以超過 1000 像素，所以我們先 <code>cv2.resize</code></li>
<li>先進行濾波，讓縮小的圖片雜訊被模糊掉，進而讓邊緣線更清楚</li>
<li>再來進行二值化，因為如果沒有二值化後面所有東西都不能做<br>至於要在那個點做 x 化就要不斷嘗試</li>
<li>查看圖片，發現還是有一些雜訊，因此先侵蝕<br>至於要在矩陣多大就要不斷嘗試</li>
<li>侵蝕完畢後，發現磁磚縫細有點變形，在做膨脹<br>至於要在矩陣多大就要不斷嘗試</li>
<li>中間有雜訊是正常的，只要不影響霍夫線即可。</li>
<li>再來劃出霍夫線，這裡的輸出的直線座標系統是用極座標。</li>
<li>由於是極座標，因此我們要在轉換成直角座標</li>
<li>轉換完成後，使用 ````cv2.line```  劃線</li>
<li>輸出答案</li>
</ul>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="http://www.opencv.org.cn/opencvdoc/2.3.2/html/doc/tutorials/imgproc/imgtrans/hough_lines/hough_lines.html" target="_blank" rel="noopener">霍夫线变换 openCV</a><br><a href="https://stackoverflow.com/questions/51796526/how-to-draw-a-desired-line-from-houghlines-function-output-in-opencv-c" target="_blank" rel="noopener">How to draw a desired line from HoughLines function output in OpenCV C++? by stackoverflow</a><br><a href="https://blog.csdn.net/sunny2038/article/details/9253823" target="_blank" rel="noopener">OpenCV-Python教程（9、使用霍夫变换检测直线） by Daetalus</a><br><a href="https://blog.csdn.net/dcrmg/article/details/78880046" target="_blank" rel="noopener">OpenCV-Python 霍夫直线检测-HoughLinesP函数参数 by -牧野-</a><br><a href="https://www.kancloud.cn/aollo/aolloopencv/269599" target="_blank" rel="noopener">图像平滑 by OpenCV-Python 中文教程</a><br><a href="https://zh.wikipedia.org/wiki/%E6%9E%81%E5%9D%90%E6%A0%87%E7%B3%BB#%E6%9E%81%E5%9D%90%E6%A0%87%E7%B3%BB%E4%B8%8E%E5%B9%B3%E9%9D%A2%E7%9B%B4%E8%A7%92%E5%9D%90%E6%A0%87%E7%B3%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E8%AE%8A%E6%8D%A2" target="_blank" rel="noopener">極座標系 by wiki</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>原本在上課老師給的學習時間中不斷嘗試卻一直失敗，果然再不太熟的情況下想要做出一份專案是不可能的壓XD，要先透過別人的資料進行學習，從中得知能做好事的關鍵，然後我們再進行模仿，成功後再進行改良、創新。</p>
<p>謝謝郭梓琳、林紀緯的程式碼，讓我從中學習到這麼多的知識。</p>
<p>放在網路上供我知道，也讓有困難的朋友也能學習到。</p>
<h2 id="程式碼"><a href="#程式碼" class="headerlink" title="程式碼"></a>程式碼</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">"../pic/floor.jpg"</span>) <span class="comment">#輸入資料</span></span><br><span class="line">h, w, ch = img.shape <span class="comment">#圖片高、寬、通道</span></span><br><span class="line">w //= <span class="number">5</span> <span class="comment">#這樣就小於 1000</span></span><br><span class="line">h //= <span class="number">5</span></span><br><span class="line">print(h)</span><br><span class="line"></span><br><span class="line">img = cv2.resize(img, (w,h), interpolation = cv2.INTER_NEAREST)</span><br><span class="line"><span class="comment">#縮小圖片，記住這邊的 interpolation 選擇很重要，如果不確定建議可以都試試找最棒的</span></span><br><span class="line">gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</span><br><span class="line">gray = cv2.medianBlur(gray,<span class="number">1</span>) <span class="comment">#透過慮波來讓縮小的圖片雜訊被模糊掉，進而讓邊緣線清楚</span></span><br><span class="line">ret, gray = cv2.threshold(gray, <span class="number">110</span>, <span class="number">255</span>, cv2.THRESH_BINARY_INV) <span class="comment">#二值化，110 是慢慢設定的</span></span><br><span class="line"><span class="comment">#需要特別注意，由於 HoughLines 是判斷**白色**得線，但我們的磁磚邊緣線是黑色，</span></span><br><span class="line"><span class="comment">#因此我們這邊的參數要用 cv2.THRESH_BINARY_INV，這樣原本判定黑色的地方就會變白色</span></span><br><span class="line"></span><br><span class="line">gray = cv2.erode(gray, np.ones((<span class="number">2</span>,<span class="number">2</span>)), iterations=<span class="number">1</span>) <span class="comment">#侵蝕，裡面矩陣與 iterations 細調</span></span><br><span class="line">gray = cv2.dilate(gray, np.ones((<span class="number">2</span>,<span class="number">2</span>)), iterations=<span class="number">1</span>) <span class="comment">##膨脹，裡面矩陣與 iterations 細調</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#cv2.imshow("img", img)</span></span><br><span class="line">cv2.imshow(<span class="string">"gray"</span>, gray) <span class="comment">#檢查一下，有雜訊是正常的，只要不影響到霍夫線劃線都沒問題</span></span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">rho = <span class="number">1.0</span> <span class="comment">#極座標系統長度</span></span><br><span class="line">theta = np.pi / <span class="number">2</span> <span class="comment">#極座標系統角度</span></span><br><span class="line">line = cv2.HoughLines(gray, rho, theta, <span class="number">200</span>) <span class="comment">#霍夫線</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> it <span class="keyword">in</span> line: <span class="comment">#將每條線</span></span><br><span class="line">  <span class="keyword">for</span> rho, theta <span class="keyword">in</span> it: <span class="comment">#拿出每條線裡面的極座標系統</span></span><br><span class="line">    a = np.cos(theta) <span class="comment">#下面轉換成為直角坐標</span></span><br><span class="line">    b = np.sin(theta)</span><br><span class="line">    x0 = a*rho</span><br><span class="line">    y0 = b*rho</span><br><span class="line">    x1 = int(x0 + h*(-b)) <span class="comment">#由於我們要畫的線基本上是從圖片的末端開始畫，因此我們直接將畫線</span></span><br><span class="line">    y1 = int(y0 + h*(a))  <span class="comment">#長度設定為，我們圖片中最長的長度即可(通常是高)。</span></span><br><span class="line">    x2 = int(x0 - h*(-b)) <span class="comment">#這樣我們就會從圖片的末端畫到另一末端</span></span><br><span class="line">    y2 = int(y0 - h*(a))</span><br><span class="line">    cv2.line(img, (x1,y1), (x2,y2), (<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>), <span class="number">2</span>)  <span class="comment">#畫線</span></span><br><span class="line">  </span><br><span class="line">cv2.imshow(<span class="string">"result"</span>, img) </span><br><span class="line">cv2.imwrite(<span class="string">"result.jpg"</span>, img) <span class="comment">#輸出圖片</span></span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h2 id="題目資料"><a href="#題目資料" class="headerlink" title="題目資料"></a>題目資料</h2><blockquote>
<p>原始磁磚圖片<br><img src="https://drive.google.com/u/2/uc?id=1-TxaJxnexwSKXkVaYH7o6IgP7JEirC_q&export=download" alt=""></p>
</blockquote>
<blockquote>
<p>灰階、濾波、二值化、膨脹、侵蝕後的圖片<br><img src="https://drive.google.com/u/2/uc?id=1Tu_KEjTqWMuwSw7AgX5dkc-1-AHozRLF&export=download" alt=""></p>
</blockquote>
<blockquote>
<p>答案<br><img src="https://drive.google.com/u/2/uc?id=1X-DH61BFUjDlNghM81X6NpP1ENiaIyNe&export=download" alt=""></p>
</blockquote>
]]></content>
      <categories>
        <category>北科上課筆記</category>
        <category>多媒體與圖像辨識 Image Recognition</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>北科大多媒體技術與應用筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>北科資工二多媒體技術與應用 第三周作業-辨識硬幣種類</title>
    <url>/2021/03/26/Media_with_Image_recognition/NTUTcs_MediaHW03-1/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊工程系大二下多媒體技術與應用作業紀錄<br><font color="#dd0000">並非所有人都適用，部分對我而言稍加容易的內容並不會寫在此內。</font><br><strong>這是學習後心得的筆記，可能不太適用會未來的學生</strong></p>
<p>由於我沒有學習過裡面的理論，因此這是資工大二學生透過網路與自身理解的筆記，學習價值並不高、且可能擁有大量錯誤。</p>
</blockquote>
<a id="more"></a>

<h2 id="題目如下，用圖片"><a href="#題目如下，用圖片" class="headerlink" title="題目如下，用圖片"></a>題目如下，用圖片</h2><blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1lEe2RtCYO2evvuoq9UGdWbQrVn5u5Lvc&export=download" alt=""></p>
</blockquote>
<h2 id="此題作法"><a href="#此題作法" class="headerlink" title="此題作法"></a>此題作法</h2><p>此題與<a href="https://theriseofdavid.github.io/2021/03/26/NTUT_note/NTUTcs_MediaHW03-3/" target="_blank" rel="noopener">北科資工二多媒體技術與應用 第三周作業-辨識硬幣與鈔票種類</a>大部分相同。<br>不一樣的部分是此題判斷硬幣是用<strong>長度</strong>來判斷，因為硬幣長寬都會相同。</p>
<p>考倒我了，嗚嗚。<br>我對於圖學的知識過少，還需要增加自己對於多媒體的思考能力R。</p>
<p>由於此題已經有告訴你需要用的步驟與規則如下</p>
<ul>
<li>二值化 <code>cv2.threshold</code><br>給予一數值 x，圖片中大於 x 的點都變成白色，小於的則變成黑色</li>
<li>膨脹 <code>cv2.dilate</code><br>先給予一個矩陣，如果此矩陣裡有白色的點，那所有點都變為<strong>白色</strong>，要搭配二值化此用</li>
<li>侵蝕 <code>cv2.erode</code><br>先給予一個矩陣，如果此矩陣裡有白色的點，那所有點都變為<strong>黑色</strong>，要搭配二值化此用</li>
<li>連通物件 <code>cv2.connectedComponentsWithStats</code>，<code>connectivity=4</code> 時表示判斷區塊的方式是上下左右，<code>connectivity=4</code> 時是上下左右加上左上、左下、右下、右上。<br>幫你找出圖片中的所有白色區塊，會給出四個回傳值。<ul>
<li>num_labels 有多少區塊</li>
<li>labels 透過矩陣表示區塊</li>
<li>stats 是一個陣列，依序是 x座標、y座標、長、寬、面積，面積以像素為單位</li>
<li>centroids 區塊的中心點</li>
</ul>
</li>
<li>圖片大小不可以超過 1000 像素，透過 <code>cv2.resize</code> 進行</li>
<li>對硬幣畫線，透過 ````cv2.rectangle``` 進行</li>
</ul>
<p>現在我們有了這些資訊，就比較好畫圖了。</p>
<p>將資料統整後，可以得出一個結論</p>
<ul>
<li>圖片大小不可以超過 1000 像素，所以我們先 <code>cv2.resize</code></li>
<li>再來進行二值化，因為如果沒有二值化後面所有東西都不能做<br>至於要在那個點做 x 化就要不斷嘗試</li>
<li>查看圖片，發現還是有很多<strong>白點</strong>散布在硬幣的旁邊，因此先侵蝕<br>至於要在矩陣多大就要不斷嘗試</li>
<li>侵蝕完畢後，發現硬幣的邊界有點變形，在做膨脹<br>至於要在矩陣多大就要不斷嘗試</li>
<li>再來連通物件，<code>print(stat)</code><br>發現有很多圓形，我們先對全部的區塊畫線，檢查有沒有硬幣沒有被畫到，或太偏差，有就在回前幾步重新嘗試</li>
<li>確認沒有後，將每種硬幣畫線<br>不斷找出每種硬幣的寬度是多少，以此為依據畫線。</li>
<li>輸出答案</li>
</ul>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p>提供我所用到的連結<br><a href="https://www.kancloud.cn/aollo/aolloopencv/260982" target="_blank" rel="noopener">OpenCV中的绘图函数 by OpenCV-Python 中文教程</a><br><a href="https://answers.opencv.org/question/115770/error-could-not-find-a-writer/" target="_blank" rel="noopener">Error could not find a writer by OpenCV</a><br><a href="https://blog.csdn.net/JNingWei/article/details/78218837" target="_blank" rel="noopener">opencv: 图像缩放(cv2.resize) by JNingWei</a><br><a href="https://stackoverflow.com/questions/35854197/how-to-use-opencvs-connected-components-with-stats-in-python" target="_blank" rel="noopener">How to use openCV’s connected components with stats in python? by stackoverflow</a><br><a href="https://shengyu7697.github.io/blog/2020/04/04/Python-OpenCV-rectangle/" target="_blank" rel="noopener">[Python+OpenCV] 畫矩形 rectangle by ShengYu Talk</a><br><a href="https://www.rapidtables.com/web/color/orange-color.html" target="_blank" rel="noopener">Orange Color Code by RapidTables</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>原本在上課老師給的學習時間中不斷嘗試卻一直失敗，果然再不太熟的情況下想要做出一份專案是不可能的壓XD，要先透過別人的資料進行學習，從中得知能做好事的關鍵，然後我們再進行模仿，成功後再進行改良、創新。</p>
<p>謝謝郭梓琳、林紀緯的程式碼，讓我從中學習到這麼多的知識。</p>
<p>放在網路上供我知道，也讓有困難的朋友也能學習到。</p>
<h2 id="程式碼"><a href="#程式碼" class="headerlink" title="程式碼"></a>程式碼</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">"../pic/coin.jpg"</span>) <span class="comment">#輸入資料</span></span><br><span class="line">h, w, ch = img.shape <span class="comment">#圖片高、寬、通道</span></span><br><span class="line"></span><br><span class="line">img = cv2.resize(img, (w//<span class="number">5</span>, h//<span class="number">5</span>), interpolation=cv2.INTER_NEAREST) <span class="comment">#important</span></span><br><span class="line"><span class="comment">#縮小圖片，記住這邊的 interpolation 選擇很重要，如果不確定建議可以都試試找最棒的</span></span><br><span class="line"></span><br><span class="line">gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) <span class="comment">#灰階化，方便閱讀</span></span><br><span class="line">ret, gray = cv2.threshold(gray, <span class="number">90</span>, <span class="number">255</span>, cv2.THRESH_BINARY) <span class="comment">#二值化，90 是慢慢設定的</span></span><br><span class="line"></span><br><span class="line">gray = cv2.erode(gray, np.ones((<span class="number">2</span>,<span class="number">2</span>)), iterations=<span class="number">2</span>) <span class="comment">#侵蝕，裡面矩陣與 iterations 細調</span></span><br><span class="line">gray = cv2.dilate(gray, np.ones((<span class="number">2</span>,<span class="number">2</span>)), iterations=<span class="number">1</span>) <span class="comment">#膨脹，裡面矩陣與 iterations 細調</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#連通物件，設八通道這樣才嚴謹</span></span><br><span class="line">num_labels, labels, stats, centroids = cv2.connectedComponentsWithStats(gray, connectivity=<span class="number">8</span>)</span><br><span class="line">print(stats)  <span class="comment">#檢查所有區塊</span></span><br><span class="line"></span><br><span class="line">ans = <span class="number">0</span> <span class="comment">#輸出多少錢</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> it <span class="keyword">in</span> stats:</span><br><span class="line">  itX = it[<span class="number">0</span>]+it[<span class="number">2</span>] <span class="comment">#寬度</span></span><br><span class="line">  itY = it[<span class="number">1</span>]+it[<span class="number">3</span>] <span class="comment">#高度</span></span><br><span class="line">  <span class="comment">#cv2.rectangle(img, (it[0], it[1]), (itX, itY), (200, 31, 31), 2)</span></span><br><span class="line">  <span class="comment">#一開始可以使用，這樣她會畫出所有的區塊來讓你判斷有沒有區塊沒畫到或連在一起</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">#下面的長度是我自己去慢慢調整出來得</span></span><br><span class="line">  <span class="keyword">if</span>(it[<span class="number">2</span>] &gt;= <span class="number">60</span> <span class="keyword">and</span> it[<span class="number">2</span>] &lt; <span class="number">75</span>): <span class="comment">#1 dallars</span></span><br><span class="line">    cv2.rectangle(img, (it[<span class="number">0</span>], it[<span class="number">1</span>]), (itX, itY), (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>) <span class="comment">#BGR </span></span><br><span class="line">    ans += <span class="number">1</span></span><br><span class="line">  <span class="keyword">if</span>(it[<span class="number">2</span>] &gt;= <span class="number">75</span> <span class="keyword">and</span> it[<span class="number">2</span>] &lt; <span class="number">90</span>): <span class="comment">#5 dallars</span></span><br><span class="line">    cv2.rectangle(img, (it[<span class="number">0</span>], it[<span class="number">1</span>]), (itX, itY), (<span class="number">0</span>, <span class="number">165</span>, <span class="number">255</span>), <span class="number">2</span>) <span class="comment">#BGR</span></span><br><span class="line">    ans += <span class="number">5</span></span><br><span class="line">  <span class="keyword">if</span>(it[<span class="number">2</span>] &gt;= <span class="number">90</span> <span class="keyword">and</span> it[<span class="number">2</span>] &lt; <span class="number">100</span>): <span class="comment">#10 dallars</span></span><br><span class="line">    cv2.rectangle(img, (it[<span class="number">0</span>], it[<span class="number">1</span>]), (itX, itY), (<span class="number">0</span>, <span class="number">255</span>, <span class="number">255</span>), <span class="number">2</span>) <span class="comment">#BGR </span></span><br><span class="line">    ans += <span class="number">10</span></span><br><span class="line">  <span class="keyword">if</span>(it[<span class="number">2</span>] &gt;= <span class="number">100</span> <span class="keyword">and</span> it[<span class="number">2</span>] &lt; <span class="number">115</span>): <span class="comment">#50 dallars  </span></span><br><span class="line">    cv2.rectangle(img, (it[<span class="number">0</span>], it[<span class="number">1</span>]), (itX, itY), (<span class="number">0</span>, <span class="number">128</span>, <span class="number">0</span>), <span class="number">2</span>) <span class="comment">#BGR</span></span><br><span class="line">    ans += <span class="number">50</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#cv2.imshow("gray", gray) </span></span><br><span class="line">print(<span class="string">"圖上共有 "</span>,ans ,<span class="string">"元"</span>) <span class="comment">#輸出答案 </span></span><br><span class="line">cv2.imshow(<span class="string">"img"</span>, img)</span><br><span class="line">cv2.imwrite(<span class="string">'ans.jpg'</span>, img)</span><br><span class="line">cv2.imwrite(<span class="string">'gray.jpg'</span>, gray)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h2 id="題目資料"><a href="#題目資料" class="headerlink" title="題目資料"></a>題目資料</h2><blockquote>
<p>硬幣圖片<br><img src="https://drive.google.com/u/2/uc?id=10EYpWRfu1TKoubjH7bA8B_aOIHdp98Ya&export=download" alt=""></p>
</blockquote>
<blockquote>
<p>灰階、二值化、膨脹、侵蝕後的圖片<br><img src="https://drive.google.com/u/2/uc?id=1VbVqubPimrhY6L-oMpluUlIMLsRJTQi3&export=download" alt=""></p>
</blockquote>
<blockquote>
<p>答案<br><img src="https://drive.google.com/u/2/uc?id=1-rSxkBPoqHoPPJjz0rv6UVLU6_Eyl3yv&export=download" alt=""></p>
</blockquote>
]]></content>
      <categories>
        <category>北科上課筆記</category>
        <category>多媒體與圖像辨識 Image Recognition</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>北科大多媒體技術與應用筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>北科資工二多媒體技術與應用 第三周作業-辨識硬幣與鈔票種類</title>
    <url>/2021/03/26/Media_with_Image_recognition/NTUTcs_MediaHW03-3/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊工程系大二下多媒體技術與應用作業紀錄<br><font color="#dd0000">並非所有人都適用，部分對我而言稍加容易的內容並不會寫在此內。</font><br><strong>這是學習後心得的筆記，可能不太適用會未來的學生</strong></p>
<p>由於我沒有學習過裡面的理論，因此這是資工大二學生透過網路與自身理解的筆記，學習價值並不高、且可能擁有大量錯誤。</p>
</blockquote>
<a id="more"></a>

<h2 id="題目如下，用圖片"><a href="#題目如下，用圖片" class="headerlink" title="題目如下，用圖片"></a>題目如下，用圖片</h2><blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1nWyLdcpQvoDLLxjXmacD9n4ivtXB2Y9T&export=download" alt=""></p>
</blockquote>
<p>由於題目沒有說 1000元要用甚麼顏色，我就用白色</p>
<h2 id="此題作法"><a href="#此題作法" class="headerlink" title="此題作法"></a>此題作法</h2><p>此題與<a href="https://theriseofdavid.github.io/2021/03/26/NTUT_note/NTUTcs_MediaHW03-1/" target="_blank" rel="noopener">北科資工二多媒體技術與應用 第三周作業-辨識硬幣種類</a>大部分相同。<br>不一樣的部分是此題判斷硬幣與紙鈔是用<strong>面積</strong>來判斷，因為題目紙鈔有橫者放、直者放，所以要用面積。</p>
<p>考倒我了，嗚嗚。<br>我對於圖學的知識過少，還需要增加自己對於多媒體的思考能力R。</p>
<p>由於此題已經有告訴你需要用的步驟與規則如下</p>
<ul>
<li>二值化 ````cv2.threshold```<br>給予一數值 x，圖片中大於 x 的點都變成白色，小於的則變成黑色</li>
<li>膨脹 <code>cv2.dilate</code><br>先給予一個矩陣，如果此矩陣裡有白色的點，那所有點都變為<strong>白色</strong>，要搭配二值化此用</li>
<li>侵蝕 <code>cv2.erode</code><br>先給予一個矩陣，如果此矩陣裡有白色的點，那所有點都變為<strong>黑色</strong>，要搭配二值化此用</li>
<li>連通物件 <code>cv2.connectedComponentsWithStats</code>，<code>connectivity=4</code> 時表示判斷區塊的方式是上下左右，<code>connectivity=4</code> 時是上下左右加上左上、左下、右下、右上。<br>幫你找出圖片中的所有白色區塊，會給出四個回傳值。<ul>
<li>num_labels 有多少區塊</li>
<li>labels 透過矩陣表示區塊</li>
<li>stats 是一個陣列，依序是 x座標、y座標、長、寬、面積，面積以像素為單位</li>
<li>centroids 區塊的中心點</li>
</ul>
</li>
<li>圖片大小不可以超過 1000 像素，透過 <code>cv2.resize</code> 進行</li>
<li>對硬幣與鈔票畫線，透過 ````cv2.rectangle``` 進行</li>
</ul>
<p>現在我們有了這些資訊，就比較好畫圖了。</p>
<p>將資料統整後，可以得出一個結論</p>
<ul>
<li>圖片大小不可以超過 1000 像素，所以我們先 <code>cv2.resize</code></li>
<li>再來進行二值化，因為如果沒有二值化後面所有東西都不能做<br>至於要在那個點做 x 化就要不斷嘗試</li>
<li>查看圖片，發現還是有很多<strong>白點</strong>散布在硬幣與鈔票的旁邊，因此先侵蝕<br>至於要在矩陣多大就要不斷嘗試</li>
<li>侵蝕完畢後，發現硬幣與鈔票的邊界有點變形，在做膨脹<br>至於要在矩陣多大就要不斷嘗試</li>
<li>再來連通物件，<code>print(stat)</code><br>發現有很多圓形，我們先對全部的區塊畫線，檢查有沒有硬幣與鈔票沒有被畫到，或太偏差，有就在回前幾步重新嘗試</li>
<li>確認沒有後，將每種硬幣與鈔票畫線<br>不斷找出每種硬幣與鈔票的寬度是多少，以此為依據畫線。</li>
<li>輸出答案</li>
</ul>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p>提供我所用到的連結<br><a href="https://www.kancloud.cn/aollo/aolloopencv/260982" target="_blank" rel="noopener">OpenCV中的绘图函数 by OpenCV-Python 中文教程</a><br><a href="https://answers.opencv.org/question/115770/error-could-not-find-a-writer/" target="_blank" rel="noopener">Error could not find a writer by OpenCV</a><br><a href="https://blog.csdn.net/JNingWei/article/details/78218837" target="_blank" rel="noopener">opencv: 图像缩放(cv2.resize) by JNingWei</a><br><a href="https://stackoverflow.com/questions/35854197/how-to-use-opencvs-connected-components-with-stats-in-python" target="_blank" rel="noopener">How to use openCV’s connected components with stats in python? by stackoverflow</a><br><a href="https://shengyu7697.github.io/blog/2020/04/04/Python-OpenCV-rectangle/" target="_blank" rel="noopener">[Python+OpenCV] 畫矩形 rectangle by ShengYu Talk</a><br><a href="https://www.rapidtables.com/web/color/orange-color.html" target="_blank" rel="noopener">Orange Color Code by RapidTables</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>原本在上課老師給的學習時間中不斷嘗試卻一直失敗，果然再不太熟的情況下想要做出一份專案是不可能的壓XD，要先透過別人的資料進行學習，從中得知能做好事的關鍵，然後我們再進行模仿，成功後再進行改良、創新。</p>
<p>謝謝郭梓琳、林紀緯的程式碼，讓我從中學習到這麼多的知識。</p>
<p>放在網路上供我知道，也讓有困難的朋友也能學習到。</p>
<p>題外話，這題的 500 元紙鈔是比 100 元的紙鈔還大的喔，我有用 PS 檢查過</p>
<ul>
<li>500 元紙鈔長 29.7、高 55.5，單位 cm，面積為 1768.635</li>
<li>100 元紙鈔長 60.82、高 28.58，單位 cm，面積為 1738.2356</li>
</ul>
<p>不要在寫程式的過程中誤以為 100 元的紙鈔比較大喔XD。</p>
<p>寫了好多 IF，好髒阿QQQ。</p>
<p>重新調整適合的參數位置，二值化、侵蝕、膨脹也是花了我好多時間QQ，圖像也是個大學問。</p>
<p>還有判斷是哪個硬幣也花我很多時間！一開始我是先用寬度來進行判斷，發現紙鈔有一張跟其他擺法不同，後來改用 <code>stat[4]</code> 來解，結果發現跟一般邏輯不同，100 元比 500 元大，1000 元最小，後來才意識到紙鈔的區塊可不一定裡面都沒有區塊阿，也就是可能 100 元的區塊裡面還有一些雜訊，因此 <code>stat[4]</code> 的面積可能就會因此縮小，就因為這樣，才會導致100 元比 500 元大，1000 元最小的問題。<br>因此要自己用長寬相乘的面積就可以忽略掉雜訊的問題，因此要自己相乘</p>
<blockquote>
<p>例如 100 元的區塊中，裡面有雜訊(黑色區塊)此時區塊的面積就會剪掉他。<br><img src="https://drive.google.com/u/2/uc?id=1gOMVelQZr7REcu1KWw0e9FlSKTzezYD6&export=download" alt=""></p>
</blockquote>
<p>總之，這讓我學了很多，算開心八XD。</p>
<h2 id="程式碼"><a href="#程式碼" class="headerlink" title="程式碼"></a>程式碼</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">"../pic/coin2.jpg"</span>) <span class="comment">#輸入資料</span></span><br><span class="line">h, w, ch = img.shape  <span class="comment">#圖片高、寬、通道</span></span><br><span class="line"></span><br><span class="line">img = cv2.resize(img, (w//<span class="number">5</span>, h//<span class="number">5</span>), interpolation=cv2.INTER_NEAREST) <span class="comment">#important</span></span><br><span class="line"><span class="comment">#縮小圖片，記住這邊的 interpolation 選擇很重要，如果不確定建議可以都試試找最棒的</span></span><br><span class="line"></span><br><span class="line">gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)  <span class="comment">#灰階化，方便閱讀</span></span><br><span class="line">ret, gray = cv2.threshold(gray, <span class="number">45</span>, <span class="number">255</span>, cv2.THRESH_BINARY) <span class="comment">#二值化，45 是慢慢設定的</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">gray = cv2.erode(gray, np.ones((<span class="number">3</span>,<span class="number">3</span>)), iterations=<span class="number">3</span>) <span class="comment">#侵蝕，裡面矩陣與 iterations 細調</span></span><br><span class="line">gray = cv2.dilate(gray, np.ones((<span class="number">3</span>,<span class="number">3</span>)), iterations=<span class="number">2</span>) <span class="comment">#膨脹，裡面矩陣與 iterations 細調</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#連通物件，設八通道這樣才嚴謹</span></span><br><span class="line">num_labels, labels, stats, centroids = cv2.connectedComponentsWithStats(gray, connectivity=<span class="number">8</span>)</span><br><span class="line">print(stats) <span class="comment">#檢查所有區塊</span></span><br><span class="line"></span><br><span class="line">ans = <span class="number">0</span> <span class="comment">#輸出多少錢</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> it <span class="keyword">in</span> stats:</span><br><span class="line">  itX = it[<span class="number">0</span>]+it[<span class="number">2</span>] <span class="comment">#寬度</span></span><br><span class="line">  itY = it[<span class="number">1</span>]+it[<span class="number">3</span>] <span class="comment">#高度</span></span><br><span class="line">  itArea = it[<span class="number">2</span>]*it[<span class="number">3</span>] <span class="comment">#面積，忽略掉區塊內雜訊</span></span><br><span class="line">  print(itArea)  <span class="comment">#可以第一次執行時先印出面積，比較容易在下面 if 的參數做微調</span></span><br><span class="line"><span class="comment">#  cv2.rectangle(img, (it[0], it[1]), (itX, itY), (200, 31, 31), 2)</span></span><br><span class="line"><span class="comment">#一開始可以使用，這樣她會畫出所有的區塊來讓你判斷有沒有區塊沒畫到或連在一起</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(itArea &gt;= <span class="number">1600</span> <span class="keyword">and</span> itArea &lt; <span class="number">2000</span>): <span class="comment">#1 dallars</span></span><br><span class="line">    cv2.rectangle(img, (it[<span class="number">0</span>], it[<span class="number">1</span>]), (itX, itY), (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>) <span class="comment">#BGR </span></span><br><span class="line">    ans += <span class="number">1</span></span><br><span class="line">  <span class="keyword">if</span>(itArea &gt;= <span class="number">2000</span> <span class="keyword">and</span> itArea &lt; <span class="number">2400</span>): <span class="comment">#5 dallars</span></span><br><span class="line">    cv2.rectangle(img, (it[<span class="number">0</span>], it[<span class="number">1</span>]), (itX, itY), (<span class="number">0</span>, <span class="number">165</span>, <span class="number">255</span>), <span class="number">2</span>) <span class="comment">#BGR</span></span><br><span class="line">    ans += <span class="number">5</span></span><br><span class="line">  <span class="keyword">if</span>(itArea &gt;= <span class="number">3000</span> <span class="keyword">and</span> itArea &lt; <span class="number">3400</span>): <span class="comment">#10 dallars</span></span><br><span class="line">    cv2.rectangle(img, (it[<span class="number">0</span>], it[<span class="number">1</span>]), (itX, itY), (<span class="number">0</span>, <span class="number">255</span>, <span class="number">255</span>), <span class="number">2</span>) <span class="comment">#BGR </span></span><br><span class="line">    ans += <span class="number">10</span></span><br><span class="line">  <span class="keyword">if</span>(itArea &gt;= <span class="number">3600</span> <span class="keyword">and</span> itArea &lt; <span class="number">4100</span>): <span class="comment">#50 dallars  </span></span><br><span class="line">    cv2.rectangle(img, (it[<span class="number">0</span>], it[<span class="number">1</span>]), (itX, itY), (<span class="number">0</span>, <span class="number">128</span>, <span class="number">0</span>), <span class="number">2</span>) <span class="comment">#BGR</span></span><br><span class="line">    ans += <span class="number">50</span></span><br><span class="line">  <span class="keyword">if</span>(itArea &gt;= <span class="number">55000</span> <span class="keyword">and</span> itArea &lt; <span class="number">57000</span>): <span class="comment">#100 dallars</span></span><br><span class="line">    cv2.rectangle(img, (it[<span class="number">0</span>], it[<span class="number">1</span>]), (itX, itY), (<span class="number">200</span>, <span class="number">31</span>, <span class="number">31</span>), <span class="number">2</span>)</span><br><span class="line">    ans += <span class="number">100</span></span><br><span class="line">  <span class="keyword">if</span>(itArea &gt;= <span class="number">53000</span> <span class="keyword">and</span> itArea &lt; <span class="number">55000</span>): <span class="comment">#500 dallars</span></span><br><span class="line">    cv2.rectangle(img, (it[<span class="number">0</span>], it[<span class="number">1</span>]), (itX, itY), (<span class="number">128</span>, <span class="number">0</span>, <span class="number">128</span>), <span class="number">2</span>)</span><br><span class="line">    ans += <span class="number">500</span></span><br><span class="line">  <span class="keyword">if</span>(itArea &gt;= <span class="number">57000</span> <span class="keyword">and</span> itArea &lt; <span class="number">59000</span>): <span class="comment">#1000 dallars</span></span><br><span class="line">    cv2.rectangle(img, (it[<span class="number">0</span>], it[<span class="number">1</span>]), (itX, itY), (<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>), <span class="number">2</span>)</span><br><span class="line">    ans += <span class="number">1000</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">"圖上共有 "</span>,ans ,<span class="string">"元"</span>)</span><br><span class="line">cv2.imshow(<span class="string">"gray"</span>, gray)  </span><br><span class="line">cv2.imshow(<span class="string">"img"</span>, img)</span><br><span class="line"></span><br><span class="line">cv2.imwrite(<span class="string">'ans3-3.jpg'</span>, img)</span><br><span class="line">cv2.imwrite(<span class="string">'gray3-3.jpg'</span>, gray)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h2 id="題目資料"><a href="#題目資料" class="headerlink" title="題目資料"></a>題目資料</h2><blockquote>
<p>硬幣圖片<br><img src="https://drive.google.com/u/2/uc?id=15ihSlBXOj1UWsNgM-TPeEIaz3uCGLFU6&export=download" alt=""></p>
</blockquote>
<blockquote>
<p>灰階、二值化、膨脹、侵蝕後的圖片<br><img src="https://drive.google.com/u/2/uc?id=1VaSFxZGCx8INaK4mpKlhi74IwelDR64C&export=download" alt=""></p>
</blockquote>
<blockquote>
<p>答案<br><img src="https://drive.google.com/u/2/uc?id=1gw8bCt_F1GhTp4QS_QRki0JQ8Dg8JztR&export=download" alt=""></p>
</blockquote>
]]></content>
      <categories>
        <category>北科上課筆記</category>
        <category>多媒體與圖像辨識 Image Recognition</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>北科大多媒體技術與應用筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>北科資工二多媒體技術與應用 第四周作業-測試 Adaboost、KNN 兩種分類器</title>
    <url>/2021/04/07/Media_with_Image_recognition/NTUTcs_MediaHW04-1/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊工程系大二下多媒體技術與應用作業紀錄<br><font color="#dd0000">並非所有人都適用，部分對我而言稍加容易的內容並不會寫在此內。</font><br><strong>這是學習後心得的筆記，可能不太適用會未來的學生</strong></p>
<p>由於我沒有學習過裡面的理論，因此這是資工大二學生透過網路與自身理解的筆記，學習價值並不高、且可能擁有大量錯誤。</p>
</blockquote>
<a id="more"></a>


<h2 id="題目如下，用圖片"><a href="#題目如下，用圖片" class="headerlink" title="題目如下，用圖片"></a>題目如下，用圖片</h2><blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1XsmKWOZfkH1oOtuxLvnf5bLG18N_SKc_&export=download" alt=""></p>
</blockquote>
<h2 id="Adaboost"><a href="#Adaboost" class="headerlink" title="Adaboost"></a>Adaboost</h2><p>主要是透過 python sklearn.ensemble 函式使用，裡面其中最重要的三個參數如下：</p>
<ul>
<li>n_estimators<br>為公式 的可最大疊代次數，其中 W_(k+1)就是每次的疊代次數記錄，通常標準是 50，如果太大可能會導致 overfitting，太小則又不夠精確。</li>
<li>learning_rate<br>為每個分類器的權重，如果每個分類器的權重越大，那建議 n_estimators 可以小點，如果每個分類器的權重越小，則建議n_estimators 要更大些。</li>
</ul>
<p>透過鳶尾花資料集進行練習，我發現最主要的問題是 train_test_split 中的 test_size 比例越小時則其準確性越高，反之則越大。</p>
<h3 id="程式碼"><a href="#程式碼" class="headerlink" title="程式碼"></a>程式碼</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> svm</span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> AdaBoostClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> make_classification</span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">iris = datasets.load_iris()</span><br><span class="line"></span><br><span class="line">x = iris.data</span><br><span class="line">y = iris.target</span><br><span class="line">x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=<span class="number">0.2</span>, random_state=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#test_size 越小，準確率越高，越大則準確率越低</span></span><br><span class="line"><span class="comment">#在learning_rate 越大，感覺越好，n_estimators注意不要 overfitting</span></span><br><span class="line">clf = AdaBoostClassifier(n_estimators=<span class="number">40</span>, learning_rate=<span class="number">1</span>, random_state=<span class="number">0</span>)</span><br><span class="line">clf.fit(x_train, y_train)</span><br><span class="line">print(<span class="string">"AdaBoost accuracy"</span>)</span><br><span class="line">print(clf.score(x, y))</span><br><span class="line">print()</span><br></pre></td></tr></table></figure>

<h3 id="輸出結果"><a href="#輸出結果" class="headerlink" title="輸出結果"></a>輸出結果</h3><blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1k0IqTG1uy6mM2godTHsLo31rmW6PS5pW&export=download" alt=""></p>
</blockquote>
<h3 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h3><p>其中最酷的是 n_estimators在 40 的情況時，準確率會降低，但在 n_estimators 是 30 的情況下時，準確率卻又會上升至 n_estimators 等於 50。</p>
<h3 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h3><p><img src="https://blog.csdn.net/TeFuirnever/article/details/100276569?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-4&spm=1001.2101.3001.4242" alt="sklearn.ensemble.AdaBoostClassifier()函数解析（最清晰的解释）by 我是管小亮"><br><img src="https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.AdaBoostClassifier.html" alt="sklearn.ensemble.AdaBoostClassifier by scikit learn"><br><img src="https://ithelp.ithome.com.tw/articles/10197110" alt="[Day26]機器學習：KNN分類演算法！by iT邦幫忙"></p>
<h2 id="KNN"><a href="#KNN" class="headerlink" title="KNN"></a>KNN</h2><p>主要是透過 python sklearn.neighbors函式使用，裡面其中最重要的三個參數如下：</p>
<ul>
<li>n_neighbors<br>預設是5，是 KKN 演算法中已離你最近的 K 的點為主，將自己也視為此類別。</li>
<li>weights<br>以要被判斷的點為中心，有兩種方法 uniform 為只要在此範圍內的點權重都相同，而 distance 每個點權重都不同，取決於每個點到中心點的距離。</li>
<li>algorithm<br>使用的演算法，預設是 auto，也就是函式自動使用適合的演算法，brute 是暴力搜尋，當訓練集大時非常耗時，而 kd_tree and ball_tree 則是用來改善 brute，而產生的演算法。</li>
</ul>
<h3 id="程式碼-1"><a href="#程式碼-1" class="headerlink" title="程式碼"></a>程式碼</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> svm</span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> AdaBoostClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> make_classification</span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">iris = datasets.load_iris()</span><br><span class="line"></span><br><span class="line">x = iris.data</span><br><span class="line">y = iris.target</span><br><span class="line">x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=<span class="number">0.2</span>, random_state=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#只有 weights 感受到差異</span></span><br><span class="line">neigh = KNeighborsClassifier(n_neighbors=<span class="number">5</span>, algorithm=<span class="string">'kd_tree'</span>, weights=<span class="string">'distance'</span>)</span><br><span class="line">neigh.fit(x_train, y_train)</span><br><span class="line">print(<span class="string">"KNN accuracy"</span>)</span><br><span class="line">print(neigh.predict(x_test))</span><br><span class="line"></span><br><span class="line">xx = neigh.predict(x_test)</span><br><span class="line">cnt = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(x_test)):</span><br><span class="line">  <span class="keyword">if</span>(xx[i] == y_test[i]):</span><br><span class="line">    cnt+=<span class="number">1</span></span><br><span class="line">print(<span class="string">"Accuracy"</span>, cnt/len(x_test))</span><br></pre></td></tr></table></figure>

<h3 id="結果"><a href="#結果" class="headerlink" title="結果"></a>結果</h3><blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=12mD7k_q8kKndDtLLVJPPX82F1xHs4_Nu&export=download" alt=""></p>
</blockquote>
<h3 id="心得-1"><a href="#心得-1" class="headerlink" title="心得"></a>心得</h3><p>其中由於 KNN 會出來的是對於每個點的預測，於是我有在第 30行到第35行簡單的對每筆資料進行判斷。<br>其中得出我們的 weights 如果使用 distance 的準確率會比 uniform 來的更好。<br>而 n_neighbors 在這邊我們則不會感受到太大的差異，主要是因為資料量太小且 5 是標準函式預設的 n_neighbors，如果再小可能就會導致 overfitting。</p>
<p>注意：n_neighbors 不可以設定為 1，此函式出來的結果畢竟會是100%準確，沒辦法發揮此函式的功用。</p>
<h3 id="參考連結-1"><a href="#參考連結-1" class="headerlink" title="參考連結"></a>參考連結</h3><p><a href="https://tefuirnever.blog.csdn.net/article/details/99818078?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control&dist_request_id=1328769.82134.16177873596971781&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control" target="_blank" rel="noopener">sklearn.neighbors.KNeighborsClassifier()函数解析（最清晰的解释）by 我是管小亮</a><br><a href="https://scikit-learn.org/stable/modules/generated/sklearn.neighbors.KNeighborsClassifier.html" target="_blank" rel="noopener">sklearn.neighbors.KNeighborsClassifier by scikit learn</a><br><a href="https://ithelp.ithome.com.tw/articles/10197110" target="_blank" rel="noopener">[Day26]機器學習：KNN分類演算法！by iT邦幫忙</a></p>
<h2 id="心得-2"><a href="#心得-2" class="headerlink" title="心得"></a>心得</h2><p>謝謝力瑋、梓琳兩位不願其煩的一直教我QQQ，這種東西沒有學過還不太熟悉RRR。</p>
<p>總之紀錄一下自己學習的過程不是一件壞事情八(?。</p>
]]></content>
      <categories>
        <category>北科上課筆記</category>
        <category>多媒體與圖像辨識 Image Recognition</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>北科大多媒體技術與應用筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>北科資工二多媒體技術與應用 第五周團隊作業 - 對兩類別影像進 PCA 降維後送入SVM分類器進行訓練進行辨識</title>
    <url>/2021/04/12/Media_with_Image_recognition/NTUTcs_MediaHW05G01/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊工程系大二下多媒體技術與應用作業紀錄<br><font color="#dd0000">並非所有人都適用，部分對我而言稍加容易的內容並不會寫在此內。</font><br><strong>這是學習後心得的筆記，可能不太適用會未來的學生</strong></p>
<p>由於我沒有學習過裡面的理論，因此這是資工大二學生透過網路與自身理解的筆記，學習價值並不高、且可能擁有大量錯誤。</p>
</blockquote>
<a id="more"></a>

<h2 id="程式碼"><a href="#程式碼" class="headerlink" title="程式碼"></a>程式碼</h2><p>直接透過程式碼來進行說明，相信會比較好理解。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Created on Thu Apr  8 12:28:01 2021</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">@author: User</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> GridSearchCV</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> fetch_lfw_people</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> classification_report</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> confusion_matrix</span><br><span class="line"><span class="keyword">from</span> sklearn.decomposition <span class="keyword">import</span> PCA</span><br><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> SVC</span><br><span class="line"></span><br><span class="line">lfw_people = fetch_lfw_people(min_faces_per_person=<span class="number">70</span>, resize=<span class="number">0.4</span>) <span class="comment">#接收 人臉資料</span></span><br><span class="line">n_samples, h, w = lfw_people.images.shape <span class="comment">#紀錄形狀</span></span><br><span class="line"></span><br><span class="line">x = lfw_people.data <span class="comment">#人臉全部資料</span></span><br><span class="line">n_features = x.shape[<span class="number">1</span>] <span class="comment">#特徵</span></span><br><span class="line"></span><br><span class="line">y = lfw_people.target <span class="comment">#每一個人臉辨識的類別</span></span><br><span class="line">target_names = lfw_people.target_names  <span class="comment">#type</span></span><br><span class="line">n_classes = target_names.shape[<span class="number">0</span>] <span class="comment">#有幾種類別</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">"Total dataset size:"</span>)</span><br><span class="line">print(<span class="string">"n_samples: %d"</span> % n_samples)</span><br><span class="line">print(<span class="string">"n_features: %d"</span> % n_features)</span><br><span class="line">print(<span class="string">"n_classes: %d"</span> % n_classes)</span><br><span class="line"></span><br><span class="line">x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=<span class="number">0.25</span>, random_state=<span class="number">42</span>) </span><br><span class="line"><span class="comment"># 創造出訓練集與切割集</span></span><br><span class="line"></span><br><span class="line">n_components = <span class="number">150</span> <span class="comment">#降至 150 維度</span></span><br><span class="line">print(<span class="string">"Extracting the top %d eigenfaces from %d faces"</span></span><br><span class="line">      % (n_components, x_train.shape[<span class="number">0</span>]))</span><br><span class="line">t0 = time() <span class="comment">#計時</span></span><br><span class="line">pca = PCA(n_components=n_components, svd_solver=<span class="string">'randomized'</span>, </span><br><span class="line">          whiten=<span class="literal">True</span>).fit(x_train) <span class="comment">#訓練中，使用方法為 randomized</span></span><br><span class="line">print(<span class="string">"done in %0.3fs"</span> % (time() - t0)) <span class="comment">#輸出時間</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#重新定義圖片大小</span></span><br><span class="line">eigenfaces = pca.components_.reshape((n_components, h, w))</span><br><span class="line"></span><br><span class="line">print(<span class="string">"Projecting the input data on the eigenfaces orthonormal basis"</span>)</span><br><span class="line">t0 = time()</span><br><span class="line">x_train_pca = pca.transform(x_train) <span class="comment">#進行降維</span></span><br><span class="line">x_test_pca = pca.transform(x_test) <span class="comment">#進行降維</span></span><br><span class="line">print(<span class="string">"done in %0.3fs"</span> % (time() - t0))</span><br><span class="line"></span><br><span class="line"><span class="comment"># #############################################################################</span></span><br><span class="line"><span class="comment"># Train a SVM classification model</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">"Fitting the classifier to the training set"</span>)</span><br><span class="line">t0 = time()</span><br><span class="line"><span class="comment">#參數，用來告訴 gridsearchCV 的懲罰與誤差，是圖像決定好的</span></span><br><span class="line"><span class="comment">#param_grid = &#123;'C': [1e3, 5e3, 1e4, 5e4, 1e5],</span></span><br><span class="line"><span class="comment">#              'gamma': [0.0001, 0.0005, 0.001, 0.005, 0.01, 0.1], &#125;</span></span><br><span class="line">param_grid = &#123;<span class="string">'C'</span>: [<span class="number">1e3</span>, <span class="number">5e3</span>, <span class="number">1e4</span>, <span class="number">5e4</span>, <span class="number">1e5</span>],</span><br><span class="line">              <span class="string">'gamma'</span>: [<span class="number">0.01</span>, <span class="number">0.05</span>, <span class="number">0.01</span>, <span class="number">0.05</span>, <span class="number">0.01</span>, <span class="number">0.1</span>], &#125; <span class="comment">#要給 SVC 的參數</span></span><br><span class="line">clf = GridSearchCV(SVC(kernel=<span class="string">'rbf'</span>, class_weight=<span class="string">'balanced'</span>), param_grid)</span><br><span class="line">fit = clf.fit(x_train_pca, y_train) <span class="comment">#尋找最佳化</span></span><br><span class="line">print(<span class="string">"done in %0.3fs"</span> % (time() - t0))</span><br><span class="line">print(<span class="string">"Best estimator found by grid search:"</span>)</span><br><span class="line">print(clf.best_estimator_) <span class="comment">#找到最佳參數組合及其準確率。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># #############################################################################</span></span><br><span class="line"><span class="comment"># Quantitative evaluation of the model quality on the test set</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">"Predicting people's names on the test set"</span>)</span><br><span class="line">t0 = time()</span><br><span class="line">y_pred = clf.predict(x_test_pca) <span class="comment">#預測</span></span><br><span class="line">print(<span class="string">"done in %0.3fs"</span> % (time() - t0))</span><br><span class="line"></span><br><span class="line">print(classification_report(y_test, y_pred, target_names=target_names))</span><br><span class="line"><span class="comment"># 輸出這次機器學習的結果，其中 f1-score 是學習成果中最重要的分數</span></span><br><span class="line"><span class="comment"># * precision 準確率，機器學習判定是正確圖片的準確率</span></span><br><span class="line"><span class="comment"># * recall 精準度，抽取出來的樣本，有多少樣本是有被視為正確的。</span></span><br><span class="line"><span class="comment"># 舉例：google 大衛的筆記，理論上要有 70 筆資料是關於大衛的筆記，卻只有輸出 40 筆，比例就是 40/70。</span></span><br><span class="line"><span class="comment">#print(confusion_matrix(y_test, y_pred, labels=range(n_classes)))</span></span><br></pre></td></tr></table></figure>


<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://scikit-learn.org/stable/auto_examples/applications/plot_face_recognition.html#sphx-glr-auto-examples-applications-plot-face-recognition-py" target="_blank" rel="noopener">Faces recognition example using eigenfaces and SVMs by scikit-learn</a><br><a href="https://scikit-learn.org/stable/modules/generated/sklearn.decomposition.PCA.html" target="_blank" rel="noopener">sklearn.decomposition.PCA by scikit-learn</a><br><a href="https://www.cnblogs.com/178mz/p/8558435.html" target="_blank" rel="noopener">机器学习classification_report方法及precision精确率和recall召回率 说明 by cnblogs</a><br><a href="https://scikit-learn.org/stable/modules/generated/sklearn.metrics.classification_report.html" target="_blank" rel="noopener">sklearn.metrics.classification_report by scikit-learn</a><br><a href="https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.GridSearchCV.html" target="_blank" rel="noopener">sklearn.model_selection.GridSearchCV by scikit-learn</a><br><a href="https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.train_test_split.html" target="_blank" rel="noopener">sklearn.model_selection.train_test_split by scikit-learn</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>機器學習裡面大量的數學公式與模型，我都還不懂，現在的我只是先按照著範例刻畫出正確的結果來，希望未來的我可以懂那些理論，因為我其實都不太懂這些理論。但是被要求做出此作業時，其實上手程度很難，某種情況來說算是壓力很大。</p>
<p>總之，希望我能夠至少大概理解怎麼運作，之後如果有機會在進行底層實作，我一定就能夠了解更多！<br>現在只能大概理解語法在幹嘛，而不能知道怎麼運作。</p>
<h2 id="無註解程式碼"><a href="#無註解程式碼" class="headerlink" title="無註解程式碼"></a>無註解程式碼</h2><p>提供無註解程式碼</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Created on Thu Apr  8 12:28:01 2021</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">@author: User</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> GridSearchCV</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> fetch_lfw_people</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> classification_report</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> confusion_matrix</span><br><span class="line"><span class="keyword">from</span> sklearn.decomposition <span class="keyword">import</span> PCA</span><br><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> SVC</span><br><span class="line"></span><br><span class="line">lfw_people = fetch_lfw_people(min_faces_per_person=<span class="number">70</span>, resize=<span class="number">0.4</span>)</span><br><span class="line">n_samples, h, w = lfw_people.images.shape</span><br><span class="line"></span><br><span class="line">x = lfw_people.data</span><br><span class="line">n_features = x.shape[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">y = lfw_people.target</span><br><span class="line">target_names = lfw_people.target_names</span><br><span class="line">n_classes = target_names.shape[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">print(<span class="string">"Total dataset size:"</span>)</span><br><span class="line">print(<span class="string">"n_samples: %d"</span> % n_samples)</span><br><span class="line">print(<span class="string">"n_features: %d"</span> % n_features)</span><br><span class="line">print(<span class="string">"n_classes: %d"</span> % n_classes)</span><br><span class="line"></span><br><span class="line">x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=<span class="number">0.25</span>, random_state=<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line">n_components = <span class="number">150</span></span><br><span class="line">print(<span class="string">"Extracting the top %d eigenfaces from %d faces"</span></span><br><span class="line">      % (n_components, x_train.shape[<span class="number">0</span>]))</span><br><span class="line">t0 = time()</span><br><span class="line">pca = PCA(n_components=n_components, svd_solver=<span class="string">'randomized'</span>, </span><br><span class="line">          whiten=<span class="literal">True</span>).fit(x_train) <span class="comment">#降維至 150 層</span></span><br><span class="line">print(<span class="string">"done in %0.3fs"</span> % (time() - t0))</span><br><span class="line"></span><br><span class="line"><span class="comment">#重新定義圖片大小</span></span><br><span class="line">eigenfaces = pca.components_.reshape((n_components, h, w))</span><br><span class="line"></span><br><span class="line">print(<span class="string">"Projecting the input data on the eigenfaces orthonormal basis"</span>)</span><br><span class="line">t0 = time()</span><br><span class="line">x_train_pca = pca.transform(x_train) <span class="comment">#進行降維</span></span><br><span class="line">x_test_pca = pca.transform(x_test) <span class="comment">#進行降維</span></span><br><span class="line">print(<span class="string">"done in %0.3fs"</span> % (time() - t0))</span><br><span class="line"></span><br><span class="line"><span class="comment"># #############################################################################</span></span><br><span class="line"><span class="comment"># Train a SVM classification model</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">"Fitting the classifier to the training set"</span>)</span><br><span class="line">t0 = time()</span><br><span class="line"><span class="comment">#參數，用來告訴 gridsearchCV 的懲罰與誤差，是圖像決定好的</span></span><br><span class="line"><span class="comment">#param_grid = &#123;'C': [1e3, 5e3, 1e4, 5e4, 1e5],</span></span><br><span class="line"><span class="comment">#              'gamma': [0.0001, 0.0005, 0.001, 0.005, 0.01, 0.1], &#125;</span></span><br><span class="line">param_grid = &#123;<span class="string">'C'</span>: [<span class="number">1e3</span>, <span class="number">5e3</span>, <span class="number">1e4</span>, <span class="number">5e4</span>, <span class="number">1e5</span>],</span><br><span class="line">              <span class="string">'gamma'</span>: [<span class="number">0.01</span>, <span class="number">0.05</span>, <span class="number">0.01</span>, <span class="number">0.05</span>, <span class="number">0.01</span>, <span class="number">0.1</span>], &#125;</span><br><span class="line">clf = GridSearchCV(SVC(kernel=<span class="string">'rbf'</span>, class_weight=<span class="string">'balanced'</span>), param_grid)</span><br><span class="line">fit = clf.fit(x_train_pca, y_train) <span class="comment">#開始訓練，找最適合的</span></span><br><span class="line">print(<span class="string">"done in %0.3fs"</span> % (time() - t0))</span><br><span class="line">print(<span class="string">"Best estimator found by grid search:"</span>)</span><br><span class="line">print(clf.best_estimator_) <span class="comment">#找到最佳參數組合及其準確率。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># #############################################################################</span></span><br><span class="line"><span class="comment"># Quantitative evaluation of the model quality on the test set</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">"Predicting people's names on the test set"</span>)</span><br><span class="line">t0 = time()</span><br><span class="line">y_pred = clf.predict(x_test_pca) <span class="comment">#預測</span></span><br><span class="line">print(<span class="string">"done in %0.3fs"</span> % (time() - t0))</span><br><span class="line"></span><br><span class="line">print(classification_report(y_test, y_pred, target_names=target_names))</span><br><span class="line"><span class="comment">#print(confusion_matrix(y_test, y_pred, labels=range(n_classes)))</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>北科上課筆記</category>
        <category>多媒體與圖像辨識 Image Recognition</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>北科大多媒體技術與應用筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>北科資工二多媒體技術與應用 第四周對於 SVM 的學習紀錄</title>
    <url>/2021/04/07/Media_with_Image_recognition/NTUTcs_MediaHW04_Note/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊工程系大二下多媒體技術與應用作業紀錄<br><font color="#dd0000">並非所有人都適用，部分對我而言稍加容易的內容並不會寫在此內。</font><br><strong>這是學習後心得的筆記，可能不太適用會未來的學生</strong></p>
<p>由於我沒有學習過裡面的理論，因此這是資工大二學生透過網路與自身理解的筆記，學習價值並不高、且可能擁有大量錯誤。</p>
</blockquote>
<a id="more"></a>

<h2 id="學習紀錄"><a href="#學習紀錄" class="headerlink" title="學習紀錄"></a>學習紀錄</h2><ul>
<li>給予越多的特徵，會有不同的結果，但規律可能不好找</li>
<li>但越多的特徵給予 SVM 會使準確率變高</li>
<li>kernel 使用 poly 方法，準確率最高，Sigmoid 則是最差</li>
<li>C 值越大(對於錯誤的忍受度)，學習的準確率越高。但對測試集沒有任何影響</li>
<li>gamma 盡量使用 scale，但是在 <code>kernel=&#39;linear&#39;</code>時則完全沒有用處，linear 不需要用到 gamma 參數。</li>
<li><code>train_test_split</code> 的 test_size 越大時準確率越低。</li>
</ul>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>謝謝力瑋、梓琳拯救我的多媒體，兩位大佬QAQ，我現在還對於多媒體沒有很了解，希望能夠趕快追上QQQQ。</p>
<p>題外話，py 真的讓我用的不太上手RRR，numpy 跟 list 沒想到在 print 出來時長的一樣，但他們本身型態卻不同，弱型態語言我還沒有辦法完全掌控R。</p>
<p>總之還是謝謝二位了QQQ。</p>
]]></content>
      <categories>
        <category>北科上課筆記</category>
        <category>多媒體與圖像辨識 Image Recognition</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>北科大多媒體技術與應用筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>北科資工二多媒體技術與應用 第三周作業-影像金字塔混和圖片</title>
    <url>/2021/03/25/Media_with_Image_recognition/NTUTcs_MediaHW03-4/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊工程系大二下多媒體技術與應用作業紀錄<br><font color="#dd0000">並非所有人都適用，部分對我而言稍加容易的內容並不會寫在此內。</font><br><strong>這是學習後心得的筆記，可能不太適用會未來的學生</strong></p>
<p>由於我沒有學習過裡面的理論，因此這是資工大二學生透過網路與自身理解的筆記，學習價值並不高、且可能擁有大量錯誤。</p>
</blockquote>
<a id="more"></a>

<h2 id="題目如下，用圖片"><a href="#題目如下，用圖片" class="headerlink" title="題目如下，用圖片"></a>題目如下，用圖片</h2><blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1y5bEeELIz9zY-7gTMm36t5jzdDvNBsuX&export=download" alt=""></p>
</blockquote>
<h2 id="此題做法"><a href="#此題做法" class="headerlink" title="此題做法"></a>此題做法</h2><p>這是一題很酷的題目，你會學到<strong>影像金字塔</strong>。</p>
<h3 id="甚麼是影像金字塔"><a href="#甚麼是影像金字塔" class="headerlink" title="甚麼是影像金字塔"></a>甚麼是影像金字塔</h3><p>影像金字塔透過將圖片放大縮小，而越將圖片放大就是越底層的金字塔，縮小就是越下層的金字塔，跟金字塔的切面面積有關。</p>
<h4 id="高斯金字塔"><a href="#高斯金字塔" class="headerlink" title="高斯金字塔"></a>高斯金字塔</h4><p>透過<a href="https://zknie.com/knowledge_base/opencv%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B06-%E5%9B%BE%E5%83%8F%E9%87%91%E5%AD%97%E5%A1%94/2020/11/02/" target="_blank" rel="noopener">公式</a>得出，不斷地使用此公式進行放大或縮小，結果如下</p>
<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1bGdBBCPh5LHf_YtGeq0s9IjAf-YaHODg&export=download" alt=""><br><a href="https://zknie.com/knowledge_base/opencv%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B06-%E5%9B%BE%E5%83%8F%E9%87%91%E5%AD%97%E5%A1%94/2020/11/02/" target="_blank" rel="noopener">蒙面西红柿取得，如果有需要移除請跟我說</a></p>
</blockquote>
<p>但有個特別重要的重點，<strong>沒有辦法用縮小後的圖片完整還原放大的圖片</strong>，很多點被壓縮，要還原也不知道要怎麼還原，因此是縮小的圖片不斷放大就會越來越模糊</p>
<h4 id="拉普拉斯金字塔"><a href="#拉普拉斯金字塔" class="headerlink" title="拉普拉斯金字塔"></a>拉普拉斯金字塔</h4><p>必須先建立高斯金字塔才能建立拉普拉斯金字塔。</p>
<p>此方法主要是對同樣大小的高斯金字塔，進行操作，其操作方式如下</p>
<ul>
<li>將原始圖片設為最底層的金字塔</li>
<li>設定要縮小的次數</li>
<li>記錄每層高斯金字塔的縮小</li>
<li>將上一層的高斯金字塔放大後與當前圖層進行圖片減法，從最上層開始，也就是圖片 size 最小的地方</li>
</ul>
<p>透過此方式將高斯金字塔上一次的縮小進行放大後在跟當前的圖層進行圖片減法，所遺失的點就是拉普拉斯金字塔</p>
<blockquote>
<p>圖片說明<br><img src="https://drive.google.com/u/2/uc?id=1RwskzYpTpXW23cKn1U4OAbb9xBgZUkAV&export=download" alt=""><br><a href="https://zknie.com/knowledge_base/opencv%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B06-%E5%9B%BE%E5%83%8F%E9%87%91%E5%AD%97%E5%A1%94/2020/11/02/" target="_blank" rel="noopener">蒙面西红柿取得，如果有需要移除請跟我說</a></p>
</blockquote>
<h3 id="回歸解法"><a href="#回歸解法" class="headerlink" title="回歸解法"></a>回歸解法</h3><p>說了這麼多，該來了解這題怎麼做了。</p>
<p>拉普拉斯金字塔是高斯金字塔放大所遺失的點，這時我們可以透過拉普拉斯金字塔來補足這些遺失的點，理論上可以回到離圖片一樣的狀態。</p>
<p>但是在高斯金字塔再放大時，可不知道拉普拉斯金字塔會補足哪些點，所以會一視同仁地把點放大。此時再加上拉普拉斯金字塔的點後(進行圖片相減)，此時那些地方就會被中和成高斯金字塔的放大點與拉普拉斯金字塔地點，達到平滑的效果，就可以讓圖片切割的地方看起來更加圓滑。</p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://blog.csdn.net/weixin_45668655/article/details/103889235" target="_blank" rel="noopener">opencv-图像融合（高斯金字塔，拉普拉斯金字塔） by Bonjour_Amy</a><br><a href="https://blog.csdn.net/u012609509/article/details/70319293" target="_blank" rel="noopener">np.vstack, np.hstack by cltdevelop</a><br><a href="https://zknie.com/knowledge_base/opencv%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B06-%E5%9B%BE%E5%83%8F%E9%87%91%E5%AD%97%E5%A1%94/2020/11/02/" target="_blank" rel="noopener">OpenCV学习笔记(6)——图像金字塔 by 蒙面西红柿</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>學習到了圖像金字塔是本題的最大收穫，要謝謝郭梓琳給我一個網頁裡面有教我怎麼做QQQ，不然我應該還要花很多時間才能把這題給解開、搞懂。</p>
<p>總之，很開心有他這個隊友，讚啦。<br>希望他可以容忍這麼不成材我的XD，愛睡覺又很拖拉。</p>
<h2 id="程式碼"><a href="#程式碼" class="headerlink" title="程式碼"></a>程式碼</h2><p>我們這邊製作六成的圖像金字塔，就能做出與題目答案類似的金字塔。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Created on Thu Mar 25 11:28:28 2021</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">@author: user</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment">#讀圖片檔案，下面會放題目所需要的圖片</span></span><br><span class="line">a = cv2.imread(<span class="string">"./pic/apple.jpg"</span>)</span><br><span class="line">b = cv2.imread(<span class="string">"./pic/orange.jpg"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#目標是圖片合併，因此我們先建兩個高斯金字塔</span></span><br><span class="line">gaussA = [a.copy()]</span><br><span class="line">gaussB = [b.copy()]</span><br><span class="line">copyA = a.copy()</span><br><span class="line">copyB = b.copy()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6</span>): <span class="comment"># more small</span></span><br><span class="line">  copyA = cv2.pyrDown(copyA) <span class="comment">#縮小，建立金字塔上層</span></span><br><span class="line">  copyB = cv2.pyrDown(copyB)</span><br><span class="line">  </span><br><span class="line">  gaussA.append(copyA)</span><br><span class="line">  gaussB.append(copyB)</span><br><span class="line"></span><br><span class="line">copyA = gaussA[<span class="number">5</span>] <span class="comment">#稍微注意，拉普拉斯金字塔由於編寫方便，我們的陣列值越大時圖層越小，金字塔相反</span></span><br><span class="line">laplacianA = [copyA] <span class="comment">#建立拉普拉斯金字塔</span></span><br><span class="line">copyB = gaussB[<span class="number">5</span>]</span><br><span class="line">laplacianB = [copyB]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>, <span class="number">0</span>, <span class="number">-1</span>): <span class="comment">#建立拉普拉斯金字塔</span></span><br><span class="line">  tempA = cv2.pyrUp(gaussA[i]) <span class="comment">#將當前高斯金字塔放大</span></span><br><span class="line">  tempB = cv2.pyrUp(gaussB[i])</span><br><span class="line"></span><br><span class="line">  subA = cv2.subtract(gaussA[i<span class="number">-1</span>], tempA) <span class="comment">#放大後，在跟下一層的高斯金字塔做減法得出拉普拉斯金字塔</span></span><br><span class="line">  subB = cv2.subtract(gaussB[i<span class="number">-1</span>], tempB)</span><br><span class="line">  laplacianA.append(subA) <span class="comment">#記錄起來</span></span><br><span class="line">  laplacianB.append(subB)</span><br><span class="line">  <span class="comment">#cv2.imshow("subA", subA)</span></span><br><span class="line">  <span class="comment">#cv2.waitKey(0)</span></span><br><span class="line"></span><br><span class="line">stack = [] <span class="comment">#要被疊加的圖層放置處</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> itA, itB <span class="keyword">in</span> zip(laplacianA, laplacianB): <span class="comment">#合併兩個拉普拉斯金字塔</span></span><br><span class="line">  h, w, ch = itA.shape <span class="comment">#圖片長、寬、通道</span></span><br><span class="line">  merge = np.hstack((itA[<span class="number">0</span>:h, <span class="number">0</span>:(w // <span class="number">2</span>)], itB[<span class="number">0</span>:h, (w // <span class="number">2</span>):w])) <span class="comment">#將圖片進行合併</span></span><br><span class="line">  <span class="comment">#注意，第二張圖片是要右半邊</span></span><br><span class="line">  stack.append(merge) <span class="comment">#紀錄</span></span><br><span class="line">  </span><br><span class="line">result = stack[<span class="number">0</span>] <span class="comment">#一開使放入最頂端金字塔的圖層，特別注意第 0 層是沒有被減法過的圖層</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">6</span>): </span><br><span class="line">  result = cv2.pyrUp(result) <span class="comment">#放大圖層</span></span><br><span class="line">  result = cv2.add(result, stack[i]) <span class="comment">#疊加我們的拉普拉斯金字塔</span></span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">"a"</span>, a)</span><br><span class="line">cv2.imshow(<span class="string">"result"</span>, result) <span class="comment">#輸出完整圖片</span></span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv.imwrite(<span class="string">'result.jpg'</span>,result)</span><br></pre></td></tr></table></figure>

<h2 id="題目資料"><a href="#題目資料" class="headerlink" title="題目資料"></a>題目資料</h2><blockquote>
<p>apple<br><img src="https://drive.google.com/u/2/uc?id=1vJakdmCZuyCBbX7A3FHsIDi7K6Co5vRE&export=download" alt=""></p>
</blockquote>
<blockquote>
<p>orange<br><img src="https://drive.google.com/u/2/uc?id=1rXZ3YuzHhbMx1IfdEHkQ3ug2pvzRhWA4&export=download" alt=""></p>
</blockquote>
<blockquote>
<p>result<br><img src="https://drive.google.com/u/2/uc?id=1CtDnQ-YeOa1gd7oHSh1iIM9MZW-COc97&export=download" alt=""></p>
</blockquote>
]]></content>
      <categories>
        <category>北科上課筆記</category>
        <category>多媒體與圖像辨識 Image Recognition</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>北科大多媒體技術與應用筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>北科資工二多媒體技術與應用 第五周個人作業</title>
    <url>/2021/04/12/Media_with_Image_recognition/NTUTcs_MediaHW05t01/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊工程系大二下多媒體技術與應用作業紀錄<br><font color="#dd0000">並非所有人都適用，部分對我而言稍加容易的內容並不會寫在此內。</font><br><strong>這是學習後心得的筆記，可能不太適用會未來的學生</strong></p>
<p>由於我沒有學習過裡面的理論，因此這是資工大二學生透過網路與自身理解的筆記，學習價值並不高、且可能擁有大量錯誤。</p>
</blockquote>
<a id="more"></a>

<h2 id="QUESTION-在Python中引入scikit-learn函式庫，利用函式庫中所提供的函式進行練習，觀察HOG方法所提取出的特徵點，在可視化表現上有何種特色，並且調整HOG函式中的各項參數，觀察是否有甚麼差異。"><a href="#QUESTION-在Python中引入scikit-learn函式庫，利用函式庫中所提供的函式進行練習，觀察HOG方法所提取出的特徵點，在可視化表現上有何種特色，並且調整HOG函式中的各項參數，觀察是否有甚麼差異。" class="headerlink" title="QUESTION: 在Python中引入scikit-learn函式庫，利用函式庫中所提供的函式進行練習，觀察HOG方法所提取出的特徵點，在可視化表現上有何種特色，並且調整HOG函式中的各項參數，觀察是否有甚麼差異。"></a>QUESTION: 在Python中引入scikit-learn函式庫，利用函式庫中所提供的函式進行練習，觀察HOG方法所提取出的特徵點，在可視化表現上有何種特色，並且調整HOG函式中的各項參數，觀察是否有甚麼差異。</h2><p>hog 的語法如下</p>
<ul>
<li>Image 圖片本身資料，num.array 格式</li>
<li>Orientation = 8，也就是每個 cell 的周遭</li>
<li>pixels_per_cell 每一個單位的像素大小</li>
<li>cells_per_block 每組單位的大小</li>
<li>visualize 是否 return hog 特徵影像</li>
<li>multichannel 支援多通道</li>
</ul>
<p>在測試的過程中，發現了 pixels_per_cell 是最重要的參數，他決定了產生出來的圖片像素大小，如果 pixels_per_cell 越小則運算速度也會越慢，邊緣越仔細，但如果越大則反而沒有辦法清楚描繪邊緣，因此要找好適合的大小。</p>
<p>cells_per_block 我嘗試過，10、1、16其實我看不太出來差異，因此我認為他們並沒有太大差異。</p>
<p>Orientation 在 8 的情況下，明顯比起 Orientation = 4 的時候跟詳細，跟清楚地描繪邊緣。</p>
<p>透過查詢老師的講義，基本上沒有太大困難，只有前期的茫然不太清楚要做甚麼。</p>
<h2 id="QUESTION-請想出一種情境，適合使用HOG-SVM進行分類，並說明原因。"><a href="#QUESTION-請想出一種情境，適合使用HOG-SVM進行分類，並說明原因。" class="headerlink" title="QUESTION:請想出一種情境，適合使用HOG+SVM進行分類，並說明原因。"></a>QUESTION:請想出一種情境，適合使用HOG+SVM進行分類，並說明原因。</h2><p>老師的講義有提過在行人辨識是很適合使用HOG+SVM進行分類，我認為如果依照這樣，根據現在最熱的火車事故新聞，我認為 HOG+SVM 應該也可以在火車行駛中辨識人或是大型雜物，如果有辨識到就進行剎車，相信一定可以拯救很多人的生命。</p>
]]></content>
      <categories>
        <category>北科上課筆記</category>
        <category>多媒體與圖像辨識 Image Recognition</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>北科大多媒體技術與應用筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>北科資工二多媒體技術與應用 第五周團隊作業 - 對兩類別影像進行HOG特徵提取並送入SVM分類器進行訓練進行辨識</title>
    <url>/2021/04/18/Media_with_Image_recognition/NTUTcs_MediaHW05G02/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊工程系大二下多媒體技術與應用作業紀錄<br><font color="#dd0000">並非所有人都適用，部分對我而言稍加容易的內容並不會寫在此內。</font><br><strong>這是學習後心得的筆記，可能不太適用會未來的學生</strong></p>
<p>由於我沒有學習過裡面的理論，因此這是資工大二學生透過網路與自身理解的筆記，學習價值並不高、且可能擁有大量錯誤。</p>
</blockquote>
<a id="more"></a>

<h2 id="題目要求"><a href="#題目要求" class="headerlink" title="題目要求"></a>題目要求</h2><blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1EffGtNGwd_bo4fO4sfsw7eWzRsGTM5K-&export=download" alt=""></p>
</blockquote>
<h2 id="hog-簡介"><a href="#hog-簡介" class="headerlink" title="hog 簡介"></a>hog 簡介</h2><p>為 Dalad and Triggs 提出的一種在電腦視覺與影像處理中用來檢測物體特徵，善於<strong>描述物件的輪廓，並降低光影變化的影響</strong></p>
<h3 id="SIFT-優點"><a href="#SIFT-優點" class="headerlink" title="SIFT 優點"></a>SIFT 優點</h3><ul>
<li>可以將 cell 放大，提高性能</li>
<li>對於<strong>影像幾何與光學變化都能保持很好的不變性</strong></li>
<li>對於細微的動作可以將 cell 放大，來進行忽略而不影響檢測結果</li>
</ul>
<h2 id="資料集"><a href="#資料集" class="headerlink" title="資料集"></a>資料集</h2><p>這裡我們採用兩組資料集來使用 hog 特徵辨識</p>
<ul>
<li><a href="https://drive.google.com/drive/folders/1YhFEnbyQ3NvUd08Y5A8Dz09Bn5ZE-BSw?usp=sharing" target="_blank" rel="noopener">貓與狗</a></li>
<li><a href="https://drive.google.com/drive/folders/1P1oG5N2q3SCGgKMaDC4RyuBvo3h7dAZa?usp=sharing" target="_blank" rel="noopener">多拉A夢與名偵探柯南</a></li>
</ul>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>自從學習過天佑的程式碼，我對於機器學習有著初步認識，但只僅限在應用上XD，大該知道要怎麼進行訓練、辨識了XD。</p>
<p>總之，謝謝在學習多媒體技術與應用時一路幫助過我的人，如果沒有他們幫助我，我可能到現在還甚麼都不會。</p>
<p>在最後一刻還沒有把作業做完，因為之前理解錯了題目意思，最後還需要助教幫忙再多開 10 分鐘，來上傳作業並將作業完成，真的是非常感謝助教QQQQQ。</p>
<p><del>我自己就搞錯了，花一堆時間除錯QQQQ</del></p>
<p>也謝謝發明此演算法的大師，可以讓我運用，讓我學會此應用方式，沒有大家我都做不好QQ。</p>
<h2 id="參考來源"><a href="#參考來源" class="headerlink" title="參考來源"></a>參考來源</h2><p>北科大電資學士班林天佑</p>
<h2 id="程式碼"><a href="#程式碼" class="headerlink" title="程式碼"></a>程式碼</h2><p>直接透過程式碼來進行說明，相信會比較好理解。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Created on Thu Apr 8 10:58:26 2021</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> skimage.feature <span class="keyword">import</span> hog</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> fetch_lfw_people</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> svm</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line">data_amount = <span class="number">100</span> <span class="comment">#每一個資料集總數 100</span></span><br><span class="line">train_amount = <span class="number">90</span> <span class="comment">#訓練資料集筆數</span></span><br><span class="line">test_amount = <span class="number">10</span> <span class="comment">#訓練資料集筆數</span></span><br><span class="line"></span><br><span class="line">dogs = list()</span><br><span class="line">cats = list()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,data_amount+<span class="number">1</span>): <span class="comment">#讀取狗原始資料</span></span><br><span class="line">  image = cv2.imread(<span class="string">"../resize_dog/dog_%.3d.jpg"</span> % i)</span><br><span class="line">  dogs.append(image)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,data_amount+<span class="number">1</span>): <span class="comment">#讀取貓原始資料</span></span><br><span class="line">  image = cv2.imread(<span class="string">"../resize_cat/cat_%.3d.jpg"</span> % i)  </span><br><span class="line">  cats.append(image)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 如果要讀柯南與哆啦A夢使用這邊的資料</span></span><br><span class="line"><span class="comment"># for i in range(1,data_amount+1):</span></span><br><span class="line"><span class="comment">#   image = cv2.imread("../conan/images (%d).jpg" % i)</span></span><br><span class="line"><span class="comment">#   image = cv2.resize(image, (349,256))</span></span><br><span class="line"><span class="comment">#   dogs.append(image)</span></span><br><span class="line"><span class="comment"># for i in range(1,data_amount+1):</span></span><br><span class="line"><span class="comment">#   image = cv2.imread("../Doraemon/images (%d).jpg" % i)  </span></span><br><span class="line"><span class="comment">#   image = cv2.resize(image, (349,256))</span></span><br><span class="line"><span class="comment">#   cats.append(image)</span></span><br><span class="line"></span><br><span class="line">hog_dogs = list()</span><br><span class="line">hog_cats = list()</span><br><span class="line"><span class="keyword">for</span> image <span class="keyword">in</span> dogs: <span class="comment">#將狗的原始資料透過 hog 描繪邊緣</span></span><br><span class="line">  fd, hog_image = hog(</span><br><span class="line">      image,</span><br><span class="line">      orientations=<span class="number">8</span>,</span><br><span class="line">      pixels_per_cell=(<span class="number">9</span>,<span class="number">9</span>),</span><br><span class="line">      cells_per_block=(<span class="number">1</span>,<span class="number">1</span>),</span><br><span class="line">      visualize=<span class="literal">True</span>,</span><br><span class="line">      )</span><br><span class="line">  hog_dogs.append(fd)</span><br><span class="line"><span class="keyword">for</span> image <span class="keyword">in</span> cats: <span class="comment">#將貓的原始資料透過 hog 描繪邊緣</span></span><br><span class="line">  fd, hog_image = hog( </span><br><span class="line">      image,</span><br><span class="line">      orientations=<span class="number">8</span>,</span><br><span class="line">      pixels_per_cell=(<span class="number">9</span>,<span class="number">9</span>),</span><br><span class="line">      cells_per_block=(<span class="number">1</span>,<span class="number">1</span>),</span><br><span class="line">      visualize=<span class="literal">True</span>,</span><br><span class="line">      )</span><br><span class="line">  hog_cats.append(fd)      </span><br><span class="line">  </span><br><span class="line"><span class="comment"># train model</span></span><br><span class="line">train_target_dog = [<span class="number">0</span>] * train_amount <span class="comment">#狗的訓練集數</span></span><br><span class="line">train_target_cat = [<span class="number">1</span>] * train_amount <span class="comment">#貓的訓練集數</span></span><br><span class="line">train_target = train_target_dog + train_target_cat <span class="comment">#合併</span></span><br><span class="line">train_images = hog_dogs[:train_amount] + hog_cats[:train_amount] <span class="comment">#圖片合併</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># test model</span></span><br><span class="line">test_target_dog = [<span class="number">0</span>] * test_amount <span class="comment">#狗的測試集數</span></span><br><span class="line">test_target_cat = [<span class="number">1</span>] * test_amount <span class="comment">#貓的測試集數</span></span><br><span class="line">test_target = test_target_dog + test_target_cat <span class="comment">#合併</span></span><br><span class="line">test_images = hog_dogs[-test_amount:] + hog_cats[-test_amount:] <span class="comment">#圖片合併</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#svm train</span></span><br><span class="line">clf = svm.SVC(kernel=<span class="string">"linear"</span>, C=<span class="number">1</span>, gamma=<span class="string">"auto"</span>) <span class="comment">#設定方法</span></span><br><span class="line">clf.fit(train_images, train_target) <span class="comment">#進行訓練</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">"accuracy"</span>)</span><br><span class="line">print(<span class="string">"train:"</span>, clf.score(train_images, train_target)) <span class="comment">#訓練集準確度</span></span><br><span class="line">print(<span class="string">"test:"</span>, clf.score(test_images, test_target), <span class="string">"\n"</span>) <span class="comment">#測試集準確度</span></span><br></pre></td></tr></table></figure>

<h2 id="結果"><a href="#結果" class="headerlink" title="結果"></a>結果</h2><h3 id="貓與狗"><a href="#貓與狗" class="headerlink" title="貓與狗"></a>貓與狗</h3><blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1A5227wHecgGpNPFMY0Gty2fG7DcEcODR&export=download" alt=""></p>
</blockquote>
<h3 id="多拉A夢與柯南"><a href="#多拉A夢與柯南" class="headerlink" title="多拉A夢與柯南"></a>多拉A夢與柯南</h3><blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1v3-SHWzi0jDnHTCzjmM_H3DGdqn2Yq-v&export=download" alt=""></p>
</blockquote>
<h2 id="圖片辨識後結論"><a href="#圖片辨識後結論" class="headerlink" title="圖片辨識後結論"></a>圖片辨識後結論</h2><h3 id="貓與狗-1"><a href="#貓與狗-1" class="headerlink" title="貓與狗"></a>貓與狗</h3><p>由於 hog 屬於輪廓辨識，小貓與小狗的體型較為類似，而我們的資料集圖片中小貓與小狗的比例佔大多數，因此 hog 辨識較差。</p>
<p>我認為如果改用成年大狗與小貓，那辨識程度就會更高</p>
<h3 id="多拉A夢與柯南-1"><a href="#多拉A夢與柯南-1" class="headerlink" title="多拉A夢與柯南"></a>多拉A夢與柯南</h3><p>這組的準確程度較高，因為多拉A夢的輪廓較圓滑、柯南的輪廓比較偏瘦，因此倆著在透過輪廓辨識時，比較容易辨識出來。</p>
<p>測試集成功率達到 0.875，很高的辨識率，我認為算是蠻不錯的成績</p>
<h2 id="無註解程式碼"><a href="#無註解程式碼" class="headerlink" title="無註解程式碼"></a>無註解程式碼</h2><p>提供無註解程式碼</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Created on Thu Apr 8 10:58:26 2021</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment">#hog 比較容易受到外音干擾，旋轉光影也會干擾</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> skimage.feature <span class="keyword">import</span> hog</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> fetch_lfw_people</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> svm</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line">data_amount = <span class="number">100</span></span><br><span class="line">train_amount = <span class="number">80</span></span><br><span class="line">test_amount = <span class="number">20</span></span><br><span class="line"></span><br><span class="line">dogs = list()</span><br><span class="line">cats = list()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,data_amount+<span class="number">1</span>):</span><br><span class="line">  image = cv2.imread(<span class="string">"../resize_dog/dog_%.3d.jpg"</span> % i)</span><br><span class="line">  dogs.append(image)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,data_amount+<span class="number">1</span>):</span><br><span class="line">  image = cv2.imread(<span class="string">"../resize_cat/cat_%.3d.jpg"</span> % i)  </span><br><span class="line">  cats.append(image)</span><br><span class="line"></span><br><span class="line"><span class="comment">#for i in range(1,data_amount+1):</span></span><br><span class="line"><span class="comment">#  image = cv2.imread("../conan/images (%d).jpg" % i)</span></span><br><span class="line"><span class="comment">#  image = cv2.resize(image, (349,256))</span></span><br><span class="line"><span class="comment">#  dogs.append(image)</span></span><br><span class="line"><span class="comment">#for i in range(1,data_amount+1):</span></span><br><span class="line"><span class="comment">#  image = cv2.imread("../Doraemon/images (%d).jpg" % i)  </span></span><br><span class="line"><span class="comment">#  image = cv2.resize(image, (349,256))</span></span><br><span class="line"><span class="comment">#  cats.append(image)</span></span><br><span class="line"></span><br><span class="line">hog_dogs = list()</span><br><span class="line">hog_cats = list()</span><br><span class="line"><span class="keyword">for</span> image <span class="keyword">in</span> dogs:</span><br><span class="line">  fd, hog_image = hog(</span><br><span class="line">      image,</span><br><span class="line">      orientations=<span class="number">8</span>,</span><br><span class="line">      pixels_per_cell=(<span class="number">9</span>,<span class="number">9</span>),</span><br><span class="line">      cells_per_block=(<span class="number">1</span>,<span class="number">1</span>),</span><br><span class="line">      visualize=<span class="literal">True</span>,</span><br><span class="line">      )</span><br><span class="line">  hog_dogs.append(fd)</span><br><span class="line"><span class="keyword">for</span> image <span class="keyword">in</span> cats:</span><br><span class="line">  fd, hog_image = hog(</span><br><span class="line">      image,</span><br><span class="line">      orientations=<span class="number">8</span>,</span><br><span class="line">      pixels_per_cell=(<span class="number">9</span>,<span class="number">9</span>),</span><br><span class="line">      cells_per_block=(<span class="number">1</span>,<span class="number">1</span>),</span><br><span class="line">      visualize=<span class="literal">True</span>,</span><br><span class="line">      )</span><br><span class="line">  hog_cats.append(fd)      </span><br><span class="line">  </span><br><span class="line"><span class="comment"># train model</span></span><br><span class="line">train_target_dog = [<span class="number">0</span>] * train_amount</span><br><span class="line">train_target_cat = [<span class="number">1</span>] * train_amount</span><br><span class="line">train_target = train_target_dog + train_target_cat</span><br><span class="line">train_images = hog_dogs[:train_amount] + hog_cats[:train_amount]</span><br><span class="line"></span><br><span class="line"><span class="comment"># test model</span></span><br><span class="line">test_target_dog = [<span class="number">0</span>] * test_amount</span><br><span class="line">test_target_cat = [<span class="number">1</span>] * test_amount</span><br><span class="line">test_target = test_target_dog + test_target_cat      </span><br><span class="line">test_images = hog_dogs[-test_amount:] + hog_cats[-test_amount:] <span class="comment">#last</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#svm train</span></span><br><span class="line">clf = svm.SVC(kernel=<span class="string">"linear"</span>, C=<span class="number">1</span>, gamma=<span class="string">"auto"</span>)</span><br><span class="line">clf.fit(train_images, train_target)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"accuracy"</span>)</span><br><span class="line">print(<span class="string">"train:"</span>, clf.score(train_images, train_target))</span><br><span class="line">print(<span class="string">"test:"</span>, clf.score(test_images, test_target), <span class="string">"\n"</span>)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>北科上課筆記</category>
        <category>多媒體與圖像辨識 Image Recognition</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>北科大多媒體技術與應用筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>北科資工二多媒體技術與應用 第六周團隊作業 - 對兩類別影像進行 SIFT 特徵提取並送入SVM分類</title>
    <url>/2021/04/18/Media_with_Image_recognition/NTUTcs_MediaHW06G01/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊工程系大二下多媒體技術與應用作業紀錄<br><font color="#dd0000">並非所有人都適用，部分對我而言稍加容易的內容並不會寫在此內。</font><br><strong>這是學習後心得的筆記，可能不太適用會未來的學生</strong></p>
<p>由於我沒有學習過裡面的理論，因此這是資工大二學生透過網路與自身理解的筆記，學習價值並不高、且可能擁有大量錯誤。</p>
</blockquote>
<a id="more"></a>

<h2 id="SIFT-簡介"><a href="#SIFT-簡介" class="headerlink" title="SIFT 簡介"></a>SIFT 簡介</h2><p>SIFT(Scale Invariant Feature Transform) 中文名為<strong>尺度不變特徵轉換</strong>，是機器用來偵測或描述影響的演算法，SIFT 對<strong>旋轉、尺度縮放、亮度變化</strong>有良好的完整性。</p>
<p>由 David G.Lowe 教授發表。</p>
<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1iT229eGknjvKzRNEeAWMzYwoUDH_yICp&export=download" alt=""></p>
</blockquote>
<h3 id="SIFT-優點"><a href="#SIFT-優點" class="headerlink" title="SIFT 優點"></a>SIFT 優點</h3><ul>
<li>局部特徵、旋轉、尺度縮放、亮度變化，有很好的完整性；對視角變化、仿射變換、噪聲，也有一定的穩定度</li>
<li>保留圖片獨特性、訊息量大，適合大量特徵，可進行快速、準確的匹配</li>
<li>如果只有少數幾張圖片也可以產生大量的 SIFT 特徵</li>
<li>最佳化的 SIFT 不需要花費時間就能完成</li>
<li>方便與其他特徵向量結合</li>
</ul>
<h2 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h2><p>如果不想看那麼多話，建議可以直接略過。總之就像標題說的，對兩類別影像進行 SIFT 特徵提取並送入SVM分類。</p>
<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=14YQXRcC3BLBcm4zDf8vpXfK9PRYE-lE-&export=download" alt=""></p>
</blockquote>
<h2 id="資料集"><a href="#資料集" class="headerlink" title="資料集"></a>資料集</h2><p>這裡我們採用兩組資料集來使用 SIFT 特徵辨識</p>
<ul>
<li><a href="https://drive.google.com/drive/folders/1YhFEnbyQ3NvUd08Y5A8Dz09Bn5ZE-BSw?usp=sharing" target="_blank" rel="noopener">貓與狗</a></li>
<li><a href="https://drive.google.com/drive/folders/1P1oG5N2q3SCGgKMaDC4RyuBvo3h7dAZa?usp=sharing" target="_blank" rel="noopener">多拉A夢與名偵探柯南</a></li>
</ul>
<p>連結為個人在 google 圖片進行搜尋時的圖片，如果有版權冒犯請通知我，我會進行下架</p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>自從上次學習過天佑的程式碼加上這次助教 pdf 詳細的解說後，我對於機器學習有著還不錯的了解，但只僅限在應用上XD，大該知道要怎麼進行訓練、辨識了XD。</p>
<p>總之，謝謝在學習多媒體技術與應用時一路幫助過我的人，如果沒有他們幫助我，我可能到現在還甚麼都不會。</p>
<p>其中，python 有兩個語法很相像，一個是 <code>sklearn.cluster.KMeans</code> 另一個是 <code>scipy.cluster.vq.kmeans</code>，我們要使用的是後者，請大家不要搞錯喔XD。</p>
<p><del>我自己就搞錯了，花一堆時間除錯QQQQ</del></p>
<p>也謝謝發明此演算法的大師，可以讓我運用，讓我學會此應用方式，沒有大家我都做不好QQ。</p>
<h2 id="參考來源"><a href="#參考來源" class="headerlink" title="參考來源"></a>參考來源</h2><p>北科大二下多媒體技術與應用 L6 SIFT 特徵 PDF (幫最多忙)<br><a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.cluster.vq.kmeans.html" target="_blank" rel="noopener">scipy.cluster.vq.kmeans¶ by sciPy.org</a><br><a href="https://scikit-learn.org/stable/modules/generated/sklearn.cluster.KMeans.html" target="_blank" rel="noopener">sklearn.cluster.KMeans by scikit learn</a><br><a href="https://blog.csdn.net/u012609509/article/details/70319293" target="_blank" rel="noopener">np.vstack, np.hstack by cltdevelop</a></p>
<h2 id="程式碼"><a href="#程式碼" class="headerlink" title="程式碼"></a>程式碼</h2><p>直接透過程式碼來進行說明，相信會比較好理解。</p>
<p>程式碼我將它分為兩部分，其中一份為 function，另一份則為主要的程式檔案</p>
<h3 id="function"><a href="#function" class="headerlink" title="function"></a>function</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Created on Sun Apr 18 15:58:29 2021</span></span><br><span class="line"><span class="string">@author: user</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> skimage.feature <span class="keyword">import</span> hog</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> svm</span><br><span class="line"><span class="keyword">from</span> scipy.cluster.vq <span class="keyword">import</span> kmeans, vq</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split </span><br><span class="line"><span class="comment">#如果懶惰的小夥伴們可以用 train_test_split 編寫</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">(path, data_amount)</span>:</span> <span class="comment">#讀取圖片用，path 是圖片路徑、data_amount 是數量</span></span><br><span class="line">  data = list()</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, data_amount+<span class="number">1</span>):</span><br><span class="line">    image = cv2.imread(path % i) <span class="comment">#讀資料</span></span><br><span class="line">    image = cv2.resize(image, (<span class="number">349</span>,<span class="number">256</span>)) <span class="comment"># resize</span></span><br><span class="line">    data.append(image)</span><br><span class="line">  <span class="keyword">return</span> data <span class="comment">#回傳 list</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sift</span><span class="params">(data)</span>:</span> <span class="comment">#SIFT 特徵取出 data 為讀取近 python 的原始圖片</span></span><br><span class="line">  output = list()</span><br><span class="line">  <span class="keyword">for</span> image <span class="keyword">in</span> data:</span><br><span class="line">    sift = cv2.SIFT_create() <span class="comment">#初始化特徵點</span></span><br><span class="line">    kp, des = sift.detectAndCompute(image, <span class="literal">None</span>) <span class="comment">#對圖片進行 sift 讀取</span></span><br><span class="line">    output.append(des) </span><br><span class="line">  <span class="keyword">return</span> output <span class="comment">#回傳 list</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kmeans_return_features</span><span class="params">(k, sift)</span>:</span> <span class="comment">#取出特徵，透過 kmeans 分辨</span></span><br><span class="line">  <span class="comment">#k 為要分辨的特徵類別數量，建議是資料類別乘以 10，sift 為擁有圖片特徵的 list</span></span><br><span class="line">  descriptors = sift[<span class="number">0</span>] <span class="comment">#先給予一個值，以避免不能合併</span></span><br><span class="line">  <span class="keyword">for</span> it <span class="keyword">in</span> sift[<span class="number">1</span>:]:</span><br><span class="line">    descriptors = np.vstack((descriptors, it))  <span class="comment">#採用水平方式將陣列堆疊起來</span></span><br><span class="line">  </span><br><span class="line">  voc, variance = kmeans(descriptors,k,<span class="number">1</span>) </span><br><span class="line">  <span class="comment">#透過 kmeans 將特徵進行分配，相似的放在一起，並分成 k 倍，只進行 1 次 iteratior</span></span><br><span class="line">  <span class="comment">#voc 回傳陣列，長度為 k，第 i 類有著相同的特徵，</span></span><br><span class="line">  <span class="comment">#variance 回傳觀察值與中心點，可能會有失真問題，如果不要失真或許可以使用 kmeans2 方法</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">#features histogram</span></span><br><span class="line">  im_features = np.zeros((len(sift), k), <span class="string">"float32"</span>) <span class="comment">#生成一個全為 0 的陣列</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(len(sift)): <span class="comment">#</span></span><br><span class="line">    words, distance = vq(sift[i], voc)</span><br><span class="line">    <span class="comment">#將 voc 收集到的特徵，與圖片 sift[i] 與中心點進行比較，將最相似的特徵分配給適合的圖片</span></span><br><span class="line">    <span class="comment">#words 回傳陣列，接受此圖片最適合的所有特徵</span></span><br><span class="line">    <span class="comment">#distance 觀察值與中心點的距離，可能會有失真的可能性</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> words:  <span class="comment">#將特徵傳給 im_features</span></span><br><span class="line">      im_features[i][j] += <span class="number">1</span> <span class="comment">#表示此圖片的 j 特徵加一</span></span><br><span class="line">      </span><br><span class="line">  <span class="keyword">return</span> im_features  <span class="comment">#回傳 list</span></span><br></pre></td></tr></table></figure>

<h3 id="main"><a href="#main" class="headerlink" title="main"></a>main</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Created on Sun Apr 18 15:57:30 2021</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">@author: user</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> skimage.feature <span class="keyword">import</span> hog</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> fetch_lfw_people</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> svm</span><br><span class="line"><span class="keyword">from</span> scipy.cluster.vq <span class="keyword">import</span> kmeans, vq</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">import</span> hw06_fn <span class="comment">#這是我自己寫的 functional progamming，請自行將上面的 function python code</span></span><br><span class="line"><span class="comment">#與此檔案放在同個資料夾底下</span></span><br><span class="line"></span><br><span class="line">data_amount = <span class="number">100</span> <span class="comment">#每一個資料集總數 100</span></span><br><span class="line">train_amount = <span class="number">80</span> <span class="comment">#訓練資料集筆數</span></span><br><span class="line">test_amount = <span class="number">20</span> <span class="comment">#訓練資料集筆數</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#如果想要讓電腦辨識貓跟狗，請使用這些程式碼</span></span><br><span class="line">dogs = hw06_fn.read(<span class="string">"../resize_dog/dog_%.3d.jpg"</span>, data_amount)</span><br><span class="line">cats = hw06_fn.read(<span class="string">"../resize_cat/cat_%.3d.jpg"</span>, data_amount)</span><br><span class="line"></span><br><span class="line"><span class="comment">#如果想要讓電腦辨識多拉A夢跟名偵探柯南，請使用這些程式碼</span></span><br><span class="line"><span class="comment"># dogs = hw06_fn.read("../Doraemon/images (%d).jpg", data_amount)</span></span><br><span class="line"><span class="comment"># cats = hw06_fn.read("../conan/images (%d).jpg", data_amount)</span></span><br><span class="line"></span><br><span class="line">sift_dogs = hw06_fn.sift(dogs) <span class="comment">#將資料送去 sift 特徵</span></span><br><span class="line">sift_cats = hw06_fn.sift(cats)</span><br><span class="line"></span><br><span class="line">train_sift = sift_dogs[:train_amount] + sift_cats[:train_amount] <span class="comment">#產生訓練集</span></span><br><span class="line">test_sift = sift_dogs[-test_amount:] + sift_cats[-test_amount:] <span class="comment">#產生測試集</span></span><br><span class="line"></span><br><span class="line">train_features = hw06_fn.kmeans_return_features(<span class="number">20</span>, train_sift) <span class="comment">#找出訓練集每張圖片特徵</span></span><br><span class="line">test_features = hw06_fn.kmeans_return_features(<span class="number">20</span>, test_sift) <span class="comment">#找出測試集每張圖片特徵</span></span><br><span class="line">train_target = [<span class="number">0</span>] * train_amount + [<span class="number">1</span>] * train_amount <span class="comment">#給予其正確的類別</span></span><br><span class="line">test_target = [<span class="number">0</span>] * test_amount + [<span class="number">1</span>] * test_amount <span class="comment">#給予其正確的類別</span></span><br><span class="line"></span><br><span class="line">clf = svm.SVC(kernel=<span class="string">"linear"</span>, C=<span class="number">1</span>, gamma=<span class="string">"auto"</span>) <span class="comment">#透過 SVC 訓練</span></span><br><span class="line">clf.fit(train_features, train_target) <span class="comment">#開始進行訓練</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">"accuracy"</span>) <span class="comment">#準確率</span></span><br><span class="line">print(<span class="string">"train:"</span>, clf.score(train_features, train_target)) <span class="comment">#訓練集分數</span></span><br><span class="line">print(<span class="string">"test:"</span>, clf.score(test_features, test_target)) <span class="comment">#測試集分數</span></span><br></pre></td></tr></table></figure>

<h2 id="結果"><a href="#結果" class="headerlink" title="結果"></a>結果</h2><p>需要特別注意 <code>scipy.cluster.vq.kmean</code> 函式，一開始會隨機選擇一座標進行分類，因此每一次使用此函數不一定回傳值永遠相同，視每次分類而定；因此在執行我這份程式碼時，準確率與我不同並沒有錯。</p>
<h3 id="貓與狗"><a href="#貓與狗" class="headerlink" title="貓與狗"></a>貓與狗</h3><blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1zbSN_IxKfqE5AHLR9TGN0d3CFxH0Vwe6&export=download" alt=""></p>
</blockquote>
<h3 id="多拉A夢與柯南"><a href="#多拉A夢與柯南" class="headerlink" title="多拉A夢與柯南"></a>多拉A夢與柯南</h3><blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1bRAv0haii4SFLH1YGRIvqpRvO7TnGVGB&export=download" alt=""></p>
</blockquote>
<h2 id="圖片辨識後結論"><a href="#圖片辨識後結論" class="headerlink" title="圖片辨識後結論"></a>圖片辨識後結論</h2><h3 id="貓與狗-1"><a href="#貓與狗-1" class="headerlink" title="貓與狗"></a>貓與狗</h3><p>由於貓跟小狗的身材較為相像且亮度變化在這裡或許會容易誤導 SVM 進行分別，導致相同的光亮度的貓與狗不好進行分配，才會使其在訓練集的準確率就不高，在此情況下，相對測試集就不高。</p>
<p>可能需要白底 png 的大量貓狗照片，就能使得此機器學習辨識率更高。</p>
<h3 id="多拉A夢與柯南-1"><a href="#多拉A夢與柯南-1" class="headerlink" title="多拉A夢與柯南"></a>多拉A夢與柯南</h3><p>這組是比較正確的一組，其中我認為哆啦A夢與名偵探柯南本身的光影明亮度稍微不同、邊緣也有大不同，因此在交由 SVM 進行分辨時，較能夠分辨得出差異性。因此在訓練集時準確率可以達到 92%，在測試集也可以達到 72%，算是不錯的辨識率。</p>
<p>但認為可能還是需要白底的 png 照片，會讓他更為準確，我認為可能有些辨識失敗的原因是圖片有大量不相干的背景使得，那不相干的背景如果與另一類型的背景相似時，就有分辨失誤的可能性。</p>
<h2 id="無註解程式碼"><a href="#無註解程式碼" class="headerlink" title="無註解程式碼"></a>無註解程式碼</h2><h3 id="hw06-fn-py"><a href="#hw06-fn-py" class="headerlink" title="hw06_fn.py"></a><code>hw06_fn.py</code></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Created on Sun Apr 18 15:58:29 2021</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">@author: user</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Created on Thu Apr 8 10:58:26 2021</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> skimage.feature <span class="keyword">import</span> hog</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> fetch_lfw_people</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> svm</span><br><span class="line"><span class="keyword">from</span> scipy.cluster.vq <span class="keyword">import</span> kmeans, vq</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">(path, data_amount)</span>:</span></span><br><span class="line">  data = list()</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, data_amount+<span class="number">1</span>):</span><br><span class="line">    image = cv2.imread(path % i)</span><br><span class="line">    image = cv2.resize(image, (<span class="number">349</span>,<span class="number">256</span>))</span><br><span class="line">    data.append(image)</span><br><span class="line">  <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sift</span><span class="params">(data)</span>:</span></span><br><span class="line">  output = list()</span><br><span class="line">  <span class="keyword">for</span> image <span class="keyword">in</span> data:</span><br><span class="line">    sift = cv2.SIFT_create()</span><br><span class="line">    kp, des = sift.detectAndCompute(image, <span class="literal">None</span>)</span><br><span class="line">    output.append(des)</span><br><span class="line">  <span class="keyword">return</span> output</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kmeans_return_features</span><span class="params">(k, sift)</span>:</span></span><br><span class="line">  descriptors = sift[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">for</span> it <span class="keyword">in</span> sift[<span class="number">1</span>:]:</span><br><span class="line">    descriptors = np.vstack((descriptors, it))  </span><br><span class="line">  </span><br><span class="line">  voc, train_variance = kmeans(descriptors,k,<span class="number">1</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">#features histogram</span></span><br><span class="line">  im_features = np.zeros((len(sift), k), <span class="string">"float32"</span>)</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(len(sift)):</span><br><span class="line">    words, distance = vq(sift[i], voc)</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> words:</span><br><span class="line">      im_features[i][j] += <span class="number">1</span></span><br><span class="line">      </span><br><span class="line">  <span class="keyword">return</span> im_features</span><br></pre></td></tr></table></figure>

<h3 id="G01-py"><a href="#G01-py" class="headerlink" title="G01.py"></a><code>G01.py</code></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Created on Sun Apr 18 15:57:30 2021</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">@author: user</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> skimage.feature <span class="keyword">import</span> hog</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> fetch_lfw_people</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> svm</span><br><span class="line"><span class="keyword">from</span> scipy.cluster.vq <span class="keyword">import</span> kmeans, vq</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">import</span> hw06_fn</span><br><span class="line"></span><br><span class="line">data_amount = <span class="number">100</span></span><br><span class="line">train_amount = <span class="number">80</span></span><br><span class="line">test_amount = <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#return list</span></span><br><span class="line">dogs = hw06_fn.read(<span class="string">"../resize_dog/dog_%.3d.jpg"</span>, data_amount)</span><br><span class="line">cats = hw06_fn.read(<span class="string">"../resize_cat/cat_%.3d.jpg"</span>, data_amount)</span><br><span class="line"></span><br><span class="line"><span class="comment">#dogs = hw06_fn.read("../Doraemon/images (%d).jpg", data_amount)</span></span><br><span class="line"><span class="comment">#cats = hw06_fn.read("../conan/images (%d).jpg", data_amount)</span></span><br><span class="line"></span><br><span class="line">sift_dogs = hw06_fn.sift(dogs)</span><br><span class="line">sift_cats = hw06_fn.sift(cats)</span><br><span class="line"></span><br><span class="line">train_sift = sift_dogs[:train_amount] + sift_cats[:train_amount]</span><br><span class="line">test_sift = sift_dogs[-test_amount:] + sift_cats[-test_amount:]</span><br><span class="line"></span><br><span class="line">train_features = hw06_fn.kmeans_return_features(<span class="number">20</span>, train_sift)</span><br><span class="line">test_features = hw06_fn.kmeans_return_features(<span class="number">20</span>, test_sift)</span><br><span class="line">train_target = [<span class="number">0</span>] * train_amount + [<span class="number">1</span>] * train_amount</span><br><span class="line">test_target = [<span class="number">0</span>] * test_amount + [<span class="number">1</span>] * test_amount</span><br><span class="line"></span><br><span class="line">clf = svm.SVC(kernel=<span class="string">"linear"</span>, C=<span class="number">1</span>, gamma=<span class="string">"auto"</span>)</span><br><span class="line">clf.fit(train_features, train_target)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"accuracy"</span>)</span><br><span class="line">print(<span class="string">"train:"</span>, clf.score(train_features, train_target))</span><br><span class="line">print(<span class="string">"test:"</span>, clf.score(test_features, test_target))</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>北科上課筆記</category>
        <category>多媒體與圖像辨識 Image Recognition</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>北科大多媒體技術與應用筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>北科資工二多媒體技術與應用 第六周個人作業 - 觀察 Harris Corner Detection</title>
    <url>/2021/04/18/Media_with_Image_recognition/NTUTcs_MediaHW06T01/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊工程系大二下多媒體技術與應用作業紀錄<br><font color="#dd0000">並非所有人都適用，部分對我而言稍加容易的內容並不會寫在此內。</font><br><strong>這是學習後心得的筆記，可能不太適用會未來的學生</strong></p>
<p>由於我沒有學習過裡面的理論，因此這是資工大二學生透過網路與自身理解的筆記，學習價值並不高、且可能擁有大量錯誤。</p>
</blockquote>
<a id="more"></a>

<h2 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h2><p>如果不想看那麼多話，建議可以直接略過。總之就像標題說的，觀察 Harris Corner Detection，然後得出結論</p>
<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1-uF3AX3mAJL3Gf6y1WGZe0Xl5m3dcaNO&export=download" alt=""></p>
</blockquote>
<h2 id="Harris-Corner-Detection"><a href="#Harris-Corner-Detection" class="headerlink" title="Harris Corner Detection"></a>Harris Corner Detection</h2><p>Chris Harris 和 Mike StephensMike 中得出的演算法，主要可以判斷圖片中的每一個轉角(轉折處)。</p>
<p>參數為</p>
<ul>
<li><code>dst = cv2.cornerHarris(src =gray, blockSize , ksize ksize , k, dst=None, borderType=None)</code><ul>
<li>src 圖片的影響，必須是單通道 8-bit or numpy.float 的影像</li>
<li>blocksize 轉角點檢測的區域大小</li>
<li>ksize 高斯 Sobel 中使用的 blocksize 大小</li>
<li>k 檢測方程中的自由參數</li>
<li>dst 輸出影像</li>
<li>boarderType 邊界類別</li>
</ul>
</li>
</ul>
<h2 id="調整其參數的結論為"><a href="#調整其參數的結論為" class="headerlink" title="調整其參數的結論為"></a>調整其參數的結論為</h2><ul>
<li>blocksize 點越小，越沒辦法判斷轉角</li>
<li>ksize 最大只能等於 blocksize</li>
<li>ksize 在使用 gauss-sobel 此公式時的大小，如果越大則細節處理越不精細</li>
<li>ksize 如果跟 blocksize 一樣大就只做一次 blocksize，越小做越多 blocksize</li>
<li>k 越大則轉角必須要越明顯，才可以知道，反之越小時，只需要小轉角就可以判斷</li>
</ul>
<h2 id="程式碼"><a href="#程式碼" class="headerlink" title="程式碼"></a>程式碼</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Created on Sun Apr 18 18:17:58 2021</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">@author: user</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">"./floor.jpg"</span>)</span><br><span class="line">cv2.imshow(<span class="string">'ori'</span>, img)</span><br><span class="line">gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</span><br><span class="line">gray = np.float32(gray)</span><br><span class="line"></span><br><span class="line">dst = cv2.cornerHarris(gray,<span class="number">5</span>,<span class="number">1</span>,<span class="number">0.1</span>)</span><br><span class="line">dst = cv2.dilate(dst, <span class="literal">None</span>)</span><br><span class="line">img[dst&gt;<span class="number">0.01</span>*dst.max()] = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>]</span><br><span class="line">cv2.imshow(<span class="string">'result'</span>, img)</span><br></pre></td></tr></table></figure>

<h2 id="原本圖片"><a href="#原本圖片" class="headerlink" title="原本圖片"></a>原本圖片</h2><blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1cHgzZ5Z9NX_zLQjomnfc963cNSsu3lJl&export=download" alt=""></p>
</blockquote>
<h2 id="透過上面程式碼產生的圖片"><a href="#透過上面程式碼產生的圖片" class="headerlink" title="透過上面程式碼產生的圖片"></a>透過上面程式碼產生的圖片</h2><blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1lBROxsoHD8CewH7ow75BLQCSwDPrsBTc&export=download" alt=""></p>
</blockquote>
]]></content>
      <categories>
        <category>北科上課筆記</category>
        <category>多媒體與圖像辨識 Image Recognition</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>北科大多媒體技術與應用筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>北科資工二多媒體技術與應用 第七次團隊作業 - 使用 google colab 與 yolo 訓練後進行圖像辨識</title>
    <url>/2021/05/19/Media_with_Image_recognition/NTUTcs_MediaHW07G01/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊工程系大二下多媒體技術與應用作業紀錄<br><font color="#dd0000">並非所有人都適用，部分對我而言稍加容易的內容並不會寫在此內。</font><br><strong>這是學習後心得的筆記，可能不太適用會未來的學生</strong></p>
<p>由於我沒有學習過裡面的理論，因此這是資工大二學生透過網路與自身理解的筆記，學習價值並不高、且可能擁有大量錯誤。</p>
<p>訓練的資料是助教同意讓我們在這堂課做使用，並非同意我將訓練資料拿來散步，因此不將訓練資料生出來。</p>
</blockquote>
<a id="more"></a>

<h2 id="專案說明"><a href="#專案說明" class="headerlink" title="專案說明"></a>專案說明</h2><blockquote>
<p>如紅色線條上方說明文字<br><img src="https://drive.google.com/u/2/uc?id=1N5XAy7nAjgKzX9oEI7fti519yKNyujVm&export=download" alt=""></p>
</blockquote>
<p>此文章的目的是紀錄如何透過 yolo 與 google colab 來進行圖像辨識</p>
<h2 id="yolo-說明"><a href="#yolo-說明" class="headerlink" title="yolo 說明"></a>yolo 說明</h2><p>yolo 是一種需要高度運算，但在建立模型時則不需要大量的圖像背景知識就可以順利完成，yolo 擁有著高辨識度，且只要一開始的辨識物件訓練有做好，那 yolo 能夠辨識每一張圖片中的物件，是個非常方便的圖像辨識。</p>
<h2 id="安裝-labelIMG-在-Windows-OS、VS-code"><a href="#安裝-labelIMG-在-Windows-OS、VS-code" class="headerlink" title="安裝 labelIMG 在 Windows OS、VS code"></a>安裝 labelIMG 在 Windows OS、VS code</h2><h3 id="labelIMG-介紹"><a href="#labelIMG-介紹" class="headerlink" title="labelIMG 介紹"></a>labelIMG 介紹</h3><p>labelIMG 是 open source 軟體，專用於 yolo 的圖像標記，也就是 yolo 所需要的訓練集。</p>
<p><a href="https://github.com/tzutalin/labelImg/releases" target="_blank" rel="noopener">下載連結 windows 請安裝 zip </a><br><a href="https://github.com/tzutalin/labelImg" target="_blank" rel="noopener">安裝的一些操作手冊</a></p>
<p>下面會說明如何在 window 安裝，以及一些說明，依序是</p>
<ul>
<li>安裝 labelImg</li>
<li>產生訓練集</li>
<li>透過 labelImg 標記影像</li>
<li>使用 google colab 進行圖像訓練</li>
<li>完美結果</li>
</ul>
<p>如果需要跳至其特定章節，可以點選右邊，右邊有針對每一個大項目進行連結(錨點)</p>
<h3 id="windows-環境安裝-labelImg"><a href="#windows-環境安裝-labelImg" class="headerlink" title="windows 環境安裝 labelImg"></a>windows 環境安裝 labelImg</h3><ul>
<li>先確認 cmd 環境中是否有安裝 python、pip<br><a href="https://theriseofdavid.github.io//2021/05/18/Python/Python_install_pip/" target="_blank" rel="noopener">如果沒有可以點擊此教學說明</a></li>
<li>在 vscode 中安裝 python</li>
<li><a href="https://www.riverbankcomputing.com/software/pyqt/download" target="_blank" rel="noopener">python 安裝 pyqt5</a><br>安裝語法 <code>pip install PyQt5</code></li>
<li><a href="https://lxml.de/installation.html" target="_blank" rel="noopener">python 安裝 lxml</a><br>安裝語法 <code>pip install lxml</code></li>
<li>再來我們要把 pyqt5 加入 windows 的環境變數，順便確認 python 是否在 windows 環境變數，沒有就加入<ul>
<li>點擊 控制台 -&gt; 系統及安全性 -&gt; 系統 -&gt; 進階系統設定 -&gt; 點擊 -&gt; 進階 -&gt; 環境變數，最後畫面應該如下<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1PK6xqALMXCjRnKwrsm-0vftWeAuErJed&export=download" alt=""></p>
</blockquote>
</li>
<li>點擊系統變數 -&gt; path -&gt; 編輯<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1BhKw_AyqZzS06sSjfQ1gRO-C1OAF0Y0y&export=download" alt=""></p>
</blockquote>
</li>
<li>找出存在 python.exe 的資料夾路徑並加入環境變數，如果曾經有則不需要，紅色線條為 python.exe 資料夾路徑<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1E0YdKxVSrVzCAgjVogyTcYPdVaKHFglG&export=download" alt=""></p>
</blockquote>
</li>
<li>找出 pyqt5 的資料夾路徑並加入環境變數，通常應該在 python.exe 資料夾中的 script 資料夾，紅色線條為 pyqt5 資料夾路徑<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1xcmt8--dAYanJnvp7q_-zBfrFvSx1bEs&export=download" alt=""></p>
</blockquote>
</li>
</ul>
</li>
<li>再來我們需要編譯<br>編譯語法如下 <code>For pyqt5, pyrcc5 -o libs/resources.py resources.qrc</code></li>
<li>我們在 VScode 打開 labelImg.py，直接執行 F5，</li>
<li>如果可以成功，畫面如下<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1fUwv9mmfHXKTtiBy0hciTXBZwlSLov22&export=download" alt=""></p>
</blockquote>
</li>
</ul>
<h2 id="產生訓練集"><a href="#產生訓練集" class="headerlink" title="產生訓練集"></a>產生訓練集</h2><p>由於助教給我們的影片有四部且每部都是長達 20s 的影片，於是我將前 3 部影片視為訓練集，將影片每幀擷取下來，擷取後的每張照片就可以當作我們的測試集。</p>
<p>因此我們寫一個程式碼，每 10 幀就擷取一張圖片。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">path = <span class="string">"D:/NTUT/大二下/多媒體技術與應用/hw07/helmet/"</span></span><br><span class="line">os.chdir(path) <span class="comment">#設定要讀取圖片的資料夾路徑</span></span><br><span class="line"></span><br><span class="line">fname = <span class="string">"helmet3.mp4"</span></span><br><span class="line">video_capture = cv2.VideoCapture(fname) <span class="comment">#讀取影片</span></span><br><span class="line"></span><br><span class="line">ret = <span class="literal">False</span> <span class="comment">#ret 判斷這幀是否有圖片</span></span><br><span class="line"><span class="keyword">if</span> video_capture.isOpened(): <span class="comment">#判斷 video_capture 是否有被打開</span></span><br><span class="line">    ret, frame = video_capture.read() <span class="comment"># ret 回傳這一幀是否有圖片，fname 為圖片本體</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">"此影片正在被使用中！"</span>)</span><br><span class="line">    print(<span class="string">"影片路徑："</span>, os.getcwd(), <span class="string">"\\"</span>, fname)</span><br><span class="line"></span><br><span class="line">timeFormat = <span class="number">10</span> <span class="comment">#每 10 幀取一張</span></span><br><span class="line">timeCount =  <span class="number">1</span> <span class="comment">#紀錄現在讀到哪一幀</span></span><br><span class="line">pictureCount = <span class="number">1</span> <span class="comment">#紀錄輸出第幾張圖片</span></span><br><span class="line"><span class="keyword">while</span> ret: <span class="comment">#如果上幀有圖片</span></span><br><span class="line">    ret, frame = video_capture.read() <span class="comment">#這幀再讀一次</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ret: <span class="keyword">break</span> <span class="comment">#如果這幀沒有就離開迴圈</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(timeCount % timeFormat ==  <span class="number">0</span>): <span class="comment">#已經是第 10 幀就輸出圖片</span></span><br><span class="line">        picName = <span class="string">".\\images\\"</span> + <span class="string">"helmet3_"</span> + str(pictureCount) + <span class="string">".jpg"</span></span><br><span class="line">        cv2.imwrite(picName, frame)</span><br><span class="line">        print(<span class="string">"影片路徑："</span>, picName, sep=<span class="string">''</span>)</span><br><span class="line">        </span><br><span class="line">        pictureCount += <span class="number">1</span> <span class="comment">#紀錄圖片 +1</span></span><br><span class="line">        timeCount = <span class="number">0</span> <span class="comment">#重新計算</span></span><br><span class="line">    timeCount += <span class="number">1</span></span><br><span class="line">    <span class="comment">#cv2.waitKey(1)</span></span><br><span class="line"></span><br><span class="line">video_capture.release() <span class="comment">#python opencv 不再讀取此圖片</span></span><br></pre></td></tr></table></figure>

<p>透過這種方式就能夠讓資料夾裡面出現大量圖片了！</p>
<h2 id="如何使用-labelImg"><a href="#如何使用-labelImg" class="headerlink" title="如何使用 labelImg"></a>如何使用 labelImg</h2><ul>
<li>點擊 open dir，之後應該會出現圖片，右下角的 file list 也會有大量圖片</li>
<li>再來我們可以點擊 Next Image, Prev Image 而到下一張圖片或是前一張圖片</li>
<li>再來將此圖示點至 yolo 模式<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1U9tkd6_JD7EhkBvxVkvI3lhNB40hMfTb&export=download" alt=""></p>
</blockquote>
</li>
<li>之後點擊 Create\nReactBox，選取想要辨識的畫面<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1sEV7evC-Xf8gUhcPg8mRi9kyi4ZuiwgJ&export=download" alt=""></p>
</blockquote>
</li>
<li>然後輸入你定義此畫面的 label，記住，如果要進行圖像辨識那理論上相同 label 的圖片至少要 20 個，且要不同張。</li>
<li>持續你的<del>人工辨識</del>，找到你的耐心。</li>
<li>經過一段痛苦的 label 後</li>
</ul>
<h3 id="完成"><a href="#完成" class="headerlink" title="完成"></a>完成</h3><ul>
<li>完成後資料夾內應該要有一個 <code>class.txt</code>、一堆圖片和圖片名子相同，但檔名是 txt 的資料</li>
<li>其中標記的 txt 必須與圖片在同個位置<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=12JeZB8S9StCpvTZ1G_0PmzhsiTKG2vzA&export=download" alt=""></p>
</blockquote>
</li>
<li>隨意點擊某一個 txt 的資料，內容大致如下<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">16</span> <span class="number">0.567578</span> <span class="number">0.327778</span> <span class="number">0.146094</span> <span class="number">0.563889</span></span><br><span class="line"><span class="number">16</span> <span class="number">0.468750</span> <span class="number">0.211806</span> <span class="number">0.095312</span> <span class="number">0.420833</span></span><br><span class="line"><span class="number">15</span> <span class="number">0.777344</span> <span class="number">0.790972</span> <span class="number">0.328125</span> <span class="number">0.418056</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#資料依序是 class(根據 class.txt 的行數) ,x 座標, y 座標, x 長度, y 長度</span></span><br></pre></td></tr></table></figure></li>
<li><code>class.txt</code> 則是所有你定義的 label 名稱</li>
</ul>
<h2 id="使用-google-colab-來進行圖像辨識"><a href="#使用-google-colab-來進行圖像辨識" class="headerlink" title="使用 google colab 來進行圖像辨識"></a>使用 google colab 來進行圖像辨識</h2><p>google colab 提供一個環境讓你能夠使用 google 資源來圖像辨識，且 google 的顯卡、處理器規格都是屬於非常棒的規格，因此如果只是簡單的事情我都建議用 google colab 來做。</p>
<p>但 google colab 有一些限制</p>
<ul>
<li>太久沒有使用 google colab 會被強制退出</li>
<li>訓練模型最多只能夠使用 12 小時</li>
</ul>
<h3 id="一開始的環境處理"><a href="#一開始的環境處理" class="headerlink" title="一開始的環境處理"></a>一開始的環境處理</h3><ul>
<li>先在 google 雲端硬碟建立一個資料夾，以下的資料夾舉例會是 <code>/content/drive/MyDrive/NTUT/&#39;大二下- 資工多媒體技術與應用/yolo&#39;</code></li>
<li>將你透過 labelImg 完成 label 標記的資料夾壓縮後放入雲端硬碟，在這邊我的資料夾名稱為 <code>dataset</code></li>
<li>從<a href="https://github.com/AlexeyAB/darknet/releases/download/darknet_yolo_v3_optimal/yolov4.conv.137" target="_blank" rel="noopener">網路上下載 yolov4.conv.137 檔案</a>，之後放入雲端硬碟，此檔案是我們在進行圖像辨識時，用於訓練的必備檔案。</li>
<li>將我們手工標記好的 label 資料夾中的 <code>class.txt</code> rename 為 <code>obj.names</code>，上傳至 google 雲端硬碟</li>
</ul>
<h3 id="使用-google-colab-與進行-yolo-訓練"><a href="#使用-google-colab-與進行-yolo-訓練" class="headerlink" title="使用 google colab 與進行 yolo 訓練"></a>使用 google colab 與進行 yolo 訓練</h3><p>接下來我們要使用 google colab 來進行圖像辨識，內容會比較麻煩，因為必須與本機和雲端硬碟交互操作。</p>
<ul>
<li>根據我們原本建立的 google 雲端硬碟資料夾，對空白處右鍵 -&gt; 更多 -&gt; 連結我的應用程式 -&gt; 搜尋 colab<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1aoUuFRP0sg2jmd28jUYOjZcGEuo9-gLD&export=download" alt=""></p>
</blockquote>
</li>
<li>建立一個 google colab 與進行 yolo 訓練<ul>
<li>以下全部都是在 google colab 運行</li>
<li>開啟 google GPU 運算<ul>
<li><blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1aulM7kfOEEmx-_FWF6ApIBQQC5Q6gaWe&export=download" alt=""></p>
</blockquote>
</li>
<li><blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1VZY9AGIi7CJ61w1kvCVecCcTv7hD_9NK&export=download" alt=""></p>
</blockquote>
</li>
</ul>
</li>
<li>我們必須允許 colab 對我們的雲端硬碟操作，因此需要勾選；也許會需要你同意 google colab 使用<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1_jSBZh29eEuvZqh-BqEt0kzUvC16NoMF&export=download" alt=""></p>
</blockquote>
</li>
<li><code>!git clone https://github.com/AlexeyAB/darknet</code></li>
<li><code>%cd darknet/</code></li>
<li>接下來我們先找 <code>/content/darknet/Makefile</code> 進行修改，修改內容如下<ul>
<li>開啟 GPU 加速，將 GPU 設定改為 1</li>
<li>OPENCV 開啟，才可讀取影片、影像，將 OPENCV = 1</li>
<li>CUDNN = 1，用於加速深度學習框架</li>
<li>CUDNN_HALF = 1，加速偵測物件</li>
<li>示意圖如下<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1gBIJq6dC7LCsNsdkqptx4uvKTcby0V3b&export=download" alt=""></p>
</blockquote>
</li>
</ul>
</li>
<li>完成後，我們進行 <code>!make</code></li>
<li><strong>再來我們要去修改 yolov4-custom.cfg</strong><ul>
<li>選擇資料夾 <code>/content/darknet/cfg/yolov4-custom.cfg</code></li>
<li>我們必須將裡面的 filter 參數修改成 \((n+5)*3\)，n 為總共有多少 class，並且必須是數字，不可以是公式(類似於 css)</li>
<li>class 則必須改成我們標記的 class 數字</li>
<li>上面講的兩點只在 yolov4-custom.cfg 的 963、970、1051、1058、1139、1146 修改<ul>
<li><blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=18V0lasogNMKzsPgWT_CwLIcE-_ZcJz9A&export=download" alt=""></p>
</blockquote>
</li>
<li><blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1GAFilxLBmDAPhbqwFop5KBaZcBuD8OH1&export=download" alt=""></p>
</blockquote>
</li>
<li><blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1VRK8cBUfu_QVmTrceGNSab-pyv2JqMDb&export=download" alt=""></p>
</blockquote>
</li>
</ul>
</li>
<li>如果接下來在下方訓練時，有遇到 <code>out of memory</code> 問題時，必須改為 subdivisions = 32 or 64<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=11WvYjcEGTfHZCLlzUnz-KQDjqz9gvpe2&export=download" alt=""></p>
</blockquote>
</li>
<li>max_batches 則是資料集 class 個數乘以 2000<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1nQsU6wAQ4GFLdfJ76OgatAAQqz-Tq1VV&export=download" alt=""></p>
</blockquote>
</li>
<li>steps 則是 max_batches 的 80% and 90%<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=183naBtkh2ubLy3G_gQqD2r4A7fRsk4GH&export=download" alt=""></p>
</blockquote>
</li>
<li>再來我們將這份修改好的檔案 copy 下來到我們的電腦上，取名為 yolov4-custom.cfg<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1x2rFu2M2MB3_uegP8dKxJTJcllaOJIZi&export=download" alt=""></p>
</blockquote>
</li>
<li>再來我們在將 yolov4-custom.cfg 上傳至雲端硬碟上，位置為 <code>/content/drive/MyDrive/NTUT/&#39;大二下- 資工多媒體技術與應用&#39;/yolo/</code></li>
</ul>
</li>
<li>再來我們將 <code>/content/drive/MyDrive/NTUT/&#39;大二下- 資工多媒體技術與應用&#39;/yolo/</code> google 雲端硬碟資料夾做一個 link，讓我們只要輸入此名詞就可以成功 link 到此資料夾<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">!ln -f -s /content/drive/MyDrive/NTUT/<span class="string">'大二下- 資工多媒體技術與應用'</span>/yolo /drive</span><br><span class="line">!ls /drive</span><br></pre></td></tr></table></figure></li>
<li>再來我們要將上傳的 dataset.zip 解壓縮，並且放入 <code>yolo/</code> 資料夾中<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">!unzip &#x2F;drive&#x2F;dataset.zip -d &#x2F;drive</span><br></pre></td></tr></table></figure></li>
<li>將所有圖片收錄到 train.txt、valid.txt<br>由於我們是要讓 google colab 來幫我們做圖像辨識，因此我們必須要產生一個檔案，讓 google coloab 在訓練時知道有哪些資料需要訓練。<ul>
<li>其中<ul>
<li><code>train.txt</code> 為訓練集資料</li>
<li><code>valid.txt</code> 為測試集資料</li>
<li>如果沒有測試集資料，那我們直接將 train.txt 資料 copy 一份至 valid.txt 即可。</li>
</ul>
</li>
<li>train.txt 裡面要收錄著我們全部的測試集圖片，並且路徑必須是 <strong>google 雲端上絕對路徑</strong></li>
<li>我們可以寫一份程式來快速產生出所有的訓練集圖片資訊<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os </span><br><span class="line"></span><br><span class="line">path = <span class="string">"D:/NTUT/大二下/多媒體技術與應用/hw07/yolo"</span> <span class="comment">#讀本機資料夾路徑</span></span><br><span class="line">output_path = <span class="string">"/drive/yolo/"</span> <span class="comment">#google drive 絕對路徑，支援捷徑</span></span><br><span class="line">images_file = list()</span><br><span class="line">os.chdir(os.path.join(path, <span class="string">"dataset"</span>)) <span class="comment"># dataset 為圖片訓練集</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> fname <span class="keyword">in</span> os.listdir(os.getcwd()): <span class="comment">#不斷讀入資料</span></span><br><span class="line">    <span class="keyword">if</span> fname.endswith(<span class="string">".jpg"</span>): <span class="comment">#必須是 jpg </span></span><br><span class="line">        images_file.append(<span class="string">"dataset/"</span> + fname)</span><br><span class="line"></span><br><span class="line">os.chdir(<span class="string">".."</span>) <span class="comment">#回到上一層</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"train.txt"</span>, <span class="string">"w"</span>) <span class="keyword">as</span> output: <span class="comment">#打開 train.txt </span></span><br><span class="line">    <span class="keyword">for</span> image <span class="keyword">in</span> images_file: <span class="comment">#不斷讀入 images_file 並且將路徑 + 圖片輸入至 train.txt</span></span><br><span class="line">        output.write(output_path + image)</span><br><span class="line">        output.write(<span class="string">"\n"</span>)</span><br><span class="line">    output.close()</span><br><span class="line">os.chdir(<span class="string">".."</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>再來我們設定 <code>obj.data</code><ul>
<li>其中所有的路徑都必須是 google driver 的絕對路徑</li>
<li>class 為 label 總共有幾個</li>
<li>train 為訓練集資料位置</li>
<li>valid 為測試集資料位置</li>
<li>names 為這些 label 的名字</li>
<li>backup 為訓練好的模型輸出位置</li>
<li>語法如下<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">classes &#x3D; 17</span><br><span class="line">train &#x3D; &#x2F;drive&#x2F;yolo&#x2F;helmet&#x2F;train.txt</span><br><span class="line">valid &#x3D; &#x2F;drive&#x2F;yolo&#x2F;helmet&#x2F;valid.txt</span><br><span class="line">names &#x3D; &#x2F;drive&#x2F;yolo&#x2F;helmet&#x2F;obj.names</span><br><span class="line">backup &#x3D; &#x2F;drive&#x2F;yolo&#x2F;helmet&#x2F;</span><br></pre></td></tr></table></figure></li>
<li>再來我們在將 obj.data 上傳至雲端硬碟上，位置為 <code>/content/drive/MyDrive/NTUT/&#39;大二下- 資工多媒體技術與應用&#39;/yolo/</code></li>
</ul>
</li>
<li>我們這邊檢查是否路徑是否設對，如果沒有設對可以回去進行檢查<ul>
<li>語法 <code>%cat /drive/obj.data</code></li>
<li>會輸出的畫面必須是<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1wfelMvzobqKHn9kWa5x_6ilWuKUne7xA&export=download" alt=""></p>
</blockquote>
</li>
</ul>
</li>
<li>再來我們就來進行 yolo 模型訓練拉，第一個是 obj.data、第二個是 cfg 設定、第三個是我們上傳的權重，<strong>基本上訓練模型時間一定要 1 小時以上</strong>，因此我們需要將，語法如下<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">!.&#x2F;darknet detector train &#x2F;drive&#x2F;obj.data \</span><br><span class="line">&#x2F;drive&#x2F;yolov4-custom.cfg \</span><br><span class="line">&#x2F;drive&#x2F;yolov4.conv.137 -dont_show</span><br><span class="line"></span><br><span class="line">#之後如果再跑此模型有問題，下方有附註我有遇到的問題。</span><br><span class="line">#可以看右邊標題列中的，訓練模型遇到的錯誤問題</span><br></pre></td></tr></table></figure></li>
<li>可以檢查 <code>/content/drive/MyDrive/NTUT/&#39;大二下- 資工多媒體技術與應用&#39;/yolo/</code> 是否有 yolov4-custom_last.weights 此檔案，如果有就表示已經訓練完成了！ </li>
<li>進行 yolo 辨識<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">!.&#x2F;darknet detector demo &#x2F;drive&#x2F;obj.data  \</span><br><span class="line">&#x2F;drive&#x2F;yolov4-custom.cfg \</span><br><span class="line">&#x2F;drive&#x2F;yolov4-custom_last.weights \</span><br><span class="line">-dont_show &#x2F;drive&#x2F;test.mp4 \</span><br><span class="line">-out_filename &#x2F;drive&#x2F;test_out.mp4 </span><br><span class="line"></span><br><span class="line">#之後如果再跑此模型有問題，下方有附註我有遇到的問題。</span><br><span class="line">#可以看右邊標題列中的，辨識模型遇到的錯誤問題</span><br></pre></td></tr></table></figure></li>
<li>如果最後 YOLO 辨識完有輸出此圖就表示成功了！<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1mw18qhcBAkltlAtpb8Fp-pGMaGEe8L6Y&export=download" alt=""></p>
</blockquote>
</li>
</ul>
</li>
<li><a href="https://colab.research.google.com/drive/1lxR-mS4oy46HSDdSjcWfaSQJTlGIGQp5?usp=sharing" target="_blank" rel="noopener">如果需要我的 google colab 這邊開放給大家，但是跟我的上面教學不太一樣，請斟酌使用</a></li>
</ul>
<h3 id="一些範例影片"><a href="#一些範例影片" class="headerlink" title="一些範例影片"></a>一些範例影片</h3><p>如果可以被成功輸出，那應該會出現類似這樣的影片</p>
<ul>
<li><div class="video-container"><iframe src="https://www.youtube.com/embed/enjm1fGZYR4" frameborder="0" loading="lazy" allowfullscreen></iframe></div></li>
<li><div class="video-container"><iframe src="https://www.youtube.com/embed/hO2DCPJEJl0" frameborder="0" loading="lazy" allowfullscreen></iframe></div>


</li>
</ul>
<h3 id="訓練模型遇到的錯誤問題"><a href="#訓練模型遇到的錯誤問題" class="headerlink" title="訓練模型遇到的錯誤問題"></a><strong>訓練</strong>模型遇到的錯誤問題</h3><ul>
<li><code>Can&#39;t open label file</code>，圖片資訊如下<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1dgsCr9sZ2EECPE-LBptqC_XJM-M419ao&export=download" alt=""></p>
</blockquote>
<ul>
<li>解決方法是必須<strong>檢查你的每一個路徑是否有設錯的可能性</strong></li>
</ul>
</li>
<li><code>out of memory</code>，已經有將 subdivisions 設定為 32 or 64<ul>
<li>調整 width、height，個人建議為 416<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1q0ePNI7mrcI69H__Ilsy60Mkg922Yn8t&export=download" alt=""></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="辨識模型遇到的錯誤問題"><a href="#辨識模型遇到的錯誤問題" class="headerlink" title="辨識模型遇到的錯誤問題"></a><strong>辨識</strong>模型遇到的錯誤問題</h3><ul>
<li>使用別人訓練好的 <code>yolov4-custom_last.weights</code>，但卻一直出錯<br>檢查別人的 <code>yolov4-custom.cfg</code> 是否與你相同</li>
<li><code>darknet: ./src/utils.c:331: error: Assertion &#39;0&#39; failed</code>，圖片資訊如下<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1d5Uy6O3UJwqkTjbzPedVpAcH-Ff9m2Sy&export=download" alt=""></p>
</blockquote>
<ul>
<li>這有很多種可能的解決方式，我的解決方式是 調整 width、height，個人建議為 416<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1q0ePNI7mrcI69H__Ilsy60Mkg922Yn8t&export=download" alt=""></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="其他問題"><a href="#其他問題" class="headerlink" title="其他問題"></a>其他問題</h3><ul>
<li>在設定路徑的捷徑後，透過 ls 此捷徑卻沒有辦法輸出正確的當前路徑下的所有檔案內容，圖片資訊如下<ul>
<li>錯誤的捷徑<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1qtL6eZ9OFvLxfdijicxfjLgkI3iCFZWl&export=download" alt=""></p>
</blockquote>
</li>
<li>正確的捷徑<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=184rg0jXoefef9plwp_zYimC9wXHUtxH_&export=download" alt=""></p>
</blockquote>
</li>
<li>你必須檢查你當前目錄的資料夾 <code>!ls</code> 中的檔案名字是否有與你設定的捷徑名字相同</li>
</ul>
</li>
<li>當你在訓練模型後一直告訴你 <code>gpu isn&#39;t used</code><br>必須回去重新設定 <code>/content/darknet/Makefile</code>，之後進行 <code>!make</code></li>
</ul>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>天啊，這真的好難….。 我根本就是 google colab 踩雷大師，我一開始還以為 yolov4-costom.cfg 支持運算，害我在每一個 filiter 都放入 \(5 + n)*3\) QQ。</p>
<p>google colab 每次都會把我登出，我就必須要重新登入，每一次重新登入就必須要重新設定一次 makefile，我常常會不小心就直接 make 而沒修改 makefile…。</p>
<p>為甚麼設定捷徑運氣那麼不好，剛好設定與 ls 資料夾中相同名稱的捷徑導致衝突！ಥ⌣ಥ</p>
<p>助教的 ppt 都沒有跟我說 vaild.txt and yolov4.conv.137 是拿來幹嘛的QQ，害我在旁邊摸索好久。</p>
<p>為甚麼 google 的路徑這麼難設定，我一直設定失敗，中文是不是有毒QQ，在訓練模型的時候加入中文路徑都不可以…，但是在捷徑的時候設定中文路徑就可以過！</p>
<p>雖然我有很多東西想要抱怨的，不過我還是很謝謝助教可以出這個題目讓我學習到這麼多知識，看看我打這麼多訊息就知道了XD。</p>
<p>也要謝謝陳力瑋一直不厭其煩的教導我，幫我排除困難，還給我他的金魚 weights 讓我做測試，要是這次沒有他，我看我弄個 1 個禮拜都弄不完八…。<br>新手入行總是特別辛苦嘛，有個師父帶非常感動QQQQ。</p>
<p>要是沒有力瑋在旁邊提點我要怎麼做，我可能做一做就生氣了八..。</p>
<p>我覺得我這次的圖像辨識沒有到很精準，主要原因是因為我在 labelImg 時是圈出每個人的輪廓，而非圈出頭 + 帽子，在我訓練的過程中，我將有些只有下半身的人也視為沒戴帽子的人，也許是這個原因才讓 yolo 在辨識中畫圖特別凌亂八。</p>
<blockquote>
<p>像這樣子，我也會視為是一個沒戴帽子的人<br><img src="https://drive.google.com/u/2/uc?id=14ATnLq-hZhEcSMRBJoMrwLJY3EtqWQj5&export=download" alt=""></p>
</blockquote>
<p>最後最後，我想要說 labelImg 能不能聰明一點啦QQQQQ，我不想要一直去用人工辨識去辨識一大堆圖片拉QQQQ。<br>整個手都點到酸了…，才發現自己只有辨識 60 張。</p>
<p>有時候都想說還是我請個國中生給他 168，讓他幫我做。<del>資本主義的力量</del></p>
<p>總之，謝謝助教、力瑋來讓我學會這份專案。</p>
<h2 id="參考來源"><a href="#參考來源" class="headerlink" title="參考來源"></a>參考來源</h2><p><a href="https://stackoverflow.com/questions/45501829/installing-pyqt5-on-windows-with-pip" target="_blank" rel="noopener">Installing PyQt5 on windows with pip by stack overflow</a><br><a href="https://blog.csdn.net/xinxing__8185/article/details/48440133" target="_blank" rel="noopener">python编程：使用opencv按一定间隔截取视频帧 by CSDN 张某人ER</a><br>[darknet yolov4训练遭遇 darknet: ./src/utils.c:326: error: Assertion `0‘ failed. by CSDN 江湖夜雨十年灯。。。](<a href="https://blog.csdn.net/xgd2016/article/details/107716702" target="_blank" rel="noopener">https://blog.csdn.net/xgd2016/article/details/107716702</a>)<br><a href="https://hackmd.io/@Titi/Sy9nQAauI" target="_blank" rel="noopener">YOLO 簡單訓練自己的資料集 by Titi</a><br><a href="https://stackoverflow.com/questions/63580887/yolov4-custom-object-detection-error-during-training" target="_blank" rel="noopener">yolov4 custom object detection error during training by stackoverflow</a></p>
]]></content>
      <categories>
        <category>北科上課筆記</category>
        <category>多媒體與圖像辨識 Image Recognition</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>北科大多媒體技術與應用筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>北科資工二多媒體技術與應用 期中專案一 - 剪刀石頭布</title>
    <url>/2021/04/25/Media_with_Image_recognition/NTUTcs_MediaHWmidternG01/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊工程系大二下多媒體技術與應用作業紀錄<br><font color="#dd0000">並非所有人都適用，部分對我而言稍加容易的內容並不會寫在此內。</font><br><strong>這是學習後心得的筆記，可能不太適用會未來的學生</strong></p>
<p>由於我沒有學習過裡面的理論，因此這是資工大二學生透過網路與自身理解的筆記，學習價值並不高、且可能擁有大量錯誤。</p>
</blockquote>
<a id="more"></a>

<h2 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h2><p>如果不想看那麼多話，建議可以直接略過。總之就像標題說的，給兩張圖片，辨識是哪種手勢，判斷剪刀石頭布的勝負。</p>
<p>這裡為求方便起見，玩家的部分改成抽取圖片。<br>可以使用 SVC 訓練模型，選擇 hog or sift 演算法來進行實作，這邊我則使用 hog，但我 sift 也有做。(只是 sift 訊練準確率較不準)。</p>
<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1xfXG0MaWav6WUMo5tSexiR9HPJxiSVPJ&export=download" alt=""></p>
</blockquote>
<h2 id="資料集"><a href="#資料集" class="headerlink" title="資料集"></a>資料集</h2><p>這裡我們則使用組員 林紀緯、郭梓琳、江大衞的手來當作圖片資料集</p>
<blockquote>
<p><a href="https://drive.google.com/drive/folders/1LvQ7akdOiTRLSDI0lf78ucllBFqdKDKc?usp=sharing" target="_blank" rel="noopener">資料集網址</a></p>
</blockquote>
<p>連結為個人在 google 圖片進行搜尋時的圖片，如果有版權冒犯請通知我，我會進行下架</p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>這次的程式碼，寫得還算順利。就是今天出了點慘事….，桌上型電腦的電腦供應器壞掉了…，害我今天都沒有辦法好好的去工作，只好使用筆電來進行工作，但是不太習慣筆電的鍵盤高度，總是會讓自己的手掌後半部感到不適且我覺得筆電畫面很不適合寫程式，畫面太小不容易使人閱讀，且沒有我最喜歡的雙螢幕阿QQQQQ。</p>
<p>總之，學到了一件事，桌上型電腦電源有問題時要用筆電RRR。</p>
<p>hog 演算法明顯比起 sift 演算法來說更準確些，我自己在寫 sift 遇到一堆坑QQQQ，例如 kmeans 語法如果圖片的特徵數量小於之前 sift 訓練的 model 時，就會噴錯QQQ。</p>
<p>我認為 sift 可以保留光影、選轉，才使得相同光影或相同選轉的手勢都被視為一樣的手勢。例如相同光影的剪刀與相同光影的石頭有可能在 sift 中被視為相同的手勢。才使得 sift 演算法辨識率過低。</p>
<p>因為 hog 他只對邊緣進行辨識，剪刀、石頭、布的邊緣都不一樣，其中還是會有些許的誤差，想必是在剪刀平面、布平面的情況下，才有機會被 hog 視為相同手勢。</p>
<p>經過這次的研究，我學會了很多。謝謝助教、老師、與我一起努力的組員呢。</p>
<h2 id="參考來源"><a href="#參考來源" class="headerlink" title="參考來源"></a>參考來源</h2><p><a href="https://jennaweng0621.pixnet.net/blog/post/403517807-%5bpython-%2b-opencv%5d-%e5%b0%87%e5%85%a9%e5%bc%b5%e5%bd%b1%e5%83%8f%e5%90%88%e6%88%90%e4%b8%80%e5%bc%b5" target="_blank" rel="noopener">Python + OpenCV 將兩張影像合成一張 by K_程式人</a><br><a href="https://docs.python.org/zh-tw/3/library/random.html" target="_blank" rel="noopener">random — 生成伪随机数 by Python</a><br><a href="https://ithelp.ithome.com.tw/articles/10207483" target="_blank" rel="noopener">Day19-Random模組 by it邦幫忙</a><br><a href="https://www.w3schools.com/python/gloss_python_raise.asp" target="_blank" rel="noopener">Python Raise an Exception by w3schools</a><br><a href="https://stackoverflow.com/questions/63802563/updating-scikit-learn-svc-object-has-no-attribute-proba" target="_blank" rel="noopener">Updating scikit-learn: ‘SVC’ object has no attribute ‘_probA’? by stackoverflow</a></p>
<p>圖片提供</p>
<ul>
<li><a href="https://rowdymclean.com/7-ways-to-win-the-recovery/" target="_blank" rel="noopener">7 Ways to win the recovery by Rowdy</a></li>
<li><a href="https://www.reddit.com/r/LegendsOfRuneterra/comments/djt7z9/tie_games/" target="_blank" rel="noopener">Tie games by reddit </a></li>
<li><a href="https://dict.eudic.net/dicts/en/fail" target="_blank" rel="noopener">fail by 歐陸辭典</a></li>
<li><a href="https://stackoverflow.com/questions/63802563/updating-scikit-learn-svc-object-has-no-attribute-proba" target="_blank" rel="noopener">Updating scikit-learn: ‘SVC’ object has no attribute ‘_probA’? by stackoverflow</a></li>
</ul>
<h2 id="結果畫面"><a href="#結果畫面" class="headerlink" title="結果畫面"></a>結果畫面</h2><h3 id="svm-SIFT-演算法訓練集測試結果"><a href="#svm-SIFT-演算法訓練集測試結果" class="headerlink" title="svm SIFT 演算法訓練集測試結果"></a>svm SIFT 演算法訓練集測試結果</h3><blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1Uzi7QxKLG7ZC3ybGvRFtupT3yBAjRdfE&export=download" alt=""></p>
</blockquote>
<h3 id="svm-HOG-演算法訓練集測試結果"><a href="#svm-HOG-演算法訓練集測試結果" class="headerlink" title="svm HOG 演算法訓練集測試結果"></a>svm HOG 演算法訓練集測試結果</h3><blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1l-PI0CE_x8MQ_F237Bhn7hS71jp76hmn&export=download" alt=""></p>
</blockquote>
<h3 id="猜拳結果，使用-HOG-演算法"><a href="#猜拳結果，使用-HOG-演算法" class="headerlink" title="猜拳結果，使用 HOG 演算法"></a>猜拳結果，使用 HOG 演算法</h3><h4 id="tie"><a href="#tie" class="headerlink" title="tie"></a>tie</h4><blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1vF42tRV8GCxUHNdyeCqr2hrzD-pUeYTB&export=download" alt=""></p>
</blockquote>
<h4 id="fail"><a href="#fail" class="headerlink" title="fail"></a>fail</h4><blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1iKkaFulJn1L-MYCucfEKYylGQgAw_aH4&export=download" alt=""></p>
</blockquote>
<h3 id="猜拳結果，使用-SIFT-演算法"><a href="#猜拳結果，使用-SIFT-演算法" class="headerlink" title="猜拳結果，使用 SIFT 演算法"></a>猜拳結果，使用 SIFT 演算法</h3><p>需要特別注意 <code>scipy.cluster.vq.kmean</code> 函式，一開始會隨機選擇一座標進行分類，因此每一次使用此函數不一定回傳值永遠相同，視每次分類而定；因此在執行我這份程式碼時，準確率與我不同並沒有錯。</p>
<h4 id="tie，但是辨識錯誤"><a href="#tie，但是辨識錯誤" class="headerlink" title="tie，但是辨識錯誤"></a>tie，但是辨識錯誤</h4><blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=12s6gXZcgCok362uEKZ1btja78JVBs85G&export=download" alt=""></p>
</blockquote>
<h4 id="win，但是辨識錯誤"><a href="#win，但是辨識錯誤" class="headerlink" title="win，但是辨識錯誤"></a>win，但是辨識錯誤</h4><blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=109TkYG5IwtB9I4X6bawZLimyLopoHq7t&export=download" alt=""></p>
</blockquote>
<h2 id="程式碼"><a href="#程式碼" class="headerlink" title="程式碼"></a>程式碼</h2><p>直接透過程式碼來進行說明，相信會比較好理解。</p>
<p><strong>特別注意：你必須先在你的電腦環境先 train 一次要使用的演算法 model，由於每個電腦所使用的套件版本不同，在 <code>joblib.load</code> 會發生衝突。因此建議先在你的電腦環境先 train 一次要使用的演算法 model，就不會發生此問題。</strong></p>
<p>程式碼我將它分為四部分</p>
<ul>
<li><a href="#hw07-fn-py"><code>hw07_fn.py</code> 大部分 function 存放此處，給下方程式使用</a></li>
<li><a href="#hog-train-py"><code>hog_train.py</code> hog 演算法 SVC 模型訓練</a></li>
<li><a href="#sift-train-py"><code>sift_train.py</code> sift演算法 SVC 模型訓練</a></li>
<li><a href="#super-bang4-py"><code>super_bang4.py</code> 主要用來辨識剪刀石頭布，判斷輸贏</a></li>
</ul>
<h3 id="hw07-fn-py"><a href="#hw07-fn-py" class="headerlink" title="hw07_fn.py"></a><code>hw07_fn.py</code></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Created on Sun Apr 18 15:58:29 2021</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">@author: user</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Created on Thu Apr 8 10:58:26 2021</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> skimage.feature <span class="keyword">import</span> hog <span class="keyword">as</span> feature_hog</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> fetch_lfw_people</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> svm</span><br><span class="line"><span class="keyword">from</span> scipy.cluster.vq <span class="keyword">import</span> kmeans, vq</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">import</span> os </span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">path_check</span><span class="params">(path)</span>:</span> <span class="comment">#由於這裡是 path，防呆測試。避免使用者輸入路徑時</span></span><br><span class="line">                      <span class="comment">#後面沒有 '/'，導致路徑被合併</span></span><br><span class="line">    <span class="keyword">if</span>(path[<span class="number">-1</span>] != <span class="string">'/'</span>):</span><br><span class="line">        path += <span class="string">'/'</span></span><br><span class="line">    <span class="keyword">return</span> path</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rename_image</span><span class="params">(folder, category)</span>:</span> <span class="comment">#將資料夾裡面的檔案全部重新命名</span></span><br><span class="line">    folder = path_check(folder) <span class="comment">#路徑防呆測試</span></span><br><span class="line">    images = os.listdir(folder)  <span class="comment">#讀取路徑全部資料</span></span><br><span class="line">    i = <span class="number">1</span> <span class="comment">#編號從 1 開始</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> old_name <span class="keyword">in</span> images:</span><br><span class="line">        new_name = <span class="string">"%s-%d.jpg"</span> % (category, i) <span class="comment">#命名格式</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">not</span> os.path.isfile(folder+new_name)): </span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            <span class="comment">#判定新的檔名有沒有被使用過，如果有就放棄</span></span><br><span class="line">        os.rename(folder+old_name, folder+new_name) <span class="comment">#將資料改名</span></span><br><span class="line">        print(<span class="string">"修改當前檔案"</span>, old_name, new_name)</span><br><span class="line">        i += <span class="number">1</span> <span class="comment"># i += 1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">(path)</span>:</span></span><br><span class="line">  data = list()</span><br><span class="line">  images = os.listdir(path) <span class="comment">#讀資料夾</span></span><br><span class="line">  <span class="keyword">for</span> image <span class="keyword">in</span> images: <span class="comment">#iterator </span></span><br><span class="line">    <span class="comment">#print("正在讀取", path + image)</span></span><br><span class="line">    image = cv2.imread(path + image) <span class="comment">#必須是相對路徑</span></span><br><span class="line">    <span class="comment">#image = cv2.resize(image, (2375,3137))</span></span><br><span class="line">    image = cv2.resize(image, (<span class="number">237</span>,<span class="number">313</span>)) <span class="comment">#重新 resize，如果沒有那訓練模型可能會極大</span></span><br><span class="line">    <span class="comment">#效率極差，程式跑很久</span></span><br><span class="line">    data.append(image) <span class="comment">#image 加入 list</span></span><br><span class="line">  <span class="keyword">return</span> data <span class="comment">#回傳資料</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sift</span><span class="params">(data)</span>:</span> <span class="comment">#SIFT 特徵取出 data 為讀取近 python 的原始圖片</span></span><br><span class="line">  output = list()</span><br><span class="line">  sift_feature = cv2.SIFT_create() <span class="comment">#初始化特徵點</span></span><br><span class="line">  <span class="keyword">for</span> image <span class="keyword">in</span> data:</span><br><span class="line">    kp, des = sift_feature.detectAndCompute(image, <span class="literal">None</span>) <span class="comment">#對圖片進行 sift 讀取</span></span><br><span class="line">    output.append(des) </span><br><span class="line">  <span class="keyword">return</span> output <span class="comment">#回傳 list</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hog</span><span class="params">(data)</span>:</span></span><br><span class="line">    output = list() </span><br><span class="line">    <span class="keyword">for</span> image <span class="keyword">in</span> data:</span><br><span class="line">        fd, hog_image = feature_hog( <span class="comment">#將資料透過 hog 描繪邊緣</span></span><br><span class="line">        image, </span><br><span class="line">        orientations=<span class="number">8</span>, <span class="comment">#8方向，上下左右、左上下、右上下</span></span><br><span class="line">        pixels_per_cell=(<span class="number">9</span>,<span class="number">9</span>), <span class="comment">#(9,9) 為一個邊緣區塊</span></span><br><span class="line">        cells_per_block=(<span class="number">1</span>,<span class="number">1</span>), <span class="comment">#(1,1) 個邊緣區塊是一個大區塊</span></span><br><span class="line">        visualize=<span class="literal">True</span>, <span class="comment">#可視性 true</span></span><br><span class="line">        )</span><br><span class="line">        output.append(fd) <span class="comment">#存入 output </span></span><br><span class="line">    <span class="keyword">return</span> output <span class="comment">#回傳 list</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kmeans_return_features</span><span class="params">(k, sift)</span>:</span> <span class="comment">#取出特徵，透過 kmeans 分辨</span></span><br><span class="line">  <span class="comment">#k 為要分辨的特徵類別數量，建議是資料類別乘以 10，sift 為擁有圖片特徵的 list</span></span><br><span class="line">  descriptors = sift[<span class="number">0</span>] <span class="comment">#先給予一個值，以避免不能合併</span></span><br><span class="line">  <span class="keyword">for</span> it <span class="keyword">in</span> sift[<span class="number">1</span>:]:</span><br><span class="line">    descriptors = np.vstack((descriptors, it)) <span class="comment">#採用水平方式將陣列堆疊起來</span></span><br><span class="line">  </span><br><span class="line">  print(len(descriptors))</span><br><span class="line">  <span class="keyword">if</span>(len(descriptors) &lt; k): <span class="comment">#有可能圖片的特徵數小於 k，就無法做 kmean 演算法，因此在這邊做提醒</span></span><br><span class="line">    <span class="keyword">raise</span> Exception(<span class="string">"無法辨識，因為此圖片特徵數小於 k"</span>)</span><br><span class="line"></span><br><span class="line">  voc, train_variance = kmeans(descriptors,k,<span class="number">1</span>)</span><br><span class="line">  <span class="comment">#透過 kmeans 將特徵進行分配，相似的放在一起，並分成 k 倍，只進行 1 次 iteratior</span></span><br><span class="line">  <span class="comment">#voc 回傳陣列，長度為 k，第 i 類有著相同的特徵，</span></span><br><span class="line">  <span class="comment">#variance 回傳觀察值與中心點，可能會有失真問題，如果不要失真或許可以使用 kmeans2 方法</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">#features histogram</span></span><br><span class="line">  im_features = np.zeros((len(sift), k), <span class="string">"float32"</span>) <span class="comment">#生成一個全為 0 的陣列</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(len(sift)):</span><br><span class="line">    words, distance = vq(sift[i], voc)</span><br><span class="line">    <span class="comment">#將 voc 收集到的特徵，與圖片 sift[i] 與中心點進行比較，將最相似的特徵分配給適合的圖片</span></span><br><span class="line">    <span class="comment">#words 回傳陣列，接受此圖片最適合的所有特徵</span></span><br><span class="line">    <span class="comment">#distance 觀察值與中心點的距離，可能會有失真的可能性</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> words:   <span class="comment">#將特徵傳給 im_features</span></span><br><span class="line">      im_features[i][j] += <span class="number">1</span> <span class="comment">#表示此圖片的 j 特徵加一</span></span><br><span class="line">      </span><br><span class="line">  <span class="keyword">return</span> im_features <span class="comment">#回傳 list</span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">random_image</span><span class="params">(folder)</span>:</span> <span class="comment">#隨機選擇資料夾圖片</span></span><br><span class="line">    folder = path_check(folder) <span class="comment">#防呆測試</span></span><br><span class="line">    images = os.listdir(folder) <span class="comment">#將資料夾全部圖片讀出</span></span><br><span class="line">    random_filename = random.choice(images) <span class="comment">#隨機選擇其中一張圖片</span></span><br><span class="line">    image = cv2.imread(folder + random_filename) <span class="comment">#路徑合併，並 opencv 讀取</span></span><br><span class="line">    image = cv2.resize(image, (<span class="number">237</span>,<span class="number">313</span>)) <span class="comment">#圖片需要 resize 與訓練模型圖片 size 相同</span></span><br><span class="line">    print(folder + random_filename) <span class="comment">#輸出路徑檢查</span></span><br><span class="line">    <span class="keyword">return</span> image <span class="comment">#回傳圖片</span></span><br></pre></td></tr></table></figure>

<h3 id="hog-train-py"><a href="#hog-train-py" class="headerlink" title="hog_train.py"></a><code>hog_train.py</code></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Created on Sat Apr 24 17:08:38 2021</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">@author: User</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Created on Sat Apr 24 14:12:06 2021</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">@author: User</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> skimage.feature <span class="keyword">import</span> hog</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> fetch_lfw_people</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> svm</span><br><span class="line"><span class="keyword">from</span> scipy.cluster.vq <span class="keyword">import</span> kmeans, vq</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">import</span> joblib</span><br><span class="line"><span class="keyword">import</span> hw07_fn <span class="comment">#這是我自己寫的 functional progamming，請自行將上面的 function python code</span></span><br><span class="line"><span class="comment">#與此檔案放在同個資料夾底下</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#將資料夾裡面全部資料夾的名子全部統一格式，通常只需要使用一次，資料夾內容全部統一命名。</span></span><br><span class="line"><span class="comment">#hw07_fn.rename_image("./scissors/", "scissor")</span></span><br><span class="line"><span class="comment"># hw07_fn.rename_image("./papers/", "paper")</span></span><br><span class="line"><span class="comment"># hw07_fn.rename_image("./rocks/", "rock")</span></span><br><span class="line"></span><br><span class="line">scissors = hw07_fn.read(<span class="string">"./scissors/"</span>) <span class="comment">#讀此資料夾資料</span></span><br><span class="line">papers = hw07_fn.read(<span class="string">"./papers/"</span>) <span class="comment">#讀此資料夾資料</span></span><br><span class="line">rocks = hw07_fn.read(<span class="string">"./rocks/"</span>) <span class="comment">#讀此資料夾資料</span></span><br><span class="line"></span><br><span class="line">sift_scissors = hw07_fn.hog(scissors) <span class="comment">#對剪刀圖片進行 hog 演算法</span></span><br><span class="line">sift_papers = hw07_fn.hog(papers) <span class="comment">#對剪刀圖片進行 hog 演算法</span></span><br><span class="line">sift_rocks = hw07_fn.hog(rocks) <span class="comment">#對剪刀圖片進行 hog 演算法</span></span><br><span class="line"></span><br><span class="line">x = sift_scissors + sift_rocks + sift_papers <span class="comment">#data 合併</span></span><br><span class="line">y = [<span class="string">"剪刀"</span>] * len(sift_scissors) + [<span class="string">"石頭"</span>] * len(sift_rocks) + [<span class="string">"布"</span>] * len(sift_papers)</span><br><span class="line"><span class="comment">#target 合併</span></span><br><span class="line"></span><br><span class="line">x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=<span class="number">0.2</span>, random_state=<span class="number">0</span>) </span><br><span class="line"><span class="comment">#產生出訓練資料集、測試資料集</span></span><br><span class="line"></span><br><span class="line">clf = svm.SVC(kernel=<span class="string">"linear"</span>, C=<span class="number">1</span>, gamma=<span class="string">"auto"</span>, probability=<span class="literal">True</span>) <span class="comment">#SVC 訓練</span></span><br><span class="line">clf.fit(x_train, y_train) <span class="comment">#開始進行訓練</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">"accuracy"</span>) <span class="comment">#準確率</span></span><br><span class="line">print(<span class="string">"train:"</span>, clf.score(x_train, y_train)) <span class="comment">#訓練集分數</span></span><br><span class="line">print(<span class="string">"test:"</span>, clf.score(x_test, y_test)) <span class="comment">#測試集分數</span></span><br><span class="line"></span><br><span class="line">joblib.dump(clf, <span class="string">"hog_paper_scissor_rock_game.pkl"</span>) <span class="comment">#輸出成檔案，在需要使用時 load，以方便使用。</span></span><br></pre></td></tr></table></figure>

<h3 id="sift-train-py"><a href="#sift-train-py" class="headerlink" title="sift_train.py"></a><code>sift_train.py</code></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Created on Sat Apr 24 14:12:06 2021</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">@author: User</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> skimage.feature <span class="keyword">import</span> hog</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> fetch_lfw_people</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> svm</span><br><span class="line"><span class="keyword">from</span> scipy.cluster.vq <span class="keyword">import</span> kmeans, vq</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">import</span> joblib</span><br><span class="line"><span class="keyword">import</span> hw07_fn <span class="comment">#這是我自己寫的 functional progamming，請自行將上面的 function python code</span></span><br><span class="line"><span class="comment">#與此檔案放在同個資料夾底下</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#將資料夾裡面全部資料夾的名子全部統一格式，通常只需要使用一次，資料夾內容全部統一命名。</span></span><br><span class="line"><span class="comment">#hw07_fn.rename_image("./scissors/", "scissor")</span></span><br><span class="line"><span class="comment"># hw07_fn.rename_image("./papers/", "paper")</span></span><br><span class="line"><span class="comment"># hw07_fn.rename_image("./rocks/", "rock")</span></span><br><span class="line"></span><br><span class="line">scissors = hw07_fn.read(<span class="string">"./scissors/"</span>) <span class="comment">#讀此資料夾資料</span></span><br><span class="line">papers = hw07_fn.read(<span class="string">"./papers/"</span>) <span class="comment">#讀此資料夾資料</span></span><br><span class="line">rocks = hw07_fn.read(<span class="string">"./rocks/"</span>) <span class="comment">#讀此資料夾資料</span></span><br><span class="line"></span><br><span class="line">sift_scissors = hw07_fn.sift(scissors) <span class="comment">#對剪刀圖片進行 sift 演算法</span></span><br><span class="line">sift_papers = hw07_fn.sift(papers)  <span class="comment">#對石頭圖片進行 sift 演算法</span></span><br><span class="line">sift_rocks = hw07_fn.sift(rocks)  <span class="comment">#對布圖片進行 sift 演算法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#data 透過 kmeans 分類特徵</span></span><br><span class="line">x = hw07_fn.kmeans_return_features(<span class="number">24</span>, sift_scissors + sift_rocks + sift_papers)</span><br><span class="line">y = [<span class="string">"剪刀"</span>] * len(sift_scissors) + [<span class="string">"石頭"</span>] * len(sift_rocks) + [<span class="string">"布"</span>] * len(sift_papers)</span><br><span class="line"><span class="comment">#target 合併</span></span><br><span class="line"></span><br><span class="line">x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=<span class="number">0.2</span>, random_state=<span class="number">0</span>)</span><br><span class="line"><span class="comment">#產生出訓練資料集、測試資料集</span></span><br><span class="line"></span><br><span class="line">clf = svm.SVC(kernel=<span class="string">"linear"</span>, C=<span class="number">1</span>, gamma=<span class="string">"auto"</span>, probability=<span class="literal">True</span>) <span class="comment">#SVC 訓練</span></span><br><span class="line">clf.fit(x_train, y_train) <span class="comment">#開始進行訓練</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">"accuracy"</span>) <span class="comment">#準確率</span></span><br><span class="line">print(<span class="string">"train:"</span>, clf.score(x_train, y_train)) <span class="comment">#訓練集分數</span></span><br><span class="line">print(<span class="string">"test:"</span>, clf.score(x_test, y_test)) <span class="comment">#測試集分數</span></span><br><span class="line"></span><br><span class="line">joblib.dump(clf, <span class="string">"sift_paper_scissor_rock_game.pkl"</span>)</span><br><span class="line"><span class="comment"># 輸出成檔案，在需要使用時 load，以方便使用。</span></span><br></pre></td></tr></table></figure>

<h3 id="super-bang4-py"><a href="#super-bang4-py" class="headerlink" title="super_bang4.py"></a><code>super_bang4.py</code></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Created on Sat Apr 24 15:26:14 2021</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">@author: User</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> joblib</span><br><span class="line"><span class="keyword">import</span> hw07_fn</span><br><span class="line"><span class="keyword">from</span> sklearn.decomposition <span class="keyword">import</span> PCA</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sift</span><span class="params">(image)</span>:</span> <span class="comment">#使用 sift 辨識，讀入圖片</span></span><br><span class="line">    clf = joblib.load(<span class="string">"./sift_paper_scissor_rock_game.pkl"</span>) <span class="comment">#讀入前面 sift 的模型</span></span><br><span class="line">    sift_image = hw07_fn.sift([image]) <span class="comment">#讀入圖片，必須是 list 格式。hw07_fn 前面要求</span></span><br><span class="line">    x = hw07_fn.kmeans_return_features(<span class="number">24</span>, sift_image) <span class="comment">#找出圖片分類特徵</span></span><br><span class="line">    predict = clf.predict(x) <span class="comment">#進行預測，輸出類別</span></span><br><span class="line">    print(<span class="string">"sift 辨識"</span>)</span><br><span class="line">    print(predict) <span class="comment">#輸出類別</span></span><br><span class="line">    print(clf.predict_proba(x)) <span class="comment">#輸出判斷為每個類別機率</span></span><br><span class="line">    <span class="keyword">return</span> predict <span class="comment">#回傳類別</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hog</span><span class="params">(image)</span>:</span></span><br><span class="line">    clf = joblib.load(<span class="string">"./hog_paper_scissor_rock_game.pkl"</span>) <span class="comment">#讀入前面 hog 的模型</span></span><br><span class="line">    x = hw07_fn.hog([image]) <span class="comment">#讀入圖片，必須是 list 格式。hw07_fn 前面要求</span></span><br><span class="line">    predict = clf.predict(x) <span class="comment">#進行預測，輸出類別</span></span><br><span class="line">    print(<span class="string">"hog 辨識"</span>)</span><br><span class="line">    print(predict) <span class="comment">#輸出類別</span></span><br><span class="line">    print(clf.predict_proba(x)) <span class="comment">#輸出判斷為每個類別機率</span></span><br><span class="line">    <span class="keyword">return</span> predict <span class="comment">#回傳類別</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#hw07_fn.rename_image("./game/", "image")p1 = hw07_fn.random_image("./game")</span></span><br><span class="line"></span><br><span class="line">p1 = hw07_fn.random_image(<span class="string">"./game"</span>) <span class="comment">#隨機從資料集抽一張圖片</span></span><br><span class="line"><span class="comment">#cv2.imshow("player1", p1) #show</span></span><br><span class="line">p2 = hw07_fn.random_image(<span class="string">"./game"</span>) <span class="comment">#隨機從資料集抽一張圖片</span></span><br><span class="line"><span class="comment">#cv2.imshow("player1", p1) #show</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#有可能 sift 的圖片特徵不夠多，小於 SVC sift 演算法的 k，就會出錯</span></span><br><span class="line"><span class="comment">#出錯如下 Exception: 無法辨識，因為此圖片特徵數小於 k</span></span><br><span class="line"><span class="comment">#predict1 = sift(p2) #進行 sift 演算法 </span></span><br><span class="line"><span class="comment">#predict2 = sift(p2) #進行 sift 演算法</span></span><br><span class="line">predict1 = hog(p1) <span class="comment">#進行 hog 演算法</span></span><br><span class="line">predict2 = hog(p2) <span class="comment">#進行 hog 演算法</span></span><br><span class="line"></span><br><span class="line">lose = cv2.imread(<span class="string">"lose.jpg"</span>) <span class="comment">#讀取失敗圖片</span></span><br><span class="line">lose = cv2.resize(lose, (<span class="number">400</span>,<span class="number">313</span>)) <span class="comment">#resize</span></span><br><span class="line">win = cv2.imread(<span class="string">"win.jpg"</span>) <span class="comment">#讀取勝利圖片</span></span><br><span class="line">win = cv2.resize(lose, (<span class="number">400</span>,<span class="number">313</span>)) <span class="comment">#resize</span></span><br><span class="line">tie = cv2.imread(<span class="string">"tie.png"</span>)  <span class="comment">#讀取平手圖片</span></span><br><span class="line">tie = cv2.resize(tie, (<span class="number">400</span>,<span class="number">313</span>)) <span class="comment">#resize</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#判斷剪刀石頭布輸贏規則</span></span><br><span class="line"><span class="keyword">if</span>(predict1 == <span class="string">"剪刀"</span> <span class="keyword">and</span> predict2 == <span class="string">"石頭"</span>):</span><br><span class="line">    result = np.hstack((p1,lose,p2))</span><br><span class="line"><span class="keyword">elif</span>(predict1 == <span class="string">"石頭"</span> <span class="keyword">and</span> predict2 == <span class="string">"布"</span>):</span><br><span class="line">    result = np.hstack((p1,lose,p2))</span><br><span class="line"><span class="keyword">elif</span>(predict1 == <span class="string">"布"</span> <span class="keyword">and</span> predict2 == <span class="string">"剪刀"</span>):</span><br><span class="line">    result = np.hstack((p1,lose,p2)) </span><br><span class="line"><span class="keyword">elif</span>(predict1 == <span class="string">"剪刀"</span> <span class="keyword">and</span> predict2 == <span class="string">"布"</span>):</span><br><span class="line">    result = np.hstack((p1,win,p2))</span><br><span class="line"><span class="keyword">elif</span>(predict1 == <span class="string">"布"</span> <span class="keyword">and</span> predict2 == <span class="string">"石頭"</span>):</span><br><span class="line">    result = np.hstack((p1,win,p2))</span><br><span class="line"><span class="keyword">elif</span>(predict1 == <span class="string">"石頭"</span> <span class="keyword">and</span> predict2 == <span class="string">"剪刀"</span>):</span><br><span class="line">    result = np.hstack((p1,win,p2))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    result = np.hstack((p1,tie,p2))</span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">"result"</span>, result) <span class="comment">#輸出結果畫面</span></span><br><span class="line"><span class="comment">#cv2.imshow("result", np.hstack((p1,tie,p2)))</span></span><br></pre></td></tr></table></figure>

<h2 id="原始程式碼"><a href="#原始程式碼" class="headerlink" title="原始程式碼"></a>原始程式碼</h2><p>下面是沒有註解程式碼</p>
<p>程式碼我將它分為四部分</p>
<ul>
<li><a href="#hw07-fn-py-1"><code>hw07_fn.py</code> 大部分 function 存放此處，給下方程式使用</a></li>
<li><a href="#hog-train-py-1"><code>hog_train.py</code> hog 演算法 SVC 模型訓練</a></li>
<li><a href="#sift-train-py-1"><code>sift_train.py</code> sift演算法 SVC 模型訓練</a></li>
<li><a href="#super-bang4-py-1"><code>super_bang4.py</code> 主要用來辨識剪刀石頭布，判斷輸贏</a></li>
</ul>
<h3 id="hw07-fn-py-1"><a href="#hw07-fn-py-1" class="headerlink" title="hw07_fn.py"></a><code>hw07_fn.py</code></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Created on Sun Apr 18 15:58:29 2021</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">@author: user</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Created on Thu Apr 8 10:58:26 2021</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> skimage.feature <span class="keyword">import</span> hog <span class="keyword">as</span> feature_hog</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> fetch_lfw_people</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> svm</span><br><span class="line"><span class="keyword">from</span> scipy.cluster.vq <span class="keyword">import</span> kmeans, vq</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">import</span> os </span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">path_check</span><span class="params">(path)</span>:</span></span><br><span class="line">    <span class="keyword">if</span>(path[<span class="number">-1</span>] != <span class="string">'/'</span>):</span><br><span class="line">        path += <span class="string">'/'</span></span><br><span class="line">    <span class="keyword">return</span> path</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rename_image</span><span class="params">(folder, category)</span>:</span></span><br><span class="line">    folder = path_check(folder)</span><br><span class="line">    images = os.listdir(folder) </span><br><span class="line">    i = <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> old_name <span class="keyword">in</span> images:</span><br><span class="line">        new_name = <span class="string">"%s-%d.jpg"</span> % (category, i)</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">not</span> os.path.isfile(folder+new_name)): </span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        os.rename(folder+old_name, folder+new_name)</span><br><span class="line">        print(<span class="string">"修改當前檔案"</span>, old_name, new_name)</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">(path)</span>:</span></span><br><span class="line">  data = list()</span><br><span class="line">  images = os.listdir(path)</span><br><span class="line">  <span class="keyword">for</span> image <span class="keyword">in</span> images:</span><br><span class="line">    <span class="comment">#print("正在讀取", path + image)</span></span><br><span class="line">    image = cv2.imread(path + image) <span class="comment">#必須是相對路徑</span></span><br><span class="line">    <span class="comment">#image = cv2.resize(image, (2375,3137))</span></span><br><span class="line">    image = cv2.resize(image, (<span class="number">237</span>,<span class="number">313</span>))</span><br><span class="line">    data.append(image)</span><br><span class="line">  <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sift</span><span class="params">(data)</span>:</span></span><br><span class="line">  output = list()</span><br><span class="line">  sift_feature = cv2.SIFT_create()</span><br><span class="line">  <span class="keyword">for</span> image <span class="keyword">in</span> data:</span><br><span class="line">    kp, des = sift_feature.detectAndCompute(image, <span class="literal">None</span>)</span><br><span class="line">    output.append(des)</span><br><span class="line">  <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hog</span><span class="params">(data)</span>:</span></span><br><span class="line">    output = list()</span><br><span class="line">    <span class="keyword">for</span> image <span class="keyword">in</span> data:</span><br><span class="line">        fd, hog_image = feature_hog(</span><br><span class="line">        image,</span><br><span class="line">        orientations=<span class="number">8</span>,</span><br><span class="line">        pixels_per_cell=(<span class="number">9</span>,<span class="number">9</span>),</span><br><span class="line">        cells_per_block=(<span class="number">1</span>,<span class="number">1</span>),</span><br><span class="line">        visualize=<span class="literal">True</span>,</span><br><span class="line">        )</span><br><span class="line">        output.append(fd)</span><br><span class="line">    <span class="keyword">return</span> output</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kmeans_return_features</span><span class="params">(k, sift)</span>:</span></span><br><span class="line">  descriptors = sift[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">for</span> it <span class="keyword">in</span> sift[<span class="number">1</span>:]:</span><br><span class="line">    descriptors = np.vstack((descriptors, it))  </span><br><span class="line">  </span><br><span class="line">  print(len(descriptors))</span><br><span class="line">  <span class="keyword">if</span>(len(descriptors) &lt; k):</span><br><span class="line">    <span class="keyword">raise</span> Exception(<span class="string">"無法辨識，因為此圖片特徵數小於 k"</span>)</span><br><span class="line">  voc, train_variance = kmeans(descriptors,k,<span class="number">1</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">#features histogram</span></span><br><span class="line">  im_features = np.zeros((len(sift), k), <span class="string">"float32"</span>)</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(len(sift)):</span><br><span class="line">    words, distance = vq(sift[i], voc)</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> words:</span><br><span class="line">      im_features[i][j] += <span class="number">1</span></span><br><span class="line">      </span><br><span class="line">  <span class="keyword">return</span> im_features    </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">random_image</span><span class="params">(folder)</span>:</span></span><br><span class="line">    folder = path_check(folder)</span><br><span class="line">    images = os.listdir(folder)</span><br><span class="line">    random_filename = random.choice(images)</span><br><span class="line">    image = cv2.imread(folder + random_filename)</span><br><span class="line">    image = cv2.resize(image, (<span class="number">237</span>,<span class="number">313</span>))</span><br><span class="line">    print(folder + random_filename)</span><br><span class="line">    <span class="keyword">return</span> image</span><br></pre></td></tr></table></figure>

<h3 id="hog-train-py-1"><a href="#hog-train-py-1" class="headerlink" title="hog_train.py"></a><code>hog_train.py</code></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Created on Sat Apr 24 17:08:38 2021</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">@author: User</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Created on Sat Apr 24 14:12:06 2021</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">@author: User</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> skimage.feature <span class="keyword">import</span> hog</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> fetch_lfw_people</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> svm</span><br><span class="line"><span class="keyword">from</span> scipy.cluster.vq <span class="keyword">import</span> kmeans, vq</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">import</span> joblib</span><br><span class="line"><span class="keyword">import</span> hw07_fn <span class="comment">#這是我自己寫的 functional progamming，請自行將上面的 function python code</span></span><br><span class="line"><span class="comment">#與此檔案放在同個資料夾底下</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#hw07_fn.rename_image("./scissors/", "scissor")</span></span><br><span class="line"><span class="comment"># hw07_fn.rename_image("./papers/", "paper")</span></span><br><span class="line"><span class="comment"># hw07_fn.rename_image("./rocks/", "rock")</span></span><br><span class="line"></span><br><span class="line">scissors = hw07_fn.read(<span class="string">"./scissors/"</span>)</span><br><span class="line">papers = hw07_fn.read(<span class="string">"./papers/"</span>)</span><br><span class="line">rocks = hw07_fn.read(<span class="string">"./rocks/"</span>)</span><br><span class="line"></span><br><span class="line">sift_scissors = hw07_fn.hog(scissors)</span><br><span class="line">sift_papers = hw07_fn.hog(papers)</span><br><span class="line">sift_rocks = hw07_fn.hog(rocks)</span><br><span class="line"></span><br><span class="line">x = sift_scissors + sift_rocks + sift_papers</span><br><span class="line">y = [<span class="string">"剪刀"</span>] * len(sift_scissors) + [<span class="string">"石頭"</span>] * len(sift_rocks) + [<span class="string">"布"</span>] * len(sift_papers)</span><br><span class="line"></span><br><span class="line">x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=<span class="number">0.2</span>, random_state=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">clf = svm.SVC(kernel=<span class="string">"linear"</span>, C=<span class="number">1</span>, gamma=<span class="string">"auto"</span>, probability=<span class="literal">True</span>)</span><br><span class="line">clf.fit(x_train, y_train) <span class="comment">#開始進行訓練</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">"accuracy"</span>) <span class="comment">#準確率</span></span><br><span class="line">print(<span class="string">"train:"</span>, clf.score(x_train, y_train)) <span class="comment">#訓練集分數</span></span><br><span class="line">print(<span class="string">"test:"</span>, clf.score(x_test, y_test)) <span class="comment">#測試集分數</span></span><br><span class="line"></span><br><span class="line">joblib.dump(clf, <span class="string">"hog_paper_scissor_rock_game.pkl"</span>)</span><br></pre></td></tr></table></figure>

<h3 id="sift-train-py-1"><a href="#sift-train-py-1" class="headerlink" title="sift_train.py"></a><code>sift_train.py</code></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Created on Sat Apr 24 14:12:06 2021</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">@author: User</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> skimage.feature <span class="keyword">import</span> hog</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> fetch_lfw_people</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> svm</span><br><span class="line"><span class="keyword">from</span> scipy.cluster.vq <span class="keyword">import</span> kmeans, vq</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">import</span> joblib</span><br><span class="line"><span class="keyword">import</span> hw07_fn <span class="comment">#這是我自己寫的 functional progamming，請自行將上面的 function python code</span></span><br><span class="line"><span class="comment">#與此檔案放在同個資料夾底下</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#hw07_fn.rename_image("./scissors/", "scissor")</span></span><br><span class="line"><span class="comment"># hw07_fn.rename_image("./papers/", "paper")</span></span><br><span class="line"><span class="comment"># hw07_fn.rename_image("./rocks/", "rock")</span></span><br><span class="line"></span><br><span class="line">scissors = hw07_fn.read(<span class="string">"./scissors/"</span>)</span><br><span class="line">papers = hw07_fn.read(<span class="string">"./papers/"</span>)</span><br><span class="line">rocks = hw07_fn.read(<span class="string">"./rocks/"</span>)</span><br><span class="line"></span><br><span class="line">sift_scissors = hw07_fn.sift(scissors)</span><br><span class="line">sift_papers = hw07_fn.sift(papers)</span><br><span class="line">sift_rocks = hw07_fn.sift(rocks)</span><br><span class="line"></span><br><span class="line">x = hw07_fn.kmeans_return_features(<span class="number">20</span>, sift_scissors + sift_rocks + sift_papers)</span><br><span class="line">y = [<span class="string">"剪刀"</span>] * len(sift_scissors) + [<span class="string">"石頭"</span>] * len(sift_rocks) + [<span class="string">"布"</span>] * len(sift_papers)</span><br><span class="line"></span><br><span class="line">x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=<span class="number">0.2</span>, random_state=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">clf = svm.SVC(kernel=<span class="string">"linear"</span>, C=<span class="number">1</span>, gamma=<span class="string">"auto"</span>, probability=<span class="literal">True</span>)</span><br><span class="line">clf.fit(x_train, y_train) <span class="comment">#開始進行訓練</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">"accuracy"</span>) <span class="comment">#準確率</span></span><br><span class="line">print(<span class="string">"train:"</span>, clf.score(x_train, y_train)) <span class="comment">#訓練集分數</span></span><br><span class="line">print(<span class="string">"test:"</span>, clf.score(x_test, y_test)) <span class="comment">#測試集分數</span></span><br><span class="line"></span><br><span class="line">joblib.dump(clf, <span class="string">"sift_paper_scissor_rock_game.pkl"</span>)</span><br></pre></td></tr></table></figure>

<h3 id="super-bang4-py-1"><a href="#super-bang4-py-1" class="headerlink" title="super_bang4.py"></a><code>super_bang4.py</code></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Created on Sat Apr 24 15:26:14 2021</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">@author: User</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> joblib</span><br><span class="line"><span class="keyword">import</span> hw07_fn</span><br><span class="line"><span class="keyword">from</span> sklearn.decomposition <span class="keyword">import</span> PCA</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sift</span><span class="params">(image)</span>:</span></span><br><span class="line">    clf = joblib.load(<span class="string">"./sift_paper_scissor_rock_game.pkl"</span>) </span><br><span class="line">    sift_image = hw07_fn.sift([image])</span><br><span class="line">    x = hw07_fn.kmeans_return_features(<span class="number">20</span>, sift_image)</span><br><span class="line">    predict = clf.predict(x)</span><br><span class="line">    print(<span class="string">"sift 辨識"</span>)</span><br><span class="line">    print(predict)</span><br><span class="line">    print(clf.predict_proba(x))</span><br><span class="line">    <span class="keyword">return</span> predict</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hog</span><span class="params">(image)</span>:</span></span><br><span class="line">    clf = joblib.load(<span class="string">"./hog_paper_scissor_rock_game.pkl"</span>) </span><br><span class="line">    x = hw07_fn.hog([image])</span><br><span class="line">    predict = clf.predict(x)</span><br><span class="line">    print(<span class="string">"hog 辨識"</span>)</span><br><span class="line">    print(predict)</span><br><span class="line">    print(clf.predict_proba(x))</span><br><span class="line">    <span class="keyword">return</span> predict</span><br><span class="line"></span><br><span class="line"><span class="comment">#hw07_fn.rename_image("./game/", "image")p1 = hw07_fn.random_image("./game")</span></span><br><span class="line"></span><br><span class="line">p1 = hw07_fn.random_image(<span class="string">"./game"</span>)</span><br><span class="line"><span class="comment">#cv2.imshow("player1", p1)</span></span><br><span class="line">p2 = hw07_fn.random_image(<span class="string">"./game"</span>)</span><br><span class="line"><span class="comment">#cv2.imshow("player1", p1)</span></span><br><span class="line"></span><br><span class="line">predict1 = sift(p1) </span><br><span class="line">predict2 = sift(p2) </span><br><span class="line"></span><br><span class="line"><span class="comment">#predict1 = hog(p1) </span></span><br><span class="line"><span class="comment">#predict2 = hog(p2)</span></span><br><span class="line"></span><br><span class="line">lose = cv2.imread(<span class="string">"lose.jpg"</span>)</span><br><span class="line">lose = cv2.resize(lose, (<span class="number">400</span>,<span class="number">313</span>))</span><br><span class="line">win = cv2.imread(<span class="string">"win.jpg"</span>)</span><br><span class="line">win = cv2.resize(win, (<span class="number">400</span>,<span class="number">313</span>))</span><br><span class="line">tie = cv2.imread(<span class="string">"tie.png"</span>)</span><br><span class="line">tie = cv2.resize(tie, (<span class="number">400</span>,<span class="number">313</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(predict1 == <span class="string">"剪刀"</span> <span class="keyword">and</span> predict2 == <span class="string">"石頭"</span>):</span><br><span class="line">    result = np.hstack((p1,lose,p2))</span><br><span class="line"><span class="keyword">elif</span>(predict1 == <span class="string">"石頭"</span> <span class="keyword">and</span> predict2 == <span class="string">"布"</span>):</span><br><span class="line">    result = np.hstack((p1,lose,p2))</span><br><span class="line"><span class="keyword">elif</span>(predict1 == <span class="string">"布"</span> <span class="keyword">and</span> predict2 == <span class="string">"剪刀"</span>):</span><br><span class="line">    result = np.hstack((p1,lose,p2)) </span><br><span class="line"><span class="keyword">elif</span>(predict1 == <span class="string">"剪刀"</span> <span class="keyword">and</span> predict2 == <span class="string">"布"</span>):</span><br><span class="line">    result = np.hstack((p1,win,p2))</span><br><span class="line"><span class="keyword">elif</span>(predict1 == <span class="string">"布"</span> <span class="keyword">and</span> predict2 == <span class="string">"石頭"</span>):</span><br><span class="line">    result = np.hstack((p1,win,p2))</span><br><span class="line"><span class="keyword">elif</span>(predict1 == <span class="string">"石頭"</span> <span class="keyword">and</span> predict2 == <span class="string">"剪刀"</span>):</span><br><span class="line">    result = np.hstack((p1,win,p2))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    result = np.hstack((p1,tie,p2))</span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">"result"</span>, result)</span><br><span class="line"><span class="comment">#cv2.imshow("result", np.hstack((p1,tie,p2)))</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>北科上課筆記</category>
        <category>多媒體與圖像辨識 Image Recognition</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>北科大多媒體技術與應用筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>北科通識大二音樂欣賞心得－看見德沃札克‧聽見世紀</title>
    <url>/2021/05/27/NTUT_note/NTUTgec_music/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學通識大二音樂欣賞心得－看見德沃札克‧聽見世紀<br><font color="#dd0000">並非所有人都適用，我非音樂專長，並不了解音樂。</font><br><strong>這是心得，可能不太適用會未來的學生</strong></p>
<p>由於是我自己進行心得，並不一定全部都是正確，只是個人想法。</p>
</blockquote>
<a id="more"></a>

<h2 id="怎麼會參加音樂會？"><a href="#怎麼會參加音樂會？" class="headerlink" title="怎麼會參加音樂會？"></a>怎麼會參加音樂會？</h2><p>先前老師有與廖家弘老師一起在北科合奏過，老師使用鋼琴演奏、廖家弘老師則使用小提琴演奏。</p>
<p>我朋友在最後有舉手回答問題，得到了廖家弘老師的演奏會門票，我則買入一張老師的音樂會票券，一起欣賞音樂。</p>
<h2 id="音樂會場景、了解音樂會內容"><a href="#音樂會場景、了解音樂會內容" class="headerlink" title="音樂會場景、了解音樂會內容"></a>音樂會場景、了解音樂會內容</h2><p>其實一開始，我不清楚這是甚麼音樂，是後來在拿到門票後慢慢地在查找我才知道原來這是交響樂！我先前其實只有知道這個名詞，並沒有把它與這種音樂旋律結合在一起QQ；進到國家音樂廳後，發現國家音樂廳真的很氣派，漂亮的裝潢，那盞蠟燭燈不知道是我多少的伙食費了，椅子比起電影院來說更舒適一些，左右扶手都非常舒服，有著高級的軟墊，而我們的椅子不確定是不是大理石還是塑膠，我的手感分不太出來。</p>
<blockquote>
<p>大廳的蠟燭燈，配上我看不太懂得書法<br><img src="https://drive.google.com/u/2/uc?id=1bH4H5Ersol-0kGmAf8MbiocWo4CQjXGu&export=download" alt=""></p>
</blockquote>
<blockquote>
<p>音樂廳的蠟燭燈<br><img src="https://drive.google.com/u/2/uc?id=1MzX-no4XzRPbi2rcfe6UWTPLFFJcoyVY&export=download" alt=""></p>
</blockquote>
<blockquote>
<p>開場的音樂廳<br><img src="https://drive.google.com/u/2/uc?id=1R6hnrMm7AIG2yHzQx5Ye3kldgYfSbk8i&export=download" alt=""></p>
</blockquote>
<h2 id="對音樂的感受"><a href="#對音樂的感受" class="headerlink" title="對音樂的感受"></a>對音樂的感受</h2><p>其實我本身的音樂底子並不好，沒有辦法分辨哪些是廖家弘老師指揮的精華部份，但我可以理解哪些是副歌類型，老師演奏的非常好聽，但我其實有點好奇一些拉著大提琴的樂手們，他們都不會累嗎？都要一直站著似乎有點辛苦啊，還有小提琴手們必須不斷拉著曲子，但還必須要不斷翻著樂譜，會容易眼睛花掉八，這樣會有些痛苦八！辛苦他們演奏著好聽的曲子給我們聽。</p>
<p>我覺得休息後的曲子（德沃札克：《斯拉夫舞曲》作品72，第1、2、7號）比起休息前的曲子更讓我喜歡，德沃札克：《斯拉夫舞曲》是很快樂的，整體音樂並沒有像休息前的曲子在有時會突然的變得大聲、便的強烈，我不太喜歡那樣子的感受，我比較喜歡開心的感覺。</p>
<p>斯拉夫舞曲有很多副歌且都有大量的重複性，在稍微重複幾次副歌後，我慢慢可以抓到副歌的節奏，稍微數著拍子聽著音樂，感受音樂。</p>
<h2 id="音樂會的結尾與我的回味"><a href="#音樂會的結尾與我的回味" class="headerlink" title="音樂會的結尾與我的回味"></a>音樂會的結尾與我的回味</h2><p>最後一首達到音樂會的高潮，愉快的氣氛，開心的音樂在我的生命中跳動著，這是我聽音樂會中印象最深刻的一次，還有廖家弘老師最後將一束花交給一位老人家，讓我難忘。</p>
<p>這次音樂是我聽過很棒的一次！</p>
<blockquote>
<p>音樂結束時的拍照<br><img src="https://drive.google.com/u/2/uc?id=11mlWAHMXwN7PCbq_HIzxVU_m-hLWUG1h&export=download" alt=""></p>
</blockquote>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://www.spwindnews.com/archives/9748" target="_blank" rel="noopener">透過音樂的呼吸 聆聽世紀演奏 看見東歐靈光 「看見德沃札克‧聽見世紀」 by 望春風電子報</a></p>
]]></content>
      <categories>
        <category>北科上課筆記</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>北科大通識</tag>
        <tag>音樂欣賞</tag>
      </tags>
  </entry>
  <entry>
    <title>北科資財二管理資訊系統 個案四 水靈科技—高雄市C-bike</title>
    <url>/2021/04/12/case_report/NTUTifm_Manager_t01/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊與財金管理系大二下管理作業系統作業紀錄<br><font color="#dd0000">並非所有人都適用，此為老師所給予的題目。</font><br><strong>這是個人心得的筆記，可能不太適用會未來的學生</strong></p>
</blockquote>
<a id="more"></a>

<h2 id="QUESTION-為何業務人員抗拒公司的流程改造？"><a href="#QUESTION-為何業務人員抗拒公司的流程改造？" class="headerlink" title="QUESTION: 為何業務人員抗拒公司的流程改造？"></a>QUESTION: 為何業務人員抗拒公司的流程改造？</h2><p>原先未導入ERP系統前，一些背景知識</p>
<ul>
<li>業務人員包辦銷售、採購、金流、物流</li>
<li>業務人員可以跟健身器材商有議價能力</li>
<li>促銷、贈品、價格都是業務員對客戶的籌碼</li>
<li>公司與業務只在意銷售額</li>
</ul>
<p>導入ERP系統前，一些背景知識</p>
<ul>
<li>採購權不在業務員而轉交到採購部門</li>
<li>嚴格的對帳系統，業務員沒有彈性操作</li>
<li>有最低販賣價格</li>
<li>重視邊際貢獻</li>
</ul>
<p>業務員原先有許多彈性操作與他個人的策略可以去誘使客戶購買產品、解決自身錯誤問題，還能夠將一些無法解決的問題推給總公司或健身器材商，業務員曾經是公司的主角，透過一些王牌業務員的策略與給其彈性，來使業務員更順利的銷售產品，甚至可以聯合其他業務員一起做策略聯盟達到雙贏的局面，業務員就像軍師一樣，操控戰場情勢與發展。</p>
<p>現在業務員的彈性空間被大大減少，失去議價能力，出現最低價格，原先可以透過大量採購而使銷售量提高的策略因為最低價格而被鎖死、部分客戶貪小便宜的心態卻因為有最低價格，重視邊際貢獻，導致些許客戶不願購買產品、加上嚴格的商品庫存管理規則讓業務員沒有犯錯空間，讓業務員從原本軍師的地位變成了士兵，原先可以透過與其他地區的業務員(軍師)一同進行策略聯盟，由於現在的地位變為士兵，只能專心販賣產品，進而就讓士兵不願意分享自己的戰鬥法則、生存策略，沒有互利共生的空間，業務員就不會選擇與他人合作。</p>
<p>業務員原先可以操控商場的情勢與發展，適時的發展策略，現在卻變成了一名遵守紀律的士兵，許多經驗老道的業務員無法發揮策略、且獎金變少，在此情況下，必會十分抗拒公司的流程改造。</p>
<h2 id="QUESTION-公司該如何讓系統成功導入"><a href="#QUESTION-公司該如何讓系統成功導入" class="headerlink" title="QUESTION: 公司該如何讓系統成功導入"></a>QUESTION: 公司該如何讓系統成功導入</h2><p>我認為這是系統在導入時會遇到的難題</p>
<ul>
<li>業務員需要彈性，有策略的空間</li>
<li>嚴格的稽查制度，讓業務員犯錯沒有彈性的機會</li>
<li>業務員長期持有高度壓力</li>
<li>重視邊際貢獻，使帳目變得好看但實際營收卻降低</li>
</ul>
<p>我認為把這四點改好，應能夠成功改善業務抗拒系統，公司的主力核心是業務，因此讓業務們願意接受就能獲得大多數人的支持。</p>
<h3 id="改善建議如下："><a href="#改善建議如下：" class="headerlink" title="改善建議如下："></a>改善建議如下：</h3><h4 id="業務員需要彈性，有策略的空間"><a href="#業務員需要彈性，有策略的空間" class="headerlink" title="業務員需要彈性，有策略的空間"></a>業務員需要彈性，有策略的空間</h4><p>主要的問題是業務員沒有辦法從根本去解決問題，客戶的期望勢必是低價格、多贈品，我認為可以讓最低價格制度進行改善，用數學公式 業務最低價格=(1-0.0業務員當月銷售數量)*公司最低價格，這樣遇到大量購買時客戶擁有較大的議價能力時，業務員就能透過此公式逐漸給客戶優惠，如果業務員能開夠用更高的價錢談成，那其中間利差給予業務員，而這部分就可以讓業務員有很好的想法與策略進行發揮，也可以看出業務員的能力。<br>可以透過先提高公司最低價格，增加公司營利。</p>
<h4 id="嚴格的稽查制度，讓業務員犯錯沒有彈性的機會"><a href="#嚴格的稽查制度，讓業務員犯錯沒有彈性的機會" class="headerlink" title="嚴格的稽查制度，讓業務員犯錯沒有彈性的機會"></a>嚴格的稽查制度，讓業務員犯錯沒有彈性的機會</h4><p>只是程序上的問題需要補足，不一定要用懲罰來給員工壓力，也許會造成總公司跟健身器材商的談判能力降低，這點我認為可以已將 1. 的公式進行改進，業務最低價格=(1-0.0業務員當月銷售數量)<em>公司最低價格</em>1.業務疏失率<br>透過此方式給業務一些壓力，也可以對於疏失量過大的業務員警惕。如果業務最低價格多 1%，勢必會讓他接下來買賣產品更辛苦，在此前提下業務員會讓自己盡量不犯錯誤，也可以識情況給予業務員更多的寬鬆機會。</p>
<h4 id="業務員長期持有高度壓力"><a href="#業務員長期持有高度壓力" class="headerlink" title="業務員長期持有高度壓力"></a>業務員長期持有高度壓力</h4><p>這邊我建議給予員工一視同仁的獎勵，工作資歷幾年以上的員工有甚麼優惠…，透過此方式讓員工知道只要自己能撐過去就能拿到更好的福利，且不會因為其他業務員有著更好的績效，而讓自己內心壓力變大，被家人親友碎念。<br>但也必須要有，淘汰掉不好的業務員的壓力，減少不必要的支出。</p>
<h4 id="重視邊際貢獻，使帳目變得好看但實際營收卻降低"><a href="#重視邊際貢獻，使帳目變得好看但實際營收卻降低" class="headerlink" title="重視邊際貢獻，使帳目變得好看但實際營收卻降低"></a>重視邊際貢獻，使帳目變得好看但實際營收卻降低</h4><p>由於公司重視邊際貢獻，在乎一單位的產品要帶來多少的效益，這樣會造成利潤有限度的提升，因為失去了薄利多銷的策略，加上市場的競爭，在開放競爭市場不太能用這種做法，這種做法比較適合獨佔市場些，公司著重在於讓自己的推銷手法可以接觸到最多的消費者，在消費者心中有好的印象，透過此方式來讓自己的經營永續化，而非單重視邊際貢獻使公司成長緩慢、容易被她家品牌超越。</p>
]]></content>
      <categories>
        <category>北科上課筆記</category>
        <category>個案報告 Case Report</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>北科大管理資訊系統筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>北科資財二管理資訊系統 個案四 水靈科技—高雄市C-bike</title>
    <url>/2021/04/12/case_report/NTUTifm_Manager_t02/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊與財金管理系大二下管理作業系統作業紀錄<br><font color="#dd0000">並非所有人都適用，此為老師所給予的題目。</font><br><strong>這是個人心得的筆記，可能不太適用會未來的學生</strong></p>
</blockquote>
<a id="more"></a>

<h2 id="QUESTION-面對顧問公司的突然倒閉，你會如何處理？"><a href="#QUESTION-面對顧問公司的突然倒閉，你會如何處理？" class="headerlink" title="QUESTION: 面對顧問公司的突然倒閉，你會如何處理？"></a>QUESTION: 面對顧問公司的突然倒閉，你會如何處理？</h2><p>面對顧問公司的突然倒閉，我的想法如下：</p>
<ul>
<li>聯繫顧問公司的第一線主要顧問，確認詳情並表示有繼續完成之決心</li>
<li>聯繫董事長等高層主管，是否願意先聘用顧問公司的第一線顧問</li>
<li>同意時<ul>
<li>聘請顧問並重新制定計劃表</li>
<li>持續導入 ERP 系統直到完成</li>
</ul>
</li>
<li>不同意時<ul>
<li>根據內部現有 ERP 進行評估，判斷公司內部人員能做到哪些事</li>
<li>對顧問表達無法聘請之意</li>
<li>對於 ERP 系統做止血動作，公司內部人員進行能力範圍內的填補</li>
<li>停止導入 ERP 系統</li>
</ul>
</li>
</ul>
<p>透過這種方式，如果董事會不願意聘請顧問時我們則停止導入 ERP，另而退而求其次有限度地使用 ERP 系統，只使用完成的模組，對於完成度較高的模組請公司內部資訊人員進行補救，嘗試讓模組完成。</p>
<p>同意時，持續導入 ERP 系統，但由於顧問人員變為公司聘請，重新了解導入狀況並制定一份新的計畫，在依照此計畫逐步完成，使 ERP 上線。</p>
<h2 id="QUESTION-如何向公司求償-是否會對X景科技提告"><a href="#QUESTION-如何向公司求償-是否會對X景科技提告" class="headerlink" title="QUESTION: 如何向公司求償?是否會對X景科技提告?"></a>QUESTION: 如何向公司求償?是否會對X景科技提告?</h2><p>必定先終止尾款與提示履約保證金，降低公司未來損失。</p>
<p>如果董事會不願意繼續聘請原先顧問時，我認為要進行提告，透過提告的方式嘗試能否讓X景科技幫我們支付顧問聘請金額，用軟硬兼施的方式，迫使X景科技妥協。</p>
<p>如果董事會願意繼續聘請原先顧問時，則不進行提告，提告可能會讓顧問們的士氣降低，因此我建議用溫和的態度對待原先的顧問群，如果公司需要，可以聘請他們做公司員工勢必會讓公司的 ERP 系統更加有完整度，且如果需要外加功能時也可以請顧問們進行修改，在更好的情況下，我們公司可以透過這些顧問外包機械公司搞入ERP系統的大工程。</p>
]]></content>
      <categories>
        <category>北科上課筆記</category>
        <category>個案報告 Case Report</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>北科大管理資訊系統筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>北科資財二管理資訊系統 個案四 水靈科技—高雄市C-bike</title>
    <url>/2021/04/12/case_report/NTUTifm_Manager_t03/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊與財金管理系大二下管理作業系統作業紀錄<br><font color="#dd0000">並非所有人都適用，此為老師所給予的題目。</font><br><strong>這是個人心得的筆記，可能不太適用會未來的學生</strong></p>
</blockquote>
<a id="more"></a>

<h2 id="QUESTION-資訊系統在個案中的功用是甚麼，以及該怎麼預防出錯？"><a href="#QUESTION-資訊系統在個案中的功用是甚麼，以及該怎麼預防出錯？" class="headerlink" title="QUESTION: 資訊系統在個案中的功用是甚麼，以及該怎麼預防出錯？"></a>QUESTION: 資訊系統在個案中的功用是甚麼，以及該怎麼預防出錯？</h2><p>在這次的案例中資訊系統擔任的是生產部門與業務部門溝通的橋樑，且是唯一的橋樑，如果橋梁發生了甚麼問題那雙方就失聯了！</p>
<p>在個案中導致生產部門與業務部門互相爭執的最大原因就是資訊組的程式是教給 SOHO 來寫，且李組長發現問題的時候並不是選擇將問題記錄下來並追縱，而是直接修改資料庫的資料，通過這次的測試，就隨之上線了。</p>
<p>已經提前偵測到橋梁壞掉的可能性，卻先做表面功夫之後沒有隨之補上，錯失了不讓錯誤預防；再來當發生錯誤時，很幸運的李組長已經知道問題在哪裡，卻在打電話的過程中發現當初原本的工作室已經消失了！這讓修補錯誤變成了難上加難的一件事。</p>
<p>且我認為李組長本身並不是對程式非常了解，沒有讓 SOHO 留下紀錄文件，公司自身的資訊部們也沒有辦法透過自身的能力去解決這種 bug。</p>
<p>根據上面可以總結出已下錯誤</p>
<ul>
<li>在測試的過程中遇到問題是掩蓋而不是將其揭發</li>
<li>工作室在做完後就消失，是否對於工作室的選擇有缺失</li>
<li>生產部門與業務部門本身並沒有太大的交流，沒有定期開會檢查</li>
<li>資訊部門不夠強大，對於簡單的錯誤沒有辦法進行修改</li>
<li>資訊組長沒有領導者風範，用人上的缺失</li>
</ul>
<p>因此相對應提出的預防錯誤如下</p>
<ul>
<li>需要有高階且中立主管在旁邊檢視整個系統測試過程，對於每一個缺失都對其紀錄，並且表示次系統不合格，當前不可以上線。</li>
<li>選擇信賴的廠商，並且簽訂合約保證在系統上線後一定時間內能夠進行錯誤回饋與修正。</li>
<li>生產部門與業務部門其高階主管可定期聚會，互相了解彼此狀態，如果有些許缺失也可以在談話中發現</li>
<li>高速成長的公司的資訊部門卻沒有辦法建立一個完整的資訊系統，我認為要對其進行檢討，將內部人員資訊技能水準提升</li>
<li>資訊組長遇到問題時並不是選擇要擔起責任，而是選擇逃避，因此應在資訊組中拔選優秀人才，並且擁有一定的職業道德與責任心。建議不空降資訊組長，較容易沒有責任心。</li>
</ul>
]]></content>
      <categories>
        <category>北科上課筆記</category>
        <category>個案報告 Case Report</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>北科大管理資訊系統筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>北科資財二管理資訊系統 個案四 水靈科技—高雄市C-bike</title>
    <url>/2021/04/12/case_report/NTUTifm_Manager_t04/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊與財金管理系大二下管理作業系統作業紀錄<br><font color="#dd0000">並非所有人都適用，此為老師所給予的題目。</font><br><strong>這是個人心得的筆記，可能不太適用會未來的學生</strong></p>
</blockquote>
<a id="more"></a>

<h2 id="QUESTION-請問你身為腳踏車使用者-有甚麼樣的因素會讓你”不想”使用該腳踏車-舉例-籃子可能很多垃圾-道路危險-歸還地點少…"><a href="#QUESTION-請問你身為腳踏車使用者-有甚麼樣的因素會讓你”不想”使用該腳踏車-舉例-籃子可能很多垃圾-道路危險-歸還地點少…" class="headerlink" title="QUESTION: 請問你身為腳踏車使用者, 有甚麼樣的因素會讓你”不想”使用該腳踏車? 舉例: 籃子可能很多垃圾. 道路危險, 歸還地點少…"></a>QUESTION: 請問你身為腳踏車使用者, 有甚麼樣的因素會讓你”不想”使用該腳踏車? 舉例: 籃子可能很多垃圾. 道路危險, 歸還地點少…</h2><ul>
<li>籃子裡有別人遺留下來的垃圾或物品<br>如果籃子裡面有別人的東西，我會覺得這台腳踏車先不要騎，怕有別人的東西；如果有遺留垃圾，我會覺得很沒有公德心，很不喜歡這種人，會覺得不必要幫他清理垃圾而不用此台腳踏車。</li>
<li>租借麻煩<br>之前有次，想要租 youbike，將悠遊卡拿去感應等待了近 10 秒卻還是沒有理我，當下會感到不開心，就不會想要使用 youbike 服務。</li>
<li>租借站離目的地太遠<br>如果最近的租借站離目的地太遠時，我就會選擇用其他方式，否則特意先將 youbike 騎到租借站還需要花 5 分鐘以上走到目的地，就會懶惰。</li>
<li>腳踏車沒有飲料架<br>有時候想要買飲料兜風的時候，因為 youbike 沒有飲料架，如果把飲料放在籃子裡就會撞來撞去，可能會讓飲料傾倒出，這種時候就不會想要用 youbike。</li>
<li>有一些國高中生或老人坐在腳踏車上休息<br>如果那台腳踏車上面有人坐著卻不租借，我會不開心，連而影響到不願意租借腳踏車。</li>
</ul>
]]></content>
      <categories>
        <category>北科上課筆記</category>
        <category>個案報告 Case Report</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>北科大管理資訊系統筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>北科資財二管理資訊系統 個案五 快樂遊網站—結構化專案工作規劃</title>
    <url>/2021/04/12/case_report/NTUTifm_Manager_t05/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊與財金管理系大二下管理作業系統作業紀錄<br><font color="#dd0000">並非所有人都適用，此為老師所給予的題目。</font><br><strong>這是個人心得的筆記，可能不太適用會未來的學生</strong></p>
<p>（請閱讀 W11_快樂遊網站—結構化專案工作規劃）</p>
</blockquote>
<a id="more"></a>

<h2 id="QUESTION-請根據人力資源方面考量，個案的三位工作人員，只能使用周末（六，日）加班嗎？如果需要，那需要多少加班時間？如果不需要，那有甚麼方法嗎？"><a href="#QUESTION-請根據人力資源方面考量，個案的三位工作人員，只能使用周末（六，日）加班嗎？如果需要，那需要多少加班時間？如果不需要，那有甚麼方法嗎？" class="headerlink" title="QUESTION:請根據人力資源方面考量，個案的三位工作人員，只能使用周末（六，日）加班嗎？如果需要，那需要多少加班時間？如果不需要，那有甚麼方法嗎？"></a>QUESTION:請根據人力資源方面考量，個案的三位工作人員，只能使用周末（六，日）加班嗎？如果需要，那需要多少加班時間？如果不需要，那有甚麼方法嗎？</h2><p>我認為是需要加班的，但只需要加班一天即可。</p>
<p>原本是預計完成一篇文章，必須要花費兩小時。我認為我們可以對尋找適合的網站此地方做優化，我認為並不需要找到30個網站這麼多，我們主要目的是推廣觀光局旅遊網站，我們只需要針對適合的旅遊論壇(如：PPT、DCARD)、BLOG PO 出其適合的文章。</p>
<p>我認為我們最多只需要找 16 個網站，如果論壇則我們尋找適合的板來進行發文；而文章的質量是我們最注重的，一個好的文章可以不被發現是業配文章或是不讓人反感，因此每篇1小時是可以被接收的。</p>
<p>而找到適合的板 PO文則需要花費 0.5 小時，由於我們認為部分論壇適合在不同的板不同角度的文章，因此這邊基本上也不建議進行調整也免造成不適合的文章在板上出沒。</p>
<p>再來我們認為需要花 6 小時的時間對我們所發布的文章進行留言，留下有價值的留言也助於網友們觸及到我們文章的機會。</p>
<h3 id="員工工作時數如下"><a href="#員工工作時數如下" class="headerlink" title="員工工作時數如下"></a>員工工作時數如下</h3><ul>
<li>加班一天約 8*3=24hr</li>
<li>禮拜一至禮拜五約 3<em>2</em>5=30hr</li>
<li>工作總和 30+24=54hr</li>
</ul>
<h3 id="工作時數如下"><a href="#工作時數如下" class="headerlink" title="工作時數如下"></a>工作時數如下</h3><ul>
<li>尋找適合的網站 18*0.5=8hr</li>
<li>適合的文章 30*1=30hr</li>
<li>將文章放在適合的板 16*0.5=8hr</li>
<li>在發布的文章下留言 6hr</li>
<li>總合為 30+8+8+6=52hr</li>
</ul>
<p>加班是很不樂見的一件事，但重點是突如其來的工作量往往讓人措手不及，因此我們建議公司應該要對資料組給予適當的休息，而非每次都安插緊急任務，會使員工士氣低落或經過文章鍛鍊後的員工，因壓力過大而跳槽去其他公司。</p>
]]></content>
      <categories>
        <category>北科上課筆記</category>
        <category>個案報告 Case Report</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>北科大管理資訊系統筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>北科資財二管理資訊系統 個案六 中信銀—eTrust網路銀行個資事件</title>
    <url>/2021/04/12/case_report/NTUTifm_Manager_t06/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊與財金管理系大二下管理作業系統作業紀錄<br><font color="#dd0000">並非所有人都適用，此為老師所給予的題目。</font><br><strong>這是個人心得的筆記，可能不太適用會未來的學生</strong></p>
<p>（請閱讀W12_中信銀—eTrust網路銀行個資事件）</p>
</blockquote>
<a id="more"></a>



<h2 id="請分析中信銀在此次事件中犯了那些錯誤"><a href="#請分析中信銀在此次事件中犯了那些錯誤" class="headerlink" title="請分析中信銀在此次事件中犯了那些錯誤?"></a>請分析中信銀在此次事件中犯了那些錯誤?</h2><p> 我認為中信金犯了這幾個錯誤：</p>
<ul>
<li>主管查核不確實</li>
<li>資訊附著在各部門，各部門主管與資訊人員有溝通問題</li>
<li>中信金不在擁有資訊高層，公司不再注重資訊</li>
<li>資訊部門的選拔依據</li>
</ul>
<h3 id="主管查核不確實"><a href="#主管查核不確實" class="headerlink" title="主管查核不確實"></a>主管查核不確實</h3><p>網站要上架前，內部的主管必須全部檢查一遍，確認並沒有任何錯誤後，才允許上架，這是每一個公司與每一位主管都必須負的責任義務。</p>
<h3 id="資訊附著在各部門，各部門主管與資訊人員有溝通問題"><a href="#資訊附著在各部門，各部門主管與資訊人員有溝通問題" class="headerlink" title="資訊附著在各部門，各部門主管與資訊人員有溝通問題"></a>資訊附著在各部門，各部門主管與資訊人員有溝通問題</h3><p>由於 2013 年後資訊部門被分散在於各部門，主管從專業主管也改變為業務主管，業務主管不懂資訊技術，當資訊人員完成自身作業時，需要一位有經驗的資訊組長來做檢查，但業務主管並不熟資訊技術，在檢查時就不一定能發現錯誤。</p>
<h3 id="中信金不在擁有資訊高層，公司不再注重資訊"><a href="#中信金不在擁有資訊高層，公司不再注重資訊" class="headerlink" title="中信金不在擁有資訊高層，公司不再注重資訊"></a>中信金不在擁有資訊高層，公司不再注重資訊</h3><p>與上面概念相同，但前面注重的是每一位資訊人員的權益，這裡則是注重於公司大型會議時資訊人員的權益，在一些公司重要會議時，如果沒有資訊部門給予資訊提醒或是一些資訊判斷，那麼在資訊成本、建置時間都不一定會有精準的判斷；也有可能上層的商業專業判斷並沒有辦法與資訊做結合，但會議卻沒有資訊部門提出其可能性，而導致上層與下層有溝通、實作障礙。</p>
<h3 id="資訊部門的選拔依據"><a href="#資訊部門的選拔依據" class="headerlink" title="資訊部門的選拔依據"></a>資訊部門的選拔依據</h3><p>由於資訊的選拔是透過人資部門進行選拔，但人資部門以不是資訊專長的人員，資訊很吃實戰經驗，如果只透過表面的履歷並不一定可以完全確認招募人才的資訊能力，如果有一個資訊部門可以全方位了解公司真正需要的諮詢人才，搭配上人資部門的專業判斷，就能找出真正適合公司的人才。</p>
<h2 id="你認為個資外洩的問題該由誰來負責"><a href="#你認為個資外洩的問題該由誰來負責" class="headerlink" title="你認為個資外洩的問題該由誰來負責?"></a>你認為個資外洩的問題該由誰來負責?</h2><p>公司主管、高層、資訊長。<br>將資訊部門裁撤，並將人員分布到各部門中，導致公司的資訊力量並不足以補足公司的資訊風險，各部門中沒有辦法有效監督資訊人員的作為、了解資訊人員的能力，才出現這次危機。</p>
<p>高層沒有意識到此問題的重要性，資訊長也應該在資訊部門是否裁撤會議上講出發生的問題以及後果，讓高層作判斷，一家銀行部門理應不該承受資訊風險，也可以從趨勢看出商業資訊明顯是大幅成長，而非下降，如果可以是一個資訊部門中分成許多組，每個組都可以互相搭配各部門，但並不受各部門影響，而是透過專業的資訊組長來進行規劃、溝通。<br>類似於委託方式，來完備各項資訊服務。</p>
]]></content>
      <categories>
        <category>北科上課筆記</category>
        <category>個案報告 Case Report</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>北科大管理資訊系統筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>北科資財二管理資訊系統 個案七 宸訊科技-開放政府資料打造精準農場決策</title>
    <url>/2021/05/28/case_report/NTUTifm_Manager_t07/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊與財金管理系大二下管理作業系統作業紀錄<br><font color="#dd0000">並非所有人都適用，此為老師所給予的題目。</font><br><strong>這是個人心得的筆記，可能不太適用會未來的學生</strong></p>
<p>（請閱讀W11_宸訊科技-開放政府資料打造精準農場決策）</p>
</blockquote>
<a id="more"></a>

<h2 id="請探討公司因業務分析需要從「政府開放系統」下載資料庫時，會遭遇什麼障礙？以及該怎麼解決？"><a href="#請探討公司因業務分析需要從「政府開放系統」下載資料庫時，會遭遇什麼障礙？以及該怎麼解決？" class="headerlink" title="請探討公司因業務分析需要從「政府開放系統」下載資料庫時，會遭遇什麼障礙？以及該怎麼解決？"></a>請探討公司因業務分析需要從「政府開放系統」下載資料庫時，會遭遇什麼障礙？以及該怎麼解決？</h2><p>公司在使用「政府開放系統」時，我們不一定可以獲得公司所需要的資料，由於「政府開放系統」的資料基本上不會有敏感、私人資訊，有時候企業需要往更深的資訊去探索相關可能性時就會被資料不足所限制住。</p>
<p>例如：氣象預報最多只會到鄉鎮市區，不會精準到街。</p>
<h3 id="此時解決方法應該是有兩種："><a href="#此時解決方法應該是有兩種：" class="headerlink" title="此時解決方法應該是有兩種："></a>此時解決方法應該是有兩種：</h3><ul>
<li>購買政府資料<br>購買政府資料相對簡單，不需要大量的檢測設備，只要與政府協議在合理的價格就可以進行購買，可以快速進行運用，但缺點是我們為資料的被動方<ul>
<li>有可能資料錯誤，但我們不好進行判定</li>
<li>政府的檢測設備不夠精準，有些資料有錯誤的問題</li>
<li>資訊的排版並不適合我們排版，我們需要花大量時間做資料預處理、資料清洗的動作</li>
</ul>
</li>
<li>自行蒐集資料<br>其中自行蒐集資料較不容易，但可以完整整理出適合公司的資料架構，如果公司需要對資料做運用時就非常容易，購買政府資料的缺點都可以透過自行蒐集資料來補足，但自行蒐集資料的缺點非常致命。 <ul>
<li>檢測設備費用</li>
<li>資料庫設備費用</li>
<li>檢測人員費用</li>
<li>資料庫人員費用</li>
<li>檢測資料是否正確</li>
<li>耗時，建立初期需要大量時間</li>
<li>是否會引起部分人民、財團反抗</li>
<li>資料保管成本</li>
</ul>
</li>
</ul>
<p>但如果能夠克服這些問題，我們可以建立起優秀的資料庫，並且完全配合公司的政策，需要甚麼都可以從公司資料庫提取，基本上所有的資料分析問題與 bug 公司都可以自行解決。<br>但公司需要大量成本與時間去做建立與維護，因此我認為除非有 5年以上的時間都在進行資料分析，否則能夠使用他人的正確資訊會更輕鬆、效率更快、更符合成本效益。</p>
]]></content>
      <categories>
        <category>北科上課筆記</category>
        <category>個案報告 Case Report</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>北科大管理資訊系統筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>北科資財二管理資訊系統 個案八 趣吧-網路共享旅遊平台</title>
    <url>/2021/05/28/case_report/NTUTifm_Manager_t08/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊與財金管理系大二下管理作業系統作業紀錄<br><font color="#dd0000">並非所有人都適用，此為老師所給予的題目。</font><br><strong>這是個人心得的筆記，可能不太適用會未來的學生</strong></p>
<p>（請閱讀W12_趣吧-網路共享旅遊平台）</p>
</blockquote>
<a id="more"></a>

<h2 id="趣吧-Tripbaa-當前之達人分潤方式是否合適"><a href="#趣吧-Tripbaa-當前之達人分潤方式是否合適" class="headerlink" title="趣吧 Tripbaa 當前之達人分潤方式是否合適?"></a>趣吧 Tripbaa 當前之達人分潤方式是否合適?</h2><p>目前趣吧是抽成 15%，我認為是合適的。</p>
<p>對於客人來說，旅遊重視的是品質，而非價格多個 1~5%，增加客人的旅遊品質提升比起增加小幅的價格來的更重要！</p>
<h3 id="如果改成-20-，我認為…"><a href="#如果改成-20-，我認為…" class="headerlink" title="如果改成 20%，我認為…"></a>如果改成 20%，我認為…</h3><p>如果趣吧抽成至 20%，也許會有些達人會想要做多量、多人，來增加自己的收入，如果因為這樣而讓每個人的旅遊品質降低時，顧客的回購率就不一定像現在高；我認為趣吧應該要主打的是 1<del>10 人的精緻旅遊團，因為達人在精、不在多，當所有的客戶都認為這是一趟不錯的旅遊品質時，他們在未來與其他朋友一同出遊時就有可能選擇我們的網頁選購旅遊行程！<br>旅遊者通常不會願意冒險去試試看別的廠商，因為旅遊的時間只有這麼一次，要大家都有時間一起旅遊，那一定是要獲得不錯的旅遊品質，即使價格多個 1</del>5 %。</p>
<h3 id="趣吧與食物外送平台一樣，達人-司機員-的服務態度是很重要的！"><a href="#趣吧與食物外送平台一樣，達人-司機員-的服務態度是很重要的！" class="headerlink" title="趣吧與食物外送平台一樣，達人(司機員)的服務態度是很重要的！"></a>趣吧與食物外送平台一樣，達人(司機員)的服務態度是很重要的！</h3><p>我們還必須注意，顧客選購旅遊行程時大多是針對品牌，也就是趣吧裡面的達人品質，如果達人並沒有給旅客帶來很好的體驗則客人會認為趣吧的品質都不好。<br>舉個例子來說：如果北科出了一個學生考上哈佛大學，大家會突然對北科的評價變好，但其實只有北科的一個學生這麼優秀，其他人還是一樣。</p>
<p>食物可以不好吃，大家不會拒用此平台，只會躲避此行程。<br>但達人不好，沒有人會喜歡此平台。</p>
<h3 id="我的見解"><a href="#我的見解" class="headerlink" title="我的見解"></a>我的見解</h3><p>我認為透過漲價的方式來給趣吧帶來更好的收益是最好的選擇，說服達人漲價其實並不困難，畢竟達人還是能夠獲得漲價中的85% 利益，而我們也可以增加 15% 利益。<br>但也必須注意如果旅遊行程太貴，導致一個月只有一組購買此行程會導致公司營收過低時，就必須稍微降價。</p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://disp.cc/b/163-bMIN" target="_blank" rel="noopener">同意讓熊貓抽30%的店家在想什麼？ by ptt</a></p>
]]></content>
      <categories>
        <category>北科上課筆記</category>
        <category>個案報告 Case Report</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>北科大管理資訊系統筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>演算法知識 - heap sort 堆積排序</title>
    <url>/2021/05/31/Explain_Algorithm/heap_sort/</url>
    <content><![CDATA[<h2 id="heap-sort-堆積排序-介紹與實作原理"><a href="#heap-sort-堆積排序-介紹與實作原理" class="headerlink" title="heap sort 堆積排序 介紹與實作原理"></a>heap sort 堆積排序 介紹與實作原理</h2><blockquote>
<p>堆積排序是透過最大堆積樹來進行排序，其實作與原理如下<br>主要核心是要讓 root 大於左右子樹，由於我們每次都能夠找出 root，且必定大於左右子樹，因此我們只需要將 root 提出來，再讓左右子樹中的最大值替補 root，依序遞迴擊可。</p>
<ul>
<li>我們用一維陣列來表達我們的二元樹</li>
<li>其中 index 0 一定是二元樹中最大的數字</li>
<li>透過遞迴，參數： i<ul>
<li>以當前 i 節點為 root，L、R 分別是左右子樹</li>
<li>如果左子樹數值比 i 數值還要大，那就讓 i 與左子樹交換</li>
<li>如果右子樹數值比 i 數值還要大，那就讓 i 與右子樹交換</li>
<li>如果先前有進行交換的動作，那我們就讓與 i 交換的子樹再重新進行遞迴</li>
</ul>
</li>
</ul>
<p>我們主要是維護二元堆積樹的 root 最大，如果 root 與其他數值有做交換，那我們必須讓 root 往下至其適合的位置，適合的位置：左右子樹都沒有比他還大，root 本身比左右子樹更大</p>
<p>時間複查度為 \(O(n log n)\)，在某些演算法中會用到堆積排序，因此算是篇重要的排序演算法之一。</p>
</blockquote>
<a id="more"></a>

<h2 id="參考來源"><a href="#參考來源" class="headerlink" title="參考來源"></a>參考來源</h2><p><a href="https://www.geeksforgeeks.org/heap-sort/" target="_blank" rel="noopener">HeapSort by geeksforgeeks</a></p>
<h2 id="heap-sort-堆積排序-程式碼說明與應用"><a href="#heap-sort-堆積排序-程式碼說明與應用" class="headerlink" title="heap sort 堆積排序 程式碼說明與應用"></a>heap sort 堆積排序 程式碼說明與應用</h2><p>透過程式碼來進行說明相信會更好理解，以下我們示範從小到大排序</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> num[] = &#123;<span class="number">4</span>,<span class="number">96</span>,<span class="number">1546</span>,<span class="number">13</span>,<span class="number">48</span>,<span class="number">34</span>,<span class="number">77</span>,<span class="number">48</span>,<span class="number">31</span>&#125;; </span><br><span class="line"><span class="keyword">int</span> num_size; <span class="comment">//陣列的 size</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">()</span></span>&#123; <span class="comment">//輸出結果</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; num_size ; i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; num[i] &lt;&lt; <span class="string">' '</span> ;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> i)</span></span>&#123; <span class="comment">//建構、調整堆積樹，i 表示數值、n 表示樹的 size</span></span><br><span class="line">    <span class="keyword">int</span> root = i; <span class="comment">//root </span></span><br><span class="line">    <span class="keyword">int</span> L = <span class="number">2</span> * i; <span class="comment">//subtree</span></span><br><span class="line">    <span class="keyword">int</span> R = <span class="number">2</span> * i + <span class="number">1</span>; <span class="comment">//subtree</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//注意：以下只有交換 index</span></span><br><span class="line">    <span class="keyword">if</span>(L &lt; n &amp;&amp; num[L] &gt; num[root]) root = L; <span class="comment">//如果 root 比左子樹小就交換</span></span><br><span class="line">    <span class="keyword">if</span>(R &lt; n &amp;&amp; num[R] &gt; num[root]) root = R; <span class="comment">//如果 root 比右子樹小就交換</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果 root 已經被交換</span></span><br><span class="line">    <span class="keyword">if</span>(root != i)&#123;</span><br><span class="line">        swap(num[root], num[i]); <span class="comment">//這邊才真正進行交換</span></span><br><span class="line">        heapify(n, root); <span class="comment">//繼續遞迴，讓 i 可以到達完整的最大堆積樹，也就是當 i 為 root，左、右子樹都比 root 小。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heap_sort</span><span class="params">()</span></span>&#123; <span class="comment">//進行 heap_sort 排序</span></span><br><span class="line">    <span class="comment">//將每個數值放到適合的堆積位置</span></span><br><span class="line">    <span class="comment">//注意：i 是從 num_size/2 開始，因為我們是從最下層的子樹(root、L、R) 不斷做 heapify</span></span><br><span class="line">    <span class="comment">//到第一層的子樹，這樣才可以將之前堆積的狀態延續至上層。</span></span><br><span class="line">    <span class="comment">//如果從第一層開始做，那每一個 root 都只會是 L、R 的最大值，</span></span><br><span class="line">    <span class="comment">//但上層的 root 並不一定會大於下層或下下層的 root，這整棵樹就並不是一個完整堆積樹</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = num_size/<span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) heapify(num_size, i);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不斷地拿出 root(最大數值)，放到數列最後面。</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = num_size<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        swap(num[<span class="number">0</span>], num[i]); <span class="comment">//與數列中的最後一個數值交換。這樣越大的數值會被放到越後面</span></span><br><span class="line">        heapify(i, <span class="number">0</span>); <span class="comment">//由於 root 已經不再是最大，因此再次進行 heapify</span></span><br><span class="line">        <span class="comment">//注意：如果我們已經將 1 次 root 與數列最後一個數值交換，那我們下次就不可以把數列中的最後一個數值放入 heapify，不然這次做的堆積樹又會變成下次堆積樹 root，因此我們要將 num_size 減少。</span></span><br><span class="line">        <span class="comment">//因此這裡的 i 為未確定排序陣列的大小。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    num_size = <span class="keyword">sizeof</span>(num) / <span class="keyword">sizeof</span>(num[<span class="number">0</span>]); <span class="comment">//紀錄陣列 size</span></span><br><span class="line">    heap_sort();</span><br><span class="line">    output();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>由於 C++ 已經有很多 sort 套件了，因此我在高中學會後我就再也沒有去複習這些知識。</p>
<p>剛好現在上課有用到那就來複習，順便把它寫出邏輯八！</p>
<h2 id="程式執行結果"><a href="#程式執行結果" class="headerlink" title="程式執行結果"></a>程式執行結果</h2><blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1Mh7M-7VluSDr0HlvYdabkXABieMRcdpJ&export=download" alt=""></p>
</blockquote>
]]></content>
      <categories>
        <category>演算法知識</category>
      </categories>
      <tags>
        <tag>程式解題</tag>
        <tag>演算法知識</tag>
        <tag>數論 Math theorm</tag>
      </tags>
  </entry>
  <entry>
    <title>北科資工二多媒體技術與應用 第七周個人作業 - 討論適合 yolov4 的情境、yoloV4 解決那些問題，為何被大量使用</title>
    <url>/2021/06/01/Media_with_Image_recognition/NTUTcs_MediaHW07T01/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊工程系大二下多媒體技術與應用作業紀錄<br><font color="#dd0000">並非所有人都適用，部分對我而言稍加容易的內容並不會寫在此內。</font><br><strong>這是學習後心得的筆記，可能不太適用會未來的學生</strong></p>
<p>由於我沒有學習過裡面的理論，因此這是資工大二學生透過網路與自身理解的筆記，學習價值並不高、且可能擁有大量錯誤。</p>
</blockquote>
<a id="more"></a>

<h2 id="請提出一種情境設想適合使用-YOLOv4並寫下原因。"><a href="#請提出一種情境設想適合使用-YOLOv4並寫下原因。" class="headerlink" title="請提出一種情境設想適合使用 YOLOv4並寫下原因。"></a>請提出一種情境設想適合使用 YOLOv4並寫下原因。</h2><p>我認為 YOLOv4 很適合用於醫院的人流控制，可以在重要的醫護室、病房、手術房中進行職業辨識，辨識是醫生？護士？或是其他職業。</p>
<p>例如病房的話，我們就可以檢測有多少護士現在在哪裡？哪個病房裡面有幾位護士、幾位家屬，可以讓護理長方便了解現在每個病房有多少護士，哪個病房裡面有過多的家屬，可能引發危險的狀態或不利於護士照顧病人。</p>
<h2 id="請思考-YOLOv4-在近幾年被大量使用的原因，對比HOG與SIFT，YOLOv4-解決了哪些問題"><a href="#請思考-YOLOv4-在近幾年被大量使用的原因，對比HOG與SIFT，YOLOv4-解決了哪些問題" class="headerlink" title="請思考 YOLOv4 在近幾年被大量使用的原因，對比HOG與SIFT，YOLOv4 解決了哪些問題"></a>請思考 YOLOv4 在近幾年被大量使用的原因，對比HOG與SIFT，YOLOv4 解決了哪些問題</h2><p>YOLOv4 與 hog、sift 最大的不同為，yolov4 可以在一張圖片中辨識許多物件，且 yoloV4 訓練是透過類神經網路演算法，可讓訓練變得很簡單，前提是要克服環境的設定、colab 的環境後最重要的一環，我們可以透過 labelImg 來對每一個圖像進行人工辨識，連國中生都可以操作。</p>
<p>後兩者則是 SVM，則需要我們去對 kernel、C、gamma 去設定，普通的學生不一定可以找到最適點。<br>如果是 Sift 則需要提取特徵，還要避免圖片特徵不足的問題。<br>Hog 則需要我們去思考 block and cell 的問題。</p>
<p>Faster R-CNN，其主要概念如下</p>
<ul>
<li>捲積層取出特徵</li>
<li>ROI 將特徵像似的分類 </li>
<li>CNN 提取 ROI 的分類</li>
<li>softMAX 分類</li>
</ul>
<p>但還是有些許的缺點，例如我們再提取特徵項似的分類時，我們還是要對每一個分類進行計算，無法省略這步驟，在特徵項似的分類量非常大的時候，計算就會變為更緩慢。</p>
<p>但 Faster R-CNN 提高準確率與速度，實現了點到點檢測目標框架，生成建議框架只需要大約 10s。</p>
]]></content>
      <categories>
        <category>北科上課筆記</category>
        <category>多媒體與圖像辨識 Image Recognition</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>北科大多媒體技術與應用筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>北科資工二多媒體技術與應用 第八次團隊作業 - 使用 google colab 與 LSTM 進行期貨價格預測</title>
    <url>/2021/05/31/Media_with_Image_recognition/NTUTcs_MediaHW08G01/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊工程系大二下多媒體技術與應用作業紀錄<br><font color="#dd0000">並非所有人都適用，部分對我而言稍加容易的內容並不會寫在此內。</font><br><strong>這是學習後心得的筆記，可能不太適用會未來的學生</strong></p>
<p>由於我沒有學習過裡面的理論，因此這是資工大二學生透過網路與自身理解的筆記，學習價值並不高、且可能擁有大量錯誤。</p>
<p>訓練的資料是從 <a href="https://api.finmindtrade.com/docs" target="_blank" rel="noopener">FinMind Api</a> 取得，謝謝他們的無私奉獻，讓我們可以輕鬆讀取資料。</p>
</blockquote>
<a id="more"></a>

<h2 id="專案說明"><a href="#專案說明" class="headerlink" title="專案說明"></a>專案說明</h2><blockquote>
<p>如紅色線條上方說明文字<br><img src="https://drive.google.com/u/2/uc?id=1xF9nYaQNrgflJApxgQTi8tPVUohvVzRV&export=download" alt=""></p>
</blockquote>
<p>此文章的目的是紀錄如何透過 LSTM 與 google colab 來進行期貨價格預測</p>
<h2 id="Long-Short-Term-Memory-LSTM-模型說明"><a href="#Long-Short-Term-Memory-LSTM-模型說明" class="headerlink" title="Long Short-Term Memory(LSTM) 模型說明"></a>Long Short-Term Memory(LSTM) 模型說明</h2><p>LSTM 主要是透過 cell 組成，cell 由輸入門、遺忘門、輸出門、單元狀態組成。</p>
<ul>
<li>輸入門：決定當下輸入的資料有多少要保留到此 cell </li>
<li>遺忘門：決定前一個 cell 給我們的資料要保留多少</li>
<li>輸出門：決定有多少資料要輸出給下一個 cell</li>
</ul>
<p>詳細的講解可以看這篇，解釋得很好，<a href="https://www.zhihu.com/question/64470274/answer/256379387" target="_blank" rel="noopener">Keras关于LSTM的units参数，还是不理解? by lonlon ago</a></p>
<h2 id="LSTM-訓練流層"><a href="#LSTM-訓練流層" class="headerlink" title="LSTM 訓練流層"></a>LSTM 訓練流層</h2><ul>
<li>讀取資料、資料前處理</li>
<li>將資料處理成 train_dataset、test_dataset</li>
<li>建立 LSTM 神經網路模型，設定模型內的神經網路</li>
<li>將資料送入網路進行訓練</li>
<li>使用訓練好的模型進行預測</li>
</ul>
<h2 id="使用-google-colab-進行期貨價格預測"><a href="#使用-google-colab-進行期貨價格預測" class="headerlink" title="使用 google colab 進行期貨價格預測"></a>使用 google colab 進行期貨價格預測</h2><p>如果不知道 colab 如何打開，可以看看 <a href="https://theriseofdavid.github.io/2021/05/19/Media_with_Image_recognition/NTUTcs_MediaHW07G01/#%E4%BD%BF%E7%94%A8-google-colab-%E4%BE%86%E9%80%B2%E8%A1%8C%E5%9C%96%E5%83%8F%E8%BE%A8%E8%AD%98" target="_blank" rel="noopener">使用 google colab 與進行 yolo 訓練 by 大衞的筆記</a></p>
<h3 id="import-package"><a href="#import-package" class="headerlink" title="import package"></a>import package</h3><p>第一步先 import 資料</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> MinMaxScaler</span><br><span class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span> Sequential</span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Dense, LSTM</span><br></pre></td></tr></table></figure>

<h3 id="從-Findmind-API-獲取期貨資料"><a href="#從-Findmind-API-獲取期貨資料" class="headerlink" title="從 Findmind API 獲取期貨資料"></a>從 Findmind API 獲取期貨資料</h3><p>Findmind API 是蒐集了主要大國投資商品的資料，包括台股、期貨….。</p>
<p>我們只需要 call API，就可以獲得大量的資料，是非常方便的工具。</p>
<p>謝謝 Findmind 團隊們用心支援且有免費的項目可讓學生順利用來測試。</p>
<ul>
<li><a href="https://github.com/FinMind/FinMind" target="_blank" rel="noopener">Findmind github</a></li>
<li><a href="https://finmind.github.io/tutor/TaiwanMarket/Derivative/#taiwanfuturesdaily" target="_blank" rel="noopener">Findmind API 期貨獲得資料教學</a></li>
</ul>
<p>接下來我們 call api，獲得資料</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">url = <span class="string">"https://api.finmindtrade.com/api/v4/data"</span></span><br><span class="line">parameter = &#123;</span><br><span class="line">    <span class="string">"dataset"</span>: <span class="string">"TaiwanFuturesDaily"</span>,</span><br><span class="line">    <span class="string">"data_id"</span>: <span class="string">"TX"</span>,</span><br><span class="line">    <span class="string">"start_date"</span>: <span class="string">"2021-05-01"</span>,</span><br><span class="line">    <span class="string">"end_date"</span>: <span class="string">"2021-05-29"</span>,</span><br><span class="line">    <span class="string">"token"</span>: <span class="string">""</span>, <span class="comment"># 參考登入，獲取金鑰</span></span><br><span class="line">&#125;</span><br><span class="line">resp = requests.get(url, params=parameter)</span><br><span class="line">data = resp.json()</span><br><span class="line">data = pd.DataFrame(data[<span class="string">"data"</span>])</span><br><span class="line">print(data.head())</span><br><span class="line">data = data.set_index(<span class="string">"date"</span>)</span><br><span class="line">print(data)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>其完成後主要如下，雖然我覺得 google colab 會隱藏資訊不是很好…。但是他提供強大運算，超讚的拉！<br><img src="https://drive.google.com/u/2/uc?id=1IFmjMTlz7uUDh73bCkvBIlPharJUtjim&export=download" alt=""></p>
</blockquote>
<h3 id="畫出趨勢圖"><a href="#畫出趨勢圖" class="headerlink" title="畫出趨勢圖"></a>畫出趨勢圖</h3><p>我們先畫出趨勢圖，檢查這份資料是否有異常的情況</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#劃出趨勢圖</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_picture</span><span class="params">(data = data)</span>:</span></span><br><span class="line">  data[<span class="string">'close'</span>].plot()</span><br><span class="line">  plt.figure(figsize=(<span class="number">100</span>, <span class="number">50</span>)) <span class="comment">#figsize 設定寬度、長度</span></span><br><span class="line">  plt.show()</span><br><span class="line">get_picture(data)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>趨勢圖大概如下<br><img src="https://drive.google.com/u/2/uc?id=1V67PQEpM-Ail8UTgazmAJBGz-lS8bXq-&export=download" alt=""></p>
</blockquote>
<h3 id="將-dataframe-的-date-轉換為時間軸，好讓-LSTM-認清楚新舊資料"><a href="#將-dataframe-的-date-轉換為時間軸，好讓-LSTM-認清楚新舊資料" class="headerlink" title="將 dataframe 的 date 轉換為時間軸，好讓 LSTM 認清楚新舊資料"></a>將 dataframe 的 date 轉換為時間軸，好讓 LSTM 認清楚新舊資料</h3><p>於是我們將資料進行轉換</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#轉換序列</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">processing</span><span class="params">(data=data, long=<span class="number">11</span>)</span>:</span> <span class="comment">#long 是我們的記憶長度，也就是我們通常用 11 筆來預測預估一筆資料</span></span><br><span class="line">  <span class="comment">#將資料型態轉換為 float，怕資料讀取時 dataframe 誤以為字串</span></span><br><span class="line">  data[<span class="string">"close"</span>] = data[<span class="string">"close"</span>].astype(float) </span><br><span class="line">  sample_size = len(data) - long + <span class="number">1</span> <span class="comment">#計算樣本長度</span></span><br><span class="line">  print(<span class="string">"共有&#123;&#125;個樣本"</span>.format(sample_size))</span><br><span class="line">  </span><br><span class="line">  data_sample = [] <span class="comment">#新增 list 用來儲存</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(sample_size): </span><br><span class="line">    data_sample.append(data[<span class="string">"close"</span>][i:i+long]) <span class="comment">#將前 11 筆資料，一同放入 data_sample</span></span><br><span class="line">    <span class="comment">#注意：python dataframe [i:i+3]，最後一筆資料是不會抓的</span></span><br><span class="line">    <span class="comment">#舉例：df[1:3] py 只抓兩筆資料</span></span><br><span class="line"></span><br><span class="line">  data_sample = np.array(data_sample) <span class="comment">#將 list 轉換為 num array </span></span><br><span class="line">  <span class="keyword">return</span> data_sample</span><br><span class="line"></span><br><span class="line">processing(data)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>完成後大概如下<br><img src="https://drive.google.com/u/2/uc?id=16cZvDIlhf766yYCulYcA7cxXmLEkF67Q&export=download" alt=""></p>
</blockquote>
<h3 id="建立-LSTM-模型"><a href="#建立-LSTM-模型" class="headerlink" title="建立 LSTM 模型"></a>建立 LSTM 模型</h3><p>此 function 則是建立且訓練 LSTM 網路</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">stock_LSTM</span><span class="params">(input_data=None)</span>:</span> <span class="comment">#input_data 要訓練的資料</span></span><br><span class="line">  scaler_x = MinMaxScaler() <span class="comment">#將原先的資料數值分布改分散至 0~1 區間，稱為歸一化</span></span><br><span class="line">  scaler_y = MinMaxScaler() <span class="comment">#同上</span></span><br><span class="line">  x = input_data[:, :<span class="number">-1</span>] <span class="comment"># x 軸為所有期貨資料</span></span><br><span class="line">  y = input_data[:, <span class="number">-1</span>]  <span class="comment">#y 軸則是最後一筆期貨資料</span></span><br><span class="line">  x = scaler_x.fit_transform(x) <span class="comment">#資料進行歸一化，使用方法為找出轉換資料規則</span></span><br><span class="line">  y = scaler_y.fit_transform(np.reshape(y, (len(y), <span class="number">1</span>))) <span class="comment">#將資料進行 reshape</span></span><br><span class="line">  spilt = int(len(y) * <span class="number">0.8</span>) <span class="comment">#0.8 為訓練集 0.2 為測試集</span></span><br><span class="line">  x_train = x[:spilt] <span class="comment">#py dataframe 切資料</span></span><br><span class="line">  x_test = x[spilt:]</span><br><span class="line">  y_train = y[:spilt]</span><br><span class="line">  y_test = y[spilt:] <span class="comment">#以上</span></span><br><span class="line">  print(x_train.shape[<span class="number">0</span>], x_train.shape[<span class="number">1</span>])</span><br><span class="line">  x_train = np.reshape(x_train, (x_train.shape[<span class="number">0</span>], x_train.shape[<span class="number">1</span>], <span class="number">1</span>)) <span class="comment">#將資料 reshape</span></span><br><span class="line">  x_test = np.reshape(x_test, (x_test.shape[<span class="number">0</span>], x_test.shape[<span class="number">1</span>], <span class="number">1</span>)) <span class="comment">#將資料 reshape</span></span><br><span class="line"></span><br><span class="line">  model = Sequential() <span class="comment">#初始化 Sequentail 模型，序列模型</span></span><br><span class="line">  <span class="comment">#加入 LSTM 深度學習，使用 50 個維度，並輸入資料</span></span><br><span class="line">  model.add(LSTM(<span class="number">50</span>, input_shape=(x_train.shape[<span class="number">1</span>],<span class="number">1</span>), return_sequences=<span class="literal">True</span>))</span><br><span class="line">  <span class="comment">#model.add(LSTM(100)) 如果使用 100 個維度就使用這個，越多維度理論上會越精準，但要小心 overfitting</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">#加入 dense 激勵函數，主要是判定權重用</span></span><br><span class="line">  model.add(Dense(<span class="number">1</span>, activation=<span class="string">"linear"</span>)) </span><br><span class="line">  model.compile(loss=<span class="string">"mse"</span>, optimizer=<span class="string">"rmsprop"</span>) <span class="comment">#進行訓練，選擇遺失函數的方法、與 optimizer 方法</span></span><br><span class="line">  print(<span class="string">"訓練中..."</span>)</span><br><span class="line">  <span class="comment">#開始進行模型擬和，batch_size 的大小，epochs 疊代大小，</span></span><br><span class="line">  <span class="comment">#validation_split 將訓連集資料一部份用於模型測試</span></span><br><span class="line">  history = model.fit(x_train, y_train, batch_size=<span class="number">8</span>, epochs=<span class="number">300</span>, validation_split=<span class="number">0.1</span>) </span><br><span class="line"></span><br><span class="line">  <span class="comment">#繪製多圖，row 1 column 2</span></span><br><span class="line">  fig, (ax1, ax2) = plt.subplots(<span class="number">1</span>, <span class="number">2</span>, figsize=(<span class="number">12</span>, <span class="number">4.5</span>))</span><br><span class="line"></span><br><span class="line">  <span class="comment">#劃出 train_loss，這個資料的不確定姓</span></span><br><span class="line">  ax1.set_title(<span class="string">"train_loss"</span>)</span><br><span class="line">  ax1.set_ylabel(<span class="string">"loss"</span>)</span><br><span class="line">  ax1.set_xlabel(<span class="string">"Epoch"</span>)</span><br><span class="line">  ax1.plot(history.history[<span class="string">"loss"</span>])</span><br><span class="line"></span><br><span class="line">  <span class="comment">#劃出預測圖</span></span><br><span class="line">  predict = model.predict(x_test)</span><br><span class="line">  <span class="comment">#將原本進行規一化的資料，反轉為原始數據</span></span><br><span class="line">  y_test = scaler_y.inverse_transform(np.reshape(y_test, (len(y_test), <span class="number">1</span>)))</span><br><span class="line">  <span class="comment">#將原本進行規一化的資料，反轉為原始數據</span></span><br><span class="line">  predict = scaler_y.inverse_transform(predict)</span><br><span class="line"></span><br><span class="line">  <span class="comment">#劃出預測圖</span></span><br><span class="line">  ax2.set_title(<span class="string">"stock predict result"</span>)</span><br><span class="line">  ax2.set_ylabel(<span class="string">"price"</span>)</span><br><span class="line">  ax2.set_xlabel(<span class="string">"time"</span>)</span><br><span class="line">  ax2.plot(predict, <span class="string">"g:"</span>)</span><br><span class="line">  ax2.plot(y_test, <span class="string">"r-"</span>)</span><br><span class="line">  fig.show()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>必須看到疊代跑到 300 才表示 LSTM 完成，接下來則會看到兩張圖<br>train_loss 表示資料的不確定性、stock predict result 的綠色折線圖則是原始的歷史價格走勢、紅色則是 LSTM 的預測價格走勢，可以發現 LSTM 其實理論上蠻準的，用於預測趨勢是可行的！<br><img src="https://drive.google.com/u/2/uc?id=1-QEv6PvpZy3KkGOK_fHhxTCbScygMRkW&export=download" alt=""></p>
</blockquote>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p>北科資工大二下 多媒體技術與應用 L10 課程<br><a href="https://wenwender.wordpress.com/2019/10/18/%E5%AF%A6%E4%BD%9C%E9%80%8F%E9%81%8Elstm%E9%A0%90%E6%B8%AC%E8%82%A1%E7%A5%A8/" target="_blank" rel="noopener">實作:透過LSTM預測股票 by nthu</a><br><a href="https://ithelp.ithome.com.tw/articles/10191725" target="_blank" rel="noopener">Day 05：Keras 模型、函數及參數使用說明 by I code so I am</a><br><a href="https://keras-cn.readthedocs.io/en/latest/layers/core_layer/" target="_blank" rel="noopener">Keras 中文文檔</a><br><a href="https://keras.io/api/optimizers/" target="_blank" rel="noopener">Keras Optimizers</a><br><a href="https://blog.csdn.net/yunfeather/article/details/106463327" target="_blank" rel="noopener">tensorflow中model.fit()用法 by yunfeather</a><br><a href="https://blog.csdn.net/htuhxf/article/details/82986440" target="_blank" rel="noopener">python 可视化：fig, ax = plt.subplots()画多表图的3中常见样例 &amp; 自定义图表格式 by htuhxf</a><br><a href="https://blog.csdn.net/qq_34840129/article/details/86257790" target="_blank" rel="noopener">inverse_transform()的用法 by bebr</a><br><a href="https://keras.io/zh/getting-started/sequential-model-guide/" target="_blank" rel="noopener">开始使用 Keras Sequential 顺序模型 by Keras 中文文檔</a><br><a href="https://keras.io/zh/optimizers/" target="_blank" rel="noopener">RMSprop by Keras 中文文檔</a><br><a href="https://blog.csdn.net/weixin_40683253/article/details/81508321" target="_blank" rel="noopener">数据归一化 - MinMaxScaler()/MaxAbsScaler() - Python代码 by 黄大侠aa</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>謝謝助教與老師！這是我很有收穫的一次！</p>
<p>上次的 yolo 其實也大有收穫，但是 yolo 太多我不懂的問題了，讓我在突破的時候充滿痛苦感QQ，但是這次的 LSTM 就不會很有痛苦感，而且可以用於我感興趣的。</p>
<p>這次助教的 code 給的很詳細，然後我在寫 blog 時就可以將一些在寫 code 沒有注意到的事項補足、加強，這樣我就可以將應用 LSTM 用的在更好些。</p>
<p>希望我可以應用看看股票預測。</p>
<p>也要謝謝力瑋告訴我 finMind API 可以讓我獲得資料，這是非常好用的 API，也要謝謝力瑋可以在 6/1 01:04 時還可以解釋我的問題。</p>
<p>嗚嗚，我的資工導師QQ。</p>
]]></content>
      <categories>
        <category>北科上課筆記</category>
        <category>多媒體與圖像辨識 Image Recognition</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>北科大多媒體技術與應用筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>演算法知識 - 插值搜尋 inerpolation search</title>
    <url>/2021/06/01/Explain_Algorithm/interpolation_search/</url>
    <content><![CDATA[<h2 id="插值搜尋-inerpolation-search-介紹與實作原理"><a href="#插值搜尋-inerpolation-search-介紹與實作原理" class="headerlink" title="插值搜尋 inerpolation search 介紹與實作原理"></a>插值搜尋 inerpolation search 介紹與實作原理</h2><blockquote>
<p>插值搜尋主要用在於資料量大，且資料離散程度大致相同的數列。</p>
<p>其概念與<a href="https://theriseofdavid.github.io/2020/11/15/Explain_Algorithm/binary_search/" target="_blank" rel="noopener">二分搜尋 by 大衞的筆記</a> 概念大致相同，只有對於 mid 並不同。</p>
<p>二分搜尋再分成左右子樹時，是切半分配。<br>插值搜尋則是透過斜率公式去進行優化。</p>
<p>其主要插值法的選擇原理如下<br>value 是我們要查詢的值，那 \(x_1, x_2\) 則是我們現在進行搜尋的區間，因為我們要搜尋的數列是<strong>已經排序好</strong>的數列，那我們假設區間的資料都是相同離散分布，因此理論上我們可以透過斜率來猜測我們的 value 應該位於 m 處(數列 index)。<br>也就是我們透過 \(m = \frac{(value - y_1)(x_2 - x_1)}{(y_2 - y_1)} + x_1\)。</p>
<p><img src="https://drive.google.com/u/2/uc?id=1c-CeW3Cg8KwD7aruMKQ3lqAxUQY6EDQH&export=download" alt=""></p>
</blockquote>
<a id="more"></a>

<h2 id="插值搜尋-inerpolation-search-程式碼說明與應用"><a href="#插值搜尋-inerpolation-search-程式碼說明與應用" class="headerlink" title="插值搜尋 inerpolation search  程式碼說明與應用"></a>插值搜尋 inerpolation search  程式碼說明與應用</h2><p>透過程式碼來進行說明相信會更好理解，以下我們示範搜尋 4 這個位置。</p>
<p>由於我們資料離散程度相當，因此只需要一次我們就可以成功找到。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> num[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;; <span class="comment">//已經排序好的數列 </span></span><br><span class="line"><span class="keyword">int</span> num_size; <span class="comment">//數列長度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">interpolation_search</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123; <span class="comment">//val 要查詢的值</span></span><br><span class="line">    <span class="keyword">int</span> L = <span class="number">0</span>; <span class="comment">//左邊界</span></span><br><span class="line">    <span class="keyword">int</span> R = num_size<span class="number">-1</span>; <span class="comment">//右邊界</span></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"interpolation search start.\n"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(R &gt;= L)&#123; <span class="comment">//如果右邊界 &gt;= 左邊界，就繼續執行</span></span><br><span class="line">        <span class="comment">//斜率優化公式找出 mid</span></span><br><span class="line">        <span class="keyword">int</span> mid = L + (val-num[L]) * (R-L) / (num[R]-num[L]);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ++cnt &lt;&lt; <span class="string">" search. find "</span> &lt;&lt; num[mid] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">        <span class="keyword">if</span>(num[mid] == val) <span class="keyword">return</span> mid; <span class="comment">//如果成功找到，就輸出 index</span></span><br><span class="line">        <span class="comment">//如果 num[mid] &gt; val，表示資料在左邊界，那就將左邊界改為 mid+1</span></span><br><span class="line">        <span class="keyword">if</span>(num[mid] &gt; val) L = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//如果 num[mid] &lt; val，表示資料在右邊界，那就將右邊界改為 mid+1 </span></span><br><span class="line">        <span class="keyword">if</span>(num[mid] &lt; val) R = mid; </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"cat't find "</span> &lt;&lt; val &lt;&lt; <span class="string">"\n"</span>; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//無法找到，輸出 -1</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    num_size = <span class="keyword">sizeof</span>(num) / <span class="keyword">sizeof</span>(num[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">int</span> val = <span class="number">4</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">" position is "</span> &lt;&lt; interpolation_search(val) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://ithelp.ithome.com.tw/articles/10207069" target="_blank" rel="noopener">[演算法] 插補搜尋 (Interpolation Search) by ramonliao</a><br><a href="http://notepad.yehyeh.net/Content/Algorithm/Search/InterpolationSearch/InterpolationSearch.php#" target="_blank" rel="noopener">[演算法] 插補搜尋法(Interpolation Search) by yehyeh notepad</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>由於 C++ 已經有搜尋的函式 <code>upper_bound</code>、<code>lower_bound</code>，因此我在高中學會後我就再也沒有去複習這些知識。</p>
<p><a href="https://theriseofdavid.github.io/2021/02/28/C++/C++_binarysearch/" target="_blank" rel="noopener">QUESTION! C++11 upperbound and lowerbound 用法 by 大衞的筆記</a></p>
<p>剛好現在上課有用到那就來複習，順便把它寫出邏輯八！</p>
<h2 id="程式執行結果"><a href="#程式執行結果" class="headerlink" title="程式執行結果"></a>程式執行結果</h2><blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1n6OF2TTPELwlThdEbcZqI8DpZLBBiy5v&export=download" alt=""></p>
</blockquote>
]]></content>
      <categories>
        <category>演算法知識</category>
      </categories>
      <tags>
        <tag>程式解題</tag>
        <tag>演算法知識</tag>
        <tag>數論 Math theorm</tag>
      </tags>
  </entry>
  <entry>
    <title>演算法知識 - 費氏搜尋 Fibonacci Search</title>
    <url>/2021/06/02/Explain_Algorithm/fib_search/</url>
    <content><![CDATA[<h2 id="費氏搜尋-Fibonacci-Search-介紹與實作原理"><a href="#費氏搜尋-Fibonacci-Search-介紹與實作原理" class="headerlink" title="費氏搜尋 Fibonacci Search 介紹與實作原理"></a>費氏搜尋 Fibonacci Search 介紹與實作原理</h2><blockquote>
<p>主要是透過費氏數列所組成的費氏二元樹來對數列進行搜尋，主要的搜尋方式與二元搜尋大概相同，不同之處在於費氏二元樹與二分搜尋的二元樹構造不同。</p>
<p>費氏二元樹在往左右子樹時，只需要使用加減法，不使用乘或除法。<br>有些 CPU 在乘除法的運算來的過大。</p>
<p>費氏二元樹，我們透過此圖進行理解</p>
<ul>
<li>有一個數列長度有 33，裡面的數字從 1~33，</li>
<li>我們必須先建立一顆費氏二元樹，我們先透過費氏數列找出 \(f(n) &gt;= 33\)，其中 \(n = 8\) </li>
<li>\(fib(8) = 35\)，其實我們可以發現 \(fib(8) = fib(7) + fib(6) \)，其實可以看的出來一些端倪，\(root = 左子樹、右子樹\)，因此 \(fib(8)\) 就是這邊的 root、\(fib(7)\) 是左子樹、\(fib(6)\) 是右子樹</li>
<li>左子樹的樹值一定比 root 小，右子樹的數值一定比 root 大</li>
<li>其實費氏樹與二元樹相同，只是二元樹是左右子樹的葉節點一樣大，<strong>而費氏樹的左子樹葉節點數量有 \(fib(n-1)\)、費氏樹的右子樹葉節點數量有 \(fib(n-2)\)</strong>。</li>
<li>再來我們就是不斷地用<strong>加減法</strong>來算出下個子樹的 index。</li>
<li>需要記住費氏數列的 index 從 0 開始。<br><img src="https://drive.google.com/u/2/uc?id=1FofkEgPv9i5rwiMkSYSDaB4Jb8JtJk5A&export=download" alt=""><br><a href="http://yljh21328.github.io/blog/posts/2014/06/search/[search]_fibonacci_search.html" target="_blank" rel="noopener">[search] fibonacci search by Chris Yang 學習筆記，如果作者不願意圖片供我引用，請告訴我，我會馬上刪除，讓你感到不舒服我很抱歉QQ</a></li>
</ul>
<p>定義 value: 為我們要查詢的樹值<br>那我們主要就是從 root 開始找</p>
<ul>
<li>如果 root == value，退出 search</li>
<li>如果 value &gt; root 往右子樹找</li>
<li>如果 value &lt; root 往左子樹找</li>
</ul>
</blockquote>
<a id="more"></a>


<h2 id="費氏搜尋-Fibonacci-Search-程式碼說明與應用"><a href="#費氏搜尋-Fibonacci-Search-程式碼說明與應用" class="headerlink" title="費氏搜尋 Fibonacci Search 程式碼說明與應用"></a>費氏搜尋 Fibonacci Search 程式碼說明與應用</h2><p>透過程式碼來進行說明相信會更好理解，以下我們示範搜尋 4 這個位置。</p>
<p>由於我們資料離散程度相當，因此只需要一次我們就可以成功找到。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> num[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;; <span class="comment">//已經排序好的數列 </span></span><br><span class="line"><span class="keyword">int</span> num_size; <span class="comment">//數列長度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123; <span class="comment">//費式數列</span></span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">1</span> || i == <span class="number">0</span>) <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">return</span> fib(i<span class="number">-1</span>) + fib(i<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib_search</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123; <span class="comment">//費氏搜尋</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"fib search start.\n"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">2</span>, cnt=<span class="number">0</span>;</span><br><span class="line">    num_size--; <span class="comment">//我們實際的 index 最大只到 9，但長度有 10</span></span><br><span class="line">    <span class="keyword">while</span>(num_size &gt; fib(i)) i++; <span class="comment">//找出 fib(i) &gt;= num_size</span></span><br><span class="line"></span><br><span class="line">    i--; <span class="comment">//折半找出 root</span></span><br><span class="line">    <span class="keyword">int</span> root = fib(i); <span class="comment">//root </span></span><br><span class="line">    <span class="keyword">int</span> diff1 = fib(i<span class="number">-1</span>); <span class="comment">//fib(root-1) </span></span><br><span class="line">    <span class="keyword">int</span> diff2 = fib(i<span class="number">-2</span>); <span class="comment">//fib(root-2) 我們會透過 diff1 and diff2 來找出左右子樹位置。</span></span><br><span class="line">    root--; <span class="comment">//由於我們 index 從 0 開始，因此 root-1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//    ^ ^</span></span><br><span class="line">    <span class="comment">//1 1 3 5 8 13 22 35 </span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"root "</span> &lt;&lt; root &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ++cnt &lt;&lt; <span class="string">" search. find "</span> &lt;&lt; num[root] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(val == num[root]) <span class="keyword">return</span> root; <span class="comment">//找到 val 的位置，輸出 index</span></span><br><span class="line">        <span class="keyword">if</span>(val &lt; num[root])&#123; <span class="comment">//往左子樹的方向找</span></span><br><span class="line">            <span class="comment">//我們主要透過此方式來推出左子樹位置</span></span><br><span class="line">            <span class="comment">//fib(n) = fib(n-1) + fib(n-2)，假設這三個數我們都已知</span></span><br><span class="line">            <span class="comment">//fib(n-1) = fib(n-2) + fib(n-3)，由於我們知道 fib(n-1) 與 fib(n-2)，就可以求出 fib(n-3)</span></span><br><span class="line"></span><br><span class="line">            root -= diff2; <span class="comment">//往左子樹的 root(index) 找</span></span><br><span class="line">            <span class="keyword">int</span> temp = diff1; <span class="comment">//temp = fib(n-1)</span></span><br><span class="line">            diff1 = diff2; <span class="comment">//diff1 = fib(n-2)</span></span><br><span class="line">            diff2 = temp - diff2; <span class="comment">//fib(n-3) = fib(n-1) - fib(n-2)，分別對應左邊 3 個變數</span></span><br><span class="line">            i--; <span class="comment">//fib 的數列降低一層，因為左子樹的數量是 fib(n-1)</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(val &gt; num[root])&#123;</span><br><span class="line">            root += diff2; <span class="comment">//往右子樹的 root(index) 找</span></span><br><span class="line">            diff1 = diff1 - diff2; <span class="comment">//fib(n-3) = fib(n-1) - fib(n-2)，分別對應左邊 3 個</span></span><br><span class="line">            diff2 = diff2 - diff1; <span class="comment">//fib(n-4) = fib(n-2) - fib(n-3)，分別對應左邊 3 個</span></span><br><span class="line">            i -= <span class="number">2</span>; <span class="comment">//fib 的數列降低兩層，因為右子樹的數量是 fib(n-2)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"cat't find "</span> &lt;&lt; val &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//無法找到，輸出 -1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    num_size = <span class="keyword">sizeof</span>(num) / <span class="keyword">sizeof</span>(num[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">int</span> val = <span class="number">4</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">" position is "</span> &lt;&lt; fib_search(val) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="http://yljh21328.github.io/blog/posts/2014/06/search/[search]_fibonacci_search.html" target="_blank" rel="noopener">[search] fibonacci search by Chris Yang 學習筆記</a><br><a href="https://www.geeksforgeeks.org/fibonacci-search/" target="_blank" rel="noopener">Fibonacci Search by GeeksforGeeks</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>高中之前就有學習過 fib serach，但學會後我就再也沒有去複習這些知識。</p>
<p>剛好現在上課有用到那就來複習，順便把它寫出邏輯八！</p>
<h2 id="程式執行結果"><a href="#程式執行結果" class="headerlink" title="程式執行結果"></a>程式執行結果</h2><blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1qDJVh6K0nybr25b7wNCxSwRJ3fzSQJSV&export=download" alt=""></p>
</blockquote>
]]></content>
      <categories>
        <category>演算法知識</category>
      </categories>
      <tags>
        <tag>程式解題</tag>
        <tag>演算法知識</tag>
        <tag>數論 Math theorm</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces 1513D - GCD and MST(設計解題)</title>
    <url>/2021/06/03/Codeforces/Codeforces%201521C/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>Nastia 有一個數列，但我們並不知道數列裡面的數值，我們現在必須知道這些數值是甚麼，其中我們得知數列裡面的數值，是 1 ~ 數列長度。</p>
<p>我們可以像 Nastia 進行詢問，但 Nastia 不接受普通的詢問方式，她接受的詢問方式如下</p>
<ul>
<li>\(t=1 : max(min(x,p_i), min(x+1, p_j)) \)</li>
<li>\(t=2 : mim(max(x,p_i), max(x+1, p_j)) \) </li>
<li>其中 \(t\) 為我們選擇哪種查詢公式，\(p_i,p_j\) 則是數列的 index 當下數值，\(x\) 則是我們任意給的值，但 \(x\) 必須是數列中的數字。</li>
<li>\(t=1\) or \(t=2, 1 \leq i,j \leq n, i != j, 1 \leq x \leq n-1\)，一定要符合這些條件。  </li>
</ul>
<p>我們可以對 Nastia 最多查詢 \( \frac{3*n}{2} + 30 \)，必須在這些次數前確認出所有的數列。</p>
<p>如果已經確定數列，那輸出格式為 <code>! a b c</code>，其中 a,b,c 為數列的數字， index 從 1 開始。</p>
<p><a href="https://codeforces.com/contest/1521/problem/C" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li>理解交互式解題</li>
<li>找出 \(t=1, t=2\) 公式，在甚麼情況下可以省略裡面一些邏輯式</li>
<li>如何確定數列中的每個數值</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>我們可以對這題進行分析。<br>稍微看看這兩個公式</p>
<blockquote>
<ul>
<li>\(t=1 : max(min(x,p_i), min(x+1, p_j)) \)</li>
<li>\(t=2 : min(max(x,p_i), max(x+1, p_j)) \) </li>
</ul>
</blockquote>
<h3 id="公式分析一下"><a href="#公式分析一下" class="headerlink" title="公式分析一下"></a>公式分析一下</h3><ul>
<li>\(t=1 : max(min(x,p_i), min(x+1, p_j)) \)<br>當 \(x\) 設為無限大時，那我們可以簡化為 \(max(p_i,p_j) \)</li>
<li>\(t=2 : min(max(x,p_i), max(x+1, p_j)) \)<br>當 \(x\) 設為無限小時，那我們可以簡化為 \(min(p_i,p_j) \)</li>
</ul>
<h3 id="我們沒有辦法設定為無限小或無限大，那該怎麼辦呢？"><a href="#我們沒有辦法設定為無限小或無限大，那該怎麼辦呢？" class="headerlink" title="我們沒有辦法設定為無限小或無限大，那該怎麼辦呢？"></a>我們沒有辦法設定為無限小或無限大，那該怎麼辦呢？</h3><ul>
<li>那我們可以設為數列的最大數值與最小數值，分別式 \(n,1\)。</li>
<li>現在我們知道可以將公式化簡了，但我沒有辦法知道 index \(i,j\) 要放哪些數值<br>很簡單，我們只要將 \(min(p_i,p_j) \)，將 \(p_j\) 放最大，那 \(p_i\) 就是我們要的數值。<br>另外一個公式亦同。</li>
<li>我們以 <strong>我們只要將 \(min(p_i,p_j) \)，將 \(p_j\) 放最大，那 \(p_i\) 就是我們要的數值。</strong> 來進行探討</li>
<li>將 \(p_j\) 放最大，那我們要先找出數列中的最大值<br>由於題目的查詢方式不可以讓我們的 \(x\) 放最大，因此就用數列最大值。</li>
</ul>
<h3 id="那我們進行分析，如何找出數列中最大值"><a href="#那我們進行分析，如何找出數列中最大值" class="headerlink" title="那我們進行分析，如何找出數列中最大值"></a>那我們進行分析，如何找出數列中最大值</h3><ul>
<li>根據上面的公式，我們有提到，當 \(x\) 設為無限小時，那我們可以簡化為 \(min(p_i,p_j) \)，因此我們要找到的是此公式中的最大值。</li>
<li>因此公式就是 \(t=1 : max(min(n,p_i), min(n+1, p_j)) = n \)，n 是數列最大值，我們把 x 設為 n<br>理論上現在我們可以知道數列最大值是在 \(i,j\) 這兩個位置，但我要怎麼寫呢？</li>
<li>不斷循序漸進，也就是 \(i =i, j = i+1\)，for 迴圈一次進行 i,j</li>
<li>我已經知道最大的數值在 \(i,j\) 位置，那我要怎麼確定她在 i 還是 j 呢？</li>
<li>似乎不太能夠確定呢…</li>
</ul>
<h3 id="那我們再稍微簡化一下，我們鎖定-j-的位置一定是題目最大值的位置。"><a href="#那我們再稍微簡化一下，我們鎖定-j-的位置一定是題目最大值的位置。" class="headerlink" title="那我們再稍微簡化一下，我們鎖定 j 的位置一定是題目最大值的位置。"></a>那我們再稍微簡化一下，我們鎖定 j 的位置一定是題目最大值的位置。</h3><ul>
<li>因此公式就是 \(t=1 : max(min(n-1,p_i), min(n, p_j)) = n\)，n 是數列最大值，我們把 x 設為 n</li>
<li>這樣 \(min(n, p_j) \) 一定是題目最大值。</li>
<li>但現在有個問題，那如果依照迴圈去寫假如數列 index i 才是最大值，那該怎麼辦<ul>
<li>我們可以知道一件事情，\(min(n-1,p_i)\)，最大的數值為 \(n-1\)</li>
<li>如果 \(p_i = n\)，那 \(min(n, p_j) &lt; n \)</li>
<li>因此只要我們 \(t=1 : max(min(n-1,p_i), min(n, p_j)) = n-1\)，我們就讓 \(i,j\) 位置互換</li>
</ul>
</li>
<li>紀錄最大的數值位置</li>
</ul>
<h3 id="現在我們有了最大的數值位置，求出其他位置數值"><a href="#現在我們有了最大的數值位置，求出其他位置數值" class="headerlink" title="現在我們有了最大的數值位置，求出其他位置數值"></a>現在我們有了最大的數值位置，求出其他位置數值</h3><ul>
<li>可以用 \(t=2 : min(max(x,p_i), max(x+1, p_j)) \) 反推</li>
<li>現在我們定義 \(p_m\) 表示最大的數值位置</li>
<li>\(t=2 : min(max(x,p_i), max(x+1, p_m)) \)<ul>
<li>\(max(x+1, p_m) &gt; p_i \) </li>
<li>因此我們只要把 x 設到最小即可。</li>
<li>數列中最小值是 0。</li>
</ul>
</li>
<li>因此我們只要對每一個 index 進行一次查詢就能推出答案！</li>
</ul>
<p><strong>注意：不可以在查詢時出現 \(? 2 p_i p_m 1 \)，其中 \(p_i == p_m\)，題目有說明 i 不可以等於 j</strong>，如果你這樣做則 codeforces 則會輸出 WA: <code>wrong answer Indices should be distinct (test case 1)</code></p>
<h3 id="稍微檢查下查詢次數會不會大於-frac-3-n-2-30"><a href="#稍微檢查下查詢次數會不會大於-frac-3-n-2-30" class="headerlink" title="稍微檢查下查詢次數會不會大於 \( \frac{3*n}{2} + 30 \)"></a>稍微檢查下查詢次數會不會大於 \( \frac{3*n}{2} + 30 \)</h3><ul>
<li>找出數列最大值 index 進行查詢次數 \(n/2+1\)</li>
<li>每一個數值與數列最大值進行 \(t=2\)查詢次數 \(n-1\)</li>
<li>因此最多的查詢次數只會有 \( \frac{3*n}{2}  \)</li>
</ul>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://blog.csdn.net/JophieQu/article/details/116524323" target="_blank" rel="noopener">C. Nastia and a Hidden Permutation by JophieQu</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>其實我之前並沒有寫過交互式解題，因此對這種流程非常不熟，是我的朋友們告訴我交互式解題我們應該要注重的是 input，而非 output，我原本在這邊思考了很久都一直鬼打牆…。腦袋不給力阿QQ。</p>
<p>後來再看 JophieQu 大大的詳解時，我一直寫錯…，我忘記 \(n-1 = max(min(n-1,p_i), min(n, p_j))) 的現象，因此要進行確認，然後再將 \(i,j\) 位置顛倒，為甚麼會忘記呢？因為我那時候認為我這樣比較好寫。<del>可是是錯的阿</del></p>
<p>然後我還忘記題目的說明，題目有說明 不可以在查詢時出現 \(? t i j x \)，其中 \(i != j\)，對！我有看到。<br>但是我把每個 index 都帶入 \(t=2\) 去推出數列的數值，卻一直得到 WA，我就一直用紙筆去推敲，就是得不出這樣會錯的結果，後來再重新看一遍題目才知道，…，\(p_m\) 也是數列中的一個 index，如果直接用 for 迴圈去跑每一個 index，那其中會有一個 index 與 \(m\) 相同。</p>
<p>唉，還不夠聰明，腦袋還不夠好。還需要多多訓練自己的腦袋R。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">30000</span>;</span><br><span class="line"><span class="keyword">int</span> T, a, n;</span><br><span class="line"><span class="keyword">int</span> num[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="built_in">string</span> cmd, <span class="keyword">int</span> t, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> x)</span></span>&#123; <span class="comment">//用於查詢</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; cmd &lt;&lt; <span class="string">" "</span> &lt;&lt; t &lt;&lt; <span class="string">' '</span> &lt;&lt; i &lt;&lt; <span class="string">' '</span> &lt;&lt; j &lt;&lt; <span class="string">' '</span> &lt;&lt; x &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; value;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="keyword">int</span> max_index = <span class="number">0</span>, value; <span class="comment">//max_index 為記錄最大值的 index</span></span><br><span class="line">        <span class="comment">// value 為 query function 回傳值</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i+=<span class="number">2</span>)&#123; <span class="comment">//找出最大的數值</span></span><br><span class="line">            <span class="keyword">if</span>(n &amp; <span class="number">1</span> &amp;&amp; i == n)&#123; <span class="comment">//由於我是 i+=2，但有可能數列是奇數的情況，因此如果</span></span><br><span class="line">                <span class="comment">//數列是奇數，並且到現在還沒有找到最大值，那麼最後一個數值一定是最大值。</span></span><br><span class="line">                max_index = n; <span class="comment">//紀錄最大值 index</span></span><br><span class="line">                num[n] = i; <span class="comment">//並放入數列中</span></span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">//找到最大值跳出迴圈</span></span><br><span class="line">            &#125;</span><br><span class="line">            value = query(<span class="string">"?"</span>, <span class="number">1</span>, i, i+<span class="number">1</span>, n<span class="number">-1</span>); <span class="comment">//進行查詢，查詢 i,j 內是否有數列最大值</span></span><br><span class="line">            <span class="keyword">if</span>(value == n)&#123; <span class="comment">//如果有，並且出現在 j 位置，j = i+1</span></span><br><span class="line">                max_index = i+<span class="number">1</span>; <span class="comment">//紀錄最大值 index</span></span><br><span class="line">                num[i+<span class="number">1</span>] = n;  <span class="comment">//並放入數列中</span></span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">//找到最大值跳出迴圈</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(value == n<span class="number">-1</span>)&#123; <span class="comment">// p_i 有 7 or 8 的可能，我們在一次進行驗證</span></span><br><span class="line">                value = query(<span class="string">"?"</span>, <span class="number">1</span>, i+<span class="number">1</span>, i, n<span class="number">-1</span>); <span class="comment">//將 i,j 相反後再 query 一次</span></span><br><span class="line">                <span class="keyword">if</span>(value == n)&#123; <span class="comment">//如果發現 i 真的是最大值</span></span><br><span class="line">                    max_index = i;  <span class="comment">//紀錄最大值 index</span></span><br><span class="line">                    num[i] = n; <span class="comment">//並放入數列中</span></span><br><span class="line">                    <span class="keyword">break</span>; <span class="comment">//找到最大值跳出迴圈</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//cout &lt;&lt; "max_index " &lt;&lt; max_index &lt;&lt; '\n';</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123; <span class="comment">//找到最大值後，利用 t=2 公式找出每個數列的數值</span></span><br><span class="line">            <span class="comment">//由於 max_index 的值會在 i 裡面，題目的查詢有說明不可以用兩個 index 相同去查詢</span></span><br><span class="line">            <span class="comment">//因此我們要避免這種情況，才會寫這個 if </span></span><br><span class="line">            <span class="keyword">if</span>(i == max_index) <span class="keyword">continue</span>; </span><br><span class="line">            num[i] = query(<span class="string">"?"</span>, <span class="number">2</span>, i, max_index, <span class="number">1</span>); <span class="comment">//找出 i 數列的值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"!"</span>; <span class="comment">//輸出答案</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; num[i];</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="思考流程"><a href="#思考流程" class="headerlink" title="思考流程"></a>思考流程</h2><p>透過紙筆與黑板而思考而成的片段，放在網路上供我紀念XD</p>
<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1v-asVesqGLqzgFYY8dml9OmyKN_k7ciw&export=download" alt=""></p>
</blockquote>
]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>設計解題</tag>
        <tag>程式解題</tag>
        <tag>交互式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 google app script 擴增 google docs 功能</title>
    <url>/2021/06/07/google/google_app_script_connect_google_doc/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記僅記錄大衛如何使用 google docs 中的建立程式碼，來寫成一份外掛程式。<br><font color="#dd0000">並非所有人都適用，部分對我而言稍加容易的內容並不會寫在此內。</font><br><strong>這是學習後心得的筆記，可能不太適用會未來的學生，或是版本更新就不適用</strong></p>
<p>由於我並不是 google app script 大神，可能有些地方沒有寫得很棒，還請多包涵。</p>
</blockquote>
<a id="more"></a>

<h2 id="Google-App-Script-是甚麼"><a href="#Google-App-Script-是甚麼" class="headerlink" title="Google App Script 是甚麼"></a>Google App Script 是甚麼</h2><ul>
<li>是 Google 以 JS 為基底再衍伸出的一種腳本</li>
<li>能專門在 Google Workspace 進行輕量應用開發<br>Google Workspace: gmail, drive, Jam….，只要是 google 提供的服務都是 Google Workspace</li>
<li>Google App Script 可以在 docs、sheet、slide 建立插件。</li>
</ul>
<h1 id="主題：Google-App-Script-連接-Google-docs"><a href="#主題：Google-App-Script-連接-Google-docs" class="headerlink" title="主題：Google App Script 連接 Google docs"></a>主題：Google App Script 連接 Google docs</h1><p>這次我們要講 Google App Script 應用在 Google docs，大家應該都很清楚，我們有時候再運用 Google docs 上總是會覺得功能不夠多，不夠好用，這時候自己寫一個外掛程式就可以幫助我們，那要怎麼寫呢？</p>
<p>首先，我們必須要學會 JavaScript，這應該對大家都還行。</p>
<p>這裡我們會細分兩部分</p>
<ul>
<li>再 google docs 加入外掛，供使用者進行使用</li>
<li>使用追縱器，追蹤使用者打開文件<br>如果是 google sheet，甚至可以追蹤文件修改。</li>
</ul>
<h2 id="google-docs-加入外掛，供使用者進行使用"><a href="#google-docs-加入外掛，供使用者進行使用" class="headerlink" title="google docs 加入外掛，供使用者進行使用"></a>google docs 加入外掛，供使用者進行使用</h2><ul>
<li>這裡我們只是做一個簡單的快速開始，我之前有再工作時應用到，但是這是工作機密因此無法洩漏，</li>
<li>不過有興趣做此應用的讀者可以考慮做做看：蒐集新聞，並放入 google docs 裡面，製作成報刊。</li>
<li>我知道 google 的 example，並不是非常好用，所以我在這邊做一個簡單介紹，方便使用者快速上手。</li>
<li><strong>那我們範例的專案就是讓 google docs 裡面的單字放到 alert 來提醒我們。</strong></li>
<li>提供一個方向給初學者參考，google App Script 都是以 class 為主，因此當我們需要用到 google docs 我們就使用 <code>DocumentApp</code>、使用 google sheet 就用 <code>spreadsheet</code>，一些常用的套件則也有 class。<del>稍微比一般的 js 容易閱讀、使用</del><ul>
<li><a href="https://developers.google.com/apps-script/reference/drive" target="_blank" rel="noopener">Google Drive Class</a></li>
<li><a href="https://developers.google.com/apps-script/reference/document" target="_blank" rel="noopener">Google Document Class</a></li>
<li>舉著兩個例子，大家可以去這邊看看 Google App Script 的 class  <blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1LEErmw-9Scy7otm4E_noaxiP0TwzFdrM&export=download" alt=""></p>
</blockquote>
<h3 id="介紹開始"><a href="#介紹開始" class="headerlink" title="介紹開始"></a>介紹開始</h3></li>
</ul>
</li>
<li>首先我們必須先開啟一份 google docs</li>
<li>之後我們點選 工具 &gt; 指令碼編輯器，注意：指令碼編輯器必須要是此文件的編輯者<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1K28zuxBX0oGW4WwqGFevYjBQ33Mi9WvT&export=download" alt=""></p>
</blockquote>
</li>
<li>再來我們進入程式碼編輯區，大家可以自行摸索下</li>
<li>我們可以從 <a href="https://developers.google.com/apps-script/reference/document" target="_blank" rel="noopener">Google Document Class</a> 得知，google Docs 的程式結構類似於 html，因此必須熟讀 <a href="https://developers.google.com/apps-script/reference/document" target="_blank" rel="noopener">Google Document Class</a> 才可以知道程式碼要如何運作。</li>
<li>將此專案進行改名，點此改名，這邊我們改名 <strong>跳出 word 內所有單字訊息</strong><blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=16fd8c3nD4GRVVI9kA5YhkKaKo-u9U-k3&export=download" alt=""></p>
</blockquote>
</li>
</ul>
<p>這邊我們則直接寫程式，直接作範例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>)</span>&#123; <span class="comment">//主要執行區</span></span><br><span class="line">  <span class="comment">//使我們的外掛套件增加一個按鈕，當點擊此按鈕執行 function pathfinder_update_word</span></span><br><span class="line">  <span class="keyword">var</span> ui = DocumentApp.getUi(); </span><br><span class="line">  ui.createAddonMenu()</span><br><span class="line">  .addItem(<span class="string">"print doc word"</span>, <span class="string">"print_doc_word"</span>)</span><br><span class="line">  .addToUi();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print_doc_word</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">  <span class="keyword">var</span> ui = DocumentApp.getUi(); <span class="comment">//使用 ui.class </span></span><br><span class="line">  <span class="keyword">var</span> result = ui.alert(<span class="string">"準備將文字進行輸出..."</span>); <span class="comment">//送出警示</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//告訴 google 你想要用程式操作的 google doc 是正在執行的 google doc </span></span><br><span class="line">  <span class="keyword">var</span> source = DocumentApp.getActiveDocument(); </span><br><span class="line">  <span class="keyword">var</span> body = source.getBody(); <span class="comment">//進入 doc body</span></span><br><span class="line">  <span class="keyword">var</span> get_text = body.getText(); <span class="comment">//獲得 body 內的所有文字</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> result = ui.alert(get_text);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Google-App-Script-操作"><a href="#Google-App-Script-操作" class="headerlink" title="Google App Script 操作"></a>Google App Script 操作</h3><ul>
<li>先將資料進行儲存(ctrl+s)，之後我們要選擇當程式啟動後，第一個呼叫的程式是哪個，這裡的話則是呼叫 <code>main</code><blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1UyxmhczY5xClJQ0Rf7CITrxaJAcCW0my&export=download" alt=""></p>
</blockquote>
</li>
<li><strong>寫完後的第一次執行</strong>，通常會告訴你需要授權這份專案存取你的資料，那我們一定也會答應的，除非你自己寫的這份程式碼有毒XDDD。</li>
<li>因此點選 審查權限 &gt; 選擇帳戶(必須與 Google App Script 的帳戶相同) &gt; 允許。</li>
<li>執行程式</li>
</ul>
<h3 id="Google-Doc-加入外掛套件"><a href="#Google-Doc-加入外掛套件" class="headerlink" title="Google Doc 加入外掛套件"></a>Google Doc 加入外掛套件</h3><ul>
<li>Google App Script 操作完成後，點選 外掛程式 &gt; 跳出 word 內所有單字訊息 &gt; update keyword<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1b2I1v8Www260lE4Um7e-nDadkv5pdVXb&export=download" alt=""></p>
</blockquote>
</li>
<li>成果畫面 A<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=171fsp9wfbGl86qM8FvHgzvO6__XxzU5A&export=download" alt=""></p>
</blockquote>
</li>
<li>成果畫面 B<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=19pGM5VjUA0k0eSULCeg-vGfC_MLdttIb&export=download" alt=""></p>
</blockquote>
</li>
</ul>
<h3 id="讓此外掛永遠存在此文件"><a href="#讓此外掛永遠存在此文件" class="headerlink" title="讓此外掛永遠存在此文件"></a>讓此外掛永遠存在此文件</h3><ul>
<li>有些讀者應該有發現，當我們 refresh google doc 則我們的外掛套件就會消失</li>
<li>如果我們執行過程式，則 google doc 的外掛程式<strong>永遠只會是第一次執行的結果</strong>，如果先前有做修改，那我們就 refresh google doc，從做上面兩大操作。</li>
<li>那當我們執行好後，應該要如何讓我們寫的程式外掛一直都存在這份文件呢？</li>
<li>請按照此照片的步驟進行點選，中間的主畫面則交給使用者進行微調。<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1ofM-huUw2T8NNpMKaMn9kNoRXFJUU2qq&export=download" alt=""></p>
</blockquote>
</li>
</ul>
<h2 id="Google-App-Script-使用其他方式來編輯-google-doc"><a href="#Google-App-Script-使用其他方式來編輯-google-doc" class="headerlink" title="Google App Script 使用其他方式來編輯 google doc"></a>Google App Script 使用其他方式來編輯 google doc</h2><p>有時候我們一份程式碼並不一定只用在當前的 google docs <code>DocumentApp.getActiveDocument()</code>，如果他有需要用到其他 google doc <code>DocumentApp.openById(id)</code>，另一份 google doc 如果想要透過 google doc ID 來編輯、追蹤此文件，則可以查看下行連結<br><a href="https://stackoverflow.com/questions/67443862/can-i-use-documentapp-openbyid-with-read-only-permission" target="_blank" rel="noopener">Can I use DocumentApp.openById() with read only permission? by stackoverflow</a></p>
<p>而 google doc ID 我們要怎麼知道呢？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;docs.google.com&#x2F;document&#x2F;d&#x2F;XXX&#x2F;edit</span><br></pre></td></tr></table></figure>

<p>其中 XXX 處中的所有文字就是這份文件的 ID。</p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://developers.google.com/apps-script/reference/drive" target="_blank" rel="noopener">Google Drive Class</a><br><a href="https://developers.google.com/apps-script/reference/document" target="_blank" rel="noopener">Google Document Class</a><br><a href="https://developers.google.com/apps-script/reference/document/element" target="_blank" rel="noopener">Google Document Interface Element</a><br><a href="https://stackoverflow.com/questions/67443862/can-i-use-documentapp-openbyid-with-read-only-permission" target="_blank" rel="noopener">Can I use DocumentApp.openById() with read only permission? by stackoverflow</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>Google 的說明文件真的很不好閱讀欸…，給我快速開始拉QQQ。</p>
<p>想當然，Google 的服務自然是非常好用，非常棒，但有些部分還沒有到完全齊全，對使用者來說可以達到百分之百的友善。</p>
<p>如果讀者有好好的去查看他們的說明文件則會發現他們的 method 都沒有給舉例，因此常常會發現，他告訴我有這個函式、這個功能！可是我不知道怎麼用，怎麼寫…。接下來我們再去用 google search 去找如何使用此函數，或是他有沒有一些必備的前置動作之類的，畢竟雲端程式最大的缺點就是 debug 非常不容易…，每次 debug 都跟通靈沒啥不一樣QQ。</p>
<p>但還是謝謝 google 發明這份程式且願意免費讓我來使用QQ，很感謝你們，嗚嗚。<br>但拜託不要養套殺我拉。</p>
]]></content>
      <categories>
        <category>Google App Script</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>google</tag>
        <tag>Google App Script</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 Google App Script 來輸入文字，並加入打字特效</title>
    <url>/2021/06/07/google/google_doc_add_text_anime/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記僅記錄大衛如何使用 google docs 中的建立程式碼，來寫成一份外掛程式。<br><font color="#dd0000">並非所有人都適用，部分對我而言稍加容易的內容並不會寫在此內。</font><br><strong>這是學習後心得的筆記，可能不太適用會未來的學生，或是版本更新就不適用</strong></p>
<p>由於我並不是 google app script 大神，可能有些地方沒有寫得很棒，還請多包涵。</p>
</blockquote>
<a id="more"></a>

<h2 id="使用-google-app-script-來輸入文字，並加入打字特效"><a href="#使用-google-app-script-來輸入文字，並加入打字特效" class="headerlink" title="使用 google app script 來輸入文字，並加入打字特效"></a>使用 google app script 來輸入文字，並加入打字特效</h2><ul>
<li><a href="https://theriseofdavid.github.io//2021/06/07/google/google_app_script_connect_google_doc/" target="_blank" rel="noopener">必須要先熟知此文件，看這份文件才容易理解、閱讀</a></li>
<li>這邊會講述一些，如果想要給女友製造一些小浪漫時，我們可以怎麼做XD。</li>
<li>或是如果要在報告時，稍微做出一些酷酷的特效。</li>
<li><strong>這種方式會大量的浪費 google 效能，請大家三思</strong></li>
</ul>
<p>其主要是這樣的，如果讀者之前有用過</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> source = DocumentApp.getActiveDocument(); </span><br><span class="line"><span class="keyword">var</span> body = source.getBody(); <span class="comment">//進入 doc body</span></span><br><span class="line"><span class="keyword">var</span> printer = body.editAsText(); <span class="comment">//啟動編輯模式</span></span><br><span class="line">printer.appendText(text[i]); <span class="comment">//輸入文字</span></span><br><span class="line">source.saveAndClose(); <span class="comment">//google App Script 可以不用寫這行，那預設會到整份程式碼執行完畢才關閉</span></span><br><span class="line"><span class="comment">//關閉程式碼，將 printer 中的所有文字輸出到 word 上</span></span><br></pre></td></tr></table></figure>

<p>可以發現，其實 printer 只是一個 buffer，他會等到 <code>source.saveAndClose();</code> 執行 or 整份程式碼結束時才會更新 word，但如果我們需要先送出資料讓使用者輸入後我們再進行下一步動作，或是打字特效時就很不方便。</p>
<p>因此，如果要先將存在 buffer 裡面的字串都先輸出，我們就必須要先 <code>source.saveAndClose();</code>，之後就可以將所有字串先輸出到 google docs 上。</p>
<p>再來我們可以透過程式在做下一步。</p>
<h2 id="Google-App-Script-程式碼"><a href="#Google-App-Script-程式碼" class="headerlink" title="Google App Script 程式碼"></a>Google App Script 程式碼</h2><p>一樣我們是先進入 google doc 後，我們點擊 工具 &gt; 指令碼編輯器，之後來寫 code 啦。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//告訴 google 你想要用程式操作的 google doc 是正在執行的 google doc</span></span><br><span class="line">  <span class="keyword">var</span> source = DocumentApp.getActiveDocument(); </span><br><span class="line">  <span class="keyword">var</span> body = source.getBody(); <span class="comment">//進入 doc body</span></span><br><span class="line">  body.clear(); <span class="comment">//將 google doc 裡面全部的資料清除</span></span><br><span class="line">  source.saveAndClose(); <span class="comment">//保存，並關閉程式碼對 google doc 的控制 </span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> text = <span class="string">"Hi David, My name is Alice."</span>; <span class="comment">//要進行打字特效的動作</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; text.length; i++)&#123;</span><br><span class="line">    <span class="keyword">var</span> source = DocumentApp.getActiveDocument(); </span><br><span class="line">    <span class="keyword">var</span> body = source.getBody(); <span class="comment">//進入 doc body</span></span><br><span class="line">    <span class="keyword">var</span> printer = body.editAsText(); <span class="comment">//進入編輯模式</span></span><br><span class="line">    printer.setFontFamily(<span class="string">"微軟正黑體"</span>); <span class="comment">//設定字體為 微軟正黑體</span></span><br><span class="line">    printer.setFontSize(<span class="number">14</span>); <span class="comment">//設定字體大小為 14</span></span><br><span class="line">    printer.appendText(text[i]); <span class="comment">//將字串讀入 google doc 內</span></span><br><span class="line">    source.saveAndClose(); <span class="comment">//保存，並關閉程式碼對 google doc 的控制，此時則會將 printer butter text 輸出。</span></span><br><span class="line">    Utilities.sleep(<span class="number">200</span>); <span class="comment">//暫停，等待 200ms。</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果檢查沒有問題後，再來我們就是打開觸發條件，如下</p>
<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1PY8O1rXYnLVhwbZcQLK_zf4jJBw_Ng33&export=download" alt=""></p>
</blockquote>
<p>但其實可以發現，這樣其實對 google 很壞，很吃他的效能。<br>因為不斷關閉又刪除…，對不起 google….。<br>但我真的很想要這個酷酷的東西XD。</p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>研究 google App Script 應該是我這周六日花最多的時間呢，<del>我才不會告訴你說最近我很喜歡打 LOL</del>，不過這個特效我自己研究了好久都還找不太出來怎麼顯現這個特效。</p>
<p>畢竟 google Doc Class 並沒有針對 <code>DocumentApp.editAsText().AppendText()</code> 中有講述到他是先將資料放入 buffer 內。<br>因此我的小笨腦袋都以為他會邊 print 邊執行程式。</p>
<p>而且我原本想要在 google App Script 寫如何在裡面放入圖片，但我還沒有讀懂如何放入圖片…，牠放入圖片的難度有點高，主要原因是我不知道 <code>BlobSource</code> 此 class，要如何產生比較好…。</p>
<p>我覺得應該可以讓  <code>DocumentApp.editAsText().AppendImage()</code> 這邊放一個快速開始，告訴大家如何在 google doc 內放入圖片，這樣我就不需要一直通靈這怎麼寫了QQQ。<del>到現在還通靈不出來</del></p>
<p>寫程式中，通靈真的是最難最痛苦的一件事RRR。</p>
<p>但還是謝謝 google 發明這份程式且願意免費讓我來使用QQ，很感謝你們，嗚嗚。<br>但拜託不要養套殺我拉。</p>
]]></content>
      <categories>
        <category>Google App Script</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>google</tag>
        <tag>Google App Script</tag>
      </tags>
  </entry>
  <entry>
    <title>北科資財二管理資訊系統 個案九 少林旅行社—標錯價格事件</title>
    <url>/2021/06/08/case_report/NTUTifm_Manager_t09/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊與財金管理系大二下管理作業系統作業紀錄<br><font color="#dd0000">並非所有人都適用，此為老師所給予的題目。</font><br><strong>這是個人心得的筆記，可能不太適用會未來的學生</strong></p>
<p>（請閱讀 W16_少林旅行社—標錯價格事件）</p>
</blockquote>
<a id="more"></a>

<h2 id="如何改善「標錯價」的問題？"><a href="#如何改善「標錯價」的問題？" class="headerlink" title="如何改善「標錯價」的問題？"></a>如何改善「標錯價」的問題？</h2><p>改善標錯價的問題，我認為可以透過兩方面進行改善。</p>
<h3 id="方案一：改革公司制度"><a href="#方案一：改革公司制度" class="headerlink" title="方案一：改革公司制度"></a>方案一：改革公司制度</h3><p>個案中有說到，將旅遊上架的都是業務部且時間點都很不一致，在某些時段並不會有公司人員發現到此問題，因此我建議每天早上 10 點讓主管們齊聚一堂開會並透過 email 傳送給決定價錢的所有公司員工，讓所有的長官一同同意此價格再進行標價。</p>
<p>如果業務部做不好文書處理的事情，那就讓主管們來做，這樣就不可以將下屬進行解雇，將責任都丟給解聘的下屬，會使主管擁有責任，主管就會更加仔細的檢查問題。</p>
<p>公司內部可以透明化，稽核就相對容易，也比較不會有丟皮球的問題。</p>
<h3 id="方法二：透過電腦判定此價格是否有問題"><a href="#方法二：透過電腦判定此價格是否有問題" class="headerlink" title="方法二：透過電腦判定此價格是否有問題"></a>方法二：透過電腦判定此價格是否有問題</h3><p>我們可以透過要求使用者在刊登旅遊商品資訊時，必須一同報上成本與利潤，當 成本+利潤 = 售價時，我們才刊登此商品，如果 成本+利潤 != 售價時，我們就可以給予刊登者提示訊息，表示他的上傳商品不正確，並傳送資訊給主管，他必須要追蹤此商品價格資訊。</p>
<p>如果第三次刊登失敗，就會將刊登的頁面鎖住，不讓業務進行刊登，同時系統透過鈴聲提醒主管，因為通常刊登三次失敗那應該就是更上面的細節有問題，並不會單單只有業務 key-in 輸入錯誤的可能性。</p>
<h3 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h3><p>我認為這兩種方式都可以降低刊登錯誤的可能性，且第二種理論上可以大幅下降，也比較不會讓主管們感覺到作業感。<br>雖然方法二無法稽查業務故意 key 錯資訊，但這並不是我們這次要考論的重點。</p>
]]></content>
      <categories>
        <category>北科上課筆記</category>
        <category>個案報告 Case Report</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>北科大管理資訊系統筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>北科資工二多媒體技術與應用 第八周個人作業 - 請提出一種情境設想，適合使用LSTM (不可與課程講義中所提到的範例相同)，並寫下原因(使用 LSTM 比起 RNN 及其他神經網路結構的優勢)。</title>
    <url>/2021/06/14/Media_with_Image_recognition/NTUTcs_MediaHW08T01/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊工程系大二下多媒體技術與應用作業紀錄<br><font color="#dd0000">並非所有人都適用，部分對我而言稍加容易的內容並不會寫在此內。</font><br><strong>這是學習後心得的筆記，可能不太適用會未來的學生</strong></p>
<p>由於我沒有學習過裡面的理論，因此這是資工大二學生透過網路與自身理解的筆記，學習價值並不高、且可能擁有大量錯誤。</p>
</blockquote>
<a id="more"></a>

<h2 id="請提出一種情境設想，適合使用LSTM-不可與課程講義中所提到的範例相同-，並寫下原因-使用-LSTM-比起-RNN-及其他神經網路結構的優勢-。"><a href="#請提出一種情境設想，適合使用LSTM-不可與課程講義中所提到的範例相同-，並寫下原因-使用-LSTM-比起-RNN-及其他神經網路結構的優勢-。" class="headerlink" title="請提出一種情境設想，適合使用LSTM (不可與課程講義中所提到的範例相同)，並寫下原因(使用 LSTM 比起 RNN 及其他神經網路結構的優勢)。"></a>請提出一種情境設想，適合使用LSTM (不可與課程講義中所提到的範例相同)，並寫下原因(使用 LSTM 比起 RNN 及其他神經網路結構的優勢)。</h2><p>LSTM 最大的優勢是他可以對於長短期記憶有效地進行思考，也就是說它適合用於會被時間軸干擾的情境。</p>
<p>我們可以對台灣的不分區立委政黨票進行預測，我們可以判斷國民黨或民進黨的不分區立委票數來預測今年國民黨、民進黨的不分區立委有幾席，讓黨內最優秀的人才可以去立法院進行監督。</p>
<p>其實選民的結構會不斷地進行改變，但改變的幅度不大，主要是老年人辭世，更多年輕人擁有投票權，台灣人大部分都有自己偏好的政黨較不容易會出現大改動，因此如果透過 LSTM 去記錄那微小的選民結構偏好政黨移動，就能夠精準預測出台灣的政黨變化，也可以讓黨內人士去評估到時候可以用多少的人力在立法院內與其他黨聯合、抗爭。</p>
]]></content>
      <categories>
        <category>北科上課筆記</category>
        <category>多媒體與圖像辨識 Image Recognition</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>北科大多媒體技術與應用筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>北科資工二多媒體技術與應用 第十周個人作業 - 請提出一種情境設想，適合在架構中加入GAN(不可與課程講義 中的內容重複)，並說明理由(甚麼情況使得需要加入GAN，可以 搭配甚麼模型架構等等)。</title>
    <url>/2021/06/14/Media_with_Image_recognition/NTUTcs_MediaHW10T01/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊工程系大二下多媒體技術與應用作業紀錄<br><font color="#dd0000">並非所有人都適用，部分對我而言稍加容易的內容並不會寫在此內。</font><br><strong>這是學習後心得的筆記，可能不太適用會未來的學生</strong></p>
<p>由於我沒有學習過裡面的理論，因此這是資工大二學生透過網路與自身理解的筆記，學習價值並不高、且可能擁有大量錯誤。</p>
</blockquote>
<a id="more"></a>

<h2 id="請提出一種情境設想，適合在架構中加入GAN-不可與課程講義-中的內容重複-，並說明理由-甚麼情況使得需要加入GAN，可以-搭配甚麼模型架構等等-。"><a href="#請提出一種情境設想，適合在架構中加入GAN-不可與課程講義-中的內容重複-，並說明理由-甚麼情況使得需要加入GAN，可以-搭配甚麼模型架構等等-。" class="headerlink" title="請提出一種情境設想，適合在架構中加入GAN(不可與課程講義 中的內容重複)，並說明理由(甚麼情況使得需要加入GAN，可以 搭配甚麼模型架構等等)。"></a>請提出一種情境設想，適合在架構中加入GAN(不可與課程講義 中的內容重複)，並說明理由(甚麼情況使得需要加入GAN，可以 搭配甚麼模型架構等等)。</h2><p>我認為可以讓程式設計中加入GAN，透過程式自己編寫程式，生成模型不斷產生程式，判別模型則類似於judge 進行評判，透過這樣的方式讓生成模型寫出一份能用的程式，再來我可以在判別模型中加入時間限制，限制生成模型程式的運行時間，讓生成模型可以寫出更快的程式。</p>
<p>由此一來，程式設計師就可以減少部分負擔，將一些底層不需要人力維護的程式設計交給GAN做，使程式設計師可以專心研發、思考開發與設計的流程。</p>
<p>至於需要大量維護得程式碼，我並不建議交給GAN去做，因為註解以及程式碼的編寫流程不一定會跟維護的人概念相同，且生成模型寫得程式模型變數也不一定對人類具有可讀性，因此我認為後端部分可以交由GAN來進行實作。</p>
<p>例如我們想要讓 Social LSTM 內部的計算可以更優化，我們可以先給生成模型原先的程式設計，並讓判別模型限定生成模型得程式不可以花超過4秒鐘。</p>
<p>如此一來，透過GAN產生的程式效率速度就能變快，其中GAN得程式並不好懂，我們也不太需要去理解。<br>因為我們已經知道其實做概念，我們只需要用GAN給我們的核心去加速運算即可，或是我們也可以研究GAN是怎麼加速的，供我們未來進步用。</p>
]]></content>
      <categories>
        <category>北科上課筆記</category>
        <category>多媒體與圖像辨識 Image Recognition</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>北科大多媒體技術與應用筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>北科資工二多媒體技術與應用 第九周個人作業 - 請提出一種情境設想，適合在架構中加入Encoder-Decoder(不可以 課程講義中的內容重複)，並說明理由(甚麼情況使得需要加入 Encoder-Decoder，可以搭配甚麼模型架構等等)。</title>
    <url>/2021/06/14/Media_with_Image_recognition/NTUTcs_MediaHW09T01/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊工程系大二下多媒體技術與應用作業紀錄<br><font color="#dd0000">並非所有人都適用，部分對我而言稍加容易的內容並不會寫在此內。</font><br><strong>這是學習後心得的筆記，可能不太適用會未來的學生</strong></p>
<p>由於我沒有學習過裡面的理論，因此這是資工大二學生透過網路與自身理解的筆記，學習價值並不高、且可能擁有大量錯誤。</p>
</blockquote>
<a id="more"></a>

<h2 id="請提出一種情境設想，適合在架構中加入Encoder-Decoder-不可以-課程講義中的內容重複-，並說明理由-甚麼情況使得需要加入-Encoder-Decoder，可以搭配甚麼模型架構等等-。"><a href="#請提出一種情境設想，適合在架構中加入Encoder-Decoder-不可以-課程講義中的內容重複-，並說明理由-甚麼情況使得需要加入-Encoder-Decoder，可以搭配甚麼模型架構等等-。" class="headerlink" title="請提出一種情境設想，適合在架構中加入Encoder-Decoder(不可以 課程講義中的內容重複)，並說明理由(甚麼情況使得需要加入 Encoder-Decoder，可以搭配甚麼模型架構等等)。"></a>請提出一種情境設想，適合在架構中加入Encoder-Decoder(不可以 課程講義中的內容重複)，並說明理由(甚麼情況使得需要加入 Encoder-Decoder，可以搭配甚麼模型架構等等)。</h2><p>我認為可以在法庭上做說謊驗證，判斷犯人講話是不是有邏輯錯誤。</p>
<p>Encoder-Decoder 擅長將現實問題轉換為邏輯問題，因此我認為我們如果可以將犯人的供詞轉換為變數，就可以變成 A=B+C 的狀態，接下來如果犯人說 A=C+D 我們就可以判斷出他在說謊。</p>
<p>因為人們的聽力並沒有辦法可以對 30 分鐘的所有內容都記錄下來並找出其不合理之處，如果可以透過程式進行量化那就更為方便且也能夠省去書記官記錄文字。</p>
]]></content>
      <categories>
        <category>北科上課筆記</category>
        <category>多媒體與圖像辨識 Image Recognition</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>北科大多媒體技術與應用筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>北科通識大二英文初級期末考作文 - 定義成功與失敗</title>
    <url>/2021/06/14/NTUT_note/NTUTgec108-2_english_essay/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學英文初級期末考作文－ 定義成功與失敗<br><font color="#dd0000">並非所有人都適用，我的英文很爛，可能有大量文法錯誤、單字錯誤，還讓大家見笑了。</font><br><strong>這是作文，可能不太適用會未來的學生</strong></p>
<p>由於是我自己寫作，並不一定全部都是正確，只是個人想法。</p>
</blockquote>
<a id="more"></a>

<h2 id="題目要求"><a href="#題目要求" class="headerlink" title="題目要求"></a>題目要求</h2><ul>
<li>How would you define success?</li>
<li>Do you have the same idea of success as your parents?</li>
<li>To what extent will your encourage your children to become successful?</li>
<li>Do you think failures can contribute to a person’s success?</li>
<li>Can you think of any famous people who encountered failure before success?</li>
</ul>
<h2 id="我的寫作"><a href="#我的寫作" class="headerlink" title="我的寫作"></a>我的寫作</h2><p>Define Success is more difficult than everything. My parents always say “have rich make you feel at ease.” My parents very poor when they young, so they hate poverty. In this case, I also think money is important in my life, no money no everything, but money isn’t everything.</p>
<p>Personally, money is important in my life, but it isn’t my life goal. My goal is I can do everything whatever I want. Since I was little, my parents always hard-working, never rest. Now, my parents are short-sightedness, When I make a decision and this decision can’t earn money, they against me this decision and they always say “what are you think about?” </p>
<p>I know they worry about me will be a Poor, but I get friendship. Good network can give you one chance. If I take the opportunity, maybe I will be success. </p>
<p>In my senior school life, My teacher wanted me to do something, like programming, run errands, then I shared school thing to my parents, they say run errands, programming doesn’t have any money, why do you do? School teacher should gave your money to encourage, but I thaught teacher gave me to learn chance, maybe teacher gave my chance in my future, maybe tomorrow, next month… </p>
<p>Once, my senior school teacher give me one chance! I told my teacher that I wanted to sign up Science Fair then my teacher offered to help me. I feel SURPRISED! Teacher can help me, so we practice and discussion from now to Science Fair day.</p>
<p>It is hard process, but my teacher don’t feel tired. He always hard-working with me. Meeting every day, improving every day. </p>
<p>Finally, We got 3th. I’m so happy cause I hug with my teacher. Tonight, I shared with my parents, then they say “This teacher is good teacher, Thanks my teacher.”</p>
<p>Sometimes, We don’t know, when the opportunity come? If the opportunity come, then I take the opportunity, maybe I will be success.<br>So, I don’t think my parents define success is the best, I think success is “I have the ability to help people, and people will help me”.</p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>好久沒有寫作文了…，我的英文作文還是一樣的爛阿…，有很多詞彙我想要抽換成另外一個概念，但是我的英文單字量太少了，腦中都只有同個單字，例如：事情，我一直都只有想到 thing，英文應該還有其他單字可以用的…。</p>
<p>還有我不太擅長用 that、what…連接詞，在閱讀時我都會看得懂並且能夠理解，但是在英文寫作時我常常會苦惱，我興奮到抱起我的老師，這句話要怎麼講…，我想了將近快 10 分鐘，結果最後竟然用 cause…XD，應該可以用 so that，可是我沒有想到阿…可惡！</p>
<p>還有就是，不要再交稿日最後一小時才開始寫作文，明明我下午就接受到老師的通知，表示我還沒有把期末考作文交出去，但是我一直拖，拖到最後一個小時我才開始寫作，導致我作文後面質量很差QAQ。</p>
<p>一堆單字、文法都是憑感覺直接寫出來，沒有好好仔細思考一番QQ。</p>
<p>總之，希望我可以學會時間管理，我還太不會時間管理，自制力不足</p>
]]></content>
      <categories>
        <category>北科上課筆記</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>北科大通識</tag>
        <tag>英文 Englisg</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa11753 - Creating Palindrome(DFS )</title>
    <url>/2021/06/11/UVa/UVa11753/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>你來幫幫 ICPC 的忙，ICPC 會給你一組數列，與一個數字 k，請你告訴 ICPC 要在這數列中至少要插入幾個數字才可以成為迴文數列，如果插入的次數大於 k 輸出 too difficult，如果不需要插入輸出 too easy，除此之外，輸出你插入的次數。</p>
<p><a href="https://onlinejudge.org/external/117/11753.pdf" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li>思考這題是 DFS 的應用</li>
<li>了解這題貪心不一定會是好解法</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>我們可以先透過數列進行簡單分析，定義數列的左邊界指針為 L、右邊界指針為 R，數列為 num</p>
<ul>
<li>如果 \(num[L] == num[R] \) 就 L-1、R-1。</li>
<li>如果 \(num[L] != num[R] \)，我們可以怎麼做?<ul>
<li>用貪心解嗎？<br>你可能會這麼覺得，我就只要判斷下一個數字有沒有等於 \(num[L] \) or \(num[R] \) 就好了，可是那假如下下個數字等於  \(num[L] \) or  \(num[R] \) 呢？</li>
<li>用 DFS 嗎？<br>效率很差，但是看看這邊的 K 只有 20，也就是說 DFS 只要跑到 20 就好，那並不會讓 DFS 過長。</li>
<li>用 DP 嗎？<br>不妥，因為 DP 時當字串過長時，會有大量座標浪費在解不出來的情況，例如：(1,2000) = 1999，那我們就有很多時間浪費在跑 y = 1~2000 的情況</li>
</ul>
</li>
</ul>
<p>主要是透過 DFS 去找出最適合的組合，當 \(num[L] != num[R] \)，就延伸出兩種 DFS，<code>L+1, R</code>、<code>L,R-1</code>。</p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://hackmd.io/@txya900619/Uva11753" target="_blank" rel="noopener">Uva11753 - Creating Palindrome by txya900619</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>這題算是輕鬆題目，寫的算快。希望以後都能能輕鬆寫完啦。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 0x3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> t, n, k, kase=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; num;</span><br><span class="line"><span class="keyword">int</span> ans_d; <span class="comment">//最小的插入次數</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> d)</span></span>&#123; <span class="comment">//DFS 找出最好排列組合</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; "num L R " &lt;&lt; num[L] &lt;&lt; ' ' &lt;&lt; num[R] &lt;&lt; '\n';</span></span><br><span class="line">    <span class="keyword">if</span>(L &gt;= R )&#123; <span class="comment">//左指針與右指針相遇就 return，注意：奇數迴文則不需要在意最中間的數值</span></span><br><span class="line">        ans_d = min(d, ans_d); <span class="comment">//找出最小插入次數</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//大於題目最大要求的 k 時，直接 return，並將這次的 d 設定為 k+1，才能讓最後輸出時可以輸出 too difficult</span></span><br><span class="line">    <span class="keyword">if</span>(d &gt; k)&#123; </span><br><span class="line">        ans_d = min(k+<span class="number">1</span>, ans_d); </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(num[L] == num[R]) dfs(L+<span class="number">1</span>, R<span class="number">-1</span>, d); <span class="comment">//一樣，左右指針 -1</span></span><br><span class="line">    <span class="keyword">if</span>(num[L] != num[R])&#123; <span class="comment">//不一樣時</span></span><br><span class="line">        dfs(L+<span class="number">1</span>, R, d+<span class="number">1</span>); <span class="comment">//讓左指針 +1，步數+1</span></span><br><span class="line">        dfs(L, R<span class="number">-1</span>, d+<span class="number">1</span>); <span class="comment">//讓右指針 -1，步數+1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"out.txt"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123; </span><br><span class="line">        num.clear(); <span class="comment">//清除數列，以免被先前資料影響</span></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123; <span class="comment">//讀資料</span></span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; temp;</span><br><span class="line">            num.push_back(temp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ans_d = MAXN;</span><br><span class="line">        dfs(<span class="number">0</span>, num.size()<span class="number">-1</span>, <span class="number">0</span>); <span class="comment">//進行 DFS</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//cout &lt;&lt; "ans_d " &lt;&lt; ans_d &lt;&lt; '\n';</span></span><br><span class="line">        <span class="comment">//判斷是哪種狀態，太簡單、太難，還是輸出插入次數</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Case "</span> &lt;&lt; ++kase &lt;&lt; <span class="string">": "</span>;</span><br><span class="line">        <span class="keyword">if</span>(ans_d == <span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">"Too easy\n"</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ans_d &lt;= k) <span class="built_in">cout</span> &lt;&lt; ans_d &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ans_d &gt; k) <span class="built_in">cout</span> &lt;&lt; <span class="string">"Too difficult\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>UVa</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa11147 - kuPellaKeS BST(遞迴)</title>
    <url>/2021/06/30/UVa/UVa11147/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>BST 是數的資料結構，kuPellaKeS BST 則是繼承 BST 後，還有以下特點</p>
<ul>
<li>kuPellaKeS BST 的左子樹、右子樹相差必須是最小的</li>
<li>kuPellaKeS BST 如果有超過一種符合第一點的方法，則選擇左子樹權重最大</li>
<li>左右子樹也都必須符合 kuPellaKeS BST</li>
</ul>
<p>並且我們 kuPellaKeS BST 也有特別的輸出方式</p>
<ul>
<li>沒有左右子樹時，則輸出 <code>root</code></li>
<li>只有左 or 右子樹時，則輸出 <code>root(sub_node)</code></li>
<li>有左右子樹時，則輸出 <code>root(left_sub_node, right_sub_node)</code></li>
</ul>
<p>給你一數列，請輸出 kuPellaKeS BST<br><a href="https://onlinejudge.org/external/111/11147.pdf" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li>建造 BST </li>
<li>difference 在這邊是相減，並不是<strong>不一樣</strong>的意思</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>difference 真的是太過分了，我一直被他誤導QQ。</p>
<ul>
<li>我們可以明顯知道，建立一個 BST 不難，只需要一個遞迴就好，那我們現在的重點就是要讓 BST 變成 kuPellaKeS BST。</li>
<li>接下來我們就是根據此方式去實作，但是我們要怎麼找，才能符合題目的左右子樹切割條件呢？<ul>
<li>原本的 BST 是 <code>(L+R)/2</code>，有一個很明顯的公式。</li>
<li>n 最大只有 2000，那我們可以用暴力的方式解解看。</li>
<li>畢竟 n 不大，2000 最多就 2 的 11 次，因此最壞情況下迴圈長度為 22000。</li>
<li>用迴圈不斷去比較，找出符合題目要求的切割左右子樹方法。</li>
</ul>
</li>
<li>一個小技巧，\(O(1)\)算出左右子樹大小<ul>
<li>可以使用區間查詢。</li>
<li>先將數列進行排序</li>
<li>也就是說，如果我們有一個陣列為 <code>sum[i] = sum[i-1] + num[i]</code>，新的 index 值會繼承救的數值並且加上當前數列數字</li>
<li>BST 的特性，左子樹的所有數值一定比 root 小，因此我們要查詢的區間就是 <code>sum[root-1] - sum[L-1]</code>，記住 root 並不是左子樹的範圍內、L 則在左子樹的範圍內</li>
<li>反之，右子樹就是我們要查詢的區間就是 <code>sum[R] - sum[root])</code></li>
</ul>
</li>
<li>判斷輸出格式<ul>
<li>考慮左右子樹都有數值，就需要輸出逗號。</li>
<li>因此我們可以用 <code>root != L &amp;&amp; root != R</code>，也就是說 root 並不在左邊界 or 右邊界上，就表示 root 下一定還有左右子樹</li>
</ul>
</li>
</ul>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>好久沒有寫演算法，腦袋變差很多QQ。 希望可以趕快恢復</p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://hackmd.io/@txya900619/Uva11147" target="_blank" rel="noopener">Uva11147 - KuPellaKeS BST by txya900619</a></p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 2000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> sum[MAXN], num[MAXN];</span><br><span class="line"><span class="keyword">int</span> t, n, kase=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L &gt; R) <span class="keyword">return</span>; <span class="comment">//沒有其他數值，因此不用輸出</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> root = L, min_diff = INT32_MAX, max_left = INT32_MIN; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = L; i &lt;= R; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i != R &amp;&amp; num[i] == num[i+<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> left_tree = (i == <span class="number">0</span> ? <span class="number">0</span> : sum[i<span class="number">-1</span>]) - (L == <span class="number">0</span> ? <span class="number">0</span> : sum[L<span class="number">-1</span>]); <span class="comment">//左子樹總和</span></span><br><span class="line">        <span class="keyword">int</span> right_tree = sum[R] - sum[i]; <span class="comment">//右子樹總和</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> diff = <span class="built_in">abs</span>(right_tree - left_tree); <span class="comment">//記住，需要 abs，不然樹會整個往左偏。</span></span><br><span class="line">        <span class="keyword">int</span> left = left_tree;</span><br><span class="line">        <span class="keyword">if</span>(diff &lt; min_diff)&#123;</span><br><span class="line">            root = i;</span><br><span class="line">            min_diff = diff;</span><br><span class="line">            max_left = left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(diff == min_diff &amp;&amp; left &gt; max_left)&#123;</span><br><span class="line">            root = i;</span><br><span class="line">            min_diff = diff;</span><br><span class="line">            max_left = left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; num[root]; <span class="comment">//輸出當前 root</span></span><br><span class="line">    <span class="keyword">if</span>(L != R )&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"("</span>;</span><br><span class="line">        dfs(L, root<span class="number">-1</span>); <span class="comment">//右子樹</span></span><br><span class="line">        <span class="keyword">if</span>(root != L &amp;&amp; root != R) <span class="built_in">cout</span> &lt;&lt; <span class="string">","</span>;</span><br><span class="line">        dfs(root+<span class="number">1</span>, R); <span class="comment">//左子樹</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">")"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">cin</span> &gt;&gt; num[i];</span><br><span class="line">        sort(num, num+n);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Case #"</span> &lt;&lt; ++kase &lt;&lt; <span class="string">": "</span>;</span><br><span class="line">        sum[<span class="number">0</span>] = num[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) sum[i] = sum[i<span class="number">-1</span>] + num[i]; <span class="comment">//計算區間總和</span></span><br><span class="line">        dfs(<span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>遞迴</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa12893 - Count It(設計解題)</title>
    <url>/2021/06/30/UVa/UVa12893/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>請根據題目連結中的程式碼進行優化，讓 \(1 \leq n \leq 10^{18}\) 時也有辦法 AC<br><a href="https://onlinejudge.org/external/128/12893.pdf" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li>找出此公式的關係式</li>
<li>二進位</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>我們可以發現一些重點</p>
<ul>
<li><code>num[i] = num[i/2] + (i%2)</code>，我們可以發現會延續 <code>num[i/2]</code> +1 or 0。</li>
<li>算算看 1 的情況，2 的情況、3 的情況。</li>
<li><code>num[1] = 1, num[2] = 2, num[4] = 3</code>，似乎有點二進位的味道？</li>
<li>因此也就是將 <code>i</code> 轉換成 2 進位，並且看 2 進位的 <code>i</code> 有幾個 1　？</li>
<li>對，就是他了！</li>
</ul>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>腦筋急轉彎…，太狠了。<br>我怎麼在看解答錢都沒有想出來RRRR，我好笨。拜託，再讓我聰明點八</p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://hackmd.io/@txya900619/Uva12893" target="_blank" rel="noopener">Uva12893 - Count It by txya900619</a></p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> t, n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n)&#123; <span class="comment">//當 n 為二進位時，有多少個 1</span></span><br><span class="line">            cnt += n &amp; <span class="number">1</span>;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; cnt &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>設計解題</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa13142 - Destroy the Moon to Save the Earth(水題、英文測驗 )</title>
    <url>/2021/06/17/UVa/UVa13142/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>在 T 年後會有一顆隕石撞擊地球！如果讓他撞擊地球會造成數以百計的死亡，這是科學家們想到一個方法，讓月亮來幫地球扛這個隕石。<br>　<br>其中 S 是月亮轉地球的速率，D 是如果隕石跟月球互相撞擊還差多少公里，D 可以是正數或負數。<br>我們知道如果消除月亮 1 ton 可以讓月亮的速度加快 1mm/s，因此科學家可以用武器撞擊月球來讓月球加速；反之，如果我們讓月亮增重 1 ton 則可以讓月亮的速度變慢 1mm/s。</p>
<p>現在請告訴科學家們，要讓月亮消除或增加多少 ton 才可以讓月亮撞擊隕石。 請輸出無條件捨去的 ton<br><a href="https://onlinejudge.org/external/131/13142.pdf" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li>英文的閱讀能力</li>
<li>判斷題目的可用資訊</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>如果你的英文夠好，那你應該會知道其實 S 對我們是沒有用的，因為其實題目的 D 是隕石跟月球互相撞擊還差多少公里，也就是說 D 的標準就是透過 S 的速率去推估，因此我們其實只需要做增加或是減少 S。</p>
<p>怎麼做呢？就是用題目的消除或增加 1 ton。<br>因此我們的公式就是 \(距離 / 時間\)，記得單位要換算，距離的單位是 mm、時間的單位是 s。</p>
<p>再來我們的輸出特別注意</p>
<ul>
<li>floor 是無條件退位，因此 \(abs(floor(-8.4)) = 9 \)，並不符合題目要求，因此我們要改成 \(floor(abs(-8.4)) = 8 \)。</li>
<li>判斷是要 remove or add<br>題目有說，ton = 0 時必須輸出 add，但是我們判斷是否等於 0 時，假設 ton = 0.3，判斷公式是 <code>if(ton &gt; 0) cout &lt;&lt; &quot;Remove &quot; &lt;&lt; floor(ton) &lt;&lt; &quot; tons\n&quot;;</code>，則會輸出 <code>remove</code>，這是因為我們的 <code>if(ton &gt; 0)</code> 這時是 0.3，才會判斷是 true，因此我們要改成  <code>if(floor(ton) &gt; 0)</code> 判斷時就先退位，這樣才會符合題目的正確輸出要求。</li>
</ul>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>我英文真的好爛，需要再複習拉QAQ。<br>看了題目那麼久，結果一個詳解發現這題目那麼簡單。</p>
<p>我一開始還以為我要知道地球的周長然後去計算月亮速率，2500 公里是隕石跟月亮的距離，還有再算一堆東西，想到就頭疼的…。</p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://hackmd.io/@txya900619/Uva13142" target="_blank" rel="noopener">Uva13142 - Destroy the Moon to Save the Earth</a></p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"out.txt"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">double</span> t, s, d, ton;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123; </span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; t &gt;&gt; s &gt;&gt; d;</span><br><span class="line">        <span class="comment">//距離 / 時間，記得單位要換算，距離的單位是 mm、時間的單位是 s</span></span><br><span class="line">        ton = d * <span class="number">1000</span> * <span class="number">100</span> * <span class="number">10</span> / (t * <span class="number">24</span> * <span class="number">60</span>* <span class="number">60</span>); </span><br><span class="line">        <span class="comment">//小心判斷，注意 0.3 的情況；注意負數時的 floor 會 -1，舉例：floor(-0.3) = -1。</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">floor</span>(ton) &gt; <span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">"Remove "</span> &lt;&lt; <span class="built_in">floor</span>(ton) &lt;&lt; <span class="string">" tons\n"</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"Add "</span> &lt;&lt; <span class="built_in">floor</span>(<span class="built_in">abs</span>(ton)) &lt;&lt; <span class="string">" tons\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>水題</tag>
        <tag>UVa</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>統計學(二) 筆記 - 期末專案 國內股票型基金分析</title>
    <url>/2021/07/02/statistics/statistics-final-project/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>我們根據<a href="https://fund.bot.com.tw/w/wq/wq02.djhtm?a=ET001004&b=BANKFUNDID&customershowall=0" target="_blank" rel="noopener">台灣銀行可申購的基金</a>，針對國內股票開放型中小型基金、國內股票開放型科技型基金、國內股票開放型一般股票型基金做探討。</p>
<p>國內股票開放型中小型基金、國內股票開放型科技型基金、國內股票開放型一般股票型基金，以下簡稱為<strong>三類基金</strong><br>我們主要想探討的是，在這三種類型的所有基金中，透過統計的方式找出哪些基金值得被購買，適合消費者購買。</p>
<p>過程中我們使用 <strong>R 語言</strong> 進行分析。<br><a href="https://drive.google.com/file/d/1TZ9b66NvqLzXglfXqvaQRIfvtH89nkx1/view?usp=sharing" target="_blank" rel="noopener">我們這組的期末 ppt 報告</a></p>
<p>此文章記錄用途只在於台北科技大學資訊與財金管理系大二下期末專案<br><font color="#dd0000">並非所有人都適用，部分對我而言稍加容易的內容並不會寫在此內。</font></p>
</blockquote>
<a id="more"></a>

<h2 id="章節"><a href="#章節" class="headerlink" title="章節"></a>章節</h2><ul>
<li>蒐集資料，透過 yahoo 基金網頁下載歷史資料。</li>
<li>根據國內股票開放型中小型基金、國內股票開放型科技型基金、國內股票開放型一般股票型基金，分別選出最好的基金。<ul>
<li>其中國內股票開放型一般股票型基金最好的基金定義為 normal_fund</li>
<li>其中國內股票開放型中小型基金最好的基金定義為 small_fund</li>
<li>其中國內股票開放型科技型基金最好的基金定義為 tech_fund</li>
</ul>
</li>
<li>再來我們針對 normal_fund、small_fund、tech_fund 比較看看這些基金是否有差異。</li>
<li>再來為這 normal_fund、small_fund、tech_fund 基金做迴歸分析，X 變數是 normal_fund、small_fund、tech_fund 的前十大股票，使用迴歸分析來看基金的前十大標的是否對這基金影響力很強。</li>
<li>再來做最適資產配置，推薦投資者應該將投資如何比例至這些基金中</li>
<li>資料來源</li>
<li>心得</li>
</ul>
<p>如果想跳到這些章節，請點選右邊的章節列描點過去。</p>
<p><font color="#dd0000">以下的統計分析的 alpha 都是 0.05。</font></p>
<h2 id="資料取得"><a href="#資料取得" class="headerlink" title="資料取得"></a>資料取得</h2><ul>
<li>我們資料使用 <a href="https://tw.stock.yahoo.com/基金" target="_blank" rel="noopener">yahoo 基金</a> 從 2017~2020 的資料作統計分析。</li>
<li>之後透過 R 語言處理資料。</li>
</ul>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">#### file name</span></span><br><span class="line"><span class="comment">#merge.data.R </span></span><br><span class="line"><span class="comment">####</span></span><br><span class="line"><span class="keyword">library</span>(magrittr)</span><br><span class="line"><span class="keyword">library</span>(quantmod)</span><br><span class="line"><span class="keyword">library</span>(agricolae)</span><br><span class="line"><span class="keyword">library</span>(tibble)</span><br><span class="line">setwd(<span class="string">"D:\\NTUT\\大二下\\統計\\報告"</span>)</span><br><span class="line"></span><br><span class="line">data_merge &lt;- <span class="keyword">function</span>(folder_name)&#123;</span><br><span class="line">  <span class="comment">#"一般股票型"</span></span><br><span class="line">  path &lt;- file.path(getwd(), <span class="string">"基金CSV"</span>, folder_name)</span><br><span class="line">  files &lt;- dir(path)</span><br><span class="line">  data &lt;- tibble(YM = character(), name = character(), <span class="keyword">return</span> = numeric(),</span><br><span class="line">                 sharpe = numeric(), sd = numeric())</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (fname <span class="keyword">in</span> files)&#123;</span><br><span class="line">    </span><br><span class="line">    path &lt;- file.path(getwd(), <span class="string">"基金CSV"</span>, folder_name, fname)</span><br><span class="line">    fund &lt;- read.csv(path)</span><br><span class="line">    fname &lt;- gsub(<span class="string">".csv"</span>, <span class="string">""</span>, fname)</span><br><span class="line">    fund$date &lt;- fund$日期 %&gt;% as.Date() %&gt;% as.character() <span class="comment">#將日期與 yahoo 股價一致</span></span><br><span class="line">    fund$漲跌幅 &lt;- gsub(<span class="string">"%"</span>, <span class="string">""</span>, fund$漲跌幅) %&gt;% as.numeric()  <span class="comment">#子串轉數字</span></span><br><span class="line">    fund &lt;- fund[-grep(<span class="string">"2021"</span>, fund$date) ,] <span class="comment">#消除 2021 的資料</span></span><br><span class="line">    fund &lt;- fund[-grep(<span class="string">"2016"</span>, fund$date) ,] <span class="comment">#消除 2016 的資料</span></span><br><span class="line">    <span class="keyword">if</span>(nrow(fund) &lt;= <span class="number">0</span>) <span class="keyword">next</span></span><br><span class="line">    </span><br><span class="line">    fund$YM &lt;- substr(fund$date, <span class="number">1</span>, <span class="number">4</span>)<span class="comment">#year with month 取出年份與月份</span></span><br><span class="line">    YMs &lt;- unique(fund$YM) </span><br><span class="line"></span><br><span class="line">    <span class="comment">#將基金的每日資料合併成每年的資料</span></span><br><span class="line">    <span class="keyword">for</span>(ym <span class="keyword">in</span> YMs)&#123;</span><br><span class="line">      sub_fund &lt;- fund[fund$YM == ym, ]</span><br><span class="line">      <span class="keyword">return</span> &lt;- (tail(sub_fund$淨值,<span class="number">1</span>) - head(sub_fund$淨值,<span class="number">1</span>)) / head(sub_fund$淨值,<span class="number">1</span>) <span class="comment">#計算報酬率</span></span><br><span class="line">      data &lt;- data %&gt;% add_row(YM = ym, name = fname,</span><br><span class="line">                         <span class="keyword">return</span> = <span class="keyword">return</span>,</span><br><span class="line">                         sharpe = (mean(sub_fund$漲跌幅) - <span class="number">0.0000232</span>) / sd(sub_fund$漲跌幅) * (sqrt(<span class="number">252</span>)), <span class="comment"># sharpe ratio</span></span><br><span class="line">                         sd = sd(sub_fund$漲跌幅)) <span class="comment"># 標準差</span></span><br><span class="line">    <span class="comment">#sharpe ratio 的無風險利率使用台灣銀行一天的利息做標準 0.0000232 </span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>(data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="蒐集資料，透過-yahoo-基金網頁下載歷史資料。"><a href="#蒐集資料，透過-yahoo-基金網頁下載歷史資料。" class="headerlink" title="蒐集資料，透過 yahoo 基金網頁下載歷史資料。"></a>蒐集資料，透過 yahoo 基金網頁下載歷史資料。</h2><p>選擇 yahoo 某一檔基金，這裡用<a href="https://tw.stock.yahoo.com/fund/summary/F0HKG05X22:FO" target="_blank" rel="noopener">安聯台灣科技基金為例</a>，點擊 <strong>歷史淨值</strong> &gt; 往下看，會看到一個<strong>下載歷史報價</strong>，選擇自己想要的期間去下載。 </p>
<h2 id="根據國內股票開放型中小型基金、國內股票開放型科技型基金、國內股票開放型一般股票型基金，分別選出最好的基金。"><a href="#根據國內股票開放型中小型基金、國內股票開放型科技型基金、國內股票開放型一般股票型基金，分別選出最好的基金。" class="headerlink" title="根據國內股票開放型中小型基金、國內股票開放型科技型基金、國內股票開放型一般股票型基金，分別選出最好的基金。"></a>根據國內股票開放型中小型基金、國內股票開放型科技型基金、國內股票開放型一般股票型基金，分別選出最好的基金。</h2><ul>
<li>將資料轉化成以每年為單位的基金資料</li>
<li>再來我們做 ANOVA 分析，看看這些基金的 報酬率、sharpe ratio 是否都一樣</li>
<li>如果 ANOVA 分析這些基金的 報酬率、sharpe ratio 不一樣，則做 LSD 找出最前段班的組別。<br>我們會先做報酬率，並取出 LSD 最好的一組，再去做 sharpe ratio 分析</li>
<li>下結論</li>
<li>從最好的基金們中找出最好的基金。</li>
</ul>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">#### file name</span></span><br><span class="line"><span class="comment">#fund.R</span></span><br><span class="line"><span class="comment">####</span></span><br><span class="line"><span class="keyword">library</span>(magrittr)</span><br><span class="line"><span class="keyword">library</span>(quantmod)</span><br><span class="line"><span class="keyword">library</span>(agricolae)</span><br><span class="line"><span class="keyword">library</span>(stats)</span><br><span class="line">setwd(<span class="string">"D:\\NTUT\\大二下\\統計\\報告"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">source</span>(<span class="string">"./merge_data.R"</span>, encoding = <span class="string">"UTF-8"</span>)</span><br><span class="line"><span class="keyword">source</span>(<span class="string">"./loading_data.R"</span>, encoding = <span class="string">"UTF-8"</span>)</span><br><span class="line"></span><br><span class="line">fund_type &lt;- c(<span class="string">"一般股票型"</span>, <span class="string">"中小型"</span>, <span class="string">"科技型"</span>)</span><br><span class="line"><span class="comment">#data_return &lt;- function(folder_name)</span></span><br><span class="line">data &lt;- data_merge(<span class="string">"一般股票型"</span>)</span><br><span class="line"><span class="comment">#write.csv(data, "一般股票型.csv")</span></span><br><span class="line">write.csv(data, <span class="string">"./ppt材料/一般股票型統計.csv"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#報酬率</span></span><br><span class="line">fit &lt;- aov(formula = <span class="keyword">return</span> ~ name, data = data) <span class="comment"># anova 分析</span></span><br><span class="line">anova_table &lt;- anova(fit)</span><br><span class="line">lsd &lt;- LSD.test(fit, <span class="string">"name"</span>, p.adj =<span class="string">"none"</span>, alpha = <span class="number">0.05</span>) <span class="comment">#判斷 LSD 分析</span></span><br><span class="line">lsd$groups$name &lt;- lsd$groups %&gt;% row.names()</span><br><span class="line">row.names(lsd$groups) &lt;- <span class="literal">NULL</span> <span class="comment">#將 rownames 轉為 index</span></span><br><span class="line">View(lsd$groups)</span><br><span class="line">good_funds &lt;- lsd$groups$name[grep(<span class="string">"a"</span>, lsd$groups$groups)]</span><br><span class="line">data &lt;- data[data$name %<span class="keyword">in</span>% good_funds, ]</span><br><span class="line"></span><br><span class="line"><span class="comment">#sharpe</span></span><br><span class="line">fit &lt;- aov(formula = sharpe ~ name, data = data) <span class="comment">#anova 分析</span></span><br><span class="line">anova_table &lt;- anova(fit)</span><br><span class="line">lsd &lt;- LSD.test(fit, <span class="string">"name"</span>, p.adj =<span class="string">"none"</span>, alpha = <span class="number">0.05</span>) <span class="comment">#判斷 LSD 分析</span></span><br><span class="line">lsd$groups$name &lt;- lsd$groups %&gt;% row.names()</span><br><span class="line">row.names(lsd$groups) &lt;- <span class="literal">NULL</span> <span class="comment">#將 rownames 轉為 index</span></span><br><span class="line">View(lsd$groups)</span><br><span class="line">good_funds &lt;- lsd$groups$name[grep(<span class="string">"a"</span>, lsd$groups$groups)]</span><br><span class="line">data &lt;- data[data$name %<span class="keyword">in</span>% good_funds, ]</span><br></pre></td></tr></table></figure>

<h3 id="結果與結論"><a href="#結果與結論" class="headerlink" title="結果與結論"></a>結果與結論</h3><ul>
<li><p>一般股票型</p>
<ul>
<li>return <ul>
<li>ANOVA，一般股票型基金的報酬差沒有明顯差異<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=19bum8ZSvbmeCnKKovx8KHVCl685-gkS8&export=download" alt=""></p>
</blockquote>
</li>
<li>LSD<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1Bb0LplP1vkSfzl_VXAPymdzuRcyys7BM&export=download" alt=""></p>
</blockquote>
</li>
</ul>
</li>
<li>sharpe ratio<ul>
<li>ANOVA，一般股票型基金的 sharpe ratio 沒有明顯差異<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1KzVqrgiSoqKu6rMZZrxq67LsboFhIqxR&export=download" alt=""></p>
</blockquote>
</li>
<li>LSD <blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=16vDV4ghesv1pQIrGsDeqs_Aawo6zJ_o1&export=download" alt=""></p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li><p>中小型</p>
<ul>
<li>return <ul>
<li>ANOVA，中小型基金的報酬差沒有明顯差異<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1zi443MEVinhnJRNUcK4i-kYb7XxbOgHm&export=download" alt=""></p>
</blockquote>
</li>
<li>LSD<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1CfZRmGEdlS-ArM9MBx7TrvLXG3UEiggM&export=download" alt=""></p>
</blockquote>
</li>
</ul>
</li>
<li>sharpe ratio<ul>
<li>ANOVA，中小型基金的 sharpe ratio 沒有明顯差異<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1AZ4aOovpoPf8obCQ76YJwMt6i2N-roNy&export=download" alt=""></p>
</blockquote>
</li>
<li>LSD <blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=12w11gSiXrXBvlsMNtaNhlslUyKi1xzBQ&export=download" alt=""></p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li><p>科技型</p>
<ul>
<li>return <ul>
<li>ANOVA，科技型的報酬差沒有明顯差異<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1ibAPTLZitwZAzHGVLInwJQcNakNMpQoU&export=download" alt=""></p>
</blockquote>
</li>
<li>LSD<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1_93_Zmy-2ZJ0fm9qf2U4cK27rqoSOd76&export=download" alt=""></p>
</blockquote>
</li>
</ul>
</li>
<li>sharpe ratio<ul>
<li>ANOVA，科技型基金的 sharpe ratio 沒有明顯差異<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1BQRdg1uS8U8u50E-eKn0rZQSuxNIpiDM&export=download" alt=""></p>
</blockquote>
</li>
<li>LSD <blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1-7iFT9d-qWRxGTW5rI2clUS8iq2cDQ0x&export=download" alt=""></p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li><p>結論</p>
<ul>
<li><p>蠻意外的，沒想到在 2017~2020 中每個類型中的所有基金的 return、sharpe ratio 全部都一樣。ummm…所以這樣應該也就表示其實所有的基金管理人都差不多優秀，沒有明顯被坑的情況。</p>
</li>
<li><p>因此我們就選出三類基金中的 return、sharpe ratio LSD 綜合排名第一名，來當作我們這三類基金的 normal_fund、small_fund、tech_fund</p>
<ul>
<li>其中國內股票開放型一般股票型基金最好的基金<strong>安聯台灣智慧基金</strong>定義為 normal_fund  </li>
<li>其中國內股票開放型中小型基金最好的基金<strong>復華中小精選基金</strong>定義為 small_fund </li>
<li>其中國內股票開放型科技型基金最好的基金<strong>安聯台灣科技基金</strong>定義為 tech_fund</li>
</ul>
</li>
<li><p>normal_fund、small_fund、tech_fund 的報酬率、sharpe ratio 折線圖</p>
<ul>
<li>return     <blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1RXtkEPP0G2y1wOptf1zZ6EbErmmh-_lZ&export=download" alt=""></p>
</blockquote>
</li>
<li>sharpe ratio 折線圖<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1rH4dc0yVpd6tHZPS7rsjr4lX3PFbuSkC&export=download" alt=""></p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="再來我們針對-normal-fund、small-fund、tech-fund-比較看看這些基金是否有差異。"><a href="#再來我們針對-normal-fund、small-fund、tech-fund-比較看看這些基金是否有差異。" class="headerlink" title="再來我們針對 normal_fund、small_fund、tech_fund 比較看看這些基金是否有差異。"></a>再來我們針對 normal_fund、small_fund、tech_fund 比較看看這些基金是否有差異。</h2><ul>
<li><strong>結論：normal_fund、small_fund、tech_fund　這三個基金的變異數都相等。</strong></li>
<li>下面有六張圖，請根據圖片中的 <code>data: xxx_fund and aaa_fund</code>，來得知是哪兩個基金比較。<ul>
<li><blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1olFq5iIq6yzQTOTX6EKIrx3UxpvrQ4s_&export=download" alt=""></p>
</blockquote>
</li>
<li><blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1gJCnHIF2VMI7H4qfes0OYqIaviDZye13&export=download" alt=""></p>
</blockquote>
</li>
<li><blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1Zsdh_q-SSLJxI2lHkT6cKU_J0Ochd53N&export=download" alt=""></p>
</blockquote>
</li>
<li><blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1OutFoK56DPngaUaHkprq_py1FHFkt2hW&export=download" alt=""></p>
</blockquote>
</li>
<li><blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1qywg5tbMcQHtC-JSell3IXVRMSUJeHML&export=download" alt=""></p>
</blockquote>
</li>
<li><blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1zRMe_YRTLlFnjUgg528e1XwV_vsw02Kg&export=download" alt=""></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">#### file name</span></span><br><span class="line"><span class="comment">#var.R</span></span><br><span class="line"><span class="comment">####</span></span><br><span class="line"><span class="keyword">library</span>(magrittr)</span><br><span class="line"><span class="keyword">library</span>(quantmod)</span><br><span class="line"><span class="keyword">library</span>(agricolae)</span><br><span class="line"><span class="keyword">library</span>(stats)</span><br><span class="line">setwd(<span class="string">"D:\\NTUT\\大二下\\統計\\報告"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">source</span>(<span class="string">"./merge_data.R"</span>, encoding = <span class="string">"UTF-8"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#在使用此函式前，必須先使用 *_fund.R 先判斷哪些基金最好</span></span><br><span class="line"></span><br><span class="line">fund_type &lt;- c(<span class="string">"一般股票型"</span>, <span class="string">"中小型"</span>, <span class="string">"科技型"</span>)</span><br><span class="line"><span class="comment">#data_return &lt;- function(folder_name)</span></span><br><span class="line">normal_fund &lt;- data_merge(<span class="string">"一般股票型"</span>)</span><br><span class="line">small_fund &lt;- data_merge(<span class="string">"中小型"</span>)</span><br><span class="line">tech_fund &lt;- data_merge(<span class="string">"科技型"</span>)</span><br><span class="line"></span><br><span class="line">write.csv(normal_fund[normal_fund$name == <span class="string">"安聯台灣智慧基金"</span>,], <span class="string">"./ppt材料/安聯台灣智慧基金統計.csv"</span>)</span><br><span class="line">write.csv(small_fund[small_fund$name == <span class="string">"復華中小精選基金"</span>,], <span class="string">"./ppt材料/復華中小精選基金統計.csv"</span>)</span><br><span class="line">write.csv(tech_fund[tech_fund$name == <span class="string">"安聯台灣科技基金"</span>,], <span class="string">"./ppt材料/安聯台灣科技基金統計.csv"</span>)</span><br><span class="line">normal_fund &lt;- normal_fund$<span class="keyword">return</span>[normal_fund$name == <span class="string">"安聯台灣智慧基金"</span>] </span><br><span class="line">small_fund &lt;- small_fund$<span class="keyword">return</span>[small_fund$name == <span class="string">"復華中小精選基金"</span>]</span><br><span class="line">tech_fund &lt;- tech_fund$<span class="keyword">return</span>[tech_fund$name == <span class="string">"安聯台灣科技基金"</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var(normal_fund)</span><br><span class="line">var(small_fund)</span><br><span class="line">var(tech_fund)</span><br><span class="line"><span class="comment">#Reject</span></span><br><span class="line">var.test(normal_fund, </span><br><span class="line">         small_fund,</span><br><span class="line">         alternative = <span class="string">"two.sided"</span>) <span class="comment">#less 表示 A 股票比 B 股票標準差更大</span></span><br></pre></td></tr></table></figure>

<h2 id="再來為這-normal-fund、small-fund、tech-fund-基金做迴歸分析，X-變數是-normal-fund、small-fund、tech-fund-的前十大股票，使用迴歸分析來看基金的前十大標的是否對這基金影響力很強。"><a href="#再來為這-normal-fund、small-fund、tech-fund-基金做迴歸分析，X-變數是-normal-fund、small-fund、tech-fund-的前十大股票，使用迴歸分析來看基金的前十大標的是否對這基金影響力很強。" class="headerlink" title="再來為這 normal_fund、small_fund、tech_fund 基金做迴歸分析，X 變數是 normal_fund、small_fund、tech_fund 的前十大股票，使用迴歸分析來看基金的前十大標的是否對這基金影響力很強。"></a>再來為這 normal_fund、small_fund、tech_fund 基金做迴歸分析，X 變數是 normal_fund、small_fund、tech_fund 的前十大股票，使用迴歸分析來看基金的前十大標的是否對這基金影響力很強。</h2><ul>
<li>以下的 x 變數是前十大股票當天漲跌幅</li>
<li>y 都是基金當天漲跌幅</li>
</ul>
<h3 id="normal-fund-基金回歸"><a href="#normal-fund-基金回歸" class="headerlink" title="normal_fund 基金回歸"></a>normal_fund 基金回歸</h3><ul>
<li>共線性測試，並沒有明顯共線性問題<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1T6D-XTxzcTyQx_ko3iXSz5uu0CravQLJ&export=download" alt=""></p>
</blockquote>
</li>
<li>回歸模型，\(adj_R^2 = 0.7381\)<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1CBDAM-7tZHJiCZR-emaTZFuOqfcKtQBe&export=download" alt=""></p>
</blockquote>
</li>
<li>所有 x 係數<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1-UYBTwNfRid5lbARBr7AVaP5pXEQsxM8&export=download" alt=""></p>
</blockquote>
</li>
<li>所有 x 的 t test，每一個都與 y 有關聯<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=10iVIHLXSQf3AIAGHk7I_UsUXkwF-aao9&export=download" alt=""></p>
</blockquote>
</li>
<li>殘差分析、常態機率等圖<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1lo5kNGjQ0qRl-KWc_pCZjxpWcuD6-_jL&export=download" alt=""></p>
</blockquote>
</li>
<li>結論<br>如果我們買前十大基金並搭配 x 係數的資金分配，那我們就可以達到基金大約 73% 的功效，也就是說我們如果單純只買這幾支股票，那麼我們理論上會跟這基金有百分之 73% 漲幅相同，也許投資人可以嘗試看看自己買股票，就可以減少基金投資人手續費。</li>
</ul>
<h3 id="small-fund-基金回歸"><a href="#small-fund-基金回歸" class="headerlink" title="small_fund 基金回歸"></a>small_fund 基金回歸</h3><ul>
<li>共線性測試，並沒有明顯共線性問題<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1J7LQMRGdeWtUk-ivL_207ncUguBZESOJ&export=download" alt=""></p>
</blockquote>
</li>
<li>回歸模型，\(adj_R^2 = 0.6952\)<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1h3gAhuhFuY85N8b2kqFOVpJZREPnltFf&export=download" alt=""></p>
</blockquote>
</li>
<li>所有 x 係數<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1ppMc_Fg0Rc6uoxpLSQ2H9ckv3q0KevvC&export=download" alt=""></p>
</blockquote>
</li>
<li>所有 x 的 t test，每一個都與 y 有關聯<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1gn55G2j8QYiXKenRFJj8-fsvX3Gl93i0&export=download" alt=""></p>
</blockquote>
</li>
<li>殘差分析、常態機率等圖<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1mlEFl481HJnPUIwt5RR7EFls9hR16Rdm&export=download" alt=""></p>
</blockquote>
</li>
<li>結論<br>如果我們買前十大基金並搭配 x 係數的資金分配，那我們就可以達到基金大約 70% 的功效，也就是說我們如果單純只買這幾支股票，那麼我們理論上會跟這基金有百分之 70% 漲幅相同，也許投資人可以嘗試看看自己買股票，就可以減少基金投資人手續費。</li>
</ul>
<h3 id="tech-fund-基金回歸"><a href="#tech-fund-基金回歸" class="headerlink" title="tech_fund 基金回歸"></a>tech_fund 基金回歸</h3><ul>
<li>共線性測試，2327 與 2492 有明顯貢獻性關係，2492 在這檔基金的權重較高，因此我們刪除 2327<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=13Vtty6mouxE2VRlUS-PNUyNjtdAIOj4y&export=download" alt=""></p>
</blockquote>
</li>
<li>回歸模型，\(adj_R^2 = 0.8399\)<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1rRyDF0i1ewMsOz_b4u2roTSm0CUIGEUT&export=download" alt=""></p>
</blockquote>
</li>
<li>所有 x 係數<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1R9pCSJse9yFvB7FW7d82LWXgcNntP_DG&export=download" alt=""></p>
</blockquote>
</li>
<li>所有 x 的 t test，每一個都與 y 有關聯<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1KcTR7KkPHOg7nLbRblMnqBR9nZBtlx5M&export=download" alt=""></p>
</blockquote>
</li>
<li>殘差分析、常態機率等圖<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1qipc8LEY37jUMZxq0vHYX0j5tnZ4sI1a&export=download" alt=""></p>
</blockquote>
</li>
<li>結論<br>如果我們買前十大基金並搭配 x 係數的資金分配，那我們就可以達到基金大約 84% 的功效，也就是說我們如果單純只買這幾支股票，那麼我們理論上會跟這基金有百分之 84% 漲幅相同，也許投資人可以嘗試看看自己買股票，就可以減少基金投資人手續費。</li>
</ul>
<h3 id="程式碼"><a href="#程式碼" class="headerlink" title="程式碼"></a>程式碼</h3><figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">#### file name</span></span><br><span class="line"><span class="comment"># lm.R </span></span><br><span class="line"><span class="comment">####</span></span><br><span class="line"><span class="keyword">library</span>(magrittr)</span><br><span class="line"><span class="keyword">library</span>(quantmod)</span><br><span class="line"><span class="keyword">library</span>(agricolae)</span><br><span class="line"><span class="keyword">library</span>(tibble)</span><br><span class="line"><span class="keyword">library</span>(ggfortify)</span><br><span class="line"><span class="keyword">source</span>(<span class="string">"./merge_data.R"</span>, encoding = <span class="string">"UTF-8"</span>)</span><br><span class="line"></span><br><span class="line">setwd(<span class="string">"D:\\NTUT\\大二下\\統計\\報告"</span>)</span><br><span class="line"></span><br><span class="line">fund_type &lt;- c(<span class="string">"一般股票型"</span>, <span class="string">"中小型"</span>, <span class="string">"科技型"</span>)</span><br><span class="line"><span class="comment">#data_return &lt;- function(folder_name)</span></span><br><span class="line"></span><br><span class="line">path &lt;- file.path(getwd(), <span class="string">"基金CSV"</span>, <span class="string">"科技型"</span>, <span class="string">"安聯台灣科技基金.csv"</span>)</span><br><span class="line"></span><br><span class="line">fund &lt;- read.csv(path)</span><br><span class="line">fund$date &lt;- fund$日期 %&gt;% as.Date() %&gt;% as.character()</span><br><span class="line"></span><br><span class="line">fund$<span class="keyword">return</span> &lt;- gsub(<span class="string">"%"</span>, <span class="string">""</span>, fund$漲跌幅) %&gt;% as.numeric() </span><br><span class="line">fund$<span class="keyword">return</span> &lt;- fund$<span class="keyword">return</span> * <span class="number">0.01</span></span><br><span class="line">date &lt;- fund$date</span><br><span class="line"></span><br><span class="line"><span class="comment">#基金的前十大股票</span></span><br><span class="line">codes &lt;- c(<span class="string">"2330.TW"</span>, <span class="string">"3529.TWO"</span>, <span class="string">"2492.TW"</span>, <span class="string">"2327.TW"</span>, <span class="string">"2337.TW"</span>, <span class="string">"8016.TW"</span>, <span class="string">"6510.TWO"</span>,</span><br><span class="line">           <span class="string">"6732.TWO"</span>, <span class="string">"4966.TWO"</span>, <span class="string">"3035.TW"</span>)</span><br><span class="line"><span class="keyword">for</span> (code <span class="keyword">in</span> codes)&#123; <span class="comment">#找出所有股票的共同日期</span></span><br><span class="line">  stock &lt;- getSymbols(code, auto.assign = <span class="literal">FALSE</span> , from = <span class="string">"2016-01-01"</span> ) %&gt;% na.omit() %&gt;% data.frame()</span><br><span class="line">  names(stock) &lt;- c(<span class="string">"open"</span>, <span class="string">"high"</span>, <span class="string">"low"</span>, <span class="string">"close"</span>, <span class="string">"vol"</span>, <span class="string">"adjPrice"</span>)</span><br><span class="line">  stock$date &lt;- rownames(stock) %&gt;% as.Date() %&gt;% as.character()</span><br><span class="line">  rownames(stock) &lt;- <span class="literal">NULL</span></span><br><span class="line">  date &lt;- intersect(date, stock$date)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data &lt;- tibble(date = date, <span class="keyword">return</span> = fund$<span class="keyword">return</span>[fund$date %<span class="keyword">in</span>% date])</span><br><span class="line"><span class="keyword">for</span>(code <span class="keyword">in</span> codes)&#123; <span class="comment">#找出所有股票的共同日期的報酬率</span></span><br><span class="line">  stock &lt;- getSymbols(code, auto.assign = <span class="literal">FALSE</span> , from = <span class="string">"2016-01-01"</span> ) %&gt;% na.omit() %&gt;% data.frame()</span><br><span class="line">  names(stock) &lt;- c(<span class="string">"open"</span>, <span class="string">"high"</span>, <span class="string">"low"</span>, <span class="string">"close"</span>, <span class="string">"vol"</span>, <span class="string">"adjPrice"</span>)</span><br><span class="line">  stock$date &lt;- rownames(stock) %&gt;% as.Date() %&gt;% as.character()</span><br><span class="line">  stock$last_close &lt;- c(<span class="literal">Inf</span>, head(stock$close, length(stock$close)-<span class="number">1</span>))</span><br><span class="line">  stock$<span class="keyword">return</span> &lt;- (stock$close - stock$last_close) / stock$last_close</span><br><span class="line">  rownames(stock) &lt;- <span class="literal">NULL</span></span><br><span class="line">  data[ , code] &lt;- stock$<span class="keyword">return</span>[stock$date %<span class="keyword">in</span>% date]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#共線性測試，</span></span><br><span class="line">cor.test &lt;- cor(data[<span class="number">3</span>:ncol(data)])</span><br><span class="line">cor.test</span><br><span class="line"></span><br><span class="line"><span class="comment">#將共線性過高的刪除</span></span><br><span class="line">data[<span class="string">"2327.TW"</span>] &lt;- <span class="literal">NULL</span></span><br><span class="line">write.csv(data, <span class="string">"科技股回歸資料.csv"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#迴歸分析</span></span><br><span class="line">model &lt;- lm(formula = <span class="keyword">return</span> ~ ., data = data[, <span class="number">2</span>:ncol(data)]) </span><br><span class="line">View(model)</span><br><span class="line">sum_model &lt;- summary(model)</span><br><span class="line">View(sum_model)</span><br><span class="line"></span><br><span class="line"><span class="comment">#殘差圖、標準常態圖</span></span><br><span class="line">autoplot(model)</span><br></pre></td></tr></table></figure>

<h2 id="再來做最適資產配置，推薦投資者應該將投資如何比例至這些基金中"><a href="#再來做最適資產配置，推薦投資者應該將投資如何比例至這些基金中" class="headerlink" title="再來做最適資產配置，推薦投資者應該將投資如何比例至這些基金中"></a>再來做最適資產配置，推薦投資者應該將投資如何比例至這些基金中</h2><ul>
<li>我們有請教<a href="http://web.fin.mcu.edu.tw/zh-hant/content/%E5%85%BC%E4%BB%BB%E5%B8%AB%E8%B3%87" target="_blank" rel="noopener">王甡老師</a> 如果要做三檔基金時要怎麼樣計算，老師給了我們一份 word 資料，提供我們學習。<br>我將檔案連結放在這邊，由於是<a href="https://drive.google.com/file/d/1eOMUrfjgTLIIECHG8-JLlR2vZJbW-tGz/view?usp=sharing" target="_blank" rel="noopener">老師的檔案我沒有權力共享，因此只有設定我的帳號才可以查看、瀏覽，提供我學習XD</a>。</li>
<li>再來我們借助 excel 的矩陣運算與最佳求解，找出三種資產的最適資產配置比例<ul>
<li>利用前面假設檢定挑選出的各基金類別中最好的基金進行最適資產配置</li>
<li>計算年化報酬率、共變異數矩陣</li>
<li>最適風險性資產投資組合的權重是投資組合變異數最小的權重</li>
<li>最小變異數的投資組合為標準差4.79%，預期報酬率31.2%</li>
</ul>
</li>
<li>結論資產配置<ul>
<li>權重為安聯台灣智慧基金111.00%</li>
<li>復華中小精選基金-18.71%</li>
<li>安聯台灣科技基金7.71%</li>
</ul>
</li>
<li>表示若要選擇風險最小的投資組合必須將投資在復華中小精選基金的資金，投資到另外兩檔基金，需要借貸資金才能達到風險最小的投資組合</li>
<li>圖表 <blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1FhK2u15yqpvjHXHxT9t29Ly8pCI5N3ye&export=download" alt=""></p>
</blockquote>
</li>
</ul>
<h3 id="非常有趣的資產配置方法"><a href="#非常有趣的資產配置方法" class="headerlink" title="非常有趣的資產配置方法"></a>非常有趣的資產配置方法</h3><ul>
<li>由於我們知道資產配置不可以有負值，如果有，表示這三種並不適合一起拿來做資產配置，或負比例基金移除。</li>
<li>但我們這邊做一個啟發。</li>
<li>公式推導<ul>
<li>A:安聯台灣智慧基金 B:復華中小精選基金C:安聯台灣科技基金 </li>
<li>A+B+C = 100，其中因為 B 是負，導致投資人沒辦法正確資產配置，因此我們將 B 改為 0。</li>
<li>\(A+B+C=100\) ，\(A+C=100+B\) ，其中 \(B = -18.71\)</li>
<li>\(A+C = 100 + B = 118.71\) ,\(A+C=118.71\)</li>
<li>\(111+7.71 = 118.71\)，\(A+C=100\) ，\(同除 1.1871\)</li>
<li>\(C=6.4948%\) ，\(A=93.505%\)</li>
</ul>
</li>
<li>因此我們推薦投資人買安聯台灣智慧基金 93.505%  ，安聯台灣科技基金 = 6.4948%</li>
<li>這個完全沒有任何論文根據，純粹個人推導，如果並不是這樣我不負責喔XD。不過可以跟我說我錯在哪裡。</li>
</ul>
<h2 id="資料來源"><a href="#資料來源" class="headerlink" title="資料來源"></a>資料來源</h2><p><a href="https://rdrr.io/r/base/row.names.html" target="_blank" rel="noopener">row.names: Get and Set Row Names for Data Frames by rdrr.io</a><br><a href="https://bookdown.org/jefflinmd38/r4biost/basicfunctiuon.html" target="_blank" rel="noopener">Chapter 6 基本函式 by bookdown</a><br><a href="https://stat.ethz.ch/pipermail/r-help/2008-January/152105.html" target="_blank" rel="noopener">[R] subsetting a data frame using string matching by stat.ethz</a><br><a href="https://stackoverflow.com/questions/15326792/select-column-2-to-last-column-in-r" target="_blank" rel="noopener">Select column 2 to last column in R by stackoverflow</a><br><a href="https://stackoverflow.com/questions/11991692/using-rs-lm-on-a-dataframe-with-a-list-of-predictors" target="_blank" rel="noopener">Using R’s lm on a dataframe with a list of predictors by stackoverflow</a><br><a href="https://stackoverflow.com/questions/6286313/remove-an-entire-column-from-a-data-frame-in-r" target="_blank" rel="noopener">Remove an entire column from a data.frame in R by stackoverflow</a><br><a href="https://bookdown.org/wangminjie/R4DS/lm.html#%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E6%A8%A1%E5%9E%8B" target="_blank" rel="noopener">33.2 线性回归模型 by bookdown</a><br><a href="https://www.rdocumentation.org/packages/stats/versions/3.6.2/topics/lm" target="_blank" rel="noopener">lm: Fitting Linear Models by rdocu</a><br><a href="https://www.statmethods.net/stats/correlations.html" target="_blank" rel="noopener">Correlations by Quick-R</a><br><a href="http://www.sthda.com/english/wiki/f-test-compare-two-variances-in-r" target="_blank" rel="noopener"> F-Test: Compare Two Variances in R by STHDA</a><br><a href="https://stat.ethz.ch/pipermail/r-help/2010-January/225345.html" target="_blank" rel="noopener">[R] Extract R-squared from summary of lm by stat.ethz</a><br><a href="https://zhuanlan.zhihu.com/p/49149862" target="_blank" rel="noopener">R语言(3)-四张图检验线性回归模型 by 知乎</a><br><a href="https://slidesplayer.com/slide/17269077/" target="_blank" rel="noopener">R教學 變異數分析R指令與範例 by 羅琪老師.</a><br><a href="https://stackoverflow.com/questions/12208090/selecting-columns-in-r-data-frame-based-on-those-not-in-a-vector" target="_blank" rel="noopener">Selecting columns in R data frame based on those <em>not</em> in a vector by stackoverflow</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>好累阿，不過先謝謝我們的組員們，畢竟我們一起努力生出這份專案 <strong>吳淑萍、彭元俊、王奕淇</strong>，也要謝謝丁秀儀老師，其實我一直很想用統計做一個投資的專案，終於讓我做出來了www。<br>也要謝謝王甡老師，有他在後面督促我們，引導方向，我們才可以順利產出，並且有符合實務。</p>
<p>其實一路上再用 R 寫統計專案真的是很累QQ，不過這已經比其他的程式語言都還好用，只是自己摸不熟拉，剛好透過這次的專案摸熟。<br>其實 R 真的很有用，建議大家有機會的話可以學學他。</p>
<p>謝謝吳淑萍幫我們做 PPT，還有跟我開那麼多會，一直跟我溝通，辛苦了XD。<br>謝謝彭元俊幫我們做資產配置，使用 excel 做資產配置最適規劃。<br>謝謝王奕淇幫我們蒐集資料。</p>
<p>總之我覺得我們這組做的很棒，也很不賴！有各位才順利。</p>
<p>不過老實講，我自己在弄統計的時候，其實寫程式寫久都會有一種負能量產生，因為寫程式寫太久一直再找 bug 常常腦中就會有RRRRR，怎麼只有我一個人再找 bug，不行，工作質量分配不均！我要上訴，之類的奇怪想法在我腦海裏面wwww，可是其實我就會想一下，我除了寫程式以外其他都沒有比較擅長的，我也只有這個會做，有了這個反擊後，我就又會乖乖的寫程式。<br>直到下一次 bug 找不到為止www。</p>
<p>不過也要很感謝 R 開放套件的人，如果沒有他們，我就會更難寫程式了！</p>
<blockquote>
<p>附上一張詢問王甡老師的照片<br><img src="https://drive.google.com/u/2/uc?id=1AKOiMXtk--MC6O-GNxDZjA9UG8rQuIoo&export=download" alt=""></p>
</blockquote>
]]></content>
      <categories>
        <category>北科上課筆記</category>
        <category>統計 statistics</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>統計學筆記</tag>
        <tag>北科大二下統計學筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>北科資工二多媒體技術與應用 期末報告 - 物件辨識，使用 colab 與 yolov4 實作</title>
    <url>/2021/07/08/Media_with_Image_recognition/NTUTcs_MediaHwfinalexamG01/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊工程系大二下多媒體技術與應用作業紀錄<br><font color="#dd0000">並非所有人都適用，部分對我而言稍加容易的內容並不會寫在此內。</font><br><strong>這是學習後心得的筆記，可能不太適用會未來的學生</strong></p>
<p>由於我沒有學習過裡面的理論，因此這是資工大二學生透過網路與自身理解的筆記，學習價值並不高、且可能擁有大量錯誤。</p>
<p>訓練的資料從 KITTI 資料集產生出來，後面會留下的成果。</p>
<p>如果需要點選某些特定章節，請善用右上的章節列</p>
</blockquote>
<a id="more"></a>

<h2 id="專案說明"><a href="#專案說明" class="headerlink" title="專案說明"></a>專案說明</h2><blockquote>
<p>如紅色線條上方說明文字<br><img src="https://drive.google.com/u/2/uc?id=1f6Rxxk0vANowWgqtTBz_u-hQdEM6nf2G&export=download" alt=""><br><img src="https://drive.google.com/u/2/uc?id=1O0gSfy0En5HQKDJj_VsLHGgY5_zONQlP&export=download" alt=""><br><img src="https://drive.google.com/u/2/uc?id=1dUtJqVaVRml61RwgiqAwFIyrLu714Z69&export=download" alt=""><br><img src="https://drive.google.com/u/2/uc?id=1OPx-JlmgCz02vmUz3MnqKm_nguzxrmtw&export=download" alt=""><br><img src="https://drive.google.com/u/2/uc?id=15b4jvm388-9JHdMAO9ljVetrpAvO93pv&export=download" alt=""><br><img src="https://drive.google.com/u/2/uc?id=1zL8qx0jhzH6UXjlNzBwyydJMWXlSDwNP&export=download" alt=""></p>
</blockquote>
<h2 id="下載資料"><a href="#下載資料" class="headerlink" title="下載資料"></a>下載資料</h2><p>根據專案要求先前往<a href="http://www.cvlibs.net/datasets/kitti/eval_object.php?obj_benchmark&fbclid=IwAR1u06li3-5cW0-g5duUsCD4Eo3JxkhseahQRAFNMXOMAqQRrd1Dy0v52wo" target="_blank" rel="noopener">此網站獲得資料集</a>，你會收到一封驗證信，點擊驗證信網址後就會自動下載，由於我們使用 colab 來進行訓練，因此就不需要下載到本地。</p>
<blockquote>
<p>保留此網址<br><img src="https://drive.google.com/u/2/uc?id=159CWiyb1iZ5lPZzlCU5uN6mhEKgkXOQs&export=download" alt=""></p>
</blockquote>
<h2 id="開啟-colab，並且將-KITTI-資料下載到雲端硬碟"><a href="#開啟-colab，並且將-KITTI-資料下載到雲端硬碟" class="headerlink" title="開啟 colab，並且將 KITTI 資料下載到雲端硬碟"></a>開啟 colab，並且將 KITTI 資料下載到雲端硬碟</h2><p>前情概要，如果<a href="https://theriseofdavid.github.io/2021/05/19/Media_with_Image_recognition/NTUTcs_MediaHW07G01/#%E4%BD%BF%E7%94%A8-google-colab-%E4%BE%86%E9%80%B2%E8%A1%8C%E5%9C%96%E5%83%8F%E8%BE%A8%E8%AD%98" target="_blank" rel="noopener">不熟悉 colab 可以看這篇網站的解說</a>，這邊我們不會對 colab 多做介紹，已完成專案需求為主。</p>
<p>以下的 colab 可能都有路徑問題，因為 colab 在久沒有使用時，會自動斷開，因此路徑會有混亂的問題，對每位讀者非常抱歉。</p>
<h3 id="必要條件與須知"><a href="#必要條件與須知" class="headerlink" title="必要條件與須知"></a>必要條件與須知</h3><ul>
<li>先將 gpu 功能開啟</li>
<li>colab 在處理大量資料時會有時間差，也就是你在 colab 已經刪除這個資料，但在 google drive 還沒看到資料被刪除，這時必須耐心等待。<del>我也是這樣撐過來的</del></li>
</ul>
<h3 id="google-drive-與-colab-串接"><a href="#google-drive-與-colab-串接" class="headerlink" title="google drive 與 colab 串接"></a>google drive 與 colab 串接</h3><p>輸入以下指令</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> google.colab <span class="keyword">import</span> drive</span><br><span class="line">drive.mount(<span class="string">'/content/drive'</span>)</span><br></pre></td></tr></table></figure>

<h3 id="再來我們設定一個捷逕，方便我們之後在操作時可以直接透過此捷徑迅速到我們的物件辨識專區"><a href="#再來我們設定一個捷逕，方便我們之後在操作時可以直接透過此捷徑迅速到我們的物件辨識專區" class="headerlink" title="再來我們設定一個捷逕，方便我們之後在操作時可以直接透過此捷徑迅速到我們的物件辨識專區"></a>再來我們設定一個捷逕，方便我們之後在操作時可以直接透過此捷徑迅速到我們的物件辨識專區</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">!ln -f -s /content/drive/MyDrive/NTUT/<span class="string">'大二下- 資工多媒體技術與應用'</span>/<span class="string">'期末報告-物件辨識'</span> /drive  <span class="comment">#這是我資料夾的路徑</span></span><br><span class="line">!ls /drive</span><br></pre></td></tr></table></figure>

<h3 id="再來我們將-KITTI-下載到雲端硬碟"><a href="#再來我們將-KITTI-下載到雲端硬碟" class="headerlink" title="再來我們將 KITTI 下載到雲端硬碟"></a>再來我們將 KITTI 下載到雲端硬碟</h3><ul>
<li>在專案說明中有提到我們必須下載三個檔案，其中有兩個檔案有驗證信、一個可以直接下載，我們將這三個網址都複製起來，並透過 colab 直接進行下載。</li>
<li>下面我只列出一個網址，但實際上我們並須下載三個網址。</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">%cd /drive/ <span class="comment">#將資料存放到物件辨識專區</span></span><br><span class="line">!pwd </span><br><span class="line">!wget https://s3.eu-central<span class="number">-1.</span>amazonaws.com/avg-kitti/data_object_image_2.zip <span class="comment">#大概有 7800 多張照片</span></span><br><span class="line">!wget https://s3.eu-central<span class="number">-1.</span>amazonaws.com/avg-kitti/data_object_label_2.zip</span><br><span class="line">!wget https://s3.eu-central<span class="number">-1.</span>amazonaws.com/avg-kitti/devkit_object.zip</span><br></pre></td></tr></table></figure>

<p>google colab 的網速真的神，我的爛到一個不行…。下載/上傳 16/3 mpbs 好慘QQ。</p>
<h3 id="再來我們將這三個檔案進行解壓縮"><a href="#再來我們將這三個檔案進行解壓縮" class="headerlink" title="再來我們將這三個檔案進行解壓縮"></a>再來我們將這三個檔案進行解壓縮</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#可能會有路徑問題，請大家注意，如果已在 drive 內，就不需要</span></span><br><span class="line">!unzip /drive/data_object_image_2.zip -d /drive/training</span><br><span class="line">!unzip /drive/data_object_label_2.zip -d /drive/training</span><br><span class="line">!unzip /drive/devkit_object.zip  -d /drive/training</span><br></pre></td></tr></table></figure>

<h3 id="檢查下是否都有成功被解壓縮到正確位置"><a href="#檢查下是否都有成功被解壓縮到正確位置" class="headerlink" title="檢查下是否都有成功被解壓縮到正確位置"></a>檢查下是否都有成功被解壓縮到正確位置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%cat .&#x2F;label&#x2F;000000.txt</span><br><span class="line">#如果有成功輸出 3 0.622194 0.609351 0.080335 0.44573，表示成功</span><br></pre></td></tr></table></figure>

<h2 id="colab-下載-darknet"><a href="#colab-下載-darknet" class="headerlink" title="colab 下載 darknet"></a>colab 下載 darknet</h2><p><a href="https://theriseofdavid.github.io/2021/05/19/Media_with_Image_recognition/NTUTcs_MediaHW07G01/#%E4%BD%BF%E7%94%A8-google-colab-%E4%BE%86%E9%80%B2%E8%A1%8C%E5%9C%96%E5%83%8F%E8%BE%A8%E8%AD%98" target="_blank" rel="noopener">請按照這邊的步驟，即可成功</a>，但有幾點需要特別注意。</p>
<ul>
<li>必須先將我們的雲端硬碟更改權限為可以讀出、寫入<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#必須先做，第一步非常重要! </span></span><br><span class="line">!chmod +x ./ <span class="comment">#讓我的雲端硬碟可被寫入</span></span><br></pre></td></tr></table></figure></li>
<li>下載 darknet<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#抓預訓練模型</span></span><br><span class="line">%cd ./darknet/</span><br><span class="line">!wget https://github.com/AlexeyAB/darknet/releases/download/darknet_yolo_v3_optimal/yolov4.conv<span class="number">.137</span></span><br></pre></td></tr></table></figure></li>
<li>Makefile 修改 4 點，之後進行 make</li>
<li>修改 <code>/content/darknet/cfg/yolov4-custom.cfg</code><br>其中讀者可以從 readme.txt 得知有 9 個 class。</li>
</ul>
<h2 id="將-KITTI-資料集-label-轉換為-yolo-格式"><a href="#將-KITTI-資料集-label-轉換為-yolo-格式" class="headerlink" title="將 KITTI 資料集 label 轉換為 yolo 格式"></a>將 KITTI 資料集 label 轉換為 yolo 格式</h2><p><a href="#專案說明">專案說明</a>有提到，KITTI 資料集的 label 並不是 yolo 格式，因此要進行轉換。<br>轉換程式碼如下，謝謝林紀瑋的編寫。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os </span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">path = <span class="string">"/drive/training"</span></span><br><span class="line">images_file = list()</span><br><span class="line">os.chdir(os.path.join(path, <span class="string">"label"</span>)) <span class="comment"># KITTI 標籤位置</span></span><br><span class="line">print(os.getcwd())</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> fname <span class="keyword">in</span> os.listdir(os.getcwd()):</span><br><span class="line">    ID = <span class="string">""</span></span><br><span class="line">    x = <span class="number">0</span></span><br><span class="line">    y = <span class="number">0</span></span><br><span class="line">    width = <span class="number">0</span></span><br><span class="line">    height = <span class="number">0</span></span><br><span class="line">    f = open(fname)</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f.readlines():</span><br><span class="line">        s = line.split(<span class="string">' '</span>)</span><br><span class="line">        ID = (s[<span class="number">0</span>])</span><br><span class="line">        x = ((float(s[<span class="number">4</span>])+float(s[<span class="number">6</span>]))/<span class="number">2</span>) <span class="comment">#x</span></span><br><span class="line">        y = ((float(s[<span class="number">5</span>])+float(s[<span class="number">7</span>]))/<span class="number">2</span>) <span class="comment">#y</span></span><br><span class="line">        width = (float(s[<span class="number">6</span>]) -float(s[<span class="number">4</span>])) <span class="comment">#width</span></span><br><span class="line">        height = (float(s[<span class="number">7</span>]) -float(s[<span class="number">5</span>])) <span class="comment">#height</span></span><br><span class="line">            </span><br><span class="line">    print(ID)</span><br><span class="line">    print(x)</span><br><span class="line">    print(y)</span><br><span class="line">    print(width)</span><br><span class="line">    print(height)</span><br><span class="line">    f.close()</span><br><span class="line"></span><br><span class="line">    <span class="comment">##path = 'output.txt'</span></span><br><span class="line">    <span class="comment">##f = open(path, 'w')</span></span><br><span class="line">    <span class="comment">##lines = ['Hello World\n', '123', '456\n', '789\n']</span></span><br><span class="line">    <span class="comment">##f.writelines(lines)</span></span><br><span class="line">    <span class="comment">##f.close()</span></span><br><span class="line"></span><br><span class="line">    f = open(fname,<span class="string">'w'</span>)</span><br><span class="line">    f.write(ID+<span class="string">'\t'</span>)</span><br><span class="line">    f.write(str(x)+<span class="string">'\t'</span>)</span><br><span class="line">    f.write(str(y)+<span class="string">'\t'</span>)</span><br><span class="line">    f.write(str(width)+<span class="string">'\t'</span>)</span><br><span class="line">    f.write(str(height)+<span class="string">'\n'</span>)</span><br></pre></td></tr></table></figure>

<h3 id="將-yolo-格式的資料放到圖片的資料夾中"><a href="#將-yolo-格式的資料放到圖片的資料夾中" class="headerlink" title="將 yolo 格式的資料放到圖片的資料夾中"></a>將 yolo 格式的資料放到圖片的資料夾中</h3><p>這裡我們直接使用 linux 語法來操作</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#將 label 資料放到圖片位置，透過正規表達式來處理</span></span><br><span class="line">!cp /drive/training/label/*.txt /drive/training/image</span><br><span class="line"></span><br><span class="line"><span class="comment">#檢查是否都有成功的將資料集標籤放到圖片資料夾下</span></span><br><span class="line">%cd /drive/training/image/</span><br><span class="line">!ls</span><br></pre></td></tr></table></figure>




<h2 id="訓練前處理"><a href="#訓練前處理" class="headerlink" title="訓練前處理"></a>訓練前處理</h2><h3 id="根據專案說明，我們訓練的資料至少有-5000-張、其他為驗證集，因此我們寫一個-py-程式來將檔名-gt-5500-的圖片放到另一資料夾與訓練集分開"><a href="#根據專案說明，我們訓練的資料至少有-5000-張、其他為驗證集，因此我們寫一個-py-程式來將檔名-gt-5500-的圖片放到另一資料夾與訓練集分開" class="headerlink" title="根據專案說明，我們訓練的資料至少有 5000 張、其他為驗證集，因此我們寫一個 py 程式來將檔名 &gt; 5500 的圖片放到另一資料夾與訓練集分開"></a>根據專案說明，我們訓練的資料至少有 5000 張、其他為驗證集，因此我們寫一個 py 程式來將檔名 &gt; 5500 的圖片放到另一資料夾與訓練集分開</h3><p>驗證集資料路徑我們使用 <code>/drive/testing</code></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#移動 5000 以上的資料至 testing </span></span><br><span class="line"><span class="comment">#%pwd</span></span><br><span class="line"><span class="keyword">import</span> os </span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line">path = <span class="string">"/drive/testing/"</span></span><br><span class="line">files = list()</span><br><span class="line">os.chdir(os.path.join(path, <span class="string">"label"</span>))</span><br><span class="line">print(os.getcwd())</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> fname <span class="keyword">in</span> os.listdir(os.getcwd()):</span><br><span class="line">  num = fname.split(<span class="string">"."</span>)[<span class="number">0</span>] <span class="comment">#判斷檔名是不是為資料集中的圖片，資料集中的圖片都已數字編號完成 </span></span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">not</span> num.isdigit()):  </span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line">  move_path = <span class="string">"/drive/testing/image/"</span> </span><br><span class="line">  <span class="keyword">if</span> int(num) &gt; <span class="number">5500</span>: <span class="comment">#移動路徑</span></span><br><span class="line">    shutil.move(os.path.join(os.getcwd(), fname), os.path.join(move_path, fname))</span><br><span class="line">    print(os.path.join(move_path), fname)</span><br></pre></td></tr></table></figure>

<p>正確輸出時會產生這樣的資料</p>
<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1AtD6hVk0Ep4tzPgZ0NS9SPzyMJ9hgoD2&export=download" alt=""></p>
</blockquote>
<h2 id="將訓練集資料、驗證集資料收錄到-train-txt-valid-txt"><a href="#將訓練集資料、驗證集資料收錄到-train-txt-valid-txt" class="headerlink" title="將訓練集資料、驗證集資料收錄到 train.txt, valid.txt"></a>將訓練集資料、驗證集資料收錄到 <code>train.txt, valid.txt</code></h2><p>前情概要，如果<a href="https://theriseofdavid.github.io/2021/05/19/Media_with_Image_recognition/NTUTcs_MediaHW07G01/#%E4%BD%BF%E7%94%A8-google-colab-%E4%BE%86%E9%80%B2%E8%A1%8C%E5%9C%96%E5%83%8F%E8%BE%A8%E8%AD%98" target="_blank" rel="noopener">不熟悉 colab 可以看這篇網站的解說</a>，這邊我們不會對 colab 多做介紹，已完成專案需求為主。</p>
<p>直接寫 py 來根據資料夾內容圖片收錄至 <code>train.txt, valid.txt</code>，因此下面這份程式要被執行兩次分別是  <code>train.txt, valid.txt</code></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os </span><br><span class="line"><span class="comment">#path = "/drive/training" #訓練集路徑</span></span><br><span class="line">path = <span class="string">"/drive/testing"</span> <span class="comment">#驗證集路徑</span></span><br><span class="line">images_file = list()</span><br><span class="line">os.chdir(os.path.join(path, <span class="string">"image"</span>)) </span><br><span class="line">print(os.getcwd())</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> fname <span class="keyword">in</span> os.listdir(os.getcwd()):</span><br><span class="line">  <span class="keyword">if</span> fname.endswith(<span class="string">".png"</span>):</span><br><span class="line">    images_file.append(<span class="string">"/image/"</span> + fname)</span><br><span class="line">    print(fname)</span><br><span class="line"></span><br><span class="line">os.chdir(<span class="string">".."</span>)</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"train.txt"</span>, <span class="string">"w"</span>) <span class="keyword">as</span> output: <span class="comment">#驗證集則使用 valid.txt</span></span><br><span class="line">  <span class="keyword">for</span> image <span class="keyword">in</span> images_file:</span><br><span class="line">    output.write(path + image)</span><br><span class="line">    output.write(<span class="string">'\n'</span>)</span><br><span class="line">  output.close()</span><br></pre></td></tr></table></figure>

<p>檢查 <code>train.txt, valid.txt</code> 是否有成功被收錄</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">%cat /drive/training/train.txt</span><br><span class="line">%cat /drive/testing/valid.txt</span><br></pre></td></tr></table></figure>

<h3 id="再來在本地產生兩個檔案，並放入-training-資料夾內"><a href="#再來在本地產生兩個檔案，並放入-training-資料夾內" class="headerlink" title="再來在本地產生兩個檔案，並放入 training 資料夾內"></a>再來在本地產生兩個檔案，並放入 training 資料夾內</h3><h4 id="obj-data"><a href="#obj-data" class="headerlink" title="obj.data"></a><code>obj.data</code></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">classes &#x3D; 9</span><br><span class="line">train &#x3D; &#x2F;drive&#x2F;training&#x2F;train.txt</span><br><span class="line">valid &#x3D; &#x2F;drive&#x2F;testing&#x2F;train.txt</span><br><span class="line">names &#x3D; &#x2F;drive&#x2F;training&#x2F;obj.names</span><br><span class="line">backup &#x3D; &#x2F;drive&#x2F;training</span><br></pre></td></tr></table></figure>

<h4 id="obj-names"><a href="#obj-names" class="headerlink" title="obj.names"></a><code>obj.names</code></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Car</span><br><span class="line">Van</span><br><span class="line">Truck</span><br><span class="line">Pedestrian</span><br><span class="line">Person_sitting</span><br><span class="line">Cyclist</span><br><span class="line">Tram</span><br><span class="line">Misc</span><br><span class="line">DontCare</span><br></pre></td></tr></table></figure>





<h2 id="訓練模型"><a href="#訓練模型" class="headerlink" title="訓練模型"></a>訓練模型</h2><p>我們就來訓練模型</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#初次訓練模型</span></span><br><span class="line">%cd ./darknet</span><br><span class="line">!./darknet detector train /drive/training/obj.data \</span><br><span class="line">/drive/darknet/cfg/yolov4-custom.cfg \</span><br><span class="line">/drive/darknet/yolov4.conv<span class="number">.137</span> -dont_show</span><br></pre></td></tr></table></figure>

<h3 id="ERROR：-Can-39-t-open-label-file-This-can-be-normal-only-if-you-use-MSCOCO-drive-training-image-2-001318-txt"><a href="#ERROR：-Can-39-t-open-label-file-This-can-be-normal-only-if-you-use-MSCOCO-drive-training-image-2-001318-txt" class="headerlink" title="ERROR： Can&#39;t open label file. (This can be normal only if you use MSCOCO): /drive/training/image_2/001318.txt"></a>ERROR： <code>Can&#39;t open label file. (This can be normal only if you use MSCOCO): /drive/training/image_2/001318.txt</code></h3><p>表示你的路徑位置並不正確，需要在檢查</p>
<h3 id="當-colab-因為使用過久而中斷後，再次進行訓練"><a href="#當-colab-因為使用過久而中斷後，再次進行訓練" class="headerlink" title="當 colab 因為使用過久而中斷後，再次進行訓練"></a>當 colab 因為使用過久而中斷後，再次進行訓練</h3><h4 id="記住，如果訓練過久中斷，你必須重新連接-google-drive-並設置捷徑，並且讓雲端硬碟可讓-colab-寫入"><a href="#記住，如果訓練過久中斷，你必須重新連接-google-drive-並設置捷徑，並且讓雲端硬碟可讓-colab-寫入" class="headerlink" title="記住，如果訓練過久中斷，你必須重新連接 google drive 並設置捷徑，並且讓雲端硬碟可讓 colab 寫入"></a>記住，如果訓練過久中斷，你必須重新連接 google drive 並設置捷徑，並且讓雲端硬碟可讓 colab 寫入</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">%cd /drive/</span><br><span class="line"><span class="comment">#%cd </span></span><br><span class="line">%ls</span><br><span class="line">%pwd</span><br><span class="line">!chmod <span class="number">755</span> -R ./ <span class="comment">#讓我的雲端硬碟可被寫入</span></span><br></pre></td></tr></table></figure>


<h4 id="再次進行訓練模型時則使用此語法"><a href="#再次進行訓練模型時則使用此語法" class="headerlink" title="再次進行訓練模型時則使用此語法"></a>再次進行訓練模型時則使用此語法</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#不斷訓練模型</span></span><br><span class="line">%cd ./darknet</span><br><span class="line">!./darknet detector train /drive/training/obj.data \</span><br><span class="line">/drive/darknet/cfg/yolov4-custom.cfg \</span><br><span class="line">/drive/training/yolov4-custom_last.weights -dont_show</span><br></pre></td></tr></table></figure>

<p>訓練完成後，您會看到有一個檔名叫做 <code>yolov4-custom_final.weights</code> 這個就是完整的訓練模型了。之後都靠她來辨識拉！</p>
<h4 id="到底還要訓練多久？"><a href="#到底還要訓練多久？" class="headerlink" title="到底還要訓練多久？"></a>到底還要訓練多久？</h4><blockquote>
<p>有看到用紅筆畫底線的數字嗎? 那個是 max_batches 的數字，只要訓練到 max_batches 就會停止了。如果希望可以訓練的快點就將 <code>yolov4-custom.cfg</code> max_batches 修改。<br><img src="https://drive.google.com/u/2/uc?id=1HkszGppT9GFiEo87QLQUozarM9LUkDSG&export=download" alt=""></p>
</blockquote>
<h2 id="使用訓練好的模型來辨識圖片"><a href="#使用訓練好的模型來辨識圖片" class="headerlink" title="使用訓練好的模型來辨識圖片"></a>使用訓練好的模型來辨識圖片</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">%cd ../</span><br><span class="line">!./darknet/darknet detector test  /drive/training/obj.data \</span><br><span class="line">/drive/darknet/cfg/yolov4-custom.cfg \</span><br><span class="line">/drive/training/yolov4-custom_final.weights \</span><br><span class="line">-dont_show /drive/testing/image/<span class="number">005510.</span>png \ </span><br><span class="line">-out_filename /drive/testing/image/<span class="number">005510.</span>png \</span><br><span class="line"><span class="comment">#隨意一張照片，沒有要求</span></span><br></pre></td></tr></table></figure>

<h3 id="ERROR-如果辨識出來的圖片沒有標籤文字怎麼辦？-如下圖所示"><a href="#ERROR-如果辨識出來的圖片沒有標籤文字怎麼辦？-如下圖所示" class="headerlink" title="ERROR: 如果辨識出來的圖片沒有標籤文字怎麼辦？ 如下圖所示"></a>ERROR: 如果辨識出來的圖片沒有標籤文字怎麼辦？ 如下圖所示</h3><blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1tDSugt34QgLLJLkB2EeImr_zXwAo0RYV&export=download" alt=""></p>
</blockquote>
<p>很不幸的，你必須自己去修改程式碼。<br>路徑為 darknet &gt; src &gt; image.c:276，必須將他修改到符合你的雲端硬碟檔案路徑位置。<br>也就是說你的 darknet &gt; data &gt; labels 資料夾這邊不更動，理論上是沒有吃到你雲端硬碟的路徑，因此將 darknet 前面改成你的雲端硬碟路徑即可。</p>
<blockquote>
<p>示意如下：<br><img src="https://drive.google.com/u/2/uc?id=1CmS8G4giEJNCaGsRgG28uhJ8My-gHni4&export=download" alt=""></p>
</blockquote>
<p>當你修改完成後，請記住需要再 <code>!make darknet</code></p>
<h3 id="QUESTION-我可以讓輸出的圖片到我指定的資料夾嗎"><a href="#QUESTION-我可以讓輸出的圖片到我指定的資料夾嗎" class="headerlink" title="QUESTION: 我可以讓輸出的圖片到我指定的資料夾嗎?"></a>QUESTION: 我可以讓輸出的圖片到我指定的資料夾嗎?</h3><p>當然沒問題，但是很麻煩QQ。 這是我跟林紀瑋學長一起嘗試用出來的。<br>我用圖片來表示那些地方要修改，變數命名很髒就不要笑了XD。</p>
<p>路徑為 darknet &gt; src &gt; detector.c:1693 開始</p>
<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1nJI2vV_gqhGRBkv5japv4KYr6sUecYwT&export=download" alt=""></p>
</blockquote>
<h3 id="QUESTION-我想要大量產生透過-yolo-辨識後的圖片，該怎麼辦呢？"><a href="#QUESTION-我想要大量產生透過-yolo-辨識後的圖片，該怎麼辦呢？" class="headerlink" title="QUESTION: 我想要大量產生透過 yolo 辨識後的圖片，該怎麼辦呢？"></a>QUESTION: 我想要大量產生透過 yolo 辨識後的圖片，該怎麼辦呢？</h3><p>我們可以將想要透過 yolo 辨識的圖片放到同一個資料夾中，然後使用 linux 語法來寫迴圈。<br>我之前有使用過 py 來操作，但發現 colab 並沒有辦法使用 os package，因此使用 linux 語法解決。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">!for i in &#123;6111..7218&#125;; do .&#x2F;darknet&#x2F;darknet detector test  &#x2F;drive&#x2F;training&#x2F;obj.data \</span><br><span class="line">&#x2F;drive&#x2F;darknet&#x2F;cfg&#x2F;yolov4-custom.cfg \</span><br><span class="line">&#x2F;drive&#x2F;training&#x2F;yolov4-custom_final.weights \</span><br><span class="line">-dont_show &#x2F;drive&#x2F;testing&#x2F;image&#x2F;00$i.png \</span><br><span class="line">-out_filename &#x2F;drive&#x2F;testing&#x2F;image&#x2F;00$i.png \ ;done</span><br></pre></td></tr></table></figure>

<h2 id="利用-yolo-訓練完的模型來對驗證集做驗證，看看效果如何"><a href="#利用-yolo-訓練完的模型來對驗證集做驗證，看看效果如何" class="headerlink" title="利用 yolo 訓練完的模型來對驗證集做驗證，看看效果如何"></a>利用 yolo 訓練完的模型來對驗證集做驗證，看看效果如何</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%cd .&#x2F;darknet&#x2F;</span><br><span class="line">!.&#x2F;darknet detector map &#x2F;drive&#x2F;training&#x2F;obj.data \</span><br><span class="line"> &#x2F;drive&#x2F;darknet&#x2F;cfg&#x2F;yolov4-custom.cfg \</span><br><span class="line">&#x2F;drive&#x2F;training&#x2F;yolov4-custom_last.weights \</span><br><span class="line">-dont_show &#x2F;drive&#x2F;testing&#x2F;image_2&#x2F;007007.png \</span><br><span class="line">-out_filename &#x2F;drive&#x2F;testing&#x2F;image_2&#x2F;007007.png &gt;&gt; pic_map.log</span><br><span class="line">#將結果存到 pic_map.log</span><br></pre></td></tr></table></figure>

<blockquote>
<p>結果如下<br>其中 TP 為正確數、FP 為錯誤數<br>average IOU 位置準確率為 68.07%，並不算很完美，但算是尚可的表現。<br>準確率達到 0.88，相當優秀。<br><img src="https://drive.google.com/u/2/uc?id=10XdEVZkhcYmkMKJUXF2EgnxAigkMDr-w&export=download" alt=""></p>
</blockquote>
<h2 id="使用訓練好的模型來辨識圖片有哪些物件，並且將驗證集的圖片都進行辨識。"><a href="#使用訓練好的模型來辨識圖片有哪些物件，並且將驗證集的圖片都進行辨識。" class="headerlink" title="使用訓練好的模型來辨識圖片有哪些物件，並且將驗證集的圖片都進行辨識。"></a>使用訓練好的模型來辨識圖片有哪些物件，並且將驗證集的圖片都進行辨識。</h2><p><a href="https://drive.google.com/drive/folders/1da--8WGo8-VYbOdrMIpRp_JUSR2abYi1?usp=sharing" target="_blank" rel="noopener">此資料夾將所有的驗證集圖片都進行辨識</a>，希望可以幫助到大家</p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://github.com/pjreddie/darknet/issues/1726" target="_blank" rel="noopener">Can’t open label file. (This can be normal only if you use MSCOCO) #1726 by github</a><br><a href="https://stackoverflow.com/questions/51109931/moving-files-in-google-colab" target="_blank" rel="noopener">Moving files in Google Colab by stackoverflow</a><br><a href="https://stackoverflow.com/questions/63321024/bin-bash-darknet-permission-denied" target="_blank" rel="noopener">/bin/bash: ./darknet: Permission denied by stackoverflow</a><br><a href="https://chtseng.wordpress.com/2018/09/01/%E5%BB%BA%E7%AB%8B%E8%87%AA%E5%B7%B1%E7%9A%84yolo%E8%BE%A8%E8%AD%98%E6%A8%A1%E5%9E%8B-%E4%BB%A5%E6%9F%91%E6%A9%98%E8%BE%A8%E8%AD%98%E7%82%BA%E4%BE%8B/" target="_blank" rel="noopener">建立自己的YOLO辨識模型 – 以柑橘辨識為例 by CH.Tseng</a><br><a href="https://www.ibm.com/docs/zh-tw/aix/7.1?topic=directories-copying-cp-command" target="_blank" rel="noopener">複製目錄（cp 指令） by IBM</a><br><a href="https://github.com/googlecolab/colabtools/issues/287" target="_blank" rel="noopener">files in colab is not in sync with google drive  by github</a><br><a href="https://makerpro.cc/2020/02/use-google-colab-to-train-yolo/" target="_blank" rel="noopener">【機器學習】利用Google Colab訓練YOLO by MAKERPRO</a><br><a href="https://blog.csdn.net/mieleizhi0522/article/details/79989754" target="_blank" rel="noopener">YOLOv3批量测试图片并保存在自定义文件夹下 by CSDN</a><br><a href="https://stackoverflow.com/questions/63328654/yolo-darknet-how-to-change-the-output-file-directory-of-a-detection-predicti" target="_blank" rel="noopener">YOLO (Darknet): How to change the output file directory of a detection (predictions.jpg)? by stackoverflow</a><br><a href="https://www.huaweicloud.com/articles/511a98ee75d2a414365e182e780f1f1d.html" target="_blank" rel="noopener">darknet评测自己的数据集 recall map计算 by 華為雲</a><br><a href="https://github.com/pjreddie/darknet/issues/903" target="_blank" rel="noopener">How to run YOLO on multiple images and save predictions to a txt file by stackoverflow</a><br><a href="https://github.com/pjreddie/darknet/issues/955" target="_blank" rel="noopener">Cannot load image “data/labels/*.png” by stackoverflow</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>真的是好累壓，上多媒體課程學習到了好多東西。老實講，很喜歡這堂課。這堂課讓我學習到了好多事務。而且也讓我願意一個字一個字慢慢打，來整理我所學習到的事物。</p>
<p>從原本討厭 yolo、colab 到慢慢可以接受，老實講心境真的變蠻多的XDDDD，果然上手了就有差，還沒突破撞牆期之前的話都不能算數阿XDD。</p>
<p>總之，希望自己未來也能夠像現在一樣努力，整理著自己學習的回憶。</p>
<p>願未來一切安好，我努力成功。</p>
<p>也謝謝組員林紀瑋、郭梓琳一路的陪伴，讓我這個外系生不需要自己一個人扛起全部，不然每次修外系課都很怕遇到雷隊友呢！</p>
<h2 id="專案報告-ppt"><a href="#專案報告-ppt" class="headerlink" title="專案報告 ppt"></a>專案報告 ppt</h2><p>我將專案報告 ppt 分享給大家，希望大家也能從我的 blog 中學到！<br><a href="https://drive.google.com/file/d/1xkjLWlkDp7rYDvqxvqtebJ14R2pa3tbt/view?usp=sharing" target="_blank" rel="noopener">多媒體技術與應用-期末報告</a></p>
<h2 id="我的-colab"><a href="#我的-colab" class="headerlink" title="我的 colab"></a>我的 colab</h2><p><a href="https://colab.research.google.com/drive/1Tah0qdum10irIaovUjHpQS0Sjea-x8dX?usp=sharing" target="_blank" rel="noopener">我在這邊共享我的 colab 副本，開放檢視權，讓讀者可以看到一些我可能文字敘述不好的地方</a></p>
<h2 id="yolov5-in-colab"><a href="#yolov5-in-colab" class="headerlink" title="yolov5 in colab"></a>yolov5 in colab</h2><p>其中在我學習的過程中，班上的好朋友力瑋提醒我說現在 yolov5 比 yolov4 更簡單，讀者們也可以去試試看。<br><a href="https://colab.research.google.com/github/ultralytics/yolov5/blob/master/tutorial.ipynb" target="_blank" rel="noopener">YOLOv5 Tutorial - Colaboratory</a></p>
]]></content>
      <categories>
        <category>北科上課筆記</category>
        <category>多媒體與圖像辨識 Image Recognition</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>北科大多媒體技術與應用筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>北科資工二多媒體技術與應用 期末心得 - 本學期中學到的內容、希望課程補充的教學內容</title>
    <url>/2021/07/08/Media_with_Image_recognition/NTUTcs_MediaHwfinalexamT01/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊工程系大二下多媒體技術與應用作業紀錄<br><font color="#dd0000">並非所有人都適用，部分對我而言稍加容易的內容並不會寫在此內。</font><br><strong>這是學習後心得的筆記，可能不太適用會未來的學生</strong></p>
<p>由於我沒有學習過裡面的理論，因此這是資工大二學生透過網路與自身理解的筆記，學習價值並不高、且可能擁有大量錯誤。</p>
</blockquote>
<a id="more"></a>


<h2 id="本學期中學到的內容"><a href="#本學期中學到的內容" class="headerlink" title="本學期中學到的內容"></a>本學期中學到的內容</h2><p>印象最深的是期中專案的剪刀石頭布，因為主要不是在 colab 上面實作，只透過自己的電腦並且 Hog、SIFT是一種演算法，因此可以清楚描繪出這些演算法是如何實現的，讓我在做的印象特別深刻。<br>我寫的 blog</p>
<p>YOLOv4、LSTM 等需要使用 colab 與深度學習，我認為我比較傾向是會在 colab 上面學會這些應用，但並沒有深刻了解 YOLOv4、LSTM 這些深度學習，深度學習比起演算法更難理解加上我其實沒有去實際體驗一次深度學習的計算，因此會有種自己像是在根據操作手冊在執行步驟的感覺，有點可惜。</p>
<h2 id="希望課程補充的教學內容"><a href="#希望課程補充的教學內容" class="headerlink" title="希望課程補充的教學內容"></a>希望課程補充的教學內容</h2><p>主要希望課程可以補充深度學習的實踐，可以給我們幾次的專案實作了解深度學習的原理，在告訴我們如何使用 YOLOv4，並移除部分軌跡預測，我認為軌跡預測是很好的學習主題，但是我希望可以將時間主要用於深度學習、圖像辨識，圖像預測對我而言有點過早XDDD。</p>
<p>如果沒有疫情，我是希望老師可以給我們主題類似於期中專案，讓我們根據手邊，從材料開始一一逐步去建立、實作！但是這樣會花費太多時間，因此說步定不是一個好想法。<br>畢竟 labelImg 如果要我們自己標籤，會標到哭吧QQ。</p>
<p>以上，謝謝老師與助教。</p>
]]></content>
      <categories>
        <category>北科上課筆記</category>
        <category>多媒體與圖像辨識 Image Recognition</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>北科大多媒體技術與應用筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa10954 - Add All(水題)</title>
    <url>/2021/07/14/UVa/UVa10954/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>給你一個數列，請善用 <code>a+b=c, cost += c</code> ，其中 a 與 b 是數列裡面的數字，並將 c 再放入數列<br>請求出最小的 cost </p>
<p><a href="https://onlinejudge.org/external/109/10954.pdf" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li>priority_queue 的應用<br><a href="https://theriseofdavid.github.io/2021/05/31/Explain_Algorithm/heap_sort/" target="_blank" rel="noopener">priority_queue 是 heap sort 的應用，理論就是不斷拿出 heap tree 的 root，需要看 heap sort 請看大衞的筆記</a></li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ul>
<li>我們可以知道不斷拿數列中兩個最小的數字相加會使得 cost 最小<br>如果你覺得不可信，可以看看題目舉例</li>
<li>因此我們使用 priority_queue 每次取出兩個最小的相加即可。</li>
</ul>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>水題，給我自信XD。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, num;</span><br><span class="line"><span class="comment">//注意，這是最小遞增 priority_queue 的寫法</span></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt; &gt; q; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n &amp;&amp; n)&#123;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()) q.pop(); <span class="comment">//clear, priority_queue 沒有 clear 的 method  </span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;  <span class="comment">//輸入資料</span></span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; num;</span><br><span class="line">            q.push(num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, a, b;</span><br><span class="line">        <span class="keyword">while</span>(q.size() != <span class="number">1</span>)&#123; <span class="comment">//只要數列中還有兩個以上的數字可以累加</span></span><br><span class="line">            a = q.top(); q.pop();</span><br><span class="line">            b = q.top(); q.pop();</span><br><span class="line">            q.push(a+b);</span><br><span class="line">            ans += a+b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa11264 - Coin Collector(設計解題、貪心)</title>
    <url>/2021/07/08/UVa/UVa11264/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>有位愛好蒐集銅板的人想要透過銀行換錢的方式蒐集各式各樣的錢幣。但礙於銀行永遠都只會先給面額較大的錢幣，因此想請問你他最多可以蒐集多少錢幣。</p>
<p>假如有 1,5,10 這三種錢幣，如果我現在有 31 元，那我就會收到 2 個 10 元硬幣、1 個 1 元硬幣。</p>
<p>假如他身上有任意的錢，請告訴她，透過銀行匯款的方式他能夠收集到幾種貨幣。</p>
<p><a href="https://onlinejudge.org/external/112/11264.pdf" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li>了解到能夠不斷給相同貨幣</li>
<li>了解絕對沒有辦法蒐集到全部的貨幣</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ul>
<li>我們來觀察題目，以 1,3,6,8 為例<ul>
<li>我有 5 元時可以拿到 3,1,1 =&gt; 比 5 小的硬幣都有順利拿到</li>
<li>我有 10 元時可以拿到 8,1,1 =&gt; 並沒有辦法順利地拿到 1,6,10 </li>
<li>我有 12 元時可以拿到 8,3,1 =&gt; 無法拿到 6 硬幣</li>
</ul>
</li>
<li>觀察 A<ul>
<li>如果我想要拿到 6,8 這兩種硬幣，則 14 元可以做到</li>
<li>如果我想拿到 1,6,7 這三種硬幣，則不可能做到。<ul>
<li>\(1+6+7=14\)，\(14 = 7+7 \)</li>
<li>如果 \(1+6 &lt;= 7\)，那麼 1,6 硬幣沒有辦法同時出現，因為會被 7 取代</li>
<li>如果 \(A+B &lt;= C\)，那麼 A,B 硬幣沒有辦法同時出現，因為會被 C 取代</li>
</ul>
</li>
</ul>
</li>
<li>觀察 B，另一種可能性，以 1,3,6,8 為例<ul>
<li>我有 18 元時可以拿到 8,8,1,1 =&gt; 3,6 沒辦法拿到</li>
<li>我有 10 元時可以拿到 8,1,1 =&gt; 3,6 沒辦法拿到</li>
<li>這是因為 \(3+6 &gt;= 8\)，因此沒有機會讓 3,6 同時被拿到。</li>
<li>我們不可能讓 3,6 同時都存在，但我們可以讓 1,3 or 1,6 存在，這裡我們則是去除最大的硬幣。</li>
</ul>
</li>
<li>結論<ul>
<li>小面額銅板的錢幣總和比當前硬幣小，則當前硬幣也可以變成一種組合(觀察A)</li>
<li>小面額銅板的錢幣總和比當前硬幣大，換掉最大的小面額銅板，並加入現在的當前硬幣(觀察B)</li>
</ul>
</li>
</ul>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://hackmd.io/@txya900619/Uva11264" target="_blank" rel="noopener">Uva11264 - Coin Collector by txya900619</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>一個好題，複習我的英文能力，不然我的英文能力真的亂糟糟QQ。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 2000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> t, n;</span><br><span class="line"><span class="keyword">int</span> num[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">cin</span> &gt;&gt; num[i];</span><br><span class="line">        <span class="comment">//sort(num, num+n); //題目本身就有排序</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123; </span><br><span class="line">            <span class="keyword">if</span>(num[i] &gt; sum)&#123; <span class="comment">//觀察 A</span></span><br><span class="line">                ans++;</span><br><span class="line">                sum += num[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> sum = sum - num[i<span class="number">-1</span>] + num[i]; <span class="comment">//觀察 B</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>設計解題</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa11583 - Alien DNA(設計解題、位元運算)</title>
    <url>/2021/07/11/UVa/UVa11583/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>我們發現外星人的 DNA 片段了！但我們必須要將這些 DNA 的片段組裝成一組 DNA。(注意：一組 DNA 是我定義的名詞)<br>而組裝的方式則是只要 DNA 片段中有一個小寫字母與另一個 DNA 片段小寫字母組在一起即可。<br>P.S. 如果想要讓一組 DNA 有三個或以上的片段組成時，則新進來的 DNA 必須都跟其他 DNA 片斷有一個以上的小寫字母連接。</p>
<p>其中一組 DNA 是連續的，因此不可以拿第一個片段 DNA 與第三個片段 DNA 組成一個新的 DNA。<br>而題目要求則是，我們最少需要<strong>切幾次</strong>可以讓裡面的片段 DNA 們都是一組 DNA。 </p>
<p><a href="https://onlinejudge.org/external/115/11583.pdf" target="_blank" rel="noopener">UVa 11583 Alien DNA</a></p>
</blockquote>
<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li>英文閱讀<ul>
<li>對很重要 <code>least one common base.</code> 我看不出來他是指說組裝的方式則是只要 DNA 片段中有一個小寫字母與另一個 DNA 片段小寫字母組在一起即可。</li>
<li>然後我也看不出來<strong>一組 DNA 是連續的</strong>，這個題目要求…</li>
</ul>
</li>
<li>程式編寫<br>有效率、簡潔的程式碼</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>這個問題如果有理解英文後就很好解。</p>
<ul>
<li>我們用 int 的 2 進位位數來表示每個字母是否在這組 DNA 中<ul>
<li>這組 DNA 預設情況 <code>000...0</code></li>
<li>這組 DNA 有了 Z 之後  <code>100...0</code></li>
</ul>
</li>
<li>上面這種方式透過數字表達的 DNA 我稱為數字 DNA</li>
<li>之後我們讓片段 DNA 先產生出數字 DNA </li>
<li>判斷片段數字 DNA 是否跟現在這組數字 DNA 有共同的地方，如果有就讓 <code>(片段數字 DNA &amp; 這組數字 DNA</code><ul>
<li>如果沒有就讓當前這組 DNA 升級成一組 DNA</li>
</ul>
</li>
<li>輸出共有幾組 DNA</li>
</ul>
<p>因為題目有說明片段 DNA 只能夠跟左右片段連接，因此如果是不同種的組裝方式，組合數量也不會不一樣。<br>一組內的片段 DNA 都必須有一個數字相同，所以往往切斷點就是無法組合的片段 DNA</p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://yuihuang.com/zj-d272/" target="_blank" rel="noopener">【題解】ZeroJudge d272: 11583 – Alien DNA by YUI HUANG 演算法學習筆記</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>這題的英文不知道是不是我邏輯差，我怎麼一直看不懂RRRRR。</p>
<p>知道了邏輯後，稍微學習了優秀大神的程式碼編寫方法，太棒了太棒了。又被教到了一課<br>用二進位來編寫真的很不賴。</p>
<p>不愧是竹女阿太秀了</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 10020</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> t, n ;</span><br><span class="line"><span class="keyword">int</span> segment, dna;</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        segment = (<span class="number">1</span> &lt;&lt; <span class="number">27</span>) - <span class="number">1</span>; <span class="comment">//產生出一組 A~Z 都是 1 的數字 DNA，才一定能跟第一組做組合 </span></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">            dna = <span class="number">0</span>; <span class="comment">//片段數字 DNA</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; s.size(); j++)&#123;</span><br><span class="line">                dna |= (<span class="number">1</span> &lt;&lt; (s[j] - <span class="string">'a'</span>));</span><br><span class="line">                <span class="comment">//數字 DNA 表達方式 0 表示沒有 1 表示有</span></span><br><span class="line">                <span class="comment">//a 是 個位數、b 是十位數... 以此類推</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果可以成為一組，那就一組八!</span></span><br><span class="line">            <span class="comment">//注意必須用 and，因為要每個片段 DNA 都有一個小寫字母相同</span></span><br><span class="line">            <span class="keyword">if</span>(dna &amp; segment ) segment &amp;= dna; </span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                segment = dna; <span class="comment">//與前面的一組 DNA 不同，這個片段 DNA 升級成一組 DNA </span></span><br><span class="line">                ans++; <span class="comment">//找到切斷點了! </span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>設計解題</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa11890 - Calculus Simplified(貪心)</title>
    <url>/2021/07/11/UVa/UVa11890/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>給你一個只有加減的多元方程式與一些數字，EX: \(-(-(x-x))\)，\(x = 2,3\)，請將這些 x 帶入方程式內，並找出一種方程式帶入 x 後可以輸出最大的數字。<br>每一個 x 只能夠使用一次</p>
<p><a href="https://onlinejudge.org/external/118/11890.pdf" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li>英文閱讀(對，這個對我來說太麻煩了….)</li>
<li>將方程式做拆解</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ul>
<li>我們需要解決的問題是將方程式做拆解，然後讓所有帶有負號的 \(x\) 放入最小的數字，讓正 \(x\) 都帶入最大的數字。</li>
<li>當運算遇到負號時，x 會改變其正負。</li>
<li>因此我們需要做到<ul>
<li>紀錄每一個 x 的正負</li>
<li>並透過 <code>pair&lt;int,int&gt;</code> 保存正 x 有幾個、負 x 有幾個</li>
<li>正 x 帶入最大的數字、負 x 帶入最小的數字</li>
</ul>
</li>
<li>現在我們來講講如何實現八<ul>
<li>由於我們要解決括號的問題，因此我們可以用一個 stack 來儲存到現在為止我們經過幾個正、負</li>
<li>並且用一個 <code>post</code> 標記，來表示這組括號內都是正 or 負</li>
<li>當碰到右括號時，看看 <code>stack.top()</code> <ul>
<li>如果是負號，就需要把 <code>post</code> 相反，因為我們已經離開現在這組帶有負項的括號，所以要變號</li>
<li>正數則不用改變。</li>
<li><code>stack.pop()</code> </li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://hackmd.io/@txya900619/Uva11890" target="_blank" rel="noopener">Uva11890 -Calculus Simplified by txya900619</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>有點被考倒了QQ。原本是很貪心的只想要紀錄現在經過了幾個 +,-，然後直接做成一個 <code>pair</code>，完全忘記括號的問題了…orz。</p>
<p>然後想到這個問題後，花了 5min 還想不出來要怎麼解決括號。<br>題外話：我原本還想用前序、後序去解，不過後來發現有更好的寫法，只要用 stack 記錄經過的括號，離開這組括號時在 pop 這組括號的符號即可。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100020</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> t, n, num[MAXN];</span><br><span class="line"><span class="built_in">string</span> formula; <span class="comment">//題目方程式</span></span><br><span class="line"></span><br><span class="line">pair&lt;int,int&gt; process()&#123;</span><br><span class="line">    pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; x; <span class="comment">//first 表示正的 x 有幾個、second 負 x 有幾個</span></span><br><span class="line">    <span class="keyword">bool</span> post = <span class="literal">true</span>; <span class="comment">//展開方程式後，當前這組括號是正還是負 post true plus, false subtract</span></span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">bool</span>&gt; status; <span class="comment">//儲存經過的每組括號正負</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; formula.length(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(formula[i] == <span class="string">'x'</span>)&#123; </span><br><span class="line">            <span class="keyword">bool</span> op = post; <span class="comment">//這一個 x 是正或是負 operator true plus, false subtract</span></span><br><span class="line">            <span class="keyword">if</span>(i != <span class="number">0</span> &amp;&amp; formula[i<span class="number">-1</span>] == <span class="string">'-'</span>) op = !op; <span class="comment">//如果這項 x 是負，那就需要變號</span></span><br><span class="line">            <span class="keyword">if</span>(op) x.first++; </span><br><span class="line">            <span class="keyword">else</span> x.second++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(formula[i] == <span class="string">'('</span>)&#123; <span class="comment">//經過這組括號</span></span><br><span class="line">            <span class="keyword">if</span>(i != <span class="number">0</span> &amp;&amp; formula[i<span class="number">-1</span>] == <span class="string">'-'</span>)&#123; <span class="comment">//這組括號是負號</span></span><br><span class="line">                post = !post;</span><br><span class="line">                status.push(<span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> status.push(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(formula[i] == <span class="string">')'</span>)&#123; <span class="comment">//離開這組括號</span></span><br><span class="line">            <span class="keyword">if</span>(status.top() == <span class="literal">false</span>) post = !post; <span class="comment">//如果這組括號是負號，那我們再把它變回來</span></span><br><span class="line">            status.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"out.txt"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; formula &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">cin</span> &gt;&gt; num[i];</span><br><span class="line">        sort(num, num+n);</span><br><span class="line">        pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; x = process();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; x.second; i++) ans -= num[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; x.first; i++) ans += num[n-i<span class="number">-1</span>];</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>設計解題</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa12321 - Gas Stations(設計解題、貪心)</title>
    <url>/2021/07/08/UVa/UVa12321/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>在一條主要幹道上，有許多加油站，其中每一個加油站都會影響主要幹道上的某個區段，用 \([x+r, x-r])\) 表示，x 是道路位置、r 是影像長度，其中幹道上的每一個點都有被加油站區斷給覆蓋到，現在加油站公司想要把一些加油站刪除，前提是幹道上的每一個點都還是必須有一個加油站覆蓋到。<br>請問總共可以刪掉幾個加油站？<br>如果不行，輸出 -1</p>
<p><a href="https://onlinejudge.org/external/123/12321.pdf" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li>英文閱讀</li>
<li>整個程式碼的架構</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>其實這個問題並不難，但要花點心思處理。</p>
<ul>
<li>我們主要是要讓整個幹道的每個點被覆蓋到<ul>
<li>因此我們需要先讓所有的加油站影響區段都記錄下來，我們用 pair 紀錄</li>
<li>排序 pair </li>
</ul>
</li>
<li>預設沒有任何幹道被覆蓋到，預設為 0</li>
<li>用 for 找到一個加油站區段的左邊界 &lt; 0<ul>
<li>因為我們不確定，現在這個加油站是不是最好的選擇，因此我們先準備一個暫存變數 temp</li>
<li>temp = 右邊界</li>
<li>接續 for 循環，如果有一個加油站區段也符合左邊界 &lt; 0，就檢查 temp 是否大於此加油站區段右邊界。</li>
<li>如果有大於，那就讓 temp 改變成此加油站右邊界。</li>
<li>找到一個必要的加油站。</li>
</ul>
</li>
<li>讓 temp 變成加油站覆蓋幹道的左邊界，並且不斷執行 for 循環。(注意: 這裡的 for 與上一點 for 相同，且 i 是接續上一個點)</li>
</ul>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://hackmd.io/@txya900619/Uva12321" target="_blank" rel="noopener">Uva12321 -Gas Stations by txya900619</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>其實這題沒有很難，就是他有一些小步驟要處理。<br>但是我沒有過這個灣，不太會反向思考嗎QQQQ 好難過，被電了一手，嗚嗚。</p>
<p>下次要學會反向思考，不要你不做的意思其實是要你做！　但我的腦袋總是編譯不成功這個意思嘛QQ</p>
<p>謝謝力瑋的 code 拉。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100020</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> G, L, x, r;</span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt; gas;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"out.txt"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; L &gt;&gt; G, L &gt; <span class="number">0</span> &amp;&amp; G &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        gas.clear();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G; i++)&#123; <span class="comment">//輸入加油站區段位置</span></span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; r;</span><br><span class="line">            gas.push_back(&#123;x-r, x+r&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(gas.begin(), gas.end()); <span class="comment">//排序</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//coverage 當前覆蓋位置</span></span><br><span class="line">        <span class="comment">//temp_coverage 為分析中的 temp 含意</span></span><br><span class="line">        <span class="comment">//eliminated 可以消除的加油站</span></span><br><span class="line">        <span class="keyword">int</span> coverage = <span class="number">0</span>, temp_coverage = <span class="number">0</span>, eliminated = G, i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(L &gt; coverage)&#123; <span class="comment">//如果當前覆蓋位置還沒有把幹道每個點都覆蓋</span></span><br><span class="line">            temp_coverage = coverage; <span class="comment">//先將 temp 設定為當前覆蓋位置的右邊界</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//for exit condition: 加油站的右邊界必須小於等於當前覆蓋區端</span></span><br><span class="line">            <span class="keyword">for</span>(; i &lt; G &amp;&amp; gas[i].first &lt;= coverage; i++)&#123; </span><br><span class="line">                <span class="comment">//有辦法比 temp 還長，那就讓 temp 延長到 gas[i].second</span></span><br><span class="line">                <span class="keyword">if</span>(gas[i].second &gt; temp_coverage) temp_coverage = gas[i].second;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(coverage == temp_coverage) <span class="keyword">break</span>; <span class="comment">//如果沒變，表示無法繼續延長區段就跳出</span></span><br><span class="line">            coverage = temp_coverage; <span class="comment">// 延伸當前區段到 temp_coverage</span></span><br><span class="line">            eliminated--; <span class="comment">//必要的加油站多一個 = 能消除的加油站 -1</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(coverage &lt; L) <span class="built_in">cout</span> &lt;&lt; <span class="string">"-1\n"</span>; <span class="comment">//如果沒辦法完整覆蓋幹道輸出 -1</span></span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; eliminated &lt;&lt; <span class="string">"\n"</span>; <span class="comment">//輸出答案</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>設計解題</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa12834 - Extreme Terror(水題)</title>
    <url>/2021/07/07/UVa/UVa12834/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>Shamsu 有幾個商業地點，這些地點分別都會帶來收益，但這些商業地點都有房租。<br>房東們全都是同一人，房東讓你選 k 個地點(不一定要選到 k，可以小於 k)不需要收租、也不能帶來利益。</p>
<p>我們想請你幫幫忙，幫助 Shamsu 獲得最大的利益。<br>其中利益計算方法為：\(收益 - 房租\)。</p>
<p><a href="https://onlinejudge.org/external/128/12834.pdf" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li>水題，英文太長，不好閱讀八XD</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ul>
<li>這題其實不難，就是先計算每一個商業地點的利益</li>
<li>之後 sort</li>
<li>選擇 k <ul>
<li>將利益最小的(負數)，都刪掉，直到放棄的地點數量 = k </li>
<li>利益如果為正，全部保留。<br>因為利益只要為正，即是在小都會讓 Shamsu 獲得更多利益</li>
</ul>
</li>
</ul>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>這題沒有很難，就是普通的水題。考我英文測驗XD</p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://hackmd.io/@txya900619/Uva12834" target="_blank" rel="noopener">Uva12834 - Extreme Terror by txya900619</a></p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1000020</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> t, n, k, kase = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> profit[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"out.txt"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123; <span class="comment">//輸入成本</span></span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; profit[i];</span><br><span class="line">            profit[i] *= <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> y;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123; <span class="comment">//輸入獲利，並計算利益</span></span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; y;</span><br><span class="line">            profit[i] += y;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(profit, profit+n); <span class="comment">//排序，由小排到大</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123; </span><br><span class="line">            <span class="keyword">if</span>(k &amp;&amp; profit[i] &lt; <span class="number">0</span>)&#123; <span class="comment">//獲利為負，並且還有額度可以放棄</span></span><br><span class="line">                k--;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += profit[i]; <span class="comment">//計算在總獲利中</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//輸出答案</span></span><br><span class="line">        <span class="keyword">if</span>(ans &gt; <span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">"Case "</span> &lt;&lt; ++kase &lt;&lt; <span class="string">": "</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"Case "</span> &lt;&lt; ++kase &lt;&lt; <span class="string">": No Profit"</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>水題</tag>
        <tag>UVa</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa13054 - Hippo Circus(設計解題、貪心)</title>
    <url>/2021/07/08/UVa/UVa13054/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>有一組馬戲團要表演，其中要表演河馬走鋼索，他們可以選擇一隻河馬走鋼索，會使用 \(T_a\) 秒、兩隻河馬<strong>疊在一起</strong>一起走鋼索，會使用 \(T_b\) 秒，但由於馬戲團的每一個部門都必須表演，且不能讓時間太長，因此請幫助河馬使用最少的秒數完成表演。</p>
<p>其中每隻河馬都有不同的高度，如果選擇兩隻河馬<strong>疊在一起</strong>一起走鋼索那他們相加起來的高度不可以大於出場門的高度，否則會撞到門。</p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li>直接了當地解決問題</li>
<li>使用貪心解決問題<ul>
<li>\(T_a * 2 &lt; T_b \)</li>
<li>如何讓兩隻河馬疊起來卻不超過門的高度呢？</li>
</ul>
</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ul>
<li>如果\(T_a * 2 &lt; T_b \)，那我就讓每隻河馬都自己走自己的就好。</li>
<li>如何讓兩隻河馬疊起來卻不超過門的高度呢？<ul>
<li>先進行排序</li>
<li>讓最大河馬高度與最小河馬高度相加，如果有大於門的高度，就讓最大的河馬自己走</li>
<li>如果<strong>沒有</strong>大於門的高度，就讓最大的河馬與最小河馬高度一起走</li>
<li>我們用左、右邊界來實現這部分。</li>
</ul>
</li>
<li>如此一來我們就可以順利讓所有的河馬都可以達到完美匹配，讓疊在一起的河馬高度不會大於門。</li>
</ul>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://hackmd.io/@txya900619/Uva13054" target="_blank" rel="noopener">Uva13054 - Hippo Circus by txya900619</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>一開始我想的太複雜，後來發現我應該這樣思考就好。 也是看完力瑋的文章後才有更好的啟發，可以把它寫得更乾淨。<br>謝謝力瑋啦。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100020</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> c, n, h, ta, tb, kase=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> num[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"out.txt"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; c;</span><br><span class="line">    <span class="keyword">while</span>(c--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; h &gt;&gt; ta &gt;&gt; tb;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">cin</span> &gt;&gt; num[i];</span><br><span class="line">        sort(num, num+n); <span class="comment">//蒐集每個河馬高度，然後排序</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> L=<span class="number">0</span>, R=n<span class="number">-1</span>, ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(R &gt; L)&#123; <span class="comment">//左右指針去查詢</span></span><br><span class="line">            <span class="comment">//如果 ta*2 比 tb 大才值得兩個河馬疊起來</span></span><br><span class="line">            <span class="comment">//河馬 R + 河馬 L 高度要比 h 小</span></span><br><span class="line">            <span class="keyword">if</span>(ta * <span class="number">2</span> &gt; tb &amp;&amp; num[R] + num[L] &lt; h)&#123; </span><br><span class="line">                R--; <span class="comment">//左右邊界各縮減一，表示都被使用過</span></span><br><span class="line">                L++;</span><br><span class="line">                ans += tb;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                R--; <span class="comment">//讓最大的自己走。</span></span><br><span class="line">                ans += ta;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//防止中間那隻河馬沒有人跟他配，所以要確認。</span></span><br><span class="line">        <span class="comment">//也不可以寫 while(R &gt;= L) 這樣中間那隻河馬跟他自己疊起來 &lt; h 時不合理。</span></span><br><span class="line">        <span class="keyword">if</span>(R == L) ans += ta; </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Case "</span> &lt;&lt; ++kase &lt;&lt; <span class="string">": "</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>設計解題</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa13177 - Orchestral scores(Binary Search 二分搜尋)</title>
    <url>/2021/07/11/UVa/UVa13177/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>一個古典樂團要進行演奏，通常古典樂團是許多樂器、許多人一起搭配而成，例如：演奏小提琴有 8 個人、中提琴有 4 個、大提琴有 2 個，由於每次演奏的曲譜都不一樣，要帶著走很不方便。<br>如果每個樂手都有一份譜，古典樂一份樂譜至少要 100 張紙以上，這很不環保、浪費成本，因此我們希望可以讓<strong>同個樂器的人可以共同看一份樂譜</strong>，但是如果讓一群人只看一張樂譜會讓聽眾視覺觀感不好，因此指揮會讓<strong>同個樂器的人拿到很多份樂譜</strong>，來降低讓觀眾視覺觀感不好。</p>
<p>因此我們希望給你 p 張譜，n 種樂器、其中每種樂器都有很多人，請告訴我們在以讓最少人一起看樂譜的前提下，最多會有幾個人一起合看一張樂譜。<br>題目不會有 <code>樂譜 &lt; 樂器種類</code> 的情況 </p>
<p>舉例：演奏小提琴有 8 個人、兩張樂譜，那麼小提琴 4 個人一起看一張樂譜。<br><a href="https://onlinejudge.org/external/131/13177.pdf" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li>這邊可以用兩種做法，其中 Binary Search 最好實現<ul>
<li>priority_queue<br><a href="https://theriseofdavid.github.io/2021/05/31/Explain_Algorithm/heap_sort/" target="_blank" rel="noopener">priority_queue 是 heap sort 的應用，理論就是不斷拿出 heap tree 的 root，需要看 heap sort 請看大衞的筆記</a></li>
<li><a href="https://theriseofdavid.github.io/2020/11/15/Explain_Algorithm/binary_search/" target="_blank" rel="noopener">Binary Search</a><br>注意，這裡的二分搜尋的區間是 <code>[L,R]</code>，而學習連結是 <code>[L,R)</code></li>
</ul>
</li>
<li>Udebug 的第二個測資有誤…。(在我寫這篇文章時他是第二個)</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ul>
<li>通常大家第一個會先想到 priority_queue，但我們要考慮一種情況。<ul>
<li>舉例：p = 5, n = 3, 9,1,1<ul>
<li>如果用最簡單的做法，大到小 priority_queue 然後不斷除二，會遇到小數點的問題。<ul>
<li><code>9/2= 4.5</code>，這時候就變成我們要 + 1，<code>push(5)</code></li>
<li>但正確答案其實是 3。</li>
</ul>
</li>
<li>也就是說，如果用 priority_queue 實作，我們必須用一個 struct 實作，參數有。<ul>
<li>樂手數量</li>
<li>幾個樂譜</li>
<li>幾個人看一張樂譜</li>
</ul>
</li>
<li>但這樣比較麻煩，因為你必須寫 struct compare。</li>
</ul>
</li>
</ul>
</li>
<li>二分搜尋，這個大家比較不會想到，原因是因為不直觀。<ul>
<li>想想，其實我們是要找出一種狀況是最多會有幾個人一起合看一張樂譜。</li>
<li>題目詢問我們的是<strong>x 個人一起合看一張樂譜</strong></li>
<li>我們把題目想深一點，可以想成<strong>這個樂團最多 x 個人看一張樂譜，樂譜總數量有沒有超過 p</strong></li>
<li>這時候就可以轉化成二分搜尋，降低複雜度。我們只要找到最低的 x 就可以了！此時就不會被 p 影響，複雜度就可以降至 \(O(n \log n\)</li>
<li>作法<ul>
<li>左邊界設為 1 個人看一張、右邊界設為樂器中最多人的一團看一張。</li>
<li>如果再 x 個人的情況下需要 y 張樂譜<ul>
<li>y 比 p 小，可以讓更多人看因此把 R 邊界降低，讓 (L+R)/2 變小，讓更少人看一張</li>
<li>y 比 p 大，把 L 邊界提高，讓更少人看一張</li>
</ul>
</li>
<li>不斷二分搜尋，找出一種最佳答案。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://hackmd.io/@txya900619/Uva13177" target="_blank" rel="noopener">Uva13177 - Orchestral scores by txya900619</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>其實我原本是要用 priority_queue 的寫法的，只是在我想好做法後，先翻了翻解答XD。<br>不然假如自己程式碼寫錯還要重改很嘔嘛，又不是比賽，深思熟慮完成後對答案來改進也不差。</p>
<p>畢竟紙上談兵都錯了的話，那做下去也不會對。</p>
<p>看了後發現這題還可以用另一種方式去詮釋，覺得很棒。就寫這種做法了。</p>
<p><a href="https://isaaclo97.github.io/problems/UVA/13177.html" target="_blank" rel="noopener">後來有在網路上看到有人用 priority_queue 這種作法，點此連結</a></p>
<p>總之，這次讓我看到了一種做法是並不是以題目給的答案為主要思考方向，而是在往上推一層，找出一個可以決定題目答案的變數，並推敲此變數已獲得答案。<br>這想法很不賴阿，100分。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="comment">//#define DEBUG</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100020</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> p, n;</span><br><span class="line"><span class="keyword">int</span> num[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="comment">//freopen("out.txt", "w", stdout);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; p &gt;&gt; n)&#123;</span><br><span class="line">        <span class="comment">//注意：這裡我們的 m 就是分析中的 x，是要看最多 x 人拿一張樂譜的情況下，每個樂器部門需要幾張</span></span><br><span class="line">        <span class="comment">//左邊界設定一個人一張</span></span><br><span class="line">        <span class="keyword">int</span> L=<span class="number">1</span>, R=<span class="number">0</span>; <span class="comment">// L </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; num[i];</span><br><span class="line">            <span class="comment">//L = min(num[i], L);</span></span><br><span class="line">            R = max(num[i], R); <span class="comment">//右邊界設定以最大團的樂器部門人數數量，以此做標準拿一張</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(L &lt;= R)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (L+R) / <span class="number">2</span>, required = <span class="number">0</span>; <span class="comment">//required 總共需要幾張樂譜</span></span><br><span class="line">            <span class="comment">//計算每張樂譜需要的數量</span></span><br><span class="line">            <span class="comment">//因為每個樂團至少要一張，因此先將 mid，以避免計算出來的數字為 0</span></span><br><span class="line">            <span class="comment">//EX: 2 / 10 = 0，但理論上要是 1</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) required += (num[i] + mid - <span class="number">1</span>) / mid;</span><br><span class="line">            <span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"L R required "</span> &lt;&lt; L &lt;&lt; <span class="string">' '</span> &lt;&lt; R &lt;&lt; <span class="string">' '</span> &lt;&lt; required &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">            <span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// DEBUG</span></span></span><br><span class="line">            <span class="keyword">if</span>(required &lt;= p)&#123; <span class="comment">//如果 required 小於等於 p，表示還可以讓更少人拿一張</span></span><br><span class="line">                ans = mid; <span class="comment">//以最多 mid 人為一個單位，剛好符合答案</span></span><br><span class="line">                R = mid<span class="number">-1</span>; <span class="comment">//由於我們的邊界是 [L,R]，因此 R-1</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> L = mid+<span class="number">1</span>; <span class="comment">//由於我們的邊界是 [L,R]，因此 L+1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>設計解題</tag>
        <tag>程式解題</tag>
        <tag>Binary Search 二分搜尋</tag>
      </tags>
  </entry>
  <entry>
    <title>演算法知識 - 動態規劃 Dynamic programming</title>
    <url>/2021/07/21/Explain_Algorithm/dynamic_programming/</url>
    <content><![CDATA[<h2 id="動態規劃-Dynamic-programming-介紹"><a href="#動態規劃-Dynamic-programming-介紹" class="headerlink" title="動態規劃 Dynamic programming 介紹"></a>動態規劃 Dynamic programming 介紹</h2><blockquote>
<p>動態規劃用在需要狀態轉移的題目上，例如說 \(y = 2x+1\)，那麼在計算出 y 之前就必須要有 x，否則 y 沒有辦法產生一個自然數。</p>
<p>動態規劃最好的理解方式就是，我們將某些變數的所有可能都列舉出來，並根據我們之前的紀錄，並透過遞迴關係式找出答案。<br>舉例：\(y = 2x+1\)，我們可以將產生出來的 y，再帶入 x，想請問 y 等於 15 有幾種組合可以產生。</p>
<ul>
<li>遞迴關係式就是 \(y = 2x+1\)</li>
<li>我們可以設定一個陣列 <code>dp[x(0~15)] = x 組合的數量</code></li>
<li>現在我們可以做一個迴圈如下</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for(int i &#x3D; 0; i &lt;&#x3D; 15; i++)&#123;</span><br><span class="line">    dp[2*i+1] &#x3D; dp[i] + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>你跟我說這很像遞迴？對！他就是遞迴的有效率版，浪費記憶體版XD。</li>
</ul>
<p>下面我們來聊聊一些常用的 dp 問題</p>
</blockquote>
<a id="more"></a>

<h2 id="01-背包問題-Knapsack-Problem"><a href="#01-背包問題-Knapsack-Problem" class="headerlink" title="01 背包問題 Knapsack Problem"></a>01 背包問題 Knapsack Problem</h2><p>你是一個水果批發商，你的卡車容量最多只能載 G 箱，你有很多種水果，他們在市場的賣出價為 S、買入價為 F、並且我們的預算只有 C，我們的目標是期望所有水果賣出價最高、C 最低。</p>
<p>並且水果每種只能買一箱，因為我們批發的水果都是高級水果，人人搶著要。</p>
<h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>通常遇到這種問題，就是使用這種解法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">memset</span>(dp, INF, <span class="keyword">sizeof</span>(dp));</span><br><span class="line"><span class="built_in">memset</span>(dp[<span class="number">0</span>], <span class="number">0</span>, <span class="keyword">sizeof</span>(dp[<span class="number">0</span>])); <span class="comment">//車子是 0 貨箱時，一定沒辦法買水果，因此最低價都是 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= 每種水果; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= 卡車容量; j++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= 預算; k++)&#123;</span><br><span class="line">            <span class="comment">//主要是我們假設卡車容量有 1~G，</span></span><br><span class="line">            <span class="comment">//總預算有 1~n </span></span><br><span class="line">            <span class="comment">//我們透過紀錄，在卡車容量是 G-1 的情況，卡車現在預算 - 這種水果預算時，</span></span><br><span class="line">            <span class="comment">//有沒有比現在的 dp[卡車容量][預算] 來得小，有就替換</span></span><br><span class="line">            dp[j][k] = min(dp[j][k], dp[j<span class="number">-1</span>][cost - 水果買入價] + 水果賣出價 )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//想要找到最高的預算就是</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; dp[卡車容量][預算];</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>演算法知識</category>
      </categories>
      <tags>
        <tag>程式解題</tag>
        <tag>演算法知識</tag>
        <tag>動態規劃 Dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa11566 - Let’s Yum Cha!(背包問題、動態規劃)</title>
    <url>/2021/07/20/UVa/UVa11566/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>一群好朋友要去吃港式飲茶，朋友們說好要一起出錢，同時不希望一樣的菜色出現兩次、或是一個人叫兩次以上的點心，看起來很膩，吃不到別的東西。<br>於是朋友們對每一樣菜列出了自己的喜愛程度，然後交由你來負責點菜，你需要滿足他們的<strong>平均最大喜愛程度</strong><br>其中有 N 位朋友、每位朋友的預算為 x，有 K 個點心，入場費用是 T，並加收 10%  服務費(點心價+入場費)，就靠你幫忙算出拉</p>
<p><a href="https://onlinejudge.org/external/115/11566.pdf" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li>能看得下那麼長的英文</li>
<li>使用 0,1 背包問題</li>
<li>花點巧思解決每盤不能點兩遍以上、一個人叫兩次以上的點心</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ul>
<li>我們理所當然地了解到這是一個背包問題，選擇喜愛程度的點心並降低預算</li>
<li>\(n+1\)，題目只有說到朋友有 n 個，但自己也會去吃所以是 \(n+1\)</li>
<li>注意 budget 計算<ul>
<li>不可以使用 \(n<em>x * 0.1\) 作為服務費<br>原因是因為服務費是根據我們的 x 再加一成，因此公式應該為 \(x + 0.1x\)，與 \(n</em>x * 0.1\) 邏輯不符合。</li>
<li>公式 \(x + 0.1x = 1.1x, x / 1.1 = 總預算\)<br>我們的點心總費用必須再加上一層服務費，因此 \(1.1x\) 就是我們的總預算。</li>
</ul>
</li>
<li>那我們要處理的背包問題如下<ul>
<li>我們必須將每位朋友的這種點心的喜愛程度加總，並算出價錢。<br>使用迴圈解決</li>
<li>每個菜色最多只能有兩盤<br>我們可以讓每個種類的點心都複製一份，也就是說我們可以把每種點心放兩次到展示櫃中，這樣我們就解決 0,1 背包問題只能夠選擇拿或不拿。</li>
<li>每個人最多只能點兩份<br>我們可以假設背包最多只能放 \(2n\)，就可以解決 0,1 背包中的個數問題。</li>
<li>如何找到<strong>平均最大喜愛程度</strong><br>我們透過 <code>max(dp[0 ~ 2*N ][總預算])</code> 即可找出答案。 </li>
</ul>
</li>
<li>注意 Udebug 中第二個測資是錯誤的，請不要使用</li>
</ul>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://hackmd.io/@txya900619/Uva11566" target="_blank" rel="noopener">Uva11566 - Let’s Yum Cha! by txya900619</a><br><a href="https://www.pinghenotes.com/UVa-11566-Let-s-Yum-Cha/" target="_blank" rel="noopener">Uva11566 - Let’s Yum Cha! by pinghenotes</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>首先我要先讚嘆各位能夠看完那麼長的英文，太佩服你們了，我自己看到一半就看不太下去了…。幾乎快要是看一點英文、做點別的事，這樣才好不容易把他看完…。</p>
<p>看來我的英文閱讀耐力是真的爛阿QQ。</p>
<p>在來就是太久沒有寫背包問題，很多演算法太久沒有用真的會忘記阿QQ，但其實都會有印象，只要看一下公式馬上就能夠想出來原理是甚麼，只是還需要看一下，感覺自己好沒用RRRR，沒辦法靠自己喚醒這個公式，需要答案幫忙QQQ。</p>
<p>總之希望我可以透過這個公式幫上自己未來的忙拉</p>
<p>還有就是希望好心人可以幫我解決為甚麼使用我的方式計算 budget，會是 WA QQ。真的很需要拜託了！</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="comment">//#define DEBUG</span></span><br><span class="line"><span class="comment">//#define int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100020</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, x, t, k;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">12</span>*<span class="number">2</span>][<span class="number">12</span>*<span class="number">100</span>];</span><br><span class="line"><span class="comment">//點心的展示櫃</span></span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; item; <span class="comment">//price value </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="comment">//freopen("out.txt", "w", stdout);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; x &gt;&gt; t &gt;&gt; k &amp;&amp; n)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">        item.clear();</span><br><span class="line"></span><br><span class="line">        n++; <span class="comment">//include me 自己也會去吃</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//UVa AC 作法，解決小數點精度問題。</span></span><br><span class="line">        <span class="comment">//其中需要 (float) 1.1 是因為在 double 時小數點較多，容易導致精度不準確，</span></span><br><span class="line">        <span class="comment">//1.1 我們只需要最多一個小數點即可，避免精度不精因此使用 float</span></span><br><span class="line">        <span class="comment">//budget = 總預算 / (服務費 + 總花費) - 茶費</span></span><br><span class="line">        <span class="keyword">int</span> budget = (n * x) / (<span class="keyword">float</span>) <span class="number">1.1</span> - (n * t);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)&#123; <span class="comment">//計算每一個點心價格與所有朋友的喜愛程度總和</span></span><br><span class="line">            <span class="keyword">int</span> value=<span class="number">0</span>, sum=<span class="number">0</span>, price;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; price;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; value;</span><br><span class="line">                sum += value;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//展示櫃直接放兩個，解決 0,1 背包問題</span></span><br><span class="line">            item.push_back(make_pair(price, sum));</span><br><span class="line">            item.push_back(make_pair(price, sum)); <span class="comment">// 2(n+1)</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; item.size(); i++)&#123; <span class="comment">//展示櫃裡的東西選擇拿或不拿</span></span><br><span class="line">            <span class="keyword">int</span> price = item[i].first;</span><br><span class="line">            <span class="keyword">int</span> value = item[i].second;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = n*<span class="number">2</span>; j &gt; <span class="number">0</span>; j--)&#123; <span class="comment">//最多只能點 n*2點心</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = budget; k &gt;= price; k--)&#123; <span class="comment">//dp 0,1 背包問題</span></span><br><span class="line">                    <span class="comment">//判斷增加這個點心，會不會帶來更大的朋友喜愛程度</span></span><br><span class="line">                    dp[j][k] = max(dp[j][k], dp[j<span class="number">-1</span>][k-price] + value);</span><br><span class="line">                    <span class="comment">//不增加會不會比較好 </span></span><br><span class="line">                    dp[j][k] = max(dp[j][k], dp[j<span class="number">-1</span>][k]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//找出最好的答案</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n*<span class="number">2</span>; i++) ans = max(ans, dp[i][budget]);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; setprecision(<span class="number">2</span>) &lt;&lt; fixed &lt;&lt; (<span class="keyword">double</span>) ans / n &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>背包問題 Knapsack Problem</tag>
        <tag>動態規劃 Dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa11832 - Account Book(動態規劃 Dynamic programming)</title>
    <url>/2021/07/19/UVa/UVa11832/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>打擊腐敗基金會要對 Nlogonia 非法組織做審查，但基金會收到帳本後卻發現帳本並沒有表示交易紀錄是收入還是支出，只剩下數字、結餘多少。<br>於是我們希望可以透過程式還原每項明細，他是收入還是支出。</p>
<p>如果此結餘跟所有明細都對不上就輸出 <code>*</code><br>如果這筆明細確認是收入就輸出 <code>+</code><br>如果這筆明細確認是費用就輸出 <code>-</code><br>如果這筆明細無法確認就輸出 <code>?</code></p>
<p><a href="https://onlinejudge.org/external/118/11832.pdf" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li><a href="https://theriseofdavid.github.io/2021/07/21/Explain_Algorithm/dynamic_programming/" target="_blank" rel="noopener">動態規劃 - 大衛的筆記</a></li>
<li>紀錄每一種明細組合的資訊</li>
<li>當明細組合與其他明細組合相同時，要如何合併</li>
<li>使用動態規劃？還是有辦法貪心嗎？</li>
<li>有負數的動態規劃要怎麼樣建立陣列？</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>好題一題，讓我學了很多東西XD</p>
<ul>
<li>我們可以確定一件事，我們必須追蹤每一個明細在不同組合時的狀態。</li>
<li>使用貪心？使用動態規劃？<ul>
<li>貪心<ul>
<li>\(40!= 8.1591528e+47\)，一看就知道不可能</li>
<li>遇到結餘有多種組合時不容易處理。</li>
</ul>
</li>
<li>動態規劃<ul>
<li>透過陣列與二進位表達，來結合多種組合</li>
<li>無法確認的狀態就是這筆明細設定為支出時，也可以透過與其他明細組合，變成結餘的數字<br>怎麼解決這個問題，我們可以用兩個 DP 陣列(紀錄正、紀錄負)來解決</li>
<li>看起來動態規劃是比較好的方法</li>
</ul>
</li>
</ul>
</li>
<li>動態規劃要處理的問題<ul>
<li>題目的明細有可能是支出，那假如結餘是負數，我的動態規劃 index 不可以是負數<br>題目有說明細最大值是 1000，最多 40 筆，因此我們可以設定 dp 長度為 \(40 * 1000 * 2 = 80000\)，為了保險起見，建議可以開 100000，並以 index 50000 作為結餘 0 的標準，方便邏輯思考</li>
<li>因為我們已經開了一個很大的 dp 陣列，如果我們開一個 <code>dp[明細數量][結餘]</code>，會爆炸，那要怎麼辦<br>我們可以了解到，其實我們的 dp 都是根據到<code>dp[上一個明細數量][結餘]</code> 延續的，因為我們<strong>每一個名係數都會使用到，只是決定正或負</strong></li>
<li>那我要怎麼在 dp 內存放每筆交易的收入或支出呢？<br>透過 2 進位表示，<code>110(2)</code>，表示第二筆第三筆是正的。以此類推</li>
<li>第三點只有提到交易為收入的表達，那支出呢？<br>沒辦法，開兩個 dp，分別存放收入交易、支出交易</li>
<li>其他的概念就與 dp 相同，直接看程式碼表達就好。</li>
</ul>
</li>
<li>提醒，在使用 2 進位表達時，必須開 long long，因為 \(n=40\)，會過大。</li>
<li>一開始必須先將第一筆交易紀錄先額外寫入 dp，不可以讓 <code>dp[上一個明細數量][0] = 1</code>，因為 f 可以是 0。</li>
<li>動態規劃邏輯關係表達如下<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> L = 累積交易明細都是支出的結餘</span><br><span class="line"><span class="keyword">int</span> R = 累積交易明細都是收入的結餘</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(交易明細)&#123;</span><br><span class="line">    <span class="keyword">for</span>(L~R)&#123; <span class="comment">//加速搜尋，以避免需要 0~100000 大量 for</span></span><br><span class="line">        <span class="keyword">if</span>(收入交易[上一個交易][結餘] || 支出交易[上一個交易][結餘])&#123;</span><br><span class="line">            收入交易[這一個交易][結餘 + 正交易明細] |=  收入交易[上一個交易][結餘] + 正交易明細</span><br><span class="line">            支出交易[這一個交易][結餘 + 正交易明細] |=  收入交易[上一個交易][結餘] </span><br><span class="line">            收入交易[這一個交易][結餘 + 負交易明細] |=  收入交易[上一個交易][結餘] </span><br><span class="line">            支出交易[這一個交易][結餘 + 負交易明細] |=  收入交易[上一個交易][結餘] + 負交易明細</span><br><span class="line"></span><br><span class="line">            <span class="comment">//也就是說當你想看某個結餘時，你必須同時看支出交易、收入交易。</span></span><br><span class="line">            <span class="comment">//支出交易負責 支出明細</span></span><br><span class="line">            <span class="comment">//收入交易負責 收入明細</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//注意必須要是 |=，因為如果剛好另種組合也等於結餘時，必須兩種狀態都保存，所以是 or</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://hackmd.io/@txya900619/Uva11832" target="_blank" rel="noopener">Uva11832 - Account Book by txya900619</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>這題很不賴欸，開導了我很多東西，很多是我自己沒有學過的一些小伎倆，透過這題來讓自己收穫許多。</p>
<p>並且也了解到有時候並不需要把所有的交易紀錄資訊都放在同個陣列裡，那樣會很難處理。分開來會好很多，只是我不知道當我遇到這種題目時，我有沒有辦法把這些想法都套用在題目上。</p>
<p>希望我都可以套用在題目上，有機會套用在未來上。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="comment">//#define DEBUG</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1020</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, f, t;</span><br><span class="line"><span class="keyword">int</span> add[<span class="number">2</span>][<span class="number">100000</span>]; <span class="comment">//收入交易</span></span><br><span class="line"><span class="keyword">int</span> subtract[<span class="number">2</span>][<span class="number">100000</span>]; <span class="comment">//支出交易</span></span><br><span class="line"><span class="keyword">int</span> num[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"out.txt"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; f &amp;&amp; n)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(add, <span class="number">0</span>, <span class="keyword">sizeof</span>(add));</span><br><span class="line">        <span class="built_in">memset</span>(subtract, <span class="number">0</span>, <span class="keyword">sizeof</span>(subtract));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">cin</span> &gt;&gt; num[i];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//roll 只會以 0,1 兩種型態存活，當 roll = 0，那 1 就是當前交易，0 為上一筆，反之亦同</span></span><br><span class="line">        <span class="keyword">int</span> L=<span class="number">50000</span>-num[<span class="number">0</span>], R=<span class="number">50000</span>+num[<span class="number">0</span>], roll = <span class="number">0</span>; </span><br><span class="line">        add[<span class="number">0</span>][R] = <span class="number">1</span>; <span class="comment">//分析第五點</span></span><br><span class="line">        subtract[<span class="number">0</span>][L] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123; <span class="comment">//分析第六點</span></span><br><span class="line">            <span class="built_in">memset</span>(add[!roll], <span class="number">0</span>, <span class="keyword">sizeof</span>(add[!roll]));</span><br><span class="line">            <span class="built_in">memset</span>(subtract[!roll], <span class="number">0</span>, <span class="keyword">sizeof</span>(subtract[!roll]));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = L; j &lt;= R; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(add[roll][j] || subtract[roll][j])&#123;</span><br><span class="line">                    <span class="keyword">int</span> add_value = j + num[i];</span><br><span class="line">                    add[!roll][add_value] |= add[roll][j] | (<span class="number">1L</span>L &lt;&lt; i);</span><br><span class="line">                    subtract[!roll][add_value] |= subtract[roll][j];</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">int</span> subtract_value = j - num[i];</span><br><span class="line">                    add[!roll][subtract_value] |= add[roll][j];</span><br><span class="line">                    subtract[!roll][subtract_value] |= subtract[roll][j] | (<span class="number">1L</span>L &lt;&lt; i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            L -= num[i]; <span class="comment">//區間修改，因為最低結餘與最高結餘的上下限改變了</span></span><br><span class="line">            R += num[i];</span><br><span class="line">            roll = !roll; <span class="comment">//roll 修改，上上一筆明細已經被延續，現在是需要當前明細</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//cout &lt;&lt; "roll " &lt;&lt; roll &lt;&lt; '\n';</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = L<span class="number">-50000</span>; i &lt;= R<span class="number">-50000</span>; i++) <span class="built_in">printf</span>(<span class="string">"%3d "</span>, i);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = L; i &lt;= R; i++) <span class="built_in">printf</span>(<span class="string">"%3d "</span>, add[roll][i]);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//debug</span></span></span><br><span class="line"></span><br><span class="line">        f += <span class="number">50000</span>; <span class="comment">//因為我們一開始就加了 50000</span></span><br><span class="line">        <span class="comment">//此結餘跟所有交易中的結餘都沒有任何明細紀錄</span></span><br><span class="line">        <span class="keyword">if</span>(add[roll][f] == <span class="number">0</span> &amp;&amp; subtract[roll][f] == <span class="number">0</span>)&#123; </span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"*"</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> item = <span class="number">1L</span>L &lt;&lt; i; <span class="comment">//2進位筆達</span></span><br><span class="line">            <span class="keyword">if</span>(add[roll][f] &amp; item)&#123; <span class="comment">//收入紀錄</span></span><br><span class="line">                <span class="keyword">if</span>(subtract[roll][f] &amp; item) <span class="built_in">cout</span> &lt;&lt; <span class="string">"?"</span>; <span class="comment">//收入跟支出都有此紀錄</span></span><br><span class="line">                <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"+"</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(subtract[roll][f] &amp; item) <span class="built_in">cout</span> &lt;&lt; <span class="string">"-"</span>; <span class="comment">//支出紀錄</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>動態規劃 Dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa12640 - Largest Sum Game(貪心)</title>
    <url>/2021/07/19/UVa/UVa12640/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>有一群人他們在玩 Largest Sum Game，主要就是在一個數列內要找出一個區間的總和最大，並輸出總和最大的數字。</p>
<p><a href="https://onlinejudge.org/external/126/12640.pdf" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li><a href="https://theriseofdavid.github.io/2021/07/21/Explain_Algorithm/dynamic_programming/" target="_blank" rel="noopener">動態規劃 - 大衛的筆記</a></li>
<li><a href="https://stackoverflow.com/questions/3292107/whats-the-difference-between-istringstream-ostringstream-and-stringstream-w" target="_blank" rel="noopener">stringstream 的使用，請點擊此連結查看教學</a></li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ul>
<li>基本上沒什麼好分析的XD</li>
<li>主要是我們從數列第一個開始，不斷累加，定義變數為 <code>sum</code><ul>
<li><code>sum + 數列第 i 值</code>，不斷讓區間變更大</li>
<li><code>if(sum &lt; 0) sum = 0</code>，由於前面的區塊總和已經是負，因此捨棄前面的區間<br>舉例：當 y,x 都是正數時，\(-y+x\) 不會比 \(x\) 大</li>
<li><code>if(sum &gt; 0) comtinue</code>，由於前面的區塊總和已經是正，因此保留前面的區間會讓數字總和更大<br>舉例：當 y,x 都是正數時，\(y+x\) 會比 \(x\) 大</li>
</ul>
</li>
<li>再來就是對每個數列時做 <code>ans = max(ans, sum)</code>，找到最大的 ans 就是答案</li>
</ul>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://hackmd.io/@txya900619/Uva12640" target="_blank" rel="noopener">Uva12640 - Largest Sum Game by txya900619</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>水題XD，應該大家都會拉。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="comment">//#define DEBUG</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100020</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, temp;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; num;<span class="comment">//debug 用數列</span></span><br><span class="line"><span class="built_in">string</span> q;</span><br><span class="line"><span class="comment">// istringstream insert ostringstream output</span></span><br><span class="line"><span class="comment">//https://stackoverflow.com/questions/3292107/whats-the-difference-between-istringstream-ostringstream-and-stringstream-w</span></span><br><span class="line"><span class="built_in">stringstream</span> ss;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">while</span>(getline(<span class="built_in">cin</span>, q))&#123;</span><br><span class="line">        ss.clear(); ss.str(<span class="string">""</span>);</span><br><span class="line">        ss &lt;&lt; q; <span class="comment">//將數列字串放入 stringstream</span></span><br><span class="line">        num.clear();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>, max_sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            ss &gt;&gt; temp;</span><br><span class="line">            <span class="comment">//stringstream.fail() 如果剛剛沒有傳任何資料到變數就是 yes</span></span><br><span class="line">            <span class="keyword">if</span>(ss.fail()) <span class="keyword">break</span>; </span><br><span class="line">            num.push_back(temp); <span class="comment">//debug 用</span></span><br><span class="line"></span><br><span class="line">            sum += temp; <span class="comment">//不斷加入數列 i 值</span></span><br><span class="line">            <span class="keyword">if</span>(sum &lt; <span class="number">0</span>) sum = <span class="number">0</span>; <span class="comment">//捨棄前面區間</span></span><br><span class="line">            max_sum = max(sum, max_sum); <span class="comment">//看看現在區間，與 ans 誰比較大</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; max_sum &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">        <span class="comment">//cout &lt;&lt; num.size() &lt;&lt; '\n';</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num.size(); i++) <span class="built_in">cout</span> &lt;&lt; num[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// DEBUG</span></span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa13095 - Tobby and Query(貪心、動態規劃)</title>
    <url>/2021/07/19/UVa/UVa13095/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>Tobby and Query 對一些事情很感興趣，Tobby 對一些問題很有興趣<br>題目會給你一組數列，其中數列的數字只會是 0~9，之後會給你一個區間 <code>[l,r]</code>，想問妳這裡面有幾個不重複的數字</p>
<p><a href="https://onlinejudge.org/external/130/13095.pdf" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li>使用動態規劃</li>
<li>題目的數字只有 10 個，是不是可以用些笨拙的方法快速解決這題？</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ul>
<li>應該會有些人像我一樣，第一個想法是使用 set or segment tree 嗎?<ul>
<li>使用 set 不好，我們只能夠確認區間裡面有那些數字，在大量查詢時沒辦法</li>
<li>使用 Segment tree 呢？在判斷左子樹、右子樹 <code>[l,r]</code> 有哪些數字時會比較難處理些</li>
</ul>
</li>
<li>動態規劃<ul>
<li>我們可以發現題目的數列是不需要修改的，也就是我們只要做到區間查詢就好，不需要做到區間修改。    </li>
<li>此時動態規劃就很適合我們解決此問題，先算出 <code>[0,0~r]</code> 中有哪些數字、有幾個，之後透過<strong>區間相減</strong>的方式來進行區間查詢</li>
<li>注意：區間查詢不能用在需要<strong>區間修改</strong>的問題</li>
</ul>
</li>
</ul>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://github.com/morris821028/UVa/blob/master/volume130/13095%20-%20Tobby%20and%20Query.cpp" target="_blank" rel="noopener">Uva11264 - Coin Collector by morris821028</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>嗚嗚，我處理這種問題還是需要再聰明點，雖然一開始就想到區間查詢 =&gt; Segment tree，確定後再試著找一些網路上的詳解，驗證我的答案是不是對的XD。</p>
<p>看來我想得不夠乾淨，理應可以把題目變得更簡單。<br>能夠盡量把題目變得更簡單，就應該要變得簡單，我還要在訓練這方面的思考。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100020</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, q, l, r, idx; <span class="comment">//var index error =&gt; https://blog.csdn.net/cyril_ki/article/details/109668100</span></span><br><span class="line"><span class="keyword">int</span> a[MAXN][<span class="number">12</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"out.txt"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123; <span class="comment">//輸入資料</span></span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; idx;</span><br><span class="line">            a[i][idx]++;</span><br><span class="line">            <span class="comment">//狀態轉移，區間 [0,i-1] =&gt; [0,i]</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) a[i][j] += a[i<span class="number">-1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; q; i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r;</span><br><span class="line">            <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)&#123;</span><br><span class="line">                <span class="comment">//如果區間 [0,r] - [0,l) = [l,r] 裡面如果有 0~9 就 ans +1</span></span><br><span class="line">                <span class="keyword">if</span>(a[r][j] - a[l<span class="number">-1</span>][j] &gt; <span class="number">0</span>) ans++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>動態規劃 Dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa10534 - Wavio Sequence(LIS, 動態規劃)</title>
    <url>/2021/07/24/UVa/UVa10534/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>我們定義 Wavio Sequence</p>
<ul>
<li>長度必須是 \(2 * n + 1\)</li>
<li>前 \(n+1\) 個數字必須遞增</li>
<li>後 \(n+1\) 個數字必須遞減<br>接下來會給你一個數列，請你在這些數字中找出 <strong>最長 Wavio Sequence</strong></li>
</ul>
<p><a href="https://onlinejudge.org/external/105/10534.pdf" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li><a href="https://theriseofdavid.github.io/2020/11/13/Explain_Algorithm/LIS/" target="_blank" rel="noopener">LIS 的應用</a></li>
<li>將每一個 index 的 LIS 長度都記錄下來</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ul>
<li>Wavio Sequence 可以看成前半段是 LIS、後半段是 LDS(最長遞減子序列)</li>
<li>那我們可以從左至右、從右至左各做一次 LIS，並且用兩個陣列紀錄每個數列位置的最長 LIS、LDS 長度<br>注意：從右至左做一次 LIS，就是從左至右做一次 LDS</li>
<li>找出在同個數列 index 下中 \(min(LIS,LDS) * 2 + 1\)，即可。</li>
<li>有些小細節，我在程式裡說明</li>
</ul>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://hackmd.io/@txya900619/Uva10534" target="_blank" rel="noopener">Uva10534 - Wavio Sequence by txya900619</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>LIS 很多小細節處理其實我也沒有學得很精，希望自己可以好好學習好。注意這些問題，加強自己的思考能力。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 10020</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, temp;</span><br><span class="line"><span class="comment">//num 題目數列, lis_index 最長的 LIS 長度，lds 也是</span></span><br><span class="line"><span class="keyword">int</span> num[MAXN], lis_index[MAXN], lds_index[MAXN]; </span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; lis, lds;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"out.txt"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n)&#123;</span><br><span class="line">        lis.clear(); lds.clear();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">cin</span> &gt;&gt; num[i];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//LIS</span></span><br><span class="line">        lis.push_back(num[<span class="number">0</span>]);</span><br><span class="line">        lis_index[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num[i] &gt; lis.back())&#123;</span><br><span class="line">                <span class="comment">//要稍微注意，因為我們 LIS 下方的 else 在輸入 lis_index[i] 是會根據 deque.size()，</span></span><br><span class="line">                <span class="comment">//但 deque.size() 從 0 開始計數，所以我們這邊的 lis_index[i] 也從 0 開始計數，</span></span><br><span class="line">                <span class="comment">//因此當 lis_index[i] = 0，都內含自己。</span></span><br><span class="line">                lis_index[i] = lis.size(); <span class="comment">//be careful, lower_bound =&gt; deque.size(). NOT LIS length</span></span><br><span class="line">                lis.push_back(num[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//大衛的筆記是用 upper_bound，是因為那篇實作 LIS 是大於等於都可以，但這裡僅限大於</span></span><br><span class="line">                temp = lower_bound(lis.begin(), lis.end(), num[i]) - lis.begin();</span><br><span class="line">                lis [temp] = num[i];</span><br><span class="line">                lis_index[i] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//LDS，解釋與上方相同</span></span><br><span class="line">        lds.push_back(num[n<span class="number">-1</span>]);</span><br><span class="line">        lds_index[n<span class="number">-1</span>] = <span class="number">0</span>; <span class="comment">//要先歸為零，不然會跟其他測資混亂。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-2</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num[i] &gt; lds.back())&#123;</span><br><span class="line">                lds_index[i] = lds.size();</span><br><span class="line">                lds.push_back(num[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                temp = lower_bound(lds.begin(), lds.end(), num[i]) - lds.begin();</span><br><span class="line">                lds[temp] = num[i];</span><br><span class="line">                lds_index[i] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; "i lis lds " &lt;&lt; i &lt;&lt; " " &lt;&lt; lis_index[i] &lt;&lt; " " &lt;&lt; lds_index[i] &lt;&lt; "\n";</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//由於 Wavio Sequence 必須左右長度都是 n+1, 因此我們就以 i 為單位，</span></span><br><span class="line">            <span class="comment">//使用最小的 LIS or LSD 長度，</span></span><br><span class="line">            <span class="comment">//但由於我們計數都是從 0 開始，別忘了 + 1(自己)</span></span><br><span class="line">            <span class="comment">//+1 原因，我們是以 num[i] 為中心算最長長度，因此重複用到一次。</span></span><br><span class="line">            <span class="comment">//但因為我們計數都是從 0 開始，所以從 (2*n)-1 改為 (2*n)+1</span></span><br><span class="line">            ans = max(ans, min(lis_index[i], lds_index[i]) * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>最長遞增子序列 Longest Increasing Subsequence</tag>
        <tag>動態規劃 Dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa10534 - Murcia’s Skyline(LIS, 動態規劃)</title>
    <url>/2021/07/24/UVa/UVa11790/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>摩天大樓一座有一座的蓋起，這時候許多摩天大樓在一起時會有一條天際線。<br>摩天大樓有不同的寬度、高度，我們想要找出 LIS 並且寬度要是最長的、LDS 並且寬度要是最長的</p>
<p><a href="https://onlinejudge.org/external/117/11790.pdf" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li><a href="https://theriseofdavid.github.io/2020/11/13/Explain_Algorithm/LIS/#LIS-實作與說明，時間複雜度-O-n-2" target="_blank" rel="noopener">了解甚麼時候使用時間複雜度 \(O(n^2)\) 的 LIS</a></li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ul>
<li>由於這題的 LIS 數值權重並非都相同，因此只能使用 \(O(n^2)\) 版</li>
<li>做一次 LIS 與 LDS，並找出最大值即可。</li>
</ul>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://hackmd.io/@txya900619/Uva11790" target="_blank" rel="noopener">Uva11790 - Murcia’s Skyline by txya900619</a><br><a href="http://web.ntnu.edu.tw/~algo/Subsequence.html" target="_blank" rel="noopener">http://web.ntnu.edu.tw/~algo/Subsequence.html</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>老實講，我其實已經太久沒有寫過 LIS 時間複雜度 \(O(n^2)\) 的版本了，都快忘記了…。<br>有時候演算法沒有到非常熟，忘了真的很難憑自己的記憶在馬上推出來，但是可以透過查看自己的筆記就可以馬上想出來。</p>
<p>還真希望我隨時都可以想到這些筆記XD。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1000020</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> t, n, kase = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> height[MAXN], width[MAXN];</span><br><span class="line"><span class="keyword">int</span> lis[MAXN], lds[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"out.txt"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="comment">//做動態規劃前，一定要先將陣列歸 0，才不會讓陣列裡面混入前面的資料</span></span><br><span class="line">        <span class="built_in">memset</span>(lis, <span class="number">0</span>, <span class="keyword">sizeof</span>(lis)); </span><br><span class="line">        <span class="built_in">memset</span>(lds, <span class="number">0</span>, <span class="keyword">sizeof</span>(lds));</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">cin</span> &gt;&gt; height[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">cin</span> &gt;&gt; width[i];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//LIS 應用</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            lis[i] = width[i];</span><br><span class="line">            lds[i] = width[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(height[i] &gt; height[j]) lis[i] = max(lis[i], lis[j] + width[i]);</span><br><span class="line">                <span class="keyword">if</span>(height[i] &lt; height[j]) lds[i] = max(lds[i], lds[j] + width[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//找出最大 lis, lds</span></span><br><span class="line">        <span class="keyword">int</span> ans_lis = <span class="number">0</span>, ans_lds = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            ans_lis = max(ans_lis, lis[i]);</span><br><span class="line">            ans_lds = max(ans_lds, lds[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//題目要求，當 LIS 大時有其輸出格式、LDS 也是</span></span><br><span class="line">        <span class="keyword">if</span>(ans_lis &gt;= ans_lds)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Case "</span> &lt;&lt; ++kase &lt;&lt; <span class="string">". Increasing ("</span> &lt;&lt; ans_lis &lt;&lt; <span class="string">"). Decreasing ("</span> &lt;&lt; ans_lds &lt;&lt; <span class="string">").\n"</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Case "</span> &lt;&lt; ++kase &lt;&lt; <span class="string">". Decreasing ("</span> &lt;&lt; ans_lds &lt;&lt; <span class="string">"). Increasing ("</span> &lt;&lt; ans_lis &lt;&lt; <span class="string">").\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>最長遞增子序列 Longest Increasing Subsequence</tag>
        <tag>動態規劃 Dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa10448 - Unique World(動態規劃)</title>
    <url>/2021/07/26/UVa/UVa10448/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>獨特世界裡面的人開車非常特別，他們從任意一個點出發到另外一個點的成本都是唯一無二的且只有一種走法，因此獨特世界只要看到成本就可以知道這是從 A 到 B 的車票，但獨特世界裡面突然發現了一個大問題，他們發現只要你願意繞路就可以讓任意一個點出發到另外一個點的成本竟然可以有多種解法，且成本不一致！<br>因此總統下令</p>
<ul>
<li>每一條路徑可以重複走，只有終點與前一個點的路徑只能走一遍</li>
<li>不可以走非必要路徑</li>
<li>必須讓開車成本符合總統要求的成本</li>
</ul>
<p>如果可以就輸出 yes、最小使用道路數量，no 表示不行<br>好了，現在需要一個程式設計師來解決問題了！<br><strong>注意，每一個 test case 中間要有斷行</strong></p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li>看得懂題目，這題題目也太難看懂了…</li>
<li>了解 DFS、動態規劃</li>
<li>了解題目細節<br>題目非常多小機關，透過分析說明。</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ul>
<li>噁心，太噁心了…，把兩題結合成一題，又有一堆細節要處理..</li>
<li>定義名詞<ul>
<li>require_cost 政府要求的 cost</li>
</ul>
</li>
<li>首先我們從題目中知道，每個節點都有一個獨特路徑。因此必須先走一次 <strong>DFS</strong>，找到最好的解法。並且判斷一些問題<ul>
<li>我們必須要確定 A 到 B 有連通</li>
<li>require_cost 要減掉所有經過路線的 cost</li>
<li>紀錄所有路徑的成本</li>
</ul>
</li>
<li>DFS 後，我們接下來會發現一些問題<ul>
<li><code>require_cost &lt; 0</code>，解不出來</li>
<li><code>require_cost == 0</code>，完美，直接輸出 dfs 路徑的數量</li>
<li>如果有 <code>require_cost &gt; 0</code> 那怎麼辦?<ul>
<li>可以轉化成動態規劃，我們來判斷我們要重複走幾次必要路徑，才能讓  <code>require_cost == 0</code></li>
<li>概念如下：有 <code>require_cost</code>，我們最少用幾個 cost 讓 <code>require_cost == 0</code></li>
</ul>
</li>
</ul>
</li>
<li>動態規劃，一樣有一些問題要注意<ul>
<li>必須先將 <code>require_cost / 2</code>，因為多走一步就必須在退回一步</li>
<li>因此我們可以得知，當 dfs 後的 require_cost 為奇數時，一定是 no，因為每一個路徑走過去又走回來一定是 \(路徑 * 2\)，不可能會有奇數</li>
<li>題目有說，終點與前一個點的路徑只能走一遍，因此我們要把終點與前一個點的 cost erase。</li>
<li>紀錄當問題求最小時，必須讓 dp 初始化時都是 INF。</li>
<li><code>DFS 的路徑數量 == 成本數量</code></li>
</ul>
</li>
</ul>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>天啊，這題太狠了….，這題目好多細節，DP 與 DFS 的融合，太可怕了…我學到好多東西。</p>
<p>老實講，這個其實還不賴，就是我在解決這題時思考的稍微有點久，也花了些時間先看懂別人如何寫的我再來自己試寫一遍。</p>
<p>然後那個 UVa 那個格式有時候真的很機車QQQ，不要這樣啦。<br>希望我到時候都能在寫其他題目時注意到這些細節</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="comment">//#define int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 60</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN_cost 100020</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> t, n, m, q;</span><br><span class="line"><span class="keyword">int</span> id1, id2, cost;</span><br><span class="line"><span class="keyword">int</span> from, to, require_cost;</span><br><span class="line"><span class="keyword">int</span> visit[MAXN];</span><br><span class="line"><span class="keyword">int</span> dp[MAXN][MAXN_cost];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> node, cost;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;edge&gt; road[MAXN]; </span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; travel_cost;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> root)</span></span>&#123;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; "root to " &lt;&lt; root &lt;&lt; ' ' &lt;&lt; to &lt;&lt; '\n';</span></span><br><span class="line">    <span class="keyword">if</span>(root == to) <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">if</span>(visit[root]) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//已被經過</span></span><br><span class="line"></span><br><span class="line">    visit[root] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; road[root].size(); i++)&#123; <span class="comment">//不斷嘗試尋找可能路徑</span></span><br><span class="line">        <span class="keyword">if</span>(dfs(road[root][i].node))&#123;</span><br><span class="line">            require_cost -= road[root][i].cost;</span><br><span class="line">            <span class="comment">//注意邏輯，這裡是越後面的 path 會放在 vector 前面</span></span><br><span class="line">            travel_cost.push_back(road[root][i].cost); </span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">coin_change</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(from == to) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//UVa debug 有這個測資，但 UVa online judge 沒用</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; "fron to require_cost " &lt;&lt; from &lt;&lt; ' ' &lt;&lt; to &lt;&lt; ' ' &lt;&lt; require_cost &lt;&lt; "\n";</span></span><br><span class="line">    <span class="keyword">int</span> connected = dfs(from); <span class="comment">//判斷是否有唯一路徑</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; "connected status " &lt;&lt; connected &lt;&lt; "\n";</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; "required cost " &lt;&lt; require_cost &lt;&lt; "\n";</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//if(connected == 0) return -1; 題目有說，一定有唯一路徑，因此不用判斷</span></span><br><span class="line">    <span class="keyword">if</span>(require_cost == <span class="number">0</span>) <span class="keyword">return</span> travel_cost.size(); <span class="comment">//分析第 4-2 點</span></span><br><span class="line">    <span class="keyword">if</span>(require_cost &lt; <span class="number">0</span> || require_cost % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//分析第 4-1、5-2 點</span></span><br><span class="line">    travel_cost.erase(travel_cost.begin()); <span class="comment">//分析 5-2 點</span></span><br><span class="line">    <span class="keyword">if</span>(travel_cost.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//如果沒有其他可重複路徑，但還有成本，那也解不出來</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//cout &lt;&lt; "start dp " &lt;&lt; '\n';</span></span><br><span class="line">    <span class="comment">//for(int i = 0; i &lt; travel_cost.size(); i++) cout &lt;&lt; travel_cost[i] &lt;&lt; ' ';</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; '\n';</span></span><br><span class="line">    require_cost /= <span class="number">2</span>; <span class="comment">//折半，走一步、退回一步</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">//dp 一開始初始化 dp[i][j], i = 使用的路徑、j = require_cost</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; travel_cost.size(); i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= require_cost; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j - travel_cost[i] &gt;= <span class="number">0</span>) dp[i][j] = min(dp[i][j], dp[i][j - travel_cost[i]]+<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//if(j - travel_cost[i] &gt;= 0) cout &lt;&lt; j &lt;&lt; " " &lt;&lt; dp[i][j] &lt;&lt; '\n';</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//狀態轉移</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span>) dp[i][j] = min(dp[i<span class="number">-1</span>][j], dp[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//cout &lt;&lt; "travel_cost.size()-1 " &lt;&lt; travel_cost.size()-1 &lt;&lt; '\n';</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; dp[travel_cost.size()-1][require_cost] &lt;&lt; ' ' &lt;&lt; INF &lt;&lt; '\n';</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果 requre_cost 有答案，就直接輸出，沒有就是 -1</span></span><br><span class="line">    <span class="keyword">if</span>(dp[travel_cost.size()<span class="number">-1</span>][require_cost] == INF) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//由於 dp 這邊是算來回走，</span></span><br><span class="line">    <span class="comment">//因此 DFS 路徑數量(路徑數量 == 成本數量) + dp * 2 + 終點與前一個點的路徑只能走一遍</span></span><br><span class="line">    <span class="keyword">return</span> travel_cost.size() + dp[travel_cost.size()<span class="number">-1</span>][require_cost] * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) road[i].clear(); <span class="comment">//路徑清空</span></span><br><span class="line">        <span class="comment">//放入路徑，為了效率， road[i][j]，i 為 node、j 為 node 的第幾個路徑</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123; </span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; id1 &gt;&gt; id2 &gt;&gt; cost;</span><br><span class="line">            road[id1].push_back(&#123;id2, cost&#125;);</span><br><span class="line">            road[id2].push_back(&#123;id1, cost&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; q; i++)&#123;</span><br><span class="line">            travel_cost.clear(); <span class="comment">//紀錄成本的 vector 刪除</span></span><br><span class="line">            <span class="built_in">memset</span>(visit, <span class="number">0</span>, <span class="keyword">sizeof</span>(visit)); <span class="comment">//初始 visit</span></span><br><span class="line">            <span class="built_in">memset</span>(dp, INF, <span class="keyword">sizeof</span>(dp)); <span class="comment">//初始 dp</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; from &gt;&gt; to &gt;&gt; require_cost;</span><br><span class="line">            <span class="keyword">int</span> ans = coin_change();</span><br><span class="line">            <span class="keyword">if</span>(ans == <span class="number">-1</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">"No"</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"Yes "</span> &lt;&lt; ans &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(t != <span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>; <span class="comment">//題目要求換行</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>動態規劃 Dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa11259 - Coin Changing Agains(動態規劃、排容原理)</title>
    <url>/2021/07/26/UVa/UVa11259/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>這個地方有四個硬幣，你必須用 4 個硬幣組合成 v 元，有 q 個查詢，且每個硬幣數量都會隨之 q 不同，想請問在每次的 q 查詢中所設定的硬幣數量內，最多有幾種組合方法</p>
<p><a href="https://onlinejudge.org/external/112/11259.pdf" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li>了解<a href="https://highscope.ch.ntu.edu.tw/wordpress/?p=12453" target="_blank" rel="noopener">排容原理</a></li>
<li>了解動態規劃</li>
<li>將他們結合應用起來</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ul>
<li>可以發現，普通的動態規劃沒有辦法解決這題，因為他的硬幣數量可能會來到 \(10^6\)</li>
<li>此時可以想想有沒有一些方法可以解決呢？<ul>
<li>貪心<br>似乎有點複雜</li>
<li>排容原理，如果我們先假設這是個無限背包問題，我們要處理一個問題<ul>
<li>使用的硬幣數量超過題目上限<ul>
<li>這時候我們可以透過一種方始解決，<code>dp[v 元] - dp[v 元 - coin[i] * (d[i]+1)]</code>，我們可以知道一件事，在 <code>coin[i] * d[i] 元</code> 中都可解出來</li>
<li>因此我們可以知道 <code>dp[v 元 - coin[i] * (d[i]+1)]</code>，就是不合法的</li>
<li>此時，可能會有個疑惑，那 <code>dp[v 元 - coin[i] * (d[i]+2)]</code> 我們就不用減嗎？</li>
<li>真的不用，因為 <code>dp[v 元 - coin[i] * (d[i]+1)]</code> 包含 <code>dp[v 元 - coin[i] * (d[i]+2)]</code></li>
<li>但注意，這邊一定要用 <code>dp[v 元 - coin[i] * (d[i]+1)]</code> 來做，不可用 <code>dp[coin[i] * (d[i]+1)]</code>，因為我們狀態是不斷往後加，如果我們只減掉一開始 dp 的非法的硬幣數量，那後面的非法的硬幣數量與其他組合我們都沒有處理掉</li>
</ul>
</li>
<li>注意，會有重複扣的問題<ul>
<li>可能會有一種組合是，<code>coin[i]、coin[j]</code> 都是非法數量，但因為上一點的邏輯而重複扣了兩遍，因此我們必須要給他加回來</li>
<li>可能會有一種組合是，<code>coin[i]、coin[j]、coin[k]</code> 都是非法數量，但因為上一點的邏輯(<code>coin[i]、coin[j]</code>)而加回來，因此我們必須要給他扣掉。</li>
<li>因此我們必須是扣掉 <code>-c[1]-c[2]+c[1]*c[2]....-c[1]*c[2]*c[3]*c[4]</code> 的非法數量</li>
<li>最後我們要判斷 v 在減掉這種非法數量時，v 是否還有大於零，因為 v 必須要大於 0 才表示這種非法組合有成立。</li>
<li>再來讓無限背包的<code>dp[v] - 非法數量</code>就是答案</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://blog.csdn.net/weixin_30416871/article/details/98992438" target="_blank" rel="noopener">UVA 11259 Coin Changing Again by weixin_30416871</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>一開始我認為這題應該可以用貪心 + dp 的方法解出來XD，後來發現確實有點太難了QQ，太久沒有寫到排容原理的題目，都忘記要這樣想了….</p>
<p>既然複習到了就讓自己未來在用到時可以順利想起來吧!</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100020</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"><span class="keyword">int</span> c[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> d[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> q, v;</span><br><span class="line"><span class="keyword">int</span> dp[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) <span class="built_in">cin</span> &gt;&gt; c[i];</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; q;</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123; <span class="comment">//無限背包問題</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = c[i]; j &lt; MAXN; j++)&#123; </span><br><span class="line">                dp[j] += dp[j - c[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) <span class="built_in">cin</span> &gt;&gt; d[i];</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; v;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//一共有 16 種組合每一種組合都可能有非法組合，每個硬筆拿或不拿，使用二進位表示</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">16</span><span class="number">-1</span>; i++)&#123; </span><br><span class="line">                <span class="comment">//flag 重複項現在的正負狀態，每有兩個重複項就補回多扣的非法數量</span></span><br><span class="line">                <span class="comment">//x 非法組合的最後的金額(元)是多少</span></span><br><span class="line">                <span class="keyword">int</span> x = v, flag = <span class="number">1</span>; </span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)&#123;<span class="comment">//這一種組合方式，有沒有使用 coin[j]</span></span><br><span class="line">                    <span class="keyword">if</span>(i &amp; (<span class="number">1</span> &lt;&lt; j))&#123; <span class="comment">//如果有</span></span><br><span class="line">                        flag = -flag; <span class="comment">//判斷現在是做補回多扣的非法數量，還是減去非法數量</span></span><br><span class="line">                        x -= c[j] * (d[j]+<span class="number">1</span>); <span class="comment">//x 減掉非法金額(元)</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果 x &gt; 0，標示這種非法數量存在，進行刪減或補回</span></span><br><span class="line">                <span class="keyword">if</span>(x &gt;= <span class="number">0</span>) ans += flag * dp[x]; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>動態規劃 Dynamic programming</tag>
        <tag>排容原理 Inclusion–exclusion principle</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa11420 - Chest of Drawers(動態規劃)</title>
    <url>/2021/08/02/UVa/UVa11420/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>抽屜櫃是很方便的家具之一，可以放入很多的物品，而且每一個抽屜都可以選擇上鎖或不上鎖，上鎖的抽屜就會相當安全，但要小心，如果 <code>i</code> 抽屜上鎖，<code>i+1</code>抽屜不上鎖，那麼小偷可以透過 <code>i+1</code> 抽屜抽掉後，把 <code>i</code> 的抽屜物品拿走。</p>
<p>我們想請問如果我們給你一個抽屜櫃並且有 n 個抽屜，並要保證 s 個物品安全，想請問一共有幾種做法？<br>UVa 題目中的 U 表示不上鎖，L 表示上鎖，在 <code>n=6, s=4</code> 的情況下，有六種做法。</p>
<p><a href="https://onlinejudge.org/external/114/11420.pdf" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li>察覺這是一個 3 維 DP</li>
<li>理解題目的抽屜，有點不好懂XD</li>
<li>透過 DP 來解決各種發生狀態<ul>
<li>如果上一層沒鎖，這層有鎖，那要怎麼用 DP 解決。</li>
<li>有可能鎖著的櫃子，比櫃子數量來的更多嗎?</li>
</ul>
</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ul>
<li>首先我們可以確定一定有兩個變數<ul>
<li>幾個抽屜、有幾個上鎖</li>
<li>但好像沒有辦法解決，透過 <code>i+1</code> 抽屜抽掉後，把 <code>i</code> 的抽屜物品拿走。這種可能性？</li>
<li>那我們可以試試一種方法來解決這種問題。</li>
<li>增加一個抽屜，都是放到櫃子中的最上層，我們每次都只判斷最上層的櫃子有沒有鎖；如此一來，就解決中間櫃子有沒有鎖的問題，因為中間的櫃子一定都是透過其他的櫃子累加上來的。</li>
</ul>
</li>
<li>因此我們就再增加一個變數，最上層的櫃子有沒有鎖？</li>
<li><code>dp[i][j][k]</code><ul>
<li>i 是抽屜</li>
<li>j 是物品可置放在安全抽屜的個數，簡稱<strong>可靠抽屜</strong><br>注意：可靠抽屜並不是鎖，但有可靠抽屜才會有鎖</li>
<li>k 是最上層有沒有上鎖，1 表示有、0 表示沒有。</li>
</ul>
</li>
<li>那就準備進行 DP 規劃拉，我們來看看 DP 的狀態轉移<ul>
<li>先找出最初的設定值 <ul>
<li><code>dp[1][0][0] = 1</code>，在 1 個櫃子、0 個可靠抽屜的情況下有一種做法，合理！<br>0 個櫃子、0 個可靠抽屜，則不合理。這樣並不符合題目要求。</li>
<li><code>dp[1][1][1] = 1</code>，1 個櫃子、1 個可靠抽屜的情況下只有一種作法，合理！<ul>
<li>0 個櫃子、1 個可靠抽屜，則不合哩，你沒有櫃子，可靠抽屜有甚麼用阿XD。</li>
<li><code>dp[1][0][1] = 1</code>，1 個櫃子、0 個可靠抽屜的情況下最上層的櫃子是所住的，不合理！<br>這裡就是一個很明顯的範例點，由於 <code>n=1</code> 因此最上層就是其本身，但是沒有鎖怎麼會有可靠抽屜呢，因此這是很明顯的錯誤</li>
</ul>
</li>
</ul>
</li>
<li>得出結論，<strong>抽屜的數量必須要大於鎖的數量</strong></li>
<li>狀態轉移公式<ul>
<li><code>dp[i][0][0] = dp[i-1][0][0] + dp[i-1][1][1]</code><ul>
<li>需要特別注意，可能有些人會搞不懂為甚麼這裡也要加 <code>dp[i-1][1][1]</code><br>因為在 <code>dp[i][0][0]</code> 情況下，最上層的櫃子是沒有鎖的，此時 <code>dp[i-1][1][1]</code> 則是有鎖，但現在最上層加了一層沒鎖的抽屜，那第二層有鎖也是白鎖。</li>
<li>因此我們的可靠抽屜必須 -1</li>
</ul>
</li>
<li><code>dp[i][j][0] = dp[i-1][j+1][1] + dp[i-1][j][0]</code><ul>
<li>由於 <code>dp[i][j][0]</code> 最上層沒有鎖，因此 <code>dp[i-1][j+1][1]</code> 中安全抽屜會少一(最上層的抽屜有鎖住，勢必<strong>可靠抽屜會多一個</strong>)，會被人從最上層抽屜拿取上鎖的抽屜。</li>
<li><code>dp[i-1][j][0]</code> 則很合理</li>
</ul>
</li>
<li><code>dp[i][j][1] = dp[i-1][j-1][0] + dp[i-1][j-1][1]</code><ul>
<li><code>dp[i-1][j-1][0]</code> 很合理，現在最上層有鎖，因此安全抽屜會加一</li>
<li><code>dp[i-1][j-1][1]</code>，同上</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://www.pinghenotes.com/UVa-11420-Chest-of-Drawers/" target="_blank" rel="noopener">UVa 11420 - Chest of Drawers by pinghenotes</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>我記得我好像高中，就有寫過這題了XD，而且我印象我想了一個禮拜才寫出這題R….，那時候的我好笨QQ，不過那時候我記得網路上還沒有太多詳解，因此我沒有辦法順利解決這些題目。</p>
<p>現在有了，也讓我學會了！太開心了，趕緊記錄起來</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 70</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> dp[MAXN][MAXN][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> n, s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"out.txt"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">//註解 4-1-1</span></span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>; <span class="comment">//註解 4-1-2 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; MAXN<span class="number">-2</span>; i++)&#123;</span><br><span class="line">        dp[i][<span class="number">0</span>][<span class="number">0</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>][<span class="number">0</span>] + dp[i<span class="number">-1</span>][<span class="number">1</span>][<span class="number">1</span>]; <span class="comment">//註解 4-3-1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++)&#123;</span><br><span class="line">            dp[i][j][<span class="number">0</span>] = dp[i<span class="number">-1</span>][j+<span class="number">1</span>][<span class="number">1</span>] + dp[i<span class="number">-1</span>][j][<span class="number">0</span>]; <span class="comment">//註解 4-3-2</span></span><br><span class="line">            dp[i][j][<span class="number">1</span>] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>][<span class="number">0</span>] + dp[i<span class="number">-1</span>][j<span class="number">-1</span>][<span class="number">1</span>]; <span class="comment">//註解 4-3-3</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; s &amp;&amp; n &gt;= <span class="number">0</span> &amp;&amp; s &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; dp[n][s][<span class="number">0</span>] + dp[n][s][<span class="number">1</span>] &lt;&lt; <span class="string">"\n"</span>; <span class="comment">//輸出答案</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>背包問題 Knapsack Problem</tag>
        <tag>動態規劃 Dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa12862 - Intrepid climber(DFS)</title>
    <url>/2021/08/02/UVa/UVa12862/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>你爬上了山峰！你想把這個興奮的心情告訴其他還在爬山朋友，但那些朋友都還在山上爬，你要跑下去跟他們說。<br>現在你想要跟全部的朋友講，下山不需要花很多體力、但是上山需要花體力，但是題目保證一定會有一條完整的路徑(不會經過重複的路)可以讓你可以走到每個朋友的身邊。</p>
<p>現在請你算出你走到每個朋友身邊需要耗費多少體力。<br><a href="https://onlinejudge.org/external/128/12862.pdf" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li>了解 DFS</li>
<li>認識<a href="https://zh.wikipedia.org/wiki/%E4%B8%80%E7%AC%94%E7%94%BB%E9%97%AE%E9%A2%98" target="_blank" rel="noopener">尤拉路徑</a></li>
<li>發現題目的細節</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ul>
<li>我們可以觀察題目，發現一個很有趣的事情</li>
<li>因為題目保證我們只會有一條路徑！因此我們不需要找出路徑</li>
<li><strong>只要找到最後一個朋友，就不需要在移動</strong></li>
<li>所以我們只要找出所有的路徑，找到有一條<strong>從山峰到路徑累積 weights 最大</strong>，並把它當作最後一條路徑，然後扣掉他(因為找到最後一個朋友，不需要再移動)。</li>
<li>為甚麼是<strong>從山峰到路徑累積 weights 最大</strong>則是因為<ul>
<li>山峰是最高點</li>
<li>我們可以把她想像成有兩種路徑以山峰為起點，一種是從左邊下山遇到朋友、另一種則是從右邊下山遇到朋友。<br>註：山峰並不代表一開始的題目位置，題目只有說有唯一路徑，並沒有說都會經過題目初始位置</li>
<li>因此我們可以把題目轉化成，從左邊下山後上山 or 從右邊下山後上山，哪邊花的能量比較少，就選那邊下山後上山，再去找另一邊的朋友，然後就下山，不需要再耗費能量。</li>
</ul>
</li>
</ul>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://hackmd.io/@txya900619/Uva12862" target="_blank" rel="noopener">Uva12862 - Intrepid climber By txya900619</a><br><a href="https://morris821028.github.io/2014/11/18/uva-12862/" target="_blank" rel="noopener">UVa 12862 - Intrepid climber By Morris</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>這題完全考細節，不考程式碼難度，太秀了。希望我以後也可以發現這些邏輯</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100020</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> f, n;</span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; nodes[MAXN]; <span class="comment">//題目的邊 first 2nd node, second weights</span></span><br><span class="line"><span class="keyword">int</span> pal[MAXN]; <span class="comment">//朋友[i] = 1，表示是不是有 i 這個朋友</span></span><br><span class="line"><span class="keyword">int</span> a, b, c, l;</span><br><span class="line"><span class="keyword">int</span> max_weights, ans;<span class="comment">//max_weights 最長的一個邊， ans 答案</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> weights)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> visited_friend = <span class="number">0</span>; <span class="comment">//遇過了幾個朋友</span></span><br><span class="line">    <span class="keyword">if</span>(pal[root] == <span class="number">1</span>)&#123; <span class="comment">//發現朋友</span></span><br><span class="line">        max_weights = max(weights, max_weights); </span><br><span class="line">        visited_friend++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nodes[root].size(); i++)&#123; <span class="comment">//不斷找朋友</span></span><br><span class="line">        <span class="keyword">int</span> node = nodes[root][i].first, weight = nodes[root][i].second;</span><br><span class="line">        <span class="keyword">int</span> visit_friend = dfs(node, weights+weight);<span class="comment">//往這邊走有幾個朋友</span></span><br><span class="line">        visited_friend += visit_friend; <span class="comment">//紀錄遇到幾個朋友了</span></span><br><span class="line">        <span class="keyword">if</span>(visit_friend) ans += weight; <span class="comment">//如果有找到朋友，表示這路徑要加近來</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//cout &lt;&lt; "root visit_friend " &lt;&lt; root &lt;&lt; " " &lt;&lt; visited_friend &lt;&lt; "\n";</span></span><br><span class="line">    <span class="keyword">return</span> visited_friend;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; f &gt;&gt; n)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= f; i++) nodes[i].clear(); <span class="comment">//清除資料</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; f<span class="number">-1</span>; i++)&#123; <span class="comment">//輸入資料</span></span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">            nodes[a].push_back(make_pair(b, c));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(pal, <span class="number">0</span>, <span class="keyword">sizeof</span>(pal)); <span class="comment">//清除朋友資訊</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123; <span class="comment">//輸入朋友位置</span></span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; l;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; "l " &lt;&lt; l &lt;&lt; "\n";</span></span><br><span class="line">            pal[l] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        max_weights = <span class="number">0</span>, ans = <span class="number">0</span>; </span><br><span class="line">        dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//cout &lt;&lt; "ans " &lt;&lt; ans &lt;&lt; "\n";</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans - max_weights &lt;&lt; <span class="string">"\n"</span>; <span class="comment">//減掉最大的</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>UVa</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa12955 - Factorial(動態規劃、背包問題)</title>
    <url>/2021/08/02/UVa/UVa12955/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>給你一個數字 n，想請問你最少可以用幾個 \(x!\) 來組合成 n。<br>其中 x 不一定都要相同數字，舉例： \(10 = 3! + 2! + 2!\)，因此我們使用 3 個 !，輸出 3。</p>
<p><a href="https://onlinejudge.org/external/129/12955.pdf" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li>了解動態規劃</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ul>
<li><a href="http://web.ntnu.edu.tw/~algo/KnapsackProblem.html#6" target="_blank" rel="noopener">Coin Change Problem</a>問題，但從找最大改成找最小</li>
<li>第一個迴圈設定為 9<br>因為 \(9! = 362880\)，大於題目的最大 N </li>
<li>第二個迴圈設為 N，從 \(0~N\) 不斷進行無限背包</li>
</ul>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>難得輕鬆解，開心</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100020</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> num[MAXN], n;</span><br><span class="line"><span class="keyword">int</span> f = <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(num, <span class="number">0x3f3f3f</span>, <span class="keyword">sizeof</span>(num)); <span class="comment">//初始為無限大</span></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">1</span>; <span class="comment">//用於計算 factorial</span></span><br><span class="line">    num[<span class="number">0</span>] = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">9</span>; i++)&#123;</span><br><span class="line">        sum *= i; <span class="comment">//第 i factorial</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = sum; j &lt; MAXN; j++)&#123; <span class="comment">//無限背包問題</span></span><br><span class="line">            num[j] = min(num[j], num[j - sum]+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//for(int i = 0; i &lt; 30; i++) cout &lt;&lt; num[i] &lt;&lt; "\n";</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; num[n] &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>背包問題 Knapsack Problem</tag>
        <tag>動態規劃 Dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa13141 - Growing Trees(動態規劃)</title>
    <url>/2021/08/02/UVa/UVa13141/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>目前正在做林地復育，大家給你一個任務是數每一個樹的其中一個 level 樹幹有幾個，而林地裡面的樹大多邏輯是這樣，觀察下面此圖找到邏輯<br><img src="https://drive.google.com/u/2/uc?id=1_RnBkRNpcUnUfg4QMgdsLjnoeHytn8wZ&export=download" alt=""></p>
<p>邏輯大概如下</p>
<ul>
<li>level 1 的樹，只會是一枝樹幹</li>
<li>level i 的樹，如果這一枝樹幹不是透過上一層分裂而來，那 level i+1 要分裂成兩個樹幹</li>
<li>level i 的樹，是透過上一層分裂而來，那 level i+1 不分裂</li>
</ul>
<p>我們會問你 level i，請告訴我們那一層有幾個樹幹</p>
<p><a href="https://onlinejudge.org/external/131/13141.pdf" target="_blank" rel="noopener">題目大意</a></p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li>觀察 DP 邏輯</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ul>
<li>稍微細心的解題者可以發現，這棵樹其實就是一個費式樹列，因此直接產生一個費式樹列即可。</li>
</ul>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 90</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> f[MAXN];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line"></span><br><span class="line">    f[<span class="number">1</span>] = <span class="number">1</span>, f[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; MAXN; i++)&#123;</span><br><span class="line">        f[i] = f[i<span class="number">-1</span>] + f[i<span class="number">-2</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n &amp;&amp; n)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; f[n] &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>動態規劃 Dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title>男朋友與女朋友交往時，遇到女朋友老爸的困境</title>
    <url>/2021/08/05/life_experence/love-is-hard-20210805/</url>
    <content><![CDATA[<h2 id="說明"><a href="#說明" class="headerlink" title="說明"></a>說明</h2><blockquote>
<p>主要是說明想跟自己喜歡的女生過夜出去玩，但女朋友跟老爸講過夜卻有可能不會成功的事情描述以及個人感受抒發</p>
</blockquote>
<a id="more"></a>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>嘿，大衛，好久沒有寫人生旅途了喔XD，沒想到這次寫就是寫不開心的事情啊XD，要不要乾脆把人生旅途改成不開心旅途了呢XDDDD，開心到讓自己寫下來的事情到沒幾個，但是讓自己難過到寫下來的心情到是一堆，大衛阿，你是不是有點沒用QQQQ。</p>
<h2 id="劇情描述"><a href="#劇情描述" class="headerlink" title="劇情描述"></a>劇情描述</h2><p>簡單說呢，就是我交了一個彰化的女友、讀雲科，認識我的也都知道嘛，我讀北科，要維持這種遠距離關係基本上對我來說是很難的，因為我對性有強烈的慾望，原本當我知道他要去讀雲科而不讀北商時我的心當然很難過啊，我喜歡的女生就這樣不會來我身邊了QQ。</p>
<!-- 我原本是想跟他分手的，畢竟我可能還是要痛下心來，我怕他捨不得，最後卻因為三番兩次的吵架而讓自己跟他的關係變成陌生人，不過他太會哄我了，導致我後來還是真的狠不下心來。 -->

<h3 id="讀雲科而不能讀北商"><a href="#讀雲科而不能讀北商" class="headerlink" title="讀雲科而不能讀北商"></a>讀雲科而不能讀北商</h3><p>我原本就認為讀北商會比雲科好，畢竟商科還是要讀北商比較有競爭力、師資也明顯比較好，原本經過我不斷努力後，稍微讓女朋友的心願意往北商，結果後來因為他爸的希望他去就讓她後來還是去了雲科。</p>
<p>我如果說不讓她去雲科是不是很為難他？這種時候我應該要怎麼辦？身為一個男生還是乖乖扛著比較好，反正本來就這樣嘛，大風大浪我也不是沒有見過，有些道理我也是挺明白的，總是要犧牲一些比較微不足道的人，才有辦法讓自己不會更有壓力嘛，人之常情，要是我，我也會這樣吧。</p>
<p>不過確實拉，從大一起我也就知道，在父母面前男友永遠都是被犧牲的那個，而大部分的女生也不會因為男友而跟父母反抗，最多就是哄哄男友、向男友表達自己內心的難受。<br>就是因為自己也不是第一次經歷過這種痛苦，不會那麼幼稚或天真的在希望女生會願意成全男友，跟父母溝通？</p>
<p>也許看到這邊，可能會說，你以後生了女兒也會這樣啊？如果會給予這種問題，那我只能說，我受過傷，我懂那對小孩的打擊，那對小孩可以造成多大的無力感，我會用更好的方式去完成，不會像大部份父母一樣那麼自私。<br>就好像是，你被 A 用刀砍，你會拿刀砍 B，就因為 A 砍你，那你完全不懂得己所不欲，勿施於人，這種心情。</p>
<h2 id="正題"><a href="#正題" class="headerlink" title="正題"></a>正題</h2><p>原本我打算趁著這次科大 ICPC，順道至台中，順便跟他一起約會、過夜，我也忘記他有沒有說可以，但我的印象是有，然後我就想了好多可以一起甜蜜的事情，雖然我不知道對女友而言算不算甜蜜拉，但對我來說算鰻甜蜜的，我蠻喜歡的劇情XD，要是不喜歡還會規畫嗎www</p>
<p>可惜，理想很豐滿、現實很苗條，雖然想了那麼多行程，但是後來聽到她<strong>不一定可以過夜，他爸反對</strong>，聽到這句話，老實講，我已經知道可以不用期待他過夜了，因此我那天態度本來就很不開心，沒辦法，快樂的東西破滅總是讓我痛苦。<br>那天晚上後來他說，<strong>講的好像我都不期待，只有你很期待；只有你不開心，我就不會不開心</strong>，當然，我知道他一定不開心，所以我的不開心應該要跟他的不開心抵銷，這樣才沒有互相愧欠，對吧？<br>可惜，我的方程式這樣似乎沒辦法成立，畢竟爸爸的權力比較大，我只是被犧牲的；不然換的方式講，爸爸不開心，女兒不開心，這樣不也抵消嗎？</p>
<p>總之，理所當然的我知道我又是被犧牲的那個。</p>
<p>只是呢，唉，被犧牲的又是我，每次都是被女友爸吃得死死，我有時候都在想，如果把男友跟爸爸放在天秤上，我想這個天秤永遠都是爸爸低、男友高的情況八，但這是因為爸爸跟男友不一樣重的關係嗎？我覺得不盡然，應該是天秤本身就已經知道男友與爸爸的位置要擺在哪裡，誰高誰低。都已經決定好了，男友跟爸爸誰比較重，早就已經不是這件事情的關鍵了。</p>
<h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><p>你說，看到這邊了，結論呢XD，答案當然是沒有結論啦。<br>怎麼可能會有結論呢？有結論的話我還要來這邊抱怨嘛QQ，其實想當然爾拉，我其實已經不認為過夜會成功了，身為一個稱職的男友當然不可以讓女生不開心，一定要想出一個可以讓女生也開心的方案，對吧！<br>畢竟他還是喜歡我的，我辜負他，是算我對不起她。</p>
<p>其實也想好了，先去住朋友家那，早上再去陪他玩，只是我不知道這樣的我會不會開心，如果我想要開房間休息，是不是又會被拒絕，到時候我是不是要擺出一副開心的表情，才符合男友的陽光正面形象呢？</p>
<p>總之，往往被傷害的是我，我想應該是我太保護女友了，應該要讓女朋友主動來追我，不是都是我來包容他。現在的我已經委屈滿滿、一肚子怨氣了到睡不著了，總感覺自己是被犧牲的一方，不過換個方式講，也許女友也才認為自己被犧牲，一直被爸爸跟男友夾著。<br>我不想論其對錯，我只想表達我很委屈、很難過，畢竟我打這篇文章也沒有想著要吵架，我覺得我好委屈，為甚麼受傷的總是我，我只是想要快快樂樂幸福甜蜜的生活，</p>
<p>總之，這也不是第一次了，只要我裝作不在意，內心一定也會不在意的，對八<br>出遊的孩子開心得睡不著，當他多出去玩幾次，就出遊的前一晚總像綿羊一樣溫馴。</p>
]]></content>
      <categories>
        <category>人生旅途</category>
      </categories>
      <tags>
        <tag>大學Life</tag>
        <tag>人生旅途</tag>
      </tags>
  </entry>
  <entry>
    <title>演算法知識 - Graph theorm Find Bridge</title>
    <url>/2021/08/11/Explain_Algorithm/Find_Bridge_Problem/</url>
    <content><![CDATA[<h2 id="Find-Bridge-介紹"><a href="#Find-Bridge-介紹" class="headerlink" title="Find Bridge 介紹"></a>Find Bridge 介紹</h2><blockquote>
<p>Find Bridge 顧名思義就是要找到橋，那這裡的橋是甚麼意思呢？<br>想想現實生活中的橋，是不是只要橋斷開了兩邊的聯繫就斷了？</p>
<p>那麼圖論中亦是如此，只要<strong>有一個邊斷掉了</strong>，那麼就一張圖就被分成兩個圖了！(注意，兩張圖中可能其中有一張圖只有一個點)<br><a href="http://web.ntnu.edu.tw/~algo/Component.html#1" target="_blank" rel="noopener">師大演算法</a>中有用圖片進行說明，其中我用紅筆圈出來的就是橋。<br>注意，圖中的 (1,2)、(7,8)、(7,9) 都是橋<br><img src="https://drive.google.com/u/2/uc?id=1_tHUD8aRq2pGCI_nSM9fb22YusZBOi2L&export=download" alt=""></p>
<p><strong>而此演算法解出的問題就是讓所有這些橋的點都被找到</strong></p>
</blockquote>
<a id="more"></a>

<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><ul>
<li>她講得很好，大力推薦 <a href="https://cp-algorithms.com/graph/bridge-searching.html" target="_blank" rel="noopener">Finding bridges in a graph in O(N+M) by CP-alhorithm</a></li>
<li><a href="http://web.ntnu.edu.tw/~algo/Component.html#1" target="_blank" rel="noopener">師大演算法</a><h2 id="邏輯證明"><a href="#邏輯證明" class="headerlink" title="邏輯證明"></a>邏輯證明</h2></li>
<li>四個陣列，一個 vector <code>edge</code> 紀錄題目的邊<ul>
<li><code>depth</code> 記錄當前深度</li>
<li><code>low</code> 紀錄當前節點，能返回的最淺深度是多少</li>
<li><code>visit</code> 紀錄是否有走訪過</li>
<li><code>ancestor</code> 為 disjoint set，將所有橋的節點放在一起</li>
</ul>
</li>
<li>程式邏輯與證明<ul>
<li>首先我們先假設 <code>low[root] = depth[root]</code>，完全一樣 </li>
<li>當 <code>root</code> 可以返回到已經走訪過的邊(定義 <code>v</code>)時，此時 <code>depth[root] &lt; depth[v]</code><br>因為可以碰到之前走訪過的點，因此這個邊不會是一個 bridge，root 就也不會是 bridge node</li>
<li>當 <code>low[root] &gt; low[v]</code> 表示 <code>v</code> 這個節點他可以返回到更前面的節點。因此就表示 root 也不是 bridge node。</li>
<li>當 <code>low[v] &gt; depth[root]</code>，表示 root 的下一個節點 v，沒辦法透過任何方式回到 root 身邊來，因此我們就可以證實 root 跟 v 都是 bridge node，有一個 bridge node。<ul>
<li>此時，將 root 與 v 放入同一個 bridge node set，就可以知道他們都是 bridge node。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="程式碼說明"><a href="#程式碼說明" class="headerlink" title="程式碼說明"></a>程式碼說明</h2><p>這裡我們透過程式碼說明，並且解釋。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; edge[MAXN];</span><br><span class="line"><span class="keyword">int</span> visit[MAXN], depth[MAXN], low[MAXN];</span><br><span class="line"><span class="keyword">int</span> ancestor[MAXN];</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> find_root(<span class="keyword">int</span> x)&#123; </span><br><span class="line">    <span class="keyword">if</span>(ancestor[x] != x) <span class="keyword">return</span> ancestor[x] = find_root(ancestor[x]);</span><br><span class="line">    <span class="keyword">return</span> ancestor[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find_bridge</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> past)</span></span>&#123; <span class="comment">//找到橋點</span></span><br><span class="line">    visit[root] = <span class="number">1</span>; <span class="comment">//表示走訪過</span></span><br><span class="line">    depth[root] = low[root] = cnt++; <span class="comment">//邏輯證明 2.1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> node: edge[root])&#123; <span class="comment">//不斷遍地</span></span><br><span class="line">        <span class="comment">//因為是無向邊，因此雙向同個 edge 不是 bridge </span></span><br><span class="line">        <span class="keyword">if</span>(node == past) <span class="keyword">continue</span>; </span><br><span class="line">        <span class="keyword">if</span>(visit[node]) low[root] = min(low[root], depth[node]); <span class="comment">//邏輯證明 2.2</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//先進行 DFS，往下找其他的 node 有沒有辦法回到曾經走放過的節點</span></span><br><span class="line">            find_bridge(node, root); </span><br><span class="line">            low[root] = min(low[root], low[node]); <span class="comment">//邏輯證明 2.3</span></span><br><span class="line">            <span class="keyword">if</span>(low[node] &gt; depth[root])&#123;  <span class="comment">//邏輯證明 2.4</span></span><br><span class="line">                <span class="keyword">int</span> fa_node = find_root(node); <span class="comment">//進行 disjoint merge</span></span><br><span class="line">                <span class="keyword">int</span> fa_root = find_root(root);</span><br><span class="line">                <span class="comment">//cout &lt;&lt; "fa " &lt;&lt; fa_node &lt;&lt; " " &lt;&lt; fa_root &lt;&lt; "\n";</span></span><br><span class="line">                ancestor[fa_node] = fa_root;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>好久沒有學演算法了，真的覺得學演算法是最開心的一件事，總是能透過一些優秀的方式來解決生活上的許多難題，這種動腦的我真的很喜歡。</p>
<p>但是我又感覺我不夠聰明好討厭QQ。</p>
<p>謝謝 cp 用好懂的方式教會我。</p>
]]></content>
      <categories>
        <category>演算法知識</category>
      </categories>
      <tags>
        <tag>程式解題</tag>
        <tag>演算法知識</tag>
        <tag>Graph Component</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa10116 - Robot Motion(DFS)</title>
    <url>/2021/08/10/UVa/UVa10116/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>我們的機器人會根據路面上的指示進行移動，請告訴我們當她從座標 \(0,c\) 進去後幾步會出來地圖外。<br>如果產生迴圈的狀態，請告訴我們這個迴圈有幾步</p>
<p><a href="https://onlinejudge.org/external/101/10116.pdf" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li>DFS</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ul>
<li>簡單的 DFS</li>
<li>判斷迴圈<ul>
<li>當碰到之前經歷過的節點，就知道是迴圈並且輸出步數</li>
</ul>
</li>
<li>可以離開地圖<ul>
<li>只要當我們走到地圖外後，就知道離開地圖</li>
</ul>
</li>
<li>途中記錄每一個遍地的節點都必須要記錄<strong>步數</strong></li>
</ul>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">string</span> maze[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> visit[<span class="number">20</span>][<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> r, c, go;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> step)</span></span>&#123;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; x &lt;&lt; " " &lt;&lt; y &lt;&lt; "\n";</span></span><br><span class="line">    <span class="keyword">if</span>(x &lt; <span class="number">0</span> || x &gt;= r || y &lt; <span class="number">0</span> || y &gt;= c)&#123; <span class="comment">//判斷是否離開地圖</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; step &lt;&lt; <span class="string">" step(s) to exit\n"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(visit[x][y] != <span class="number">-1</span>)&#123; <span class="comment">//又重新回到 loop</span></span><br><span class="line">        <span class="comment">//visit[x][y] 由於回到迴圈，因此碰到迴圈的那個點之前的步數都是正常</span></span><br><span class="line">        <span class="comment">//step - visit[x][y] 總步數 - 不是迴圈的步數 = 迴圈步數</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; visit[x][y] &lt;&lt; <span class="string">" step(s) before a loop of "</span> &lt;&lt; step - visit[x][y] &lt;&lt; <span class="string">" step(s)\n"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    visit[x][y] = step; <span class="comment">//這是第幾步</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//判斷下一個位置要怎麼走</span></span><br><span class="line">    <span class="keyword">if</span>(maze[x][y] == <span class="string">'N'</span>) dfs(x<span class="number">-1</span>, y, step+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(maze[x][y] == <span class="string">'S'</span>) dfs(x+<span class="number">1</span>, y, step+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(maze[x][y] == <span class="string">'W'</span>) dfs(x, y<span class="number">-1</span>, step+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(maze[x][y] == <span class="string">'E'</span>) dfs(x, y+<span class="number">1</span>, step+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"out.txt"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; r &gt;&gt; c &gt;&gt; go &amp;&amp; (r + c + go) != <span class="number">0</span>)&#123; <span class="comment">//注意，我的 index 從 0 開始</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r; i++) <span class="built_in">cin</span> &gt;&gt; maze[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= r; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= c; j++) visit[i][j] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(<span class="number">0</span>,go<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>UVa</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa10505 - Montesco vs Capuleto(DFS、塗色問題)</title>
    <url>/2021/08/10/UVa/UVa10505/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>羅密歐與茱麗葉要結婚啦，但他們的雙方家庭是世仇，但他們還是希望可以找雙方家庭的親朋好友來，因此它們避免婚禮之間有衝突，他們邀請的人如下</p>
<ul>
<li>如果 a 跟 b 是敵人，b 跟 c 也是敵人，d 跟 a,b,c 都不是敵人，那麼 a 跟 c 就是朋友、a 與 d <strong>並不是朋友</strong>。</li>
<li>如果 a 跟 b 是敵人，雙方都討厭對方</li>
<li>我們只邀請數字小於 N 的人，大於 N 的都不邀請</li>
<li>如果我們邀請 a，那麼 a 以外的所有朋友都要參加，避免被誤會。</li>
</ul>
<p>現在請告訴羅密歐與茱麗葉，最多有幾個人可以來參加婚禮</p>
<p><a href="https://onlinejudge.org/external/105/10505.pdf" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li>塗色問題(在題目的第一點可以得知)</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ul>
<li>寫一個 DFS，並分成 A、B 陣營，只要是 B 的敵人就是 A 陣營，反之亦同。</li>
<li>必須邀請每一個朋友，因此只要有一個好朋友不能來就不行，也表示當塗色問題遇到衝突時，就果斷放棄那棵樹，因為不管怎麼選都會有一個朋友沒辦法參加，或出現一個敵人。<ul>
<li>舉例，A 跟 B 是敵人、B 跟 C 是敵人、A 跟 C 是敵人</li>
</ul>
</li>
<li><strong>因此這個朋友關係表不可以有任何衝突，有就不能記錄</strong></li>
<li>最多邀請人數 = 每一個朋友關係表中的最大陣營(<code>max(a,b)</code>)<br>每一個是因為題目不一定<strong>只給一個</strong></li>
<li><strong>紀錄，不可以發現衝突就 return 回來，這樣那一個完整的朋友關係圖沒有完整走過，因此我們不斷在尋找下一張朋友關系圖時，程式會拆成兩張，造成 bug</strong></li>
</ul>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://hackmd.io/@txya900619/Uva10505" target="_blank" rel="noopener">Uva10505 - Montesco vs Capuleto by txya900619</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>一開始我還沒辦法發現這是塗色問題QQ，加上好久沒有看到 <strong>if, and only if,</strong>，都是看到 iff，直接把題目意思給搞錯了…。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 300</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; edge[MAXN];</span><br><span class="line"><span class="keyword">int</span> visit[MAXN];</span><br><span class="line"><span class="keyword">int</span> t, n, cnt, enemy;</span><br><span class="line"><span class="keyword">int</span> color[<span class="number">2</span>], flag; <span class="comment">//color = A、B 兩大陣營，flag 為判斷這個朋友關係表是否有衝突</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> status)</span></span>&#123; <span class="comment">//status 表示現在的 node 必須是哪個陣營</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; "root " &lt;&lt; root &lt;&lt; "\n";</span></span><br><span class="line">    <span class="keyword">if</span>(visit[root] == <span class="number">-1</span>) visit[root] = status; <span class="comment">//加入陣營</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//如果此節點已經有加入陣營且陣營與 status 相同，表示不衝突</span></span><br><span class="line">        <span class="comment">//注意這裡是用 and (1 &amp; 1 = 0) (0 &amp; 0=1)，不要像我一樣突然把 and 當成 nor..</span></span><br><span class="line">        flag &amp;= (visit[root] == status); </span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">//他之前已經遍地過因此 return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//cout &lt;&lt; "root status " &lt;&lt; root &lt;&lt; " " &lt;&lt; visit[root] &lt;&lt; "\n";</span></span><br><span class="line">    color[status]++; <span class="comment">//status 陣營增加一個</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edge[root].size(); i++)&#123; <span class="comment">//幫 subnode 加入敵對陣營</span></span><br><span class="line">        dfs(edge[root][i], <span class="number">1</span>-status);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="comment">//freopen("out.txt", "w", stdout);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            visit[i] = <span class="number">-1</span>;</span><br><span class="line">            edge[i].clear();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; cnt;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cnt; j++)&#123;</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; enemy;</span><br><span class="line">                <span class="keyword">if</span>(enemy &gt; n) <span class="keyword">continue</span>; <span class="comment">//題目第三點說明</span></span><br><span class="line">                edge[i].push_back(enemy); <span class="comment">//雙向，題目第二點說明</span></span><br><span class="line">                edge[enemy].push_back(i);</span><br><span class="line">                <span class="comment">//cout &lt;&lt; "i enemy " &lt;&lt; i &lt;&lt; " " &lt;&lt; enemy &lt;&lt; "\n";</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="built_in">memset</span>(color, <span class="number">0</span>, <span class="keyword">sizeof</span>(color));</span><br><span class="line">            <span class="keyword">if</span>(visit[i] == <span class="number">-1</span>)&#123;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">                dfs(i, <span class="number">0</span>); </span><br><span class="line">                <span class="comment">//表示這個朋友關係表沒有衝突，找最大的陣營的來參加婚禮</span></span><br><span class="line">                <span class="keyword">if</span>(flag == <span class="number">1</span>) ans += max(color[<span class="number">0</span>], color[<span class="number">1</span>]); </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//cout &lt;&lt; "max " &lt;&lt; max(color[0], color[1]) &lt;&lt; "\n";</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>UVa</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa12363 - Hedge Mazes(DFS、Find Bridge Problem、Disjoint Set)</title>
    <url>/2021/08/10/UVa/UVa12363/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>女王是迷宮粉絲，因此他把女王的住處切割成每一個房間，並透過走廊連接，每一個房間都透過走廊連接，女王想問你說從 A 到 B 是不是<strong>恰好只有一條路徑可以抵達</strong>。</p>
<p><a href="https://cp-algorithms.com/graph/bridge-searching.html" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li><a href="https://cp-algorithms.com/graph/bridge-searching.html" target="_blank" rel="noopener">Find Bridge Problem</a></li>
<li><a href="https://theriseofdavid.github.io/2021/02/02/Explain_Algorithm/disjoint-set/" target="_blank" rel="noopener">並查集</a></li>
<li>必須先熟悉上面兩點才有辦法寫此題目</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ul>
<li>首先，我們知道，如果要恰好只有一條路徑，那麼就必須每一個走廊都要是 bridge 才有辦法完成。</li>
<li>因此，我們用 Find Bridge Problem + disjoint set 將所有的橋都放在同個 set。</li>
<li>這篇則有詳細的說明 <a href="https://theriseofdavid.github.io/2021/08/11/Explain_Algorithm/Find_Bridge_Problem/" target="_blank" rel="noopener">Find Bridge Problem by 大衞的筆記</a></li>
</ul>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://hackmd.io/@txya900619/Uva12363" target="_blank" rel="noopener">Uva12363 - Hedge Mazes by txya900619</a><br><a href="https://cp-algorithms.com/graph/bridge-searching.html" target="_blank" rel="noopener">Finding bridges in a graph in O(N+M) by CP-alhorithm</a></p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。<br>其中 <a href="https://theriseofdavid.github.io/2021/08/11/Explain_Algorithm/Find_Bridge_Problem/" target="_blank" rel="noopener">Find Bridge Problem by 大衞的筆記</a> 這邊的程式碼請看這個 link 有詳細的說明。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="comment">//#define DEBUG</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100020</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; edge[MAXN];</span><br><span class="line"><span class="keyword">int</span> visit[MAXN], ancestor[MAXN];</span><br><span class="line"><span class="keyword">int</span> depth[MAXN], low[MAXN];</span><br><span class="line"><span class="keyword">int</span> r, c, q, cnt;</span><br><span class="line"><span class="keyword">int</span> a, b;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_root</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ancestor[x] != x) <span class="keyword">return</span> ancestor[x] = find_root(ancestor[x]);</span><br><span class="line">    <span class="keyword">return</span> ancestor[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find_bridge</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> past)</span></span>&#123;</span><br><span class="line">    visit[root] = <span class="number">1</span>;</span><br><span class="line">    depth[root] = low[root] = cnt++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> node: edge[root])&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == past) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(visit[node]) low[root] = min(low[root], depth[node]);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            find_bridge(node, root);</span><br><span class="line">            low[root] = min(low[root], low[node]);</span><br><span class="line">            <span class="keyword">if</span>(low[node] &gt; depth[root])&#123;</span><br><span class="line">                <span class="keyword">int</span> fa_node = find_root(node);</span><br><span class="line">                <span class="keyword">int</span> fa_root = find_root(root);</span><br><span class="line">                <span class="comment">//cout &lt;&lt; "fa " &lt;&lt; fa_node &lt;&lt; " " &lt;&lt; fa_root &lt;&lt; "\n";</span></span><br><span class="line">                ancestor[fa_node] = fa_root;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; r &gt;&gt; c &gt;&gt; q &amp;&amp; (r+c+q) != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= r; i++)&#123;</span><br><span class="line">            edge[i].clear();</span><br><span class="line">            ancestor[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(visit, <span class="number">0</span>, <span class="keyword">sizeof</span>(visit));</span><br><span class="line">        <span class="built_in">memset</span>(depth, <span class="number">0</span>, <span class="keyword">sizeof</span>(depth));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; c; i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">            edge[a].push_back(b);</span><br><span class="line">            edge[b].push_back(a);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= r; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visit[i]) find_bridge(i, <span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= r; i++)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"ancestor "</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span> &lt;&lt; ancestor[i] &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= r; i++)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"low "</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span> &lt;&lt; low[i] &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">            <span class="keyword">int</span> fa_a = find_root(a);</span><br><span class="line">            <span class="keyword">int</span> fa_b = find_root(b);</span><br><span class="line">            <span class="keyword">if</span>(fa_a == fa_b) <span class="built_in">cout</span> &lt;&lt; <span class="string">"Y\n"</span>; <span class="comment">//如果在同個 bridge node 就是 Yes</span></span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"N\n"</span>; <span class="comment">//沒有表示有兩種以上路徑 or 沒有路徑</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"-\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>UVa</tag>
        <tag>Disjoint Set 並查集</tag>
        <tag>程式解題</tag>
        <tag>Graph Component</tag>
      </tags>
  </entry>
  <entry>
    <title>程式交易股票經驗，賠了 3 萬的大衛QQ</title>
    <url>/2021/08/10/trade_life/program_stock_experence20210811/</url>
    <content><![CDATA[<h2 id="前情概要"><a href="#前情概要" class="headerlink" title="前情概要"></a>前情概要</h2><blockquote>
<p>主要是大衛從 7/16 開始用程式做交易，結果賠了 3 萬元，在這邊做一個心得回饋與紀錄。</p>
</blockquote>
<a id="more"></a>

<h2 id="一開始的我"><a href="#一開始的我" class="headerlink" title="一開始的我"></a>一開始的我</h2><p>由於一開始我的策略透過回測都很棒，勝率 80%、profit factor 大於 3，就會很想要下去實際操作看看。(題外話：感謝吳沐恩老師與研究生們，讓我學到很多知識)</p>
<p>那說實在的，我去年工作也就只有 15 萬多，跟媽媽要了 10 萬，就拿 25 萬下去玩股票拉XD。</p>
<p>一開始的時候策略大賺就陸續想了一些新的策略，看起來也都很漂亮就慢慢來使用了。<br>其實很想要跟沐恩老師開會報告，但感覺沒有面對面我不太會表達QQ，想說等到開學見面再跟他講講我的策略想法。</p>
<h2 id="程式交易"><a href="#程式交易" class="headerlink" title="程式交易"></a>程式交易</h2><p>雖然說是程式交易拉，但其實也不算，更正確一點說是<strong>股票推薦機器人</strong>，因為我都是用日K來做判斷，畢竟我沒有那麼多時間看盤，我怕做當沖，我去忙一個程式錯誤就要把我的錢大切八塊了QQ。</p>
<p>因此我就寫了一個股票機器人，用日K判斷，此時就可以善用台股的盤後交易去交易，抑或是掛這今天收盤價去明天市場買入。</p>
<h2 id="等等，我回測公式錯了，我竟然沒發現！"><a href="#等等，我回測公式錯了，我竟然沒發現！" class="headerlink" title="等等，我回測公式錯了，我竟然沒發現！"></a>等等，我回測公式錯了，我竟然沒發現！</h2><p>這時候我有一個策略，我定義它叫做<strong>斜率突破策略</strong>，他是我回測最漂亮、最亮眼的一隻策略，陸陸續續給了我好多隻股票，我就都買下去了，結果都大賠！常常就是隔天跌停…，我這個是放空大策略八…。<br>此時，我研究出了一個問題！發現我買的股票都是隔日沖大戶買的！</p>
<p>起初，我一開始以為只是我的股票策略輸給了隔日沖大戶，因此還是繼續買，注意那幾個隔日沖卷商就好，結果還是有 70% 賠掉，這跟我原本想得很不一樣，明明應該至少都會大賺，怎麼會這樣？</p>
<p>因此，我馬上回來檢查我的程式碼，發現我有一個的公式寫錯，導致我都是用前一天的價格買，這下可好了，我用前一天的價格判斷我今天會不會漲，阿可是我現實中是買今天的成交價阿…。</p>
<p>我應該用今天預知明天，卻用了昨天來預知今天，接下來我將此程式修正，發現這隻策略就完全沒有賺，還大賠…，聽起來好適合放空喔XD。<br>但是我好像不能股票放空？沒有問過卷商不清楚。</p>
<h2 id="現在才發現的我，已經賠了-1-萬-5-了…"><a href="#現在才發現的我，已經賠了-1-萬-5-了…" class="headerlink" title="現在才發現的我，已經賠了 1 萬 5 了…"></a>現在才發現的我，已經賠了 1 萬 5 了…</h2><p>沒辦法，乖乖認賠止損拉，雖然心很痛，但也沒辦法嘛。畢竟是自己的問題，怎麼能抱怨別人？自己摸摸鼻子，下次努力。</p>
<p>然後今天，我那隻表現比較普通的策略讓我現在未實現損益 4.97%，我都是 5% 停損，雖然現在很想停損…，但還是遵守紀律，看看明天的收盤有沒有跌破 5% 八…。</p>
<h2 id="其實回測下來，發現等待不可怕，但是在購買的時候，發現等待才是魔鬼"><a href="#其實回測下來，發現等待不可怕，但是在購買的時候，發現等待才是魔鬼" class="headerlink" title="其實回測下來，發現等待不可怕，但是在購買的時候，發現等待才是魔鬼"></a>其實回測下來，發現等待不可怕，但是在購買的時候，發現等待才是魔鬼</h2><p>你會因為在等待，看到股票漲，那天心情就好；看到股票跌，心情就差，很容易被股票的未實現損益給影響心情，賠的時候就很想趕快賣掉，賺的時候就會想放著慢慢賺，ummm…聽起來真的是很微妙…。</p>
<p>要讓自己學會等待，雖然我自己最不擅長等待，每次一等待就會急躁，心情不好…，還要多練練。</p>
<h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><p>介於上面這些因素，我對程式買賣股票有了一些結論</p>
<ul>
<li>先下模擬單一個月，讓自己習慣這個策略的漲跌習性<ul>
<li>如果發現這個月都是賠，那就先不要下場。也許是還在吹西北風，還沒吹東風。</li>
<li>如果這個月都是賺，漂亮，該下場了bro。</li>
</ul>
</li>
<li>如果短期(5 天)想不到好策略，要不要試試看中期？(一個月)<ul>
<li>我都以 5 日為目標，但發現只用 5 個 K 棒有點難做，我玩期貨也沒有只用 5 跟K，也許我還泰菜了</li>
</ul>
</li>
</ul>
<p>總之，希望我能記起這 3 萬得教訓，讓自己好好變的優秀，可以讓自己在股票市場中賺的到錢！<br>我還蠻希望可以把交易員當作我的工作，我可以看盤看 3 個小時不覺得累！看盤跟寫演算法都是我的最大樂趣之一！</p>
<p>只是看盤不利可能會睡公園，所以我要加緊腳步學習！</p>
]]></content>
      <categories>
        <category>交易人生</category>
      </categories>
      <tags>
        <tag>程式交易</tag>
        <tag>股票</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa12783 - Weak Links(DFS、Find Bridge Problem)</title>
    <url>/2021/08/12/UVa/UVa12783/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>警察想要拆除犯罪份子的聯繫，會給你一個犯罪分子的聯繫圖，只要我們能夠將這個聯繫圖一分為二，此時他們的消息傳播就會被我們給阻斷。</p>
<p>你的任務就是要找出只要切斷那些犯罪份子的聯繫，就可以讓消息傳播阻斷，輸出總共有幾種切法，並且輸出每一種切法。<br>並且從最小的犯罪份子(數字代號)開始依序輸出<br><a href="https://onlinejudge.org/external/127/12783.pdf" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li><a href="https://cp-algorithms.com/graph/bridge-searching.html" target="_blank" rel="noopener">Find Bridge Problem</a></li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ul>
<li>首先，我們知道，將圖一分為二的方法就是找到 bridge</li>
<li>因此我們就將所有的 bridge 存在 vector</li>
<li>之後 vector sort 就可以輸出。</li>
<li>這篇則有詳細的說明 <a href="https://theriseofdavid.github.io/2021/08/11/Explain_Algorithm/Find_Bridge_Problem/" target="_blank" rel="noopener">Find Bridge Problem by 大衞的筆記</a></li>
</ul>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><ul>
<li><a href="https://cp-algorithms.com/graph/bridge-searching.html" target="_blank" rel="noopener">Find Bridge Problem</a></li>
<li><a href="https://hackmd.io/@txya900619/Uva12783" target="_blank" rel="noopener">Uva12783 - Weak Links by txya900619</a></li>
</ul>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>有時候不要耍小聰明，想說少寫一兩行，少做一個 step，將一些步驟優化掉，一定要先確認這個絕對沒錯，才可以優化！</p>
<p>不然就會像我一樣，為了除一個錯，花了一個小時…，雖然我是覺得當你認為你優化非常棒的時候，就不會覺得有錯XD，好矛盾喔www。</p>
<p>總之就是，要想清楚再寫，盡量想到各種可能性，沒想到地就當經驗，吸收起來。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。<br>其中 <a href="https://theriseofdavid.github.io/2021/08/11/Explain_Algorithm/Find_Bridge_Problem/" target="_blank" rel="noopener">Find Bridge Problem by 大衞的筆記</a> 這邊的程式碼請看這個 link 有詳細的說明。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="comment">//#define DEBUG</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1200</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; edge[MAXN];</span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt; bridge; <span class="comment">//儲存 bridge</span></span><br><span class="line"><span class="keyword">int</span> visit[MAXN], depth[MAXN], low[MAXN];</span><br><span class="line"><span class="keyword">int</span> n, m, a, b;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find_bridge</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> past, <span class="keyword">int</span> cnt)</span></span>&#123;</span><br><span class="line">    visit[root] = <span class="number">1</span>; <span class="comment">//表示走訪過</span></span><br><span class="line">    depth[root] = low[root] = cnt; <span class="comment">//邏輯證明 2.1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> node: edge[root])&#123; <span class="comment">//不斷遍地</span></span><br><span class="line">        <span class="comment">//因為是無向邊，因此雙向同個 edge 不是 bridge</span></span><br><span class="line">        <span class="keyword">if</span>(node == past) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(visit[node]) low[root] = min(low[root], depth[node]); <span class="comment">//邏輯證明 2.2</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//先進行 DFS，往下找其他的 node 有沒有辦法回到曾經走放過的節點</span></span><br><span class="line">            find_bridge(node, root, cnt+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            low[root] = min(low[root], low[node]); <span class="comment">//邏輯證明 2.3</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(low[node] &gt; depth[root])&#123;  <span class="comment">//邏輯證明 2.4</span></span><br><span class="line">                <span class="comment">//我的 bug，請引以為戒。</span></span><br><span class="line">                <span class="comment">//我原本想說按照題目要求，小的放前面。那我就先使用 if 如果 root &gt; node 就交換，</span></span><br><span class="line">                <span class="comment">//但這樣會造成接下來的 for 中 root 全部都是錯的！</span></span><br><span class="line">                <span class="comment">//請大家不要跟我一樣犯錯...</span></span><br><span class="line">                <span class="comment">//if(node &lt; root) swap(node, root); </span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//小的節點放前面，大的放後面</span></span><br><span class="line">                bridge.push_back(&#123;min(node, root), max(node, root)&#125;); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="comment">//freopen("out.txt", "w", stdout);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &amp;&amp; (n+m) != <span class="number">0</span>)&#123;</span><br><span class="line">        bridge.clear();</span><br><span class="line">        <span class="built_in">memset</span>(visit, <span class="number">0</span>, <span class="keyword">sizeof</span>(visit));</span><br><span class="line">        <span class="built_in">memset</span>(depth, <span class="number">0</span>, <span class="keyword">sizeof</span>(depth));</span><br><span class="line">        <span class="built_in">memset</span>(low, <span class="number">0</span>, <span class="keyword">sizeof</span>(low));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) edge[i].clear();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">            edge[a].push_back(b);</span><br><span class="line">            edge[b].push_back(a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visit[i]) find_bridge(i,<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sort(bridge.begin(), bridge.end());</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; bridge.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> b: bridge)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; b.first &lt;&lt; <span class="string">" "</span> &lt;&lt; b.second;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"i depth low "</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span> &lt;&lt; depth[i] &lt;&lt; <span class="string">" "</span> &lt;&lt; low[i] &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> n: edge[<span class="number">8</span>]) <span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>UVa</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>LATEX 中如何使用中文、並且搭配 listings 製作 style 卻沒辦法套用在中文身上</title>
    <url>/2021/08/17/latex/latex_chinese/</url>
    <content><![CDATA[<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><blockquote>
<p>LATEX 中有時候會需要用到中文，並且如果我們要使用 listings 來配合中文時，常會遇到一些無法顯示中文或無法編譯的問題，這邊紀錄遇到這些問題的解決方法。</p>
</blockquote>
<a id="more"></a>

<h2 id="解決-LATEX-不能編譯出中文"><a href="#解決-LATEX-不能編譯出中文" class="headerlink" title="解決 LATEX 不能編譯出中文"></a>解決 LATEX 不能編譯出中文</h2><p>解決方法如下，加入 CJKutf8 套件，並且在文章開始時加入 <code>\begin{CJK*}{UTF8}{bsmi}</code>，最後在配上 <code>\end{CJK*}</code></p>
<p>其中值得注意的是，bsmi(看起來類似於新細明體)、bkai(看起來類似於標楷體) 表示繁體中文、gmsm and gkai 表示簡體中文</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\documentclass[book, oneside, 12pt]&#123;article&#125;</span><br><span class="line">\usepackage&#123;CJKutf8&#125;</span><br><span class="line">\begin&#123;document&#125;</span><br><span class="line">\begin&#123;CJK*&#125;&#123;UTF8&#125;&#123;bsmi&#125;</span><br><span class="line"></span><br><span class="line">\section&#123;大綱&#125;</span><br><span class="line">這裡是大綱，也可輸入英文 \\</span><br><span class="line">You can also type english here.</span><br><span class="line"></span><br><span class="line">\section&#123;先備知識&#125;</span><br><span class="line">這裡是先備知識</span><br><span class="line"></span><br><span class="line">\end&#123;CJK*&#125;</span><br><span class="line">\end&#123;document&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LATEX-搭配-listings-製作-style-卻沒辦法套用在中文身上，導致編譯錯誤"><a href="#LATEX-搭配-listings-製作-style-卻沒辦法套用在中文身上，導致編譯錯誤" class="headerlink" title="LATEX 搭配 listings 製作 style 卻沒辦法套用在中文身上，導致編譯錯誤"></a>LATEX 搭配 listings 製作 style 卻沒辦法套用在中文身上，導致編譯錯誤</h2><p>主要是因為 listings 不支援中文 style。</p>
<p>其中 listings 在製作 style 時有提供 escape(逃脫) 這個用法，他可以使一些字元被忽略掉，讓一些字元不加入 style，而避免 listings 編譯崩潰。</p>
<h3 id="但如果是在程式碼中註解有使用到中文則可以解決。"><a href="#但如果是在程式碼中註解有使用到中文則可以解決。" class="headerlink" title="但如果是在程式碼中註解有使用到中文則可以解決。"></a>但如果是在程式碼中註解有使用到中文則可以解決。</h3><p>但 listings 有提供 texcl，texcl 意思為只要碰到註解標記，那就讓後面的字元全部都是註解 style，此時的 CJKutf8 支援 texcl，因此我們就可以透過此優勢來編譯！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\documentclass&#123;article&#125;</span><br><span class="line"></span><br><span class="line">\usepackage&#123;CJKutf8&#125;</span><br><span class="line">\usepackage&#123;listings&#125;</span><br><span class="line">\usepackage&#123;tikz&#125;</span><br><span class="line"></span><br><span class="line">\lstset&#123;</span><br><span class="line">  extendedchars&#x3D;false,</span><br><span class="line">  commentstyle&#x3D;\color&#123;blue&#125;,</span><br><span class="line">  texcl,</span><br><span class="line">  %escapebegin&#x3D;\obeyspaces, %我不懂 obeyspaces 意思</span><br><span class="line">  escapeinside&#x3D;&#96;&#96;, % 當遇到 &#96;&#96; 時，裡面的文字保持原本 style 不受 listing 限制</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">\begin&#123;document&#125;</span><br><span class="line">\begin&#123;CJK&#125;&#123;UTF8&#125;&#123;gbsn&#125;</span><br><span class="line"></span><br><span class="line">Text % may contain UTF-8 characters</span><br><span class="line"></span><br><span class="line">\begin&#123;lstlisting&#125;[language&#x3D;Python]</span><br><span class="line"># Comment</span><br><span class="line"># 注释 comment      with spaces       and tabs</span><br><span class="line"># コメント comment</span><br><span class="line">\end&#123;lstlisting&#125;</span><br><span class="line"></span><br><span class="line">Text % may contain UTF-8 characters</span><br><span class="line"></span><br><span class="line">\newpage</span><br><span class="line">\end&#123;CJK&#125;</span><br><span class="line">\end&#123;document&#125;</span><br></pre></td></tr></table></figure>

<h3 id="成果如下"><a href="#成果如下" class="headerlink" title="成果如下"></a>成果如下</h3><blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=17mshX0UfBuxf7MJLv06FGf3JC0cfwJ6q&export=download" alt=""></p>
</blockquote>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://wlzhong.wordpress.com/2016/10/31/latex-%E5%A6%82%E4%BD%95%E5%9C%A8%E6%96%87%E7%AB%A0%E4%B8%AD%E8%BC%B8%E5%85%A5%E4%B8%AD%E6%96%87/" target="_blank" rel="noopener">[LaTeX] 如何在文章中輸入中文 Blue’s blog</a><br><a href="https://blog.csdn.net/z_feng12489/article/details/90201217" target="_blank" rel="noopener">LaTex 代码模块中文注释 by TransientYear</a><br><a href="https://tex.stackexchange.com/questions/500135/utf-8-comment-highlighting-in-lstlisting" target="_blank" rel="noopener">UTF-8 comment highlighting in lstlisting by StackExchange</a></p>
]]></content>
      <categories>
        <category>LATEX</category>
      </categories>
      <tags>
        <tag>LATEX</tag>
      </tags>
  </entry>
  <entry>
    <title>演算法知識 - Component Tarjan&#39;s Algorithm</title>
    <url>/2021/08/31/Explain_Algorithm/Tarjan&#39;s_Algorithm/</url>
    <content><![CDATA[<h2 id="Tarjan’s-Algorithm-介紹"><a href="#Tarjan’s-Algorithm-介紹" class="headerlink" title="Tarjan’s Algorithm 介紹"></a>Tarjan’s Algorithm 介紹</h2><blockquote>
<p>Tarjan’s Algorithm 分成無向圖與有向圖兩種</p>
<ul>
<li>無向圖<br>作者還沒有複習到此題目，就還沒寫XD。</li>
<li>有向圖找出所有的 Sridge-connected Component(強連通分量)<ul>
<li>Bridge-connected Component 所有兩點之間雙向皆有路可以抵達，圖片由<a href="http://web.ntnu.edu.tw/~algo/Component.html#8" target="_blank" rel="noopener">師大演算法</a>提供，不願意讓我放上再請告知我<br><img src="https://drive.google.com/u/2/uc?id=1exHXMEPgbRfMIm8pBpkvw6f7j1DIAD2_&export=download" alt="">   </li>
</ul>
</li>
</ul>
</blockquote>
<a id="more"></a>

<h2 id="Tarjan’s-Algorithm-無向圖實作與原理"><a href="#Tarjan’s-Algorithm-無向圖實作與原理" class="headerlink" title="Tarjan’s Algorithm 無向圖實作與原理"></a>Tarjan’s Algorithm 無向圖實作與原理</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul>
<li>使用 DFS 實作</li>
<li>使用堆疊紀錄每一個經過的點</li>
<li>找出每一個點最高能回到哪一個點</li>
<li>如果這個點最高能回朔的點還是自己，則表示這個點往下的所有點都會回朔到他，形成一個 SCC，因此將堆疊裡的點刪除，直到 stack.top() 最高能回朔的點還是自己。</li>
</ul>
<h3 id="實作"><a href="#實作" class="headerlink" title="實作"></a>實作</h3><p>不廢話，直接上來</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 10020</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; edge[MAXN]; <span class="comment">//圖</span></span><br><span class="line"><span class="keyword">int</span> stk[MAXN], in_stk[MAXN]; <span class="comment">//stk 是堆疊、in_stk 確認此點是否已在堆疊上</span></span><br><span class="line"><span class="keyword">int</span> visit[MAXN]; <span class="comment">//是否有走訪過</span></span><br><span class="line"><span class="keyword">int</span> lead[MAXN], low[MAXN]; <span class="comment">//lead 表示此點為哪一個 SCC、low 表示此點最高能回到哪一個點</span></span><br><span class="line"><span class="keyword">int</span> stk_index; <span class="comment">//堆疊的 size</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scc</span><span class="params">(<span class="keyword">int</span> root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(visit[root]) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    visit[root] = low[root] = cnt++; <span class="comment">//因為是第一次接觸，先認定 root 只能回到 root</span></span><br><span class="line">    stk[++stk_index] = root; <span class="comment">// root 加入 stack， stk_index+1</span></span><br><span class="line">    in_stk[root] = <span class="number">1</span>; <span class="comment">//此點加入 stack</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it: edge[root])&#123; <span class="comment">//DFS</span></span><br><span class="line">        scc(it);</span><br><span class="line">        <span class="comment">//如果 scc 完成以後，因為 root -&gt; it 是一條邊，如果 it 可以返回到的點比 root 小，</span></span><br><span class="line">        <span class="comment">//那就改變 low[root]</span></span><br><span class="line">        <span class="keyword">if</span>(in_stk[it]) low[root] = min(low[it], low[root]); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果 low[root] 同時也是 root，表示這個點是 SCC 起點，把這個點以下的 stack，都設定為同組的 SCC</span></span><br><span class="line">    <span class="keyword">if</span>(visit[root] == low[root])&#123; </span><br><span class="line">        <span class="keyword">int</span> it;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            it = stk[stk_index--]; <span class="comment">//找出 stack.top()</span></span><br><span class="line">            in_stk[it] = <span class="number">0</span>; <span class="comment">//stack.pop()</span></span><br><span class="line">            lead[it] = root; <span class="comment">//it 的 SCC 是 root 組</span></span><br><span class="line">        &#125;<span class="keyword">while</span>(it != root); <span class="comment">//只要 it != root，表示還沒有找玩</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(visit, <span class="number">0</span>, <span class="keyword">sizeof</span>(visit));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(visit[i]) <span class="keyword">continue</span>;</span><br><span class="line">        stk_index = <span class="number">-1</span>; cnt = <span class="number">1</span>;</span><br><span class="line">        scc(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="http://web.ntnu.edu.tw/~algo/Component.html#8" target="_blank" rel="noopener">Component: Tarjan’s Algorithm by 師大演算法</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>復習了之前學習過的演算法，不要再把她忘記了拉QQ。</p>
]]></content>
      <categories>
        <category>演算法知識</category>
      </categories>
      <tags>
        <tag>程式解題</tag>
        <tag>演算法知識</tag>
        <tag>Graph Component</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa11770 - Lighting Away(DFS、Tarjan&#39;s Algorithm)</title>
    <url>/2021/08/31/UVa/UVa11770/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>Ronju 是一個保全，他每天晚上都必須讓公園裡的所有燈開啟，為此他必須每個電燈都走過去並開啟，他覺得太麻煩了，因此他買了許多不良但價格便宜的光感追蹤器，這種光感追蹤器很酷，只要他感應到 A 的電燈有開，則 B 也會開啟。</p>
<p>現在會給你已知的資訊，只要 A 被點亮，同時 B 也會開啟的光感追蹤器數組，請告訴 Ronju 自己必須去手動開幾個電燈才可以把公園裡的全部電燈打開</p>
<p><a href="https://onlinejudge.org/external/117/11770.pdf" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li><a href="https://theriseofdavid.github.io/2021/08/31/Explain_Algorithm/Tarjan' target="_blank" rel="noopener"s_Algorithm/">Tarjan’s Algorithm by 大衞的筆記</a></li>
<li>找到每個 SCC 後，確認是否可以讓兩個 SCC 被連通。</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ul>
<li>首先，先做一次 Tarjan’s Algorithm</li>
<li>假如有兩個 SCC 是可以透過一個 bridge 連通，那是不是只要點一個燈，就可以讓兩個 SCC 連起來了，那我要怎麼排除這種情況<ul>
<li>對所有的節點連接的每個連接都檢查一次 <ul>
<li>it 為 A 開啟則 B 會開啟中的 B</li>
<li>root 為 A 開啟則 B 會開啟中的 A</li>
</ul>
</li>
<li>首先我們知道，如果 <code>lead[it] != it</code> 表示，這一個 SCC 的老大並不是 it</li>
<li>如果 <code>lead[it] != lead[root]</code>，表示他們是兩個不同的 SCC，但卻可以互相連接，因此我們就可以讓 <code>lead[it]</code> 這組 SCC 不用被開啟，因為它可以被 <code>lead[root]</code> 開啟</li>
</ul>
</li>
</ul>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="http://web.ntnu.edu.tw/~algo/Component.html#8" target="_blank" rel="noopener">Component: Tarjan’s Algorithm by 師大演算法</a><br><a href="https://github.com/morris821028/UVa/blob/master/volume117/11770%20-%20Lighting%20Away.cpp" target="_blank" rel="noopener">11770 - Lighting Away by morris821028</a></p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。<br>其中 <a href="https://theriseofdavid.github.io/2021/08/31/Explain_Algorithm/Tarjan' target="_blank" rel="noopener"s_Algorithm/">Tarjan’s Algorithm by 大衞的筆記</a> 這邊的程式碼請看這個 link 有詳細的說明。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 10020</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> t, n, m, a, b, kase=<span class="number">1</span>, cnt;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; edge[MAXN];</span><br><span class="line"><span class="keyword">int</span> stk[MAXN], in_stk[MAXN];</span><br><span class="line"><span class="keyword">int</span> visit[MAXN];</span><br><span class="line"><span class="keyword">int</span> lead[MAXN], low[MAXN];</span><br><span class="line"><span class="keyword">int</span> follow[MAXN]; <span class="comment">//follow 如果數值大於等於 1 表示，這個電燈可以被另外一個電燈給開啟。</span></span><br><span class="line"><span class="keyword">int</span> stk_index;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scc</span><span class="params">(<span class="keyword">int</span> root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(visit[root]) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    visit[root] = low[root] = cnt++;</span><br><span class="line">    stk[++stk_index] = root;</span><br><span class="line">    in_stk[root] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it: edge[root])&#123;</span><br><span class="line">        scc(it);</span><br><span class="line">        <span class="keyword">if</span>(in_stk[it]) low[root] = min(low[it], low[root]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(visit[root] == low[root])&#123;</span><br><span class="line">        <span class="keyword">int</span> it;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            it = stk[stk_index--];</span><br><span class="line">            in_stk[it] = <span class="number">0</span>;</span><br><span class="line">            lead[it] = root;</span><br><span class="line">        &#125;<span class="keyword">while</span>(it != root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">isfollow</span><span class="params">(<span class="keyword">int</span> root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it: edge[root])&#123;</span><br><span class="line">        <span class="keyword">if</span>(lead[it] != it) follow[it]++;</span><br><span class="line">        <span class="keyword">if</span>(lead[root] != lead[it]) follow[lead[it]]++; <span class="comment">//如果可以從 A強通道走道 B 強通道，就刪掉 B 強通道的開燈點</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"out.txt"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123; <span class="comment">//清除資料</span></span><br><span class="line">            edge[i].clear();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123; <span class="comment">//加入邊</span></span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">            edge[a].push_back(b);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(visit, <span class="number">0</span>, <span class="keyword">sizeof</span>(visit));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123; <span class="comment">//進行 tarjan</span></span><br><span class="line">            <span class="keyword">if</span>(visit[i]) <span class="keyword">continue</span>;</span><br><span class="line">            stk_index = <span class="number">-1</span>; cnt = <span class="number">1</span>;</span><br><span class="line">            scc(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; "banana\n";</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(follow, <span class="number">0</span>, <span class="keyword">sizeof</span>(follow));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) isfollow(i);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="comment">//如果沒有辦法被其他電燈給開啟就 ans++</span></span><br><span class="line">            <span class="keyword">if</span>(!follow[i] &amp;&amp; lead[i] == i) ans++; </span><br><span class="line">            <span class="comment">//其中 lead[i] == i 則是此電燈沒辦法被其他電燈開啟，表示他會是強通道</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//for(int i = 1; i &lt;= n; i++) cout &lt;&lt; i &lt;&lt; " " &lt;&lt; group[i] &lt;&lt; "\n";</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Case "</span> &lt;&lt; kase++ &lt;&lt; <span class="string">": "</span> &lt;&lt; ans &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>UVa</tag>
        <tag>Disjoint Set 並查集</tag>
        <tag>程式解題</tag>
        <tag>Graph Component</tag>
      </tags>
  </entry>
  <entry>
    <title>R 股票回測推薦機器人首頁與目錄 - 使用 R 語言寫出你的第一個股票回測</title>
    <url>/2021/08/25/trade_life/R_backtest_example/</url>
    <content><![CDATA[<h2 id="文章概要"><a href="#文章概要" class="headerlink" title="文章概要"></a>文章概要</h2><blockquote>
<p>主要透過 R 語言來寫股票回測，我們主要是想要解決這些問題</p>
<ul>
<li>將自己的策略透過程式回測，決定此策略是否有用</li>
<li>選出適合自己的回測分析指標</li>
<li>將所有的上市股票都嘗試一遍此策略，看看有多少股票適合此策略</li>
</ul>
<p>這裡我們會用一個簡單的例子來為各位示範一遍。</p>
</blockquote>
<a id="more"></a>

<h2 id="章節，我們根據每一份程式碼來做一個章節"><a href="#章節，我們根據每一份程式碼來做一個章節" class="headerlink" title="章節，我們根據每一份程式碼來做一個章節"></a>章節，我們根據每一份程式碼來做一個章節</h2><ul>
<li><a href=""><code>Ystock_data_convert.R</code> 股票資料蒐集</a></li>
<li><code>strategy.R</code> 回測主程式</li>
<li><code>XX_strategy.R</code> 策略回測程式碼</li>
<li><code>trade_record_convert_to_profit_info.R</code> 將交易紀錄轉換為損益</li>
<li><code>backtest_statistics.R</code> 回測效益分析</li>
</ul>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>每一個人都希望可以透過操盤來賺錢，但並不是每一個人都可以順利透過操盤賺錢，但可以透過回測的方式將一些不好的策略提前逐出、將優秀的策略去無存菁。</p>
<p>股票在短時間中也是一個零和遊戲，因此風險也必須是投資者所可以承受的範圍內，不應該因為在股票交易的過程股價，而讓自己的心情開心或難過。</p>
<p>只有出場才是真的，沒有出場前都還說不一定。</p>
]]></content>
      <categories>
        <category>R語言</category>
        <category>交易人生</category>
      </categories>
      <tags>
        <tag>R語言</tag>
        <tag>學習筆記</tag>
        <tag>R dataframe</tag>
      </tags>
  </entry>
  <entry>
    <title>第六屆全國科大程式競賽心得 - 金獎(3th)心得</title>
    <url>/2021/08/19/contest_experence/ncut2021/</url>
    <content><![CDATA[<h2 id="文章概要"><a href="#文章概要" class="headerlink" title="文章概要"></a>文章概要</h2><blockquote>
<p>紀錄 2021/08/19 第六屆全國科大程式競賽心得。<br>「紀錄每個時刻，讓未來的自己不遺忘過去的自己」<br>獲得了第三屆全國科大程式競賽金獎 (3th)</p>
<p>組員有 陳力瑋、官齊芫分別簡稱為立委、阿官</p>
</blockquote>
<a id="more"></a>

<h2 id="前提概要、賽前練習"><a href="#前提概要、賽前練習" class="headerlink" title="前提概要、賽前練習"></a>前提概要、賽前練習</h2><p>這是我第二次參加這個比賽，雖然也不是第一次，但這次的隊友跟上次都完全不同，班底全都換了，老實說心裡還是會有點緊張，怕怕的。</p>
<p>不過這次比上次來說，更有系統化、持續性的練習，這次開始加入風平學長推薦的 competitive programming 4 書中練習題，並且每個禮拜都會找一天來練習 codeforces、每周寫 4 題 UVa 並附上簡單詳解。</p>
<p>從去年 12 月開始練習，大家其實也都有一點默契在、也都具備有一定的知識，其實我並不擔心會考差，只是我也不太希望考得比上次差，會難過QQ。</p>
<h2 id="賽前準備"><a href="#賽前準備" class="headerlink" title="賽前準備"></a>賽前準備</h2><p>我們比賽前時，讓大家都蒐集好各自學習的演算法，並開一個 github 團隊空間，讓大家把程式碼放進去，接下來再透過 latex 將所有的演算法透過 LATEX 編譯成一本 notebook。</p>
<p>不得不說，使用 latex 製作 notebook，其中的 mathjax and chinese 真的是夠搞死我的…，花了一堆時間去解決這些問題。</p>
<p>最後，這裡是我們這次的 notebook，就給大家看看拉。</p>
<p><a href="https://drive.google.com/file/d/1lzciqnBq3FsxkXoEokk4OKNFS3rFK2J1/view?usp=sharing" target="_blank" rel="noopener">NTUT_King notebook</a></p>
<p>也要謝謝史丹佛大學願意提供 latex 範本給我們使用，謝謝風平學長在網路上找到此資源，並與我分享。</p>
<h2 id="比賽前一天"><a href="#比賽前一天" class="headerlink" title="比賽前一天"></a>比賽前一天</h2><h3 id="從台北下去雲林"><a href="#從台北下去雲林" class="headerlink" title="從台北下去雲林"></a>從台北下去雲林</h3><p>從台北下去雲林時，我們就取票來搭高鐵，結果我前面的那個阿伯把他的椅子靠背拉超低，讓我根本不能用筆電，超級妨礙我的工作，請大家以後看到後面有人的時候請不要將靠背拉到最低，對後面的人來說非常不友善。</p>
<p>不得不說，我還是覺得雲林高鐵站真的好漂亮，就像旅館大廳一樣高級，可是卻有點空虛，因為高鐵站裡面只有高鐵，但是地都很大，有時候難免會有點冷清感。</p>
<blockquote>
<p>雲林高鐵站<br><img src="https://drive.google.com/u/2/uc?id=1qowJJS1XBt5BGfRsCx8rJdHDRdTXIBmR&export=download" alt=""></p>
</blockquote>
<h3 id="民宿價格變貴了！"><a href="#民宿價格變貴了！" class="headerlink" title="民宿價格變貴了！"></a>民宿價格變貴了！</h3><p>按照慣例，我們習慣在比賽前一天會去住宿，因為去年有去過了，所以就想說找去年的，因此我就先在網路上搜尋此民宿並且去詢問價格，結果價格比去年多 200 元…。</p>
<p>沒辦法嘛，窮學生，因此就回去找之前那間民宿的 Line，跟他們說我們要比賽，看看他會不會覺得我們是老顧客就給我們算便宜一點，按照去年價 1280 元XD。</p>
<p>結果沒有QQ，好難過。<br>而且還有點尷尬，因為我都是用一樣的帳號去問，可能讓老闆娘覺得我很白目XD，故意想問便宜的價錢，不過沒辦法嘛，我是學生又不是大老闆QAQ。</p>
<p>不過民宿雖然變貴，但是跟去年的裝潢差不多，不會很差。</p>
<blockquote>
<p>民宿與我的搭配<br><img src="https://drive.google.com/u/2/uc?id=1tXxwhQqZQeIykNJAYheGOil3VDFntfeE&export=download" alt=""></p>
</blockquote>
<h3 id="下來雲林後的探險"><a href="#下來雲林後的探險" class="headerlink" title="下來雲林後的探險"></a>下來雲林後的探險</h3><p>當我們下來到雲林高鐵站後，我們就搭計程車到虎尾，平均計程車價格在 170~190 左右，如果有些人也下來比賽，注意不要被計程車司機坑了XD。</p>
<p>再來當我們到了民宿後，民宿的鐵門早上是不會關的..，我們以為必須關，還我們一直想把他關起來，結果他有卡住阿！我還以為是我太笨了，關不起來…。</p>
<h4 id="吃飯"><a href="#吃飯" class="headerlink" title="吃飯"></a>吃飯</h4><p>到了民宿後，我們就先去吃飯。</p>
<p>我們住的民宿離虎尾科大比較近，但虎尾科大沒有好吃的QQ，要走大概 20 分鐘才會到虎尾市區QQ，我們就一路走，一路吃東西。</p>
<p>虎尾中正路上面有一堆好吃的，重點是虎尾都賣得很便宜！讓我這個台北俗覺得哇，太棒了！<br>而且南部的飲料店很酷，有一家叫做<strong>茶之魔手</strong>，他們的青茶只要 25 元，卻好喝到讓我驚豔，而且重點是我以為 25 元是大杯(700CC)，不過好像南部的大杯是 1000CC，哇喔，能花 25 元喝到 1000cc，在台北真的是有點想都別想..。</p>
<p>他們的杯子是使用保麗龍杯，讚！在台北每次拿著塑膠杯，當裡面還有冰塊的時候手都會覺得冰冰冷冷，很不舒服，虎尾就不會！</p>
<p>我上次在虎尾認識的學長宇翔學長則是告訴我說，虎尾有家很好吃的爆漿雞排，真的好吃，但是在外面不好吃QQ。疫情的關係邊走邊吃看起來都很罪惡，好難過…。<br>趕快解封拉，我想邊走邊吃。</p>
<p>然後在虎尾真的不要買有掛名台北的東西，真的不好吃，我吃了士林粥，真的不合我口味…。<br>爆漿雞排、茶之魔手，是我那天吃過最好的東西了八XD。</p>
<p>由於阿官沒有電腦，因此只有我跟立委有帶電腦來，且我們還有一年的考古題還沒寫，就想說順便在旅館裡面寫寫<br>吃飽後，我們來寫一下考古題，我拿出我帶來的 poker 提議說我們來玩大老二，誰先贏下兩場就不用寫 UVa。<br>結果我都輸，我沒辦法爽，哭阿。</p>
<blockquote>
<p>在民宿裡面的我們<br><img src="https://drive.google.com/u/2/uc?id=18MmBeWiTZM1u0avtfeQexqgqkyFccJ3O&export=download" alt=""></p>
</blockquote>
<p>再來我跟立委稍微買了些酒，吃飽後，我們在民宿裡面玩遊戲，玩99(poker)，每個人都限定一個數字，當那個人丟出那個數字後，其他人就必須喝酒XD。</p>
<p>其實蠻好玩的，只是我一直輸:(<br>才 20 分鐘我就把我的長罐啤酒喝完了…。</p>
<h4 id="洗澡"><a href="#洗澡" class="headerlink" title="洗澡"></a>洗澡</h4><p>洗澡的時候熱水一直沒有很熱，真的是快被冷死了…，下次在進去浴室之前必須都先確認浴室蓮蓬頭流出的水是熱水，不是冷水！<br>不然你在浴室裡面一直叫隊友幫你調高熱水器溫度真的很尷尬，而且你也不知道要在裡面冷多久…。</p>
<h4 id="睡覺"><a href="#睡覺" class="headerlink" title="睡覺"></a>睡覺</h4><p>下次一定要提醒我，<strong>睡雙人床一定要拿兩個棉被</strong>，千萬不能一個，要是棉被被捲走了就真的不用睡了…。<br>我的棉被過程中常常被捲走QQ，或是被熱醒！可能會有些人想說，太熱就把冷氣調冷阿，我也這麼覺得，可是我已經開 26 度，卻還是被熱醒，但是其他人都不會，我只能說這間民宿的棉被真的太暖了，一定是想要我蓋著暖被子、開最冷的冷氣，讓我舒服睡覺XD。</p>
<p>結果後面有點睡不太著，只睡了 2,3 個小時，其他時間都是被熱醒或是棉被被捲走了XD。</p>
<p>總之下次一定要拿兩件棉被，不然跟男生睡覺時真的不太喜歡在睡覺時肢體碰撞，感覺有點微妙w。</p>
<h2 id="比賽當天"><a href="#比賽當天" class="headerlink" title="比賽當天"></a>比賽當天</h2><h3 id="比賽的早上"><a href="#比賽的早上" class="headerlink" title="比賽的早上"></a>比賽的早上</h3><p>比賽當天早上，我們就順利的抵達虎尾科大報到，由於這次疫情關係，分成兩間教室，採用 2,1 方式做法，也就是 2 個人做一間教室，另一個人一間這樣。</p>
<p>跟上次一樣的開場，因為去年有比過，大部分都差不多，比較不同的是這次有了隔板，以電腦為中心左右各塞一個隔板，真的是蠻不友善的設計…，不過疫情嘛，也沒辦法，只好將就點忍耐瞜。</p>
<p>再來中午時我跟立委和阿官去印 notebook，順邊跟立委買個提神飲料，好笑的是，我買了兩杯 redbull 可以玩小七的兩杯飲料抽抽樂，我原本想要自己點，結果店員直接幫我點了，哭阿…，這..這是我的樂趣阿QAQ，不過店員幫我點到 68 折，蠻好的XD，馬上就不哭了www。</p>
<h3 id="比賽了！"><a href="#比賽了！" class="headerlink" title="比賽了！"></a>比賽了！</h3><p>接下來進到考場比賽，這次比賽的難度比以往大幅提升超多…，出了大量數學、一點點幾何，圖論、字串題的難度較輕，剩下的就是基本操作題。</p>
<p>其中我以為 E 是最難的題目，因為 E 的頁數最多，按照以往 ICPC 的慣例就是頁數最多、秒數最多的題目最難，結果在 NCUT 下完全不是！剛好反了，秒數越少的越難…，頁數多的反而講得很仔細，偏操作題，越難的題目頁數就越少…，哭阿，今年不按牌理出牌，我被唬到了…。</p>
<p>其中這次我寫 D，D 其實不難，就是很煩…，我直接寫到崩潰…，要一直轉換，害我把我的程式寫得又臭又髒，並且在快要寫完的時候讓力瑋來接手，因為我的腦袋已經到極限了QQ，不要出這種一直要人硬幹的題目拉，出點正常點，需要一點小巧思的題目，讓我甘拜下風啦。</p>
<p>接下來這次立委一共寫了 2.5 題、阿官寫了一題，我則寫了 0.5 題，看起來我最沒用QQ，這次沒有我擅長的題目QAQ。</p>
<p>其中在最後半小時的時候特別刺激，因為我們在一個小時前就先寫了四題，接下來的一個小時都沒有新的進展，我們的名次則一直都在第三名，但是其中 4~10 名都是寫了三題，且作答時數都比我們少，因為我們常常把題目送出去 WA，被扣了一些分數，但他們幾乎沒有，因此真的很怕他們隨時有一組突然寫對一題，那我們就不是第三名，是第四名了…。</p>
<p>因此其實真的很緊張，很怕別人寫出來，但是我現在也沒辦法讓我們這組再多寫一題，好無能為力QQ，真的只能交由天來決定了…。</p>
<p>比賽最後 5 分鐘，聽到某一組突然歡呼的聲音，不知道他們是不是寫到四題，超越我們，害我突然很緊張…。</p>
<p>幸好最後頒獎，我們還是第三名，我在想歡呼的那組應該不是 4~10 名八，好理家在，不然我這次回去就會有點苦悶了XD。<br>不過我也要好好改進，當我遇到這種大部分題目我都不會的時候，我應該要做甚麼，我能做甚麼，真的要好好檢討一下QQ。</p>
<p>接下來順利頒完獎後，我們也拿到了獎金 6000 元，再來我們一起平分，就順順利利的準備打道回府啦。</p>
<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1gX-KmwP9ry1evpFhnJ9xkyf6OQiOs9bR&export=download" alt=""></p>
</blockquote>
<p>不過很酷的是，這次沒有參加獎狀那些東西，就是只有拍一張照片，簡單頒獎，讓我覺得有點小小難過QQ。</p>
<blockquote>
<p>虎尾聯軍(參加這次比賽虎尾科大的所有人)的合照<br><img src="https://drive.google.com/u/2/uc?id=1lkR131E_qx1dJMK0TICrAQaWWCC6qBB9&export=download" alt=""></p>
</blockquote>
<h2 id="準備回家"><a href="#準備回家" class="headerlink" title="準備回家"></a>準備回家</h2><p>接下來我們就離開虎尾，立委昨天提議說要吃拉麵，因此我們就去吃了一碗拉麵，話說我還真不懂拉麵，因為我之前看日本的影片，似乎日本人吃拉麵都會把湯給喝完，因此我也想說把湯給喝完，但是那個湯好鹹好油阿QQ，後來果斷放棄不喝湯，出了店家後我問立委說，這家店算好吃嗎？立委跟我說還不錯，我就感到驚訝，我就說可是他的湯好鹹好油，他跟我說那樣是正常的，表示這家店很用心，我就感到很驚訝！<br>原來是我見識少阿，看來文化這種東西可能還是不太能夠太相信影片(?，還是有知道的人幫我解答下QQ。</p>
<blockquote>
<p>拉麵照片<br><img src="https://drive.google.com/u/2/uc?id=1hTmch_bMMo02jTVcZ-spdnvRwprHscex&export=download" alt=""></p>
</blockquote>
<p>接下來我們就搭計程車回到雲林高鐵站，不得不說，雲林高鐵站是真的好繁華阿…，要是旁邊不要那麼的荒涼就好了XD。<br>計程車司機還蠻有趣的，一直跟我幹話，因為我不太能夠進去前座…，我覺得不是我胖啊，就書包太大了，不好進去，他車子太小了齁XD。然後一直被隊友還有司機開玩笑，哭阿哭阿。</p>
<p>到了雲林高鐵站後，其實也才 6 點，但是我是訂 9 點的高鐵…，不小心訂得太晚了..，害我們整組隊員一起在高鐵站白等了 3 小時，我很抱歉&gt;&lt;，下次我會改進的！</p>
<p>總之還是謝謝阿官、立委陪我一起比賽，要是沒有他們，我這次真的不會拿到第三名。</p>
<h2 id="檢討"><a href="#檢討" class="headerlink" title="檢討"></a>檢討</h2><p>最後還是要稍微檢討一下，我覺得這次其實沒有太大問題，就是我的一些過去心態必須要改正，不可以一直按照過去經驗行事，畢竟比賽都是當下的，你還是不可以說，因為之前的比賽題目都怎樣怎樣，所以接下來會怎樣怎樣，這樣會出意外的。</p>
<p><strong>要將所有題目都看完，不可以因為題目太多、秒數太久而不看，對待每一道題目都是一視同仁，不可以偏心</strong>，這就是我打這個比賽最需要檢討的地方了。</p>
<p><strong>還有就是要多拍一些照片，多紀念，太久沒有出門了，一直忘記在路上多拍照，留下許多回憶</strong>。</p>
]]></content>
      <categories>
        <category>競賽心得</category>
      </categories>
      <tags>
        <tag>大學Life</tag>
        <tag>ICPC</tag>
        <tag>程式比賽</tag>
        <tag>競賽心得</tag>
        <tag>人生旅途</tag>
      </tags>
  </entry>
  <entry>
    <title>演算法知識 - Component Kosaraju&#39;s Algorithm</title>
    <url>/2021/08/31/Explain_Algorithm/Kosaraju_algorithm/</url>
    <content><![CDATA[<h2 id="Kosaraju’s-Algorithm-介紹"><a href="#Kosaraju’s-Algorithm-介紹" class="headerlink" title="Kosaraju’s Algorithm 介紹"></a>Kosaraju’s Algorithm 介紹</h2><blockquote>
<p>Kosaraju’s Algorithm 可以找出有向圖的 SCC</p>
<ul>
<li>Sridge-connected Component(強連通分量)<ul>
<li>Bridge-connected Component 所有兩點之間雙向皆有路可以抵達，圖片由<a href="http://web.ntnu.edu.tw/~algo/Component.html#8" target="_blank" rel="noopener">師大演算法</a>提供，不願意讓我放上再請告知我<br><img src="https://drive.google.com/u/2/uc?id=1exHXMEPgbRfMIm8pBpkvw6f7j1DIAD2_&export=download" alt="">   </li>
</ul>
</li>
</ul>
</blockquote>
<a id="more"></a>

<h2 id="Kosaraju’s-Algorithm-原理"><a href="#Kosaraju’s-Algorithm-原理" class="headerlink" title="Kosaraju’s Algorithm 原理"></a>Kosaraju’s Algorithm 原理</h2><h3 id="證明"><a href="#證明" class="headerlink" title="證明"></a>證明</h3><ul>
<li>如果是 A、B、C 三個點都為 SCC，那我從 A 反方向走或正方向走都能走到 A</li>
<li>其中圖中有一條邊為 A -&gt; D<ul>
<li>如果有一個邊是 D -&gt; A，那我們就可以表示 A、B、C、D 都是 SCC</li>
</ul>
</li>
<li>因此我們準備一張反向圖，一樣從 A 出發<ul>
<li>題目給的圖如果是 A -&gt; B，則反向圖為 B -&gt; A</li>
</ul>
</li>
<li>走訪 A、B、C<ul>
<li>同理，如果我能夠滿足此上述條件就表示 A、B、C 為 SCC</li>
</ul>
</li>
<li>無法走訪 A、D</li>
<li>不可以的話，他們就不是同一組 SCC</li>
</ul>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul>
<li>使用 DFS 實作</li>
<li>先進行一次 DFS，並由離開 DFS 的節點順序，依序放入 vector，定義為 <code>path</code></li>
<li>再來根據 <code>path</code>，從最後被加入的節點不斷往前疊代進行 DFS。<ul>
<li>這一次 dfs 中，此節點能夠碰到的所有節點都是同一組 scc。</li>
</ul>
</li>
</ul>
<h2 id="Kosaraju’s-Algorithm-實作"><a href="#Kosaraju’s-Algorithm-實作" class="headerlink" title="Kosaraju’s Algorithm 實作"></a>Kosaraju’s Algorithm 實作</h2><p>不廢話，直接上來</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1020</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; edge[MAXN]; <span class="comment">//題目圖</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rev_edge[MAXN]; <span class="comment">//反向圖</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path; <span class="comment">//紀錄離開 DFS 的節點順序</span></span><br><span class="line"><span class="keyword">int</span> visit[MAXN]; </span><br><span class="line"><span class="keyword">int</span> group[MAXN]; <span class="comment">//判斷此節點在哪一個組</span></span><br><span class="line"><span class="keyword">int</span> cnt, a, b, q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(visit[root]) <span class="keyword">return</span>;</span><br><span class="line">    visit[root] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it: edge[root])&#123;</span><br><span class="line">        dfs1(it);</span><br><span class="line">    &#125;</span><br><span class="line">    path.push_back(root); <span class="comment">//紀錄 DFS 離開的節點</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> ancestor)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(visit[root]) <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">    visit[root] = <span class="number">1</span>;</span><br><span class="line">    group[root] = ancestor; <span class="comment">//root 跟 ancestor 在同一個 SCC</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it: rev_edge[root])&#123;</span><br><span class="line">       dfs2(it, ancestor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kosoraju</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; q; i++)&#123; <span class="comment">//q 為邊的長度 </span></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        edge[a].push_back(b); <span class="comment">//題目圖</span></span><br><span class="line">        rev_edge[b].push_back(a); <span class="comment">//反向圖</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(visit, <span class="number">0</span>, <span class="keyword">sizeof</span>(visit));</span><br><span class="line">    path.clear();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; cnt; i++)&#123; <span class="comment">//第一次 DFS</span></span><br><span class="line">        <span class="keyword">if</span>(!visit[i]) dfs1(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(visit, <span class="number">0</span>, <span class="keyword">sizeof</span>(visit));</span><br><span class="line">    <span class="built_in">memset</span>(group, <span class="number">0</span>, <span class="keyword">sizeof</span>(group));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = path.size()<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--)&#123; <span class="comment">//尋找以 path[i] 為主的 SCC 有哪些節點</span></span><br><span class="line">        <span class="keyword">if</span>(!visit[path[i]])&#123;</span><br><span class="line">            dfs2(path[i], path[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="http://web.ntnu.edu.tw/~algo/Component.html#9" target="_blank" rel="noopener">Component: Kosaraju’s Algorithm by 師大演算法</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>專家們、科學家們研究出來的成果希望我都可以把他們吸收進去，並且運用在我未來的道路上。</p>
]]></content>
      <categories>
        <category>演算法知識</category>
      </categories>
      <tags>
        <tag>程式解題</tag>
        <tag>演算法知識</tag>
        <tag>Graph Component</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa11709 - Trust groups(DFS、Kosaraju&#39;s Algorithm)</title>
    <url>/2021/08/31/UVa/UVa11709/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>由於公司內部的員工產生了不信任的問題導致公司生產力降低，為了解決此問題，因此公司決定讓互相信任的人組成一組，來增加生產力。<br>我們希望可以在公司的員工們，分成最小的組別數。</p>
<p><a href="https://onlinejudge.org/external/117/11709.pdf" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li><a href="https://theriseofdavid.github.io/2021/08/31/Explain_Algorithm/Kosaraju_algorithm/" target="_blank" rel="noopener">Kosaraju’s Algorithm by 大衞的筆記</a></li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>Kosaraju’s Algorithm 的模板題，直接套用即可。</p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://hackmd.io/@txya900619/Uva11709" target="_blank" rel="noopener">Uva11709 - Trust groups by txya900619</a><br><a href="http://web.ntnu.edu.tw/~algo/Component.html#9" target="_blank" rel="noopener">Component: Kosaraju’s Algorithm by 師大演算法</a></p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。<br>其中 <a href="https://theriseofdavid.github.io/2021/08/31/Explain_Algorithm/Tarjan' target="_blank" rel="noopener"s_Algorithm/">Tarjan’s Algorithm by 大衞的筆記</a> 這邊的程式碼請看這個 link 有詳細的說明。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1020</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">string</span> a, b;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; name;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; edge[MAXN];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rev_edge[MAXN];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line"><span class="keyword">int</span> visit[MAXN];</span><br><span class="line"><span class="keyword">int</span> group[MAXN];</span><br><span class="line"><span class="keyword">int</span> t, p, cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(visit[root]) <span class="keyword">return</span>;</span><br><span class="line">    visit[root] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it: edge[root])&#123;</span><br><span class="line">        dfs1(it);</span><br><span class="line">    &#125;</span><br><span class="line">    path.push_back(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> ancestor)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(visit[root]) <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">    visit[root] = <span class="number">1</span>;</span><br><span class="line">    group[root] = ancestor;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it: rev_edge[root])&#123;</span><br><span class="line">       dfs2(it, ancestor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"out.txt"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; p &gt;&gt; t &amp;&amp; (t+p)!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">cin</span>.ignore();</span><br><span class="line">        name.clear();</span><br><span class="line">        cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p; i++)&#123; <span class="comment">//清除資料，將名子進行 hash</span></span><br><span class="line">            edge[cnt].clear();</span><br><span class="line">            rev_edge[cnt].clear();</span><br><span class="line"></span><br><span class="line">            getline(<span class="built_in">cin</span>, a);</span><br><span class="line">            name[a] = cnt++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; i++)&#123;</span><br><span class="line">            getline(<span class="built_in">cin</span>, a);</span><br><span class="line">            getline(<span class="built_in">cin</span>, b);</span><br><span class="line">            edge[name[a]].push_back(name[b]); <span class="comment">//題目圖</span></span><br><span class="line">            rev_edge[name[b]].push_back(name[a]); <span class="comment">//反向圖</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(visit, <span class="number">0</span>, <span class="keyword">sizeof</span>(visit));</span><br><span class="line">        path.clear();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; cnt; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visit[i]) dfs1(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>; <span class="comment">//總共有幾組 SCC</span></span><br><span class="line">        <span class="built_in">memset</span>(visit, <span class="number">0</span>, <span class="keyword">sizeof</span>(visit));</span><br><span class="line">        <span class="built_in">memset</span>(group, <span class="number">0</span>, <span class="keyword">sizeof</span>(group));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = path.size()<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--)&#123; </span><br><span class="line">            <span class="keyword">if</span>(!visit[path[i]])&#123;</span><br><span class="line">                dfs2(path[i], path[i]);</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//for(int i = 1; i &lt; cnt; i++)&#123;</span></span><br><span class="line">        <span class="comment">//    cout &lt;&lt; i &lt;&lt; " " &lt;&lt; group[i] &lt;&lt; "\n";</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">"\n"</span>; <span class="comment">//輸出答案</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>Graph Component</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa11831 - Sticker Collector Robot(DFS)</title>
    <url>/2021/08/31/UVa/UVa11831/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>給你一個地圖，地圖中有貼紙與柱子，機器人碰到柱子則無法前進，碰到貼紙則會蒐集貼紙<br>給你機器人的位置，並告訴你機器人的行動方式，請告訴機器人可以蒐集幾個貼紙。</p>
<p>機器人會向左轉、向右轉、往前走三個動作，並告訴妳一開始機器人面對的方位是哪邊。</p>
<p><a href="https://onlinejudge.org/external/118/11831.pdf" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li>模擬操作</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ul>
<li>由於機器人只有東西南北四個方位，而每個方位都有一個左邊、一個右邊，因此我們可以直接將各種情況列舉出來，下面舉例<ul>
<li>北方的左邊是西邊</li>
<li>北方的右邊是東邊</li>
</ul>
</li>
<li>用一個 <code>visit</code> 來表示地圖中的這個 cell 有沒有被走過，如果有且這個 cell 有貼紙則答案 +1。</li>
<li>將邊界更輕鬆處理，在第 0 層與 \(n+1\) 層的 cell 全部都設定為牆壁的</li>
</ul>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://blog.csdn.net/mobius_strip/article/details/49493383" target="_blank" rel="noopener">UVa 11831 - Sticker Collector Robot by 小白菜又菜</a></p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 120</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, s;</span><br><span class="line"><span class="keyword">int</span> x, y, ans;</span><br><span class="line"><span class="keyword">int</span> visit[MAXN][MAXN]; <span class="comment">//判斷是不是第一次經過此 cell，避免撞牆後重複蒐集地圖</span></span><br><span class="line"><span class="built_in">string</span> graph[MAXN]; <span class="comment">//地圖</span></span><br><span class="line"><span class="built_in">string</span> line, direct, pillars; <span class="comment">//direct 機器人的方位, pillars 表示 row 都是柱子(邊界)</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; L; <span class="comment">//L[方位A] = 方位B，方位 A 的左邊是方位 B</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; R; <span class="comment">//與上面概念向通</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">walk</span><span class="params">(<span class="keyword">char</span> cmd)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(cmd == <span class="string">'F'</span>)&#123; <span class="comment">//如果是往前走</span></span><br><span class="line">        <span class="comment">//如果往此方向走，並且不撞到支柱，就讓機器人往那邊走</span></span><br><span class="line">        <span class="keyword">if</span>(direct == <span class="string">"N"</span> &amp;&amp; graph[x<span class="number">-1</span>][y] != <span class="string">'#'</span>) x = x<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(direct == <span class="string">"S"</span> &amp;&amp; graph[x+<span class="number">1</span>][y] != <span class="string">'#'</span>) x = x+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(direct == <span class="string">"O"</span> &amp;&amp; graph[x][y<span class="number">-1</span>] != <span class="string">'#'</span>) y = y<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(direct == <span class="string">"L"</span> &amp;&amp; graph[x][y+<span class="number">1</span>] != <span class="string">'#'</span>) y = y+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(!visit[x][y] &amp;&amp; graph[x][y] == <span class="string">'*'</span>) ans++; <span class="comment">//如果第一次走到且此 cell 有貼紙則答案+1</span></span><br><span class="line">        visit[x][y] = <span class="number">1</span>; <span class="comment">//表示並不是第一次經過</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(cmd == <span class="string">'D'</span>) direct = R[direct]; <span class="comment">//轉向</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(cmd == <span class="string">'E'</span>) direct = L[direct];</span><br><span class="line">    <span class="comment">//cout &lt;&lt; "cmd x y graph " &lt;&lt; cmd &lt;&lt; " " &lt;&lt; x &lt;&lt; " " &lt;&lt; y &lt;&lt; " " &lt;&lt; direct &lt;&lt; "\n";</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"out.txt"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line"></span><br><span class="line">    L[<span class="string">"N"</span>] = <span class="string">"O"</span>; L[<span class="string">"O"</span>] = <span class="string">"S"</span>; L[<span class="string">"S"</span>] = <span class="string">"L"</span>, L[<span class="string">"L"</span>] = <span class="string">"N"</span>; <span class="comment">//將各種方位轉向都列舉出來</span></span><br><span class="line">    R[<span class="string">"N"</span>] = <span class="string">"L"</span>; R[<span class="string">"L"</span>] = <span class="string">"S"</span>; R[<span class="string">"S"</span>] = <span class="string">"O"</span>, R[<span class="string">"O"</span>] = <span class="string">"N"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; s &amp;&amp; (n+m+s) != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(visit, <span class="number">0</span>, <span class="keyword">sizeof</span>(visit));</span><br><span class="line">        pillars = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m+<span class="number">1</span>; i++) pillars += <span class="string">"#"</span>; <span class="comment">//建造邊界牆</span></span><br><span class="line"></span><br><span class="line">        graph[<span class="number">0</span>] = pillars; <span class="comment">//分析第三點</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; line;</span><br><span class="line">            graph[i] = <span class="string">"#"</span> + line + <span class="string">"#"</span>; <span class="comment">//最左邊、最右邊都加入支柱，避免邊界額外判斷</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(graph[i][j] == <span class="string">'N'</span> || graph[i][j] == <span class="string">'S'</span> || graph[i][j] == <span class="string">'L'</span> || graph[i][j] == <span class="string">'O'</span>)&#123; <span class="comment">//找到機器人現在方位，並且定位</span></span><br><span class="line">                    x = i;</span><br><span class="line">                    y = j;</span><br><span class="line">                    direct = graph[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        graph[n+<span class="number">1</span>] = pillars; <span class="comment">//分析第三點</span></span><br><span class="line"></span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; line;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; line.length(); i++)&#123; <span class="comment">//執行機器人全部指令</span></span><br><span class="line">            walk(line[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">"\n"</span>; <span class="comment">//輸出答案</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>UVa</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>演算法知識 - Kruskal Algorithm</title>
    <url>/2021/09/06/Explain_Algorithm/kruskal/</url>
    <content><![CDATA[<h2 id="Kruskal-Algorithm-介紹"><a href="#Kruskal-Algorithm-介紹" class="headerlink" title="Kruskal Algorithm 介紹"></a>Kruskal Algorithm 介紹</h2><blockquote>
<p>主要是在一張圖中組合成一顆樹，其中每一條邊都有一個成本，且要求這顆樹的總和成本必須要是最小。<br>時間複雜度為 \(O(E \log E)\)</p>
<p>主要用來找出一張圖中的最小生成樹、最大生成樹</p>
</blockquote>
<a id="more"></a>

<h2 id="Kruskal-Algorithm-證明與實作"><a href="#Kruskal-Algorithm-證明與實作" class="headerlink" title="Kruskal Algorithm 證明與實作"></a>Kruskal Algorithm 證明與實作</h2><h3 id="證明"><a href="#證明" class="headerlink" title="證明"></a>證明</h3><ul>
<li>不難理解，我們可以知道從最小的邊開始組合成的一棵樹一定是總成本最小的</li>
<li>但是有可能再拿最小的邊時，發現這個邊與其他邊有衝突<ul>
<li>舉例：(1,3) 成本 2，(1,3) 成本 3，(1,4) 成本 10</li>
<li>如果從最小的拿，那我們必須避免使用 (1,3) 成本 3 </li>
</ul>
</li>
<li>因此我們使用並查集，只要拿最小的邊，並且判斷這兩個邊的節點是否在同個 set 裡，如果有那就要捨棄掉，因為已經有更小的邊連接他們了。<ul>
<li>可能會有疑問，那有沒有可能這個生成樹是多顆生成樹，其實並沒有被連接</li>
<li>只要保證他是一張圖，那麼圖中的每一個點我們會遍地經歷過，就勢必會經過連接點，此時若沒有更小的邊，那我們就會加入他，並透過 disjoint set 來合併這兩個生成樹</li>
<li>因此，我們必須確認他是<strong>一張圖</strong>，而不是兩張圖，因為如果是兩張分裂的圖那麼 set 很高機率會變拆成兩組。</li>
<li>此時就變成有兩顆生成樹</li>
</ul>
</li>
<li>不斷連接，只到將所有的邊都使用過。</li>
</ul>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul>
<li>使用 disjoint set 判斷每一個節點現在屬於哪一個生成樹</li>
<li>再來將每一個 edge 放入 vector，並 sort</li>
<li>使用 for loop，確認邊的節點是否有在同個 set<ul>
<li>如果都在同個 set，則不需要這個 edge</li>
<li>如果不同，則加入此 edge，並記錄</li>
</ul>
</li>
</ul>
<h2 id="Kruskal-Algorithm-實作"><a href="#Kruskal-Algorithm-實作" class="headerlink" title="Kruskal Algorithm 實作"></a>Kruskal Algorithm 實作</h2><p>不廢話，直接上來</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 200020</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> a, b, c;</span><br><span class="line"><span class="keyword">int</span> p[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, v, c; <span class="comment">//u,v 分別為邊的節點， c 是成本</span></span><br><span class="line">    </span><br><span class="line">    edge(): u(<span class="number">0</span>), v(<span class="number">0</span>), c(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    edge(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c): u(u), v(v), c(c) &#123;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> edge&amp; other) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c &lt; other.c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;edge&gt; node;</span><br><span class="line"><span class="built_in">vector</span>&lt;edge&gt; MST; <span class="comment">//最小生成樹</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_root</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; "find_root " &lt;&lt; x &lt;&lt; "\n";</span></span><br><span class="line">    <span class="keyword">if</span>(p[x] != x) <span class="keyword">return</span> p[x] = find_root(p[x]);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kruskal</span><span class="params">()</span></span>&#123;</span><br><span class="line">    node.clear();</span><br><span class="line">    MST.clear();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) p[i] = i; <span class="comment">//init disjoint set</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c; <span class="comment">//輸入邊、成本</span></span><br><span class="line">        node.push_back(&#123;a,b,c&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(node.begin(), node.end()); <span class="comment">//排序，這邊排序方式為遞增</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(edge it: node)&#123;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; it.u &lt;&lt; " " &lt;&lt; it.v &lt;&lt; " " &lt;&lt; it.c &lt;&lt; "\n";</span></span><br><span class="line">        <span class="comment">//cout &lt;&lt; p[3] &lt;&lt; " " &lt;&lt; p[4] &lt;&lt; "\n";</span></span><br><span class="line">        <span class="keyword">int</span> pu = find_root(it.u); <span class="comment">//判斷邊的節點們是否都在同個 set </span></span><br><span class="line">        <span class="keyword">int</span> pv = find_root(it.v);</span><br><span class="line">        <span class="keyword">if</span>(pu != pv)&#123; <span class="comment">//分析 3-1</span></span><br><span class="line">                p[pv] = pu;</span><br><span class="line">                MST.push_back(it); <span class="comment">//記錄此 edge</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(edge it: MST)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; it.u &lt;&lt; <span class="string">" "</span> &lt;&lt; it.v &lt;&lt; <span class="string">" "</span> &lt;&lt; it.c &lt;&lt; <span class="string">"\n"</span>; <span class="comment">//輸出所有邊</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="http://web.ntnu.edu.tw/~algo/SpanningTree.html" target="_blank" rel="noopener">Minimum Spanning Tree: Kruskal’s Algorithm by 師大演算法</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>專家們、科學家們研究出來的成果希望我都可以把他們吸收進去，並且運用在我未來的道路上。</p>
]]></content>
      <categories>
        <category>演算法知識</category>
      </categories>
      <tags>
        <tag>程式解題</tag>
        <tag>Kruskal&#39;s algorithm</tag>
        <tag>演算法知識</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa11631 - Dark Roads(Kruskal)</title>
    <url>/2021/09/06/UVa/UVa11631/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>Byteland 這座城市想要節省電費，因此想要在晚上把路燈給關掉，每一公尺就需要花一塊錢，但是要是整座城市都沒有路燈就太可怕了！於是 Byteland 折衷，她希望可以有一個明亮的路徑通往到每一個道路上，因此他想問說，如果只有一條明亮的路徑並且可以通往到每個道路上，那我將其他燈都關掉可以省下多少成本</p>
<p><a href="https://onlinejudge.org/external/116/11631.pdf" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li><a href="https://theriseofdavid.github.io/2021/09/06/Explain_Algorithm/kruskal/" target="_blank" rel="noopener">Kruskal by 大衞的筆記</a></li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ul>
<li>只要看懂題目大意後就會知道，其實是一個最小生成樹，只要讓每一條路可以抵達其他路即可。</li>
</ul>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://www.pinghenotes.com/UVa-11631-Dark-Roads/" target="_blank" rel="noopener">UVa 11631 - Dark Roads</a></p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。</p>
<p>關於 kruskal 詳解請參考 <a href="https://theriseofdavid.github.io/2021/09/06/Explain_Algorithm/kruskal/" target="_blank" rel="noopener">Kruskal by 大衞的筆記</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 200020</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> a, b, c;</span><br><span class="line"><span class="keyword">int</span> p[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, v, c; </span><br><span class="line">    edge()&#123;</span><br><span class="line">        u = <span class="number">0</span>, v = <span class="number">0</span>, c = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    edge(<span class="keyword">int</span> _u, <span class="keyword">int</span> _v, <span class="keyword">int</span> _c)&#123;</span><br><span class="line">        u = _u, v = _v, c = _c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> edge&amp; other) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c &lt; other.c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;edge&gt; node;</span><br><span class="line"><span class="built_in">vector</span>&lt;edge&gt; remain; <span class="comment">//放入沒有被用入 edge，記錄省下成本</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_root</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; "find_root " &lt;&lt; x &lt;&lt; "\n";</span></span><br><span class="line">    <span class="keyword">if</span>(p[x] != x) <span class="keyword">return</span> p[x] = find_root(p[x]);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"out.txt"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &amp;&amp; (n+m) != <span class="number">0</span>)&#123;</span><br><span class="line">        node.clear();</span><br><span class="line">        remain.clear();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) p[i] = i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">            node.push_back(&#123;a,b,c&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(node.begin(), node.end());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(edge it: node)&#123;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; it.u &lt;&lt; " " &lt;&lt; it.v &lt;&lt; " " &lt;&lt; it.c &lt;&lt; "\n";</span></span><br><span class="line">            <span class="comment">//cout &lt;&lt; p[3] &lt;&lt; " " &lt;&lt; p[4] &lt;&lt; "\n";</span></span><br><span class="line">            <span class="keyword">int</span> pu = find_root(it.u);</span><br><span class="line">            <span class="keyword">int</span> pv = find_root(it.v);</span><br><span class="line">            <span class="keyword">if</span>(pu != pv) p[pv] = pu;</span><br><span class="line">            <span class="keyword">else</span> remain.push_back(it); <span class="comment">//紀錄沒被用到的邊</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(edge it: remain) ans += it.c; <span class="comment">//計算總和</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>Kruskal&#39;s algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa12442 - Forwarding Emails(DFS)</title>
    <url>/2021/09/06/UVa/UVa12442/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>有一封信需要給大家知道，而每一個人都會將信轉寄給另外一個人(不會轉寄給第二個人)，你必須找出寄給誰才可以讓最多的人知道。</p>
<p>請輸出，從誰開始轉寄可以讓最多人知道。<br><a href="https://onlinejudge.org/external/124/12442.pdf" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li>DFS 概念轉換</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ul>
<li>由於題目有說明每一個人只會轉寄給另外一個人，那我們的目標就是知道每一個人他不斷往下轉寄後，最多可以轉寄給幾個人</li>
<li>因此直接使用 DFS 實作</li>
<li>因為不可能每一個人都 DFS，會 TLE，因此優化<ul>
<li>舉例： A 給 B，B 給 C，C 給 D</li>
<li>那我們如果從 B 開始寄信，那麼 C、D 我們是不是也知道他最多可以轉寄給幾個人(DFS特性)</li>
<li>因此只要 DFS 跑過的，我們就不需要再跑一次。</li>
<li>但是假如接下來我們跑 A，那我們是不是就直接找出 B 最多轉寄 3 個？<ul>
<li>不行，要注意迴圈問題</li>
<li>舉例：A 給 B，B 給 C，C 給 A，D 給 A</li>
<li>如果從 C 開始跑，那順序會是 C -&gt; A -&gt; B。</li>
<li>此時再來從 D 繼續跑，那 D 碰到 A，直接收到 A 最多轉寄兩個，輸出答案</li>
<li>但其實不對，從 D 開始跑，可以轉寄給四個</li>
</ul>
</li>
</ul>
</li>
<li>為了避免 DFS 拓樸排序的問題，因此我們只能<strong>保證知道 DFS 的節點，最多可以轉寄幾個</strong>，但沒辦法確認沒有被 DFS 的節點碰到有被 DFS 過的節點，此時，有被 DFS 過的節點最多轉寄的信已經被我們求出。</li>
</ul>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://github.com/nur-shuvo/UVA-solutions/blob/master/uva%20%2012442%20Forwarding%20%20Emails%20%20.cpp" target="_blank" rel="noopener">uva 12442 Forwarding Emails by nur-shuvo</a></p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 50020</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> t, n, kase = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> a, b, cnt;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; edge[MAXN];</span><br><span class="line"><span class="keyword">int</span> visit[MAXN], flag[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(visit[root]) <span class="keyword">return</span>; <span class="comment">//有被經過，因此不再重複</span></span><br><span class="line">    visit[root] = <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> it : edge[root])&#123;</span><br><span class="line">        dfs(it);</span><br><span class="line">        cnt++; <span class="comment">//紀錄總長度</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//由於只能轉寄給一個人，因此從起點到 root 只有一種路徑，經過後就不會再重複經過。</span></span><br><span class="line">    <span class="comment">//但有可能這個路徑本身是 circle，但不會出現兩個以上 circle，因此不會發生衝突。</span></span><br><span class="line">    <span class="comment">//如果有兩個以上 circle 表示，會有一個人可以轉寄給兩個人</span></span><br><span class="line">    visit[root] = <span class="number">0</span>; </span><br><span class="line">    flag[root] = <span class="number">1</span>; <span class="comment">//分析 2-1,2-2,2-3,4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"out.txt"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) edge[i].clear(); <span class="comment">//清除資料</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">            edge[a].push_back(b); <span class="comment">//加入邊</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(visit, <span class="number">0</span>, <span class="keyword">sizeof</span>(visit));</span><br><span class="line">        <span class="built_in">memset</span>(flag, <span class="number">0</span>, <span class="keyword">sizeof</span>(flag));</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, ans_cnt = <span class="number">0</span>; <span class="comment">//ans 是從誰寄信最好，ans_cnt 則是最多可以轉寄給幾個人</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(flag[i]) <span class="keyword">continue</span>;</span><br><span class="line">            cnt = <span class="number">0</span>;</span><br><span class="line">            dfs(i);</span><br><span class="line">            <span class="keyword">if</span>(ans_cnt &lt; cnt)&#123; <span class="comment">//如果現在的答案比較大，就替換他</span></span><br><span class="line">                ans = i;</span><br><span class="line">                ans_cnt = cnt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Case "</span> &lt;&lt; ++kase &lt;&lt; <span class="string">": "</span> &lt;&lt; ans &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>UVa</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa1265 - Tour Belt(Kruskal)</title>
    <url>/2021/09/08/UVa/UVa1265/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>Korea 群島可以組成很多種旅遊行程，那如果是兩個島連在一起所產生的好處稱為 SE(協同效應)，再來我們定義協同效應</p>
<ul>
<li>有一張連通圖裡面有 n 個頂點、m 個邊</li>
<li>SE 必須使用兩頂點組成(也就是邊)，且不可以有重複地點用到</li>
<li>再來我們要在一張圖中組成協同效應，其中協同效應必須要選大的，並且要在圖中找出最多的 SE。</li>
<li>如果可以有多組以上的協同效應，那麼我們必須確認我們選的邊必須要大於內部的協同效應</li>
</ul>
<p>簡單來說就是使用 kruskal 找出最大的 SE，並檢查有沒有辦法再跟其他 SE 組成一個更大的 SE。<br>並將所有 SE 的 size 總合起來輸出。</p>
<p>我題目講的沒有很清楚，這題要去看題目才好理解，不太好解釋。有點出得很難懂..<br><a href="https://onlinejudge.org/external/12/1265.pdf" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li>超級讚的英文</li>
<li><a href="https://theriseofdavid.github.io/2021/09/06/Explain_Algorithm/kruskal/" target="_blank" rel="noopener">Kruskal by 大衞的筆記</a></li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ul>
<li>由於有一種可能性是 SE 與 SE 再組成更大的 SE</li>
<li>題目有說明 SE 與 SE 中間不可以有比這兩個 SE 之間更大的 SE，否則應該拿更大的 SE 去跟別的 SE 產生新的 SE。</li>
<li>我們要證明第二點，那就先使用 Kruskal 不斷地從最大點 SE 做生成<ul>
<li>只要生成樹的內部 SE 沒有比生成樹外部的 SE 小，我們就可以知道這邊會再多一組 SE</li>
<li>因為 SE 會先從最大的開始產生，因此兩個大 SE 如果裡面包著小 SE，那麼那兩個大 SE 還是可以再組成一組 SE</li>
<li>因此只要確認<ul>
<li><code>兩個大 SE 包著小 SE 最大值</code> 大於 <code>兩個大 SE 以外的 SE 最小值</code> 就可以計入答案</li>
<li>因為如果<code>兩個大 SE 以外的 SE</code> 還有更小值的話，那麼應該要讓兩個大 SE 去包她才對。 </li>
</ul>
</li>
</ul>
</li>
<li>剩下的直接看 code 理解。</li>
</ul>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://mypaper.pchome.com.tw/zerojudge/post/1325001404" target="_blank" rel="noopener">uva 1265 - Tour Belt by morris</a><br><a href="https://blog.csdn.net/keshuai19940722/article/details/48379693" target="_blank" rel="noopener">uva 1265 - Tour Belt（生成树） by CDSN</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>這一次真的寫不太好，但是不太知道要怎麼解釋，非常抱歉，請大家見諒</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。</p>
<p>關於 kruskal 詳解請參考 <a href="https://theriseofdavid.github.io/2021/09/06/Explain_Algorithm/kruskal/" target="_blank" rel="noopener">Kruskal by 大衞的筆記</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 5020</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> t, n, m;</span><br><span class="line"><span class="keyword">int</span> a, b, c;</span><br><span class="line"><span class="keyword">int</span> p[MAXN], length[MAXN]; <span class="comment">//length 表示以 i 為中心的生成樹，裡面的 sum SE 有多少</span></span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt; edges[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, v, c; <span class="comment">//u,v 分別為邊的節點， c 是成本</span></span><br><span class="line">    edge(): u(<span class="number">0</span>), v(<span class="number">0</span>), c(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    edge(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c): u(u), v(v), c(c) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> edge&amp; other) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c &gt; other.c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;edge&gt; node;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_root</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; "find_root " &lt;&lt; x &lt;&lt; "\n";</span></span><br><span class="line">    <span class="keyword">if</span>(p[x] != x) <span class="keyword">return</span> p[x] = find_root(p[x]);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="comment">//inedge 內部的 SE 大小，outedge 外部的 edge 大小，預設是最小</span></span><br><span class="line">    <span class="keyword">int</span> inedge = INF, outedge = <span class="number">0</span>; <span class="comment">//inedge = inside edge, outedge = outside edge</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123; <span class="comment">//針對每一個邊仔細檢查</span></span><br><span class="line">        <span class="keyword">if</span>(x != find_root(i)) <span class="keyword">continue</span>; <span class="comment">//如果兩個生成樹並不一樣，表示內部沒有 SE</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it: edges[i])&#123; </span><br><span class="line">            <span class="comment">//如果生成樹都一樣，那將內部最大 SE 取出</span></span><br><span class="line">            <span class="keyword">if</span>(find_root(it.first) == x) inedge = min(inedge, it.second);</span><br><span class="line">            <span class="keyword">else</span> outedge = max(outedge, it.second); <span class="comment">//如果不一樣，那就表示這個邊並不是內部SE、而是外部 SE</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//cout &lt;&lt; "x inedge outedge " &lt;&lt; x &lt;&lt; " " &lt;&lt; inedge &lt;&lt; " " &lt;&lt; outedge &lt;&lt; "\n";</span></span><br><span class="line">    <span class="keyword">return</span> inedge &gt; outedge; <span class="comment">//如果內部 SE 比外部大，表示這一個生成樹可以在組成一組 SE</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"out.txt"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        node.clear();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            p[i] = i; <span class="comment">//init disjoint set</span></span><br><span class="line">            edges[i].clear();</span><br><span class="line">            length[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c; <span class="comment">//輸入邊、成本</span></span><br><span class="line">            node.push_back(&#123;a,b,c&#125;);</span><br><span class="line">            edges[a].push_back(&#123;b,c&#125;);</span><br><span class="line">            edges[b].push_back(&#123;a,c&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(node.begin(), node.end()); <span class="comment">//排序，這邊排序方式為遞增</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(edge it: node)&#123;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; it.u &lt;&lt; " " &lt;&lt; it.v &lt;&lt; " " &lt;&lt; it.c &lt;&lt; "\n";</span></span><br><span class="line">            <span class="keyword">int</span> pu = find_root(it.u); <span class="comment">//判斷邊的節點們是否都在同個 set</span></span><br><span class="line">            <span class="keyword">int</span> pv = find_root(it.v);</span><br><span class="line">            <span class="keyword">if</span>(find_root(pu) != find_root(pv))&#123;</span><br><span class="line">                p[pv] = pu;</span><br><span class="line">                length[pu] += length[pv]; <span class="comment">//計入成本，表示以 pv 為頭的 SE，轉給 pu</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//cout &lt;&lt; "len pu " &lt;&lt; length[pu] &lt;&lt; "\n";</span></span><br><span class="line">                <span class="keyword">if</span>(check(pu)) ans += length[pu]; <span class="comment">//分析 3.3</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>Kruskal&#39;s algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa10426 - Knights’ Nightmare(BFS)</title>
    <url>/2021/09/20/UVa/UVa10426/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>這個國家的人民們都是西洋棋騎士，因此他們只能夠走西洋棋棋法；土地也跟西洋棋的棋盤相似。<br>有天，他們的土地上出現了一個怪物，這個怪物很特別</p>
<ul>
<li>長年都在睡覺</li>
<li>只要有一個騎士經過，怪物則會醒來，但不會吃掉他</li>
<li>接下來只要有其他騎士走過都會被吃掉</li>
</ul>
<p>由於四位騎士必須聚在一起討論會議，因此他們要找一個沒有怪物的格子開會。<br>保險起見，當有一個騎士在行走時，其他騎士不會行走，以確保安全。<br>想知道，這些騎士們聚集在土地上的哪一個格子會讓騎士們行走距離最小，輸出最小行走距離。</p>
<p><a href="https://onlinejudge.org/external/104/10426.pdf" target="_blank" rel="noopener">題目連結</a> </p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li>BFS 應用</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ul>
<li>首先我們針對四位騎士先執行允許經過怪物格子的 BFS</li>
<li>再來我們針對四位騎士執行不經過怪物格子的 BFS</li>
<li>再來我們先計算 <code>四位騎士執行不經過怪物格子的 BFS</code> 總和</li>
<li>然後針對 <code>max(騎士允許經過怪物格子 - 騎士不允許經過怪物格子)</code>，並將上一點的總和減去此公式就可算出答案<ul>
<li>因為題目說明可以讓一位騎士經過，因此我們有一個騎士經過怪物格子可以比不經過怪物格子還快，那我們就讓他抄近路。</li>
<li>如果有多位騎士符合上一點條件，那就找最大的。</li>
</ul>
</li>
<li>之後對每一個點都求出最小距離，最後再找出哪個點距離最小，輸出距離即可。</li>
</ul>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://mypaper.pchome.com.tw/zerojudge/post/1326963368" target="_blank" rel="noopener">UVa 10426 Knights’ Nightmare by morris</a><br><a href="https://web.ntnu.edu.tw/~algo/State.html" target="_blank" rel="noopener">西洋棋走法 by 師大演算法筆記</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>真的好討厭寫棋盤，每一次都寫得頭暈腦脹…。<br>棋盤真的好難搞 :(。</p>
<p>還有 <code>memset(visit, 0, sizeof(visit[i]))</code> 這樣會永遠只讓 <code>visit[0]</code> 被清空，一直被這個 bug 氣到:(</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 20</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> dx[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-2</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">2</span>&#125;; <span class="comment">//騎士方向</span></span><br><span class="line"><span class="keyword">int</span> dy[] = &#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-2</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="keyword">int</span> r, c;</span><br><span class="line"><span class="comment">//dist 不經過怪物格子、dist2 經過怪物格子</span></span><br><span class="line"><span class="keyword">int</span> dist[<span class="number">4</span>][MAXN][MAXN], dist2[<span class="number">4</span>][MAXN][MAXN]; </span><br><span class="line"><span class="keyword">int</span> visit[<span class="number">4</span>][MAXN][MAXN], visit2[<span class="number">4</span>][MAXN][MAXN]; <span class="comment">//判斷此路徑是否有走過</span></span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt; people;</span><br><span class="line"><span class="keyword">int</span> mx, my; <span class="comment">//monster x, y</span></span><br><span class="line"><span class="keyword">int</span> a, b;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isboard</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123; <span class="comment">//判斷是否在棋盤內</span></span><br><span class="line">    <span class="keyword">if</span>(x &gt; <span class="number">0</span> &amp;&amp; x &lt;= r &amp;&amp; y &gt; <span class="number">0</span> &amp;&amp; y &lt;= c ) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// https://stackoverflow.com/questions/8767166/passing-a-2d-array-to-a-c-function</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> root_x, <span class="keyword">int</span> root_y, <span class="keyword">int</span> dist[MAXN][MAXN], <span class="keyword">int</span> visit[MAXN][MAXN], <span class="keyword">int</span> is_monster)</span></span>&#123; </span><br><span class="line">    <span class="built_in">deque</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; q;</span><br><span class="line">    q.push_back(&#123;root_x, root_y&#125;);</span><br><span class="line">    visit[q.front().first][q.front().second] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(is_monster == <span class="number">1</span>) visit[mx][my] = <span class="number">1</span>; <span class="comment">//判斷這次的 spfa 是否有怪物</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> x, y, tx, ty;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        x = q.front().first; </span><br><span class="line">        y = q.front().second;</span><br><span class="line"></span><br><span class="line">        q.pop_front();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)&#123;</span><br><span class="line">            tx = x + dx[i];</span><br><span class="line">            ty = y + dy[i];</span><br><span class="line">            <span class="keyword">if</span>(isboard(tx,ty) &amp;&amp; !visit[tx][ty])&#123; <span class="comment">//判斷是否在棋盤內 &amp;&amp; 沒有經歷過</span></span><br><span class="line">                dist[tx][ty] = dist[x][y] + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//cout &lt;&lt; "dist[tx][ty] " &lt;&lt; dist[tx][ty] &lt;&lt; "\n";</span></span><br><span class="line">                visit[tx][ty] = <span class="number">1</span>; </span><br><span class="line">                q.push_back(&#123;tx,ty&#125;); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">distance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="comment">//由於怪物在我們前面的 spfa 是被我們設定成一開始就被經歷過，所以這邊額外判斷</span></span><br><span class="line">    <span class="keyword">if</span>(x == mx &amp;&amp; y == my) <span class="keyword">return</span> <span class="number">0x3f3f3f</span>; </span><br><span class="line">    <span class="keyword">int</span> cost = <span class="number">0</span>, reduce = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">        <span class="comment">//沒被經歷過，表示無法抵達，直接回傳 INF</span></span><br><span class="line">        <span class="keyword">if</span>(dist2[i][x][y] == <span class="number">0</span> &amp;&amp; !visit2[i][x][y]) <span class="keyword">return</span> <span class="number">0x3f3f3f</span>; </span><br><span class="line">        cost += dist2[i][x][y];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123; <span class="comment">//判斷經過怪物的走法會不會比較好</span></span><br><span class="line">        <span class="keyword">if</span>(dist[i][x][y] == <span class="number">0</span> &amp;&amp; !visit[i][x][y]) <span class="keyword">continue</span>; <span class="comment">//無法抵達，不用判斷</span></span><br><span class="line">        reduce = max(dist2[i][x][y] - dist[i][x][y], reduce);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; "x y cost reduce " &lt;&lt; x &lt;&lt; " " &lt;&lt; y &lt;&lt; " " &lt;&lt; cost &lt;&lt; " " &lt;&lt; reduce &lt;&lt; "\n";</span></span><br><span class="line">    <span class="keyword">return</span> cost - reduce;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; s)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; r &gt;&gt; c;</span><br><span class="line">        people.clear();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">            people.push_back(&#123;a,b&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; mx &gt;&gt; my;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(dist, <span class="number">0</span>, <span class="keyword">sizeof</span>(dist));</span><br><span class="line">        <span class="built_in">memset</span>(dist2, <span class="number">0</span>, <span class="keyword">sizeof</span>(dist2));</span><br><span class="line">        <span class="built_in">memset</span>(visit, <span class="number">0</span>, <span class="keyword">sizeof</span>(visit));</span><br><span class="line">        <span class="built_in">memset</span>(visit2, <span class="number">0</span>, <span class="keyword">sizeof</span>(visit2));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123; <span class="comment">//輸入騎士座標</span></span><br><span class="line">            spfa(people[i].first, people[i].second, dist[i], visit[i], <span class="number">0</span>);</span><br><span class="line">            spfa(people[i].first, people[i].second, dist2[i], visit2[i], <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            cout &lt;&lt; "debug dist2 \n";</span></span><br><span class="line"><span class="comment">            for(int j = 1; j &lt;= r; j++)&#123;</span></span><br><span class="line"><span class="comment">                for(int k = 1; k &lt;= c; k++)</span></span><br><span class="line"><span class="comment">                    cout &lt;&lt; dist2[i][j][k] &lt;&lt; " ";</span></span><br><span class="line"><span class="comment">                cout &lt;&lt; "\n";</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            cout &lt;&lt; "debug dist\n";</span></span><br><span class="line"><span class="comment">            for(int j = 1; j &lt;= r; j++)&#123;</span></span><br><span class="line"><span class="comment">                for(int k = 1; k &lt;= c; k++)</span></span><br><span class="line"><span class="comment">                    cout &lt;&lt; dist[i][j][k] &lt;&lt; " ";</span></span><br><span class="line"><span class="comment">                cout &lt;&lt; "\n";</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//對每一個點都求出最小距離，最後再找出哪個點距離最小，輸出距離即可。</span></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0x3f3f3f</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= r; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= c; j++)&#123;</span><br><span class="line">                ans = min(ans, distance(i, j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">        <span class="keyword">if</span>(ans == <span class="number">0x3f3f3f</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">"Meeting is impossible.\n"</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"Minimum time required is "</span> &lt;&lt; ans &lt;&lt; <span class="string">" minutes.\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>廣度優先搜尋 Breadth-First Search</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa10457 - Magic Car(Kruskal)</title>
    <url>/2021/09/08/UVa/UVa10457/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>有一台神奇的車子，稱呼為 magic car</p>
<ul>
<li>發動跟結束都需要耗費能量</li>
<li>中間距離所使用的能量是這樣計算的：\(max(每一條街最大的能量) - min(每一條街最大的能量\)<br>現在這台車子要從 A 到 B，會經過許多條路，請你告訴我走最省油的路徑抵達 B 點時，會花多少能量</li>
</ul>
<p><a href="https://onlinejudge.org/external/104/10457.pdf" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li>如何確定 \(max(每一條街最大的能量) - min(每一條街最大的能量\) 最佳化</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ul>
<li>首先我們將公式進行解析，\(max(每一條街最大的能量)\) 可以用 Kruskal 找出來<ul>
<li>判斷 A 與 B 是否在同個最小生成樹，當 A 與 B 在同個生成樹時使用的最後一個邊，可以知道是 \(max(每一條街最大的能量)\)<br>因為 kruskal 會從最小的邊開始累積</li>
</ul>
</li>
<li>\(min(每一條街最大的能量\) 由於 Kruskal 都是從最小的開始找、並且題目的邊不大於 1000，因此我們使用暴力。<ul>
<li>從最小的邊開始，不斷找出生成樹，並讓 \(生成樹最大邊 - 最小的邊能量\)，並找出最小的答案即可。</li>
</ul>
</li>
</ul>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://blog.csdn.net/accelerator_/article/details/38897735" target="_blank" rel="noopener">UVA 10457 - Magic Car(最小瓶颈路) by lab104_yifan</a><br><a href="https://blog.csdn.net/li1615882553/article/details/79843891" target="_blank" rel="noopener">最小瓶颈路含义 by csdn</a></p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。</p>
<p>關於 kruskal 詳解請參考 <a href="https://theriseofdavid.github.io/2021/09/06/Explain_Algorithm/kruskal/" target="_blank" rel="noopener">Kruskal by 大衞的筆記</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 200020</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> t, n, m, q;</span><br><span class="line"><span class="keyword">int</span> a, b, c;</span><br><span class="line"><span class="keyword">int</span> start, destination;</span><br><span class="line"><span class="keyword">int</span> ca, cb;</span><br><span class="line"><span class="keyword">int</span> p[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, v, c; <span class="comment">//u,v 分別為邊的節點， c 是成本</span></span><br><span class="line"></span><br><span class="line">    edge(): u(<span class="number">0</span>), v(<span class="number">0</span>), c(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    edge(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c): u(u), v(v), c(c) &#123;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> edge&amp; other) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c &lt; other.c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;edge&gt; node;</span><br><span class="line"><span class="built_in">vector</span>&lt;edge&gt; MST; <span class="comment">//最小生成樹</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_root</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; "find_root " &lt;&lt; x &lt;&lt; "\n";</span></span><br><span class="line">    <span class="keyword">if</span>(p[x] != x) <span class="keyword">return</span> p[x] = find_root(p[x]);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kruskal</span><span class="params">()</span></span>&#123;</span><br><span class="line">    node.clear();</span><br><span class="line">    MST.clear();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c; <span class="comment">//輸入邊、成本</span></span><br><span class="line">        node.push_back(&#123;a,b,c&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(node.begin(), node.end()); <span class="comment">//排序，這邊排序方式為遞增，求最小生成樹</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; ca &gt;&gt; cb;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; q;</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = INF;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; start &gt;&gt; destination;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123; <span class="comment">//分析 2-1</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) p[j] = j; <span class="comment">//init disjoint set</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = i; k &lt; m; k++)&#123;</span><br><span class="line">                edge it = node[k];</span><br><span class="line">                <span class="comment">//cout &lt;&lt; it.u &lt;&lt; " " &lt;&lt; it.v &lt;&lt; " " &lt;&lt; it.c &lt;&lt; "\n";</span></span><br><span class="line">                <span class="comment">//cout &lt;&lt; p[3] &lt;&lt; " " &lt;&lt; p[4] &lt;&lt; "\n";</span></span><br><span class="line">                <span class="keyword">int</span> pu = find_root(it.u); <span class="comment">//判斷邊的節點們是否都在同個 set</span></span><br><span class="line">                <span class="keyword">int</span> pv = find_root(it.v);</span><br><span class="line">                <span class="keyword">if</span>(pu != pv) p[pv] = pu;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//如果這個邊可讓這兩個節點都在同個生成樹，那就是最大邊</span></span><br><span class="line">                <span class="keyword">if</span>(find_root(start) == find_root(destination))&#123; </span><br><span class="line">                    ans = min(it.c - node[i].c, ans);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans + ca + cb &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    kruskal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>Kruskal&#39;s algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa10477 - The Hybrid Knight(BFS)</title>
    <url>/2021/09/20/UVa/UVa10477/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>生物學家讓西洋棋的騎士更跟其他棋子進行雜交，因此現在產生了一種棋子叫做怪異騎士，怪異騎士總共有三種型態，依序是普通騎士、變異騎士、變異士兵。</p>
<ul>
<li>普通騎士與一般騎士走法相同</li>
<li>變異騎士則是比一般騎士的長度再多一格</li>
<li>變異士兵走法與一般士兵相同，但變異士兵在走最後一步時可以走一格對角線</li>
</ul>
<p>現在給你一個棋盤 \(N*N\) 再給你怪異騎士的初始位置，請你讓怪異騎士走到終點。<br>請給出最小步數走法</p>
<p><a href="https://onlinejudge.org/external/104/10477.pdf" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li>多種狀態在棋盤上行走時要如何解決</li>
<li>BFS</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ul>
<li>這邊的 BFS 與其他類似題目的 BFS 不同，由於他有不同形態，因此不可以單單只有 <code>visit</code> 來判斷此格子是否有經過。<ul>
<li>舉例：普通騎士走到 x 位置，變異騎士走到 y 位置，變異士兵走到 z 位置，普通騎士走到 a 位置，變異騎士走到 x 位置，此時，x 位置就有了變異騎士、普通騎士的走法。</li>
<li>因此我們 <code>visit</code> 還要針對每一種不同的型態分開討論。</li>
<li>因此我們這樣也不在使用 <code>dist</code>，因為這樣必須按照多種形態再去開創，較為麻煩</li>
<li>比較簡單的辦法是將步數也直接存入 <code>deque</code> 裡面，就可以達到狀態延續。</li>
</ul>
  <strong>注意：這是因為題目只問最後一步才可以這樣做</strong></li>
<li>BFS 也必須按照型態順序不斷進行 BFS</li>
<li>紀錄，題目一開始沒有說初始點怪異騎士是甚麼型態，因此三種都要舉例</li>
<li>變異士兵的最後一步需要拉進來討論，但不需要再放入 <code>deque</code> 裡面 </li>
</ul>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>真的很想罵髒話…，這題目有夠噁心 = =，可以把題目出成這樣真的太鬼了，我為了解這題花了 4hr，我還沒有覺得我學到了甚麼大觀念、大格局，只有學到一些小技巧，然後發現一些缺點，就重新編寫程式碼。</p>
<p>天啊，這快跟 poker code 一樣難過:(</p>
<p>可以看看我下面的 code，就知道我到底 debug 多少次XD。</p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://github.com/limon2009/ACM-UVA-Online-Judge-solution/blob/master/10477.cpp" target="_blank" rel="noopener">UVa 10477 by monir-bjit</a></p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 25</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> kx[] = &#123;<span class="number">-2</span>, <span class="number">-2</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>&#125;; <span class="comment">//普通騎士走法</span></span><br><span class="line"><span class="keyword">int</span> ky[] = &#123;<span class="number">-1</span>, <span class="number">1</span>, <span class="number">-2</span>, <span class="number">2</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">-2</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> mx[] = &#123;<span class="number">-3</span>, <span class="number">-3</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>&#125;; <span class="comment">//變異騎士走法</span></span><br><span class="line"><span class="keyword">int</span> my[] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">-3</span>, <span class="number">3</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">-3</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> px[] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;; <span class="comment">//變異小兵普通走法</span></span><br><span class="line"><span class="keyword">int</span> py[] = &#123;<span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> dx[] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>&#125;; <span class="comment">//變異小兵最後一步走法</span></span><br><span class="line"><span class="keyword">int</span> dy[] = &#123;<span class="number">-1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> visit[<span class="number">3</span>][MAXN][MAXN]; <span class="comment">//記錄各種狀態在此格子是否有走過</span></span><br><span class="line"><span class="keyword">int</span> n, s, b, e, kase=<span class="number">0</span>, cmd, cost; </span><br><span class="line"><span class="keyword">int</span> bx, by, ex, ey; <span class="comment">//b 起點 e 終點</span></span><br><span class="line"><span class="keyword">int</span> x, y, m, tx, ty;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y, m, cost; <span class="comment">//x,y 座標 m 現在是哪個型態, cost 從一開始到現在已經走了幾步</span></span><br><span class="line">    node(): x(<span class="number">0</span>), y(<span class="number">0</span>), m(<span class="number">0</span>), cost(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    node(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> m, <span class="keyword">int</span> cost): x(x), y(y), m(m), cost(cost) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">deque</span>&lt;node&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isboard</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123; <span class="comment">//判斷 x,y 是否還在棋盤內</span></span><br><span class="line">    <span class="keyword">if</span>(x &gt;= <span class="number">0</span> &amp;&amp; x &lt; n &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; n) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushK</span><span class="params">()</span></span>&#123; <span class="comment">//普通騎士走法</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)&#123;</span><br><span class="line">        tx = x + kx[i];</span><br><span class="line">        ty = y + ky[i];</span><br><span class="line">        <span class="keyword">if</span>(isboard(tx,ty) &amp;&amp; !visit[cmd][tx][ty])&#123;</span><br><span class="line">            visit[cmd][tx][ty] = <span class="number">1</span>;</span><br><span class="line">            q.push_back(&#123;tx,ty,m+<span class="number">1</span>, cost+<span class="number">1</span>&#125;);</span><br><span class="line">            <span class="comment">//cout &lt;&lt; "K tx ty cost " &lt;&lt; tx &lt;&lt; " " &lt;&lt; ty &lt;&lt; " " &lt;&lt; cost+1 &lt;&lt; "\n";</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushM</span><span class="params">()</span></span>&#123; <span class="comment">//變異騎士走法</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)&#123;</span><br><span class="line">        tx = x + mx[i];</span><br><span class="line">        ty = y + my[i];</span><br><span class="line">        <span class="keyword">if</span>(isboard(tx,ty) &amp;&amp; !visit[cmd][tx][ty])&#123;</span><br><span class="line">            visit[cmd][tx][ty] = <span class="number">1</span>;</span><br><span class="line">            q.push_back(&#123;tx,ty,m+<span class="number">1</span>, cost+<span class="number">1</span>&#125;);</span><br><span class="line">            <span class="comment">//cout &lt;&lt; "M tx ty cost " &lt;&lt; tx &lt;&lt; " " &lt;&lt; ty &lt;&lt; " " &lt;&lt; cost+1 &lt;&lt; "\n";</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushP</span><span class="params">()</span></span>&#123; <span class="comment">//變異小兵走法</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">        tx = x + px[i];</span><br><span class="line">        ty = y + py[i];</span><br><span class="line">        <span class="keyword">if</span>(isboard(tx,ty) &amp;&amp; !visit[cmd][tx][ty])&#123;</span><br><span class="line">            visit[cmd][tx][ty] = <span class="number">1</span>;</span><br><span class="line">            q.push_back(&#123;tx,ty,m+<span class="number">1</span>, cost+<span class="number">1</span>&#125;);</span><br><span class="line">            <span class="comment">//cout &lt;&lt; "P tx ty cost " &lt;&lt; tx &lt;&lt; " " &lt;&lt; ty &lt;&lt; " " &lt;&lt; cost+1 &lt;&lt; "\n";</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushD</span><span class="params">()</span></span>&#123; <span class="comment">//變異小兵對角線走法</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">        tx = x + dx[i];</span><br><span class="line">        ty = y + dy[i];</span><br><span class="line">        <span class="keyword">if</span>(isboard(tx,ty))&#123;</span><br><span class="line">            <span class="keyword">if</span>(tx == ex &amp;&amp; ty == ey)&#123; <span class="comment">//不需要 q.push_back() 因為不能再走</span></span><br><span class="line">                visit[cmd][tx][ty] = <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//cout &lt;&lt; "D tx ty dist " &lt;&lt; tx &lt;&lt; " " &lt;&lt; ty &lt;&lt; " " &lt;&lt; dist[tx][ty] &lt;&lt; "\n";</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0</span>, <span class="keyword">sizeof</span>(dist));</span><br><span class="line">    <span class="built_in">memset</span>(visit, <span class="number">0</span>, <span class="keyword">sizeof</span>(visit));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//各種狀態初始化</span></span><br><span class="line">    q.push_back(&#123;bx, by, <span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    visit[<span class="number">0</span>][bx][by] = <span class="number">1</span>;</span><br><span class="line">    q.push_back(&#123;bx, by, <span class="number">1</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    visit[<span class="number">1</span>][bx][by] = <span class="number">1</span>;</span><br><span class="line">    q.push_back(&#123;bx, by, <span class="number">2</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    visit[<span class="number">2</span>][bx][by] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; bx &lt;&lt; " " &lt;&lt; by &lt;&lt; "\n";</span></span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        x = q.front().x;</span><br><span class="line">        y = q.front().y;</span><br><span class="line">        m = q.front().m;</span><br><span class="line">        cost = q.front().cost;</span><br><span class="line">        q.pop_front();</span><br><span class="line">        cmd = m % <span class="number">3</span>; <span class="comment">//由於只有三種型態，因此 %3</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(cmd == <span class="number">0</span>) pushK();</span><br><span class="line">        <span class="keyword">if</span>(visit[cmd][ex][ey]) <span class="keyword">return</span> cost+<span class="number">1</span>; <span class="comment">//如果在這次普通騎士中有找到，表示再走一步就到，因此直接 return cost+1</span></span><br><span class="line">        <span class="keyword">if</span>(cmd == <span class="number">1</span>) pushM();</span><br><span class="line">        <span class="keyword">if</span>(visit[cmd][ex][ey]) <span class="keyword">return</span> cost+<span class="number">1</span>; <span class="comment">//遇上面概念相同</span></span><br><span class="line">        <span class="keyword">if</span>(cmd == <span class="number">2</span>) pushP();</span><br><span class="line">        <span class="keyword">if</span>(visit[cmd][ex][ey]) <span class="keyword">return</span> cost+<span class="number">1</span>; <span class="comment">//遇上面概念相同</span></span><br><span class="line">        <span class="keyword">if</span>(cmd == <span class="number">2</span>) pushD();</span><br><span class="line">        <span class="keyword">if</span>(visit[cmd][ex][ey]) <span class="keyword">return</span> cost+<span class="number">1</span>; <span class="comment">//遇上面概念相同</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//找不到，輸出 -1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"out.txt"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; s &amp;&amp; (n != <span class="number">0</span>))&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Set "</span> &lt;&lt; ++kase &lt;&lt; <span class="string">":\n"</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s; i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; b &gt;&gt; e; <span class="comment">//由於題目給一維陣列表達，我們直接將資料全部 -1，就可用一般數學比達</span></span><br><span class="line">            <span class="comment">//因此此題目中所有關於棋盤的 index 都從 0 開始</span></span><br><span class="line">            b--; e--; </span><br><span class="line">            bx = b / n; by = b % n; <span class="comment">//轉換成 x,y 座標</span></span><br><span class="line">            ex = e / n; ey = e % n; <span class="comment">//轉換成 x,y 座標</span></span><br><span class="line">            q.clear();</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; spfa() &lt;&lt; <span class="string">"\n"</span>; <span class="comment">//計算答案</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>廣度優先搜尋 Breadth-First Search</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa11792 - Krochanska is Here(BFS)</title>
    <url>/2021/09/14/UVa/UVa11792/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p><a href="https://m80126colin.github.io/blog/articles/%E7%BF%BB%E8%AD%AF/uva/uva11792/" target="_blank" rel="noopener">中文連結，她講得太好了</a><br><a href="https://onlinejudge.org/external/117/11792.pdf" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li>最短路徑快速演算法，與 dijkstra 相同，但使用 queue 來實作</li>
<li>目標重點：找出 \(min(重點車站到其他重點車站的平均值)\)</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ul>
<li>由於是要找出 \(min(重點車站到其他能抵達重點車站的平均值)\)，題目說重點車站最多只有 100，因此使用暴力解</li>
<li>題目是說要找出<strong>平均</strong>，但是題目是要找到所有能抵達的重要車站，但因為每一個車站都要能夠抵達全部的重要車站，因此分母都是相同，就可以進行省略，直接計算距離即可。</li>
</ul>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://github.com/morris821028/UVa/blob/master/volume117/11792%20-%20Krochanska%20is%20Here.cpp" target="_blank" rel="noopener">11792 - Krochanska is Here by morrir821028</a><br><a href="http://naivered.github.io/2018/03/19/Problem_Solving/UVa/UVa-11792-Krochanska-is-Here/" target="_blank" rel="noopener">UVa 11792 - Krochanska is Here</a><br><a href="https://m80126colin.github.io/blog/articles/%E7%BF%BB%E8%AD%AF/uva/uva11792/" target="_blank" rel="noopener">中文連結，她講得太好了</a></p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 10020</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> t, n, m;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; edge[MAXN]; <span class="comment">//邊的陣列</span></span><br><span class="line"><span class="keyword">int</span> visit[MAXN];</span><br><span class="line"><span class="keyword">int</span> dist[MAXN], important[MAXN]; <span class="comment">//dist 從 x 到 index 的距離</span></span><br><span class="line"><span class="comment">//important 重要車站，當經過的路徑大於 2，就是重要車站</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//不使用 dijkstra，因為每一個權重都相同，因此使用普通的 queue 就好</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> root)</span></span>&#123; <span class="comment">//don't using dijkstra, because each have same weights</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) dist[i] = INF; <span class="comment">//root 一開始無法抵達這些點，因此都次 INF</span></span><br><span class="line">    <span class="built_in">memset</span>(visit, <span class="number">0</span>, <span class="keyword">sizeof</span>(visit));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; q; <span class="comment">//queue 類似於 dijkstra piority queue</span></span><br><span class="line">    q.push_back(root); </span><br><span class="line">    dist[root] = <span class="number">0</span>; <span class="comment">//root 到本身為 0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        root = q.front(); q.pop_front();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it: edge[root])&#123;</span><br><span class="line">            <span class="keyword">if</span>(dist[it] &gt; dist[root] + <span class="number">1</span>)&#123;</span><br><span class="line">                dist[it] = dist[root] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(!visit[it])&#123;</span><br><span class="line">                    visit[it] = <span class="number">1</span>;</span><br><span class="line">                    q.push_back(it);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123; <span class="comment">//計算可以抵達每一個車站，使用多少距離</span></span><br><span class="line">        <span class="keyword">if</span>(important[i] &gt; <span class="number">1</span>) ans += dist[i]; <span class="comment">//如果 root 沒辦法抵達此車站，那就會是 +INF</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) edge[i].clear();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(important, <span class="number">0</span>, <span class="keyword">sizeof</span>(important));</span><br><span class="line">        <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">            <span class="keyword">int</span> pre, next;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; pre;</span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; next &amp;&amp; next)&#123;</span><br><span class="line">                edge[pre].push_back(next); <span class="comment">//有向圖</span></span><br><span class="line">                edge[next].push_back(pre);</span><br><span class="line">                important[pre]++; <span class="comment">//經過的路徑 + 1</span></span><br><span class="line">                pre = next;</span><br><span class="line">            &#125;</span><br><span class="line">            important[pre]++;  <span class="comment">//經過的路徑 + 1</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//min_dist 當前的最小距離，ans 當前最小距離的車站</span></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, min_dist = INF, spfa_dist;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(important[i] &gt; <span class="number">1</span>)&#123; <span class="comment">//當經過的路徑大於 2，就是重要車站</span></span><br><span class="line">                <span class="comment">//cout &lt;&lt; "important " &lt;&lt; i &lt;&lt; "\n";</span></span><br><span class="line">                spfa_dist = spfa(i);</span><br><span class="line">                <span class="comment">//cout &lt;&lt; "spfa_dist " &lt;&lt; spfa_dist &lt;&lt; "\n";</span></span><br><span class="line">                <span class="keyword">if</span>(spfa_dist &lt; min_dist)&#123;</span><br><span class="line">                    ans = i;</span><br><span class="line">                    min_dist = spfa_dist;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Krochanska is in: "</span> &lt;&lt; ans &lt;&lt; <span class="string">"\n"</span>; <span class="comment">//輸出答案</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>廣度優先搜尋 Breadth-First Search</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa12826 - Incomplete Chessboard(BFS)</title>
    <url>/2021/09/15/UVa/UVa12826/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>給你一個西洋棋盤，給你 A、B、C 座標，請透過上下左右、對角線的方式從 A 走到 B 並繞開 C，最短距離為多少？</p>
<p><a href="https://onlinejudge.org/external/128/12826.pdf" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li>最短路徑快速演算法，與 dijkstra 相同，但使用 queue 來實作</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ul>
<li>使用最短路徑快速演算法實作</li>
<li>將 C 點一開始就設定為已經過即可。</li>
</ul>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://github.com/morris821028/UVa/blob/master/volume128/12826%20-%20Incomplete%20Chessboard.cpp" target="_blank" rel="noopener">UVa 12826 by morris821028 </a></p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> dist[MAXN][MAXN]; <span class="comment">//距離</span></span><br><span class="line"><span class="keyword">int</span> visit[MAXN][MAXN]; <span class="comment">//是否已經歷過</span></span><br><span class="line"><span class="keyword">int</span> ax,ay, bx,by, cx,cy; <span class="comment">//a,b,c 的座標</span></span><br><span class="line"><span class="keyword">int</span> kase = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dx[] = &#123;<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;; <span class="comment">//上下左右、對角線</span></span><br><span class="line"><span class="keyword">int</span> dy[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">islegal</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123; <span class="comment">//判斷是否越界</span></span><br><span class="line">    <span class="keyword">if</span>(x &gt; <span class="number">8</span> || x &lt;= <span class="number">0</span> || y &gt; <span class="number">8</span> || y &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//memset(g, 0x3f, sizeof(dist)); //using visit</span></span><br><span class="line">    <span class="built_in">memset</span>(visit, <span class="number">0</span>, <span class="keyword">sizeof</span>(visit));</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0</span>, <span class="keyword">sizeof</span>(dist));</span><br><span class="line">    visit[cx][cy] = <span class="number">1</span>; <span class="comment">//C 點設為以使用</span></span><br><span class="line">    visit[ax][ay] = <span class="number">1</span>; <span class="comment">//起點設為已使用</span></span><br><span class="line">    <span class="built_in">deque</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt; q;</span><br><span class="line">    q.push_back(&#123;ax,ay&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123; <span class="comment">//spfa</span></span><br><span class="line">        <span class="keyword">int</span> x = q.front().first;</span><br><span class="line">        <span class="keyword">int</span> y = q.front().second;</span><br><span class="line">        q.pop_front();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tx = x+dx[i], ty = y+dy[i];</span><br><span class="line">            <span class="keyword">if</span>(!visit[tx][ty] &amp;&amp; islegal(tx, ty))&#123;</span><br><span class="line">                dist[tx][ty] = dist[x][y] + <span class="number">1</span>;</span><br><span class="line">                visit[tx][ty] = <span class="number">1</span>;</span><br><span class="line">                q.push_back(&#123;tx,ty&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(visit[bx][by]) <span class="keyword">return</span> dist[bx][by]; <span class="comment">//如果已被經歷過，表示找出最佳解。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"out.txt"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; ax &gt;&gt; ay &gt;&gt; bx &gt;&gt; by &gt;&gt; cx &gt;&gt; cy)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Case "</span> &lt;&lt; kase++ &lt;&lt; <span class="string">": "</span> &lt;&lt; spfa() &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>廣度優先搜尋 Breadth-First Search</tag>
      </tags>
  </entry>
  <entry>
    <title>演算法知識 - Dijkstra&#39;s Algorithm (無權重、有權重向圖)</title>
    <url>/2021/09/24/Explain_Algorithm/dijkstra/</url>
    <content><![CDATA[<h2 id="Dijkstra’a-Algorithm-介紹"><a href="#Dijkstra’a-Algorithm-介紹" class="headerlink" title="Dijkstra’a Algorithm 介紹"></a>Dijkstra’a Algorithm 介紹</h2><blockquote>
<p>能夠針對<strong>有、無權重的</strong>有向圖做出單點全源最短路徑演算法。</p>
<ul>
<li>單點全源：從 A 點到任意邊的最短距離<br>時間複雜度為 \(O((E+V)log V)\)，E 為邊、V 為頂點</li>
</ul>
</blockquote>
<a id="more"></a>

<h2 id="Dijkstra’s-Algorithm-證明與實作"><a href="#Dijkstra’s-Algorithm-證明與實作" class="headerlink" title="Dijkstra’s Algorithm 證明與實作"></a>Dijkstra’s Algorithm 證明與實作</h2><h3 id="證明"><a href="#證明" class="headerlink" title="證明"></a>證明</h3><ul>
<li>我們知道無權重的有向圖可以做出單點全源最短路徑演算法。keyword: spfa</li>
<li>但是如果有權重的時候有可能 <code>queue</code> 上面的節點並不是最快速的節點，因為放入 <code>queue</code> 的順序是依照<strong>時間放入</strong>。</li>
<li>因此我們改使用 <code>priority_queue</code> 將 queue 的排序從依照<strong>時間放入</strong>更改為<strong>queue 中成本最小的值</strong>。</li>
<li>理所當然，成本最小的值加上任一相同路徑也還會是最小<ul>
<li>EX: \(3+5 =8, 10+5 = 15\)</li>
</ul>
</li>
<li>其他與無權重的有向圖相同。</li>
</ul>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul>
<li>使用  <code>priority_queue</code>，內部資料結構為 <code>(root, cost)</code></li>
<li>放入節點 <code>(root,0)</code>，root 為出發點節、0 表示成本</li>
<li>進行 BFS，並用一陣列從出發點到 x 點最短距離。<ul>
<li>其中 E 表示有一條邊從 root 到 x</li>
<li>如果 \((root, cost) + E(root,x).成本 &gt;  當前 x 點最短距離  \)<ul>
<li>\( 當前 x 點最短距離 = (root, cost) + E(root,x).成本 \)</li>
<li><code>priority_queue.push(x, 當前 x 點最短距離)</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Dijkstra-Algorithm-實作"><a href="#Dijkstra-Algorithm-實作" class="headerlink" title="Dijkstra Algorithm 實作"></a>Dijkstra Algorithm 實作</h2><p>不廢話，直接上來</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 10020</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2100000000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span> <span class="comment">// 我們使用 Edge struct 實做 (root, cost)</span></span><br><span class="line">    <span class="keyword">int</span> v, c;</span><br><span class="line">    Edge(): v(<span class="number">0</span>), c(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    Edge(<span class="keyword">int</span> _v, <span class="keyword">int</span> _c): v(_v), c(_c) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Status</span>&#123;</span> <span class="comment">// 我們使用 Status struct 實做 priority_queue (root, cost)</span></span><br><span class="line">    <span class="keyword">int</span> v, c; <span class="comment">//v 節點, c 成本</span></span><br><span class="line">    Status(): v(<span class="number">0</span>), c(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    Status(<span class="keyword">int</span> _v, <span class="keyword">int</span> _c): v(_v), c(_c) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Status&amp; other) <span class="keyword">const</span>&#123; </span><br><span class="line">        <span class="keyword">return</span> c &lt; other.c; <span class="comment">//遞減排序，決定 priority_queue 的方式</span></span><br><span class="line">        <span class="comment">//return c &gt; other.c; //遞增排序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> c, v;</span><br><span class="line"><span class="keyword">int</span> a, b, cost;</span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; edge[MAXN]; <span class="comment">//放入題目的邊</span></span><br><span class="line"><span class="keyword">int</span> dist[MAXN]; <span class="comment">//從 root 出發到 x 邊的最短距離</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> root)</span></span>&#123;</span><br><span class="line">    priority_queue&lt;Status&gt; q;</span><br><span class="line">    q.push(&#123;root,<span class="number">0</span>&#125;); <span class="comment">//初始放入開始點</span></span><br><span class="line">    dist[root] = <span class="number">0</span>; <span class="comment">//自己到自己成本為零</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cost;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        Status node = q.top(); q.pop(); </span><br><span class="line">        <span class="comment">//cout &lt;&lt; node.v &lt;&lt; " " &lt;&lt; node.c &lt;&lt; "\n";</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it: edge[node.v])&#123;</span><br><span class="line">            cost = dist[node.v] + it.c; <span class="comment">//分析 3</span></span><br><span class="line">            <span class="keyword">if</span>(cost &lt; dist[it.v])&#123; </span><br><span class="line">                q.push(&#123;it.v, cost&#125;);</span><br><span class="line">                dist[it.v] = cost;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"out.txt"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; c &gt;&gt; v)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= c; i++)&#123; <span class="comment">//清除邊、重置距離</span></span><br><span class="line">            edge[i].clear();</span><br><span class="line">            dist[i] = INF; </span><br><span class="line">            dist[i] = -INF; <span class="comment">//當題目要求，是最大成本時使用</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v; i++)&#123; <span class="comment">//加入邊</span></span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; cost;</span><br><span class="line">            edge[a].push_back(&#123;b,cost&#125;); <span class="comment">//單向時使用</span></span><br><span class="line">            edge[b].push_back(&#123;a,cost&#125;); <span class="comment">//雙向時使用</span></span><br><span class="line">        &#125;</span><br><span class="line">        dijkstra(root); <span class="comment">//root 為任移值，為開始的點</span></span><br><span class="line">        <span class="keyword">if</span>(dist[x] == INF) <span class="built_in">cout</span> &lt;&lt; <span class="string">"-1\n"</span>; <span class="comment">// root -&gt; x 最短距離為多少，無法抵達輸出 -1</span></span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; dist[x] &lt;&lt; <span class="string">"\n"</span>; <span class="comment">//可以抵達則輸出。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>演算法知識</category>
      </categories>
      <tags>
        <tag>Dijkstra&#39;s</tag>
        <tag>程式解題</tag>
        <tag>演算法知識</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa12950 - Even Obsession(Dijkstra&#39;s)</title>
    <url>/2021/09/20/UVa/UVa12950/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>Patricia 是個傑出的軟體工程師，但她有一些怪癖，喜歡偶數的事物，例如:喜歡買偶數張電影票、一天吃兩餐 or 四餐…等。<br>在 Patricia 所住的城市需要收過路費，Patricia 想從 1 到 x 點，她希望他可以被收偶數次的過路費，並且花費最少，你則必須輸出花費最小的數值為多少。</p>
<p><a href="https://onlinejudge.org/external/129/12950.pdf" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li><a href="https://theriseofdavid.github.io/2021/09/24/Explain_Algorithm/dijkstra/" target="_blank" rel="noopener">dijkstra’s by 大衛的筆記</a></li>
<li>dijkstra’s 的變化題</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ul>
<li>只有一點點小小的變化， dijkstra’s 是想要找出最短路徑，而這題目新增條件是要經過偶數個邊</li>
<li>那我們就分開操作，產生兩個 dist，一個裝在偶數邊時的最短距離、一個則裝奇數邊的最短距離。<ul>
<li>定義<ul>
<li>odd_dist 奇數邊的最短距離</li>
<li>even_dist 偶數邊時的最短距離</li>
<li>root <code>priority queue</code> 當前的節點</li>
<li>cost <code>priority queue</code> 當前的成本</li>
<li>x root 可以抵達的任意節點</li>
<li>edge.c 當前的任意邊成本</li>
<li><code>{root, cost}</code> 為 <code>priority queue</code> 型別，root 是節點、cost 是成本</li>
</ul>
</li>
<li>只要  <code>edge.c[x] + odd_dist[root] &gt; even_dist[x]</code>，  <code>priority queue.push({x, edge.c[x] + odd_dist[root]})</code></li>
<li>只要  <code>edge.c[x] + even_dist[root] &gt; odd_dist[x]</code>，  <code>priority queue.push({x, edge.c[x] + even_dist[root]})</code></li>
</ul>
</li>
</ul>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://www.bbsmax.com/A/A2dmx4e45e/" target="_blank" rel="noopener">UVa 12950 by bbsmax</a><br><a href="https://www.cnblogs.com/fightfordream/p/5552225.html" target="_blank" rel="noopener">UVa 12950 by Shadowdsp</a></p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>有一些程式碼註解在 <a href="https://theriseofdavid.github.io/2021/09/24/Explain_Algorithm/dijkstra/" target="_blank" rel="noopener">dijkstra’s by 大衛的筆記</a> 請供參考。</p>
<p>會在下面放一些簡單註解，供大家學習時參考。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 10020</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2100000000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v, c; </span><br><span class="line">    Edge(): v(<span class="number">0</span>), c(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    Edge(<span class="keyword">int</span> _v, <span class="keyword">int</span> _c): v(_v), c(_c) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Edge&amp; other) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c &lt; other.c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> c, v;</span><br><span class="line"><span class="keyword">int</span> a, b, cost;</span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; edge[MAXN];</span><br><span class="line"><span class="keyword">int</span> odd_dist[MAXN], even_dist[MAXN]; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> root)</span></span>&#123;</span><br><span class="line">    <span class="built_in">deque</span>&lt;Edge&gt; q;</span><br><span class="line">    q.push_back(&#123;root,<span class="number">0</span>&#125;);</span><br><span class="line">    even_dist[root] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//odd_dist[root] = 0;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cost;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        Edge node = q.front(); q.pop_front();</span><br><span class="line">        <span class="comment">//cout &lt;&lt; node.v &lt;&lt; " " &lt;&lt; node.c &lt;&lt; "\n";</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it: edge[node.v])&#123; </span><br><span class="line">            cost = odd_dist[node.v] + it.c;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; "even dist " &lt;&lt; cost &lt;&lt; " " &lt;&lt; even_dist[it.v] &lt;&lt; "\n";</span></span><br><span class="line">            <span class="keyword">if</span>(cost &lt; even_dist[it.v])&#123; <span class="comment">//分析 2</span></span><br><span class="line">                q.push_back(&#123;it.v, cost&#125;);</span><br><span class="line">                even_dist[it.v] = cost;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            cost = even_dist[node.v] + it.c;</span><br><span class="line">            <span class="keyword">if</span>(cost &lt; odd_dist[it.v])&#123;</span><br><span class="line">                q.push_back(&#123;it.v, cost&#125;);</span><br><span class="line">                odd_dist[it.v] = cost;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"out.txt"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; c &gt;&gt; v)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= c; i++)&#123;</span><br><span class="line">            edge[i].clear();</span><br><span class="line">            even_dist[i] = INF;</span><br><span class="line">            odd_dist[i] = INF;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v; i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; cost;</span><br><span class="line">            edge[a].push_back(&#123;b,cost&#125;); <span class="comment">//題目為雙向邊</span></span><br><span class="line">            edge[b].push_back(&#123;a,cost&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        dijkstra(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(even_dist[c] == INF) <span class="built_in">cout</span> &lt;&lt; <span class="string">"-1\n"</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; even_dist[c] &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>Dijkstra&#39;s</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa12047 - Highest Paid Toll(Dijkstra&#39;s)</title>
    <url>/2021/09/24/UVa/UVa12047/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>在一個城市中，每一條道路都必須要收過路費。<br>其中會給你一個數值 p，你從出發點到終點不可以花超過 p 費用，並且在符合前面條件下，會產生 toll<br>toll: 在你走的路徑中，花費最多一次的過路費。<br>請你找出最大的 toll 是多少。</p>
<p><a href="https://onlinejudge.org/external/120/12047.pdf" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li><a href="https://theriseofdavid.github.io/2021/09/24/Explain_Algorithm/dijkstra/" target="_blank" rel="noopener">dijkstra’s by 大衛的筆記</a></li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ul>
<li>由於 toll 在你走的路徑中，花費最多一次的過路費。</li>
<li>題目是單向圖</li>
<li>因此我們可以做兩張圖，第一張圖與題目相同、第二章圖與題目相反，且兩張圖都做 dijkstra<ul>
<li>第一張圖的出發點，為題目的出發點，定義為 st_dist</li>
<li>第二張圖的出發點，以題目的終點為出發點 ed_dist</li>
<li>再來我們的 toll 任意枚舉每一條邊，u -&gt; v</li>
</ul>
</li>
<li>公式： \(st_dist[u] + ed_dist[v] + edge[v].cost \)<ul>
<li>從出發點到 u 點的最短距離 + 從終點到 v 點的最短距離 + (u -&gt; v) 的成本，是不是有比 p 小。</li>
<li>如果有，就看有沒有比當前答案大，有就替換。</li>
</ul>
</li>
<li>由於題目的每一個過路費最大可能到 \(10^4\)，因此 INF 必須要開到 \(10^5 * 10^5 = 10^10\)</li>
</ul>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://mypaper.pchome.com.tw/zerojudge/post/1325001267" target="_blank" rel="noopener">UVa 12047 by Morris’s</a><br><a href="https://github.com/yulonglong/UVa-Solutions/blob/master/12047.cpp" target="_blank" rel="noopener">UVa 12047 by yulonglong</a></p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>有一些程式碼註解在 <a href="https://theriseofdavid.github.io/2021/09/24/Explain_Algorithm/dijkstra/" target="_blank" rel="noopener">dijkstra’s by 大衛的筆記</a> 請供參考。</p>
<p>會在下面放一些簡單註解，供大家學習時參考。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 10020</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2100000000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> t, n, m;</span><br><span class="line"><span class="keyword">int</span> st, ed, p;</span><br><span class="line"><span class="keyword">int</span> a, b, c;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v, c; <span class="comment">//vector, cost;</span></span><br><span class="line">    Edge(): v(<span class="number">0</span>), c(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    Edge(<span class="keyword">int</span> _v, <span class="keyword">int</span> _c): v(_v), c(_c) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Edge&amp; other) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c &gt; other.c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//st_edge 題目圖, ed_edge 反向圖</span></span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; st_edge[MAXN], ed_edge[MAXN]; </span><br><span class="line"><span class="comment">//以 st_dist 題目圖最小距離, ed_edge 反向圖最小距離</span></span><br><span class="line"><span class="keyword">int</span> visit[MAXN], st_dist[MAXN], ed_dist[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> root, <span class="built_in">vector</span>&lt;Edge&gt; edge[MAXN], <span class="keyword">int</span> dist[MAXN] )</span></span>&#123;</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt; &gt; q;</span><br><span class="line">    q.push(root); <span class="comment">//這裡理應要使用 dijkstra by 大衛的筆記，</span></span><br><span class="line">    <span class="comment">//但是我認為題目 n 太小，queue 應該也做得到，試試看，結果過了 AC XD。</span></span><br><span class="line">    dist[root] = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cost, x;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123; </span><br><span class="line">        x = q.top(); q.pop(); </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it: edge[x])&#123; </span><br><span class="line">            cost = dist[x] + it.c;</span><br><span class="line">            <span class="keyword">if</span>(cost &lt; dist[it.v])&#123;</span><br><span class="line">                q.push(it.v);</span><br><span class="line">                dist[it.v] = cost;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="comment">//freopen("out.txt", "w", stdout);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCLA</span></span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; st &gt;&gt; ed &gt;&gt; p;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123; <span class="comment">//clear</span></span><br><span class="line">            st_edge[i].clear();</span><br><span class="line">            st_dist[i] = INF;</span><br><span class="line">            ed_edge[i].clear();</span><br><span class="line">            ed_dist[i] = INF;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">            st_edge[a].push_back(&#123;b,c&#125;); <span class="comment">//題目圖</span></span><br><span class="line">            ed_edge[b].push_back(&#123;a,c&#125;); <span class="comment">//反向圖</span></span><br><span class="line">        &#125;</span><br><span class="line">        dijkstra(st, st_edge, st_dist); <span class="comment">//題目圖 dijkstra</span></span><br><span class="line">        dijkstra(ed, ed_edge, ed_dist); <span class="comment">//題目圖 dijkstra</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//cout &lt;&lt; "dist 2 " &lt;&lt; st_dist[2] &lt;&lt; "\n";</span></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">-1</span>, cost = <span class="number">0</span>; <span class="comment">//ans 題目答案</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123; <span class="comment">//枚舉每一個邊</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> it: st_edge[i])&#123;</span><br><span class="line">                cost = st_dist[i] + ed_dist[it.v] + it.c; <span class="comment">//分析 4</span></span><br><span class="line">                <span class="comment">//cout &lt;&lt; "cost i j " &lt;&lt; i &lt;&lt; " " &lt;&lt; it.v &lt;&lt; " " &lt;&lt; cost &lt;&lt; "\n";</span></span><br><span class="line">                <span class="comment">//cout &lt;&lt; "cost formula " &lt;&lt; st_dist[i] &lt;&lt; " " &lt;&lt; ed_dist[it.v] &lt;&lt; " " &lt;&lt; it.c &lt;&lt; "\n";</span></span><br><span class="line">                <span class="keyword">if</span>(cost &lt;= p)&#123; </span><br><span class="line">                    ans = max(ans, it.c);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>Dijkstra&#39;s</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>QUESTION! Win10 無法更新安裝，並顯示 virutalbox 需要解除安裝，但電腦沒有此文件</title>
    <url>/2021/09/28/windows/win10_update_with_virtualbox/</url>
    <content><![CDATA[<h2 id="內容說明"><a href="#內容說明" class="headerlink" title="內容說明"></a>內容說明</h2><blockquote>
<p>QUESTION! Win10 無法更新安裝，並顯示 virutalbox 需要解除安裝，但電腦沒有此文件</p>
</blockquote>
<a id="more"></a>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><ul>
<li>確認自己的電腦裡面真的沒有 virutal box </li>
<li>將所有手機模擬器全部檢查，只要他們有用到 virutal box，就將手機模擬器全部解除安裝。<ul>
<li>尤其是夜神，很難清乾淨</li>
</ul>
</li>
</ul>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://answers.microsoft.com/zh-hant/windows/forum/all/%E6%88%91%E7%9A%84%E9%9B%BB%E8%85%A6windows/ba61cd48-145f-4907-992e-999bd7799ec4?page=3&auth=1" target="_blank" rel="noopener">我的電腦Windows 10無法更新安裝 然後出現說virtualbox立即解除安裝此應用程式 因為他與Windows 10不相容 然後旁邊還有出現手動解除安裝 但是無法按 by est7711</a></p>
]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>ngrok</tag>
        <tag>server</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa1265 - Flying to Fredericton(Dijkstra)</title>
    <url>/2021/09/08/UVa/UVa11280/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>Brett 現在人在 Calgary 他想要透過飛機到 Fredericton，他想要走最省錢的方式抵達，他可以忍受 x 次轉機<br>請告訴 Brett 他最多忍受幾次轉機，最省錢抵達 Fredericton 的成本是多少</p>
<p><a href="https://onlinejudge.org/external/112/11280.pdf" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li><a href="https://theriseofdavid.github.io/2021/09/24/Explain_Algorithm/dijkstra/" target="_blank" rel="noopener">dijkstra’s by 大衛的筆記</a></li>
<li>dijkstra 增加一維度，紀錄轉機次數</li>
<li>最多忍受，但不一定要剛好忍受 x 次班機，如果 x-2 次有更好的答案，為何不用呢?</li>
<li>題目有嚴格輸出</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ul>
<li>題目的城市進行簡單 hash</li>
<li>使用 dijkstra 並記錄，成本多少、轉機幾次，以成本最少為 priority queue</li>
<li>dijkstra 增加一維度，記錄轉機次數<br>如果 x 點轉機三次，則是 <code>dist[x][3]</code></li>
<li>用一個迴圈，讓一些轉機次數比較少，但成本低的，可以取代轉機次數高，且成本也高<ul>
<li>如果轉機次數多，成本高，那就不需要那麼多次轉機了</li>
<li>題目說的是容忍最多 x 次轉機</li>
</ul>
</li>
<li>由於城市最多只會有 100 個，因此當轉機次數大於 100 時，基本上是不可能的，直接當作是 100 即可。</li>
</ul>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://blog.csdn.net/accelerator_/article/details/39533251" target="_blank" rel="noopener">UVA 11280 - Flying to Fredericton（最短路） by lab104_yifan</a></p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>有一些程式碼註解在 <a href="https://theriseofdavid.github.io/2021/09/24/Explain_Algorithm/dijkstra/" target="_blank" rel="noopener">dijkstra’s by 大衛的筆記</a> 請供參考。</p>
<p>會在下面放一些簡單註解，供大家學習時參考。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 120</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="comment">//#define int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> t, n, m, kase=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> q, step; <span class="comment">//q 查詢, step 轉機最多幾次</span></span><br><span class="line"><span class="keyword">int</span> a, b, c, int_city; </span><br><span class="line"><span class="built_in">string</span> city, cityA, cityB; <span class="comment">//用來輸入 city </span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; citys; <span class="comment">//hash citys </span></span><br><span class="line"><span class="keyword">int</span> dist[MAXN][MAXN]; <span class="comment">//dist[city_name][int_city] 分析 3</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">status</span>&#123;</span> <span class="comment">// 我們使用 Edge struct 實做 (root, cost)</span></span><br><span class="line">    <span class="keyword">int</span> v, c, step; <span class="comment">//step 轉機幾次</span></span><br><span class="line">    status(): v(<span class="number">0</span>), c(<span class="number">0</span>), step(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    status(<span class="keyword">int</span> _v, <span class="keyword">int</span> _c, <span class="keyword">int</span> _step): v(_v), c(_c), step(_step) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> status&amp; other) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c &lt; other.c; <span class="comment">//遞減排序，決定 priority_queue 的方式</span></span><br><span class="line">        <span class="comment">//return c &gt; other.c; //遞增排序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span> <span class="comment">// 我們使用 Edge struct 實做 (root, cost)</span></span><br><span class="line">    <span class="keyword">int</span> v, c;</span><br><span class="line">    Edge(): v(<span class="number">0</span>), c(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">    Edge(<span class="keyword">int</span> _v, <span class="keyword">int</span> _c): v(_v), c(_c)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Edge&amp; other) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c &lt; other.c; <span class="comment">//遞減排序，決定 priority_queue 的方式</span></span><br><span class="line">        <span class="comment">//return c &gt; other.c; //遞增排序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; edge[MAXN]; <span class="comment">//放入題目的邊</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> root)</span></span>&#123;</span><br><span class="line">    <span class="built_in">deque</span>&lt;status&gt; q; </span><br><span class="line">    q.push_back(&#123;root,<span class="number">0</span>,<span class="number">0</span>&#125;); <span class="comment">//初始放入開始點</span></span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(dist)); <span class="comment">//全部 dist 無限大</span></span><br><span class="line">    dist[root][<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">//自己到自己成本為零</span></span><br><span class="line">    <span class="keyword">int</span> cost;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        status node = q.front(); q.pop_front();</span><br><span class="line">        <span class="comment">//cout &lt;&lt; node.v &lt;&lt; " " &lt;&lt; node.c &lt;&lt; "\n";</span></span><br><span class="line">        <span class="keyword">if</span>(node.step &gt; <span class="number">110</span>) <span class="keyword">continue</span>; <span class="comment">//轉機 110 次以上基本上不合法</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it: edge[node.v])&#123; </span><br><span class="line">            cost = dist[node.v][node.step] + it.c; <span class="comment">//分析 3</span></span><br><span class="line">            <span class="comment">//node.step+1 要比轉機後的成本還要低，才有取代的價值</span></span><br><span class="line">            <span class="keyword">if</span>(cost &lt; dist[it.v][node.step+<span class="number">1</span>])&#123; </span><br><span class="line">                q.push_back(&#123;it.v, cost, node.step+<span class="number">1</span>&#125;); <span class="comment">//放入資料</span></span><br><span class="line">                dist[it.v][node.step+<span class="number">1</span>] = cost; <span class="comment">//更改成本</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"out.txt"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        int_city = <span class="number">0</span>;</span><br><span class="line">        citys.clear();</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; city;</span><br><span class="line">            citys[city] = int_city++; <span class="comment">//hash city </span></span><br><span class="line">            edge[i].clear(); <span class="comment">//資料清除</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; cityA &gt;&gt; cityB &gt;&gt; c;</span><br><span class="line">            edge[citys[cityA]].push_back(&#123;citys[cityB], c&#125;); <span class="comment">//加入有向邊</span></span><br><span class="line">            <span class="comment">//cout &lt;&lt; citys[cityA] &lt;&lt; " " &lt;&lt; citys[cityB] &lt;&lt; " " &lt;&lt; c &lt;&lt; "\n";</span></span><br><span class="line">        &#125;</span><br><span class="line">        dijkstra(citys[<span class="string">"Calgary"</span>]); <span class="comment">//從起點出發</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Scenario #"</span> &lt;&lt; kase++ &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; q;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; MAXN; i++)&#123; <span class="comment">//分析 4</span></span><br><span class="line">           dist[citys[<span class="string">"Fredericton"</span>]][i] = min(dist[citys[<span class="string">"Fredericton"</span>]][i], dist[citys[<span class="string">"Fredericton"</span>]][i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; q; i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; step;</span><br><span class="line">            <span class="keyword">if</span>(step &gt; <span class="number">100</span>) step = <span class="number">100</span>; <span class="comment">//分析 5</span></span><br><span class="line">            ans = dist[citys[<span class="string">"Fredericton"</span>]][step+<span class="number">1</span>]; </span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(ans == INF) <span class="built_in">cout</span> &lt;&lt; <span class="string">"No satisfactory flights\n"</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"Total cost of flight(s) is $"</span> &lt;&lt; ans &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(t != <span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>Dijkstra&#39;s</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa12768 - Inspired Procrastination(Dijkstra)</title>
    <url>/2021/10/04/UVa/UVa12768/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>一個很嚴重的問題常困擾著大學生，那就是拖延XD，我們現在來看你人生中一系列的事件，有些事件你可能會拖延，有些事不會，反而會提前做，也許有的時候你可能會在幾個重複的事件繞阿繞。</p>
<p>我們想找出如果我們在人生中一系列的事件中不斷的拖延，最多可以拖延多少，如果可以拖延一輩子都不做，就輸出 Unlimited!<br><a href="https://onlinejudge.org/external/127/12768.pdf" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li><a href="https://theriseofdavid.github.io/2021/09/24/Explain_Algorithm/dijkstra/" target="_blank" rel="noopener">dijkstra’s by 大衛的筆記</a></li>
<li>繞圈圈的 dijkstra 如何解決</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ul>
<li>首先寫一個 dijkstra</li>
<li><code>priority_queue</code> 除了原本的 u,v 再加入一個陣列 <code>visit[index] = dist</code><ul>
<li>其中 visit 表示從起點到 index 距離為多少，一開始設定為 0。方便 C++ struct init</li>
<li>每次 <code>priority_queue.push()</code> 時，都會更新 <code>visit[index] = dist</code></li>
</ul>
</li>
<li>當再次碰到 <code>visit[index]</code> 且不等於 0 時表示準備進入重複事件，此時我們要判斷<ul>
<li>如果進入重複事件時當前成本，有比原本的 <code>visit[index]</code> 成本<strong>高</strong>，表示只要不斷的走重複路徑，就可以把拖延變得無限大。就可以輸出 Unlimited!</li>
<li>如果進入重複事件時當前成本，有比原本的 <code>visit[index]</code> 成本<strong>小</strong>，表示只要一直走重複路徑，就可以把每件事情都提前，就不會有拖延，因此會直接 pop 掉。</li>
</ul>
</li>
<li>題目輸出不可能為負數，如果是負數，就直接乾脆不走就好。</li>
</ul>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>好久沒有自己一個人不看詳解去寫題目了XD，原本還很怕這題會不會解不開來，因為自己不夠強，雖然有學習過，但還是不會解出變化題，結果幸好還是讓我有解開來，鰻開心的！</p>
<p>有種自己好像學以致用的感覺，好像比之前又更進步一些些。</p>
<p>不過也要感謝 udebug 提供大量測資，讓我不用一直想我錯在哪裡..，可以不斷驗證</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>有一些程式碼註解在 <a href="https://theriseofdavid.github.io/2021/09/24/Explain_Algorithm/dijkstra/" target="_blank" rel="noopener">dijkstra’s by 大衛的筆記</a> 請供參考。</p>
<p>會在下面放一些簡單註解，供大家學習時參考。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 120</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 1100*1100</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span> <span class="comment">// 我們使用 Edge struct 實做 (root, cost)</span></span><br><span class="line">    <span class="keyword">int</span> v, c;</span><br><span class="line">    Edge(): v(<span class="number">0</span>), c(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">status</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v, c, visit[MAXN];</span><br><span class="line">    status(): v(<span class="number">0</span>), c(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    status(<span class="keyword">int</span> _v, <span class="keyword">int</span> _c): v(_v), c(_c) &#123;&#125;</span><br><span class="line">    status(<span class="keyword">int</span> _v, <span class="keyword">int</span> _c, <span class="keyword">int</span> _visit[])&#123;</span><br><span class="line">        v = _v;</span><br><span class="line">        c = _c;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXN; i++) visit[i] = _visit[i]; <span class="comment">//不斷將資料透過 byval 寫入</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> status&amp; other) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="comment">//return c &lt; other.c; //遞減排序，決定 priority_queue 的方式</span></span><br><span class="line">        <span class="keyword">return</span> c &gt; other.c; <span class="comment">//遞增排序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> a, b, cost;</span><br><span class="line"><span class="built_in">vector</span>&lt;status&gt; edge[MAXN]; <span class="comment">//放入題目的邊</span></span><br><span class="line"><span class="keyword">int</span> dist[MAXN]; <span class="comment">//從 root 出發到 x 邊的最短距離</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> root)</span></span>&#123;</span><br><span class="line">    status node = status(root, <span class="number">0</span>);</span><br><span class="line">    node.visit[root] = <span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;status&gt; q;</span><br><span class="line">    q.push(node); <span class="comment">//初始放入開始點</span></span><br><span class="line">    dist[root] = <span class="number">0</span>; <span class="comment">//自己到自己成本為零</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cost;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        status node = q.top(); q.pop();</span><br><span class="line">        <span class="comment">//cout &lt;&lt; node.v &lt;&lt; " " &lt;&lt; node.c &lt;&lt; "\n";</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it: edge[node.v])&#123;</span><br><span class="line">            cost = dist[node.v] + it.c; <span class="comment">//分析 3</span></span><br><span class="line">            <span class="comment">//cout &lt;&lt; cost &lt;&lt; " " &lt;&lt; dist[it.v] &lt;&lt; " " &lt;&lt; node.visit[it.v] &lt;&lt; "\n";</span></span><br><span class="line">            <span class="keyword">if</span>(node.visit[it.v] != <span class="number">0</span>)&#123; <span class="comment">//分析 3</span></span><br><span class="line">                <span class="keyword">if</span>(cost &gt; node.visit[it.v]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(cost &lt;= node.visit[it.v]) <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(cost &gt; dist[it.v])&#123;</span><br><span class="line">                node.visit[it.v] = cost; <span class="comment">//status 經過此路徑，新增紀錄</span></span><br><span class="line">                q.push(&#123;it.v, cost, node.visit&#125;); <span class="comment">//push 資料</span></span><br><span class="line">                node.visit[it.v] = <span class="number">0</span>; <span class="comment">//更新過了，再改回來，以免干擾後續資料</span></span><br><span class="line">                dist[it.v] = cost;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"out.txt"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &amp;&amp; (n+m) != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//if(cnt == 44) cout &lt;&lt; "question " &lt;&lt; n &lt;&lt; " " &lt;&lt; m &lt;&lt; "\n";</span></span><br><span class="line">        cnt++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123; <span class="comment">//清除邊、重置距離</span></span><br><span class="line">            edge[i].clear();</span><br><span class="line">            dist[i] = -INF;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123; <span class="comment">//加入邊</span></span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; cost;</span><br><span class="line">            edge[a].push_back(&#123;b,cost&#125;); <span class="comment">//單向時使用</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> Inf_check = dijkstra(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(Inf_check == <span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">"Unlimited!\n"</span>; <span class="comment">//如果 return 0 表示拖延無限大</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> ans = <span class="number">0</span>; <span class="comment">//最小為零</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">                ans = max(ans, dist[i]); <span class="comment">//找最大拖延</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>Dijkstra&#39;s</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>與大學好朋友宜蘭三星兩天行 2021/09/25</title>
    <url>/2021/10/08/life_experence/Yilan_202109/</url>
    <content><![CDATA[<h2 id="說明"><a href="#說明" class="headerlink" title="說明"></a>說明</h2><blockquote>
<p>記錄我從 2021/09/25 ~ 2021/09/26 去宜蘭的旅行紀錄<br>謝謝在程式社團中認識的好朋友<br>他們在我的開學前增添了一段美好回憶</p>
</blockquote>
<a id="more"></a>

<h2 id="出發前的準備"><a href="#出發前的準備" class="headerlink" title="出發前的準備"></a>出發前的準備</h2><p>這次出發根本就沒有甚麼準備www，首先紹宇先說可以去他們家烤肉，大家也都說好，然後就沒有下文…。</p>
<p>直到要出發前兩天，大家才開始討論何時出發，哪裡集合www。</p>
<h2 id="9-月-25-日"><a href="#9-月-25-日" class="headerlink" title="9 月 25 日"></a>9 月 25 日</h2><h3 id="台北轉運站"><a href="#台北轉運站" class="headerlink" title="台北轉運站"></a>台北轉運站</h3><p>我們一開始約 11:30 在台北轉運站集合，可是天佑遲到了XD，然後我們就拖到 12:15 才順利上車，上車的時候我跟天佑一起做，天佑很好聊，感覺有跟他更親密了！<br>有時候大家都好忙，都不會互相關心到，我還是希望可以關心我周遭的每個好朋友。</p>
<p>天佑還說我很緊張，很像一個不安心的小動物，聽起來蠻可愛的www。</p>
<blockquote>
<p>出發前帥氣的我<br><img src="https://drive.google.com/u/2/uc?id=1798ypGJ5cPYtQs2g33vOidg7MPkvGN5r&export=download" alt=""></p>
</blockquote>
<h3 id="抵達羅東"><a href="#抵達羅東" class="headerlink" title="抵達羅東"></a>抵達羅東</h3><p>在宜蘭的路上大塞車，硬被拖到兩個小時，座得好累QQ。</p>
<blockquote>
<p>羅東車站<br><img src="https://drive.google.com/u/2/uc?id=1X-MKqmqHLW0s-pmh7q2zkS8OK2j53vUO&export=download" alt=""></p>
</blockquote>
<blockquote>
<p>羅東車站平交道</p>
<div class="video-container"><iframe src="https://www.youtube.com/embed/J93_1Wtap38" frameborder="0" loading="lazy" allowfullscreen></iframe></div>
</blockquote>
<p>到了後，先在羅東車站那邊吃了一碗滷肉飯，蠻好吃的XD，吃完後在逛逛羅東的市場、羅東的醫院，其中羅東兩家大醫院還在隔壁，好奇怪www。這樣不會搶生氣嗎</p>
<h3 id="抵達民宿"><a href="#抵達民宿" class="headerlink" title="抵達民宿"></a>抵達民宿</h3><h4 id="全聯"><a href="#全聯" class="headerlink" title="全聯"></a>全聯</h4><p>抵達民宿後，我們先做休息，後來我跟紹宇還有天佑去全聯買肉</p>
<p>在全聯的時候，一位全聯阿姨跟我聊天，我就跟他幹話回去，他說我很帥，那是當然的。阿姨，真有眼光<br>阿姨還推薦我們要買哪些肉，可是他都推薦有骨頭的QAQ，不愛有骨頭的啦。</p>
<p>不過三星的全聯阿姨很熱情，這就是人情味嗎，感覺真棒。那種陌生卻溫暖的心</p>
<h4 id="民宿景觀"><a href="#民宿景觀" class="headerlink" title="民宿景觀"></a>民宿景觀</h4><p>由於我現在股票賠錢，因此我只好精打細算QQ，算了一下後，順利讓烤肉錢 + 啤酒錢只到 2200，我好棒！理財大師大衛</p>
<blockquote>
<p>民宿風景<br><img src="https://drive.google.com/u/2/uc?id=1HP7ThJrA9DbKFhFF4AsUfw2Jrffe-JRp&export=download" alt=""></p>
</blockquote>
<p>我沒有帶手機出門，手機在民宿充電。</p>
<blockquote>
<p>裝潢內襯<br><img src="https://drive.google.com/u/2/uc?id=1vCV-wmUp1yaZ4uU2dDaVKE5NEpeafMqF&export=download" alt=""></p>
</blockquote>
<p>因為我其實沒有很想買很厚的肉，我覺得不太好烤，但是應該會有人想吃，所以我就拍了張照片問大家要吃哪塊肉</p>
<blockquote>
<p>選擇一 澳洲梅花牛排<br><img src="https://drive.google.com/u/2/uc?id=1DrQtWjV5laN82ADM1JsqJSZznSOTEPKZ&export=download" alt=""></p>
</blockquote>
<blockquote>
<p>選擇二 美國牛排<br><img src="https://drive.google.com/u/2/uc?id=12HzxUrA-kp-332WJ8XvezWCSHi2IGPsy&export=download" alt=""></p>
</blockquote>
<h3 id="烤肉"><a href="#烤肉" class="headerlink" title="烤肉"></a>烤肉</h3><p>這次由我跟力瑋與洸銘當主廚，負責烤肉。</p>
<blockquote>
<p>帥氣烤肉的我<br><img src="https://drive.google.com/u/2/uc?id=1wnopTYDvSC5gmNG0Nq5qiF6Z_Xg31s6l&export=download" alt=""></p>
<p>還有力瑋跟洸銘<br><img src="https://drive.google.com/u/2/uc?id=1Aqn6aIYZ5Vbm3yKu-kRb4tXw5mBaO2Vj&export=download" alt=""></p>
</blockquote>
<p>之後，我們就在樓下烤肉，其實我一開始沒有試過吐司＋美乃滋＋烤肉醬＋烤肉，都沒有試過XD，我就先跟好朋友們說，這個好吃，信我一把，一定會愛上wwww。</p>
<p>後來大家看我吃了一片後，大家也不反感，都吃吃看，看起來大家不反感嘛，那應該蠻好吃的喔wwww</p>
<blockquote>
<p>好吃的烤肉<br><img src="https://drive.google.com/u/2/uc?id=1hvnn16-XGalH3nnLBAnJqjkjVqfz5Uf3&export=download" alt=""></p>
</blockquote>
<p>可樂娜啤酒鐵罐沒有很好喝，要喝還是要喝玻璃瓶的，感覺比較對味。</p>
<h4 id="玉米筍"><a href="#玉米筍" class="headerlink" title="玉米筍"></a>玉米筍</h4><p>其中我有買玉米筍，我想烤玉米筍來吃，但是好像烤網太焦了，不知道怎麼考，我就拿鋁箔紙在烤盤上面烤，這樣就不會讓玉米筍焦掉了XDDD，結果旁邊的肉都熟了，玉米筍都還沒熟，哭阿qqqq。</p>
<p>我知道了，玉米筍不能放到鋁箔紙上面烤，長知識了！</p>
<blockquote>
<p>這到底甚麼玉米筍<br><img src="https://drive.google.com/u/2/uc?id=13KUXYNenfLVSx24eR4ZDrCo3LkcmK89G&export=download" alt=""></p>
</blockquote>
<h4 id="金針菇"><a href="#金針菇" class="headerlink" title="金針菇"></a>金針菇</h4><p>再來我們在全聯的時候我跟紹宇、天佑討論，金針菇要買有機的還是無機的，他們都說買有機的，可是我覺得無機應該跟有機差不多XDDD，所以我就說那我們各買一個，看大家吃不吃得出來XDDD。</p>
<p>結果我在烤金針菇的時候，用鋁箔紙包住，花了好長一段時間才煮熟，然後我給大家吃一些金針菇讓大家猜猜金針菇是有機還是無機的，結果大家都猜錯XDDD。</p>
<p>看來有機跟無機舌頭是分不出來的XDDDD。</p>
<h4 id="棉花糖"><a href="#棉花糖" class="headerlink" title="棉花糖"></a>棉花糖</h4><p>紹宇說他很會烤棉花糖，棉花糖真的很好吃。我印象很深刻，但是我那時候跑去裡面切蔥，沒看到過程。</p>
<h4 id="牛排呢？"><a href="#牛排呢？" class="headerlink" title="牛排呢？"></a>牛排呢？</h4><p>一定大家都很好奇牛排，好不好吃對吧！結果我們在冰箱找不到牛排，力瑋說有看到我們的袋子有，但是紹宇回去找都找不到XDDD，我想一定是我們忘記買了QAQ。</p>
<p>問大家說要買哪塊牛排，結果就把牛排放在架上了，好好笑。</p>
<h3 id="烤肉結束，在外面聊天"><a href="#烤肉結束，在外面聊天" class="headerlink" title="烤肉結束，在外面聊天"></a>烤肉結束，在外面聊天</h3><p>大概烤肉到 10 點時，紹宇爸爸說不能再烤了，要休息，大家就趕快滅火、清理環境。然後在外面聊天，聊一些八卦。</p>
<p>聊一聊後，因為我烤肉烤最久，身上都是烤肉味，我就提議我先去洗澡，洗澡的時候打電話跟女朋友聊天，聊著聊著很開心，結果他們都上來了，我也沒有發現，等到我出來的時候每一個都對我呼呼黑黑的笑說，大衛阿，跟女友聊得很開心喔！</p>
<p>哭阿，好尷尬..，在裡面聊天不讓你們洗澡，對不起啦&gt;&lt; </p>
<p>我跟他們說對不起後，他們其實都沒關係，禮讓我，嗚嗚嗚，好開心。</p>
<p>女朋友我還是最愛妳拉，筱柔！看我出去都會接妳電話，我是不是 100 分。</p>
<h3 id="大家洗完澡後大概-11-點左右"><a href="#大家洗完澡後大概-11-點左右" class="headerlink" title="大家洗完澡後大概 11 點左右"></a>大家洗完澡後大概 11 點左右</h3><p>此時我們就去一樓玩桌游，玩間諜，其實看不太懂，所以不太會玩，好玩的是吹牛，一直吹牛一直爽，又有洸銘一直抓，讓這個遊戲互動感變的超級高！</p>
<p>但結果不是洸銘贏，洸銘還在最後跟天佑廝殺，有夠刺激，吹牛真的是完全的心理戰，太強太誇張了。</p>
<p>我只知道一個策略，都先收集三張相同牌，一張一張打，最後下三張，就可以把前面的牌都消耗掉，後面手上又有王牌，太強了大衛，你真的太強了，無情吹牛。</p>
<p>可是我不是第一名，是第二名QQ。</p>
<blockquote>
<p>桌游<br><img src="https://drive.google.com/u/2/uc?id=1k4VMXB0KDgTd63YfwN61PBCuLFd5tp0P&export=download" alt=""> </p>
</blockquote>
<h2 id="9-月-26-日"><a href="#9-月-26-日" class="headerlink" title="9 月 26 日"></a>9 月 26 日</h2><h3 id="深夜"><a href="#深夜" class="headerlink" title="深夜"></a>深夜</h3><p>大家累了後，就回到樓上，此時其他四個人平常可能這時候都還在 coding，精神都很好，而我這時候已經昏昏欲睡，就直接躺在床上睡覺了XD。</p>
<p>隱隱約約有聽到他們說甚麼，但是都沒有很認真聽，因為太累了，腦袋都在關機。</p>
<p>最後只有聽到節風跟 Line 一些事情，其他的都想不起來了。</p>
<h3 id="早起"><a href="#早起" class="headerlink" title="早起"></a>早起</h3><p>大概早上 10 點左右，我醒來了，大家都很晚睡覺，所以此時沒有一個人是醒著的，我就躺在床上欣賞風景，順便想想股票怎麼樣才會賺XD。</p>
<p>想策略還是要在這種漂亮的風景下想，才會容易想出來呀，雖然想到的策略回家實測後發現賠錢…。<br>看來想得出來，也不一定能夠賺大錢呢…</p>
<blockquote>
<p>偷拍的風景 1<br><img src="https://drive.google.com/u/2/uc?id=1JYqBOAEp_ScjurVEkwx2oy_lbx3yVhNF&export=download" alt=""> </p>
</blockquote>
<blockquote>
<p>偷拍的風景 2<br><img src="https://drive.google.com/u/2/uc?id=12fWbktEKMKnAYd5pyQTRTZFB1KW5uzNJ&export=download" alt=""> </p>
</blockquote>
<h3 id="中午，起來拔草拉"><a href="#中午，起來拔草拉" class="headerlink" title="中午，起來拔草拉"></a>中午，起來拔草拉</h3><p>到了中午，紹宇爸爸叫大家起床，大家下去吃早餐，吃完早餐後大家把棉被套、枕頭套都拆下來，方便紹宇爸爸清洗，辛苦了！</p>
<p>而我們則到花園來開始進行拔草，不得不說，拔草真的是最辛苦的一件事情欸…，帶著手套用力將草往上拔，但是有些草十分頑強，都不讓你拔起來，還要用一些技巧才可以連根拔起…，開始懂農民的辛苦了，拔了一個小時就腰酸背痛，尤其是小草，很難拔，因為葉子太少了，不好施力，常常只把葉子拔掉，但沒有把莖拔起來，可能過兩個月她又生出來了XD。</p>
<p>拔完一趟後，還有第二趟，我們把兩道雜草清乾淨後，順利的完成任務，我又第一個去洗澡了XD。<br>沒辦法，我比較胖，很容易流汗拉QAQ。</p>
<p>而且拔草的時候，拔一些比較大的草，就會有一堆超大的螞蟻跑出來、蝸牛跑出來，我是不是毀了他們的家，應該沒有拉，我再幫他們都更，讓他們可以在 5 個月後有新的家(雜草)出來，它們應該要感謝我，對八XD。</p>
<p>拔完草後，紹宇媽媽請大家吃豆花，豆花真的好好吃，謝謝紹宇媽媽。</p>
<h3 id="下午"><a href="#下午" class="headerlink" title="下午"></a>下午</h3><p>下午我們打了下桌游，互相洗完澡後。</p>
<p>我讓紹宇帶我去買蘭陽冰棒，紹宇順便買蔥油餅給大家吃，蘭陽冰棒真的超級好吃，我一口氣帶了 25 支冰棒回家，我幫大家實測過，從蘭陽冰廠在有蜜封的保麗龍箱裡面真的可以撐 3 個小時，從宜蘭回到台北，吃到美味的冰棒，真的好讚。</p>
<p>蔥油餅也很好吃，但是蘭陽冰棒真的只在蘭陽買的到，吃起來很鮮甜，真的超讚的，希望下次可以在帶給大家吃。</p>
<p>我覺得紹宇的騎車技術比開車好，開車要再走幾次，記起感覺阿紹宇XD，那兩張駕照不可以是雞腿阿XDD。</p>
<h3 id="晚上"><a href="#晚上" class="headerlink" title="晚上"></a>晚上</h3><p>晚上我們就搭紹宇爸爸的車回家，回到羅東車站，不得不說，紹宇爸爸的車技是真的猛阿，完全沒有猶豫，任何小路都輕鬆經過，遇到他的駕駛還在猶豫要不要過，紹宇爸爸就直接加速衝走，太猛了太猛了。</p>
<p>還有，車子底盤太重不是只有我，還有其他人拉，我只是讓這個車的重心更穩，我怕大家被風吹走拉。</p>
<p>回到家後，順利吃一支冰棒，好吃。這就是宜蘭的甜蜜感，吃一支便回顧這趟宜蘭之旅中的每個片刻。</p>
]]></content>
      <categories>
        <category>人生旅途</category>
      </categories>
      <tags>
        <tag>大學Life</tag>
        <tag>人生旅途</tag>
      </tags>
  </entry>
  <entry>
    <title>NCPC2021 110年度全國大專電腦軟體設計初賽 - 27th 心得</title>
    <url>/2020/10/07/contest_experence/ncpc2021_preliminary/</url>
    <content><![CDATA[<h2 id="導讀"><a href="#導讀" class="headerlink" title="導讀"></a>導讀</h2><blockquote>
<p>紀錄 2021 參加 110年度全國大專電腦軟體設計初賽</p>
<p>這次比賽前夕大家都比較趕，來不及複習很多 NCPC 初賽的題目，只有寫一次考古題就上戰場了</p>
<p>由於這次疫情關係，因此比賽改成用遠距的方式進行，稍微變得麻煩一些。<br>要跟教授討論出電腦教室辦公室位置，還有負責來幫忙監考我們。</p>
<p>總之來來回回的確認後，終於搞定了XD。</p>
</blockquote>
<a id="more"></a>

<h2 id="比賽前"><a href="#比賽前" class="headerlink" title="比賽前"></a>比賽前</h2><p>一開始我們約 11:30 來學校先吃個拉麵，結果因為我沒有先跟老師確認電腦教室的鑰匙，導致禮拜六到學校的時候發現沒有鑰匙，沒辦法開門阿QQ。</p>
<p>只好趕緊打電話給老師，老師檢查下有沒有我們可以輕鬆解決的方法後，老師就開車過來幫我們開門XD。<br>那我們就先去吃拉麵，結果還吃到遲到XDDD，大概遲到快 20min 八。</p>
<blockquote>
<p>被鎖住的教室<br><img src="https://drive.google.com/u/2/uc?id=19TmMMVaMwQm6bjTfwIDX8O8tzzzw_qIl&export=download" alt=""></p>
</blockquote>
<h2 id="比賽中"><a href="#比賽中" class="headerlink" title="比賽中"></a>比賽中</h2><p>洸銘與天佑負責當我們的經理準備。</p>
<p>比賽開始 20min，我們還不知道比賽的密碼是甚麼，ummm有點尷尬，別人都寫出兩題了，我們還進不去考場阿，不斷來回反覆確認後，洸銘才發現原來密碼在信箱裡面。</p>
<p>首先我們趕快解出大家解出的兩個水題，力瑋中間一直 TLE，我幫他檢查下 code，但發現其實也很簡單，就蠻意外為甚麼不會過的，在多方嘗試後發現是 <code>cin.tie(0)</code>、<code>ios::sync_with_stdio(false);</code> 這兩個 cin、cout 優化不給過…。</p>
<p>再來阿官用 py 順利解出一題，過關。</p>
<p>我也使用貪婪、區間相減解出一題，名次大約在第 27 名，可是另外一題，我不知道有甚麼地方出了 bug，我一直沒辦法成功過關。<br>然後比賽的時候，監考人員還一直監督我們好好寫，給我們加油打氣下。</p>
<h2 id="比賽結束"><a href="#比賽結束" class="headerlink" title="比賽結束"></a>比賽結束</h2><p>比賽結束後，確定是第 27 名，雖然比上次還要差，但也沒有很差，因為只要再寫對一題就可以到前 10 名，這一次我們所在的區間比較大且我們比別人晚 20min 比賽，一些時間就這樣被拉掉，不過還是好希望決賽可以考好！</p>
<p>這次要檢討的是 cin、cout 優化要記得寫，long long 也要記得開。<br>題目檢討的部分，因為沒有題解，就沒辦法檢討錯誤，要在努力。</p>
<p>總之希望有好成績啦。</p>
<p>後來稍微整理下環境，一起下樓回家啦。</p>
]]></content>
      <categories>
        <category>競賽心得</category>
      </categories>
      <tags>
        <tag>大學Life</tag>
        <tag>ICPC</tag>
        <tag>程式比賽</tag>
        <tag>競賽心得</tag>
        <tag>人生旅途</tag>
      </tags>
  </entry>
  <entry>
    <title>演算法知識 - Floyd-Warshall algorithm (無權重、有權重向圖)</title>
    <url>/2021/10/11/Explain_Algorithm/floyd/</url>
    <content><![CDATA[<h2 id="Floyd-Warshall-algorithm-介紹"><a href="#Floyd-Warshall-algorithm-介紹" class="headerlink" title="Floyd-Warshall algorithm 介紹"></a>Floyd-Warshall algorithm 介紹</h2><blockquote>
<p>能夠針對<strong>有、無權重的</strong>有向圖做出全點全源最短路徑演算法。<br>全點全源：任意點到任意點的最短距離</p>
<p>時間複雜度為 \(O(n^3)\)，n 為頂點</p>
</blockquote>
<a id="more"></a>

<h2 id="Floyd-Warshall-algorithm-證明與實作"><a href="#Floyd-Warshall-algorithm-證明與實作" class="headerlink" title="Floyd-Warshall algorithm 證明與實作"></a>Floyd-Warshall algorithm 證明與實作</h2><h3 id="證明"><a href="#證明" class="headerlink" title="證明"></a>證明</h3><ul>
<li>非常暴力的動態規劃</li>
<li><code>D[i][j]</code> 表示 i 到 j 的最短距離</li>
<li>只要我們能夠讓 <code>D[i][k] + D[k][j] &lt; D[i][j]</code>，即表示如果經過 k 點，可以找到當前最短路徑，並取代。</li>
<li>迭代 i,j,k 就能完全證明，圖中所有點都是最短路徑</li>
</ul>
<h3 id="實作"><a href="#實作" class="headerlink" title="實作"></a>實作</h3><ul>
<li>使用動態規劃實作</li>
<li>節點數量為 \((1…k)\)<ul>
<li>以最短路徑為舉例</li>
<li><code>D[i][j]</code> 表示 i 到 j 的最短距離</li>
<li>除了 <code>D[i][i] = 0</code> 其他設定為無限大</li>
<li>加入其他邊</li>
<li>如果最短路徑會經過 k 點，則 <code>D[i][k] + D[k][j] &lt; D[i][j]</code>，替換答案</li>
</ul>
</li>
</ul>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://web.ntnu.edu.tw/~algo/Path3.html" target="_blank" rel="noopener">All Pairs Shortest Paths: Floyd-Warshall Algorithm by 師大演算法</a><br><a href="https://zh.wikipedia.org/wiki/Floyd-Warshall%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">Floyd-Warshall演算法 by wiki</a> </p>
<h2 id="Floyd-Warshall-algorithm-實作"><a href="#Floyd-Warshall-algorithm-實作" class="headerlink" title="Floyd-Warshall algorithm 實作"></a>Floyd-Warshall algorithm 實作</h2><p>不廢話，直接上來</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 120</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> t, n, r;</span><br><span class="line"><span class="keyword">int</span> u, v, c;</span><br><span class="line"><span class="keyword">int</span> start, destination, kase = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> dist[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floyd</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++)&#123; <span class="comment">//以 k 為中繼點</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123; <span class="comment">//從 i 出發</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123; <span class="comment">//抵達 j </span></span><br><span class="line">                <span class="comment">//如果 i to j，經過 k 會比較快就替換答案</span></span><br><span class="line">                <span class="keyword">if</span>(dist[i][k] + dist[k][j] &lt; dist[i][j]) </span><br><span class="line">                    dist[i][j] = dist[i][k] + dist[k][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123; <span class="comment">//印出最短距離圖</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%10d "</span>, dist[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; r;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                dist[i][j] = INF; <span class="comment">//一開始 i 都無法抵達 j 節點</span></span><br><span class="line">            &#125;</span><br><span class="line">            dist[i][i] = <span class="number">0</span>; <span class="comment">//但是自己可以抵達自己</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r; i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">            dist[u][v] = <span class="number">1</span>; <span class="comment">//加入邊</span></span><br><span class="line">            dist[v][u] = <span class="number">1</span>; <span class="comment">//考慮雙向邊</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        floyd();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; start &gt;&gt; destination; </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; dist[start][destination] &lt;&lt; <span class="string">"\n"</span> <span class="comment">//輸出起點到終點的最短距離</span></span><br><span class="line">        <span class="comment">//print();</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>演算法知識</category>
      </categories>
      <tags>
        <tag>Floyd-Warshall algorithm</tag>
        <tag>程式解題</tag>
        <tag>演算法知識</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa10354 - Avoiding Your Boss(Floyd)</title>
    <url>/2021/10/11/UVa/UVa10354/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>你是一個悠閒但優秀的程式設計師，有一天，你裝病請假，但你想出門到超市買東西，你要避免遇到老闆，老闆會從老闆家會走路徑到辦公室，其中老闆一定會走最短路徑，那你的任務則是避開老闆走的最短路徑中所有節點，再讓你自己走最短路徑抵達超市。</p>
<p>請輸出自己走最短路徑抵達超市的成本，不行請輸出 “MISSION IMPOSSIBLE.”</p>
<p><a href="https://onlinejudge.org/external/103/10354.pdf" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li><a href="https://theriseofdavid.github.io/2021/10/11/Explain_Algorithm/floyd/" target="_blank" rel="noopener">演算法知識 - Floyd-Warshall algorithm (無權重、有權重向圖) by 大衛的筆記</a></li>
<li>如果從老闆家到辦公室，可能有複數的最短路徑，那都要避開</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ul>
<li>首先寫一個 floyd 找出老闆的所有最短路徑</li>
<li>確認每一個點老闆會不會經過，經過就紀錄，定義 <code>ban[i]</code><ul>
<li>判斷每一個點是不是最短路徑 <code>dist1[BH][i] + dist1[i][OF] == dist1[BH][OF]</code></li>
<li>如果成立，那就是老闆會經過的點</li>
</ul>
</li>
<li>再做一個 floyd，但是避免 <code>ban[i]</code></li>
<li>之後直接輸出答案</li>
</ul>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://mypaper.pchome.com.tw/zerojudge/post/1324635740" target="_blank" rel="noopener">Avoiding Your Boss by 台長</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>以前都沒有想過 floyd 可以做到這些操作，現在學到了。好開心</p>
<p>希望我可以多應用一些演算法在日常生活上，才不會白費自己學到。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>有一些程式碼註解在 <a href="https://theriseofdavid.github.io/2021/10/11/Explain_Algorithm/floyd/" target="_blank" rel="noopener">演算法知識 - Floyd-Warshall algorithm (無權重、有權重向圖) by 大衛的筆記</a> 請供參考。</p>
<p>會在下面放一些簡單註解，供大家學習時參考。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 120</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> P, R, BH, OF, YH, M;</span><br><span class="line"><span class="keyword">int</span> u, v, c;</span><br><span class="line"><span class="keyword">int</span> dist1[MAXN][MAXN], dist2[MAXN][MAXN]; <span class="comment">//dist1 老闆家到辦公室、dist2 自己家到超市</span></span><br><span class="line"><span class="keyword">int</span> ban[MAXN]; <span class="comment">//老闆可能會經過的節點</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floyd</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= P; k++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= P; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= P; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dist1[i][k] + dist1[k][j] &lt; dist1[i][j])</span><br><span class="line">                    dist1[i][j] = dist1[i][k] + dist1[k][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floyd2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= P; k++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ban[k]) <span class="keyword">continue</span>; <span class="comment">//老闆可能會經過的節點，要避開</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= P; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ban[k]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= P; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(ban[k]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(dist2[i][k] + dist2[k][j] &lt; dist2[i][j])</span><br><span class="line">                    dist2[i][j] = dist2[i][k] + dist2[k][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; P &gt;&gt; R &gt;&gt; BH &gt;&gt; OF &gt;&gt; YH &gt;&gt; M)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= P; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= P; j++)&#123;</span><br><span class="line">                dist1[i][j] = INF;</span><br><span class="line">                dist2[i][j] = INF;</span><br><span class="line">            &#125;</span><br><span class="line">            dist1[i][i] = <span class="number">0</span>;</span><br><span class="line">            dist2[i][i] = <span class="number">0</span>;</span><br><span class="line">            ban[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; R; i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; c;</span><br><span class="line">            dist1[u][v] = c;</span><br><span class="line">            dist1[v][u] = c;</span><br><span class="line"></span><br><span class="line">            dist2[u][v] = c;</span><br><span class="line">            dist2[v][u] = c;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        floyd(); <span class="comment">//老闆家到辦公室</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= P; i++)&#123; </span><br><span class="line">            <span class="comment">//如果從老闆家 到 i 點在到辦公室跟最短距離相同，那就是老闆會經過的節點</span></span><br><span class="line">            <span class="keyword">if</span>(dist1[BH][i] + dist1[i][OF] == dist1[BH][OF])</span><br><span class="line">                ban[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        floyd2(); <span class="comment">//自己家到超市</span></span><br><span class="line">        <span class="comment">//如果 dist2 無法抵達或超市、自己家老闆都會通過，那就沒辦法</span></span><br><span class="line">        <span class="keyword">if</span>(dist2[BH][OF] == INF || ban[YH] || ban[M]) <span class="built_in">cout</span> &lt;&lt; <span class="string">"MISSION IMPOSSIBLE.\n"</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; dist2[YH][M] &lt;&lt; <span class="string">"\n"</span>; <span class="comment">//輸出答案</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>Floyd-Warshall algorithm</tag>
        <tag>UVa</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa11463 - Commandos(Floyd)</title>
    <url>/2021/10/11/UVa/UVa11463/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>敢死隊們要去爆破敵隊的建築物，有 n 個建築物要爆破，從 A 到 B 建築物都需要花費時間，我們要將所有 n 個建築物都爆破完，敢死隊們會分工進行，可以分到 n 組，爆破時間不計入，我們會再 start 點出發、destination 點集合，想請問完成這個任務，最少要花多少時間</p>
<p><a href="https://onlinejudge.org/external/114/11463.pdf" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li><a href="https://theriseofdavid.github.io/2021/10/11/Explain_Algorithm/floyd/" target="_blank" rel="noopener">演算法知識 - Floyd-Warshall algorithm (無權重、有權重向圖) by 大衛的筆記</a></li>
<li><strong>因為可以分工進行，因此我們只要算從出發點到第 i 點 + 第 i 點到集合點距離最遠即可。，因為他們是最晚回來的一組</strong></li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ul>
<li>做一次 floyd</li>
<li>對每一個點確認，輸出必須走最久的最短路徑</li>
</ul>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://www.pinghenotes.com/UVa-11463-Commandos/" target="_blank" rel="noopener">UVa 11463 - Commandos by Ping</a></p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>有一些程式碼註解在 <a href="https://theriseofdavid.github.io/2021/10/11/Explain_Algorithm/floyd/" target="_blank" rel="noopener">演算法知識 - Floyd-Warshall algorithm (無權重、有權重向圖) by 大衛的筆記</a> 請供參考。</p>
<p>會在下面放一些簡單註解，供大家學習時參考。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 120</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> t, n, r;</span><br><span class="line"><span class="keyword">int</span> u, v, c;</span><br><span class="line"><span class="keyword">int</span> start, destination, kase = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> dist[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floyd</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dist[i][k] + dist[k][j] &lt; dist[i][j])</span><br><span class="line">                    dist[i][j] = dist[i][k] + dist[k][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%10d "</span>, dist[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; r;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                dist[i][j] = INF;</span><br><span class="line">            &#125;</span><br><span class="line">            dist[i][i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r; i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">            dist[u][v] = <span class="number">1</span>;</span><br><span class="line">            dist[v][u] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        floyd();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; start &gt;&gt; destination;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123; <span class="comment">//判斷從 start to i, i to destination 最久的距離是哪個，輸出他</span></span><br><span class="line">            <span class="keyword">if</span>(dist[start][i] + dist[i][destination] &gt; ans)&#123;</span><br><span class="line">                ans = dist[start][i] + dist[i][destination];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//print();</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Case "</span> &lt;&lt; kase++ &lt;&lt; <span class="string">": "</span> &lt;&lt; ans &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>Floyd-Warshall algorithm</tag>
        <tag>UVa</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>演算法知識 - Maximum Bipartite Matching (使用 Augmenting Path Algorithm)</title>
    <url>/2021/10/16/Explain_Algorithm/Maximum_Bipartite_Matching/</url>
    <content><![CDATA[<h2 id="Maximum-Bipartite-Matching-介紹"><a href="#Maximum-Bipartite-Matching-介紹" class="headerlink" title="Maximum Bipartite Matching 介紹"></a>Maximum Bipartite Matching 介紹</h2><blockquote>
<p>在介紹最大二分匹配時，必須先介紹二分圖。<br>二分圖是一種圖的特例，二分圖的結構為，X 群體的每一個點都有連結到至少一個以上 Y 群體的點、T 群體的每一個點都有連結到至少一個以上 X 群體的點，且 X、Y 群體各自沒有邊互相連接。<br><img src="https://drive.google.com/u/2/uc?id=1lSatIhYWuXC1s4yqM_3qgz3CpkKzYg_3&export=download" alt=""><br>圖源引用師大演算法</p>
<p>二分匹配就是，每一個 x 節點只能連到一個 y 個節點、每一個 y 節點只能連到一個 x 個節點，舊式二分匹配，類似於一夫一妻制。<br><img src="https://drive.google.com/u/2/uc?id=1qJJvxwOkz6cTJ40gFXnURnYWEbbyuaMd&export=download" alt=""><br>圖源引用師大演算法</p>
<p>我們使用 Augmenting Path Algorithm 實作，時間複雜度為 \(O(VE)\)，V 是頂點、e 是邊</p>
</blockquote>
<a id="more"></a>

<h2 id="Augmenting-Path-Algorithm-證明與實作"><a href="#Augmenting-Path-Algorithm-證明與實作" class="headerlink" title="Augmenting Path Algorithm 證明與實作"></a>Augmenting Path Algorithm 證明與實作</h2><h3 id="證明"><a href="#證明" class="headerlink" title="證明"></a>證明</h3><ul>
<li>我們可以用 DFS，與三個陣列來解釋<ul>
<li><code>mx[]</code> x 每一個節點連接 y 的節點</li>
<li><code>my[]</code> y 的每一個節點連接 x 的節點</li>
<li><code>vy[]</code> 判斷 y 是否有被走過</li>
</ul>
</li>
<li>我們知道 DFS 會走完所有的路程，因此我們對每一個 x 進行 dfs，如果 \(E(x,y)\)，且 y 沒有跟其他 x 點連接，那表示是一個匹配。</li>
<li>如果 y 有跟其他 x 點連接(定義 x’)，那我們只要讓 x’ 在找到下一個 y 點即可。<ul>
<li>如果找的到，那就新增一個最大匹配</li>
<li>如果找不到，表示無法新增</li>
</ul>
</li>
</ul>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul>
<li>建立 <code>mx[],my[],vy[]</code>，並且有一個 <code>edge[]</code> vector，edge 為邊</li>
<li>將 <code>mx[],my[]</code>，設為 -1，表示沒有匹配節點</li>
<li>對每一個 x 節點進行 DFS<ul>
<li>如果 y 節點為 -1，那就新增匹配</li>
<li>如果 y 節點配對 x’，檢查 x’，進行 DFS</li>
</ul>
</li>
<li>如果沒有辦法匹配，輸出 false</li>
</ul>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://web.ntnu.edu.tw/~algo/Matching.html#4" target="_blank" rel="noopener">Maximum Bipartite Matching: Augmenting Path Algorithm by 師大演算法</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>謝謝師大演算法幫助我這麼多，在北科學不太到的知識可以透過網路自學的方式學習，感謝你們！</p>
<h2 id="Augmenting-Path-Algorithm-實作"><a href="#Augmenting-Path-Algorithm-實作" class="headerlink" title="Augmenting Path Algorithm 實作"></a>Augmenting Path Algorithm 實作</h2><p>不廢話，直接上來</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; edge[MAXN];</span><br><span class="line"><span class="keyword">int</span> mx[MAXN], my[MAXN], vy[MAXN]; <span class="comment">//matchX, matchY, visitY</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> y: edge[x])&#123; <span class="comment">//對 x 可以碰到的邊進行檢查</span></span><br><span class="line">        <span class="keyword">if</span>(vy[y] == <span class="number">1</span>) <span class="keyword">continue</span>; <span class="comment">//避免遞迴 error</span></span><br><span class="line">        vy[y] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(my[y] == <span class="number">-1</span> || dfs(my[y]))&#123; <span class="comment">//分析 3</span></span><br><span class="line">            mx[x] = y;</span><br><span class="line">            my[y] = x;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//分析 4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bipartite_matching</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(mx, <span class="number">-1</span>, <span class="keyword">sizeof</span>(mx)); <span class="comment">//分析 1,2</span></span><br><span class="line">    <span class="built_in">memset</span>(my, <span class="number">-1</span>, <span class="keyword">sizeof</span>(my));</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++)&#123;  <span class="comment">//對每一個 x 節點進行 DFS(最大匹配)</span></span><br><span class="line">        <span class="built_in">memset</span>(vy, <span class="number">0</span>, <span class="keyword">sizeof</span>(vy));</span><br><span class="line">        <span class="keyword">if</span>(dfs(i)) ans++;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>演算法知識</category>
      </categories>
      <tags>
        <tag>程式解題</tag>
        <tag>演算法知識</tag>
        <tag>Maximum Bipartite Matching 二分匹配</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa10342 - Always Late(Dijkstra&#39;s、SPFA、次短路徑)</title>
    <url>/2021/10/11/UVa/UVa10342/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>有一支隊伍比賽時都會遲到，因為他們都喜歡走第二短路徑，且他們允許重複經過相同的道路。<br>請告訴我們，他們走第二短路徑需要花多少時間。</p>
<p><a href="https://onlinejudge.org/external/103/10342.pdf" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li><a href="https://theriseofdavid.github.io/2021/09/24/Explain_Algorithm/dijkstra/" target="_blank" rel="noopener">dijkstra’s by 大衛的筆記</a><br>將 <code>priority_queue</code> 改成一般的 <code>deque</code> 即可。</li>
<li>使用 <code>visit[node]</code> 避免 <code>deque</code> 裡面有相同的節點，卻有不同的成本，導致浪費時間</li>
<li><strong>路徑可以重複，但不能來回走</strong></li>
<li><code>dist[node][第幾短路徑]</code> 來得知第二短路徑，從 0 開始表示第一短</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ul>
<li>由於這題可以重複經過路徑，如果用 <code>priority_queue</code> 會變成都 <code>front</code> 成本小的節點，所以有高機率 <code>priority_queue</code> 都還在 <code>front</code> 起點附近的路徑，導致 TLE。</li>
<li><code>dist[node][第幾短路徑]</code><ul>
<li>當現在的 <code>cost = dist[node][x]</code> 表示現在這個節點跟第 x 短路徑成本相同，並不需要紀錄</li>
<li><code>cost != dist[node][0] &amp;&amp; cost != dist[node][1]</code> 表示與第一、第二最短路徑不同</li>
<li>如果 <code>cost &lt; dist[it.v][1]</code> 表示當前第二短路徑還比較大，因此替換</li>
<li><code>if(cost &lt; dist[it.v][0])</code> 表示當前第一短路徑還比成本高，因此把第一路徑和第二路徑成本替換，不需要跟 cost 換，因為會在上一個 if 就讓 <code>cost != dist[node][0]</code></li>
<li>紀錄現在 <code>deque</code> 裡面的節點有哪些，避免無線輪迴<ul>
<li>舉例有一個地圖是 (a,b)，沒有紀錄 deque 裡面節點則會導致，deque 不斷的進行 a,b </li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="http://mobcs.blogspot.com/2015/07/uva-10342-always-late.html" target="_blank" rel="noopener">[UVa] 10342 - Always Late by Hi, I am Code</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>好題好題，我學起來了，有時候還是不太懂變形題，還要再多磨練</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>有一些程式碼註解在 <a href="https://theriseofdavid.github.io/2021/09/24/Explain_Algorithm/dijkstra/" target="_blank" rel="noopener">dijkstra’s by 大衛的筆記</a> 請供參考。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 120</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2100000000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span> <span class="comment">// 我們使用 Edge struct 實做 (root, cost)</span></span><br><span class="line">    <span class="keyword">int</span> v, c;</span><br><span class="line">    Edge(): v(<span class="number">0</span>), c(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    Edge(<span class="keyword">int</span> _v, <span class="keyword">int</span> _c): v(_v), c(_c) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Status</span>&#123;</span> <span class="comment">// 我們使用 Status struct 實做 priority_queue (root, cost)</span></span><br><span class="line">    <span class="keyword">int</span> v, c; <span class="comment">//v 節點, c 成本</span></span><br><span class="line">    Status(): v(<span class="number">0</span>), c(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    Status(<span class="keyword">int</span> _v, <span class="keyword">int</span> _c): v(_v), c(_c) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Status&amp; other) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c &lt; other.c; <span class="comment">//遞減排序，決定 priority_queue 的方式</span></span><br><span class="line">        <span class="comment">//return c &gt; other.c; //遞增排序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> kase = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> n, r, q, start, destination;</span><br><span class="line"><span class="keyword">int</span> a, b, c;</span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; edge[MAXN];</span><br><span class="line"><span class="keyword">int</span> dist[MAXN][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> visit[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> root)</span></span>&#123;</span><br><span class="line">    <span class="comment">//because dijkstra find second shortest path,which push duplicate node</span></span><br><span class="line">    <span class="comment">//priority_queue&lt;Status&gt; q; //TLE</span></span><br><span class="line">    <span class="built_in">deque</span>&lt;Status&gt; q;</span><br><span class="line">    q.push_back(&#123;root,<span class="number">0</span>&#125;); <span class="comment">//初始放入開始點</span></span><br><span class="line">    dist[root][<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">//自己到自己成本為零</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cost;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        Status node = q.front(); q.pop_front();</span><br><span class="line">        <span class="comment">//cout &lt;&lt; node.v &lt;&lt; " " &lt;&lt; node.c &lt;&lt; "\n";</span></span><br><span class="line"></span><br><span class="line">        visit[node.v] = <span class="number">0</span>; <span class="comment">//分析 2-5 可以再次經過他，因為不會使 deque 節點中資料在裡面 circle</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it: edge[node.v])&#123;</span><br><span class="line">            cost = dist[node.v][<span class="number">0</span>] + it.c;</span><br><span class="line">            <span class="keyword">if</span>(cost != dist[it.v][<span class="number">0</span>] &amp;&amp; cost != dist[it.v][<span class="number">1</span>])&#123; <span class="comment">//分析 2-2</span></span><br><span class="line">                <span class="keyword">if</span>(cost &lt; dist[it.v][<span class="number">1</span>])&#123; <span class="comment">//分析 2-3</span></span><br><span class="line">                    dist[it.v][<span class="number">1</span>] = cost;</span><br><span class="line">                    <span class="comment">//分析 2-4</span></span><br><span class="line">                    <span class="keyword">if</span>(cost &lt; dist[it.v][<span class="number">0</span>]) swap(dist[it.v][<span class="number">0</span>], dist[it.v][<span class="number">1</span>]); </span><br><span class="line">                    <span class="keyword">if</span>(!visit[it.v])&#123; <span class="comment">//分析 2-5</span></span><br><span class="line">                        visit[it.v] = <span class="number">1</span>;</span><br><span class="line">                        q.push_back(&#123;it.v, cost&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            cost = dist[node.v][<span class="number">1</span>] + it.c; </span><br><span class="line">            <span class="keyword">if</span>(cost != dist[it.v][<span class="number">0</span>] &amp;&amp; cost != dist[it.v][<span class="number">1</span>])&#123; <span class="comment">//分析 2-2</span></span><br><span class="line">                <span class="keyword">if</span>(cost &lt; dist[it.v][<span class="number">1</span>])&#123;  <span class="comment">//分析 2-3</span></span><br><span class="line">                    dist[it.v][<span class="number">1</span>] = cost;</span><br><span class="line">                    <span class="comment">//分析 2-4</span></span><br><span class="line">                    <span class="keyword">if</span>(cost &lt; dist[it.v][<span class="number">0</span>]) swap(dist[it.v][<span class="number">0</span>], dist[it.v][<span class="number">1</span>]);</span><br><span class="line">                    <span class="keyword">if</span>(!visit[it.v])&#123; <span class="comment">//分析 2-5</span></span><br><span class="line">                        visit[it.v] = <span class="number">1</span>;</span><br><span class="line">                        q.push_back(&#123;it.v, cost&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"out.txt"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; r)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) edge[i].clear();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r; i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">            edge[a].push_back(&#123;b,c&#125;);</span><br><span class="line">            edge[b].push_back(&#123;a,c&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; q;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Set #"</span> &lt;&lt; kase++ &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">        <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">                dist[i][<span class="number">0</span>] = INF;</span><br><span class="line">                dist[i][<span class="number">1</span>] = INF;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">memset</span>(visit, <span class="number">0</span>, <span class="keyword">sizeof</span>(visit));</span><br><span class="line"></span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; start &gt;&gt; destination;</span><br><span class="line">            dijkstra(start);</span><br><span class="line">            <span class="keyword">if</span>(dist[destination][<span class="number">1</span>] == INF) <span class="built_in">cout</span> &lt;&lt; <span class="string">"?\n"</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; dist[destination][<span class="number">1</span>] &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>Dijkstra&#39;s</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa12668 - Attacking rooks(Maximum Bipartite Matching 二分匹配)</title>
    <url>/2021/10/16/UVa/UVa12668/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>給你一個西洋棋盤，會在這個棋盤上放一些小兵，你必須在這個棋盤中放入一些城堡，且保證城堡攻擊範圍不會有另外一個城堡<br>試問最多可以放幾個</p>
<p><a href="https://blog.csdn.net/acmmmm/article/details/40599333?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_title~default-1.no_search_link&spm=1001.2101.3001.4242" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li><a href="https://theriseofdavid.github.io/2021/10/16/Explain_Algorithm/Maximum_Bipartite_Matching/" target="_blank" rel="noopener">Maximum Bipartite Matching by 大衛的筆記</a></li>
<li>如何將棋盤變成二分圖</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ul>
<li>題目要求為，不讓城堡看到城堡，也就是城堡在的位置\((x,y)\)，其 x 軸與 y 軸都不可以有其他城堡，除非有小兵擋住，那就是一個很明顯的二分圖，x 對 y 二分</li>
<li>如果有小兵站在棋盤上，那我們應該要以小兵為分界線，分出兩個 x,y 軸，因為站在小兵兩旁的城堡是合法的</li>
<li>再來我們相同的 x,y 軸都設定為同一號碼，不斷進行匹配即可。</li>
</ul>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://blog.csdn.net/acmmmm/article/details/40599333?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_title~default-1.no_search_link&spm=1001.2101.3001.4242" target="_blank" rel="noopener">UVALive 6525 Attacking rooks 二分匹配 经典题 by 九野的博客</a><br><a href="https://blog.csdn.net/u013081425/article/details/25217803?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EOPENSEARCH%7Edefault-6.no_search_link&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EOPENSEARCH%7Edefault-6.no_search_link" target="_blank" rel="noopener">UVALive 6525 Attacking rooks(二分图最大匹配) by FDU_Nan</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>這題我學了好久…，第一次寫到用棋盤來表達二分圖，一開始真的是完全不知道原來這裡要用二分圖阿XDDD，也學到原來可以將二分圖的<strong>節點</strong>內在放入很多的點，就可以做到讓題目的要求，太神了、太酷了，第一次學到。</p>
<p>希望學起來可以對我的未來有幫助</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>有一些程式碼註解在 <a href="https://theriseofdavid.github.io/2021/10/16/Explain_Algorithm/Maximum_Bipartite_Matching/" target="_blank" rel="noopener">Maximum Bipartite Matching by 大衛的筆記</a> 請供參考。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 120</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; edge[MAXN*MAXN];</span><br><span class="line"><span class="keyword">int</span> graph[MAXN][MAXN];</span><br><span class="line"><span class="keyword">int</span> mx[MAXN*MAXN], my[MAXN*MAXN], vy[MAXN*MAXN]; <span class="comment">//matchX, matchY, visitY</span></span><br><span class="line"><span class="keyword">int</span> ex[MAXN][MAXN], ey[MAXN][MAXN]; <span class="comment">//edgeX, edgeY</span></span><br><span class="line"><span class="keyword">int</span> n, cnt;</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> y: edge[x])&#123;</span><br><span class="line">        <span class="keyword">if</span>(vy[y] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        vy[y] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(my[y] == <span class="number">-1</span> || dfs(my[y]))&#123;</span><br><span class="line">            mx[x] = y;</span><br><span class="line">            my[y] = x;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bipartite_matching</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(mx, <span class="number">-1</span>, <span class="keyword">sizeof</span>(mx));</span><br><span class="line">    <span class="built_in">memset</span>(my, <span class="number">-1</span>, <span class="keyword">sizeof</span>(my));</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(vy, <span class="number">0</span>, <span class="keyword">sizeof</span>(vy));</span><br><span class="line">        <span class="keyword">if</span>(dfs(i)) ans++;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">connect_edge</span><span class="params">()</span></span>&#123; <span class="comment">//將棋盤轉換成二分圖的邊</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++) edge[i].clear();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(graph[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">                x = ex[i][j];</span><br><span class="line">                edge[x].push_back(ey[i][j]); <span class="comment">//這個點的相同 x,y 軸，組成一個邊</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_graph</span><span class="params">()</span></span>&#123; <span class="comment">//debug 與方便學習用</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%2d "</span>, graph[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_ex</span><span class="params">()</span></span>&#123; <span class="comment">//debug 與方便學習用</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%2d "</span>, ex[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_ey</span><span class="params">()</span></span>&#123; <span class="comment">//debug 與方便學習用</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%2d "</span>, ey[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"out.txt"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(graph, <span class="number">0</span>, <span class="keyword">sizeof</span>(graph)); <span class="comment">//清空資料</span></span><br><span class="line">        <span class="built_in">memset</span>(ex, <span class="number">0</span>, <span class="keyword">sizeof</span>(ex));</span><br><span class="line">        <span class="built_in">memset</span>(ey, <span class="number">0</span>, <span class="keyword">sizeof</span>(ey));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果那一個 row or column 有小兵存在，那分裂後的 x 軸就從 n+1 開始依序 hash</span></span><br><span class="line">        cnt = n+<span class="number">1</span>; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">            s = <span class="string">' '</span> + s; <span class="comment">//從 index 1 開始</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[j] == <span class="string">'X'</span>) graph[i][j] = cnt++; <span class="comment">//表示這邊可以分裂 row and column </span></span><br><span class="line">                <span class="keyword">else</span> graph[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//print_graph();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//y 軸，從前往後，判斷他們是否屬於同一個 y 軸</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) ey[<span class="number">0</span>][i] = i; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">                <span class="comment">//如果有分裂，那就將 ey 點開始往前都變為新節點</span></span><br><span class="line">                <span class="keyword">if</span>(graph[i][j]) ey[i][j] = graph[i][j]; </span><br><span class="line">                <span class="keyword">else</span> ey[i][j] = ey[i<span class="number">-1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//print_ey(); cout &lt;&lt; "\n";</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//x 軸，從後往前，判斷他們是否屬於同一個 x 軸</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) ex[i][n+<span class="number">1</span>] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &gt; <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">                <span class="comment">//如果有分裂，那就將 ex 點開始往前都變為新節點</span></span><br><span class="line">                <span class="keyword">if</span>(graph[j][i]) ex[j][i] = graph[j][i];</span><br><span class="line">                <span class="keyword">else</span> ex[j][i] = ex[j][i+<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//print_ex();</span></span><br><span class="line"></span><br><span class="line">        connect_edge();</span><br><span class="line">        <span class="keyword">int</span> ans = bipartite_matching();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>Maximum Bipartite Matching 二分匹配</tag>
      </tags>
  </entry>
  <entry>
    <title>財務報表分析 - 第四章 財務報表分析的技術、常有的財務比率</title>
    <url>/2021/10/24/Financial_Statement%20_Analysis/Financial_Statement%20_Analysis_04/</url>
    <content><![CDATA[<h2 id="將資產負債表及綜合損益表轉換成共同比財務報表"><a href="#將資產負債表及綜合損益表轉換成共同比財務報表" class="headerlink" title="將資產負債表及綜合損益表轉換成共同比財務報表"></a>將資產負債表及綜合損益表轉換成共同比財務報表</h2><ul>
<li>資產負債表: 以資產總額為 100%，各項金額除以資產總額就是各項比率</li>
<li>綜合損益表: 以營業收入(銷貨淨額)為 100%，各項金額除以銷貨淨額就是各項比率<ul>
<li>台積電 2019 年簡明損益比較分析<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1vLBfp_o-PsFZ_1l75f9hwYKQMFsGtHKQ&export=download" alt=""></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="舉例：台積電的獲利之趨勢分析"><a href="#舉例：台積電的獲利之趨勢分析" class="headerlink" title="舉例：台積電的獲利之趨勢分析"></a>舉例：台積電的獲利之趨勢分析</h3><blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1ylAB7cmCslN86tz3b7VUd_oToXJr5vZf&export=download" alt=""><br><img src="https://drive.google.com/u/2/uc?id=1GkDWYJGpYhzP2C6eAHoD6LYQs6LFOI9s&export=download" alt=""></p>
</blockquote>
<ul>
<li>以 2013 為 base，去對 2014~2019 做比例</li>
<li>營業收入淨額、營業毛利、營業利益、本期淨利都是往上，表示這公司獲利良好，是一間好公司。 </li>
<li>但近期向上幅度變小，可能有點沒力，需要密切注意下一年的狀態。</li>
</ul>
<h2 id="常用的財務比率"><a href="#常用的財務比率" class="headerlink" title="常用的財務比率"></a>常用的財務比率</h2><h3 id="變現力比率"><a href="#變現力比率" class="headerlink" title="變現力比率"></a>變現力比率</h3><ul>
<li>流動比率 \(\frac{流動資產}{流動負債}\)</li>
<li>速動比率 \(\frac{速動資產}{流動負債} = \frac{流動資產 - 存貨 - 預付費用}{流動負債}\)</li>
</ul>
<h3 id="負債管理比率"><a href="#負債管理比率" class="headerlink" title="負債管理比率"></a>負債管理比率</h3><ul>
<li>負債比例 \(\frac{負債總額}{資產總額}\)</li>
<li>負債對股東權益比率 \(\frac{負債總額}{股東權益總額}\)</li>
<li>權益乘數 \(\frac{資產總額}{股東權益總額}\)</li>
<li>利息保障倍數 \(\frac{稅前息前淨利}{利息費用}\)</li>
<li>現金涵蓋比率 \(\frac{稅前息前淨利+折舊費用}{利息費用}\)</li>
</ul>
<h3 id="資產管理比例"><a href="#資產管理比例" class="headerlink" title="資產管理比例"></a>資產管理比例</h3><ul>
<li>存貨周轉率 \(\frac{營業成本}{平均存貨}\)</li>
<li>存貨週轉天數 \(\frac{365天}{存貨周轉率}\)</li>
<li>應收帳款周轉率 \(\frac{賒帳收入淨額}{平均應收帳款}\)</li>
<li>平均收現期間 \(\frac{365天}{應收帳款週轉率} \)</li>
<li>不動產、廠房及設備周轉率 \(\frac{營業收入淨額}{平均淨不動產、廠房及設備}\)</li>
<li>總資產周轉率 \(\frac{營業收入淨額}{平均總資產}\)</li>
</ul>
<h3 id="獲利能力比率"><a href="#獲利能力比率" class="headerlink" title="獲利能力比率"></a>獲利能力比率</h3><ul>
<li>純益率 \(\frac{稅後淨利}{營業收入淨額}\)</li>
<li>股東權益報酬率 \(\frac{稅後淨利}{平均股東權益}\)</li>
<li>總資產報酬率 \(\frac{稅後淨利 + 利息費用 * (1- 邊際稅率)}{平均總資產}\)</li>
</ul>
<h3 id="市場價值比率"><a href="#市場價值比率" class="headerlink" title="市場價值比率"></a>市場價值比率</h3><ul>
<li>本益比 \(\frac{普通股每股市價}{每股盈餘}\)</li>
<li>股利收益率 \(\frac{每股股利}{普通股每股市價}\)</li>
<li>市價淨值比 \(\frac{每股股價}{每股淨值}\)</li>
</ul>
<h2 id="作業"><a href="#作業" class="headerlink" title="作業"></a>作業</h2><p><a href="https://hackmd.io/EUkI8p67Sjycz61-kM1eyw" target="_blank" rel="noopener">財報分析 - Ch04 財務報表分析的技術</a></p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p>財務報表分析(五版) by 謝劍平</p>
]]></content>
      <categories>
        <category>北科上課筆記</category>
        <category>財務報表分析</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>財務報表分析筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>財務報表分析 - 第三章 認識現金流量表與權益變動表</title>
    <url>/2021/10/21/Financial_Statement%20_Analysis/Financial_Statement%20_Analysis_03/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊與財金管理系大三上財務報表分析重點整理<br><font color="#dd0000">並非所有人都適用，部分對我而言稍加容易的內容並不會寫在此內。</font></p>
<p>如果有侵犯到版權的問題在聯繫我，再聯絡我，我在移除</p>
</blockquote>
<a id="more"></a>

<h2 id="了解現金與企業活動的關聯"><a href="#了解現金與企業活動的關聯" class="headerlink" title="了解現金與企業活動的關聯"></a>了解現金與企業活動的關聯</h2><blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1oK3jWmasnDK6IxPyh97CZLaJkOt0agmV&export=download" alt=""></p>
</blockquote>
<h2 id="現金流量計算與類型"><a href="#現金流量計算與類型" class="headerlink" title="現金流量計算與類型"></a>現金流量計算與類型</h2><p>由於都是基礎的會計知識，有對會計有初中級了解、並熟知分錄即可知道，比較偏向定義；因此我在這邊附上二連結，方便大家學習</p>
<p><a href="http://blog.ncue.edu.tw/sys/lib/read_attach.php?id=10774" target="_blank" rel="noopener">由會計基本方程式破解現金流量法的快速解法 by 彰商 吳秀蓮</a><br><a href="https://rich01.com/what-operating-cash-flow/" target="_blank" rel="noopener">營業現金流量是什麼、如何計算？如何用它來分析公司營運 by Mr.Marker 先生</a><br><a href="https://drive.google.com/file/d/1ErOl_pK9KbwtolduMoNALfSzUEaytH-1/view?usp=sharing" target="_blank" rel="noopener">老師上課筆記 pdf 照片，不是個人筆記就非公開</a></p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p>財務報表分析(五版) by 謝劍平</p>
<h2 id="作業"><a href="#作業" class="headerlink" title="作業"></a>作業</h2><p><a href="https://hackmd.io/XWWE34ufRj6hhGQXUipjig" target="_blank" rel="noopener">財報分析 - Ch03</a></p>
]]></content>
      <categories>
        <category>北科上課筆記</category>
        <category>財務報表分析</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>財務報表分析筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>財務報表分析 - 第五章 流動性分析</title>
    <url>/2021/10/21/Financial_Statement%20_Analysis/Financial_Statement%20_Analysis_05/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊與財金管理系大三上財務報表分析重點整理<br><font color="#dd0000">並非所有人都適用，部分對我而言稍加容易的內容並不會寫在此內。</font></p>
<p>如果有侵犯到版權的問題在聯繫我，再聯絡我，我在移除</p>
</blockquote>
<a id="more"></a>

<h2 id="流動性分析的重要性及目的"><a href="#流動性分析的重要性及目的" class="headerlink" title="流動性分析的重要性及目的"></a>流動性分析的重要性及目的</h2><h3 id="應受帳款分析注意事項"><a href="#應受帳款分析注意事項" class="headerlink" title="應受帳款分析注意事項"></a>應受帳款分析注意事項</h3><ul>
<li>是否美化帳面<br>EX: 在財報發布前，給客戶大量優惠，讓客戶大量購買已達到帳面美化功能</li>
<li>是否借新還舊<br>避免先將舊應付票據用<strong>新的應付票據去償還</strong></li>
<li>公司信用政策<br>檢查公司對於應受帳款接受度，如果應收帳款越高則呆帳可能性就越高，但公司如果都不接受應收帳款則可能導致公司客戶流失。</li>
<li>帳齡分析<br>透過帳齡分析表，得知公司的應收帳款狀況</li>
<li>客戶集中度<br>如果客戶越集中，則客戶議價能力強，如果客戶流失則會導致公司財務狀況出現震盪</li>
</ul>
<h3 id="2018-台灣各產業平均收現期間"><a href="#2018-台灣各產業平均收現期間" class="headerlink" title="2018 台灣各產業平均收現期間"></a>2018 台灣各產業平均收現期間</h3><ul>
<li>觀光事業大多在出遊前就會收集好款項，才會帶你出去玩</li>
<li>汽車工業，則因為汽車昂貴，大都需要貸款，才導致應收帳款這麼久</li>
</ul>
<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1tZT9lg7PWL_brZzamYyw1jCndlnfkFAn&export=download" alt=""></p>
</blockquote>
<h2 id="存貨價值"><a href="#存貨價值" class="headerlink" title="存貨價值"></a>存貨價值</h2><ul>
<li>存貨數量為正確的盤點數量，而非帳面數量</li>
<li>存貨價值則兩者取其低<ul>
<li>成本：先進先出、平均加權、個別認定法</li>
<li>淨變現價值</li>
</ul>
</li>
</ul>
<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1L22ytsERe6HmyHRXsYuxAGrB5KLmgiE2&export=download" alt=""></p>
</blockquote>
<h3 id="存貨錯誤對綜合損益表的影響"><a href="#存貨錯誤對綜合損益表的影響" class="headerlink" title="存貨錯誤對綜合損益表的影響"></a>存貨錯誤對綜合損益表的影響</h3><blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=17Gln9ay3XromVtvDBRG18ZyrOp98Pj9-&export=download" alt=""></p>
</blockquote>
<h3 id="台灣各產業平均存貨週轉天數"><a href="#台灣各產業平均存貨週轉天數" class="headerlink" title="台灣各產業平均存貨週轉天數"></a>台灣各產業平均存貨週轉天數</h3><ul>
<li>以營造業最久，建造房子需要花費大量時間</li>
<li>觀光業最少，旅遊行程通常都在近期才推出</li>
</ul>
<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1ht244glbxws7Y6byb49dCGEPMFqDvL7K&export=download" alt=""></p>
</blockquote>
<h2 id="作業與練習"><a href="#作業與練習" class="headerlink" title="作業與練習"></a>作業與練習</h2><p><a href="https://hackmd.io/zil2Dr-TSCmycz375LGMwA" target="_blank" rel="noopener">財報分析 - Ch05 流動性分析之基本要素</a></p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p>財務報表分析(五版) by 謝劍平</p>
]]></content>
      <categories>
        <category>北科上課筆記</category>
        <category>財務報表分析</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>財務報表分析筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>財務報表分析 - 第六章 現金流量分析</title>
    <url>/2021/10/21/Financial_Statement%20_Analysis/Financial_Statement%20_Analysis_06/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊與財金管理系大三上財務報表分析重點整理<br><font color="#dd0000">並非所有人都適用，部分對我而言稍加容易的內容並不會寫在此內。</font></p>
<p>如果有侵犯到版權的問題在聯繫我，再聯絡我，我在移除</p>
</blockquote>
<a id="more"></a>

<h2 id="現金流量表"><a href="#現金流量表" class="headerlink" title="現金流量表"></a>現金流量表</h2><p>由於現金流量比起收入更難造假，因此有時會用現金流量才審視這間公司合不合格</p>
<h3 id="現金流量分析用處"><a href="#現金流量分析用處" class="headerlink" title="現金流量分析用處"></a>現金流量分析用處</h3><ul>
<li>對獲取現金能力做出評價</li>
<li>對償債能力做出評價</li>
<li>對收益品質做出評價</li>
<li>對投資活動、籌資活動做出評價</li>
</ul>
<h2 id="現金流量計算"><a href="#現金流量計算" class="headerlink" title="現金流量計算"></a>現金流量計算</h2><blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1ItnSt2ZMcHSlYDVzoO1n-hSK3Avk3g7R&export=download" alt=""><br><img src="https://drive.google.com/u/2/uc?id=1287R5rBZ5r3trgVsiut12_8ggJvmZJJv&export=download" alt=""></p>
</blockquote>
<ul>
<li>\(自由現金流量 = 營業用現金流量 - 資本支出 \)</li>
</ul>
<h2 id="現金流量公式"><a href="#現金流量公式" class="headerlink" title="現金流量公式"></a>現金流量公式</h2><blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=186QfSHvXh9BAETvt-5TAC9QyZx7lHrnB&export=download" alt=""></p>
</blockquote>
<h3 id="現金流量比率"><a href="#現金流量比率" class="headerlink" title="現金流量比率"></a>現金流量比率</h3><p>\( 現金流量比例 = 營業活動之淨現金收入 / 流動負債合計 * 100% \)<br>與流動比例有關，現金流入越多表示對當期債務償還保障越強，企業的流動性越好；表示營業活動現金流入是否可以應付流動負債</p>
<p>例題:</p>
<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1zhzMmUOhXDdw8FgrZvJbu7E0OwwTJP-e&export=download" alt=""></p>
</blockquote>
<h3 id="現金流量允當比率"><a href="#現金流量允當比率" class="headerlink" title="現金流量允當比率"></a>現金流量允當比率</h3><p>\(現金流量允當比率＝ 最近5年度營業活動淨現金流量／（最近5年度的資本支出＋最近5年度的存貨增加額＋最近5年度的現金股利）×100% \)</p>
<p>公式意義為最近五年，公司經常性營業活動所賺進的現金，是否能應付最近五年資本支出、存貨、與發放給股東的現金股利。<br>如果 現金流量允當比率 &gt; 100%，表示公司近五年來財務狀況良好，不需要做借錢或新增股資</p>
<p>例題:</p>
<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1mYTSWQqHT8STljN7b7Zy7cYUsJ1YaptW&export=download" alt=""></p>
</blockquote>
<h3 id="現金再投資比例"><a href="#現金再投資比例" class="headerlink" title="現金再投資比例"></a>現金再投資比例</h3><p>\(現金再投資比率＝ （營業活動淨現金流量－現金股利）／（固定資產毛額＋長期投資＋其他資產＋營運資金）×100%\)<br>其中 \(營運資金 = 流動資產 - 流動負債) \)<br>其公式表示為公司經常性營業活動的現金流入扣除給股東的現金股利後，將剩餘的錢再轉投資到此公司，讓其公司更強大</p>
<p>當現金再投資比例 &gt; 10%，則表示公司留下來的現金則夠再進行投資。</p>
<p>例題: </p>
<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1rVeqDIlsi9qP-domodU3t4f_cLAlU_vl&export=download" alt=""><br>\((615138744-259303805)/(1352377405+38581386+822613914-590735701+2559781484) = 0.08507\)</p>
</blockquote>
<h3 id="利息保障倍數"><a href="#利息保障倍數" class="headerlink" title="利息保障倍數"></a>利息保障倍數</h3><p>\(利息保障倍數 = 稅前息前利潤 / 利息費用\)<br>表示一間公司支付利息的能力，利息保障倍數越高，表示此企業的償還能力越好。<br>一般來說會希望利息保障倍數大於五倍。</p>
<p>利息保障倍數低：公司負債高、利息壓力沉重、獲利少，容易有還不出錢倒閉的風險。<br>利息保障倍數高：公司有能力支付利息，財務風險較低。</p>
<h4 id="比較利息保障倍數需要注意的事情"><a href="#比較利息保障倍數需要注意的事情" class="headerlink" title="比較利息保障倍數需要注意的事情"></a>比較利息保障倍數需要注意的事情</h4><ul>
<li>利息保障倍數必須要跟同業比較，例如銀行業、保險業是以借錢再營利，而零售業則不太需要借錢，因此要跟同產業比較才準確</li>
<li>有些產業不適合使用比較利息保障倍數，例如零售業</li>
<li>利息保障倍數比較適合用來評估每年資本資出大的公司，因為這些公司會借錢來投資自己產業，來維持競爭力，如電子廠、製造廠</li>
</ul>
<p>例題: </p>
<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1w5Fgjs5ix6Zm0bMdffsNTfKKYryzm16j&export=download" alt=""></p>
</blockquote>
<p>(615138774 + 52044071) / 3597145 = 185.475660559</p>
<h2 id="練習與作業"><a href="#練習與作業" class="headerlink" title="練習與作業"></a>練習與作業</h2><p><a href="https://hackmd.io/8S4pSWkLQY2xcaCKdSGr1A" target="_blank" rel="noopener">財報分析 - Ch06 現金流量分析 作業</a></p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p>財務報表分析(五版) by 謝劍平<br><a href="https://smart.businessweekly.com.tw/Reading/WebArticle.aspx?id=68260&p=3" target="_blank" rel="noopener">3項現金流指標　評估企業存活能力 by 財經好讀</a><br><a href="https://rich01.com/what-times-interest-earned/" target="_blank" rel="noopener">利息保障倍數是什麼？公式如何計算？如何用它來判斷公司好壞？ by Mr.Market 市場先生</a></p>
]]></content>
      <categories>
        <category>北科上課筆記</category>
        <category>財務報表分析</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>財務報表分析筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>財務報表分析 - 第七章 現金流量分析</title>
    <url>/2021/10/21/Financial_Statement%20_Analysis/Financial_Statement%20_Analysis_07/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>北科上課筆記</category>
        <category>財務報表分析</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>財務報表分析筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>演算法知識 - Directed Acyclic Graph</title>
    <url>/2021/11/09/Explain_Algorithm/Directed_Acyclic_Graph/</url>
    <content><![CDATA[<h2 id="Directed-Acyclic-Graph-介紹"><a href="#Directed-Acyclic-Graph-介紹" class="headerlink" title="Directed Acyclic Graph 介紹"></a>Directed Acyclic Graph 介紹</h2><blockquote>
<p>是一種沒有 circle、無向圖，因此 DAG 不走回頭路、不斷向前進，永遠都從起點通往到對岸的另外一邊，讓所有點都可以碰觸到終點。</p>
</blockquote>
<a id="more"></a>

<h2 id="Directed-Acyclic-Graph-用法"><a href="#Directed-Acyclic-Graph-用法" class="headerlink" title="Directed Acyclic Graph 用法"></a>Directed Acyclic Graph 用法</h2><p>但你遇到 DAG 的題目時，你可以使用以下方式解決</p>
<ul>
<li>DP<br>在起點超過一個以上時使用</li>
<li>SPFA<br>在起點只有一個時使用</li>
</ul>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://web.ntnu.edu.tw/~algo/DirectedAcyclicGraph.html" target="_blank" rel="noopener">Directed Acyclic Graph by 師大演算法</a></p>
]]></content>
      <categories>
        <category>演算法知識</category>
      </categories>
      <tags>
        <tag>程式解題</tag>
        <tag>演算法知識</tag>
        <tag>Directed Acyclic Graph</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa10987 - AntiFloyd(Floyd)</title>
    <url>/2021/10/31/UVa/UVa10987/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>一個系統管理師要管理一家公司的網路，他測試每一個 cable to 每一台電腦，現在他想要移除一些 cable，但不可以讓原本的速度變快或變慢，還是必須是速度一樣快的狀態。<br>請問他應該保留那一些電纜，如果沒有辦法移除，那就輸出 ‘Need better measurements.’</p>
<p><a href="https://onlinejudge.org/external/109/10987.pdf" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li><a href="https://theriseofdavid.github.io/2021/10/11/Explain_Algorithm/floyd/" target="_blank" rel="noopener">演算法知識 - Floyd-Warshall algorithm (無權重、有權重向圖) by 大衛的筆記</a></li>
<li>判斷現在的電纜會不會有最短邊</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ul>
<li>使用 floyd 檢查 <code>path[i][j] &lt;= path[i][k] + path[k][j]</code>，如果有的話就表示可能會讓速度更快，沒辦法移除，直接輸出 ‘Need better measurements.’</li>
<li>如果剛好 <code>path[i][j] == path[i][k] + path[k][j]</code>，則表示此邊可以移除，因為可以讓 i 走 k 走 j</li>
<li>一開始先假設所有的邊都可以用，然後符合第二點的移除。</li>
</ul>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://morris821028.github.io/2015/05/11/uva-10987/" target="_blank" rel="noopener">UVa 10987 - Antifloyd by morris</a></p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>有一些程式碼註解在 <a href="https://theriseofdavid.github.io/2021/10/11/Explain_Algorithm/floyd/" target="_blank" rel="noopener">演算法知識 - Floyd-Warshall algorithm (無權重、有權重向圖) by 大衛的筆記</a> 請供參考。</p>
<p>會在下面放一些簡單註解，供大家學習時參考。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#define LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 120</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> kase = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> path[MAXN][MAXN], edge[MAXN][MAXN];</span><br><span class="line"><span class="keyword">int</span> t, n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anti_floyd</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++)&#123; <span class="comment">//floyd</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(path[i][j] &gt; path[i][k] + path[k][j])&#123; <span class="comment">//分析 1</span></span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Need better measurements.\n"</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(i == j || j == k || i == k) <span class="keyword">continue</span>; <span class="comment">//同樣的點，沒有意義</span></span><br><span class="line">                <span class="keyword">if</span>(path[i][j] == path[i][k] + path[k][j])&#123; <span class="comment">//分析 2</span></span><br><span class="line">                    <span class="comment">//cout &lt;&lt; "i j k " &lt;&lt; i &lt;&lt; " " &lt;&lt; j &lt;&lt; " " &lt;&lt; k &lt;&lt; "\n";</span></span><br><span class="line">                    edge[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>; <span class="comment">//記錄有多少邊被留下來</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(edge[i][j]) cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; cnt &lt;&lt; <span class="string">"\n"</span>; <span class="comment">//輸出所有邊</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(edge[i][j]) <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span> &lt;&lt; j &lt;&lt; <span class="string">" "</span> &lt;&lt; path[i][j] &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* print</span></span><br><span class="line"><span class="comment">    cout &lt;&lt; "\n";</span></span><br><span class="line"><span class="comment">    for(int i = 1; i &lt;= n; i++)&#123;</span></span><br><span class="line"><span class="comment">        for(int j = 1; j &lt;= n; j++)&#123;</span></span><br><span class="line"><span class="comment">            cout &lt;&lt; edge[i][j] &lt;&lt; " ";</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        cout &lt;&lt; "\n";</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    cout &lt;&lt; "\n";</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123; <span class="comment">//分析第三點</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">                edge[i][j] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> cost;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123; <span class="comment">//輸入資料</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++)&#123;</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; cost;</span><br><span class="line">                path[i][j] = cost;</span><br><span class="line">                path[j][i] = cost;</span><br><span class="line">            &#125;</span><br><span class="line">            path[i][i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Case #"</span> &lt;&lt; kase++ &lt;&lt; <span class="string">":\n"</span>;</span><br><span class="line">        anti_floyd();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>Floyd-Warshall algorithm</tag>
        <tag>UVa</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa10259 - Hippity Hopscotch(SPFA、dijkstra、Directed Acyclic Graph)</title>
    <url>/2021/11/09/UVa/UVa10259/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>小時候大家都有玩過跳格子八XD，現在我們對跳格子再增加一些規則，格子中都有錢，每個人從 (1,1) 出發，可以水平或垂直跳至多 K 格，但跳到下一個格子時，下一個格子的錢必須比現在的格子還要多<br>請問最多可以拿多少錢</p>
<p><a href="https://onlinejudge.org/external/102/10259.pdf" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li><a href="https://theriseofdavid.github.io/2021/11/09/Explain_Algorithm/Directed_Acyclic_Graph/" target="_blank" rel="noopener">演算法知識 - Directed Acyclic Graphby 大衛的筆記</a></li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ul>
<li>由於我們可以理解出這題是 DAG，無向圖，不會有 circle(每次跳得格子都必須比現在的格子大)，因此用 SPFA 來解。</li>
<li>只要根據上下左右並且對可抵達的格子進行查詢，看是否能夠擴展即可。</li>
</ul>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="http://mobcs.blogspot.com/2015/06/uva-10259-hippity-hopscotch.html" target="_blank" rel="noopener">[UVa] 10259 - Hippity Hopscotch by Hi, I am Code</a></p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 110</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> g[MAXN][MAXN]; <span class="comment">//題目</span></span><br><span class="line"><span class="keyword">int</span> ans[MAXN][MAXN]; <span class="comment">//當前格子可收集到的最大數量</span></span><br><span class="line"><span class="keyword">int</span> t, n, k, collect = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(ans, <span class="number">0</span>, <span class="keyword">sizeof</span>(ans));</span><br><span class="line">    <span class="built_in">deque</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt; q;</span><br><span class="line">    q.push_back(&#123;<span class="number">1</span>,<span class="number">1</span>&#125;);</span><br><span class="line">    ans[<span class="number">1</span>][<span class="number">1</span>] = g[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    collect = g[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; node = q.front(); q.pop_front();</span><br><span class="line">        <span class="keyword">int</span> x = node.first, y = node.second;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; x &lt;&lt; " " &lt;&lt; y &lt;&lt; " " &lt;&lt; collect &lt;&lt; "\n";</span></span><br><span class="line">        <span class="comment">//cout &lt;&lt; (x+9 &lt;= n &amp;&amp; g[x+9][y] &gt; g[x][y] &amp;&amp; ans[x][y] + g[x+9][y] &gt; ans[x+9][y]) &lt;&lt; " " &lt;&lt; g[x+9][y] &lt;&lt; "\n";</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++)&#123; <span class="comment">//對可抵達距離(1~K) 展開擴展</span></span><br><span class="line">            <span class="comment">//cout &lt;&lt; "i= " &lt;&lt; i &lt;&lt; " " &lt;&lt; g[x+k][y]&lt;&lt; "\n";</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//擴展時必須比原先的 ans 還要大，這樣才有擴展的理由</span></span><br><span class="line">            <span class="keyword">if</span>(x+i &lt;= n &amp;&amp; g[x+i][y] &gt; g[x][y] &amp;&amp; ans[x][y] + g[x+i][y] &gt; ans[x+i][y])&#123; <span class="comment">//左</span></span><br><span class="line">                 ans[x+i][y] = ans[x][y] + g[x+i][y];</span><br><span class="line">                 collect = max(ans[x+i][y], collect);</span><br><span class="line">                 q.push_back(&#123;x+i,y&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(x-i &gt; <span class="number">0</span> &amp;&amp; g[x-i][y] &gt; g[x][y] &amp;&amp; ans[x][y] + g[x-i][y] &gt; ans[x-i][y])&#123; <span class="comment">//右</span></span><br><span class="line">                 ans[x-i][y] = ans[x][y] + g[x-i][y];</span><br><span class="line">                 collect = max(ans[x-i][y], collect);</span><br><span class="line">                 q.push_back(&#123;x-i,y&#125;);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(y + i &lt;= n &amp;&amp; g[x][y+i] &gt; g[x][y] &amp;&amp; ans[x][y] + g[x][y+i] &gt; ans[x][y+i])&#123; <span class="comment">//下</span></span><br><span class="line">                 ans[x][y+i] = ans[x][y] + g[x][y+i];</span><br><span class="line">                 collect = max(ans[x][y+i], collect);</span><br><span class="line">                 q.push_back(&#123;x,y+i&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(y - i &gt; <span class="number">0</span> &amp;&amp; g[x][y-i] &gt; g[x][y] &amp;&amp; ans[x][y] + g[x][y-i] &gt; ans[x][y-i])&#123; <span class="comment">//上</span></span><br><span class="line">                 ans[x][y-i] = ans[x][y] + g[x][y-i];</span><br><span class="line">                 collect = max(ans[x][y-i], collect);</span><br><span class="line">                 q.push_back(&#123;x,y-i&#125;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> collect;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"out.txt"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">        <span class="built_in">memset</span>(g, <span class="number">-1</span>, <span class="keyword">sizeof</span>(g)); <span class="comment">//輸入資料</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; g[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; bfs() &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">        <span class="keyword">if</span>(t) <span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>; <span class="comment">//最後只需要一個斷行 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        for(int i = 1; i &lt;= n; i++)&#123;</span></span><br><span class="line"><span class="comment">//            for(int j = 1; j &lt;= n; j++)&#123;</span></span><br><span class="line"><span class="comment">//                cout &lt;&lt; ans[i][j] &lt;&lt; " ";</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//            cout &lt;&lt; "\n";</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>Dijkstra&#39;s</tag>
        <tag>程式解題</tag>
        <tag>Directed Acyclic Graph</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa12644 - Vocabulary(Maximum Bipartite Matching 二分匹配)</title>
    <url>/2021/10/31/UVa/UVa12664/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>Jack 與 Jill 在玩字彙大挑戰，挑戰誰的字彙多：<br>Jack 會給一些單字，Jill 則需要符合一個規則，並給出一些單字。<br>規則是：Jill 單字中的每一個字元出現次數，至少要符合 Jack 裡面的單字，相同字元次數(可以多不能少)<br>其中 Jack 已經使用的單字，則不能再被使用，試問最多可以拼出幾組</p>
<p><a href="https://onlinejudge.org/external/126/12644.pdf" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li>二分匹配</li>
<li>從字串轉換成 Edge</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ul>
<li>我們可以透過以下方式將字串轉換成 Edge<ul>
<li>先記錄每一個單字的所有字元</li>
<li>一個雙迴圈，如果 Jill 與 Jack 中某個單字符合規則，就讓他們連出一個 edge</li>
</ul>
</li>
<li>對 Jill 單字做二分匹配，完成。</li>
</ul>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://github.com/rezwan4029/UVA-CODES/blob/master/12644%20-%20Vocabulary.cpp" target="_blank" rel="noopener">UVA-CODES/12644 - Vocabulary.cpp by rezwan4029</a></p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>有一些程式碼註解在 <a href="https://theriseofdavid.github.io/2021/10/16/Explain_Algorithm/Maximum_Bipartite_Matching/" target="_blank" rel="noopener">Maximum Bipartite Matching by 大衛的筆記</a> 請供參考。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 550</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m; <span class="comment">//n = Jill 單字量, m = Jack 單字量</span></span><br><span class="line"><span class="keyword">int</span> A[MAXN][<span class="number">30</span>], B[MAXN][<span class="number">30</span>]; <span class="comment">//A = Jill, B = Jack</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; edge[MAXN*<span class="number">2</span>];</span><br><span class="line"><span class="built_in">string</span> input;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123; <span class="comment">//判斷是否符合規則</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(A[a][i] &lt; B[b][i]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mx[MAXN*<span class="number">2</span>], my[MAXN*<span class="number">2</span>], vy[MAXN*<span class="number">2</span>]; <span class="comment">//matchX, matchY, visitY</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> y: edge[x])&#123; <span class="comment">//對 x 可以碰到的邊進行檢查</span></span><br><span class="line">        <span class="keyword">if</span>(vy[y] == <span class="number">1</span>) <span class="keyword">continue</span>; <span class="comment">//避免遞迴 error</span></span><br><span class="line">        vy[y] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(my[y] == <span class="number">-1</span> || dfs(my[y]))&#123; <span class="comment">//分析 3</span></span><br><span class="line">            mx[x] = y;</span><br><span class="line">            my[y] = x;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//分析 4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bipartite_matching</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(mx, <span class="number">-1</span>, <span class="keyword">sizeof</span>(mx)); <span class="comment">//分析 1,2</span></span><br><span class="line">    <span class="built_in">memset</span>(my, <span class="number">-1</span>, <span class="keyword">sizeof</span>(my));</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++)&#123;  <span class="comment">//對每一個 x 節點進行 DFS(最大匹配)</span></span><br><span class="line">        <span class="built_in">memset</span>(vy, <span class="number">0</span>, <span class="keyword">sizeof</span>(vy));</span><br><span class="line">        <span class="keyword">if</span>(dfs(i)) ans++;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"out.txt"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(A, <span class="number">0</span>, <span class="keyword">sizeof</span>(A));</span><br><span class="line">        <span class="built_in">memset</span>(B, <span class="number">0</span>, <span class="keyword">sizeof</span>(B));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123; <span class="comment">//輸入單字，並拆解 char</span></span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; input;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; input.length(); j++)&#123;</span><br><span class="line">                A[i][input[j]-<span class="string">'a'</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; input;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; input.length(); j++)&#123;</span><br><span class="line">                B[i][input[j]-<span class="string">'a'</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m+n; i++) edge[i].clear(); <span class="comment">//將符合規則的連接成邊</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(check(i,j)) edge[j].push_back(i+m);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = bipartite_matching();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>Maximum Bipartite Matching 二分匹配</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa10350 - Liftless EME(DP、Directed Acyclic Graph)</title>
    <url>/2021/11/09/UVa/UVa10350/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>EME 大樓有非常多層樓，每一個學生要透過樓梯爬上去，現在學校舉行一場比賽，看學生們從一樓走到頂樓，誰最快，想請問最快必須花幾分鐘</p>
<p>題目給的格式如下，有 n,m，其中 ```for(int k = 1; k &lt;= m; k++)，其中 n 表示第幾層樓走到第 n+1 個樓的第 k 個樓梯要花幾分鐘，且每爬一層樓需要花兩分鐘。 </p>
<p><del>題目格式讓我非常看不懂</del><br><a href="https://onlinejudge.org/external/103/10350.pdf" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>


<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li><a href="https://theriseofdavid.github.io/2021/11/09/Explain_Algorithm/Directed_Acyclic_Graph/" target="_blank" rel="noopener">演算法知識 - Directed Acyclic Graphby 大衛的筆記</a></li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ul>
<li>由於起點都是在一樓且可以透過任意一個樓梯開始行走，因此起點並不是都在同個位置，你可以考慮起點在一樓第二個樓梯…</li>
<li>符合 DAG 特性，不會有環，不斷向前進，且起點不只一個，因此使用 DP</li>
<li>dp公式 <code>dp[下一層樓][k號樓梯] = min(dp[這層樓][k號樓梯] + cost[這層樓][到下一樓][經過 k 號樓梯],dp[下一層樓][k號樓梯] )</code></li>
</ul>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://mypaper.pchome.com.tw/zerojudge/post/1325000097" target="_blank" rel="noopener">UVa10350 - Liftless EME by morris</a></p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 150</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> cost[MAXN][<span class="number">20</span>][<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> dp[MAXN][<span class="number">20</span>];</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"out.txt"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; s)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= m; k++)&#123;</span><br><span class="line">                    <span class="built_in">cin</span> &gt;&gt; cost[i][j][k]; <span class="comment">//cost[這層樓][到下一樓][經過 k 號樓梯]</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXN; i++)&#123; <span class="comment">//一開始設為無限大，因為題目要求最小</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">20</span>; j++)&#123;</span><br><span class="line">                dp[i][j] = INF;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) dp[<span class="number">1</span>][i] = <span class="number">0</span>; <span class="comment">//一樓全部都是起點，設為0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123; <span class="comment">//分析 3</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= m; k++)&#123;</span><br><span class="line">                    dp[i+<span class="number">1</span>][k] = min(dp[i][j] + cost[i][j][k] ,dp[i+<span class="number">1</span>][k]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = INF; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) ans = min(dp[n][i], ans);<span class="comment">//看誰最小</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; (ans + <span class="number">2</span>*n<span class="number">-2</span>) &lt;&lt; <span class="string">"\n"</span>; <span class="comment">//加上爬樓時需要的時間</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>動態規劃 Dynamic programming</tag>
        <tag>Directed Acyclic Graph</tag>
      </tags>
  </entry>
  <entry>
    <title>NCPC2021 110年度全國大專電腦軟體設計決賽 - 30th 心得</title>
    <url>/2020/11/09/contest_experence/ncpc2021_final/</url>
    <content><![CDATA[<h2 id="導讀"><a href="#導讀" class="headerlink" title="導讀"></a>導讀</h2><blockquote>
<p>紀錄 2021 參加 110年度全國大專電腦軟體設計決賽</p>
<p>這次決賽一樣在師大比賽。</p>
</blockquote>
<a id="more"></a>

<h2 id="比賽早上"><a href="#比賽早上" class="headerlink" title="比賽早上"></a>比賽早上</h2><!-- 早上我跟齊笎還有力瑋約 9 點來參加比賽，結果力瑋說他還在公車上還沒辦法來預計 10 點才會到，而主辦單位 9 點 30 開始進行開幕典禮，後來主辦單位就允許我們先進行簽到，並等第三位隊友到來。

當立委到來時， -->
<p>我們在電腦教室進行上機測試，與我上次不一樣，上次我在三樓比賽，這次則是在四樓比賽，我們的鍵盤一開始還不能進行打字，幸好後面順利解決。</p>
<p>原本我還忘記 linux terminal 要打甚麼指令 compiler C++，幸好力瑋及時幫忙，才沒有搞砸XD。</p>
<h2 id="比賽中"><a href="#比賽中" class="headerlink" title="比賽中"></a>比賽中</h2><p>這次比較不順利，我負責寫的那題英文一直爛掉，一直沒有看懂英文題目，送出了太多 WA 導致名次落後QQ，阿官那題數學則好像被小數精度雷到，也一直都卡住不太好過，幸好最後都順利完成。</p>
<p>最後幾何的部分我們都忘記海龍公式怎麼用，所以求不出來三角形wwww。</p>
<p>這次比賽都沒有甜點可以讓我在思考時補充養分，好難過QQQQ，比賽中最幸福的事情沒了QQ。</p>
<p>當比賽快要結束時，外面下起了大雨，讓我的心情也有點不開心，怕自己會不會考不好之類的…。</p>
<h2 id="比賽結束"><a href="#比賽結束" class="headerlink" title="比賽結束"></a>比賽結束</h2><p>比賽結束時，我們的名次在第 30th，應該是可以比上一次在好一些些，但是就是我英文一直爛掉、，看錯題意、數學精度問題，送太多WA，不然我猜應該可以拿到 28 或是 27th。</p>
<p>題外話：當寫對的題目越來越多時，晉升名次的幅度成遞減模式XD，越寫到後面，步步皆辛苦。</p>
<p>我們在師大拍了幾張照片紀念後，我也拿了一兩顆氣球回家紀念。</p>
<blockquote>
<p>團隊合照<br><img src="https://drive.google.com/u/2/uc?id=1XLhO1uOS1hp6v8C1AazSd25_mJ5ivmh-&export=download" alt=""></p>
</blockquote>
<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=17tYeBkwOGtl08PWwcyPZznMnGjqxJclt&export=download" alt=""><br>明明比上次的成績還要好 3 名，可是外面下起的大雨卻讓我的心情有一種說不出來的悶，或許我可能要出去走走療育一下自己，不在乎這些名次、成績，讓自己躲起來一兩天，享受著一個人的時光嗎…，可能不是，是想要逃避一些現實，例如演算法不強…之類的，抑或是覺得自己已經不再是那個享受比賽的自己嗎？</p>
</blockquote>
<p>不清楚自己怎麼想的，也許只要錢夠多了安全感就出來了吧。</p>
<p>總之希望自己可以在山上或海邊買個房子，買一些桌游，每天邀請大家來家裡玩桌游，放鬆之類的八。<br>應該也是自己累了，太久沒有被療育。</p>
<p>但還是希望自己可以好好振作起來拉，畢竟隊友們都很努力，只是最近太多未來可能性要準備了，研究所、升學未來、投資之類的。</p>
<p>越成長就必須要有更多核心處理事情，但我好像不太擅長。</p>
<h2 id="頒獎典禮-2021-11-28"><a href="#頒獎典禮-2021-11-28" class="headerlink" title="頒獎典禮　2021/11/28"></a>頒獎典禮　2021/11/28</h2><p>我們的頒獎典禮跟 ICPC 相同，這是我們的獎項和照片，就在這邊與大家一同留戀拉！</p>
<blockquote>
<p>頒獎照片<br><img src="https://drive.google.com/u/2/uc?id=1C5lGKeHzDi0NWOOg-TD5LnSebEu9qkWw&export=download" alt=""></p>
</blockquote>
<blockquote>
<p>獎狀<br><img src="https://drive.google.com/u/2/uc?id=1gnHLBjquaQId-NA3BWHFo-dk-z0nQ1oI&export=download" alt=""></p>
</blockquote>
]]></content>
      <categories>
        <category>競賽心得</category>
      </categories>
      <tags>
        <tag>大學Life</tag>
        <tag>ICPC</tag>
        <tag>程式比賽</tag>
        <tag>競賽心得</tag>
        <tag>人生旅途</tag>
      </tags>
  </entry>
  <entry>
    <title>北科大資工資料庫管理期中考複習</title>
    <url>/2021/11/12/NTUT_note/NTUTCSIE_database_midterm/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊工程系大三上資料庫管理學習紀錄<br><font color="#dd0000">並非所有人都適用，部分對我而言稍加容易的內容並不會寫在此內。</font><br><strong>這是學習後心得的筆記，可能不太適用會未來的學生</strong></p>
<p>由於我沒有學習過裡面的理論，因此這是資工大三學生透過網路與自身理解的筆記，學習價值並不高、且可能擁有大量錯誤。</p>
</blockquote>
<a id="more"></a>



]]></content>
      <categories>
        <category>北科上課筆記</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>資料庫管理</tag>
        <tag>北科大通識</tag>
      </tags>
  </entry>
  <entry>
    <title>系統分析與設計- 第二章 分析企業個案</title>
    <url>/2021/11/14/System_analysis_and_design/ch2_System_analysis_and_design/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊與財金管理系大三上系統分析與設計重點整理<br><font color="#dd0000">並非所有人都適用，部分對我而言稍加容易的內容並不會寫在此內。</font></p>
<p>如果有侵犯到版權的問題在聯繫我，再聯絡我，我在移除</p>
</blockquote>
<a id="more"></a>

<h2 id="策略規劃"><a href="#策略規劃" class="headerlink" title="策略規劃"></a>策略規劃</h2><ul>
<li>策略規劃(strategic planning) 是一套制訂長期性的組織目標、策略及資源的流程。</li>
<li>通廠已反映公司願景、目的及價值，關鍵成功因素，優先權高的短期目標為主</li>
<li>SWOT 分析，對公司的科技、人力及財務等資源進行檢查</li>
<li>IT 部門的角色<ul>
<li>專案能支持商業策略與作業需求</li>
<li>專案每一個事件都明確完整  </li>
<li>專案目標能夠切乎實際及可達成，且與特定宣言、假設、限制、因素及其他需求緊密相連</li>
</ul>
</li>
<li>策略規劃工具<ul>
<li>Word、Excel</li>
<li>心智圖</li>
<li>平衡計分法 </li>
<li>差距分析 </li>
</ul>
</li>
</ul>
<h2 id="企業個案"><a href="#企業個案" class="headerlink" title="企業個案"></a>企業個案</h2><ul>
<li>企業個案 (business case)是指一個提案的提出理由或正當性。<ul>
<li>描述清楚、容易理解。</li>
<li>清楚描述專案、一個執行的正當性，並對專案財務影響進行估計</li>
</ul>
</li>
<li>能回答這些問題<ul>
<li>為甚麼要做</li>
<li>在做甚麼</li>
<li>帶來的好處與風險</li>
</ul>
</li>
</ul>
<h2 id="系統請求"><a href="#系統請求" class="headerlink" title="系統請求"></a>系統請求</h2><ul>
<li>大部分資訊專案都從系統請求開始<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1Y0GOxYoHVYyQi4sZk1Sj4LNyZGyv3AMX&export=download" alt=""></p>
</blockquote>
</li>
<li>影響資訊專案的因素<ul>
<li>內部<br>策略計畫、使用者需求、公司財務…</li>
<li>外部<br>科技、顧客、競爭者、政府</li>
</ul>
</li>
</ul>
<h2 id="系統評估請求"><a href="#系統評估請求" class="headerlink" title="系統評估請求"></a>系統評估請求</h2><ul>
<li>會有一個系統審查委員會進行系統評估請求<ul>
<li>委員會可以讓決策不受到個人偏見</li>
<li>可能委員會會有派系</li>
<li>委員會運作才會開始處理這些請求</li>
</ul>
</li>
<li>請求必須有一致性、容易理解且清楚的指示、申請程序流暢</li>
<li>可行性<ul>
<li>花多少時間、經歷才可以完成</li>
</ul>
</li>
<li>進行初步事實調查<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=14343QQdMzXFBGvWPuKJQ3I_kMqeqdHfw&export=download" alt=""></p>
</blockquote>
</li>
</ul>
<h2 id="評估請求的可行性"><a href="#評估請求的可行性" class="headerlink" title="評估請求的可行性"></a>評估請求的可行性</h2><ul>
<li>這邊的人們為消費者與顧客、經理</li>
<li>操作可行性<ul>
<li>人們是否支持該專案</li>
<li>新系統可以對人力要求降低嗎</li>
<li>新系統是否要重新訓練使用者</li>
<li>使用者是否在新系統規劃時要加入他們的意見</li>
</ul>
</li>
<li>操作可行性<ul>
<li>會對人們產生什麼樣的負擔</li>
<li>公司商譽、形象會有甚麼風險</li>
<li>法律問題、道德問題</li>
<li>是否會與公司其他事情發生衝突</li>
</ul>
</li>
<li>技術可行性<ul>
<li>開發、採購、安裝、操作用到的技術資源<ul>
<li>硬體是否足夠</li>
<li>新舊系統整合</li>
</ul>
</li>
<li>公司需要新增什麼樣的資源嗎</li>
<li>需要增加技術專家嗎</li>
<li>是否要用到雛形(prototype)</li>
</ul>
</li>
<li>經濟可行性<ul>
<li>專案效益是否會大於成本，包括人力、財力、物力</li>
<li>有形成本(tangible costs) 通常可以用金錢衡量</li>
<li>無形成本(intangible costs)肯定會影響公司績效</li>
<li>有形利益 (tangible benefits)可以是來自花費的減少，或收益的增加</li>
<li>無形利益 (intangible benefits)難以透過金錢衡量，卻對公司十分重要</li>
</ul>
</li>
<li>時程可行性<ul>
<li>是否可在允許時間內完成</li>
<li>如果加速開發會有甚麼風險</li>
<li>專案時程表</li>
</ul>
</li>
<li>設定優先順序<ul>
<li>什麼樣的事情要先做，其他可以慢做</li>
<li>影響優先順序的因素<ul>
<li>新系統是否可以增加利益</li>
<li>是否可以降低成本</li>
<li>能讓人們更喜歡</li>
</ul>
</li>
<li>可讓管理者選擇是否進行的專案為自由裁量專案(discretionary projects) </li>
<li>不可讓管理者選擇是否進行的專案為非自由裁量專案(nondiscretionary projects)<ul>
<li>有些非自由裁量專案是可預期的，例如薪資調整、稅率調整</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="初步調查"><a href="#初步調查" class="headerlink" title="初步調查"></a>初步調查</h2><ul>
<li>初步調查規劃<ul>
<li>主要的管理者、使用者及IT人員見面，並描述這個專案、說明你的職責、回答問題及徵詢意見</li>
<li>「問題」，在訪談時過度使用會讓人覺得厭惡</li>
<li>詢問使用者需要甚麼新的功能，而非遇到困難</li>
<li>交出報告示意圖<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1SIQ7VYWSPee21b-lQG5NVXj9Di7WGU2L&export=download" alt=""></p>
</blockquote>
</li>
</ul>
</li>
<li>初步調查五步驟<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=17BH54-N_Fw5OP_nDgbrCbr6_rUY6EbZw&export=download" alt=""></p>
</blockquote>
</li>
<li>初步調查<ul>
<li>step1: 了解問題或機會<ul>
<li>描述問題或機會</li>
<li>如果改進會有甚麼好處</li>
<li>牽涉到那些部門</li>
<li>有些潛在問題沒辦法被發現</li>
<li>使用魚骨圖或石川圖表達</li>
</ul>
</li>
<li>step2: 定義專案範圍與限制<ul>
<li>專案範疇 (project scope)是指定義出具體的專案邊界或範圍</li>
<li>建立清單並分成必須做、應該做、可以做、不要做</li>
<li>避免形成專案蔓延(project creep)的情況，專案範疇應該盡可能定義清楚</li>
<li>識別出限制 (constraint)<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=15gxXUXyaRNQL7I3smiRSPBvwttmN6JJP&export=download" alt=""></p>
</blockquote>
</li>
</ul>
</li>
<li>step3: 進行實情調查<ul>
<li>蒐集專案可用性、成本、利益以及時程的資料</li>
<li>分析組織圖</li>
<li>訪談題目券任</li>
<li>紀錄並回顧文件、使用者問卷調查</li>
<li>分析資料，帕列圖(Pareto chart)、散布圖(scatter diagram)</li>
</ul>
</li>
<li>step4: 分析專案可用性、成本、利益和時程資料<ul>
<li>取得那些資訊、如何蒐集、分析</li>
<li>如何訪談，訪談對象為誰</li>
</ul>
</li>
<li>step5: 評估可行性<ul>
<li>操作可行性、經濟可行性、技術可行性、時程可行性</li>
</ul>
</li>
<li>總結<ul>
<li>提供一份準備報告給管理者</li>
<li>需要有系統請求摘要、調查發現、解決方案、可行性評估、期望利益</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>北科上課筆記</category>
        <category>系統分析與設計</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>系統分析與設計筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>系統分析與設計- 第五章 結構化分析中資料與流程塑模</title>
    <url>/2021/11/14/System_analysis_and_design/ch5_System_analysis_and_design/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊與財金管理系大三上系統分析與設計重點整理<br><font color="#dd0000">並非所有人都適用，部分對我而言稍加容易的內容並不會寫在此內。</font></p>
<p>如果有侵犯到版權的問題在聯繫我，再聯絡我，我在移除</p>
</blockquote>
<a id="more"></a>

<h2 id="邏輯模型與實體模型"><a href="#邏輯模型與實體模型" class="headerlink" title="邏輯模型與實體模型"></a>邏輯模型與實體模型</h2><ul>
<li>邏輯模型(logical model)，表示系統必須做成什麼(what) 樣子</li>
<li>實體模型(physical model)， 描述系統如何(how)建構</li>
<li>四模型法(four-model approach)<ul>
<li>實體模型 </li>
<li>邏輯模型 </li>
<li>新系統邏輯模型  </li>
<li>新系統實體模型 </li>
</ul>
</li>
</ul>
<h2 id="資料流向圖"><a href="#資料流向圖" class="headerlink" title="資料流向圖"></a>資料流向圖</h2><ul>
<li>系統分析師會使用許多圖形化技術來描述一個資訊系統</li>
<li>資料流向圖(data flow diagram, DFD)<ul>
<li>使用數種不同符號來表示系統輸入資料轉換為有用資訊</li>
<li>顯示資料在資訊系統流動，但不呈現程式邏輯、處理步驟</li>
<li>資料流向圖符號解釋<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1LgqTnld3OYxUzpeN5MfTh0agSqS3me-G&export=download" alt=""></p>
</blockquote>
</li>
</ul>
</li>
<li>程序符號<ul>
<li>程序(process) 可接收資料輸入並且產出不同內容或形式的輸出</li>
<li>程序內含有商業邏輯(business logic)，或稱為業務規則(business rules)</li>
<li>程序命名有一定的規則</li>
<li>一個程序符號可以被視為一種黑箱(black box)<br>黑箱，裡面的邏輯與細節都隱藏起來，透過延伸圖才將其劃出</li>
</ul>
</li>
<li>資料流符號為具有單、雙向的一條線</li>
<li>資料流符號不能有以下錯誤<ul>
<li>自然生長(spontaneous generation)，程序沒有資料流入，但卻有流出</li>
<li>黑洞(black hole)，兩個資料流符號進入程序，但卻沒有輸出</li>
<li>灰洞(gray hole)，有資料流入也流出，但邏輯不對、文不對題</li>
<li>示意圖<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1eARqNhVfSvdL0_NuH7ahqjiz6KDmgp9X&export=download" alt=""></p>
</blockquote>
</li>
</ul>
</li>
<li>資料儲存處符號<ul>
<li>資料儲存處代表系統存放的資料</li>
<li>資料儲存處的實體特性在此並不重要，具體在程式中定義</li>
<li>資料儲存處必須透過一個資料流符號連接到一個程序</li>
<li>正確的示意圖<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1GGk1h7SmQFwHLJi0fo5e9H9uSyvd4uEO&export=download" alt=""></p>
</blockquote>
</li>
<li>錯誤的示意圖<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=12j-9ZQzWfLANQdtd6y-TUBtmGUY1PbYI&export=download" alt=""></p>
</blockquote>
</li>
</ul>
</li>
<li>實體符號<ul>
<li>實體(entity)的符號為一個長方形</li>
<li>顯示提供資料給系統或是從系統接收資料的外部實體<ul>
<li>也稱為終端(terminators)，因為它們是資料的來源或最終目的地</li>
<li>來源端(source)，將資料送出去</li>
<li>接收端(sink)，將資料收進來</li>
</ul>
</li>
</ul>
</li>
<li>正確的示意圖<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1WWV3E7UzsWZC0yH5HrBuEabHSkLP_fVd&export=download" alt=""></p>
</blockquote>
</li>
<li>資料流符號的正確與錯誤使用方式<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1fTfseUWjLN0qg_5WR_vSx5q3NMlR4AX-&export=download" alt=""></p>
</blockquote>
</li>
</ul>
<h2 id="建立一套-DFD"><a href="#建立一套-DFD" class="headerlink" title="建立一套 DFD"></a>建立一套 DFD</h2><ul>
<li>利用實情調查的結果，為資訊系統建立一個圖形化模型</li>
<li>繪製環境圖(DFD)遵循要點<ul>
<li>一整頁來繪製系統環境圖</li>
<li>使用資訊系統的名稱來命名系統環境圖中的程序</li>
<li>每個符號都使用唯一的符號</li>
<li>不要出現交錯線條</li>
<li>為每個程序提供一個唯一的名稱和參照號碼</li>
<li>盡可能取得更多使用者輸入跟反饋</li>
</ul>
</li>
</ul>
<h3 id="繪製-DFD"><a href="#繪製-DFD" class="headerlink" title="繪製 DFD"></a>繪製 DFD</h3><ul>
<li>初始的 DFD 圖表<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1683C8esxVqu5js9EPIqygIbR7K9_dD9D&export=download" alt=""></p>
</blockquote>
</li>
<li>接下來我們再將圖 0 畫出來，(process 0展開)<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=17_gy1wYgxBElCgQGuIEnbH2G3fyirvvs&export=download" alt=""></p>
</blockquote>
</li>
<li>將圖 0 中 process 1 在劃出來<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1t3bVsZGsWOygjf4Kl-86757jm0xCReVH&export=download" alt=""></p>
</blockquote>
</li>
<li>DFD 要保持一致性<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1U-CLCRS-Yxj00Eb65TBRCshDR3zWSjRV&export=download" alt=""></p>
</blockquote>
</li>
</ul>
<h2 id="資料字典"><a href="#資料字典" class="headerlink" title="資料字典"></a>資料字典</h2><ul>
<li>資料字典(data dictionary) 或資料倉庫(data repository) 是指存放系統相關資料的中央倉儲，用來記錄資料<ul>
<li>資料字典中必須記載每一個資料元素</li>
<li>將組成系統的資料與程序的資訊清楚且完整地呈現</li>
<li>資料字典必須有這些屬性<ul>
<li>資料元素名稱</li>
<li>別名(alias)，其他可識別名稱</li>
<li>型態(type)和長度(length)</li>
<li>預設值</li>
<li>可接受值定義域 (domain)和有效規則 (validity rules)，一個有效的值且符合規定，例如：人不可以會飛，會飛的人不是人</li>
<li>安全性</li>
<li>描述和備註</li>
</ul>
</li>
</ul>
</li>
<li>資料元素(data element) 或稱為資料項目(data item)或欄位(field)<ul>
<li>資訊系統中有意義的資料最小單位</li>
<li>紀錄，將資料進行組成，產生有意義的資訊</li>
</ul>
</li>
<li>書中推薦使用 Case 工具進行記載 </li>
<li>記載資料流則必須有<ul>
<li>資料流名稱</li>
<li>描述</li>
<li>替代名稱</li>
<li>紀錄</li>
<li>容量</li>
</ul>
</li>
<li>記載資料儲存處必須有<ul>
<li>資料儲存處名稱</li>
<li>描述</li>
<li>屬性</li>
<li>容量</li>
</ul>
</li>
<li>記載程序必須有<ul>
<li>程序名稱</li>
<li>描述</li>
<li>程序編號</li>
<li>程序說明</li>
</ul>
</li>
<li>記載實體必須有<ul>
<li>實體名稱</li>
<li>描述</li>
<li>替代名稱</li>
<li>輸入資料流</li>
<li>輸出資料流</li>
</ul>
</li>
<li>記載記錄必須有<ul>
<li>紀錄或資料結構名稱</li>
<li>定義或描述</li>
<li>替代名稱</li>
<li>屬性</li>
</ul>
</li>
<li>資料字典報表<ul>
<li>按照排序將資料元素展示</li>
<li>描述每個資料元素的報表，其中並指出負責輸入、更新或刪除的使用者或部門</li>
<li>舉出某特定資料元素被哪些資料流和資料儲存處所使用的報表</li>
<li>載明資料字典中的資料元素、紀錄、資料流、程序或其他選用項目所有特性</li>
</ul>
</li>
</ul>
<h2 id="模組設計時的程序說明工具"><a href="#模組設計時的程序說明工具" class="headerlink" title="模組設計時的程序說明工具"></a>模組設計時的程序說明工具</h2><ul>
<li>程序說明 (process description) 記載了基本功能的詳細內容，並展現一套明確的處理步驟和商業邏輯，可用決策樹、決策表說明</li>
<li>程序說明工具也可以應用在物件導向開發<ul>
<li>物件導向分析將資料和處理資料流程結合成一個物件</li>
<li>物件導向的流層為方法</li>
</ul>
</li>
<li>模組化設計(modular design)<ul>
<li>三個邏輯結構(logical structure)，是程序的組成要素<ul>
<li>序列(sequence)<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1JpEsbsQinw97uOGd7eGVY2ZfOUUdlgub&export=download" alt=""></p>
</blockquote>
</li>
<li>選擇(selection)<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=18sRYdJmdrW-XkUn4-Uk9wDS5dz_zTZG2&export=download" alt=""></p>
</blockquote>
</li>
<li>反覆(iteration) 迴圈 (looping)<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1lAD2hCqOVCj9l-pzWvRNQOVeH8iP8xRY&export=download" alt=""></p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li>結構化英文(structured English)<ul>
<li>清楚又精確地描述邏輯程序，使用縮排</li>
<li>只使用序列、選擇、反覆做為三個組成要素</li>
<li>盡可能用最少單字、簡單表達</li>
</ul>
</li>
<li>決策表 A<ul>
<li>顯示一個邏輯結構，而且可以列出所有條件與其結果的可能組合</li>
<li>每加入一條新規則，規則數量就會增加一倍</li>
<li>決策表最適合用來描述一套複雜的條件<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1xuN0hMK7qI_d1a_oXmemtBBhMpd7rCK1&export=download" alt=""></p>
</blockquote>
</li>
<li>有時候如果沒有滿足 A 則同時也不能符合 B 條件時，我們則可以把這種組合刪去</li>
</ul>
</li>
<li>決策樹<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1gYaLG88rkpad2Wd5wrwZc2Sm_SJvEagm&export=download" alt=""></p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>北科上課筆記</category>
        <category>系統分析與設計</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>系統分析與設計筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>系統分析與設計- 第一章 簡介</title>
    <url>/2021/11/14/System_analysis_and_design/ch1_System_analysis_and_design/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊與財金管理系大三上系統分析與設計重點整理<br><font color="#dd0000">並非所有人都適用，部分對我而言稍加容易的內容並不會寫在此內。</font></p>
<p>如果有侵犯到版權的問題在聯繫我，再聯絡我，我在移除</p>
</blockquote>
<a id="more"></a>

<h2 id="資訊科技"><a href="#資訊科技" class="headerlink" title="資訊科技"></a>資訊科技</h2><ul>
<li>系統分析與設計(system analysis and design)是發展高品質資訊系統的逐步過程</li>
<li>資訊系統(information system)結合資訊科技、人員及資料來支援企業的需求</li>
<li>系統設計師職責<ul>
<li>協助規劃、開發、維護資訊系統</li>
<li>管理 IT 專案、召開會議、進行簡報，以及撰寫備忘錄、報告及文件</li>
</ul>
</li>
</ul>
<h2 id="資訊系統"><a href="#資訊系統" class="headerlink" title="資訊系統"></a>資訊系統</h2><ul>
<li>系統(system)是由一組產生特定結果的相關要件組成<ul>
<li>關鍵任務系統是指對公司營運有非常重大影響的系統</li>
<li>系統必須輸入資料(data)</li>
<li>資訊(information) 則是對使用者有價值的輸出資料</li>
</ul>
</li>
<li>一個完整的系統透過硬體、軟體、資料、流程、人員</li>
<li>硬體，包含資訊系統內的實體事務</li>
<li>軟體  <ul>
<li>系統軟體，用來管理軟體</li>
<li>應用軟體，支援日常商業功能<ul>
<li>水平系統，適合不同種類的公司使用</li>
<li>垂直系統，針對特定需求的公司使用</li>
<li>老舊系統，之前的舊系統，要考慮其相容性</li>
</ul>
</li>
</ul>
</li>
<li>資料，資訊系統裡面的原料</li>
<li>流程，使用者、經理、IT人員為達成特定結果所經歷的任務與需要執行的業務功能</li>
<li>人員，與資訊系統相關的利害關係人</li>
</ul>
<h2 id="網路商業策略"><a href="#網路商業策略" class="headerlink" title="網路商業策略"></a>網路商業策略</h2><ul>
<li>三個主要趨勢<ul>
<li>全球化快速增加</li>
<li>提供無縫隙資料存取並進行技術整合</li>
<li>雲端運算服務成長</li>
</ul>
</li>
<li>網際網路模式<ul>
<li>電子商務</li>
<li>使用者介面可實現資料庫管理軟體與 Web server 進行互動</li>
<li>B2C</li>
<li>B2B<ul>
<li>供應商關係管理，指某項商品提供所需原料、服務、功能的所有公司</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="企業營運塑模"><a href="#企業營運塑模" class="headerlink" title="企業營運塑模"></a>企業營運塑模</h2><ul>
<li>業務概況<br>描述公司的使命、功能、流程、組織、產品、服務、顧客、供應商、競爭者、限制，以及未來方向</li>
<li>商業流程，能被記錄成文件的特定交易、事件、任務或結果<ul>
<li>商業流程塑模(business process modeling, BPM)是以圖形化方式顯示一個或多個商業流程</li>
<li>商業流程塑模記法(business process modeling notation, BPMN)<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1wej-lyd165kFVhmLZGGVC9LYwk1kRWQc&export=download" alt=""></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="企業資訊系統"><a href="#企業資訊系統" class="headerlink" title="企業資訊系統"></a>企業資訊系統</h2><ul>
<li>員工不論職位高低，都必須使用可提升生產力的辦公室系統<ul>
<li>第一線的操作員也必須接觸決策支援系統</li>
<li>現今的系統應該從其功能及特性來區分</li>
</ul>
</li>
<li>企業運算(enterprise computing)，支持整體企業運作與資料管理需求的資料庫系統<ul>
<li>企業資源規劃(enterprise resource planning, ERP)系統，提供高效率全方位管理</li>
<li>交易處理系統(transaction processing (TP) systems)，處理日常業務運作產生的資料，如：顧客訂單處理、應收帳款等</li>
<li>商務支援系統(business support systems, BSS)，提供和工作有關的資訊，以支援公司內各階層的使用者，如<ul>
<li>管理資訊系統(management information systems, MIS)</li>
<li>無線射頻辨識 (radio frequency identification, RFID)</li>
</ul>
</li>
<li>知識管理系統(Knowledge management system)，使用知識庫以及推理法則<ul>
<li>知識庫 (knowledge base)是由一個大型資料庫所組成，輸入關鍵字或一般英文的疑問句來尋找所需的資訊</li>
<li>推理法則 (inference rule)則是識別資料型態與關係的邏輯法則</li>
</ul>
</li>
<li>數位助理</li>
<li>系統整合，將交易處理、商務支援、知識管理以及使用者生產力等功能結合在同一個系統</li>
<li>使用者生產力系統，可提供生產力的科技</li>
</ul>
</li>
</ul>
<h2 id="組織資訊模型"><a href="#組織資訊模型" class="headerlink" title="組織資訊模型"></a>組織資訊模型</h2><ul>
<li>高階經理，擬定長期計畫</li>
<li>中階經理，提供只是、必要資源、績效回饋給督導和小組長</li>
<li>知識工作者(knowledge worker)對組織的基本功能提供支援</li>
<li>組織階層、商務職能示意圖<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1DcQfW6c6UbUXsK3kTyr9MaZEiMWKhuho&export=download" alt=""></p>
</blockquote>
</li>
<li>督導與小組長，負責監管操作人員，並且執行日常功能</li>
<li>操作人員<ul>
<li>包含從交易處理系統取得與輸入資料的使用者</li>
<li>許多公司的操作人員也必須接觸到資訊以及做出過去應該是督導負責的決策</li>
</ul>
</li>
</ul>
<h2 id="系統開發"><a href="#系統開發" class="headerlink" title="系統開發"></a>系統開發</h2><ul>
<li>示意圖<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1llgpsCBVbY2j2WBBh0Q6vm2-0Bj49RfD&export=download" alt=""></p>
</blockquote>
</li>
<li>結構化分析<ul>
<li>使用系統開發生命週期，對資訊系統進行規劃、分析、設計、建置以及支援等</li>
<li>結構化分析使用一連串的流程模型，以圖形來描述一套系統</li>
<li>系統規畫階段<ul>
<li>對IT部門的請求開始，稱為系統請求(systems request)</li>
<li>初步調查(preliminary investigation)，其中重點為可行性評估(feasibility study)</li>
</ul>
</li>
<li>系統分析階段(systems analysis phase) <ul>
<li>建立新系統的邏輯模型(logical model) </li>
<li>建立商業、資料、流程及物件等模型</li>
<li>產生系統需求文件(system requirements document)</li>
</ul>
</li>
<li>系統設計階段(systems design phase)<ul>
<li>目的是創造一個滿足所有需求的具體模型(physical model) A</li>
<li>設計使用介面，識別出必要的輸出、輸入與流程</li>
<li>可交付成果是系統設計規格(system design specification) A</li>
<li>使用者與管理者不能對系統設計產生誤解</li>
</ul>
</li>
<li>系統建置階段(systems implementation phase)<ul>
<li>建置新的系統</li>
<li>撰寫程式、測試、撰寫文件(documented)及系統導入(installed)</li>
<li>系統必須功能完整、運作正常、文件完整</li>
</ul>
</li>
<li>系統支援與安全階段(systems support and security phase)<ul>
<li>系統必須具備安全、可靠、可維護及可延展等特性</li>
<li>系統在運作幾年後，大都需要重大更新或汰舊換新</li>
</ul>
</li>
</ul>
</li>
<li>物件導向分析，將資料與處理資料的流程合而為一，類似於 OOP</li>
<li>快捷法<ul>
<li>雛形(prototype)是資訊系統完成之前的早期工作版本<br>缺點：如果業務或IT沒有徹底了解問題時，有些決策下定後，可能還需要修改，導致大量重來。</li>
<li>建立一連串雛形，並根據使用者需求進行調整</li>
<li>開發人員也不斷地修正、擴充並合併先前的雛型，進而產生最終產品</li>
<li>強調不斷反覆開發，每一次開發都會更新上次的缺點</li>
<li>螺旋式模型 (spiral model)，表示一連串根據使用者回饋而進行的反覆、修正動作</li>
</ul>
</li>
<li>系統分析師必須對方法有了解，才可夠選出適合的方案</li>
</ul>
<h2 id="資訊科技部門"><a href="#資訊科技部門" class="headerlink" title="資訊科技部門"></a>資訊科技部門</h2><blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1sftP6ngsJIY5eQPTyAN_a_KCh-aNyjYR&export=download" alt=""></p>
</blockquote>
<ul>
<li>應用程式開發，由使用者、管理者及IT 團隊成員所組成的小組負責開發</li>
<li>系統支援與安全，負責為系統軟硬體提供防護與維護服務</li>
<li>使用者支援，負責為使用者提供技術方面的資訊與訓練，並協助增加生產力</li>
<li>資料庫管理，涵蓋資料設計、管理、安全、備份及存取等</li>
<li>網路管理，包括網路方面的軟硬體維修、支援及安全</li>
<li>Web 支援，設計與架構網頁、監看流量、管理軟硬體，以及連結 Web 式應用程<br>式與公司既有的資訊系統</li>
<li>品質保證，負責審查與測試系統，以確定規格與品質符合標準</li>
</ul>
<h2 id="系統分析師"><a href="#系統分析師" class="headerlink" title="系統分析師"></a>系統分析師</h2><ul>
<li>對公司的資訊系統進行調查、分析、設計、開發、安裝、評估及維護等</li>
<li>經常與使用者和管理者在公司裡外進行互動</li>
<li>角色<ul>
<li>擔任管理者和程式設計師的翻譯者</li>
<li>IT災難時的最佳防衛者</li>
<li>最有價值的技能：傾聽的能力</li>
<li>向使用者尋求回饋與意見，以避免專案方向走偏</li>
</ul>
</li>
<li>所需知識、技能、背景<ul>
<li>技術知識</li>
<li>溝通技巧</li>
<li>商業技能</li>
<li>批判性思考技能</li>
<li>有學士學位，並有 IT 經驗</li>
<li>有進行認證</li>
</ul>
</li>
</ul>
<h2 id="資訊科技趨勢"><a href="#資訊科技趨勢" class="headerlink" title="資訊科技趨勢"></a>資訊科技趨勢</h2><ul>
<li>發展最快的產業之一</li>
<li>重要趨勢<ul>
<li>快捷法</li>
<li>雲端運算</li>
<li>資料科學</li>
<li>行動裝置</li>
<li>服務導向</li>
<li>社群媒體網路</li>
</ul>
</li>
</ul>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p>系統分析與設計 by Scott Tilley</p>
]]></content>
      <categories>
        <category>北科上課筆記</category>
        <category>系統分析與設計</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>系統分析與設計筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>系統分析與設計- 第三章 系統專案管理</title>
    <url>/2021/11/14/System_analysis_and_design/ch3_System_analysis_and_design/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊與財金管理系大三上系統分析與設計重點整理<br><font color="#dd0000">並非所有人都適用，部分對我而言稍加容易的內容並不會寫在此內。</font></p>
<p>如果有侵犯到版權的問題在聯繫我，再聯絡我，我在移除</p>
</blockquote>
<a id="more"></a>

<h2 id="專案管理描述"><a href="#專案管理描述" class="headerlink" title="專案管理描述"></a>專案管理描述</h2><ul>
<li>專案管理(project management)是指開發一套資訊系統時所進行的規劃、排程、監督與控制，以及回報等流程。</li>
<li>專案樣貌，一項成功專案要準時完成、低於預算，提供有品質的系統來滿足消費者需求</li>
<li>專案三角(project triangle)，會隨著那邊比重大而改變<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=17ieGLBFfkiq2TD7IenPU19MtNLkp9pPb&export=download" alt=""></p>
</blockquote>
</li>
<li>專案經理的任務<ul>
<li>專案規劃(project planning)，確認專案任務並估計完成時間成本</li>
<li>專案排程(project scheduling)，建立明確時間表顯示任務、任務依存性，以及會造成專案延宕的關鍵任務</li>
<li>專案監督 (project monitoring)，引導、監督、協調專案團隊工作負荷</li>
<li>專案回報(project reporting)，對主管、使用者及專案團隊本身進行例行性進度報告</li>
</ul>
</li>
</ul>
<h2 id="建立工作分解結構"><a href="#建立工作分解結構" class="headerlink" title="建立工作分解結構"></a>建立工作分解結構</h2><ul>
<li>工作分解結構(work breakdown structure, WBS)是將一個專案拆解成一系列較小的任務<ul>
<li>甘特圖(Gantt chart)</li>
<li>PERT/CPM 圖</li>
<li>同時使用甘特圖、PERT 圖並不衝突</li>
<li>專案評核術 (Program Evaluation Review Technique, PERT) 與 關鍵路徑法 (Critical Path Method, CPM) 已不在被使用</li>
</ul>
</li>
<li>確認工作分解結構中的任務<ul>
<li>任務(task)或活動(activity)是指具有開始與結束時間的任何一項工作、相對小並好管理</li>
<li>每項專案都必須要有檢查點</li>
</ul>
</li>
<li>確認工作分解結構中的任務<ul>
<li>列出任務</li>
<li>估計任務時間，使用最佳情況估計(best-case estimate, B)、可能情況估計(probable-caseestimate, P)、最差情況估計(worst-case estimate, W)，通常會用此公式預估 \(\frac{B+4P+W}{6}\)</li>
<li>做出估計後，經理分配權重</li>
</ul>
</li>
<li>示意圖<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=18tMukbP7_u5b_dDK1XHYoqnMeuAEBVvr&export=download" alt=""></p>
</blockquote>
</li>
<li>影響所需時間的因素<ul>
<li>專案大小<br>事情多不多、任務時間</li>
<li>人力資源<br>大家忙不忙、會不會有辭職問題</li>
<li>如何預估時間<ul>
<li>相似專案的經驗</li>
<li>直接要求限制</li>
</ul>
</li>
</ul>
</li>
<li>可以透過任務群組的方式，將許多任務進行溝通簡化</li>
</ul>
<h2 id="任務模式"><a href="#任務模式" class="headerlink" title="任務模式"></a>任務模式</h2><ul>
<li>工作分解結構中的所有任務都必須按照任務模式(taskpattern)的邏輯順序來排列</li>
<li>以任務盒建立模型<ul>
<li>任務名稱簡潔且具描述性</li>
<li>任務編號必須唯一</li>
<li>其他按照字面意思</li>
</ul>
</li>
<li>任務盒示意圖<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1MW_6NAZsXJx4fayb5I47yC6mT5iJUySR&export=download" alt=""></p>
</blockquote>
</li>
<li>任務模式類型<ul>
<li>依存任務 (dependent task)，任務必須一個一個完成</li>
<li>多重後續任務，類似 tree，可以透過一個任務展開兩個任務</li>
<li>多重前置任務，必須要先將前面某些任務完成，才可以進行此任務</li>
</ul>
</li>
<li>複雜的任務模式<br>當加入選多任務後，必須清楚了解邏輯順序，否則沒有效率、不準確</li>
<li>任務模式類型示意圖<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1vjfW1qi6jGqTe8OoRluGXR3r0kaGS5eZ&export=download" alt=""></p>
</blockquote>
</li>
</ul>
<h2 id="關鍵路徑"><a href="#關鍵路徑" class="headerlink" title="關鍵路徑"></a>關鍵路徑</h2><ul>
<li>關鍵路徑(critical path)是指一連串的任務，假如這些任務延誤了，將會影響整個專案的最終完成日期<br>必須先決定每項任務的開始與結束日期，才能決定專案的關鍵路徑</li>
</ul>
<h2 id="專案監督與控制"><a href="#專案監督與控制" class="headerlink" title="專案監督與控制"></a>專案監督與控制</h2><ul>
<li>監督與控制技術<ul>
<li>結構化逐步審查(structured walk-through)是一種將專案團隊成員的工作交由團隊中其他成員進行審查的方式</li>
<li>結構化審查在 SDLC(系統發展生命週期) 中會不斷出現</li>
<li>設計審查(designreviews) </li>
<li>程式碼審查(code reviews) </li>
<li>測試審查(testing reviews) </li>
</ul>
</li>
<li>保持進度<ul>
<li>專案很難沒辦法都不延誤、沒遇到問題</li>
<li>透過監督與控制工作，來將破壞降至最低</li>
</ul>
</li>
<li>任務與關鍵路徑<br>專案經理會花大部分時間去追縱關鍵路徑上的任務</li>
<li>專案狀態會議<ul>
<li>定期開會討論專案狀態</li>
<li>分享問題，討論新技術</li>
</ul>
</li>
<li>專案狀態報告<br>向長官、使用者回報</li>
<li>處理問題</li>
</ul>
<h2 id="風險管理"><a href="#風險管理" class="headerlink" title="風險管理"></a>風險管理</h2><ul>
<li>風險管理(risk management)則是一套確認、分析、預估，以及監控風險的流程，使其對專案的影響減到最低</li>
<li>風險管理步驟<ul>
<li>發展一份風險管理計畫(risk management plan)</li>
<li>風險確認(risk identification)，可能產生的風險的問題列出</li>
<li>質性風險分析(qualitative risk analysis)，評估風險發生的可能性並評估</li>
<li>建立風險應對計畫(risk response plan)，對於風險，那我們前置作業要怎麼防範</li>
<li>監控風險</li>
</ul>
</li>
</ul>
<h2 id="專案管理的成功"><a href="#專案管理的成功" class="headerlink" title="專案管理的成功"></a>專案管理的成功</h2><ul>
<li>專案經理必須具有高度的警覺性、良好的技術及應變能力，此外也必須具有良好的溝通和交際能力</li>
<li>專案問題有這幾種<ul>
<li>業務問題<ul>
<li>每一個系統都是為了解決問題</li>
<li>專案蔓延(project creep)，專案不斷擴大、變化，到無法控制的地步</li>
</ul>
</li>
<li>預算問題，EX:成本超支</li>
<li>時程問題，EX:員工離職</li>
</ul>
</li>
</ul>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p>系統分析與設計 by Scott Tilley</p>
]]></content>
      <categories>
        <category>北科上課筆記</category>
        <category>系統分析與設計</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>系統分析與設計筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>系統分析與設計- 第四章 需求工程</title>
    <url>/2021/11/14/System_analysis_and_design/ch4_System_analysis_and_design/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊與財金管理系大三上系統分析與設計重點整理<br><font color="#dd0000">並非所有人都適用，部分對我而言稍加容易的內容並不會寫在此內。</font></p>
<p>如果有侵犯到版權的問題在聯繫我，再聯絡我，我在移除</p>
</blockquote>
<a id="more"></a>

<h2 id="系統需求"><a href="#系統需求" class="headerlink" title="系統需求"></a>系統需求</h2><ul>
<li>系統需求(system requirement)是指在一套資訊系統中必須包含的特性或功能，以滿足業務需求以及使用者的實際需要。</li>
<li>需求工程<ul>
<li>蒐集需求：了解(understanding)問題</li>
<li>表示需求：描述(describing)問題</li>
<li>確認與驗證需求：同意(agreeing)問題</li>
</ul>
</li>
<li>需求類型<ul>
<li>根據不同特性分類，區分為功能性、非功能性</li>
</ul>
</li>
<li>需求的挑戰，不夠精確、同意、拖延</li>
</ul>
<h2 id="其他考量"><a href="#其他考量" class="headerlink" title="其他考量"></a>其他考量</h2><ul>
<li>可延展性(scalability)：系統處理未來業務與交易量增加的能力</li>
<li>安全性</li>
<li>總體擁有成本(total cost of ownership, TCO)：直接成本與間接成本</li>
</ul>
<h2 id="團隊技巧"><a href="#團隊技巧" class="headerlink" title="團隊技巧"></a>團隊技巧</h2><h3 id="JAD"><a href="#JAD" class="headerlink" title="JAD"></a>JAD</h3><ul>
<li>聯合應用開發(joint application development, JAD)，頗受歡迎，他將使用者視為實際參與、開發者，需要有一個良好人際關係組長，還有負責記錄討論與決議的組員</li>
<li>JAD 優勢<ul>
<li>缺點<ul>
<li>與傳統方法相比，JAD 成本高</li>
<li>規模大，則會比較繁瑣</li>
</ul>
</li>
<li>優點<ul>
<li>能夠有效餐與</li>
<li>使用者有參與感，更喜歡</li>
<li>JAD 更容易產生正確系統，提高新系統的投入程度</li>
</ul>
</li>
</ul>
</li>
<li>JAD 示意圖<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1b4oqYewSkutaiJy7rA8Is-kYIOM3AJhh&export=download" alt=""></p>
</blockquote>
</li>
<li>開會流程<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1d4iaVVF0d-tQzZpdf7_oXrgYJB3-1cOx&export=download" alt=""></p>
</blockquote>
</li>
</ul>
<h3 id="RAD"><a href="#RAD" class="headerlink" title="RAD"></a>RAD</h3><ul>
<li>快速應用開發(rapid application development, RAD)<ul>
<li>類似於 JAD</li>
<li>開發新的資訊系統</li>
<li>開發方法<ul>
<li>包括與傳統 SDLC(系統生命開發週期)</li>
<li>減少成本、開發時間</li>
<li>提升成功機率</li>
<li>依賴雛型化與使用者涉入</li>
</ul>
</li>
<li>RAD 示意圖<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1vm7E-KOoKmjuLh8TeI8fkUFsd_hQ8-sy&export=download" alt=""></p>
</blockquote>
</li>
</ul>
</li>
<li>RAD 目標<br>讓使用者參與系統開發的各個階段，以縮短開發時間與支出</li>
<li>RAD 優劣<ul>
<li>更快、成本更低</li>
<li>注重系統本身，可能會忽略公司要求</li>
<li>倉促行事，則會產生問題</li>
</ul>
</li>
</ul>
<h2 id="團隊技巧-1"><a href="#團隊技巧-1" class="headerlink" title="團隊技巧"></a>團隊技巧</h2><h3 id="快捷法-agile-method-，屬於團隊技巧，而非開發"><a href="#快捷法-agile-method-，屬於團隊技巧，而非開發" class="headerlink" title="快捷法(agile method)，屬於團隊技巧，而非開發"></a>快捷法(agile method)，屬於團隊技巧，而非開發</h3><ul>
<li>累加方式建構雛形，並根據使用者需求調整</li>
<li>不斷修改、刪除、合併雛形，而完成商品</li>
<li>會隨著先前的雛型而進步</li>
<li>另一種方法為 Scrum<ul>
<li>心智上的合作</li>
<li>每個團員都要扮演角色，達到有趣與加速生產、明確角色</li>
<li>強調時間、互動、以及可產生交付軟體的團隊式活動</li>
</ul>
</li>
<li>優點<ul>
<li>彈性、效率快</li>
<li>反覆確認，降低最終錯誤風險</li>
</ul>
</li>
<li>缺點<ul>
<li>團隊人員需要良好溝通技巧</li>
<li>缺乏結構化與文件紀錄則容易導致風險</li>
<li>專案範疇也可能因為使用者需求的變化而變動    </li>
</ul>
</li>
</ul>
<h2 id="蒐集需求"><a href="#蒐集需求" class="headerlink" title="蒐集需求"></a>蒐集需求</h2><ul>
<li>使用需求獲取(requirement elicitation)或實情調查(fact-finding)<ul>
<li>需求獲取，獲得顆戶德需求</li>
<li>實情調查，根據現實層面進行分析</li>
</ul>
</li>
<li>示意圖<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1Gro2vlFawBQs9MA-zZIINKwoDGsD2p7v&export=download" alt=""></p>
</blockquote>
</li>
<li>step1 決定訪談對象<ul>
<li>選擇正確的人且問題扎實，考慮來自正式和非正式結構(informal structure)中的人員</li>
<li>確認群組或個人訪談</li>
</ul>
</li>
<li>step2 建立訪談目標<ul>
<li>決定討論的問題範圍</li>
<li>了解事項</li>
</ul>
</li>
<li>step3 設計訪談問題<ul>
<li>對訪談的問題進行標準化可以讓訪談有所依循，也避免節外生枝</li>
<li>避免導引式問題(leading questions)，有意或無意暗示訪談者說出某個答案<ul>
<li>開放式問題(open-ended questions)可以讓受訪者不拘形式的回答，沒有固定的標準答案</li>
<li>封閉式問題(closed-ended questions)會限制受訪者的回答，在需要特定資訊或查證事實時使用</li>
<li>範圍式問題(range-of-response questions)也是一種封閉式問題，它可讓受訪者從一組既定答案中或某個數值範圍選擇解答</li>
</ul>
</li>
</ul>
</li>
<li>step4 準備訪談<ul>
<li>不能閒聊，非常重要</li>
<li>一個小時內完成</li>
<li>將主題提前送給受訪者</li>
</ul>
</li>
<li>step5 執行訪談<ul>
<li>會議擬訂計畫</li>
<li>進行訪談時先自我介紹、描述專案內容</li>
<li>專注傾聽(engaged listening)</li>
<li>給對方思考</li>
<li>彙整資料，並告訴對方我們為甚麼需要</li>
</ul>
</li>
<li>step6 記錄訪談<br>可以發感謝卡，並做筆記</li>
<li>step7 評量訪談<br>檢討自己與對方</li>
</ul>
<h2 id="其他蒐集需求的方法"><a href="#其他蒐集需求的方法" class="headerlink" title="其他蒐集需求的方法"></a>其他蒐集需求的方法</h2><ul>
<li>文件查閱(document review)，了解現有系統如何運作</li>
<li>觀察(observation)<ul>
<li>就是觀察你</li>
<li>霍桑效應(Hawthorne Effect，別人看你，你會讓自己做的最好</li>
</ul>
</li>
<li>問卷(questionnaire)和調查(survey)</li>
<li>訪談針對個人做表達，但花時間</li>
<li>問卷可以讓許多人表達意見，但不一定準確</li>
<li>腦力激盪 (brainstorming)是指針對特定問題、機會與議題的小組討論<ul>
<li>結構化腦力激盪 (structured brainstorming)，參加者輪流發言</li>
<li>非結構化腦力激盪 (unstructured brainstorming)，<del>立法院</del>，隨便你發言</li>
</ul>
</li>
<li>抽樣<ul>
<li>系統抽樣(systematic sample)：每10人抽取1人</li>
<li>階層抽樣(stratified sample) ：在所有四個郵遞區號中，每個抽取5人</li>
<li>隨機抽樣(random sample) ：任意抽取20人    </li>
<li>管你怎麼抽，只要樣本能代表母體就可以</li>
</ul>
</li>
<li>研究<ul>
<li>讀書、開會</li>
<li>實地參訪</li>
</ul>
</li>
<li>快捷法專案中的需求蒐集<ul>
<li>注重使用者案例、情境、故事</li>
<li>蒐集需求是為了改進</li>
</ul>
</li>
</ul>
<h2 id="需求的表示"><a href="#需求的表示" class="headerlink" title="需求的表示"></a>需求的表示</h2><ul>
<li>分析師紀錄文件時需要注意<ul>
<li>獲得資訊就紀錄</li>
<li>簡單方式紀錄、好懂</li>
<li>文件容易被檢索</li>
</ul>
</li>
<li>自然語言</li>
<li>圖表</li>
<li>功能分解圖(functional decomposition diagram, FDD) <blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1TyW_RjopA_69qfIQ7EEU_1E-_7jSxLF-&export=download" alt=""></p>
</blockquote>
</li>
<li>商業流程模型(BPM)<ul>
<li>描述一個或多個商業流程</li>
<li>商業流程塑模記法(business process modeling notation, BPMN)包含可用來表示事件、程序及流程的各種不同圖形和符號</li>
<li>示意圖<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1vXBT_woRibdFH106Hzn27RIGrx2-EreK&export=download" alt=""></p>
</blockquote>
</li>
</ul>
</li>
<li>資料流向圖(data flow diagram, DFD)<ul>
<li>顯示系統如何儲存、運作、轉變資料</li>
</ul>
</li>
<li>模型<ul>
<li>統一塑模語言(unified modeling language, UML) </li>
<li>使用案例圖(use case diagram)<br>視覺化表示使用者與資訊系統的互動</li>
<li>循序圖(sequence diagram)<br>表述各物件之間互動及其時間</li>
<li>示意圖 A<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1JV-RkUfLAbccX0MRfR793aodZY8gD5T1&export=download" alt=""></p>
</blockquote>
</li>
<li>示意圖 B<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1c23M26u3gQxCFoMnWfZMWG_tZwNFIvDm&export=download" alt=""></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="確認與驗證需求"><a href="#確認與驗證需求" class="headerlink" title="確認與驗證需求"></a>確認與驗證需求</h2><ul>
<li>需求的確認與驗證(validation and verification, V&amp;V)<ul>
<li>為了讓需求能夠定義出顧客真正需要的系統<ul>
<li>確認：陳述的需求是否正確？</li>
<li>驗證：需求是否正確地陳述？    </li>
</ul>
</li>
<li>並檢查是否有完整性、一致性、可理解性</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>北科上課筆記</category>
        <category>系統分析與設計</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>系統分析與設計筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>物件導向程式設計 筆記 - 大二上期中考手寫筆試重點複習</title>
    <url>/2021/12/01/NTUT_note/NTUTcsie_OOPmidterm/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊工程系大二上物件導向程式設計學重點整理<br><font color="#dd0000">並非所有人都適用，部分對我而言稍加容易的內容並不會寫在此內。</font></p>
</blockquote>
<a id="more"></a>

<h2 id="makefile-用處如何，語法"><a href="#makefile-用處如何，語法" class="headerlink" title="makefile 用處如何，語法"></a>makefile 用處如何，語法</h2><p>輸入 <code>make</code> 指令，會尋找 ls 是否有 makefile 的文件，並編譯 makefile 文件進而自動化建構程式。</p>
<p>makefile 適合開發大型程式，根據 target、rule 來判斷那些程式需要重新編譯、哪些不需要，在編譯大型程式時，如果我們只改動一小部分卻要將所有程式整個編譯就會花費大量時間</p>
<ul>
<li><code>#</code> 是 makefile 中的註解</li>
<li><code>\</code> 是 makefile 中的換行</li>
<li><code>.PHONY</code> 原先 make 會先確認當前是否有此命令資料夾，如果有就會認為已經執行過而不執行，而在 <code>.PHONY</code> 裡面則會強制他必須執行，不須確認是否有此資料夾</li>
</ul>
<p>一個 makefile 的範例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.PHONY: directories clean stat </span><br><span class="line"></span><br><span class="line">all: directories bin&#x2F;ut_all</span><br><span class="line"></span><br><span class="line">bin&#x2F;ut_all: test&#x2F;ut_main.cpp test&#x2F;ut_cat.h src&#x2F;cat.h</span><br><span class="line">	g++ -std&#x3D;c++11 test&#x2F;ut_main.cpp -o bin&#x2F;ut_all -lgtest -lpthread</span><br><span class="line"></span><br><span class="line">directories: </span><br><span class="line">	mkdir -p bin</span><br><span class="line"></span><br><span class="line">clean: </span><br><span class="line">	rm -rf bin</span><br><span class="line"></span><br><span class="line">stat: </span><br><span class="line">	wc src&#x2F;* test&#x2F;*</span><br></pre></td></tr></table></figure>

<h2 id="Default-Constructor-甚麼時機用，甚麼時候不用"><a href="#Default-Constructor-甚麼時機用，甚麼時候不用" class="headerlink" title="Default Constructor 甚麼時機用，甚麼時候不用"></a>Default Constructor 甚麼時機用，甚麼時候不用</h2><ul>
<li>Default Constructor 在使用時，會讓內部參數都是預設參數，如果使用者沒有進行預設那則使用系統預設</li>
<li>如果使用者有建構 constructor 時，則系統就不會存在 default constructor </li>
<li>可以使用 <code>object() = delete</code> 來把 deafault constructor 刪除</li>
</ul>
<h2 id="By-Reference-By-Value-Pointer-個別意思，如何區別，請舉例"><a href="#By-Reference-By-Value-Pointer-個別意思，如何區別，請舉例" class="headerlink" title="By Reference, By Value, Pointer 個別意思，如何區別，請舉例"></a>By Reference, By Value, Pointer 個別意思，如何區別，請舉例</h2><ul>
<li>point 與 ByReference 相同<ul>
<li>pointer 可以隨時 assign，但 Reference 只能在初始化時 assign </li>
<li>pointer 可以設定 NULL，但 Reference 不可以</li>
<li>pointer 可使用 iterator</li>
<li>pointer 持有 memory，但 Reference 只是共享</li>
<li>pointer 需要用到 * 才可以讀取內部資料，但 Reference 不用</li>
</ul>
</li>
<li>By Value 是複製一份資料進來，因此與先前的資料就完全不同</li>
</ul>
<h2 id="Copy-assignment、copy-constructor-個別意思，如何區別"><a href="#Copy-assignment、copy-constructor-個別意思，如何區別" class="headerlink" title="Copy assignment、copy constructor 個別意思，如何區別"></a>Copy assignment、copy constructor 個別意思，如何區別</h2><ul>
<li>Copy assignment 已被初始化後的物件複製其他 object</li>
<li>copy constructor <strong>未被初始化的物件</strong>複製其他 object</li>
<li><code>object(a,b)</code> copy constructor </li>
<li><code>object a = b;</code> copy assignment </li>
</ul>
<h2 id="Function-overloading-個別意思"><a href="#Function-overloading-個別意思" class="headerlink" title="Function overloading 個別意思"></a>Function overloading 個別意思</h2><ul>
<li>相同的 function name 但卻有不同的 parma </li>
<li>函數可以相同，<strong>但參數不可以相同</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">" Here is int "</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">double</span> f)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">" Here is float "</span> &lt;&lt; f &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">char</span> <span class="keyword">const</span> *c)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">" Here is char* "</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	print(<span class="number">10</span>);</span><br><span class="line">	print(<span class="number">10.10</span>);</span><br><span class="line">	print(<span class="string">"ten"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://www.geeksforgeeks.org/passing-by-pointer-vs-passing-by-reference-in-c/" target="_blank" rel="noopener">Passing by pointer Vs Passing by Reference in C++ by GeekforGeeks</a><br><a href="https://medium.com/@racktar7743/c-c-%E6%8C%87%E6%A8%99%E6%95%99%E5%AD%B8-%E5%9B%9B-pass-by-value-vs-pass-by-reference-ed5882802789" target="_blank" rel="noopener">[C/C++] 指標教學[四]: Pass by value vs Pass by reference by MuLong PuYang</a><br><a href="https://stackoverflow.com/questions/11706040/whats-the-difference-between-assignment-operator-and-copy-constructor" target="_blank" rel="noopener">What’s the difference between assignment operator and copy constructor by stackoverflow</a><br><a href="https://www.geeksforgeeks.org/function-overloading-c/" target="_blank" rel="noopener">Function Overloading in C++ by GeekforGeeks</a></p>
]]></content>
      <categories>
        <category>北科上課筆記</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>資料庫管理</tag>
      </tags>
  </entry>
  <entry>
    <title>R dataframe append column 透過變數</title>
    <url>/2021/05/03/R/R-dataframe-append-column-with-string/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>有時候想要透過變數來讓 dataframe append column，那該怎麼辦呢？</p>
</blockquote>
<a id="more"></a>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h2><p>使用這種方法解決</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">df &lt;- data.frame(x = c(<span class="number">1</span>:<span class="number">100</span>)) <span class="comment">#create dataframe</span></span><br><span class="line">new_column &lt;- <span class="string">"new_column"</span> </span><br><span class="line"></span><br><span class="line">df[[new_column]] &lt;- <span class="number">0</span> <span class="comment">#增加新的 column</span></span><br></pre></td></tr></table></figure>

<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://stackoverflow.com/questions/31458244/how-to-create-and-add-new-columns-to-a-dataframe-in-r-within-a-loop" target="_blank" rel="noopener">How to create and add new columns to a dataframe in R within a loop? by stackoverflow</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>老實講 R 真的蠻香的XDD，雖然之前一直嫌棄她不好用。但最近有點被調教成功了XD，多元的套件包就有多元的支持，讚啦！</p>
<p>可是有些效率問題好難過QQ</p>
]]></content>
      <categories>
        <category>R語言</category>
      </categories>
      <tags>
        <tag>R語言</tag>
        <tag>學習筆記</tag>
        <tag>json</tag>
      </tags>
  </entry>
  <entry>
    <title>系統分析與設計- 第九章 資料設計</title>
    <url>/2021/11/14/System_analysis_and_design/ch9_System_analysis_and_design/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊與財金管理系大三上系統分析與設計重點整理<br><font color="#dd0000">並非所有人都適用，部分對我而言稍加容易的內容並不會寫在此內。</font></p>
<p>如果有侵犯到版權的問題在聯繫我，再聯絡我，我在移除</p>
</blockquote>
<a id="more"></a>

<h2 id="資料設計概念"><a href="#資料設計概念" class="headerlink" title="資料設計概念"></a>資料設計概念</h2><ul>
<li>資料結構<ul>
<li>資料結構是資訊系統內的組織、儲存及管理資料的架構</li>
<li>檔案和資料表它們有各種形式彼此連結</li>
</ul>
</li>
<li>檔案式系統(file-oriented system)，利用檔案來處理資料</li>
<li>關聯式模型(relational model)，利用資料庫來處理資料</li>
<li>資料庫管理系統(database management system, DBMS)<ul>
<li>可讓使用者新增、更新、管理、存取並分析資料內容的一組工具、功能及介面的組合。</li>
<li>優點<ul>
<li>可延展性(scalability)，系統可以輕易擴充、縮小</li>
<li>經濟規模(economy of scale)，長期平均總成本會因為產量增加而減少</li>
<li>有效支援企業級應用系統——資料庫管理師 (database, administrator,DBA)</li>
<li>更強的標準</li>
<li>更佳的安全性</li>
<li>資料獨立性</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="DBMS-組成元件"><a href="#DBMS-組成元件" class="headerlink" title="DBMS 組成元件"></a>DBMS 組成元件</h2><blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1gk75CY0q4SKefV4C3HiGVPsnZHe8CsqA&export=download" alt=""></p>
</blockquote>
<ul>
<li>使用者、資料庫管理師與其系統介面<ul>
<li>使用者，根據事先定義查詢或指令來執行動作</li>
<li>資料庫管理師，負責 DBMS 管理與支援</li>
<li>相關資訊系統，DBMS 可支援許多提供輸入給 DBMS 或是從 DBMS 取得特定資料</li>
</ul>
</li>
<li>資料綱目<ul>
<li>綱目(schema) A<ul>
<li>包括所有欄位、資料表及關聯性的描述</li>
<li>子綱目(subschema)：資料庫中符合特定系統或使用者需求，或是允許存取的部分</li>
</ul>
</li>
</ul>
</li>
<li>實體資料儲存處<ul>
<li>包含綱目與子綱目</li>
<li>可集中式也可以分散到數個地點</li>
</ul>
</li>
</ul>
<h2 id="Web-式設計"><a href="#Web-式設計" class="headerlink" title="Web 式設計"></a>Web 式設計</h2><ul>
<li>讓資料庫連上 web，史資料可以被更新或閱讀</li>
<li>中介軟體(middleware)是一種整合不同應用系統並讓它們彼此能夠交換資料的軟體</li>
<li>Web 式資料必須顧及安全性，並且讓授權使用者能輕易存取</li>
<li>Web 特性<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=127jTFH07odZVHVHpwxB1H6TOzPKw4wwf&export=download" alt=""></p>
</blockquote>
</li>
<li>Web 與 database 架構<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1xe3SAo5oEzYC_TbFkVxx2M-gN9_4poaf&export=download" alt=""></p>
</blockquote>
</li>
</ul>
<h2 id="資料設計術語"><a href="#資料設計術語" class="headerlink" title="資料設計術語"></a>資料設計術語</h2><ul>
<li>定義<ul>
<li>實體(entity)，蒐集和維護資料的對象</li>
<li>資料表(table)或檔案(file)，包含了一組相關的紀錄，這些紀錄都存放了與特定實體有關的資料</li>
<li>欄位(field)，也稱為屬性(attribute)，亦即實體的一個特性，如果一個屬性有兩個實體則是共同欄位</li>
<li>紀錄(record)，也稱為值組(tuple)，一組相關欄位的組合，用以描述實體的一筆實例</li>
</ul>
</li>
<li>鍵欄位(key fields)<ul>
<li>主鍵(primary key)，一個欄位或一組欄位，可以唯一且簡潔地識別出實體某個特定成員</li>
<li>候選鍵(candidate key)，其他可以做為主鍵的欄位</li>
<li>外鍵(foreign key)，某一張資料表的其中一個欄位，但同時也是另一張資料表的主鍵，用以建立兩張資料表的關係</li>
<li>次級鍵(secondary key)，其他的欄位</li>
</ul>
</li>
<li>參照完整性(referential integrity)，避免資料不一致、品質不穩定的問題<br>每一個外來鍵必須對應到其他資料表的主鍵，否則不應該輸入</li>
</ul>
<h3 id="實體關係圖"><a href="#實體關係圖" class="headerlink" title="實體關係圖"></a>實體關係圖</h3><ul>
<li>實體關係圖(entityrelationship diagram, ERD)是一個顯示系統實體間邏輯關係的模型<ul>
<li>關係，兩個實體的媒介，分成一對一、一對多、多對多</li>
<li>示意圖<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1x9KyOELQk4zqXrNHhSIte_WR5iKKW5jF&export=download" alt=""></p>
</blockquote>
</li>
</ul>
</li>
<li>基數(cardinality)<ul>
<li>描述兩實體間的關記數量，顯示與另外一個實體的關聯性<ul>
<li>基數標記法(cardinality notation)利用特殊的符號來表示關係</li>
<li>基數標記法示意圖<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=123kKiWWol56mv7oG300z-MSLIOksiu_M&export=download" alt=""></p>
</blockquote>
</li>
<li>鴨足標記法(crow’s foot notation)使用圓圈、直線條以及類似鴨子腳的符號來標示各種可能的關係</li>
<li>鴨足標記法示意圖<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=14HQMPNyc-zINbGuD72JCkhXZvlB-z-Zx&export=download" alt=""></p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="資料正規化"><a href="#資料正規化" class="headerlink" title="資料正規化"></a>資料正規化</h2><ul>
<li>正規化(normalization)是為資料庫中每個資料表指定明確欄位或屬性的資料表設計建立流程</li>
<li>資料表設計(table design)，為特定檔案或資料表指定其欄位與主鍵的動作</li>
<li>正規化程序包含四階段<ul>
<li>未正規化的設計</li>
<li>第一正規形式</li>
<li>第二正規形式</li>
<li>第三正規形式</li>
</ul>
</li>
<li>標準標記格式(standard notation format)<ul>
<li>表示資料表結構、欄位、primary key</li>
<li>name(++primary_key++, attribute1, attribute2)</li>
</ul>
</li>
<li>未正規化的設計<ul>
<li>沒有辨認重複的群組或欄位，不可以有重複群組的問題。</li>
<li>示意圖<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=17fLiE96Bhw3SsIf2jaW5IcUXYtl6TDVU&export=download" alt=""></p>
</blockquote>
</li>
</ul>
</li>
<li>第一正規形式(first normal form, 1NF)<ul>
<li>資料表不包含群組</li>
<li>把重複群組的 primary key 變成資料表的 primary key<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1J6ILCDjVj7cJC1VCLrsC54iqZ0GQysoC&export=download" alt=""></p>
</blockquote>
</li>
</ul>
</li>
<li>第二正規形式(second normal form, 2NF)<ul>
<li>功能相依(functionally dependent)的概念，如果 attribute1 會根據 attribute2 而改變，那麼 attribute1 功能相依 attribute1</li>
<li>所有 attribute 必須依賴 primary key</li>
<li>當資料表符合 1nf，且有功能相依的 table 時就是 2nf。<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1pIc1mUUa2QjE3Rf8oIdoawnVmaSAlPzo&export=download" alt=""></p>
</blockquote>
</li>
</ul>
</li>
<li>第三正規形式(third normal form, 3NF)<ul>
<li>其他非 primary key 的 attribute，都功能相依於 primary key 時，就符合 3nf</li>
<li>可避免 2nf 的重複、資料完整性問題<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1I4xI8aegbeBvpOogZJOfS44Hsb_BmiS7&export=download" alt=""></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="代碼-code"><a href="#代碼-code" class="headerlink" title="代碼 code"></a>代碼 code</h2><ul>
<li>代碼(code) 是一組用來代表資料項目的英文字母或數字，它可以用來簡化輸出、輸入和資料格式</li>
<li>代碼(code) 的特性<ul>
<li>通常比本身資料來的更簡短</li>
<li>節省儲存空間與成本</li>
<li>減少資料傳輸時間並減少資料輸入時間</li>
<li>用來揭露和隱藏資訊</li>
<li>減少資料輸入的錯誤</li>
<li>比較好記且容易輸入</li>
</ul>
</li>
<li>代碼的類型<ul>
<li>順序代碼(sequence codes) 是指以特定次序指定的數字和字母</li>
<li>分段順序代碼(block sequence codes) 是用一些區塊的數字代表不同的分類</li>
<li>字母代碼 (alphabetic codes) 是以英文字母來區分不同的項目<ul>
<li>類別代碼(category codes)，用來分類一群相關項目</li>
<li>縮寫代碼(abbreviation codes)，將名稱進行縮寫</li>
</ul>
</li>
<li>舉例 TPE 為桃園國際機場代號</li>
<li>我認為應該要叫代號，但不知道為甚麼課本教做代碼，不太是台灣用詞</li>
</ul>
</li>
<li>加密代碼(cipher codes)用一個關鍵字將一個數字進行編碼的方法</li>
<li>行動代碼(action codes)表示要對其所關聯的項目採取什麼行動</li>
<li>設計代碼<ul>
<li>保持精簡、簡單結構</li>
<li>允許擴充並維持一致性</li>
<li>保持代碼穩定</li>
<li>使代碼唯一、避免混淆</li>
<li>使用可排序代碼</li>
</ul>
</li>
</ul>
<h2 id="資料儲存及存取"><a href="#資料儲存及存取" class="headerlink" title="資料儲存及存取"></a>資料儲存及存取</h2><ul>
<li>工具與技術<ul>
<li>資料倉儲(data warehouse)，它可以涵蓋公司內各處所存放而似乎並不相關的資料</li>
<li>資料市集(data mart)，專門設計用來服務特定部門需求<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1X08FxU5OiQ3V3G6_qqIfPB64ekKSoqcn&export=download" alt=""></p>
</blockquote>
</li>
</ul>
</li>
<li>資料探勘建議目標<ul>
<li>增加每次連線的平均造訪網頁數</li>
<li>增加推薦顧客的數量</li>
<li>減少成交點擊數(clicks to close)，減少平均完成一次購買行為，使用者會開幾個網頁搜尋，降低消費者去比較或是猶豫的慾望。</li>
<li>增加每次造訪的結帳次數</li>
<li>增加每次結帳的平均利潤</li>
</ul>
</li>
<li>邏輯與實體儲存<ul>
<li>邏輯儲存(logical storage)係指透過使用者觀點所見到的資料，而不管該資訊實際組織或儲存的方法及地點</li>
<li>實體儲存(physical storage)純粹與硬體相關</li>
<li>資料編碼<ul>
<li>EBCDIC 應用在大型主機或高容量伺服器</li>
<li>ASCII 大部分個人電腦編碼方式</li>
<li>Unicode 使用二位元組</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="資料控制"><a href="#資料控制" class="headerlink" title="資料控制"></a>資料控制</h2><ul>
<li>設計良好的 DBMS，必須提供內建的控制與安全性功能</li>
<li>資料保護方式<ul>
<li>限制檔案和資料庫存取</li>
<li>使用者 ID 與密碼</li>
<li>權限(permission)與加密(encryption)</li>
</ul>
</li>
<li>所有系統檔案與資料庫都要定期備份</li>
<li>復原程序(recovery procedures)可以將檔案和資料庫復原到上次備份時的狀態</li>
</ul>
]]></content>
      <categories>
        <category>北科上課筆記</category>
        <category>系統分析與設計</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>系統分析與設計筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>北科電子大三上機器學習 使用回歸預測房價</title>
    <url>/2021/11/25/deep_learning/NTUTece_deeplearning_regression/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學電子大三上機器學習作業紀錄<br><font color="#dd0000">並非所有人都適用，部分對我而言稍加容易的內容並不會寫在此內。</font><br><strong>這是學習後心得的筆記，可能不太適用會未來的學生</strong></p>
<p>由於我沒有學習過裡面的理論，因此這是資財大三學生透過網路與自身理解的筆記，學習價值並不高、且可能擁有大量錯誤。</p>
</blockquote>
<a id="more"></a>


<h1 id="台北科大深度學習-房價預測回歸模型"><a href="#台北科大深度學習-房價預測回歸模型" class="headerlink" title="台北科大深度學習 - 房價預測回歸模型"></a>台北科大深度學習 - 房價預測回歸模型</h1><h2 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h2><p>使用 keras 中的 sequence 進行房價預測，在 kaggle Private Leaderboard 獲得 136 名</p>
<h2 id="查看房價預測中的所有欄位說明"><a href="#查看房價預測中的所有欄位說明" class="headerlink" title="查看房價預測中的所有欄位說明"></a>查看房價預測中的所有欄位說明</h2><blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1JghS7Z2aAsqWvT7FoHX3akB3FTKqwqdN&export=download" alt=""></p>
</blockquote>
<h2 id="輸出欄位要求必須為"><a href="#輸出欄位要求必須為" class="headerlink" title="輸出欄位要求必須為"></a>輸出欄位要求必須為</h2><blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1Fedy4zhBv-IXjvgUiNN3nfjis0eUkvc8&export=download" alt=""></p>
</blockquote>
<h2 id="輸入資料"><a href="#輸入資料" class="headerlink" title="輸入資料"></a>輸入資料</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#輸入資料</span></span><br><span class="line"><span class="comment">#train csv </span></span><br><span class="line">train = pd.read_csv(<span class="string">"./regression_data/train-v3.csv"</span>)</span><br><span class="line">  </span><br><span class="line">X_train = train.drop([<span class="string">"price"</span>, <span class="string">"id"</span>], axis=<span class="number">1</span>)</span><br><span class="line">Y_train = train[<span class="string">"price"</span>].values</span><br><span class="line"><span class="comment">#print(X_train)</span></span><br><span class="line"></span><br><span class="line">valid = pd.read_csv(<span class="string">"./regression_data/valid-v3.csv"</span>)</span><br><span class="line"><span class="comment">#print(train)</span></span><br><span class="line">X_valid = valid.drop([<span class="string">"price"</span>, <span class="string">"id"</span>], axis=<span class="number">1</span>)</span><br><span class="line">Y_valid = valid[<span class="string">"price"</span>].values</span><br><span class="line"><span class="comment">#print(X_valid)</span></span><br></pre></td></tr></table></figure>

<h2 id="資料預處理"><a href="#資料預處理" class="headerlink" title="資料預處理"></a>資料預處理</h2><p>這邊我使用了幾種不同方式的資料預處理，但發現其實都沒有比不處理來的好</p>
<h3 id="將內部相關係數大於-0-7-的選擇一個移除"><a href="#將內部相關係數大於-0-7-的選擇一個移除" class="headerlink" title="將內部相關係數大於 0.7 的選擇一個移除"></a>將內部相關係數大於 0.7 的選擇一個移除</h3><p>先來檢測內部參數相關性，如果太相關那我們就選一個拔除，避免回歸時某些類型被重複強調。</p>
<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1KBIASypCusFb0t8hLeI4FGES71QnhxRC&export=download" alt=""></p>
</blockquote>
<p>其中我將以下相關性過高的欄位進行移除</p>
<ul>
<li>bathrooms 與 sqft_living 有相關性，刪除 bathrooms </li>
<li>grade 與 sqft_living 有相關性，刪除 grade</li>
<li>sqft_above 與 sqft_living 有相關性，刪除 sqft_above</li>
<li>sqft_living15 與 sqft_living 有相關性，刪除 sqft_living15</li>
<li>sqft_lot15 與 sqft_lot 有相關性，刪除 sqft_lot15</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns </span><br><span class="line"></span><br><span class="line">train_cor = train.corr(method = <span class="string">"pearson"</span>).round(<span class="number">2</span>)</span><br><span class="line">print(train_cor)</span><br><span class="line">plt.subplots(figsize=(<span class="number">13</span>, <span class="number">16</span>))</span><br><span class="line">sns.heatmap(train_cor, annot = <span class="literal">True</span>,  cmap = <span class="string">"Blues"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#bathrooms 與 sqft_living 有相關性，刪除 bathrooms </span></span><br><span class="line"><span class="comment">#grade 與 sqft_living 有相關性，刪除 grade</span></span><br><span class="line"><span class="comment">#sqft_above 與 sqft_living 有相關性，刪除 sqft_above</span></span><br><span class="line"><span class="comment">#sqft_living15 與 sqft_living 有相關性，刪除 sqft_living15</span></span><br><span class="line"><span class="comment">#sqft_lot15 與 sqft_lot 有相關性，刪除 sqft_lot15</span></span><br><span class="line">train_cor = train.drop([<span class="string">"bathrooms"</span>, <span class="string">"grade"</span>, <span class="string">"sqft_above"</span>, <span class="string">"sqft_living15"</span>, <span class="string">"sqft_lot15"</span>], axis=<span class="number">1</span>)</span><br><span class="line">train_cor = train_cor.corr(method = <span class="string">"pearson"</span>).round(<span class="number">2</span>)</span><br><span class="line">plt.subplots(figsize=(<span class="number">12</span>, <span class="number">9</span>))</span><br><span class="line">sns.heatmap(train_cor, annot = <span class="literal">True</span>,  cmap = <span class="string">"Blues"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">X_train = X_train.drop([<span class="string">"bathrooms"</span>, <span class="string">"grade"</span>, <span class="string">"sqft_above"</span>, <span class="string">"sqft_living15"</span>, <span class="string">"sqft_lot15"</span>], axis=<span class="number">1</span>) <span class="comment">#共線性檢視完畢</span></span><br><span class="line">X_valid = X_valid.drop([<span class="string">"bathrooms"</span>, <span class="string">"grade"</span>, <span class="string">"sqft_above"</span>, <span class="string">"sqft_living15"</span>, <span class="string">"sqft_lot15"</span>], axis=<span class="number">1</span>) <span class="comment">#共線性檢視完畢</span></span><br></pre></td></tr></table></figure>

<p>但沒有比不做處理就直接回歸來的好</p>
<h3 id="將-year、month、day-進行移除"><a href="#將-year、month、day-進行移除" class="headerlink" title="將 year、month、day 進行移除"></a>將 year、month、day 進行移除</h3><p>由於我認為時間序列在回歸中會搗亂預測、讓預測模糊因此我 drop 這三個 column 然後進行回歸。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">X_train = X_train.drop([<span class="string">"sale_yr"</span>, <span class="string">"sale_month"</span>, <span class="string">"sale_day"</span>], axis=<span class="number">1</span>) <span class="comment">#共線性檢視完畢</span></span><br><span class="line">X_valid = X_valid.drop([<span class="string">"sale_yr"</span>, <span class="string">"sale_month"</span>, <span class="string">"sale_day"</span>], axis=<span class="number">1</span>) <span class="comment">#共線性檢視完畢</span></span><br></pre></td></tr></table></figure>

<p>但沒有比不做處理就直接回歸來的好</p>
<h2 id="開始回歸"><a href="#開始回歸" class="headerlink" title="開始回歸"></a>開始回歸</h2><p>使用 sequential 然後我們加入隱藏層並 unit 從 256 不斷除 2，在不斷加入在 model 上</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model = Sequential()</span><br><span class="line">model.add(Dense(<span class="number">250</span>, input_dim =X_train.shape[<span class="number">1</span>], kernel_initializer= <span class="string">"random_normal"</span>, activation=<span class="string">"relu"</span> ))</span><br><span class="line">model.add(Dense(<span class="number">125</span>, kernel_initializer= <span class="string">"random_normal"</span>, activation=<span class="string">"relu"</span> ))</span><br><span class="line">model.add(Dense(<span class="number">60</span>, kernel_initializer= <span class="string">"random_normal"</span>, activation=<span class="string">"relu"</span> ))</span><br><span class="line">model.add(Dense(<span class="number">30</span>, kernel_initializer= <span class="string">"random_normal"</span>, activation=<span class="string">"relu"</span> ))</span><br><span class="line">model.add(Dense(<span class="number">15</span>, kernel_initializer= <span class="string">"random_normal"</span>, activation=<span class="string">"relu"</span> ))</span><br><span class="line">model.add(Dense(<span class="number">1</span>, kernel_initializer= <span class="string">"random_normal"</span>, activation=<span class="string">"relu"</span> ))</span><br><span class="line"></span><br><span class="line">model.compile(loss=<span class="string">"mean_squared_error"</span>, optimizer=<span class="string">"adam"</span>) <span class="comment">#設定 model 的損失函數、優化器</span></span><br></pre></td></tr></table></figure>

<h3 id="訓練開始"><a href="#訓練開始" class="headerlink" title="訓練開始"></a>訓練開始</h3><p>設定好 model epoch 並且將訓練集、測試集資料放入，就等一段時間開始訓練拉</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> keras.callbacks <span class="keyword">import</span> ModelCheckpoint</span><br><span class="line">call = ModelCheckpoint(<span class="string">"regression.model"</span>, </span><br><span class="line">                              monitor = <span class="string">"val_loss"</span>,</span><br><span class="line">                              )</span><br><span class="line"></span><br><span class="line">fit = model.fit(X_train, Y_train,</span><br><span class="line">                validation_data = (X_valid, Y_valid),</span><br><span class="line">                callbacks = [call],</span><br><span class="line">                epochs = <span class="number">320</span>)</span><br></pre></td></tr></table></figure>

<h2 id="查看差異，1-100-筆預設與實務差異"><a href="#查看差異，1-100-筆預設與實務差異" class="headerlink" title="查看差異，1~100 筆預設與實務差異"></a>查看差異，1~100 筆預設與實務差異</h2><p>我們訓練完資料後可以看看預測跟實際上的資料差多少</p>
<p>其中我們可以看到我的預測都較保守，實際答案都比我的預測超出許多，有些甚至到了超級多。</p>
<ul>
<li>藍色線表示 predict</li>
<li>橘色線表示 valid </li>
</ul>
<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=11Fm6H1lQy7-mVLZF24rOTMzLgFdtbcEG&export=download" alt=""></p>
</blockquote>
<h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><ul>
<li>不正確的資料預處理並不會導致 kaggle MSE 分數降低</li>
<li>像今天上課同學報告的一樣，zipcode 比較沒有甚麼意義，也許可以變成頻率分析</li>
<li>可以自己加入一些加減乘除的變數，例如室內面積 / 浴室面積比，會有一些參考價值存在</li>
<li>每次 model 完成後，可以畫出 model accuracy、model loss 圖，方便自己更了解問題所在</li>
</ul>
<p><a href="https://colab.research.google.com/drive/1hxwF9CY-1IVXIMpLVcCGHBF_LxE3XxS2?usp=sharing" target="_blank" rel="noopener">我的 colab 供大家參考</a></p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://machinelearningmastery.com/display-deep-learning-model-training-history-in-keras/" target="_blank" rel="noopener">Display Deep Learning Model Training History in Keras 教學劃出 model accuracy、model loss by  Jason Brownlee </a><br><a href="https://keras.io/api/callbacks/model_checkpoint/" target="_blank" rel="noopener">ModelCheckpoint by Keras</a><br><a href="https://blog.csdn.net/imxlw00/article/details/109905940" target="_blank" rel="noopener">Keras深度学习笔记 非线性回归 by csdn imxlw00</a><br><a href="https://keras.io/zh/models/sequential/" target="_blank" rel="noopener">Sequential 模型 API by Keras</a><br><a href="https://keras.io/zh/losses/" target="_blank" rel="noopener">损失函数的使用 by Keras</a><br><a href="https://www.journaldev.com/45330/relu-function-in-python" target="_blank" rel="noopener">ReLu Function in Python by Keras</a><br><a href="https://www.jiqizhixin.com/graph/technologies/f41c192d-9c93-4306-8c47-ce4bf10030dd" target="_blank" rel="noopener">Adam优化器 by 機器之心</a><br><a href="https://zhuanlan.zhihu.com/p/35494575" target="_blank" rel="noopener">python3.x-seaborn.heatmap随笔 by wiliken</a><br><a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.drop.html" target="_blank" rel="noopener">pandas.DataFrame.drop by pandas</a><br><a href="https://blog.csdn.net/weixin_38278334/article/details/82971752" target="_blank" rel="noopener">fit_transform,fit,transform区别和作用详解！！！！！！ by 九点澡堂子</a><br><a href="https://www.delftstack.com/zh-tw/api/numpy/python-numpy-numpy.shape-function/" target="_blank" rel="noopener">Python NumPy numpy.shape() 函式 by DelftStack</a></p>
]]></content>
      <categories>
        <category>北科上課筆記</category>
        <category>機器學習</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>機器學習</tag>
      </tags>
  </entry>
  <entry>
    <title>機器學習 SOP</title>
    <url>/2021/04/25/deep_learning/deep_learning_SOP/</url>
    <content><![CDATA[<h2 id="說明"><a href="#說明" class="headerlink" title="說明"></a>說明</h2><p>紀錄大衛在做機器學習時，應該要怎麼做會達到最好。</p>
<h2 id="SOP-開始"><a href="#SOP-開始" class="headerlink" title="SOP 開始"></a>SOP 開始</h2><ul>
<li>將遺失的資料移除</li>
<li>對於沒有意義的數字可以進行移除</li>
<li>可以考慮把一些 string, numeric 變成頻率分析</li>
<li>可以自己加入一些加減乘除的變數，例如室內面積 / 浴室面積比，會有一些參考價值存在</li>
<li>每次 model 完成後畫圖<ul>
<li>畫出 model accuracy</li>
<li>model loss 圖，方便自己更了解問題所在</li>
<li>畫出前 100 筆資料的預測與答案</li>
<li>使用 tensorboard 來看自己的 model 訓練問題</li>
</ul>
</li>
</ul>
<h2 id="額外輕鬆項"><a href="#額外輕鬆項" class="headerlink" title="額外輕鬆項"></a>額外輕鬆項</h2><ul>
<li>bayesian optimization 來自動選擇參數，但要花許久時間，因為是不斷嘗試每個參數</li>
<li>ReLu 當 activation function</li>
</ul>
]]></content>
      <categories>
        <category>機器學習</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>機器學習</tag>
      </tags>
  </entry>
  <entry>
    <title>大衛手寫考試改進策略，每次考試前必看</title>
    <url>/2021/11/26/life_experence/exam/</url>
    <content><![CDATA[<h2 id="說明"><a href="#說明" class="headerlink" title="說明"></a>說明</h2><blockquote>
<p>記錄大衛在手寫考試時，常常會遇到老師考A，我就只會覺得老師考 A，結果老師考試都喜歡來 A+B，然後我就都不會、考很差。</p>
<p>這篇主要是改善自己的缺點，然後盡量考好。</p>
</blockquote>
<a id="more"></a>

<h2 id="改進"><a href="#改進" class="headerlink" title="改進"></a>改進</h2><ul>
<li>在期中考前再次手寫全部的習題<br>習題很重要，第一次寫過之後，大考前在重寫一次，加深自己印象</li>
<li>如果沒有買課本，記得在大考前幾周要跟朋友借課本<br>上課 PPT 不一定都有重點，透過具有系統化的課本複習來作筆記會讓自己更加深刻。</li>
<li>熟記所有公式，找女朋友來幫忙你背</li>
<li>大考前兩個禮拜就必須開始做好複習<br>我不適合短期衝刺，比較適合慢慢準備</li>
</ul>
]]></content>
      <categories>
        <category>人生旅途</category>
      </categories>
      <tags>
        <tag>大學Life</tag>
        <tag>人生旅途</tag>
      </tags>
  </entry>
  <entry>
    <title>ICPC 檢討、隊員努力守則</title>
    <url>/2021/12/08/contest_experence/ICPC_review/</url>
    <content><![CDATA[<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><blockquote>
<p>在參加 ICPC 中的所有檢討會議都會在這邊，檢討我們比賽中的缺失，讓自己不在犯錯導致失誤，並且銘記在心，記錄下來以避免忘記</p>
</blockquote>
<a id="more"></a>

<h2 id="比賽練習方向"><a href="#比賽練習方向" class="headerlink" title="比賽練習方向"></a>比賽練習方向</h2><ul>
<li>Codeforces 比起 UVa 來的更重要，這是用經驗換來的</li>
</ul>
<h2 id="隊員"><a href="#隊員" class="headerlink" title="隊員"></a>隊員</h2><ul>
<li>當隊員看一題看超過 15min or 送出程式碼卻 WA 時，其他隊員必須也來聽聽這個題目，並確認此隊員想法是否有正確，達成共識後再 submit。</li>
<li>必須線下共同練習，線上共同練習就失去共同練習、共同討論的意義</li>
<li>每周必須讓隊員碰演算法，熟悉演算法</li>
<li>讓隊員的心主要都在演算法上，而不會因為其他事情而忽略演算法</li>
<li>準時開會</li>
</ul>
]]></content>
      <categories>
        <category>競賽心得</category>
      </categories>
      <tags>
        <tag>大學Life</tag>
        <tag>ICPC</tag>
        <tag>程式比賽</tag>
        <tag>競賽心得</tag>
        <tag>人生旅途</tag>
      </tags>
  </entry>
  <entry>
    <title>2021 International Collegiate Programming Contest Asia Taipei-Hsinchu Site (ICPC2021) - 72th 心得</title>
    <url>/2021/11/28/contest_experence/icpc2021/</url>
    <content><![CDATA[<blockquote>
<p>僅此紀錄 2021/11/28 2021 ICPC 心得。<br>「紀錄每個時刻，讓未來的自己不遺忘過去的自己」<br>只有自己才能體會自己的過去<br>沒有得獎拉，只是很可惜自己還不夠好吧。</p>
<p><strong>明天要保持笑容，面對每個挑戰，因為不優秀的人是沒有資格哭泣的。</strong></p>
<p><a href="https://theriseofdavid.github.io/2020/11/10/contest_experence/ICPC2020/" target="_blank" rel="noopener">ICPC 的流程可以看這裡</a></p>
</blockquote>
<a id="more"></a>

<h2 id="第一天的報告"><a href="#第一天的報告" class="headerlink" title="第一天的報告"></a>第一天的報告</h2><h3 id="前情"><a href="#前情" class="headerlink" title="前情"></a>前情</h3><p>由於最後這幾周是期中考周，大家都比較忙也沒有在練習其他題目，因此我們的 codebook 跟 NCPC 決賽時相同</p>
<h3 id="報告"><a href="#報告" class="headerlink" title="報告"></a>報告</h3><p>由於這次因為疫情的關係，這次比賽後沒有晚宴可以吃，只有餐盒可以拿QQ。</p>
<p>我跟阿官還有力瑋約 13 點 20 分在北商集合，結果我遲到了，其他兩個都比我早到，我好對不起大家。</p>
<p>確認力瑋有帶字典後我們就去報到了，這次我們的比賽組別是在 A20，我們選手的衣服顏色沒變，倒是工作人員與教練的衣服變得很好看，讓我覺得很羨慕阿！藍色的衣服真的不適合我拉。</p>
<p>但是書包這次明顯有升級，我覺得好很多。</p>
<p>報到完成，換成比賽衣服，就拍完照準備上去報到啦。</p>
<blockquote>
<p>ICPC 報告照<br><img src="https://drive.google.com/u/2/uc?id=17GeeEED2am611AlU2vX3MzSyPJkGZxe1&export=download" alt=""></p>
</blockquote>
<blockquote>
<p>北商照片<br><img src="https://drive.google.com/u/2/uc?id=1VsTB7hBdYgC-M0iUMnSHDstMxukwCkc5&export=download" alt=""></p>
</blockquote>
<h3 id="進場與開幕典禮"><a href="#進場與開幕典禮" class="headerlink" title="進場與開幕典禮"></a>進場與開幕典禮</h3><p>由於因為疫情關係，ICPC 這次沒有其他國外隊參賽，因此比賽的隊伍跟 NCPC 基本上一樣，此時我原本對我們隊伍很有信心，因為上次我們拿到 30th，這次應該不會太差吧，我心裡是這樣想著的。</p>
<p>主辦單位開始舉行開幕儀式，因為這次沒有外國隊，因此開幕典禮就用中文表達XD，其實還蠻不賴拉，對不懂英文的我來說也是一大好事啦。</p>
<p>這次的點心是巧克力跟一些小餅乾，不是不好吃拉，但是好懷念 2020 那時候可以吃很多好吃的小蛋糕喔，小蛋糕真的 100 分，這次的小餅乾讓我好傷心QQ。</p>
<h3 id="電腦測試"><a href="#電腦測試" class="headerlink" title="電腦測試"></a>電腦測試</h3><p>這次電腦測試是用 TOPC2021 的題目來做測試，由於其實題目大部分都相似，因此就是讓我們熟悉電腦環境，讓我們上傳去測試各種錯誤 or AC。</p>
<p>大概在下午 4 點的時候主辦單位就說可以陸續讓大家回家拉。</p>
<h2 id="第二天"><a href="#第二天" class="headerlink" title="第二天"></a>第二天</h2><h3 id="報到"><a href="#報到" class="headerlink" title="報到"></a>報到</h3><p>這天我最早到XD，接下來 10 分鐘後力瑋跟阿官就順利到場，開始進行報到。</p>
<h3 id="比賽過程"><a href="#比賽過程" class="headerlink" title="比賽過程"></a>比賽過程</h3><p>這次比賽題目比較多，我希望可以拿高好名次，因此我跟隊友說有把握在送出去，盡量不要錯一些可惜的地方，起初我順利解出水題，再來力瑋解出一題，而阿官這時還沒有找出其他簡單好寫的題目，再來我看了一題字串，力瑋也在看一題。</p>
<p>力瑋送出一題 CE，原因是 freopen 沒有關，好可惜<br>力瑋在送一次 TLE，好可惜，也是沒過QQ。</p>
<p>大衛送出一題 WA，再送一次 WA，再送一次 WA，此時我已經浪費很多時間在更改邏輯、程式碼，大概只剩下 1 小時了。</p>
<p>我跟力瑋、阿官求救，此時阿官想到一個很簡單、直覺的想法，並上前寫了上去 AC，我當下的腦中真的一片空白，是我想太深、思考不夠全面嗎，把一個最簡單的想法給漏了，要是成功把他解開來說不定就可以爭取更多時間寫題目拉！</p>
<p>當阿官順利解完時，時間只剩下 30min，其他的題目我們都不太能夠解出來。</p>
<p>主辦單位不斷發放許多的小餐點給大家補充營養，但是我覺得都還是沒有比小蛋糕來的好吃拉，小糕點才是最棒的，那些餅乾甚麼的在糕點面前都不勘一提阿XD。</p>
<blockquote>
<p>競賽畫面<br><img src="https://drive.google.com/u/2/uc?id=17Qdb8FVcaUKJTay0uOIQe-XyuE1DHCpx&export=download" alt=""></p>
</blockquote>
<h3 id="頒獎典禮-amp-心得"><a href="#頒獎典禮-amp-心得" class="headerlink" title="頒獎典禮 &amp; 心得"></a>頒獎典禮 &amp; 心得</h3><p>我們其實都知道我們這次比得不好，主要是我在浪費時間，我花了太多時間解一題我一直都沒有往正確方向思考的題，才讓這次我們的隊伍考得這麼差QQ，要是如果我在第一次 WA 就先與隊友討論，那或許情況不應該遭到此地步，而非讓隊友去看其他難的題目，我自己慢慢解實作題。</p>
<p>自己實作題其實沒有到很擅長，但當下我覺得我做得到就上去解，結果失敗了，好自責。因為這次比賽其實解出 3 題、解出 4 題的人非常多，大概從 25 名 ~ 85 名都是解出三題跟四題，也就意味著這次比賽很考驗你解題錯了幾次，錯越多，那你的名次就越後面。</p>
<p>最後在公布名次的時候我也發現有很多學校隊伍只花了 120 分鐘就寫出 3 題後就再也不作答了，我才驚然意識到很多人在這次比賽都使用保守策略，不衝題，我只要等著其他努力的人解題目然後 WA 把名次往下摔就好，雖然覺得這種策略很消極，但他們成功了。<br>也許我下次 ICPC 也要考慮使用這種策略，解完有把握的，再來就都不解，休息等比賽結束，說不定才是最好的解法。</p>
<h3 id="檢討"><a href="#檢討" class="headerlink" title="檢討"></a>檢討</h3><ul>
<li>我對不起我的隊友，這次我比得不好，我需要好好檢討自己。</li>
<li>我們最後的練習也不足，演算法也練不多，我想這是我們隊伍必須要好好檢討的，向心力有點不太足夠。</li>
<li>Codeforces 比起 UVa 來的更重要，這是用經驗換來的</li>
<li>當隊員看一題看超過 15min or 送出程式碼卻 WA 時，其他隊員必須也來聽聽這個題目，並確認此隊員想法是否有正確，達成共識後再 submit。</li>
</ul>
<h3 id="賽後結束"><a href="#賽後結束" class="headerlink" title="賽後結束"></a>賽後結束</h3><p>再來賽後結束大家就各自領著餐盒結束，一起好好準備未來，也謝謝各位努力陪我練習演算法一整年，謝謝力瑋跟阿官了，即使大家在忙，也沒有把這邊的責任逃避或放下，都有好好做完。</p>
]]></content>
      <categories>
        <category>競賽心得</category>
      </categories>
      <tags>
        <tag>大學Life</tag>
        <tag>ICPC</tag>
        <tag>程式比賽</tag>
        <tag>競賽心得</tag>
        <tag>人生旅途</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa10913 - Walking on a Grid(DP、DFS)</title>
    <url>/2021/12/26/UVa/UVa10913/</url>
    <content><![CDATA[<h1 id="UVa10913-Walking-on-a-Grid-DP、DFS"><a href="#UVa10913-Walking-on-a-Grid-DP、DFS" class="headerlink" title="UVa10913 - Walking on a Grid(DP、DFS)"></a>UVa10913 - Walking on a Grid(DP、DFS)</h1><h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>有一個 \(n*n\) 的棋盤，你從 (1,1) 出發抵達到 (n,n)，其中棋盤裡面的格子都有不同的權重(有正負數)，請告訴我從 (1,1) 抵達 (n,n) 最大路徑是多少，有一些規則你必須遵守</p>
<ul>
<li>每一個格子只能走一次</li>
<li>只能夠往下、往左、往右行走</li>
<li>給你 k 號數字表示，你最多能夠經過 k 個負數格</li>
</ul>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><p><a href="https://theriseofdavid.github.io/2021/11/09/Explain_Algorithm/Directed_Acyclic_Graph/" target="_blank" rel="noopener">演算法知識 - Directed Acyclic Graph by 大衛的筆記</a></p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ul>
<li>理論上使用 SPFA 來進行搜尋，但是可以向左走、對於行走負數限制，讓 SPFA 相對沒那麼好解</li>
<li>因此我們將 SPFA 進行拆解，原先我們是使用 BFS，但是因為每一個格子只能夠使用用一次，使用 BFS 就無法將路徑延續性儲存下來(不好儲存)，這時候則使用與 BFS 等價的 DFS</li>
<li>搭配 DP 使用，如果 DFS 的節點比當前 DP 大就繼續 DFS，否則就不需要</li>
</ul>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://blog.csdn.net/keshuai19940722/article/details/11954257" target="_blank" rel="noopener">uva 10913 - Walking on a Grid（记忆化）by CSDN</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>最近太久沒有寫演算法，腦袋有點笨阿QQ</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 10000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">80</span>;</span><br><span class="line"><span class="keyword">int</span> dp[N][N][<span class="number">10</span>][<span class="number">5</span>], visit[N][N]; <span class="comment">//dp[x][y][走了幾個負數格子][方向]</span></span><br><span class="line"><span class="keyword">int</span> g[N][N];</span><br><span class="line"><span class="keyword">int</span> direct[<span class="number">3</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;, &#123;<span class="number">1</span>,<span class="number">0</span>&#125;, &#123;<span class="number">0</span>,<span class="number">1</span>&#125;&#125;; <span class="comment">//left, down, right</span></span><br><span class="line"><span class="keyword">int</span> n, qk, ans, kase = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ans = -INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">10</span>; k++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> m = <span class="number">0</span>; m &lt; <span class="number">5</span>; m++)</span><br><span class="line">                    dp[i][j][k][m] = -INF;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(visit, <span class="number">0</span>, <span class="keyword">sizeof</span>(visit));</span><br><span class="line">    <span class="built_in">memset</span>(g, <span class="number">0</span>, <span class="keyword">sizeof</span>(g));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;<span class="comment">//輸入資料</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; g[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> cnt, <span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cnt &gt; qk) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(x == n &amp;&amp; y == n)&#123; <span class="comment">//看是不是最大</span></span><br><span class="line">        ans = max(sum, ans);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mx, my;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">3</span>; k++)&#123; <span class="comment">//針對三個方向不斷遞迴</span></span><br><span class="line">        mx = x + direct[k][<span class="number">0</span>];</span><br><span class="line">        my = y + direct[k][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判斷是否出界，visit[mx][my] 則是要避免節點先往左後往右，導致不斷循環</span></span><br><span class="line">        <span class="comment">//且不同方向、同個節點是不允許被重複使用</span></span><br><span class="line">        <span class="keyword">if</span>(mx &lt;= <span class="number">0</span> || mx &gt; n || my &lt;= <span class="number">0</span> || my &gt; n || visit[mx][my]) <span class="keyword">continue</span>; <span class="comment">//out of boarder</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//此節點以使用當前格子</span></span><br><span class="line">        visit[mx][my] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//如果現在節點權重比 dp 大才有延伸的必要性</span></span><br><span class="line">        <span class="keyword">if</span>(g[mx][my] &gt;= <span class="number">0</span> &amp;&amp; sum + g[mx][my] &gt; dp[mx][my][cnt][k])&#123;</span><br><span class="line">            dp[mx][my][cnt][k] = sum + g[mx][my];</span><br><span class="line"></span><br><span class="line">            <span class="comment">//cout &lt;&lt; "mx my " &lt;&lt; mx &lt;&lt; " " &lt;&lt; my &lt;&lt; " " &lt;&lt; dp[mx][my][cnt][k] &lt;&lt; "\n";</span></span><br><span class="line">            dfs(mx, my, cnt, sum+g[mx][my]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(g[mx][my] &lt; <span class="number">0</span> &amp;&amp; sum + g[mx][my] &gt; dp[mx][my][cnt+<span class="number">1</span>][k])&#123;</span><br><span class="line">            dp[mx][my][cnt+<span class="number">1</span>][k] = sum + g[mx][my];</span><br><span class="line">            dfs(mx, my, cnt+<span class="number">1</span>, sum+g[mx][my]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此節點不再使用當前格子</span></span><br><span class="line">        visit[mx][my] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"out.txt"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; qk &amp;&amp; (n+qk) != <span class="number">0</span>)&#123;</span><br><span class="line">        init();</span><br><span class="line"></span><br><span class="line">        visit[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(g[<span class="number">1</span>][<span class="number">1</span>] &gt;= <span class="number">0</span>) dfs(<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>, g[<span class="number">1</span>][<span class="number">1</span>]); </span><br><span class="line">        <span class="keyword">if</span>(g[<span class="number">1</span>][<span class="number">1</span>] &lt; <span class="number">0</span>) dfs(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>, g[<span class="number">1</span>][<span class="number">1</span>]); <span class="comment">//出發點是負數，則一開始要記錄</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Case "</span> &lt;&lt; kase++ &lt;&lt; <span class="string">": "</span>;</span><br><span class="line">        <span class="keyword">if</span>(ans == -INF) <span class="built_in">cout</span> &lt;&lt; <span class="string">"impossible\n"</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>動態規劃 Dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title>北科電子大三上機器學習 使用 CNN 對 The Simpons 中 50 個人物進行辨識</title>
    <url>/2021/12/26/deep_learning/NTUTece_deeplearning_classification/</url>
    <content><![CDATA[<h1 id="台北科大深度學習-使用-CNN-對-The-Simpons-中-50-個人物進行辨識"><a href="#台北科大深度學習-使用-CNN-對-The-Simpons-中-50-個人物進行辨識" class="headerlink" title="台北科大深度學習 - 使用 CNN 對 The Simpons 中 50 個人物進行辨識"></a>台北科大深度學習 - 使用 CNN 對 The Simpons 中 50 個人物進行辨識</h1><h2 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h2><p>使用 CNN 算法來針對 The Simpons 中的 50 人物進行辨識</p>
<h2 id="將-kaggle-資料進行解壓縮"><a href="#將-kaggle-資料進行解壓縮" class="headerlink" title="將 kaggle 資料進行解壓縮"></a>將 kaggle 資料進行解壓縮</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">!unzip .&#x2F;data&#x2F;machine-learningntut-2021-autumn-classification.zip</span><br></pre></td></tr></table></figure>

<h2 id="將-50-個人物名稱透過-dict-紀錄"><a href="#將-50-個人物名稱透過-dict-紀錄" class="headerlink" title="將 50 個人物名稱透過 dict 紀錄"></a>將 50 個人物名稱透過 dict 紀錄</h2><ul>
<li>先將所有的人物先存在文字檔再透過 py 一個一個進行讀取</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#%cd /content/drive/My Drive/NTUT/大三上-深度學習/Predict_Simposons/ #t108AB0008@ntut.org.tw</span></span><br><span class="line"><span class="comment">#other email</span></span><br><span class="line">%cd /content/drive/.shortcut-targets-by-id/<span class="number">1</span>EmT_yvIKvgl-iNKBU0Wu2XOFjOPsxhyu/大三上-深度學習/Predict_Simposons </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">characters = dict()</span><br><span class="line">characters.clear()</span><br><span class="line">f = open(<span class="string">"characters.txt"</span>, <span class="string">"r"</span>)</span><br><span class="line">cnt = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> f.readlines():</span><br><span class="line">  characters[cnt] = line.strip()</span><br><span class="line">  cnt += <span class="number">1</span></span><br><span class="line">print(characters)</span><br></pre></td></tr></table></figure>

<h2 id="決定圖像大小、訓練集、測試集大小"><a href="#決定圖像大小、訓練集、測試集大小" class="headerlink" title="決定圖像大小、訓練集、測試集大小"></a>決定圖像大小、訓練集、測試集大小</h2><ul>
<li>由於圖像大小會影響深度學習中的模型細節，還有時間，由於使用 colab 進行訓練因此將圖像 size 設定為非常小</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">pic_width = <span class="number">42</span></span><br><span class="line">pic_height = <span class="number">42</span></span><br><span class="line"></span><br><span class="line">num_class = len(characters)</span><br><span class="line">print(num_class)</span><br><span class="line">test_size = <span class="number">0.15</span></span><br></pre></td></tr></table></figure>

<h2 id="讀取所有資料"><a href="#讀取所有資料" class="headerlink" title="讀取所有資料"></a>讀取所有資料</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"><span class="keyword">from</span> google.colab.patches <span class="keyword">import</span> cv2_imshow</span><br><span class="line"></span><br><span class="line"><span class="comment">#imgpath = "/content/drive/My Drive/NTUT/大三上-深度學習/Predict_Simposons/data/theSimpsons-train/train"</span></span><br><span class="line">imgpath = <span class="string">"/content/drive/.shortcut-targets-by-id/1EmT_yvIKvgl-iNKBU0Wu2XOFjOPsxhyu/大三上-深度學習/Predict_Simposons/theSimpsons-train/train"</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_picture</span><span class="params">()</span>:</span></span><br><span class="line">  pics = []</span><br><span class="line">  labels = []</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> k, v <span class="keyword">in</span> characters.items(): <span class="comment"># k 是編號， v 是名稱</span></span><br><span class="line">    origin_pics = [k <span class="keyword">for</span> k <span class="keyword">in</span> glob.glob(imgpath + <span class="string">"/"</span> + v + <span class="string">"/*"</span>)]</span><br><span class="line">    print(v + <span class="string">" : "</span> + str(len(origin_pics)))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i, filename <span class="keyword">in</span> enumerate(origin_pics):</span><br><span class="line">      tmp_img = cv2.imread(filename)</span><br><span class="line">      </span><br><span class="line">      <span class="comment"># opencv 讀圖片時用 BGR，而非 RGB 因此做轉換</span></span><br><span class="line">      tmp_ing = cv2.cvtColor(tmp_img, cv2.COLOR_BGR2RGB)</span><br><span class="line">      tmp_img = cv2.resize(tmp_img, (pic_height, pic_width))</span><br><span class="line">      pics.append(tmp_img)</span><br><span class="line">      labels.append(k)</span><br><span class="line">  <span class="keyword">return</span> np.array(pics), np.array(labels)</span><br><span class="line"></span><br><span class="line"><span class="comment">#load_picture()</span></span><br></pre></td></tr></table></figure>

<h2 id="分割成訓練集、測試集，並透過-h5py-存成資料集"><a href="#分割成訓練集、測試集，並透過-h5py-存成資料集" class="headerlink" title="分割成訓練集、測試集，並透過 h5py 存成資料集"></a>分割成訓練集、測試集，並透過 h5py 存成資料集</h2><p>由於老師是給全部的資料，因此我們就需要進行分割。</p>
<p>那下面這個程式中的參數用意如下</p>
<ul>
<li>save 則是將讀進來的全部資料分成訓練集、測試集，並存取</li>
<li>load 將之前分好的訓練集、測試集讀取</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> keras</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">import</span> h5py</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_dataset</span><span class="params">(save=False, load=False)</span>:</span></span><br><span class="line">  <span class="keyword">if</span> load:</span><br><span class="line">    <span class="comment"># 讀檔</span></span><br><span class="line">    h5f = h5py.File(<span class="string">"train60.h5"</span>, <span class="string">"r"</span>)</span><br><span class="line">    x_train = h5f[<span class="string">"x_train"</span>][:]</span><br><span class="line">    x_test = h5f[<span class="string">"x_test"</span>][:]</span><br><span class="line">    h5f.close()</span><br><span class="line"></span><br><span class="line">    h5f = h5py.File(<span class="string">"valid60.h5"</span>, <span class="string">"r"</span>)</span><br><span class="line">    y_train = h5f[<span class="string">"y_train"</span>][:]</span><br><span class="line">    y_test = h5f[<span class="string">"y_test"</span>][:]</span><br><span class="line">    h5f.close()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="comment">#從最原始圖像進行處理</span></span><br><span class="line">    x, y= load_picture()</span><br><span class="line">    y = keras.utils.np_utils.to_categorical(y, num_class) <span class="comment">#將分類轉換成 numpy  https://blog.csdn.net/moyu123456789/article/details/83444140</span></span><br><span class="line">    x_train, x_test, y_train, y_test = train_test_split(x, y, test_size = test_size)</span><br><span class="line">    <span class="keyword">if</span> save: <span class="comment">#將資料集、測試集存到 google drive</span></span><br><span class="line">      h5f = h5py.File(<span class="string">"train60.h5"</span>, <span class="string">"w"</span>)</span><br><span class="line">      h5f.create_dataset(<span class="string">"x_train"</span>, data=x_train)</span><br><span class="line">      h5f.create_dataset(<span class="string">"x_test"</span>, data=x_test)</span><br><span class="line">      h5f.close()</span><br><span class="line"></span><br><span class="line">      h5f = h5py.File(<span class="string">"valid60.h5"</span>, <span class="string">"w"</span>)</span><br><span class="line">      h5f.create_dataset(<span class="string">"y_train"</span>, data=y_train)</span><br><span class="line">      h5f.create_dataset(<span class="string">"y_test"</span>, data=y_test)</span><br><span class="line">      h5f.close()</span><br><span class="line"></span><br><span class="line">  <span class="comment">#資料歸一化處理</span></span><br><span class="line">  x_train = x_train.astype(<span class="string">"float32"</span>) /<span class="number">255</span></span><br><span class="line">  x_test = x_test.astype(<span class="string">"float32"</span>) /<span class="number">255</span></span><br><span class="line">  print(<span class="string">"Train"</span>, x_train.shape, y_train.shape)</span><br><span class="line">  print(<span class="string">"valid"</span>, x_test.shape, y_test.shape)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> x_train, x_test, y_train, y_test                    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">x_train, x_test, y_train, y_test = get_dataset(save = <span class="literal">True</span>, load = <span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>完成示意圖<br><img src="https://drive.google.com/u/2/uc?id=1cRqR0-Yx91MX0V6EySePA7BQODEaAVVQ&export=download" alt=""></p>
</blockquote>
<h2 id="增強訓練習的資料"><a href="#增強訓練習的資料" class="headerlink" title="增強訓練習的資料"></a>增強訓練習的資料</h2><p>如果覺得自己的訓練集資料不夠多時，可以考慮透過 <code>from keras.preprocessing.image import ImageDataGenerator</code> 透過圖像偏移、角度轉換的方式來補充訓練集資料，加強模型</p>
<p>但我在這邊沒有加入，因為我認為訓練集資料已經足夠</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> keras.preprocessing.image <span class="keyword">import</span> ImageDataGenerator</span><br><span class="line">datagen = ImageDataGenerator(</span><br><span class="line">    shear_range = <span class="number">0.2</span>,</span><br><span class="line">    zoom_range = <span class="number">0.2</span>,</span><br><span class="line">  horizontal_flip = <span class="literal">True</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="模型設定"><a href="#模型設定" class="headerlink" title="模型設定"></a>模型設定</h2><p>Sequential 是在機器學習中最簡單、也最好用的模型，且在大部分的機器學習中她都可以應用（但她不一定是最好的），因此我在這邊就使用 Sequential 來做出簡單的 CNN 模型</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> keras.layers.convolutional_recurrent <span class="keyword">import</span> ConvLSTM2D</span><br><span class="line"><span class="keyword">import</span> tensorflow.keras.optimizers</span><br><span class="line"><span class="keyword">import</span> keras</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span> Sequential</span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Dense, Dropout, Activation, Flatten, BatchNormalization, MaxPool2D </span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Conv2D, MaxPooling2D</span><br><span class="line"><span class="keyword">from</span> keras.applications.resnet <span class="keyword">import</span> ResNet50</span><br><span class="line"><span class="keyword">from</span> keras.applications.vgg16 <span class="keyword">import</span> VGG16</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createModel2</span><span class="params">()</span>:</span></span><br><span class="line">  input_shape = (pic_height, pic_width, <span class="number">3</span>)</span><br><span class="line">  model = Sequential()</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 由於我們是圖像，加入 Convolution Layer 必須用 "2D"，</span></span><br><span class="line">  <span class="comment"># kernel_size 用 (3,3) 則是因為我圖像已經相對小了，因此要對細節好好處理</span></span><br><span class="line">  <span class="comment"># padding 對超出邊界的視窗直接補 0 即可</span></span><br><span class="line">  model.add(Conv2D(<span class="number">32</span>, kernel_size = (<span class="number">3</span>,<span class="number">3</span>), padding = <span class="string">"Same"</span>,</span><br><span class="line">            activation=<span class="string">"relu"</span>, input_shape = input_shape))</span><br><span class="line">  model.add(Conv2D(<span class="number">32</span>, kernel_size=(<span class="number">3</span>,<span class="number">3</span>), padding = <span class="string">"Same"</span>, activation=<span class="string">"relu"</span>))</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 在一般情況下 pool_size 設定成 2 就有不錯效果</span></span><br><span class="line">  model.add(MaxPool2D(pool_size=(<span class="number">2</span>,<span class="number">2</span>)))</span><br><span class="line">  model.add(BatchNormalization())</span><br><span class="line">  model.add(Conv2D(<span class="number">64</span>, kernel_size=(<span class="number">3</span>,<span class="number">3</span>), padding=<span class="string">"Same"</span>, activation=<span class="string">"relu"</span>))</span><br><span class="line">  model.add(Conv2D(<span class="number">64</span>, kernel_size=(<span class="number">3</span>,<span class="number">3</span>), padding=<span class="string">"Same"</span>, activation=<span class="string">"relu"</span>))</span><br><span class="line">  model.add(MaxPool2D(pool_size=(<span class="number">2</span>,<span class="number">2</span>)))</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 將前面每一層的 layer 的 feature 都做 Normalization，確保不會讓前面的 layer 權重太大，</span></span><br><span class="line">  <span class="comment"># 由於每一層 layer 都會影響到下一層，因此會容易讓前面一層的 layer 影響被放大，就有可能 overfitting </span></span><br><span class="line">  <span class="comment">#可以參考 [ML筆記] Batch Normalization by 陳雲濤的部落格</span></span><br><span class="line">  model.add(BatchNormalization())</span><br><span class="line">  model.add(Conv2D(<span class="number">86</span>, kernel_size = (<span class="number">3</span>,<span class="number">3</span>), padding = <span class="string">"Same"</span>, activation=<span class="string">"relu"</span>))</span><br><span class="line">  model.add(Conv2D(<span class="number">86</span>, kernel_size=(<span class="number">3</span>,<span class="number">3</span>), padding = <span class="string">"Same"</span>, activation=<span class="string">"relu"</span>))</span><br><span class="line">  model.add(MaxPool2D(pool_size=(<span class="number">2</span>,<span class="number">2</span>)))</span><br><span class="line">  model.add(BatchNormalization())</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 將多維的輸入轉化成一維</span></span><br><span class="line">  model.add(Flatten())</span><br><span class="line">  <span class="comment"># 將資料變成 1024 個特徵</span></span><br><span class="line">  model.add(Dense(<span class="number">1024</span>, activation=<span class="string">"relu"</span>))</span><br><span class="line">  model.add(Dense(<span class="number">512</span>, activation=<span class="string">"relu"</span>))</span><br><span class="line">  </span><br><span class="line">  <span class="comment"># 由於我們最後辨識 50 個腳色，因此大小就是 50</span></span><br><span class="line">  model.add(Dense(<span class="number">50</span>, activation=<span class="string">"softmax"</span>)) <span class="comment">#因為我們資料是機率，所以用 softmax，可以顯現出 50 個 character 機率</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">#define the optimizer</span></span><br><span class="line">  optimizer = <span class="string">"Adam"</span></span><br><span class="line">  model.compile(optimizer=optimizer, loss=<span class="string">"categorical_crossentropy"</span>, metrics=[<span class="string">"accuracy"</span>])</span><br><span class="line">  <span class="keyword">return</span> model</span><br></pre></td></tr></table></figure>

<h2 id="開始執行-model"><a href="#開始執行-model" class="headerlink" title="開始執行 model"></a>開始執行 model</h2><p>這邊就開始執行 model</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> keras.callbacks <span class="keyword">import</span> ModelCheckpoint, LearningRateScheduler, EarlyStopping</span><br><span class="line"></span><br><span class="line">model = createModel2()</span><br><span class="line">model.summary()</span><br><span class="line"></span><br><span class="line">lr = <span class="number">0.001</span></span><br><span class="line"></span><br><span class="line">batch_size = <span class="number">32</span></span><br><span class="line">epoch = <span class="number">50</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lr_schedule</span><span class="params">(epoch)</span>:</span></span><br><span class="line">  <span class="keyword">return</span> lr*(<span class="number">0.1</span>**(int(epoch/<span class="number">10</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 會將最好的 model 儲存，並且如果 epoch 沒有更好時，就會讓此 model 暫停</span></span><br><span class="line">history = model.fit(x_train, y_train,</span><br><span class="line">                    batch_size = batch_size,</span><br><span class="line">                    epochs = epoch,</span><br><span class="line">                    validation_data = (x_test, y_test),</span><br><span class="line">                    shuffle = <span class="literal">True</span>,</span><br><span class="line">                    callbacks=[LearningRateScheduler(lr_schedule), </span><br><span class="line">                               ModelCheckpoint(<span class="string">"model2.h5"</span>, save_best_only=<span class="literal">True</span>, period=<span class="number">10</span>),</span><br><span class="line">                               EarlyStopping(monitor=<span class="string">"val_accuracy"</span>, patience=<span class="number">3</span>, mode= <span class="string">"auto"</span>)])</span><br></pre></td></tr></table></figure>

<blockquote>
<p>執行畫面<br><img src="https://drive.google.com/u/2/uc?id=11UKudkD2brtfha8DFC4PsTGSw4uxZRBl&export=download" alt=""></p>
</blockquote>
<h2 id="對準確率、還有錯誤率進行畫圖"><a href="#對準確率、還有錯誤率進行畫圖" class="headerlink" title="對準確率、還有錯誤率進行畫圖"></a>對準確率、還有錯誤率進行畫圖</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_train_history</span><span class="params">(history, train_metrics, val_metrics)</span>:</span></span><br><span class="line">  plt.plot(history.history.get(train_metrics), <span class="string">'-o'</span>)</span><br><span class="line">  plt.plot(history.history.get(val_metrics, <span class="string">'-o'</span>))</span><br><span class="line">  plt.ylabel(train_metrics)</span><br><span class="line">  plt.xlabel(<span class="string">"epoch"</span>)</span><br><span class="line">  plt.legend([<span class="string">"train"</span>, <span class="string">"validation"</span>])</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">12</span>,<span class="number">4</span>))</span><br><span class="line">plt.subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">plot_train_history(history, <span class="string">"loss"</span>, <span class="string">"val_loss"</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">plot_train_history(history, <span class="string">"accuracy"</span>, <span class="string">"val_accuracy"</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<h2 id="驗證辨識結果"><a href="#驗證辨識結果" class="headerlink" title="驗證辨識結果"></a>驗證辨識結果</h2><p>如果送上去 kaggle 之前可以先看看，模型對每一個角色的辨識率。<br>對結果大概有個譜XD</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sklearn</span><br><span class="line">predict = model.predict(x_test)</span><br><span class="line">predict = np.argmax(predict, axis=<span class="number">1</span>)</span><br><span class="line">ans = np.argmax(y_test, axis = <span class="number">1</span>)</span><br><span class="line">print(<span class="string">"\n"</span>, sklearn.metrics.classification_report(ans, predict, target_names=list(characters.values())), sep=<span class="string">''</span>)</span><br></pre></td></tr></table></figure>

<h2 id="對老師給的測試集進行辨識"><a href="#對老師給的測試集進行辨識" class="headerlink" title="對老師給的測試集進行辨識"></a>對老師給的測試集進行辨識</h2><ul>
<li>將測試資料讀入，並呼教我們的 model 來進行辨識</li>
<li>要注意的是，我們 model 設定最後一層是呼叫機率，但是老師希望我們輸出最大的機率角色即可，因此就找第一項即可</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span> load_model</span><br><span class="line"><span class="keyword">from</span> google.colab.patches <span class="keyword">import</span> cv2_imshow</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_images</span><span class="params">(path)</span>:</span></span><br><span class="line">  images=[]</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10791</span>):</span><br><span class="line">  <span class="comment">#for i in range(3):</span></span><br><span class="line">    print(path+str(i+<span class="number">1</span>)+<span class="string">'.jpg'</span>)</span><br><span class="line">    image = cv2.resize(cv2.imread(path+str(i+<span class="number">1</span>)+<span class="string">'.jpg'</span>), (pic_height, pic_width))</span><br><span class="line">    <span class="comment">#image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)</span></span><br><span class="line">    <span class="comment">#cv2_imshow(image)</span></span><br><span class="line">    images.append(image)</span><br><span class="line">  images = np.array(images, dtype=np.float32) / <span class="number">255</span></span><br><span class="line">  <span class="keyword">return</span> images</span><br><span class="line"></span><br><span class="line">model = load_model(<span class="string">"model2.h5"</span>)</span><br><span class="line"><span class="comment">#imgpath = "/content/drive/My Drive/NTUT/大三上-深度學習/Predict_Simposons/theSimpsons-test/test/" #t108AB0008@ntut.org.tw</span></span><br><span class="line">imgpath = <span class="string">"/content/drive/.shortcut-targets-by-id/1EmT_yvIKvgl-iNKBU0Wu2XOFjOPsxhyu/大三上-深度學習/Predict_Simposons/theSimpsons-test/test/"</span> <span class="comment">#others</span></span><br><span class="line"></span><br><span class="line">test_images = read_images(imgpath)</span><br><span class="line">print(test_images.shape)</span><br><span class="line">predict = model.predict(test_images)</span><br><span class="line">predict = np.argmax(predict, axis=<span class="number">1</span>) <span class="comment">#找第一個機率最大的</span></span><br><span class="line">print(characters[int(predict[<span class="number">2</span>])])</span><br></pre></td></tr></table></figure>

<h2 id="將辨識結果輸出-csv"><a href="#將辨識結果輸出-csv" class="headerlink" title="將辨識結果輸出 csv"></a>將辨識結果輸出 csv</h2><p>再來就從 google drive 下載 csv 然後上傳 kaggle</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">"predict2.csv"</span>, <span class="string">"w"</span>) <span class="keyword">as</span> f:</span><br><span class="line">  f.write(<span class="string">"id,character\n"</span>)</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(len(predict)):</span><br><span class="line">    text = str(i+<span class="number">1</span>) + <span class="string">","</span> + characters[int(predict[i])] + <span class="string">"\n"</span></span><br><span class="line">    f.write(text)</span><br></pre></td></tr></table></figure>
<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1207sKmU2LVju89YnRQvxAr9fePu7wVHm&export=download" alt=""></p>
</blockquote>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><strong>北科電子系機器學習教授廖元甫老師的學生教學，教得非常好</strong><br><a href="https://ithelp.ithome.com.tw/articles/10192028" target="_blank" rel="noopener">Day 08：CNN 模型設計 by I code so I am</a><br><a href="http://violin-tao.blogspot.com/2018/02/ml-batch-normalization.html" target="_blank" rel="noopener">[ML筆記] Batch Normalization by 陳雲濤的部落格</a></p>
]]></content>
      <categories>
        <category>北科上課筆記</category>
        <category>機器學習</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>機器學習</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa12875 - Concert Tour(DP、DAG)</title>
    <url>/2022/01/05/UVa/UVa12875/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>有一位歌手要舉辦演唱會，在各縣市中的百貨公司進行演唱，來吸引更多的顧客消費，給你 c 天、有許多個百貨公司必須要去，給你在每一天每一個百貨公司演唱預期帶來的利益，以及每一個百貨公司到另一個百貨公司的成本，請告訴我最大化利益為多少<br><a href="https://onlinejudge.org/external/128/12875.pdf" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><p><a href="https://theriseofdavid.github.io/2021/11/09/Explain_Algorithm/Directed_Acyclic_Graph/" target="_blank" rel="noopener">演算法知識 - Directed Acyclic Graph by 大衛的筆記</a></p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ul>
<li>根據重點觀念，因為可以有多個起點，因此使用 DP</li>
<li>因此使用三迴圈，從第幾天開始，再從 a 到 b 點，轉移方程式為 <code>dp[第i+1天][抵達 k 百貨公司], dp[第 i 天][抵達 j 百貨公司] + profit[第 k 天][在 i+1 百貨公司] - cost[從 j 百貨公司][到 k 百貨公司]</code></li>
</ul>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://morris821028.github.io/2014/12/30/uva-12875/" target="_blank" rel="noopener">UVa 12875 - Concert Tour by morris</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>好久沒寫 DAG，都有點忘記要怎麼寫了QQ。<br>一開始還想把它寫成 DFS</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 200</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> t, s, c;</span><br><span class="line"><span class="keyword">int</span> dp[MAXN][MAXN], cost[MAXN][MAXN], profit[MAXN][MAXN]; <span class="comment">//dp, cost 百貨公司移動成本, 百貨公司演唱利益</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s &gt;&gt; c;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= c; j++)&#123;</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; profit[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= s; j++)&#123;</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; cost[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; c; i++)&#123; <span class="comment">//第幾天</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= s; j++)&#123; <span class="comment">//從 j 百貨公司</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= s; k++)&#123; <span class="comment">//到 k 百貨公司</span></span><br><span class="line">                    dp[i+<span class="number">1</span>][k] = max(dp[i+<span class="number">1</span>][k], dp[i][j] + profit[k][i+<span class="number">1</span>] - cost[j][k]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s; i++)&#123; <span class="comment">//尋找最大利益</span></span><br><span class="line">            ans = max(ans, dp[c][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>動態規劃 Dynamic programming</tag>
      </tags>
  </entry>
</search>
