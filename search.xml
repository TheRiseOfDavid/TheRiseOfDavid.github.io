<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>惠特科技產學合作</title>
    <url>/2020/05/05/computer_image_teach/</url>
    <content><![CDATA[<h2 id="主要"><a href="#主要" class="headerlink" title="主要"></a>主要</h2><p>此網頁主要是在幫助大衛在 惠特科技專案一 期間中所遇到的 圖像演算法 問題。</p>
<p>並非教學用，但學習資源會在這並透過我加以整理。</p>
<ol>
<li>Laplace <ul>
<li><a href="https://blog.csdn.net/fengbingchun/article/details/79321200" target="_blank" rel="noopener">图像边缘检测之拉普拉斯(Laplacian)C++实现</a></li>
<li><a href="https://blog.csdn.net/qq_38131594/article/details/80776367" target="_blank" rel="noopener">拉普拉斯边缘检测</a></li>
<li><a href="https://blog.csdn.net/u013580497/article/details/46822121" target="_blank" rel="noopener">【数字图像处理之三】拉普拉斯边缘检测算法</a> </li>
<li><a href="https://medium.com/@sourabhjigjinni/install-opencv-4-0-0-for-c-windows-7-10-code-blocks-tdm-gcc-64-dff65addf162" target="_blank" rel="noopener">Install OpenCV 4.1.0 for C++, Windows 7/10, Code::Blocks</a></li>
<li><a href="https://stackoverflow.com/questions/38834729/cmake-libintl-8-dll-is-missing-from-your-computer/56814576?fbclid=IwAR1nQoYHNKFja-ZoX-QtfzP27IC5DVMTIDtQfW-TnBf3qi3mtPF2gSxBfIg" target="_blank" rel="noopener">CMAKE libintl-8.dll is missing from your computer</a></li>
<li><a href="https://debbiedbaby.pixnet.net/blog/post/426657881" target="_blank" rel="noopener">【c#】 emgucv 設定</a></li>
<li><a href="https://dotblogs.com.tw/april_notes/2019/05/14/cinque" target="_blank" rel="noopener">EMGU 與 Visual studio 的裝設方法 (範例為 x64 / Release )</a></li>
<li><a href="https://dotblogs.com.tw/v6610688/2013/12/25/emgucv_cvinvoke_typeinitailization_exception?fbclid=IwAR1f5XwXNiYp_CEC76fbU5y1NgStfWvcYIlzY-GFJatk_2DIKteiLWdxwFs" target="_blank" rel="noopener">[EmguCV]CvInvoke的型別初始化設定發生例外 (CvInvoke TypeInitialization Exception) 處理</a></li>
<li><a href="https://me1237guy.pixnet.net/blog/post/61614517" target="_blank" rel="noopener">Emgu CV: 基礎影像容器Mat</a></li>
<li><a href="http://dangerlover9403.pixnet.net/blog/post/213895974?fbclid=IwAR24_9mIqb5VJyXx2EAVd9fq2wcx1WpJW78pm1IdShUxSEQrSPhcagdphRo" target="_blank" rel="noopener">[教學]C# EmguCV教學-圖像輪廓處理方式-拉普拉斯(Laplace)</a></li>
<li><a href="http://dangerlover9403.pixnet.net/blog/post/213568605-%5B%E6%95%99%E5%AD%B8%5Dc%23-emgucv---%E5%BB%BA%E7%BD%AE%E7%92%B0%E5%A2%83" target="_blank" rel="noopener">[教學]C# EmguCV - 建置環境</a></li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>學習筆記</category>
      </categories>
      <tags>
        <tag>產學合作</tag>
      </tags>
  </entry>
  <entry>
    <title>PS 快速將底層顏色替換</title>
    <url>/2020/07/17/PS-replace-color/</url>
    <content><![CDATA[<blockquote>
<p>此文章記錄快速在 PS 將底層顏色替換方法 </p>
</blockquote>
<a id="more"></a>

<h2 id="問題描述"><a href="#問題描述" class="headerlink" title="問題描述"></a>問題描述</h2><p>這張圖片沒有圖層讓我去修改背景顏色！，那這時候我要怎麼做才能快速修改呢?</p>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>使用 PS 功能中的<strong>取代顏色</strong></p>
<p>步驟如下(粗體字代表為需要點擊)：</p>
<ol>
<li><strong>影像</strong></li>
<li><strong>調整</strong></li>
<li><strong>取代顏色</strong></li>
<li>接下來你一定會做！</li>
</ol>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>PhotoShop 是我最喜歡也是最擅長的編輯圖片軟體了，它的功能到現在我都還沒完全摸會，希望我能夠好好學會他、精熟他!</p>
]]></content>
      <categories>
        <category>學習筆記</category>
      </categories>
      <tags>
        <tag>PhotoShop</tag>
      </tags>
  </entry>
  <entry>
    <title>甚麼是 RESTAPI ?</title>
    <url>/2020/07/23/API/</url>
    <content><![CDATA[<h2 id="內容說明"><a href="#內容說明" class="headerlink" title="內容說明"></a>內容說明</h2><blockquote>
<p>此文章講述於 RESTAPI 的大概使用方法與使用時機，並沒有詳細解釋，詳細解釋還需讀閱他人優秀文章</p>
</blockquote>
<a id="more"></a>

<h2 id="甚麼是-API"><a href="#甚麼是-API" class="headerlink" title="甚麼是 API?"></a>甚麼是 API?</h2><p>就是別人把資料給你，你再把那些資料處理成資訊後再給別人，然後是透過 url 來進行交換的入口</p>
<h2 id="API-Method"><a href="#API-Method" class="headerlink" title="API Method"></a>API Method</h2><ul>
<li>POST：新增</li>
<li>GET：讀取</li>
<li>PUT：修改（修改整份文件）</li>
<li>PATCH：修改（修改其中幾個欄位）</li>
<li>DELETE：刪除</li>
</ul>
<h2 id="API-回傳資料"><a href="#API-回傳資料" class="headerlink" title="API 回傳資料"></a>API 回傳資料</h2><table>
<thead>
<tr>
<th>狀態</th>
<th>英文</th>
<th>中文</th>
<th>說明</th>
</tr>
</thead>
<tbody><tr>
<td>200</td>
<td>OK</td>
<td>完成</td>
<td>通常在 get 時使用</td>
</tr>
<tr>
<td>201</td>
<td>Created</td>
<td>資源新增成功</td>
<td>通常在 post 時使用</td>
</tr>
<tr>
<td>202</td>
<td>Accepted</td>
<td>請求接受，但在處理中</td>
<td>有可能會失敗</td>
</tr>
<tr>
<td>204</td>
<td>No Content</td>
<td>請求成功，但沒有返回內容</td>
<td>通常用在刪除或修改</td>
</tr>
<tr>
<td>400</td>
<td>Bad Request</td>
<td>錯誤請求</td>
<td>通常有欄位未填寫或填寫錯誤</td>
</tr>
<tr>
<td>401</td>
<td>Unauthorized</td>
<td>使用者沒有進行驗證</td>
<td></td>
</tr>
<tr>
<td>403</td>
<td>Forbidden</td>
<td>使用者已經登入，但沒有權限操作</td>
<td></td>
</tr>
<tr>
<td>410</td>
<td>Gone</td>
<td>資源已經過期</td>
<td></td>
</tr>
<tr>
<td>500</td>
<td>Internal Server Error</td>
<td>伺服器端錯誤</td>
<td></td>
</tr>
<tr>
<td>502</td>
<td>Bad Gateway</td>
<td>伺服器某個服務沒有被正確執行</td>
<td></td>
</tr>
<tr>
<td>503</td>
<td>Service Unavailable</td>
<td>伺服器臨時維護或即將死亡，暫時無法處理請求</td>
<td></td>
</tr>
<tr>
<td>504</td>
<td>Gateway Timeout</td>
<td>伺服器上服務回應</td>
<td></td>
</tr>
</tbody></table>
<h2 id="觀念釐清："><a href="#觀念釐清：" class="headerlink" title="觀念釐清："></a>觀念釐清：</h2><h3 id="POST-跟-GET-主要差在哪裡呢？"><a href="#POST-跟-GET-主要差在哪裡呢？" class="headerlink" title="POST 跟 GET 主要差在哪裡呢？"></a>POST 跟 GET 主要差在哪裡呢？</h3><p>根據我的經驗(對不起我經驗連一年都沒有滿 QQ)，我盡可能來進行解釋。</p>
<h4 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h4><ul>
<li>比較像是明信片，只能傳送簡單資訊。</li>
<li>通常會將你傳送的資訊放在 url 之後。</li>
<li>沒有 body，畢竟明信片也沒有 Body XD。</li>
<li>如果有壞蛋想要看你寫甚麼，只要抓到你傳送的 url 就好，安全性較低。<h4 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h4></li>
<li>比較像是信封，可以傳送複雜資訊。</li>
<li>通常是將你 post 的資訊放入 body 內。</li>
<li>比起 get 有保障些，你傳送的資訊較沒有那麼容易就能被他人得知。</li>
</ul>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結:"></a>參考連結:</h2><p><a href="https://medium.com/%E5%B0%8F%E5%B0%8F%E8%AA%AA%E6%9B%B8%E4%BA%BA/%E7%B6%B2%E9%A0%81get-%E8%88%87-post-%E5%B7%AE%E7%95%B0-%E7%A7%91%E6%99%AE%E5%A3%B9%E9%BB%9E%E9%80%9A-94cbaa666fdb" target="_blank" rel="noopener">網頁Get 與 Post 差異 (科普壹點通)</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>API 其實蠻好用，只是有點偏複雜。還需要多加磨練，我也要能夠讓自己變得更優秀，也謝謝各位前輩的努力。<br>也謝謝 台灣STEAM基礎教育聯盟給予我機會使我成長，對不起我有時候速度拖太慢。</p>
]]></content>
      <categories>
        <category>學習筆記</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>RESTAPI</tag>
      </tags>
  </entry>
  <entry>
    <title>透過 ngrok 來讓自己的電腦成為 server</title>
    <url>/2020/07/24/ngrok-experience/</url>
    <content><![CDATA[<h2 id="內容說明"><a href="#內容說明" class="headerlink" title="內容說明"></a>內容說明</h2><blockquote>
<p>如何讓自己的電腦變成 server，來方便自己測試或架設!<br>使用 ngrok 就對搂~</p>
</blockquote>
<a id="more"></a>

<h2 id="安裝教學"><a href="#安裝教學" class="headerlink" title="安裝教學"></a>安裝教學</h2><p>先去官網 <a href="https://ngrok.com/download" target="_blank" rel="noopener">下載ngrok</a>，安裝完成後將 exe，拉出來並執行。<br>接下來去官網登入，沒有就註冊。</p>
<p>註冊後有此詳細教學，跟隨教學即可。</p>
<p>在這邊提供我的頁面，方便使用者確認並且沒有走錯</p>
<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=19O15rqQ0fGcl-zDrfW9GWb6dTLMTzweK&export=download" alt=""></p>
</blockquote>
<p>記住 authtoken 一定要正確喔。</p>
<h2 id="使用教學"><a href="#使用教學" class="headerlink" title="使用教學"></a>使用教學</h2><p>這官網都教你且教導的一定比我還好，就交給官網。</p>
<p>之後打 terminal 先找到 ngrok，然後呼叫他並且在後面打上<code>協定+端口</code>，就可以成為伺服器了！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;ngrok http y</span><br></pre></td></tr></table></figure>

<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>真的要謝謝各位科技前輩讓我學會這些事物，也要謝謝基礎教育聯盟讓我有機會學習新事物，真的很謝謝陪我的各位！</p>
]]></content>
      <categories>
        <category>學習筆記</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>ngrok</tag>
        <tag>server</tag>
      </tags>
  </entry>
  <entry>
    <title>ProblemK Assigning Frequencies (暴力搜尋 Brute force)</title>
    <url>/2020/08/18/ICPC/2017-ICPC-Asia-Taipei-Hualien-Regional-Pk/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>給你一張圖，這圖不會超過 25 個 Node，試問能不能用 3 個顏色塗滿所有點但相鄰的點不能有相同顏色。<br>題目提示: 測資不會超過 85 筆。</p>
</blockquote>
<a id="more"></a>

<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>如果對暴力搜尋法有一定了解的人，應該看到題目就會馬上想到暴力搜尋法了吧！<br>可惜我不是，我用了一個奇怪的想法然後還沒解開…。(有興趣的可以往下滑)</p>
<h3 id="甚麼時機該用暴力搜尋法？"><a href="#甚麼時機該用暴力搜尋法？" class="headerlink" title="甚麼時機該用暴力搜尋法？"></a>甚麼時機該用暴力搜尋法？</h3><ol>
<li>題目有告訴你測資不超過幾筆，但那數字卻不大</li>
<li>圖也不大，相較於其他圖論的題目</li>
<li>明顯看到他的測資基本上不大於 100 or 1000，應題目而定</li>
</ol>
<p>由於是暴力搜尋法，也沒有甚麼好講，但他有一地方神奇就在於遞迴。讓我來稍微解說下:</p>
<h3 id="依序新增一點，然後塗色"><a href="#依序新增一點，然後塗色" class="headerlink" title="依序新增一點，然後塗色"></a>依序新增一點，然後塗色</h3><p>這是我認為最為有趣的地方，也是最困擾我的地方。一開始我認為這遞迴非常好寫，輕輕鬆鬆，開始寫以後才證明我錯了，在這邊呼籲各位不要精神 AC 阿，真的，魔鬼藏在細節裡。</p>
<p>由於他依序新增一點，所以她其實在過程中，並不是完整的圖而是分裂的，但沒關係。不影響我們作答，因為之後連起來時就會發現顏色一樣而再將點更改顏色。如果都不行就可以直接 FALSE。</p>
<p>塗色，你是要幫下一個點選色。這是遞迴裡面最有魅力的地方，明明是 a 的遞迴 time，但卻幫 b 做好顏色選擇。你可能會覺得很奇怪？<br>但你仔細想想，如果不這樣做的話，那你在 a 的遞迴才幫 a 做塗色，那複雜度雖然一樣，但程式碼就非常亂了，因為要考慮你是因為 3 個顏色都不行呢？還是這顏色可以通過。這兩種情況下，你可能還需要一個 flag 之類的東西來判斷，不好看。太醜了。<br>但這點我也是觀看別人程式碼，我才懂得。寫這份文件的人果真大神。</p>
<h3 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h3><p>我在解這題時，是閱讀觀看這位<a href="https://www.twblogs.net/a/5b8ee83f2b7177188348a611" target="_blank" rel="noopener">大神</a>才得以解出的，謝謝他。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 30</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> path[MAXN][MAXN] = &#123;&#125; ;</span><br><span class="line"><span class="keyword">int</span> node[MAXN] = &#123;&#125; ;</span><br><span class="line"><span class="keyword">int</span> n , p , N ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; v ; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(path[v][i] &amp;&amp; node[v] == node[i])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n == v<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; <span class="number">3</span> ; j++)&#123;</span><br><span class="line">        node[v+<span class="number">1</span>] = j ;</span><br><span class="line">        <span class="keyword">if</span>(DFS(v+<span class="number">1</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span> ;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">int</span> _i , _j ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N ;</span><br><span class="line">    <span class="keyword">while</span>(N--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; p ;</span><br><span class="line">        <span class="comment">//clear</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; n ; j++)</span><br><span class="line">                path[i][j] = <span class="number">0</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; p ; i++ )&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; _i &gt;&gt; _j ;</span><br><span class="line">            path[_i][_j] = <span class="number">1</span> ;</span><br><span class="line">            path[_j][_i] = <span class="number">1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(DFS(<span class="number">0</span>))</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Y"</span> ;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"N"</span> ;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="我再看到此題的想法"><a href="#我再看到此題的想法" class="headerlink" title="我再看到此題的想法:"></a>我再看到此題的想法:</h2><p>這裡是廢文。如果不想要了解我的想法可以直接略過，因為我的想法是錯誤的。但如果想看看我的思考邏輯就建議看看。</p>
<p>我一開始看到這題目時，就想到簡單 2 顏色塗色問題，想說直接用 BFS，搞定！但絕對沒有那麼簡單啊 XD，於是我就想出一方法關於我要怎麼解出這題目。<br>怎麼做呢，用有點類似於 DP 的方式，開一 struct，裡面放入一陣列代表有 3 顏色，只要他相鄰的點有被用過的顏色，那此點就不能用這顏色，只要附近的點都將 3 種顏色都用過就輸出 N，是不是覺得我的想法還不賴！當初的我也覺得我的想法很不錯，所以就用了這方式。</p>
<p>寫出來後，丟去 judge，卻發現是錯的！可是錯在哪裡我不知道…，非常討厭。於是我就去問了我的朋友們，但我的朋友們似乎也不太清楚，於是就問了奧林匹亞銅牌國手，他說出了一句令我震驚的話。<br><img src="./images/2017-ICPC-Asia-Taipei-Hualien-Regional-Pk/1.jpg" alt=""></p>
<p>原來剛剛的我試圖在嘗試不可能的任務阿，怕。差點我就能把 3 塗色問題的演算法名稱掛上大衛了www，沒，開玩笑的。於是我就也放棄了此題，使用暴力搜尋法 ಥ⌣ಥ。</p>
<p>下面是我寫的程式碼(我的想法)，有興趣的可以拿去研究看看www。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path[<span class="number">30</span>] ;</span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; nodes ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N , n , p  ;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> color[<span class="number">3</span>] = &#123;&#125; ;</span><br><span class="line">    <span class="keyword">int</span> use = <span class="number">0</span> ;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">        color[<span class="number">0</span>] = <span class="number">0</span> ;</span><br><span class="line">        color[<span class="number">1</span>] = <span class="number">0</span> ;</span><br><span class="line">        color[<span class="number">2</span>] = <span class="number">0</span> ;</span><br><span class="line">        use = <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;node[<span class="number">30</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">choose</span><span class="params">(<span class="keyword">int</span> i , <span class="keyword">int</span> k )</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; path[i].<span class="built_in">size</span>() ; j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!node[path[i][j]].use)&#123;</span><br><span class="line">            nodes.push_back(path[i][j]);</span><br><span class="line">            node[path[i][j]].use = <span class="number">1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(node[path[i][j]].color[k])</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> i )</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span> ; k &lt; <span class="number">3</span> ; k++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(node[i].color[k])</span><br><span class="line">            <span class="keyword">continue</span> ;</span><br><span class="line">        <span class="keyword">if</span>(choose(i,k))&#123;</span><br><span class="line">            node[i].color[k] = <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BFS</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//node[0].color[0] = 1 ;</span></span><br><span class="line">    nodes.push_back(<span class="number">0</span>) ;</span><br><span class="line">    node[<span class="number">0</span>].use = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span>(nodes.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">if</span>(!check(nodes.front()))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">        nodes.pop_front();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">int</span> i , j ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N ;</span><br><span class="line">    <span class="keyword">while</span>(N--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; p ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//clear</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i++)&#123;</span><br><span class="line">            path[i].<span class="built_in">clear</span>() ;</span><br><span class="line">            node[i].<span class="built_in">clear</span>() ;</span><br><span class="line">        &#125;</span><br><span class="line">        nodes.<span class="built_in">clear</span>() ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//bulid</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span> ; k &lt; p ; k++)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; i &gt;&gt; j ;</span><br><span class="line">            path[i].push_back(j) ;</span><br><span class="line">            path[j].push_back(i) ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(BFS())</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Y"</span> ;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"N"</span> ;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*//debug</span></span><br><span class="line"><span class="comment">        for(int i = 0 ; i &lt; n ; i++)&#123;</span></span><br><span class="line"><span class="comment">            cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; node[i].color[0] &lt;&lt; ' ' &lt;&lt; node[i].color[1] &lt;&lt; ' ' &lt;&lt; node[i].color[2] &lt;&lt; '\n' ;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ICPC</category>
      </categories>
      <tags>
        <tag>ICPC</tag>
        <tag>程式解題</tag>
        <tag>2017-ICPC-Asia-Taipei-Hualien-Regional</tag>
        <tag>暴力搜尋 Brute force</tag>
      </tags>
  </entry>
  <entry>
    <title>C#_大衛製作套件</title>
    <url>/2020/07/15/C_sharp/Csharp_gauss/</url>
    <content><![CDATA[<blockquote>
<p>此套件為大衞製作，方便未來的我可以直接套用套件。<br>若要使用，在 VS 上加入參考加入 gauss.dll 即可使用</p>
</blockquote>
<a id="more"></a>


<h2 id="C-套件"><a href="#C-套件" class="headerlink" title="C# 套件"></a>C# 套件</h2><p>此套可解決於多元一次方程式組解，快速且有效率解法<br>P.S. 技術僅限到更新日期</p>
<p><a href="https://drive.google.com/file/d/1GB_UtHQ0Ja1pWHgObjNUCXonvex5NknS/view?usp=sharing" target="_blank" rel="noopener">gauss 套件下載</a></p>
<p><strong>必須加入 using guass;</strong></p>
<h3 id="高斯消去法"><a href="#高斯消去法" class="headerlink" title="高斯消去法"></a>高斯消去法</h3><h4 id="宣告物件"><a href="#宣告物件" class="headerlink" title="宣告物件"></a>宣告物件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gauss test &#x3D; new gauss(int n ,doublue[,]  douGauss , double[] ans )</span><br></pre></td></tr></table></figure>

<p>n = 有多少階數<br>douGauss = 所有行係數的陣列<br>ans = 每元的係數</p>
<h4 id="prepare-測試用方法"><a href="#prepare-測試用方法" class="headerlink" title="prepare()  測試用方法"></a>prepare()  測試用方法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gauss.prepare() ;</span><br></pre></td></tr></table></figure>

<p>透過 console.wrire 來輸入 n , douGauss , ans<br>方便使用者加入 gauss 中的變數</p>
<h4 id="elimindation-高斯消元法"><a href="#elimindation-高斯消元法" class="headerlink" title="elimindation() 高斯消元法"></a>elimindation() 高斯消元法</h4><p><a href="https://zh.wikipedia.org/wiki/%E9%AB%98%E6%96%AF%E6%B6%88%E5%8E%BB%E6%B3%95" target="_blank" rel="noopener">高斯消元法</a>說明</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gauss.elimindation() ;</span><br></pre></td></tr></table></figure>

<h4 id="seidel-method-賽德爾疊代-and-SOR-超鬆弛迭代法"><a href="#seidel-method-賽德爾疊代-and-SOR-超鬆弛迭代法" class="headerlink" title="seidel_method() 賽德爾疊代 and SOR 超鬆弛迭代法"></a>seidel_method() 賽德爾疊代 and SOR 超鬆弛迭代法</h4><p><a href="https://www.maa.org/press/periodicals/loci/joma/iterative-methods-for-solving-iaxi-ibi-gauss-seidel-method" target="_blank" rel="noopener">賽德爾疊代</a>說明<br>在 2020/06/08 時將 seidel_method() 優化，現在已經在任何情況下比消元速度還快</p>
<p><a href="http://marta.certik.cz/NM/Asor.pdf" target="_blank" rel="noopener">超鬆弛迭代法</a>說明<br>在 2020/07/15 時由於 SOR 是找 omega 來進行鬆弛(P.S. seidel_method() 為 1)，由於 omega 在每個多元一次方成組解時 omega 量為不固定，要找出對應的 omega 計算十分複雜(且我尚未讀熟，如果有大佬懂可以教我嗎 QQ) ，於是我目前先將 omega 定為 1.1。</p>
<p>Q: 為甚麼 omega 是 1.1?<br>A: 我曾訂過 0.658 , 1.658 發現都不如預期，在大多數情況下多元一次方成組 omega 大多分布在 1.1 ~ 1.3 之間，於是我選擇 1.1，如果大家不喜歡的話可以在裡面帶自訂數值。</p>
<p>Q: it 是甚麼? <del>可以吃嗎</del><br>A: 不行啦， it 是自訂迭代次數，你可以自己設定想迭代幾層，預設 -1 為完美迭代，即答案必求到絕對正確。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gauss.Seidel_method(double omega &#x3D; 1.1 , int it &#x3D; -1);</span><br></pre></td></tr></table></figure>

<h3 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h3><p>在開發　gauss 套件時，其實花了很多時間在 Debug 與 效率優化，由於分手的關係，這真的是非常痛苦的過程阿…。工程師需要讓自己不被情緒給影響真的有些許的困難，我們也要能夠在 coding 過程中注意到女朋友，不可以讓女生感覺到自己已經不在意他，消耗愛的能量，導致愛情與悲劇收場。</p>
<p>然後再鑽寫程式的過程中，我發現出了一個極大的問題。使我的「賽德爾疊代」應該要能夠比「高斯消元法」速度還要快，但因為原先我的「賽德爾疊代」在陣列方式處理不佳，過程中浪費大量效率使我矩陣在 &gt; 500 時速度會比「高斯消元法」過慢。</p>
<p>因為在 seidel_method 中每次都需要 k+1 的迭代，於是原先我的程式寫法是準備一個巨大的迭代陣列，但我發現 二維陣列 當索引值太大時，查找速度會過慢，在大量迭代之下就會將此問題放大。於是後來將迭代陣列弄成 二維，類似於 array[2][n] (因為每次迭代只需要 k+1 , k )，相對來說查找速度就快很多。在 500*500的陣列中，原先使用 seidel_method 未優化需使用 578s，優化後只需要 2s，二維陣列查找速度。</p>
<h2 id="更新日誌"><a href="#更新日誌" class="headerlink" title="更新日誌"></a>更新日誌</h2><p>2020-05-18 14:30:21 - 完成 gauss 套件、 高斯消元法<br>2020-05-30 20:34:28 - 完成 seidel_method<br>2020-06-08 15:58:42 - 完成 seidel_method 優化<br>2020-07-15 00:23:42 - 將 Successive Over Relaxation 的 omega 鎖定為 1.1</p>
]]></content>
      <categories>
        <category>C_sharp</category>
      </categories>
      <tags>
        <tag>套件說明</tag>
        <tag>C_sharp</tag>
      </tags>
  </entry>
  <entry>
    <title>ProblemB Binary Tree (水題)</title>
    <url>/2020/06/15/ICPC/2019-2020-ICPC-Asia-Hong-Kong-Regional-Contest-Pb/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>給 ALICE and BOB 一個遊戲，這個遊戲是他們要不斷刪除樹的節點，但有規定，刪除的節點必定是完整二元樹。試問，誰一定必勝？</p>
<p>完整二元樹定義：</p>
<ol>
<li>root 必須要有 left node and right node</li>
<li>是樹的最後節點</li>
</ol>
</blockquote>
<a id="more"></a>

<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><blockquote>
<p>雖然叫水題，但是卻沒辦法解出來，假水題阿 QQ<br>然後香港的題目真的好難，第一題我用 20 min 都無法想出來，於是我觀察別人的 Blog 才能將此題解出。</p>
</blockquote>
<p>此題可以用奇偶數可以直接判斷 Alice and Bob 誰是贏家！很神奇吧</p>
<p>為甚麼呢？<br>因為 ALICE 與 BOB 都只能砍掉「完整二元樹」，而在這裏的完整二元樹節點都會是「奇數」，完整二元樹的樹節點必定是 1 , 3 , 5 , 7 …..。然後透過數學歸納我們可以歸納出兩個奇數 (ALICE and BOB 各畫一次 )相加必等於偶數。</p>
<p>於是當「節點」為奇數時必定是 ALICE 勝，因為接下來換 BOB，但如果 BOB 可以畫就必定是偶數。<br>反之，當「節點」為偶數時必定是 BOB 勝，由前句推出</p>
<p>P.S. <a href="https://www.cnblogs.com/st1vdy/p/12444426.html" target="_blank" rel="noopener">觀看此 Blog 才學習到的</a><br>小小的題外話，我可以在 cin &gt;&gt; n 時即可輸出答案，不一定要等到將這筆測資完整 cin 完全時在輸出。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t ;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">int</span> a , b , n ;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">        <span class="keyword">if</span>(n % <span class="number">2</span>)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Alice\n"</span> ;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Bob\n"</span> ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; n ; i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ICPC</category>
      </categories>
      <tags>
        <tag>水題</tag>
        <tag>2019_2020_ICPC_Asia_Hong_Kong_Regional_Contest</tag>
        <tag>ICPC</tag>
      </tags>
  </entry>
  <entry>
    <title>C# 開超大陣列解決方法</title>
    <url>/2020/06/16/C_sharp/C-sharp-big-array/</url>
    <content><![CDATA[<h2 id="C-在一個陣列裡最多可以有多少元素阿！"><a href="#C-在一個陣列裡最多可以有多少元素阿！" class="headerlink" title="C# 在一個陣列裡最多可以有多少元素阿！"></a>C# 在一個陣列裡最多可以有多少元素阿！</h2><blockquote>
<p>根據 MSDN 預設，陣列的最大大小只能夠有 2GB， 假設此陣列為 int 時，最大元素最多只能有 \( 2^{31} /4 \)</p>
</blockquote>
<a id="more"></a>

<h2 id="那我一定要開到比這更大的陣列呢！"><a href="#那我一定要開到比這更大的陣列呢！" class="headerlink" title="那我一定要開到比這更大的陣列呢！"></a>那我一定要開到比這更大的陣列呢！</h2><p>別擔心，還是會有些解決之道的，如果你在 64 位元的電腦就可以解決了！只需要下方兩步驟即可完成。<br>但還是有些限制，假設 RAM 夠大，將可以使陣列擁有 40 億 elements。如果 RAM 沒辦法負荷 40 億 elements，則只能到負荷最大值。</p>
<ol>
<li><p>將電腦預設 32bits 建置環境改成 64 bits<br> 建置 &gt; 組態管理員 &gt; 平台 &gt; 新增 &gt; 新平台 &gt; x64，剩下按確認就可以了。</p>
<img src="/images/C_sharp_math_2.jpg" alt="C_sharp_math_2.jpg">
</li>
<li><p>在 config 新增 gcAllowVeryLargeObjects 來新增<br> 在 packages.config 新增 gcAllowVeryLargeObjects 即可</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">runtime</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">gcAllowVeryLargeObjects</span> <span class="attr">enabled</span>=<span class="string">"true"</span> /&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;/<span class="name">runtime</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<img src="/images/C_sharp_math_1.png" alt="C_sharp_math_1.png">

</li>
</ol>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>即使，未來科技再進步，還是必須要有好的資料結構與演算法，若豪不在意的不斷增加記憶體與處理器只是對之前那些努力設計電腦的人不敬，也會對自家的電腦造成很大的負擔QQ<br>這是必殺技，請小心慎用，不要上癮。</p>
<h3 id="更新日誌"><a href="#更新日誌" class="headerlink" title="更新日誌"></a>更新日誌</h3><p>2020-06-22 14:45:24 - 錯誤資訊修改</p>
]]></content>
      <categories>
        <category>C_sharp</category>
      </categories>
      <tags>
        <tag>套件說明</tag>
        <tag>C_sharp</tag>
      </tags>
  </entry>
  <entry>
    <title>ProblemD Defining Labels (數論 Math theorm)</title>
    <url>/2020/07/03/ICPC/2019-2020-ICPC-Asia-Hong-Kong-Regional-Contest-Pd/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意:"></a>題目大意:</h2><blockquote>
<p>給你 x 進制 y 值且他是試算表模式，如:A,B,..,Z,AA,AB..，請嘗試將他轉回 10 進制</p>
</blockquote>
<a id="more"></a>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析:"></a>分析:</h2><p>是我太久不會寫演算法，還是我變爛了，這題我花了兩小時才解決問題。QQ </p>
<p>我們先來看十進制的試算表模式與正常十進位模式</p>
<blockquote>
<p>試算表模式: 0 1 2 3 4 5 6 7 8  9 00 01 02 …<br>十進位模式: 1 2 3 4 5 6 7 8 9 10 11 12 13 …</p>
</blockquote>
<p>在試算表 0 時十進位為 1 相差 1，在試算表 00 時十進位為 11 相差 11(這裡只兩個 1 )，這讓我們找出一邏輯，只要試算表的位數在多新增一位時，就會在每位數相差 1。於是我們在多計算一位數時就先 -1，以求正確答案。<br>要記住轉換進位的時候先出來的數值是尾數，因為是透過不斷迭代相除完成的。<br>其餘剩下就是進制轉換了，用遞迴式表達:</p>
<ul>
<li>\(f(x,y)\)<ul>
<li>\(\text{if( x = 0 ) return ;} \)</li>
<li>\(\text{ else { f(x%y,y) , 10 - y + x % y } } \)</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x , <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    x--;</span><br><span class="line">    dfs(x/k , k );</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="number">10</span> - k + x % k ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">int</span> t , x , k ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t ;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; k &gt;&gt; x ;</span><br><span class="line">        dfs(x,k);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ICPC</category>
      </categories>
      <tags>
        <tag>2019_2020_ICPC_Asia_Hong_Kong_Regional_Contest</tag>
        <tag>ICPC</tag>
        <tag>數論 Math theorm</tag>
      </tags>
  </entry>
  <entry>
    <title>ProblemD Tapioka (水題)</title>
    <url>/2020/05/14/ICPC/2019-ICPC-Asia-Taipei-Hsinchu-Regional-Pd/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>給你一行話，請不要輸出 “bubble” 、 “tapioka”<br>格式有特別要求，請注意。</p>
</blockquote>
<a id="more"></a>

<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>這題你要是不會，是不是應該要撞豆腐了?</p>
<p>字串透過陣列求出，然後加上空白即可</p>
<p>額外話: py 不用5行就能把他寫完吧?<br>        py 真的是程式設計師救星，所有簡單的東西都能變簡單，但是語法不習慣</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PB push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP make_pair</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> );</span><br><span class="line">    <span class="comment">//freopen("out.txt" , "w" , stdout );</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="built_in">string</span> strTemp , strAns[<span class="number">5</span>] ;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; strTemp)&#123;</span><br><span class="line">        <span class="keyword">if</span>(strTemp == <span class="string">"bubble"</span> || strTemp == <span class="string">"tapioka"</span>)</span><br><span class="line">            <span class="keyword">continue</span> ;</span><br><span class="line">        strAns[index] = strTemp ;</span><br><span class="line">        index++ ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(index == <span class="number">0</span> )&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"nothing"</span> ;</span><br><span class="line">        <span class="keyword">return</span>  <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; index <span class="number">-1</span> ; i++)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; strAns[i] &lt;&lt; <span class="string">' '</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; strAns[index<span class="number">-1</span>] ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ICPC</category>
      </categories>
      <tags>
        <tag>水題</tag>
        <tag>ICPC</tag>
        <tag>2019_ICPC_Asia_Taipei-Hsinchu_Regional_Contest</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>ProblemG Game Design</title>
    <url>/2020/07/26/ICPC/2019-2020-ICPC-Asia-Hong-Kong-Regional-Contest-Pg/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>請設計塔防遊戲的地圖，這個地圖為一棵樹但可以超過 2 個 leaf。怪物只會從 leaf 往 root 走(即走到樹的根節點就再也不會走動)，我們將他簡單設計化，我們假設每個塔都可以完美殺死怪物，但建造塔則需要花費，請設計一張地圖 (那張地圖需要有節點與節點上的成本)，給你一數值 k，請生成一張地圖總共有 k 種最少成本的建造塔的解法 (任意一種即可)。</p>
</blockquote>
<a id="more"></a>

<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><blockquote>
<p>這題的想法非常有趣，我原本快要想對，但最後還是想錯方向了…<br>P.S. 如果我的分析不好，可以看此 <a href="https://www.cnblogs.com/st1vdy/p/12444426.html#1865251979" target="_blank" rel="noopener">st1vdy的 BLOG</a>，我是從他那邊得到靈感的。<br>下方說明文的 root，為整棵樹的 root。<br>x 為任意變數<br>left node 為 x 的右邊節點<br>right node 為 x 的左邊節點</p>
</blockquote>
<p>由於我們要設計一張地圖(樹)，為了方便我們簡單設計地圖，我們就定義為他是一顆二元樹。那我們接下來就是要來找一個規律來設計 k！</p>
<h3 id="初步思考"><a href="#初步思考" class="headerlink" title="初步思考"></a>初步思考</h3><p>我們先來思考哪種方式設計是最棒的，由於我們簡單設計成二元樹，於是我們先設定一算法，只有 root 為 x，其餘 node 值都為 1，且 \(x \geq  2 \)，這樣子最好算法就會有 \(k = a \cdot b \)。</p>
<p>那如果是質數呢？質數沒辦法符合那方程式阿，那只要把 \( x = 2 \)，就會再多一種算法，即\(k + 1\)，因為最小成本都是 2，如果從 root 放塔，那最小成本也還會是 2(\(因為 x = 2\))，因而多一種算法。</p>
<p><img src="/images/2019-2020-ICPC-Asia-Hong-Kong-Regional-Contest-Pg/1.jpg" alt=""></p>
<h3 id="找出問題"><a href="#找出問題" class="headerlink" title="找出問題"></a>找出問題</h3><p>我們的初步思考有一個很致命的缺點，因為他是給予我們 k，但如果要從 k 還原 a , b，如果遇到質數還需要 +1，程式碼太複雜不好維護。於是我們想出新的方法，既然可以 \(a \cdot b \)，那一定也有道理 \( a \cdot a \cdot b \)，可以推導成 \(a^{c} * b \)，但由於我們將算法簡化成程式碼好解決，就是將 \(a = 2\)，由於二元樹的特性，可以省下很多程式碼的功夫。</p>
<h3 id="新的想法"><a href="#新的想法" class="headerlink" title="新的想法"></a>新的想法</h3><p>所以我們把它從原本只有樹的 root 分兩邊然後 \(a * b \)，那我們就把每一個只要是「有連接到 leaf 的 node 的右子樹」(引號內在之後簡稱為 LN )都加入兩顆為 1 的 node，就可以達到 \( \cdot a \)的功用，剩下我們就是考慮到底要有幾個 LN，就可以湊出 k 種解法，然後如果說數字為一質數時，我們就把那 LN 的成本變成 \(LN = \text{left node} + \text{right node} \)，那如果不是質數就是 \(LN \geq \text{left node} + \text{right node} \)。</p>
<p>然後則必須思考，當 \(k = 1 \) 時我們實際上不需要 \(*2\)，於是我們只需要將那兩個 node 其中 1 節點改為 1，另一點則 \( &gt; 1 \)。但當 \( k = 2 \)時，則兩節點必要為 1。</p>
<p>下方圖片為當 k = x 時所產生的地圖與有多少解方法及選擇的點<br><img src="/images/2019-2020-ICPC-Asia-Hong-Kong-Regional-Contest-Pg/2.jpg" alt=""></p>
<h3 id="設計想法"><a href="#設計想法" class="headerlink" title="設計想法"></a>設計想法</h3><p>因為這題是不斷的進行除以 2，來生成地圖，但我們並不確定他需要幾次才能將 \( k / 2 &lt; 1\)，所以用遞迴解決，當用遞迴解決時，這遞迴需要的條件如下:</p>
<p>也就是遞迴可以解決，方程式想法如下:</p>
<ul>
<li>\(f(K) = if k &gt; 2 , 呼叫 f(k/2) + f(2) \)</li>
<li>\(if(k \leq 2) , 在右子樹加入 2 個 node\)</li>
<li>\(LN = \text{left node} + \text{right node} \)</li>
<li>\(if (k \% 2 == 0), LN +1 \)</li>
</ul>
<p>下方則是說明，對應每個方程式的說明</p>
<ul>
<li>當 \(k &gt; 2 \) 時，我們需要做 \( /2\) 這動作，但因為我們是在尋找 \( /2\) 的最好長度，於是需要再後面加入 \(f(2)\)，才能滿足 k 的要求</li>
<li>由於 k 的值小於等於 2，我們要加入 2 個 node 以滿足 \( * 2\)的動作</li>
<li>LN 會等於左節點 + 右節點，這為 K = 質數時的情況</li>
<li>如果 k 是偶數，那我們將 LN + 1，才不會多出一種解</li>
</ul>
<h3 id="觀念小釐清"><a href="#觀念小釐清" class="headerlink" title="觀念小釐清"></a>觀念小釐清</h3><p>在新的想法中，圖片最後在最後的 LN 時，左子樹也是右子樹的一種，減少程式碼撰寫麻煩。</p>
<p>Q: 為甚麼在下方的程式碼 function dfs 中是 <code>return temp</code> 而不是 <code>return value[root]</code>?<br>A: 很簡單的一個邏輯， 5 / 2 = 2 ，但 (2+1) * (2) = 6 ，回推不符合。應該還是要 2 * 2 + 1 = 5。</p>
<p>Q: 這篇講得很爛，文章主人是不是國文不好?<br>A: 這種想法的東西真的很難用文字表述，我的表達能力不好抱歉…<br>P.S. 但你可以稍微嘗試將這些用文字表達，真的不太好表達。這需要你去嘗試才知道困難處。</p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>要感謝 Bill and Entroy 先思考這題，等他們想通後，我才根據他們說給予我的指導和想法，幫助我寫出此題，不然要是自己寫應該要花比有他人指導更多的時間吧！希望我跟他們能夠一輩子都是好朋友。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 100010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> pa[SIZE] , value[SIZE] , cnt=<span class="number">0</span> ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> root )</span></span>&#123;</span><br><span class="line">    cnt++ ;</span><br><span class="line">    <span class="keyword">int</span> temp ;</span><br><span class="line">    pa[cnt] = root++ ;</span><br><span class="line">    <span class="keyword">if</span>(k &lt;= <span class="number">2</span>)&#123;</span><br><span class="line">        value[cnt] = <span class="number">3</span> - k ;</span><br><span class="line">        pa[cnt+<span class="number">1</span>] = cnt ;</span><br><span class="line">        value[++cnt] = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    temp = dfs(k/<span class="number">2</span>,root) + dfs(<span class="number">2</span>,root)  ;</span><br><span class="line">    value[root] = temp + (k % <span class="number">2</span> == <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> temp ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; k ;</span><br><span class="line">    dfs(k , <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; cnt &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= cnt ; i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; pa[i] &lt;&lt; <span class="string">' '</span> ;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= cnt ; i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; value[i] &lt;&lt; <span class="string">' '</span> ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ICPC</category>
      </categories>
      <tags>
        <tag>ICPC_2019-2020_North-Western_Russia_Regional_Contest</tag>
        <tag>ICPC</tag>
        <tag>設計解題</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>ProblemC Are They All Integers? (水題)</title>
    <url>/2020/05/14/ICPC/2019-ICPC-Asia-Taipei-Hsinchu-Regional-Pc/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>給你一微陣列數字(a[])，試問此陣列中是否都符合此公式 (a[i]+a[j]) / a[k] % 1 == 0 </p>
<p>如果不是，輸出 “no”。是請輸出 “yes” 。</p>
</blockquote>
<a id="more"></a>

<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>沒啥好說的，純操作題。</p>
<p>這題全部參加這次比賽的都有解出來呢，所以你不可以沒解出來喔。</p>
<p>小心這題犯的錯誤</p>
<ol>
<li>陣列要用 double ，不然怎樣 mod 1 都會 == 0 喔~</li>
<li>可以類似用 bubble sort的方式加速，要記得加 abs ，想必大家都知道啦。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PB push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FB <span class="meta-keyword">if</span>(!flag) break</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> );</span><br><span class="line">    <span class="comment">//freopen("out.txt" , "w" , stdout );</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">int</span> num[<span class="number">60</span>] ;</span><br><span class="line">    <span class="keyword">int</span> n ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; num[i] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">1</span> , intMod ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i +<span class="number">1</span>  ; j &lt; n ; j++ )&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span> ; k &lt; n ; k++)&#123;</span><br><span class="line">                <span class="keyword">if</span>( i == k || j == k)</span><br><span class="line">                    <span class="keyword">continue</span> ;</span><br><span class="line">                intMod = <span class="built_in">abs</span>(num[i] - num[j]) % num[k] ;</span><br><span class="line">                <span class="keyword">if</span> (intMod != <span class="number">0</span> )&#123;</span><br><span class="line">                    flag = <span class="number">0</span> ;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//debug</span></span><br><span class="line">                    <span class="comment">//cout &lt;&lt; intMod &lt;&lt; ' ' &lt;&lt; num[i] &lt;&lt; ' ' &lt;&lt; num[j] &lt;&lt; ' ' &lt;&lt; num[k] &lt;&lt; '\n' ;</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            FB;</span><br><span class="line">        &#125;</span><br><span class="line">        FB;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"yes"</span> ;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"no"</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ICPC</category>
      </categories>
      <tags>
        <tag>水題</tag>
        <tag>ICPC</tag>
        <tag>2019_ICPC_Asia_Taipei-Hsinchu_Regional_Contest</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>ProblemE The League of Sequence Designers(數論 Math theorm)</title>
    <url>/2020/07/18/ICPC/2019-ICPC-Asia-Taipei-Hsinchu-Regional-Pe/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>有一公式\( \max(r - l + 1 ) \cdot  \sum_{l \leq i \leq n } a_{i} , 其中 1 \leq l \leq r \leq n \)<br>題目給予一貪心演算法，但此演算法並不正確。演算法如下:<br><img src="/images/2019-ICPC-Asia-Taipei-Hsinchu-Regional-Pe/1.png" alt=""></p>
<p>給你 k , l ， k 為貪心演算法與正確解答的差距， l 為最少要生成數列的長度，請您給出一組數列能夠在正確的演算法成功輸出正確答案，也能讓貪心演算法與正確演算法的差距等於 k，如果不行請輸出 -1</p>
</blockquote>
<a id="more"></a>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p><strong><font color="#dd0000">這種解題方式我還是第一次看到阿，只能說自己見識太淺還需要磨練</font></strong></p>
<p>這題我是直接去看別人 BLOG 分析的 CODE 才 AC 的，但是他沒有解析，我在這邊附註解析好讓未來的自己複習，會在後面附上連結。</p>
<p>這題分成幾個步驟:</p>
<p>由於題目有限制數列長度必小於 2000，於是我們直接把每一個生成的陣列都直接定義成 1999，就可以直接輕鬆跳過 l 的問題。</p>
<h3 id="長度必小於-2000"><a href="#長度必小於-2000" class="headerlink" title="長度必小於 2000"></a>長度必小於 2000</h3><p>根據貪心演算法的程式碼，當 \(curMAX &lt; 0 \) 時，我們就直接捨棄掉，只用後面的 \( left \)，於是我們可以用一個簡單方法直接找出貪心演算法的最大問題核心。</p>
<h3 id="舉例說明"><a href="#舉例說明" class="headerlink" title="舉例說明"></a>舉例說明</h3><p>EX: 舉例數列為 -1 1 1 3</p>
<table>
<thead>
<tr>
<th>演算法</th>
<th>數列總和</th>
<th>長度</th>
<th>總和*長度=答案</th>
</tr>
</thead>
<tbody><tr>
<td>貪心演算法</td>
<td>5</td>
<td>3</td>
<td>\( 5 \cdot 3 = 15\)</td>
</tr>
<tr>
<td>正確演算法</td>
<td>4</td>
<td>4</td>
<td>\( 4 \cdot 4 = 16 \)</td>
</tr>
</tbody></table>
<p>看出來了嗎?<br>問題在於如果一開始為 -1 時貪心演算法永遠都會捨棄那長度，於是我們只要設計出一個數列是可以破解他的貪心演算法就完成了。</p>
<h3 id="怎麼破解"><a href="#怎麼破解" class="headerlink" title="怎麼破解?"></a>怎麼破解?</h3><p>其實我們也不用那麼麻煩一定要讓自己想出一個絕對正確的演算法，我們只要將貪心演算法稍加改良在讓我們產生的數列可以產生出一個差額為 k 值，是不是非常聰明！教導我的 BLOG 就是這樣做的，真的優秀</p>
<h3 id="設計演算法"><a href="#設計演算法" class="headerlink" title="設計演算法"></a>設計演算法</h3><p>根據舉例，我們可以得出一結論</p>
<ol>
<li>貪心演算法的長度永遠會比正確演算法少 1</li>
<li>正確演算法的長度永遠會比貪心演算法多 1</li>
</ol>
<p>根據數學乘法公式，可找出適合的 k 值，這裡我們用舉例的方式來說明比較清楚:</p>
<h4 id="EX-1-前項為數列總和-定義為-A-後項為長度總和-定義為-B"><a href="#EX-1-前項為數列總和-定義為-A-後項為長度總和-定義為-B" class="headerlink" title="EX:1 前項為數列總和(定義為 A)  後項為長度總和(定義為 B)"></a>EX:1 前項為數列總和(定義為 A)  後項為長度總和(定義為 B)</h4><p>數列: -1 1 1 3<br>\(5 \cdot 3 = 15 \)<br>\(4 \cdot 4 = 16 \)<br>\(16 - 15 = 1 , k = 1 \)</p>
<h4 id="EX-2-前項為數列總和-定義為-A-後項為長度總和-定義為-B"><a href="#EX-2-前項為數列總和-定義為-A-後項為長度總和-定義為-B" class="headerlink" title="EX:2 前項為數列總和(定義為 A)  後項為長度總和(定義為 B)"></a>EX:2 前項為數列總和(定義為 A)  後項為長度總和(定義為 B)</h4><p>數列: -1 1 1 4<br>\(6 \cdot 3 = 18 \)<br>\(5 \cdot 4 = 20 \)<br>\(20 - 18 = 2 , k = 2 \)</p>
<h4 id="證明"><a href="#證明" class="headerlink" title="證明"></a>證明</h4><p>當 \(C \cdot D = E \) 時，如果  C 項 -1，則 E - D (定義為 F)</p>
<p>\(7 \cdot 2 = 14\)<br>\(6 \cdot 3 = 18\)<br>\(18 - 14 = 4 , k = 4 \)<br>經過轉變後<br>\(7 \cdot 3 = 21 \)<br>\(6 \cdot 3 = 18 \)<br>在將 \(7 \cdot 3 = 21 \) 的 <strong>3</strong> -1 ，於是 \(21 - 18 -7 = -4\)得此證明 k。</p>
<h4 id="證明好了，那我應該怎麼做"><a href="#證明好了，那我應該怎麼做" class="headerlink" title="證明好了，那我應該怎麼做?"></a>證明好了，那我應該怎麼做?</h4><p>由於數列中的數字的大小必小於 2000，理所當然的 k 最大只能到 1999，所以我們可以用透過放大中間的數列來讓 k 值加大</p>
<h4 id="EX-3"><a href="#EX-3" class="headerlink" title="EX:3"></a>EX:3</h4><p>數列: -1 2 2 3<br>\(7 \cdot 3 = 21 \)<br>\(6 \cdot 4 = 24 \)<br>\(24 - 21 = 3 , k = 3 \)<br>由於中間的數值從 1 被我放大到 2，所以 k 的值也隨之 +2，原因是因為中間的數列長度為 2 且原本的 1 都被我在 +1 ，於是 \(1 * 2 = 2\) </p>
<h3 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h3><p>當雙方 A 都增加 1，且雙方 B 一樣都不變時， k 的值會 +1，並且當 k 必須大於 2000 時我們必須放大中間數列，OK 我們找到公式了！</p>
<h3 id="找到公式了，但在等等題目很壞心眼"><a href="#找到公式了，但在等等題目很壞心眼" class="headerlink" title="找到公式了，但在等等題目很壞心眼"></a>找到公式了，但在等等題目很壞心眼</h3><p>由於題目很惡意，他 l 的範圍並不是在 \(0 \leq l &lt; 2000\)，是在 \(0 \leq &lt; 10^{9}\)，於是你必須多加行 if 判斷如果 \(l \geq 2000\) 就 cout -1 ，OK開始寫 code 吧</p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>這題對於不擅長數論的我來說非常痛苦阿，前面的證明我也並不覺得我證明得很好，如果我的文字敘述上有錯誤，拜託跟我講QQQQQQ，或是有更好的表達方式請告訴我，我會改進。<br>這題我光看懂大神的程式碼就花了 3hr，自己的領悟力還是不夠強還需要努力，也是第一次遇到這種需要設計題目的，學起來了！</p>
<p>附上<a href="https://www.cnblogs.com/st1vdy/p/12701920.html" target="_blank" rel="noopener">我從大神學來知識的 BLOG</a><br>打了篇文章也花了我 2hr 整，自己的表達能力需要加強，寫 BLOG 也不是一件簡單的事情啊…</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 2020</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="keyword">int</span> arr[MAXN] = &#123;&#125; ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">int</span> t , k , l ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t ;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; k &gt;&gt; l ;</span><br><span class="line">        arr[<span class="number">1</span>] = <span class="number">-1</span> ;</span><br><span class="line">        <span class="keyword">if</span>(l &gt;= <span class="number">2000</span>)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">            <span class="keyword">continue</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fill(arr+<span class="number">2</span> , arr+<span class="number">2000</span> , (<span class="number">1999</span> + k) / <span class="number">1998</span>) ;</span><br><span class="line">        arr[<span class="number">1999</span>] += (<span class="number">1999</span> + k ) % <span class="number">1998</span> ;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="number">1999</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= <span class="number">1999</span> ; i++)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">' '</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ICPC</category>
      </categories>
      <tags>
        <tag>ICPC</tag>
        <tag>2019_ICPC_Asia_Taipei-Hsinchu_Regional_Contest</tag>
        <tag>設計解題</tag>
        <tag>程式解題</tag>
        <tag>數論 Math theorm</tag>
      </tags>
  </entry>
  <entry>
    <title>ProblemB Bad Treap (數論 Math theorm)</title>
    <url>/2020/06/16/ICPC/ICPC-2019-2020-North-Western-Russia-Regional-Contest-Pb/</url>
    <content><![CDATA[<head>
  <script type="text/javascript"
    src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
<meta name="generator" content="Hexo 4.2.1"></head>

<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>給你一個數 n ，然後生成一顆樹，比 root 小的 node 在左邊，比 root 大的 node 在右邊，規則是 \(y = sin(x)\)</p>
<p>要求是可以生成出一個最高高度的樹，但只能用 n 個點。</p>
</blockquote>
<a id="more"></a>

<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><blockquote>
<p>這題跟鬼一樣難，是假程式題，真數學題阿！<br>我對於這題還是沒有辦法很了解，如果看不懂我的可以建議多看別人的 Blog。</p>
<p>P.S.  我也是看<a href="https://acm.uestc.edu.cn/blog/41/" target="_blank" rel="noopener">他的 Blog </a></p>
</blockquote>
<p>我們的目的就是 n = 最高長度，然後我們在簡化一點題目就是單調隊列最大化。即 root 都是 left or right 有 node。</p>
<p>由於 sin 的週期是 \( 2 \pi \)，但是 \(sin(0) = sin(\pi) \) 會造成一個現象就是有兩個 \(y = sin(x) \)，所以我們必須再將範圍縮小至 \( \dfrac{-2}{\pi} \sim \dfrac{2}{\pi}  \)。<br>但因為 sin 的週期很難控制，也抓不太到規律。<br>於是我們現在有了一個新的任務，找出最小點，透過倍數來完成這題。<br>但是 sin 的倍數不會調整嗎? 會，但是我們只要找出最小點，這個最小點再乘以 50000 倍也不超過 \( \dfrac{-2}{\pi} \sim \dfrac{2}{\pi} \)，這樣就可以了！<br>接下來要怎麼找呢? 這裡就很神奇瞜!</p>
<p>由於太神奇了，我特別拉出來講，我們要找出一個極小值，我們就先假設 0.0035 ，當 sin (0.0035 角度) = 0.00006，夠我們使用了。怎麼說呢? 因為我們 \( \pi = 3.14 \)，然後我們需要 50000 個數值，所以 \( \dfrac{-2}{\pi} = -25000 * 0.00006 \) and \( \dfrac{2}{\pi} = 0.00006 * 25000 \) 且因 \(25000 + 25000 = 50000 \)，就能搞定題目的 50000 個數值了！最後我們剩下一個任務就能把解題的必要元素都解出來。<br>P.S. 不一定要用 0.0035 ，只要能夠找出一個可以在 \( \dfrac{-2}{\pi} \sim \dfrac{2}{\pi}  \) 能放入 50000個等比級數即可，我有考慮使用過 sin(0.002 角度) = 0.00003，但我解不出下方公式 A , B</p>
<p>公式如下:<br>\(  sin(A * 360 + 0.0035)度數 = sin(B) 弧度\) and \( A , B \in Z \)<br>Z 則是我們需要的答案。</p>
<p>由於題目說過 B 必須為整數，A 則是由於 sin 週期而必須是整數。<br>這時候呢，這條公式我則是透過看解答解開的， A = 113 , B = 710，我想不出有甚麼公式或是可以寫一個簡單的程式可以順利找出來。如果知道還請聯絡我，拜託了QQ<br>P.S. 我覺得只能透過暴力解，才能解出。</p>
<p>接下來就是看他有幾個數列就直接乘以 B 即可，但還需要減去 25000 * B，因為我們是從 \( \dfrac{-2}{\pi} \) 開始。</p>
<h4 id="作者心得"><a href="#作者心得" class="headerlink" title="作者心得"></a>作者心得</h4><p>這題也太難了吧，俄羅斯人都跟鬼一樣強阿，此題考的不是寫出來的程式，而是你需要非常清晰的邏輯與能夠解出公式的 A 與 B，若是你能解出來，你的實力肯定在我之上，我佩服你！<br>(然後解出來，就告訴我你的想法吧！)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">    <span class="keyword">for</span>(ll i = <span class="number">0</span> ; i &lt; n ; i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i * <span class="number">710</span> - <span class="number">25000</span> * <span class="number">710</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ICPC</category>
      </categories>
      <tags>
        <tag>ICPC_2019-2020_North-Western_Russia_Regional_Contest</tag>
        <tag>ICPC</tag>
        <tag>設計解題</tag>
        <tag>程式解題</tag>
        <tag>數論 Math theorm</tag>
      </tags>
  </entry>
  <entry>
    <title>ProblemA Accurate Movement (數論 Math theorm)</title>
    <url>/2020/05/18/ICPC/ICPC-2019-2020-North-Western-Russia-Regional-Contest-Pa/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>有兩個 Box ，這兩個 Box 不可以互相拋棄對方，必須要相互連在一起</p>
<p>他們要走到 n 距離，試問走幾步才能走到?</p>
</blockquote>
<a id="more"></a>

<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>數學一直都不是我擅長的阿，好難過 ಥ_ಥ</p>
<p>還是我今年 ICPC 的好夥伴幫我想出的，然後我再理解，邏輯不好rrrrrr<br>Bill and Entroy 都是 math master </p>
<p>公式: ceiling( (n-b) / (b-a) ) * 2 + 1 ;</p>
<p>n-b 為大箱子到 n   的距離<br>b-a 為小箱子到大箱子的距離<br>+1  最後小箱子移動到終點的距離</p>
<p>我還有 n-b 的距離要移動 每次最多只能移動 (b-a) 每次移動的權重為 2 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span>) ;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">int</span> a , b , n ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; n ;</span><br><span class="line">    <span class="keyword">int</span> ans , temp ;</span><br><span class="line">    temp = (n-b) / (b-a) ;</span><br><span class="line">    <span class="keyword">if</span>( (n-b) % (b-a) != <span class="number">0</span> )</span><br><span class="line">        temp += <span class="number">1</span> ;</span><br><span class="line">    ans = temp * <span class="number">2</span> + <span class="number">1</span> ;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>ICPC</category>
      </categories>
      <tags>
        <tag>ICPC_2019-2020_North-Western_Russia_Regional_Contest</tag>
        <tag>ICPC</tag>
        <tag>程式解題</tag>
        <tag>數論 Math theorm</tag>
      </tags>
  </entry>
  <entry>
    <title>ProblemE Equidistant (DFS)</title>
    <url>/2020/05/20/ICPC/ICPC-2019-2020-North-Western-Russia-Regional-Contest-Pe/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>有一張地圖，有幾個需要參加 ICPC 的城市，我們需要設計一個程式，尋找一個城市可以讓每個要參加 ICPC 的城市都是花相同的距離到達?</p>
</blockquote>
<a id="more"></a>

<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>此題有很多種做法，但唯有時間複雜度最低才能 AC (我怎麼覺得我好像在說廢話 XD)</p>
<p>先透過 DFS 把參加 ICPC 中的城市兩個最遠距離給求出來。<br>再將兩個城市中的最長距離 /2 ，再找出那個路經的城市(<strong>定義為 A</strong>)。</p>
<p>再透過 DFS 從 A 開始到每一個需要參加 ICPC 的城市，如果他們的距離不等於我們在上個 DFS 找出的最長距離 /2，就輸出 “NO” ，如果都可以那就輸出 “YES”</p>
<p>P.S. 我好久沒有寫 DFS 了，居然都快忘記了。這邊就要感謝 BILL。<br>喚醒我那在史前時代的記憶用 vector 去做 DFS，真的優秀。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> m , n , flag=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> Maxn_city = <span class="number">0</span> , Maxn_path = <span class="number">0</span> ;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;tree[<span class="number">200020</span>] ;</span><br><span class="line"><span class="keyword">int</span> city[<span class="number">200020</span>] = &#123;&#125; ;</span><br><span class="line"><span class="keyword">int</span> visit[<span class="number">200020</span>] = &#123;&#125; ;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; travel ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS_to_large_path</span><span class="params">(<span class="keyword">int</span> root )</span></span>&#123;</span><br><span class="line">    visit[root] = <span class="number">1</span> ;</span><br><span class="line">    travel.push_back(root);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; tree[root].size() ; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> node = tree[root][i] ;</span><br><span class="line">        <span class="keyword">if</span>(!visit[node])&#123;</span><br><span class="line">            BFS_to_large_path(node);</span><br><span class="line">            travel.pop_back();</span><br><span class="line">            visit[root] = <span class="number">0</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//debug to check large path</span></span><br><span class="line">    <span class="comment">//if (root == 1)</span></span><br><span class="line">    <span class="comment">//    cout &lt;&lt; "1=" &lt;&lt; travel.size() &lt;&lt; ' ' &lt;&lt; Maxn_path &lt;&lt; ' ' &lt;&lt; city[root] &lt;&lt; '\n' ;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(city[root] &amp;&amp; travel.size() &gt; Maxn_path)&#123;</span><br><span class="line">        Maxn_city = travel[travel.size()/<span class="number">2</span>];</span><br><span class="line">        Maxn_path = travel.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS_to_other_path</span><span class="params">(<span class="keyword">int</span> root ,<span class="keyword">int</span> path)</span></span>&#123;</span><br><span class="line">    visit[root] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; tree[root].size() ; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> node = tree[root][i] ;</span><br><span class="line">        <span class="keyword">if</span>(!visit[node])&#123;</span><br><span class="line">            BFS_to_other_path(node , path+<span class="number">1</span>);</span><br><span class="line">            visit[root] = <span class="number">0</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//debug</span></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="number">1</span> )</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"city="</span> &lt;&lt; root &lt;&lt; <span class="string">" path= "</span> &lt;&lt; path &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(city[root] &amp;&amp; path != Maxn_path)</span><br><span class="line">        flag = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ;</span><br><span class="line">    <span class="keyword">int</span> a , b ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n<span class="number">-1</span> ; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b ;</span><br><span class="line">        tree[a].push_back(b) ;</span><br><span class="line">        tree[b].push_back(a) ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; m ; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a ;</span><br><span class="line">        city[a] = <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    BFS_to_large_path(a);</span><br><span class="line">    <span class="comment">//visit[a] = 0 ;</span></span><br><span class="line">    BFS_to_other_path(Maxn_city , <span class="number">1</span> );</span><br><span class="line">    <span class="keyword">if</span>(flag)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"YES\n"</span> &lt;&lt; Maxn_city ;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"NO"</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//debug</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Maxn_path= "</span> &lt;&lt; Maxn_path &lt;&lt; <span class="string">" Maxn_city= "</span> &lt;&lt; Maxn_city &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ICPC</category>
      </categories>
      <tags>
        <tag>ICPC_2019-2020_North-Western_Russia_Regional_Contest</tag>
        <tag>DFS</tag>
        <tag>圖論</tag>
        <tag>ICPC</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>ProblemH High Load Database (Complex Optimization)</title>
    <url>/2020/05/26/ICPC/ICPC-2019-2020-North-Western-Russia-Regional-Contest-Ph/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>給你兩組陣列 (定義為 A , B)，詢問 B 的每一個數字，能將 A 分割最大。<br>補述說明：　可將 A 想像成包裹 B 想像為箱子<br>要將 A 塞到 B 裡面並最佳化利用但必須按照順序，試問需要幾個箱子。</p>
</blockquote>
<a id="more"></a>

<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><blockquote>
<p>這題看起來很簡單對不對！<br><strong>但其實它是非常可怕的效率優化</strong><br>要是打得像文章一樣，沒人會理解吧！</p>
</blockquote>
<ol>
<li><p>使用前綴和 + 二分收尋<br> 在上一份包裹沒被收納前，下一份包裹就無法加入箱子。並且透過二分收尋的方式，就可以很方便的加入並且省掉撰寫更多程式碼的時間。</p>
<p> 舉例:<br> EX: 2 2 4 3 3 包裹 =&gt; 2 4 8 11 14 設定箱子為 4<br> 因此一開始收尋 4 是在 4 8 之間 (這裡使用 C++ upper_bound 直接抓 &gt; x 的值 index)，因為 4+4 = 8 ，因此我下次就收尋 8，8 在 8 13 之間，所以 8+4 = 12，以此類推。每做二分收尋一次就是多切一段，很聰明的想法吧！只是單單這樣還是不夠的，俄羅斯沒那麼友善QQ。</p>
</li>
<li><p>找出包裹之間的最大值並與箱子比較<br> 這想法其實一開始我的隊友跟我說時，我還無法想通邏輯。但多思考個幾分鐘就能懂了，我的邏輯敏感力還是不太好啊…。</p>
<p> 假設題型：<br> 如果 箱子是 5 ，包裹為 3 6 7 8 9，那箱子 5 是不是必定沒辦法包住 6 7 8 9? 因此我找出這些包裹的最大差額，要是箱子不能裝到裡面最大的包裹，就直接判斷 Impossible，省去 step1 的查找時間。<del>反正有找跟沒找還不是一樣</del></p>
</li>
</ol>
<ol start="3">
<li>他的查找資料是會重複的<br><font color="#dd0000"> <strong>最機車的地方</strong> </font><br>應該是我英文底子不太好，可能看不太懂他有說資料會重複查詢抑或是他沒有說。這邊我是去查看這邊我是去查看<a href="https://blog.csdn.net/m0_37809890/article/details/102946147?utm_medium=distribute.pc_relevant.none-task-blog-baidujs-1" target="_blank" rel="noopener">Little_Fall 天才</a>，不然我應該永遠都想不出來吧…。<br>好了，前面廢話那麼多，該講重點了。再新增一個陣列來記錄如果使用 t 箱子可以裝幾個包裹就可以完成了！</li>
</ol>
<p>這份解題記錄我打了一小時…好累阿。還有兩題要打，加油!</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">200020</span>] = &#123;&#125; ;</span><br><span class="line"><span class="keyword">int</span> save[<span class="number">1000200</span>] = &#123;&#125; ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n , sum =<span class="number">0</span> , Mv = <span class="number">0</span> ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i++)&#123; <span class="comment">//cin array</span></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; arr[i] ;</span><br><span class="line">        sum += arr[i] ;</span><br><span class="line">        arr[i] = sum ;</span><br><span class="line">        Mv = max(Mv, arr[i] - arr[i<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(save , <span class="number">-1</span> , <span class="keyword">sizeof</span>(save));</span><br><span class="line">    <span class="keyword">int</span> seaT , t , seaN , index ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; seaN ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; seaN ; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; t ;</span><br><span class="line">        seaT = t ;</span><br><span class="line">        sum = <span class="number">0</span> ;</span><br><span class="line">        index = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>; <span class="comment">//flag = 1 non-impossible flag2 = impossible</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(save[t] != <span class="number">-1</span>)</span><br><span class="line">            flag = <span class="number">1</span> ;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(Mv &gt; t)</span><br><span class="line">            flag = <span class="number">2</span> ;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(flag==<span class="number">0</span>)&#123;</span><br><span class="line">            index = upper_bound(arr+index , arr+n , seaT )-arr;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//debug</span></span><br><span class="line">            <span class="comment">//cout &lt;&lt; "seaT=" &lt;&lt; " " &lt;&lt; seaT &lt;&lt; " value=" &lt;&lt; arr[index-1] &lt;&lt; '\n' ;</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(index == n)&#123; </span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">                save[t] = ++sum ;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            seaT = arr[index<span class="number">-1</span>] + t ;</span><br><span class="line">            sum++ ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="number">2</span> || save[t] == <span class="number">0</span> )</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Impossible"</span> ;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; save[t] ;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ICPC</category>
      </categories>
      <tags>
        <tag>ICPC_2019-2020_North-Western_Russia_Regional_Contest</tag>
        <tag>效率優化</tag>
        <tag>ICPC</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>ProblemI Ideal Pyramid (Complex Optimization)</title>
    <url>/2020/05/26/ICPC/ICPC-2019-2020-North-Western-Russia-Regional-Contest-Pi/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>我需要一個蓋一個金字塔，中間要有許多柱子。請寫出一個程式告訴此金字塔的中心點與高。</p>
</blockquote>
<a id="more"></a>

<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><blockquote>
<p>非常的數論阿…</p>
</blockquote>
<p>先假設他給的每個點都需要蓋一個金字塔(因為必須要大於等於金字塔)，這很數學，我太笨，不好解釋。我只能跟你說金字塔是 45 度，所以從中點切面來說會是正三角形，接著 /2，就是等腰三角形，就可以找到解答了！</p>
<p>於是策略如下:</p>
<ol>
<li>找最大最小的 xy ，然後求對角線。</li>
<li>高則透過 (max(MaxX - MinX , MaxY - MinY)+1) /2算一半的對角線就能求出。</li>
</ol>
<h3 id="疑問"><a href="#疑問" class="headerlink" title="疑問"></a>疑問</h3><p><font color="#dd0000"><strong>這題有個很奇怪的點，就是因為如果是用 int 是會有 .5 的問題，於是我很貼心的加入四捨五入，但在 submit 時就吃 WA，氣死我了。</strong></font></p>
<p><del>以後不要想那麼多，我們寫演算法的。盡量把他想得簡單化，不要太貼心</del><br>題目有說只有 int，希望他可以說多一點…</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Maxn -100000020</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Minn 100000020</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> ) ;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    ll n ;</span><br><span class="line">    ll MaxX , MinX , MaxY , MinY ;</span><br><span class="line">    MaxX = Maxn ;</span><br><span class="line">    MinX = Minn ;</span><br><span class="line">    MaxY = Maxn ;</span><br><span class="line">    MinY = Minn ;</span><br><span class="line">    ll a , b , c ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c ;</span><br><span class="line">        MaxX = max(a + c , MaxX);</span><br><span class="line">        MinX = min(a - c , MinX);</span><br><span class="line">        MaxY = max(b + c , MaxY);</span><br><span class="line">        MinY = min(b - c , MinY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> x , y , h , dx , dy ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//debug</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; MaxX &lt;&lt; " " &lt;&lt; MinX &lt;&lt; " " &lt;&lt; MaxY &lt;&lt; " " &lt;&lt; MinY &lt;&lt; '\n' ;</span></span><br><span class="line">    x = (MaxX + MinX+<span class="number">1</span>) /<span class="number">2</span> ;</span><br><span class="line">    y = (MaxY + MinY+<span class="number">1</span>) /<span class="number">2</span> ;</span><br><span class="line">    h = (max(MaxX - MinX , MaxY - MinY)+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">' '</span> &lt;&lt; y &lt;&lt; <span class="string">' '</span> &lt;&lt; h ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ICPC</category>
      </categories>
      <tags>
        <tag>ICPC_2019-2020_North-Western_Russia_Regional_Contest</tag>
        <tag>效率優化</tag>
        <tag>ICPC</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>ProblemJ Just the Last Digit (Floyd)</title>
    <url>/2020/05/25/ICPC/ICPC-2019-2020-North-Western-Russia-Regional-Contest-Pj/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>有一張有向圖，有一人遍地此路徑，於是她得出每個點有幾種不一樣的路徑，並繪製地圖<br>你的任務就是將此圖還原成原始地圖，如 a -&gt; b , c -&gt; b </p>
</blockquote>
<a id="more"></a>

<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><blockquote>
<p>對我而言這有點類似於 Floyd 演算法，但我沒有十足把握。有描繪出其大概想法，但卻沒辦法將演算法建立完成，需查看 <a href="https://www.cnblogs.com/Dup4/p/11968817.html" target="_blank" rel="noopener">Dup4’Blog 大神</a>才有辦法解出。</p>
</blockquote>
<p>由於題目有說明 i &gt; j &gt; k 所以不會有 5 &gt; 3 &gt; 2 問題加上路徑數量不會超過 10 (last digit 代表只會有 1 位數)，使問題簡單很多壓力將低，<del>比起這年份的俄羅斯考卷只喜歡一值考時間優化好多了…</del>。</p>
<p>我將我的程式想法說明，希望大家與未來的我可以看懂，嗚嗚嗚</p>
<p>array before = 題目給的<br>array after  = 還原陣列</p>
<p>請先記住由於測試資料是 xxxxx 模式，所以透過 char 會來的比 int 陣列更方便輸入</p>
<p>下面的標題為 Line 行數<br>22. 由於路徑只會從小到大，於是從 i 開始遍地不斷嘗試<br>23. i -&gt; j 的路徑收尋<br>24. sum = 紀錄過去的路徑<br>25. i -&gt; k -&gt; j 先假設玩家透過 i -&gt; k ( Before 的路徑 )<br>26. after 要有才可以做 27. ，因為先前必須要有路徑才可以實行<br>27. 若是 after (必須要先確定有這個路徑，才可以用 sum 記錄才真實) 的路徑<br>30. 為甚麼是 sum +1? 例如說只有 2 個點 0 -&gt; 1 ，在前面的程式 sum = 0，因為前面程式邏輯 after[i][k] 要有值 sum 才會增加紀錄，所以 +1 表示為單純只從 a -&gt; b 次過程中並沒有其他的點。<br>31. 於是原始資料是有路徑的，所以透過 after 還原</p>
<p>對不起我解釋得很爛… 非常抱歉</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">char</span> before[<span class="number">520</span>][<span class="number">520</span>] = &#123;&#125; ;</span><br><span class="line"><span class="keyword">int</span> after[<span class="number">520</span>][<span class="number">520</span>] = &#123;&#125; ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; n ; j++)</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; before[i][j] ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面程式註解</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span> ; j &lt; n ; j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span> ;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = i + <span class="number">1</span> ; k &lt; j ; k++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(after[i][k])</span><br><span class="line">                    sum += before[k][j]-<span class="string">'0'</span> ;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>( (sum +<span class="number">1</span>) % <span class="number">10</span> == before[i][j] - <span class="string">'0'</span>)&#123;</span><br><span class="line">                after[i][j] = <span class="number">1</span> ;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n ; j++)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; after[i][j] ;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ICPC</category>
      </categories>
      <tags>
        <tag>ICPC_2019-2020_North-Western_Russia_Regional_Contest</tag>
        <tag>Floyd-Warshall algorithm</tag>
        <tag>ICPC</tag>
        <tag>程式解題</tag>
        <tag>動態規劃 Dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title>ProblemM Managing Difficulties (Complex Optimization)</title>
    <url>/2020/05/18/ICPC/ICPC-2019-2020-North-Western-Russia-Regional-Contest-Pm/</url>
    <content><![CDATA[<script type="text/javascript"
  src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>給你一斷數列<br>判斷裡面的值有幾個是可以符合公式 \(a_j−a_i=a_k−a_j\)</p>
</blockquote>
<a id="more"></a>


<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>這題很簡單，就是要著重在效率時顯得十分棘手。<br>我將分成 3 個部分說明。</p>
<ol>
<li><p>透過字典優化<br>可將公式移項成 \(2a_j = a_i + a_k \)，加上 i &gt; j &gt; k<br>透過字典的部分能夠將 \(a_k\) 點就可以省略掉 for k 的迴圈</p>
</li>
<li><p>j 從最後 n - 1 開始往前 for<br>如果只透過 1. 會發現一個問題，因為在每次 i 結束時，需要再將之前刪除的 dict[j] 值補回，會增加一個 for與是透過反向輸出，可省略掉須將刪除的 dict[j] 補回，於是減少一個 for了!</p>
</li>
<li><p>使用unorder_map<br>map 會造成效率增加  \( o (n \log \ n)\)，少量使用內存。<br><a href="https://blog.csdn.net/StephenZou14/article/details/69568620" target="_blank" rel="noopener">unordered_map</a> 則是效率減少 \(o(1)\)，大量使用內存。</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> num[<span class="number">2020</span>] = &#123;&#125; ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> t , n , ans, now  ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t ;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span> ,<span class="keyword">int</span> &gt; dict ;</span><br><span class="line">        ans = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; num[i] ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dict[num[n<span class="number">-1</span>]] += <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = n<span class="number">-2</span> ; j &gt; <span class="number">0</span> ; j--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; j ; i++ )&#123;</span><br><span class="line">                now = <span class="number">2</span> * num[j] - num[i] ;</span><br><span class="line">                ans += dict[now];</span><br><span class="line">            &#125;</span><br><span class="line">            dict[num[j]]+=<span class="number">1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>ICPC</category>
      </categories>
      <tags>
        <tag>ICPC_2019-2020_North-Western_Russia_Regional_Contest</tag>
        <tag>效率優化</tag>
        <tag>ICPC</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>債劵定價筆記</title>
    <url>/2020/07/02/NTUT_note/bond-pricing/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊與財金管理系大一下財務管理中債劵定價重點整理<br><font color="#dd0000">並非所有人都適用，部分對我而言稍加容易的內容並不會寫在此內。</font></p>
</blockquote>
<a id="more"></a>

<h5 id="名詞解釋"><a href="#名詞解釋" class="headerlink" title="名詞解釋"></a>名詞解釋</h5><ul>
<li>r = 利率</li>
<li>t = 期數</li>
</ul>
<h2 id="債劵定價"><a href="#債劵定價" class="headerlink" title="債劵定價"></a>債劵定價</h2><ul>
<li>殖利率 (YTM) <ul>
<li><strong>每年</strong>使用這筆資金平均每年應該要付給債權人的資金成本</li>
<li>會隨著其他因素改變，如:違約程度風險，債劵到期時間長短</li>
<li>\(公司債券 = \sum_{t=0}^{n} \frac{利息}{(1+殖利率)^{t}} +  \frac{本金}{(1+殖利率)^{n}} \)</li>
<li>\(YTM = 當期受益率 + 資本利得(損失)率 \)</li>
</ul>
</li>
</ul>
<h3 id="殖利率計算機按法"><a href="#殖利率計算機按法" class="headerlink" title="殖利率計算機按法"></a>殖利率計算機按法</h3><ol>
<li>set = end </li>
<li>PV 輸入發行價格並在前面加上負號，如: -123</li>
<li>PMT 輸入利息</li>
<li>FV 輸入票價 </li>
<li>到 i 點 solve</li>
</ol>
<ul>
<li>票價發行<ul>
<li><table>
<thead>
<tr>
<th>票面利率與殖利率比較</th>
<th>評價</th>
</tr>
</thead>
<tbody><tr>
<td>票面利率 = 殖利率</td>
<td>評價發行</td>
</tr>
<tr>
<td>票面利率 &gt; 殖利率</td>
<td>溢價發行</td>
</tr>
<tr>
<td>票面利率 &lt; 殖利率</td>
<td>折價發行</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li>債劵風險<ul>
<li>到期日越久的債劵風險越高</li>
<li>利率越高的債券風險越低</li>
</ul>
</li>
<li>當期收益率 \( current yield \)<ul>
<li>\(current yield = \frac{當年度利息收入}{債劵當年度期初價格} \)</li>
</ul>
</li>
<li>資本利得率<ul>
<li>\(資本利得率 = \frac{債券今年價格 - 債券去年價格}{債券去年價格} \)</li>
</ul>
</li>
</ul>
<h2 id="債券特性"><a href="#債券特性" class="headerlink" title="債券特性"></a>債券特性</h2><ul>
<li>債券的利息可以被當成費用，降低稅率</li>
<li>債券名稱依時間長短區分<ul>
<li>中期債券 -&gt; 一年以上，十年以下</li>
<li>長期債券 -&gt; 十年以上</li>
</ul>
</li>
<li>債劵名稱以擔保品區分<ul>
<li>擔保債券 -&gt; 用股票或其他有價債券擔保</li>
<li>抵押擔保債券 -&gt; 以固定資產或不動產擔保</li>
<li>信用債券 -&gt; 用信用擔保，通常信譽良好大公司才能發行<ul>
<li><font color="#dd0000"><strong>信用債券必須等到公司將其他債務清償完畢後才能求償</strong></font>，但能優於股東</li>
</ul>
</li>
</ul>
</li>
<li>贖回債券 (call provision)<ul>
<li>公司可以買回，但通常會比票面價格高</li>
</ul>
</li>
<li>償債基金 (sinking fund)<ul>
<li>透過特定信託公司，買回或贖回特定債券</li>
</ul>
</li>
</ul>
<h2 id="債券評價"><a href="#債券評價" class="headerlink" title="債券評價"></a>債券評價</h2><ul>
<li>債券平等<ul>
<li>評價越高，投資人要求報酬低</li>
<li>評價越低，投資人要求報酬高</li>
</ul>
</li>
<li>投資型債券<ul>
<li>評價等級高，以賺取本金與少許利息</li>
</ul>
</li>
<li>投機型債券<ul>
<li>評價等級低，以賺取本金與<strong>大量</strong>利息</li>
</ul>
</li>
</ul>
<h2 id="市場術語"><a href="#市場術語" class="headerlink" title="市場術語"></a>市場術語</h2><ul>
<li>交叉型債券<ul>
<li>被 n 種信評公司評初不同等級債券</li>
</ul>
</li>
<li>垃圾債券 (Jund Bond) <ul>
<li>信用較差公司，發行的高收益債券，通常都以高票面利率為主</li>
</ul>
</li>
<li>墮落天使 (fallen angel)<ul>
<li>從投資型債券轉變成垃圾債券</li>
</ul>
</li>
<li>NCAA<ul>
<li>No coupon at all -&gt; 無法支付任何利息的債券</li>
</ul>
</li>
</ul>
<h2 id="其他債券"><a href="#其他債券" class="headerlink" title="其他債券"></a>其他債券</h2><ul>
<li>金融債券<ul>
<li>還本期間不得低於兩年</li>
</ul>
</li>
<li>零息債券 (zero coupon bond)<ul>
<li>完全不支付利息，到期末時將一次性將面額償還，通常面額裡面內含利息</li>
<li>\(發行價格 = \frac{發行面額}{(1+r)^{t}}\)</li>
<li>發行必定為<strong>折價</strong>發行</li>
<li>\(利息(coupon) = 發行面額 - 發行價格 \)</li>
<li>到期前不付息，但必須提列利息費用</li>
</ul>
</li>
<li>浮動利率 (floating-rate bond)<ul>
<li>每 3 到 6 個月進行調整利率</li>
<li>仍有上下限，上下限區間為利率區間</li>
<li>通常為金融機構發行，時間約為 10 年</li>
</ul>
</li>
<li>可轉換債券 (convertible bond)<ul>
<li>在到期前，可以有<strong><font color="#dd0000">權利(非義務)</font>轉成<font color="#dd0000">原發行機構股票</font></strong></li>
</ul>
</li>
<li>可交換公司債 (exchangeable bond)<ul>
<li>在到期前，可以有<strong><font color="#dd0000">權利(非義務)</font>轉成<font color="#dd0000">其他發行機構股票</font></strong></li>
</ul>
</li>
<li>附認購權債證券 (warrant bond)<ul>
<li>在購買此債券時，可以用較低價格買該機構發行股票，以刺激投資債券</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>北科上課筆記</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>財務管理筆記</tag>
        <tag>北科大一下財務管理筆記</tag>
        <tag>北科上課筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>資本預算決策</title>
    <url>/2020/07/03/NTUT_note/capital-budget-decision/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊與財金管理系大一下財務管理中資本預算決策重點整理<br><font color="#dd0000">並非所有人都適用，部分對我而言稍加容易的內容並不會寫在此內。</font></p>
</blockquote>
<a id="more"></a>

<h5 id="名詞解釋"><a href="#名詞解釋" class="headerlink" title="名詞解釋"></a>名詞解釋</h5><ul>
<li>\(r_{s} = 股東要求報酬率\)</li>
<li>\(r_{d} = 債權人要求報酬率 \)</li>
<li>\(n = 年數 \)</li>
</ul>
<h4 id="基本觀念"><a href="#基本觀念" class="headerlink" title="基本觀念"></a>基本觀念</h4><ul>
<li>資本<ul>
<li>運用於長期投資方案資金為資本</li>
</ul>
</li>
<li>資本預算決策<ul>
<li>判斷資本應投資在哪項長期資產</li>
</ul>
</li>
<li>決策類別<ol>
<li>在某 1 時點利用各種評估技術判定<strong>某投資方案是否可行</strong></li>
<li>在某 1 時點利用各種評估技術判定<strong>多方案中何者最佳</strong></li>
</ol>
</li>
<li>投資方案<ul>
<li>獨立方案 (independent projects)<ul>
<li>此投資案不影響其他</li>
</ul>
</li>
<li>互斥方案 (mutually exclusive projects)<ul>
<li>選 A 則其餘方案不可選</li>
</ul>
</li>
<li>初次新投資案 (new venture projects)<ul>
<li>無投資經驗，評估成本難，風險高</li>
</ul>
</li>
<li>擴增方案 (expansion projects)<ul>
<li>以增加效能為目的，評估成本與風險次難</li>
</ul>
</li>
<li>重置方案 (replacement projects)<ul>
<li>更新設備，風險低，評估容易</li>
</ul>
</li>
</ul>
</li>
<li>投資產生的現金流入<ul>
<li>在未來發生<ul>
<li>考慮貨幣時間價值</li>
</ul>
</li>
<li>發生的年數與金額不確定性高<ul>
<li>無法完美預估，總有變數</li>
</ul>
</li>
<li>受市場景氣影響<ul>
<li>受限於景氣循環</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="淨現值法-NPV"><a href="#淨現值法-NPV" class="headerlink" title="淨現值法 NPV"></a>淨現值法 NPV</h2><p>未來收益折現後，判斷投資優劣標準<br>\( NPV = \frac{現金}{(1+資金成本)^{n}} - 期初投入金額 \)</p>
<ul>
<li>優點<ol>
<li>考量到投資案本身真實現金流量，而非會計數字</li>
<li>考量到投資案所有現金流量，結果精確</li>
<li>考量了貨幣時間價值，未來現金流入折現計算</li>
</ol>
</li>
</ul>
<h2 id="還本期法-Payback-period-method-與-折現還本期法-discounted-payback-period-method"><a href="#還本期法-Payback-period-method-與-折現還本期法-discounted-payback-period-method" class="headerlink" title="還本期法 (Payback period method) 與 折現還本期法 (discounted payback period method)"></a>還本期法 (Payback period method) 與 折現還本期法 (discounted payback period method)</h2><p>投資金額需 x 年才能完全回收，通常以年為單位。<br>不考慮折現為還本期法，考慮則為折現還本期法。</p>
<ul>
<li>優點<ol>
<li>方法簡單</li>
<li>方便衡量管理者決策能力</li>
<li>可大概了解一筆資金套牢致回收的時間 </li>
</ol>
</li>
<li>缺點<ol>
<li>未考慮時間價值</li>
</ol>
</li>
</ul>
<h2 id="內部報酬率法-IRR"><a href="#內部報酬率法-IRR" class="headerlink" title="內部報酬率法 IRR"></a>內部報酬率法 IRR</h2><p>考慮今年時間價值，計算出隱含報酬率，在將報酬率與資金成本比較並判定投資案可行性</p>
<ul>
<li>特性<ol>
<li>考慮所有現金流量</li>
<li>考慮現金流量時間價值</li>
<li>獨立方案與追求公司價值最大化目標一致</li>
<li>互斥方案與追求公司價值極大化目標不一致</li>
</ol>
</li>
</ul>
<h2 id="修正後內部報酬率法-MIRR"><a href="#修正後內部報酬率法-MIRR" class="headerlink" title="修正後內部報酬率法 MIRR"></a>修正後內部報酬率法 MIRR</h2><p>IRR 可能導致誤判，因而產生此法修正。<br>如有甲乙兩互斥方案，分別畫出 NPV 線，如有相交情況則該焦點資金成本稱為銜接率 (crossover rate)<br>當資金成本低於銜接率時，IRR會<font color="#dd0000"><strong>誤判</strong></font></p>
<ul>
<li>銜接率計算:<ul>
<li>類似於 NPV，需將兩方案每次獲得的收益量相減，所得數值為銜接率。一樣使用 NPV 計算</li>
</ul>
</li>
</ul>
<h2 id="計算機按法-IRR-and-NPV"><a href="#計算機按法-IRR-and-NPV" class="headerlink" title="計算機按法 IRR and NPV"></a>計算機按法 IRR and NPV</h2><ol>
<li>輸入利率 (若想詢問 IRR 可忽略此步驟)</li>
<li>csh 點擊執行</li>
<li>第一期輸入為負數，接下來都為正數</li>
<li>在按一次 CASH </li>
<li>選擇 IRR or NPV 按執行</li>
</ol>
<h2 id="計算機按法-MIRR"><a href="#計算機按法-MIRR" class="headerlink" title="計算機按法 MIRR"></a>計算機按法 MIRR</h2><ol>
<li>先使用 CPMD 計算複利</li>
<li>PMT 輸入每年報酬</li>
<li>n 為期數</li>
<li>i 為利率</li>
<li>FV 按執行</li>
<li>\((FV / 投資價格)^{1/年數} \)</li>
</ol>
<h2 id="獲利指數法-profitability-index-PI"><a href="#獲利指數法-profitability-index-PI" class="headerlink" title="獲利指數法 (profitability index , PI)"></a>獲利指數法 (profitability index , PI)</h2><ul>
<li>特性<ol>
<li>考慮全部現金流量</li>
<li>考慮現金流量時間價值</li>
<li>獨立方案與追求公司價值極大化目標一致</li>
<li>互斥方案與追求公司價值極大化目標不一致</li>
<li>若是獨立方案只要 PI &gt; 1全部採用</li>
</ol>
</li>
<li>公式<ul>
<li>\( PI = \frac{\frac{當年度收益}{(1+資金成本)^{年數}}}{期初投資}\)</li>
</ul>
</li>
</ul>
<h2 id="實務上的資本決策方法"><a href="#實務上的資本決策方法" class="headerlink" title="實務上的資本決策方法"></a>實務上的資本決策方法</h2><ul>
<li>IRR 與 NPV 最常被使用</li>
<li>還本期法應計算方便為第二長使用</li>
</ul>
]]></content>
      <categories>
        <category>北科上課筆記</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>財務管理筆記</tag>
        <tag>北科大一下財務管理筆記</tag>
        <tag>北科上課筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>股票定價筆記</title>
    <url>/2020/07/02/NTUT_note/stock_pricing/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊與財金管理系大一下財務管理中股票定價重點整理<br><font color="#dd0000">並非所有人都適用，部分對我而言稍加容易的內容並不會寫在此內。</font></p>
</blockquote>
<a id="more"></a>

<h2 id="普通股"><a href="#普通股" class="headerlink" title="普通股"></a>普通股</h2><ul>
<li><p>普通股介紹</p>
<ol>
<li>有稅後盈餘且提撥過資本公積與盈餘公積才可以發放股利   </li>
<li>股利不可以折稅或當成公司費用使用</li>
<li>有 \( 2 \% \) 健保補充費</li>
</ol>
</li>
<li><p>普通股評價 </p>
<ul>
<li><p>現金股利零成長</p>
<ol>
<li>\( \frac{現金股利}{必要報酬率}\)</li>
</ol>
</li>
<li><p>股利固定成長型</p>
<ol>
<li>\( \frac{現金股利 * (1+股利成長率) }{必要報酬率 - 股利成長率} \)</li>
<li>\(下一次股價 = 這次股價 * (1+股利成長率)\)</li>
</ol>
</li>
<li><p>非固定成長股利</p>
<ol>
<li>\( \frac{現金股利 * (1+前面股利成長率)}{(1+要求報酬率)} + 後來的股利固定成長型 \)</li>
</ol>
</li>
<li><p>股利成長率 \((g)\)</p>
<ul>
<li>\(股利成長率(g) = 保留比率 * 普通股權益報酬率 \)</li>
</ul>
</li>
<li><p>普通股權益報酬率 \((ROE)\)</p>
<ul>
<li>\(\frac{淨利}{平均普通股股東權益}\)</li>
</ul>
</li>
<li><p>必要報酬率 \((k)\)</p>
<ul>
<li>\( k = g + \frac{明年的現金股利}{股價} \)</li>
</ul>
</li>
<li><p>\((每股盈餘 = EPS)\)</p>
</li>
</ul>
</li>
<li><p>本益比還原法</p>
<ul>
<li>\( E(p) = 產業平均比 * 預期 EPS \)</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>北科上課筆記</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>財務管理筆記</tag>
        <tag>北科大一下財務管理筆記</tag>
        <tag>北科上課筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>資本結構筆記</title>
    <url>/2020/07/02/NTUT_note/capital-structure/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊與財金管理系大一下財務管理中資本結構重點整理<br><font color="#dd0000">並非所有人都適用，部分對我而言稍加容易的內容並不會寫在此內。</font></p>
</blockquote>
<a id="more"></a>

<h5 id="名詞解釋"><a href="#名詞解釋" class="headerlink" title="名詞解釋"></a>名詞解釋</h5><ul>
<li>\(k = 負債資本成本\)</li>
<li>\(R_{s} = 權益資本成本 \)</li>
<li>\(EBIT = 稅前息前利潤\)</li>
<li>\( A = 舉債後普通股資本成本 \)</li>
<li>\( B = 舉債前普通股資本成本 \)</li>
</ul>
<h2 id="資本結構"><a href="#資本結構" class="headerlink" title="資本結構"></a>資本結構</h2><ul>
<li>資本來源<ul>
<li>長期負債</li>
<li>股東權益</li>
</ul>
</li>
<li>資本結構以負債比例衡量<ul>
<li>\(長期負債 / (股東權益 + 長期負債) \)</li>
<li>\(長期負債 / (股東權益) \) 筆記採用此定義</li>
</ul>
</li>
<li>公司價值總和計算<ol>
<li>未來所有現金流入之折現值</li>
<li>流通在外有價證劵 (股票加負債)總市值</li>
<li>上述兩者必相同</li>
</ol>
</li>
<li>資本成本<ul>
<li>資金使用者: 使用每一元付出的代價</li>
<li>資金提供者: 使用每一元獲得的報酬</li>
<li>資本成本計算<ul>
<li>\( \frac{明年現金股利}{普通股價格} + 股票成長率 \)</li>
</ul>
</li>
</ul>
</li>
<li>債務資本成本<ul>
<li>通常都以 % 為單位</li>
<li>\(資金成本 = 名目利息 - 名目利息 * 稅率 \)</li>
</ul>
</li>
<li>加權平均資金成本 (WACC)<ul>
<li>無公司所得稅時，舉債增加，WACC<strong>不變</strong></li>
<li>有公司所得稅時，舉債增加，WACC<strong>減少</strong></li>
<li>\(WACC = \frac{權益}{負債+權益} * 權益資本成本 + \frac{負債}{負債+權益} * 債務資本成本 * (1 - 所得稅率) \)</li>
</ul>
</li>
<li>固定投資成長<ul>
<li>\( PV = \frac{每年獲益量}{WACC - 成長率}\)</li>
</ul>
</li>
<li>公司價值與股東財富最大化<ul>
<li>公司價值增加，股東財富增加</li>
<li>如果資本結構影響公司價值，則經理人應讓公司價值極大化才能讓股東財富極大化</li>
</ul>
</li>
</ul>
<h2 id="MM理論"><a href="#MM理論" class="headerlink" title="MM理論"></a>MM理論</h2><ul>
<li><font color="#dd0000"><strong>無所得稅</strong></font><ul>
<li>在<font color="#dd0000"><strong>無所得稅</strong></font>下，公司價值與資本結構無關</li>
<li>\(公司價值 = \frac{EBIT}{普通股資本成本} \)</li>
<li>舉債後會提高普通股的資金成本，因舉債後公司風險上升，股東勢必會要求更高報酬率。公式與定義如下:<br>\(A = B +  (B - 此債務資本成本) * (舉債 / (公司價值 - 舉債) )\)<br>且總和必定會跟原先計算 WACC 不變</li>
</ul>
</li>
<li><font color="#dd0000"><strong>有所得稅</strong></font><ul>
<li>在<font color="#dd0000"><strong>有所得稅</strong></font>下，公司價值與資本結構有關且提升   </li>
<li>\(公司價值 = \frac{EBIT * (1 - 稅率)}{普通股資本成本} + 舉債 * 稅率\)</li>
<li>\(A = B + (B - 此債務資本成本) * (1 - 稅率) * (舉債 / (公司價值 - 舉債))\)</li>
</ul>
</li>
</ul>
<h2 id="槓桿關聯成本"><a href="#槓桿關聯成本" class="headerlink" title="槓桿關聯成本"></a>槓桿關聯成本</h2><ul>
<li>財務危機成本 (financial distress cost)<ul>
<li>直接破產成本: 公司已破產，申請破產之行政費用。如:律師、會計師行政費用</li>
<li>間接破產成本: 處於財務危機，避免破產而產生的相關費用</li>
</ul>
</li>
<li>負債代理成本<ul>
<li>債權人避免經理人做出對股東有利而對債權人不利的相關費用。如:監督經理人相關費用</li>
<li>高風險投資<ul>
<li>如投資成功，債權人只能拿到一樣利息，但股東可拿更多。反之，失敗則債權人可能完全拿不回來，股東也只會失去先前投資金額</li>
</ul>
</li>
<li>不作該做投資<ul>
<li>若投資案可能影響到股東利益，而使股東要求經理人不投資</li>
</ul>
</li>
<li>舉債發放現金股利<ul>
<li>損害公司的償債能力</li>
</ul>
</li>
</ul>
</li>
<li>債權人減少監督股東的代理成本做法<ol>
<li>限制舉債投資項目</li>
<li>舊債之優先求償權</li>
<li>限制債務期間現金股利發放</li>
<li>限制舉新債</li>
</ol>
</li>
</ul>
<h2 id="訊號發射理論"><a href="#訊號發射理論" class="headerlink" title="訊號發射理論"></a>訊號發射理論</h2><p>公司管理人員與投資人員存在資訊不對稱 (information asymmetry)，當公司資本結構已給投資人知道時，公司經營狀況就已經改變，投資人可在這時重新評估公司價值</p>
<ul>
<li>舉債增加<ul>
<li>有高獲利投資機會時，公司會選擇舉債而避免發行新股而造成利益稀釋</li>
</ul>
</li>
<li>發行新股<ul>
<li>公司投資機會風險高或經營狀況不佳時，所需資金則會以發行股票來獲得，以避免無法還債風險</li>
</ul>
</li>
<li><strong>舉債是好消息而發行新股是壞消息</strong></li>
<li>公司應該將負債水準控制在較低水準，有好機會再使用負債融資</li>
</ul>
<h2 id="融資順利理論"><a href="#融資順利理論" class="headerlink" title="融資順利理論"></a>融資順利理論</h2><p>融資可分成三類，保留盈餘、舉債、發行新股。而企業優先採有的資訊來源順序如下:</p>
<ol>
<li>保留盈餘</li>
<li>舉債</li>
<li>發行新股</li>
</ol>
<ul>
<li>此理論並不認為公司存在最理想之負債水準，公司視資金需要時機不同，而決定是否採用負債融資</li>
<li>此理論認為足夠獲利公司會先採用保留盈餘，MM理論則認為會先使用負債，達到稅盾效果</li>
<li>此理論認為最先利用應為保留盈餘，而備投資案所用。但MM理論考慮權益代理成本認為過多的自由現金會導致管理階層浪費</li>
</ul>
]]></content>
      <categories>
        <category>北科上課筆記</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>財務管理筆記</tag>
        <tag>北科大一下財務管理筆記</tag>
        <tag>北科上課筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>QUESTION! R 如果要讓程式碼換行要怎麼辦?</title>
    <url>/2020/08/12/R/R-coding-new-line/</url>
    <content><![CDATA[<h2 id="內容說明"><a href="#內容說明" class="headerlink" title="內容說明"></a>內容說明</h2><blockquote>
<p>寫程式的時候是不可能沒遇到 bug 的，bug 紀錄整理</p>
</blockquote>
<a id="more"></a>


<h2 id="QUESTION-R-如果要讓程式碼換行要怎麼辦"><a href="#QUESTION-R-如果要讓程式碼換行要怎麼辦" class="headerlink" title="QUESTION: R 如果要讓程式碼換行要怎麼辦?"></a>QUESTION: R 如果要讓程式碼換行要怎麼辦?</h2><h3 id="answer"><a href="#answer" class="headerlink" title="answer:"></a>answer:</h3><p>如果是在 Rstudio 畫面時，就直接按 enter 即可，不須再加 \</p>
<h4 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h4><p><a href="https://bbs.pinggu.org/thread-2187964-1-1.html" target="_blank" rel="noopener">[问答] 在R程序脚本中如何换行</a></p>
<h2 id="QUESTION-R-的-if-要怎麼使用"><a href="#QUESTION-R-的-if-要怎麼使用" class="headerlink" title="QUESTION: R 的 if 要怎麼使用"></a>QUESTION: R 的 if 要怎麼使用</h2><h3 id="answer-1"><a href="#answer-1" class="headerlink" title="answer:"></a>answer:</h3><p>很簡單，但必須要注意 R 並不是用 <code>continue</code> 來當作下一個，而是使用 <code>next</code></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">x &lt;- <span class="number">1</span>:<span class="number">5</span></span><br><span class="line"><span class="keyword">for</span> (val <span class="keyword">in</span> x) &#123;</span><br><span class="line">    <span class="keyword">if</span> (val == <span class="number">3</span>)&#123;</span><br><span class="line">    <span class="keyword">next</span></span><br><span class="line">    &#125;</span><br><span class="line">print(val)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="參考連結-1"><a href="#參考連結-1" class="headerlink" title="參考連結:"></a>參考連結:</h2><p><a href="https://www.datamentor.io/r-programming/break-next/" target="_blank" rel="noopener">R break and next Statement</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>程式語言的世界博大精神，要是沒有他們的付出我能走上現在的路嗎?<br>肯定是沒辦法的，於是我也需要更努力地去為社會付出。</p>
]]></content>
      <categories>
        <category>R語言</category>
      </categories>
      <tags>
        <tag>R語言</tag>
        <tag>學習筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>貨幣時間價值筆記</title>
    <url>/2020/07/02/NTUT_note/time-value-of-money/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊與財金管理系大一下財務管理章節中貨幣時間價值筆記重點整理<br><font color="#dd0000">並非所有人都適用，部分對我而言稍加容易的內容並不會寫在此內。</font></p>
</blockquote>
<a id="more"></a>

<h5 id="名詞解釋"><a href="#名詞解釋" class="headerlink" title="名詞解釋"></a>名詞解釋</h5><ul>
<li>\(m = 月份\)</li>
<li>\(r = 利率 \)</li>
</ul>
<h2 id="複利與有效年利率"><a href="#複利與有效年利率" class="headerlink" title="複利與有效年利率"></a>複利與有效年利率</h2><ul>
<li>\(現值 = PV \)</li>
<li>問複利的利率，給期初、期末金額<ul>
<li>\( (期末/期初)^{\frac{1}{年數}}\)</li>
</ul>
</li>
<li>七二法則<ul>
<li>如果利率為 k 倍，期數為 n，則要使本金成長一倍的時間可由 \(k * n = 72 \)來求出近似值。</li>
</ul>
</li>
<li>複利<ul>
<li>\( FV = PV*(1+\frac{r}{m})^{m}\)   </li>
</ul>
</li>
<li>有效年利率 \( EAR \)<ul>
<li>\(EAR = (1+ \frac{r}{m})^{m} -1 \)</li>
</ul>
</li>
<li>連續複利下的 EAR <ul>
<li>\((1+ \frac{r}{m})^{m} -1 \)</li>
</ul>
</li>
</ul>
<h2 id="年金"><a href="#年金" class="headerlink" title="年金"></a>年金</h2><ul>
<li>普通年金<ul>
<li>每一期<strong>末</strong>領取或支付金額，直到期滿為止</li>
</ul>
</li>
<li>期初年金<ul>
<li>每一期<strong>初</strong>領取或支付金額，直到期滿為止</li>
</ul>
</li>
<li>永續年金<ul>
<li>普通年金或期初年金方式，但期數為無限多期</li>
</ul>
</li>
</ul>
<h3 id="普通、期初年金計算機按法"><a href="#普通、期初年金計算機按法" class="headerlink" title="普通、期初年金計算機按法"></a>普通、期初年金計算機按法</h3><ol>
<li>點 CMPD</li>
<li>PMT 為每年要付的金額</li>
<li>FV 未來要提領的金額</li>
<li>I 利率</li>
<li>n 期數</li>
<li>set 選擇普通年金還是期初年金</li>
<li>PV 現在所提領金額 (基本上不用到)</li>
<li><strong>未用到的數值都要歸零</strong></li>
</ol>
<h3 id="永續年金計算方式"><a href="#永續年金計算方式" class="headerlink" title="永續年金計算方式"></a>永續年金計算方式</h3><p>\(PV = \frac{PMT}{r}\)</p>
<h2 id="貸款形式與攤銷"><a href="#貸款形式與攤銷" class="headerlink" title="貸款形式與攤銷"></a>貸款形式與攤銷</h2><ul>
<li>純折價貸款 (pure discont loan)<ul>
<li>期初借入，期中<strong>不給錢</strong>，期末一次給清</li>
</ul>
</li>
<li>純付息貸款 (interest-only loan)<ul>
<li>期初借入，期中<strong>付利息</strong>，期末付最後一次利息與本金</li>
</ul>
</li>
<li>分期貸款 (amortized loan) 有下述兩種<ol>
<li>期初借入，期中<strong>付利息也支付固定金額償還本金欠款</strong>，期末償還完畢</li>
<li>期初借入，期中<strong>支付固定金額內包含部分本金與利息</strong>，期末償還完畢</li>
</ol>
</li>
</ul>
<h3 id="貸款題型"><a href="#貸款題型" class="headerlink" title="貸款題型"></a>貸款題型</h3><ul>
<li>氣球型貸款<ul>
<li>給你帶 x 年貸款，但在第 y 年時貸款就必須付清。其中 x &gt; y <ol>
<li>每月底償付固定本息的金額是多少?<br>A:  一樣用 x 算不必在算 y</li>
<li>y 年到期時時未償還金額為多少?<br>A:  將第一題算出的 PMT 帶入年金公式即可，因為它題目詢問為現值。</li>
</ol>
</li>
</ul>
</li>
<li>每 x 年支付一次的年金，利率應該怎麼算?<ul>
<li>\(利率 = (1+r)^{x}-1\)</li>
</ul>
</li>
<li>我每年付 x 年，但我最後 y 年都必須提取 z 元，則我每年該存入多少固定資金<ol>
<li>使用期初年金公式，先將 y 年存取 z 元折現回來，那就是我們要存錢時期的最後終值</li>
<li>再用最後終值帶入普通年金公式，PMT就是我們要的答案</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>北科上課筆記</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>財務管理筆記</tag>
        <tag>北科大一下財務管理筆記</tag>
        <tag>北科上課筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>透過 plumber 完成 RESTAPI 在 R 上的應用</title>
    <url>/2020/07/23/R/R-api/</url>
    <content><![CDATA[<h2 id="內容說明"><a href="#內容說明" class="headerlink" title="內容說明"></a>內容說明</h2><blockquote>
<p>RESTAPI 有點類似於打包程式碼成為 class 的概念，一開始再碰 RESTAPI 會較難懂。<del>我第一次學 API 就是現在，我花了快兩三個小時才懂RRR</del><br>plumber 可以應用在 RESTAPI<br>以下紀錄 plumber 在 R 上的應用與<strong><font color="#dd0000">需要注意的地方</font></strong></p>
</blockquote>
<a id="more"></a>

<h2 id="安裝-plumber"><a href="#安裝-plumber" class="headerlink" title="安裝 plumber"></a>安裝 plumber</h2><p>首先需要 plumber</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">install.packages(<span class="string">"plumber"</span>)</span><br></pre></td></tr></table></figure>

<h2 id="教學範例"><a href="#教學範例" class="headerlink" title="教學範例"></a>教學範例</h2><h3 id="使用-R-plumber-可以檢的使用-R-創建-RESTFUL-API，plumber-識別-，以下提供簡單範例"><a href="#使用-R-plumber-可以檢的使用-R-創建-RESTFUL-API，plumber-識別-，以下提供簡單範例" class="headerlink" title="使用 R plumber 可以檢的使用 R 創建 RESTFUL API，plumber 識別 #*，以下提供簡單範例"></a>使用 R <code>plumber</code> 可以檢的使用 R 創建 RESTFUL API，plumber 識別 <code>#*</code>，以下提供簡單範例</h3><figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="keyword">library</span>(plumber)</span><br><span class="line"></span><br><span class="line"><span class="comment">#* @method /url</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#* Echo provided text</span></span><br><span class="line"><span class="comment">#* @param text The text to be echoed in the response</span></span><br><span class="line"><span class="comment">#* @get /echo</span></span><br><span class="line"><span class="keyword">function</span>(text = <span class="string">""</span>) &#123;</span><br><span class="line">  list(</span><br><span class="line">    message_echo = paste(<span class="string">"The text is:"</span>, text)</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="在-R-上面啟動-api-指令"><a href="#在-R-上面啟動-api-指令" class="headerlink" title="在 R 上面啟動 api 指令"></a>在 R 上面啟動 api 指令</h3><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">plumber::plumb(file=<span class="string">'./plumber.R'</span>)$run(port = <span class="number">5762</span>)</span><br></pre></td></tr></table></figure>

<p>其中 port 可以忽略不打(則會隨機產生)，接下來用 curl 來試著呼叫</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl --data &quot;text&#x3D;hi_my_friend&quot; &quot;localhost:5762&#x2F;echo&quot;</span><br></pre></td></tr></table></figure>

<h3 id="如果要輸出-json-呢"><a href="#如果要輸出-json-呢" class="headerlink" title="如果要輸出 json 呢"></a>如果要輸出 json 呢</h3><p>這點 R 完全幫你做好，R 可以自動幫你轉成 json，但還是有少部分情況例外。<strong><font color="#dd0000">裡面完全不需要轉成 json，就放心地給他輸出吧！</font></strong><br><strong>只限定傳送一個參數並且是 json 檔案</strong></p>
<h3 id="我想要輸入-json，但我卻輸入不進去"><a href="#我想要輸入-json，但我卻輸入不進去" class="headerlink" title="我想要輸入 json，但我卻輸入不進去.."></a>我想要輸入 json，但我卻輸入不進去..</h3><p>這點就比較有趣了，看下面的程式碼就能了解箇中奧妙</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">#* parse JSON</span></span><br><span class="line"><span class="comment">#* @param req  the request object</span></span><br><span class="line"><span class="comment">#* @get /json</span></span><br><span class="line"><span class="comment">#* @post /json</span></span><br><span class="line">echo_json &lt;- <span class="keyword">function</span>(req)&#123;</span><br><span class="line">  print(req$postBody)</span><br><span class="line">  <span class="keyword">return</span>(req$postBody)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到了嘛!? 我們必須在物件後使用 <code>$postBody</code>，就可以成功輸入 json</p>
<h3 id="我遇到了一個問題，我不懂要怎麼把-json-post-給-api"><a href="#我遇到了一個問題，我不懂要怎麼把-json-post-給-api" class="headerlink" title="我遇到了一個問題，我不懂要怎麼把 json post 給 api"></a>我遇到了一個問題，我不懂要怎麼把 json post 給 api</h3><p>小問題，我已經試過了，早就狀況排除了~ <del>血與淚的過程</del></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl &quot;localhost:8551&#x2F;url&quot; --header &quot;Content-type:application&#x2F;json&quot; -X POST -d @path&#x2F;file</span><br></pre></td></tr></table></figure>

<h2 id="QUESTIONS-and-ERRORS-集合地"><a href="#QUESTIONS-and-ERRORS-集合地" class="headerlink" title="QUESTIONS and ERRORS 集合地"></a>QUESTIONS and ERRORS 集合地</h2><p>這裡有些作者已經經歷過的問題就放在這裡供大家參考怎麼解決或<del>放棄</del>。</p>
<h3 id="QUESTION-windows上傳遞參數的時候出現亂碼怎麼辦？"><a href="#QUESTION-windows上傳遞參數的時候出現亂碼怎麼辦？" class="headerlink" title="QUESTION: windows上傳遞參數的時候出現亂碼怎麼辦？"></a>QUESTION: windows上傳遞參數的時候出現亂碼怎麼辦？</h3><p>改用 LINUX 平台是目前作者最好的解法。由於 Window 似乎在傳遞進來時編碼會遇到問題例如 <code>‘</code> 透過字串傳輸在 windows 上是亂碼，但在 Linux 不會，於是建議遇到此問題一律都使用 linux server 來解決。</p>
<h2 id="寫一個-api-傳送許多參數"><a href="#寫一個-api-傳送許多參數" class="headerlink" title="寫一個 api 傳送許多參數"></a>寫一個 api 傳送許多參數</h2><p>有時候我們並不是只需要傳送一個參數，而是傳送多個參數時就必須這樣寫。</p>
<p>如果參數後面的等於配上空字串表示預設為空，只有被傳回來有；那後面如果有值則代表如果 api 沒有傳此參數就已預設為主。<br><strong>注意，參數後面一律都必須搭配字串，api 傳送的都是字串格式</strong></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">path_json &lt;- <span class="keyword">function</span>(data = <span class="string">""</span> , path_length = <span class="string">"20"</span> )&#123;</span><br><span class="line">  json_content &lt;- run_path(data , path_length )</span><br><span class="line">  <span class="keyword">return</span>(json_content)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>其實不得不說，要不是因為有上班的地方願意讓我磨練，不然我可能連 api 是甚麼都還需要等到未來 2,3 年後我才能夠熟悉並且知道這些事物，也很謝謝<strong>高鈺成學長</strong>在我有些遇到狀況時會給我些許提示，然後專案報告真的好趕阿QwQ，希望我能夠如期做完，那就是最完美的了！謝謝 <strong>Luft 學長</strong> 幫我很多忙，也謝謝 steam 基礎教育聯盟給我機會學習。</p>
<h2 id="連結"><a href="#連結" class="headerlink" title="連結"></a>連結</h2><p>我在翻找資料的過程中，閱讀到一些對我非常有意義的資料。如下:</p>
<p><a href="https://rviews.rstudio.com/2018/07/23/rest-apis-and-plumber/" target="_blank" rel="noopener">REST APIs and Plumber</a><br><a href="https://www.rplumber.io/articles/routing-and-input.html" target="_blank" rel="noopener">Routing &amp; Input</a><br><a href="https://stackoverflow.com/questions/51944328/sending-json-file-in-curl-and-receiving-it-in-r-using-plumber/51945300#51945300" target="_blank" rel="noopener">Sending json file in curl and receiving it in R using plumber</a><br><a href="https://stackoverflow.com/questions/7172784/how-do-i-post-json-data-with-curl" target="_blank" rel="noopener">How do I POST JSON data with cURL?</a></p>
]]></content>
      <categories>
        <category>R語言</category>
      </categories>
      <tags>
        <tag>R語言</tag>
        <tag>學習筆記</tag>
        <tag>RESTAPI</tag>
      </tags>
  </entry>
  <entry>
    <title>ERROR! source(path) 裡面有中文字體時會出現無效位元的輸出解析</title>
    <url>/2020/08/12/R/R-chinese-bug/</url>
    <content><![CDATA[<h2 id="內容說明"><a href="#內容說明" class="headerlink" title="內容說明"></a>內容說明</h2><blockquote>
<p>寫程式的時候是不可能沒遇到 bug 的，bug 紀錄整理</p>
</blockquote>
<a id="more"></a>

<h2 id="ERROR-source-path-裡面有中文字體時會出現無效位元的輸出解析"><a href="#ERROR-source-path-裡面有中文字體時會出現無效位元的輸出解析" class="headerlink" title="ERROR: source(path) 裡面有中文字體時會出現無效位元的輸出解析"></a>ERROR: source(path) 裡面有中文字體時會出現無效位元的輸出解析</h2><blockquote>
<p>由於 R 對於漢字的不友善，使華語系國家需要使用其他方式來解決漢字問題。</p>
</blockquote>
<h3 id="solution-1"><a href="#solution-1" class="headerlink" title="solution 1:"></a>solution 1:</h3><p>嘗試用著各位前輩完成的方法</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="keyword">source</span>(path,encoding = <span class="string">"UTF-8"</span> , local=<span class="literal">TRUE</span>)</span><br></pre></td></tr></table></figure>
<h3 id="solution-2"><a href="#solution-2" class="headerlink" title="solution 2:"></a>solution 2:</h3><p>須將 source 改寫，透過 <code>R eval()</code>進行改寫，eval() 可將字串變成表達式(即 R 的程式碼)使用。<br>R 是可以進行覆寫的語言，可用這招來解決問題。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="keyword">source</span> &lt;- <span class="keyword">function</span>(path, encoding = <span class="string">'UTF-8'</span>) &#123;</span><br><span class="line">    l &lt;- readLines(path, encoding=encoding)</span><br><span class="line">    eval(parse(text=l),envir=.GlobalEnv)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">source</span>(path)</span><br></pre></td></tr></table></figure>
<p>envir = 環境<br>.GlobalEnv = 全域環境</p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://stackoverflow.com/questions/5031630/how-to-source-r-file-saved-using-utf-8-encoding" target="_blank" rel="noopener">How to source() .R file saved using UTF-8 encoding?</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>程式語言的世界博大精神，要是沒有他們的付出我能走上現在的路嗎?<br>肯定是沒辦法的，於是我也需要更努力地去為社會付出。</p>
]]></content>
      <categories>
        <category>R語言</category>
      </categories>
      <tags>
        <tag>R語言</tag>
        <tag>學習筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>QUESTION! data.frame 要 append 新 data 太麻煩，有沒有比較快的方法?</title>
    <url>/2020/08/12/R/R-data-frame-append-data/</url>
    <content><![CDATA[<h2 id="內容說明"><a href="#內容說明" class="headerlink" title="內容說明"></a>內容說明</h2><blockquote>
<p>寫程式的時候是不可能沒遇到 bug 的，bug 紀錄整理</p>
</blockquote>
<a id="more"></a>

<h2 id="QUESTION-data-frame-要-append-新-data-太麻煩，有沒有比較快的方法"><a href="#QUESTION-data-frame-要-append-新-data-太麻煩，有沒有比較快的方法" class="headerlink" title="QUESTION: data.frame 要 append 新 data 太麻煩，有沒有比較快的方法?"></a>QUESTION: data.frame 要 append 新 data 太麻煩，有沒有比較快的方法?</h2><h3 id="answer"><a href="#answer" class="headerlink" title="answer:"></a>answer:</h3><p>那肯定是有的，使用最新的 tribble，就可以搞定。但要記住一開始如果宣告的為空值則必須使用</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">t &lt;- tribble(x=character() , y=numeric())</span><br></pre></td></tr></table></figure>
<p>之後如果要加入資料就使使用</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">t &lt;- tribble(t , x=num , y = num)</span><br></pre></td></tr></table></figure>
<p><strong><font color="#dd0000">必須特別注意: 他要求型態，於是你每次 add 的資料型態都絕對必須要對，可以從這裡進行檢查</font></strong></p>
<h4 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h4><p><a href="https://stackoverflow.com/questions/48833807/initialize-an-empty-tibble-with-column-names-and-0-rows" target="_blank" rel="noopener">Initialize an empty tibble with column names and 0 rows</a><br><a href="https://github.com/tidyverse/tibble/issues/215" target="_blank" rel="noopener">Allow tribble to create empty tibble with defined column type</a><br><a href="https://tibble.tidyverse.org/reference/add_row.html" target="_blank" rel="noopener">Add rows to a data frame</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>程式語言的世界博大精神，要是沒有他們的付出我能走上現在的路嗎?<br>肯定是沒辦法的，於是我也需要更努力地去為社會付出。</p>
]]></content>
      <categories>
        <category>R語言</category>
      </categories>
      <tags>
        <tag>R語言</tag>
        <tag>學習筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>透過 httr 來使用 API 完成在 R 上的應用</title>
    <url>/2020/08/13/R/R-httr/</url>
    <content><![CDATA[<h2 id="內容說明"><a href="#內容說明" class="headerlink" title="內容說明"></a>內容說明</h2><blockquote>
<p>透過 httr 來方便 R 的使用者 post , get …。<br>以下紀錄 httr 在 R 上的應用與</p>
</blockquote>
<a id="more"></a>

<h2 id="安裝-httr"><a href="#安裝-httr" class="headerlink" title="安裝 httr"></a>安裝 httr</h2><p>當然需要安裝 httr 呀</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">install.packages(<span class="string">"httr"</span>)</span><br></pre></td></tr></table></figure>

<h2 id="教學範例"><a href="#教學範例" class="headerlink" title="教學範例"></a>教學範例</h2><p>我會記錄關於我所有用到的相關語法，會不斷進行補充</p>
<h3 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h3><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">object &lt;- POST(url , body=list(data) , timeout(seconds) , encode = c(<span class="string">"multipart"</span>,<span class="string">"text"</span> , <span class="string">"json"</span>),  accept_json())</span><br></pre></td></tr></table></figure>
<p><strong>url</strong> = 網址<br><strong>body</strong> 則放入你需要傳送給他的資料，EX: 密碼…<br><strong>timeout()</strong> 最多等待幾秒後就退出<br>程式範例如下 <code>body = list(a=1 , b=2 , c=3)</code><br><strong>encode</strong> 編碼有分</p>
<ol>
<li>multipart 多重</li>
<li>text 文字</li>
<li>json </li>
</ol>
<h3 id="傳進來的資料竟然只是資料介紹"><a href="#傳進來的資料竟然只是資料介紹" class="headerlink" title="傳進來的資料竟然只是資料介紹!"></a>傳進來的資料竟然只是資料介紹!</h3><p>傳進來的資料其實都還並不算是資料，應該算是「資料介紹」，需要再加 </p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">content(object)</span><br></pre></td></tr></table></figure>
<p>就可以了。</p>
<h3 id="將傳進來的資料轉換成-json"><a href="#將傳進來的資料轉換成-json" class="headerlink" title="將傳進來的資料轉換成 json"></a>將傳進來的資料轉換成 json</h3><p>則需要些比較麻煩的方式，然後注意 <strong>encoding</strong> 必須正確。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="keyword">library</span>(jsonlite)</span><br><span class="line">data_json &lt;- jsonlite::fromJSON(content(data , type=<span class="string">"text"</span> , encoding=<span class="string">"UTF8"</span>))</span><br></pre></td></tr></table></figure>

<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://community.rstudio.com/t/get-timeout-error-httr-package-error-in-curl/21349" target="_blank" rel="noopener">GET Timeout Error - httr package - Error in Curl</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>httr 真的很好用，他是我在學 R 過程中最容易上手的 ಥ⌣ಥ。能夠將難的東西變成簡單，我真的敬佩那些人的能力。比起 igraph 真的好用太多..，不過應該是我不會用拉，我沒慧根。</p>
]]></content>
      <categories>
        <category>R語言</category>
      </categories>
      <tags>
        <tag>R語言</tag>
        <tag>學習筆記</tag>
        <tag>RESTAPI</tag>
      </tags>
  </entry>
  <entry>
    <title>ERROR! A 物件無法轉成 B 物件</title>
    <url>/2020/08/12/R/R-objectA-convert-to-objectB/</url>
    <content><![CDATA[<h2 id="內容說明"><a href="#內容說明" class="headerlink" title="內容說明"></a>內容說明</h2><blockquote>
<p>寫程式的時候是不可能沒遇到 bug 的，bug 紀錄整理</p>
</blockquote>
<a id="more"></a>

<h2 id="ERROR-A-物件無法轉成-B-物件"><a href="#ERROR-A-物件無法轉成-B-物件" class="headerlink" title="ERROR: A 物件無法轉成 B 物件"></a>ERROR: A 物件無法轉成 B 物件</h2><h3 id="solution-1"><a href="#solution-1" class="headerlink" title="solution 1:"></a>solution 1:</h3><p>上網查找其他替代語法或套件進行解決。</p>
<h3 id="solution-2"><a href="#solution-2" class="headerlink" title="solution 2:"></a>solution 2:</h3><p>也許有可能是你其他套件與此語法一樣，但並不支持 A 物件轉成 B 物件，嘗試考慮在前面加上 namespace，EX: 套件::語法()</p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>程式語言的世界博大精神，要是沒有他們的付出我能走上現在的路嗎?<br>肯定是沒辦法的，於是我也需要更努力地去為社會付出。</p>
]]></content>
      <categories>
        <category>R語言</category>
      </categories>
      <tags>
        <tag>R語言</tag>
        <tag>學習筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux R 在 install packages 遇到的問題集</title>
    <url>/2020/07/24/R/R-server-install-package/</url>
    <content><![CDATA[<h2 id="內容說明"><a href="#內容說明" class="headerlink" title="內容說明"></a>內容說明</h2><blockquote>
<p>以 <strong>CentOS 6</strong> 為例，在這會遇到非常多關於 R server 要安裝套件時遇到的問題，在這邊進行記錄。</p>
</blockquote>
<a id="more"></a>

<h2 id="Warning-關於-Install-Packages-的萬用解"><a href="#Warning-關於-Install-Packages-的萬用解" class="headerlink" title="Warning: 關於 Install Packages 的萬用解"></a>Warning: 關於 Install Packages 的萬用解</h2><p>可先嘗試用此方法，假如不行再根據下面錯誤改變</p>
<h3 id="solution-1"><a href="#solution-1" class="headerlink" title="solution 1"></a>solution 1</h3><p>嘗試用此方法</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">install.packages(<span class="string">"packages"</span>, dependencies = <span class="literal">TRUE</span>)</span><br></pre></td></tr></table></figure>
<h3 id="連結"><a href="#連結" class="headerlink" title="連結"></a>連結</h3><p><a href="https://stackoverflow.com/questions/20923209/problems-installing-the-devtools-package" target="_blank" rel="noopener">Problems installing the devtools package</a></p>
<h2 id="Warning-unable-to-access-index-for-repository-https-cran-csie-ntu-edu-tw-src-contrib"><a href="#Warning-unable-to-access-index-for-repository-https-cran-csie-ntu-edu-tw-src-contrib" class="headerlink" title="Warning: unable to access index for repository https://cran.csie.ntu.edu.tw/src/contrib"></a>Warning: unable to access index for repository <a href="https://cran.csie.ntu.edu.tw/src/contrib" target="_blank" rel="noopener">https://cran.csie.ntu.edu.tw/src/contrib</a></h2><h3 id="solution-1-1"><a href="#solution-1-1" class="headerlink" title="solution 1:"></a>solution 1:</h3><p>嘗試看看至 chooseCRANmirror() 然後再使用 http ， <strong><font color="#dd0000">注意，並不是 https</font></strong></p>
<h4 id="連結-1"><a href="#連結-1" class="headerlink" title="連結"></a>連結</h4><h2 id="Warning-message-package-‘magrittr’-is-not-available-for-R-version-3-2-0"><a href="#Warning-message-package-‘magrittr’-is-not-available-for-R-version-3-2-0" class="headerlink" title="Warning message: package ‘magrittr’ is not available (for R version 3.2.0)"></a>Warning message: package ‘magrittr’ is not available (for R version 3.2.0)</h2><h3 id="solution-1-2"><a href="#solution-1-2" class="headerlink" title="solution 1:"></a>solution 1:</h3><p>透過 Bioconductor ，嘗試並下載或更新套件包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source(&quot;http:&#x2F;&#x2F;bioconductor.org&#x2F;biocLite.R&quot;)</span><br><span class="line">biocLite(&quot;包名&quot;)</span><br></pre></td></tr></table></figure>
<h4 id="連結-2"><a href="#連結-2" class="headerlink" title="連結"></a>連結</h4><p><a href="https://blog.csdn.net/yepeng2007fei/article/details/78112557" target="_blank" rel="noopener">R语言 关于package’***’ is not available(for R version 3.4.1)</a></p>
<h2 id="Warning"><a href="#Warning" class="headerlink" title="Warning"></a>Warning</h2>]]></content>
      <categories>
        <category>R語言</category>
      </categories>
      <tags>
        <tag>R語言</tag>
        <tag>學習筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 shinyapps 建立網站</title>
    <url>/2020/07/28/R/R-shinyapps-experence/</url>
    <content><![CDATA[<h2 id="內容說明"><a href="#內容說明" class="headerlink" title="內容說明"></a>內容說明</h2><blockquote>
<p>shinyapps 也是一個說坑不坑，建立起來速度很快，但是又有很多小細節要處理。<br>以下紀錄 shinyapps 怎麼建立網站與<strong><font color="#dd0000">需要注意的地方</font></strong></p>
</blockquote>
<a id="more"></a>

<h2 id="前置作業"><a href="#前置作業" class="headerlink" title="前置作業"></a>前置作業</h2><ul>
<li>需要有 R </li>
<li>需要註冊 shinyapps 這<a href="https://ithelp.ithome.com.tw/articles/10197292" target="_blank" rel="noopener">網站</a>教學不錯，建議點擊</li>
<li>you need server.R and ui.R </li>
</ul>
<h2 id="安裝教學"><a href="#安裝教學" class="headerlink" title="安裝教學"></a>安裝教學</h2><ol>
<li><p>首先需要安裝 rsconnect</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">install.packages(&quot;rsconnect&quot;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>點擊<a href="https://ithelp.ithome.com.tw/articles/10197292" target="_blank" rel="noopener">網站</a>查看關於 shinyapps 的教學</p>
</li>
<li><p>執行!<br>很簡單吧，一下子就完成了。這時候直接按 R studio 右上角的 run 即可，如果測試成功後，可直接點擊發布</p>
</li>
<li><p>發布<br><img src="/images/R-shinyapps-experence/1.PNG" alt=""><br>先點擊右上角的紅色圈圈，跳出視窗後點擊 publish，稍等一刻就可以看到結果拉！</p>
</li>
</ol>
<h2 id="錯誤排除"><a href="#錯誤排除" class="headerlink" title="錯誤排除"></a>錯誤排除</h2><h3 id="等等，為甚麼我出來的是一段英文字母不是我的網頁阿"><a href="#等等，為甚麼我出來的是一段英文字母不是我的網頁阿" class="headerlink" title="等等，為甚麼我出來的是一段英文字母不是我的網頁阿"></a>等等，為甚麼我出來的是一段英文字母不是我的網頁阿</h3><p>漂亮，兄弟。你已進入到 shinyapps 深淵中的第一步，還有好多步在等著你喔 QwQ。<br><img src="/images/R-shinyapps-experence/2.PNG" alt=""></p>
<h3 id="所有程式碼都必須要用-utf-8-編碼"><a href="#所有程式碼都必須要用-utf-8-編碼" class="headerlink" title="所有程式碼都必須要用 utf-8 編碼"></a>所有程式碼都必須要用 utf-8 編碼</h3><p>只要是需要上傳至 shinyapps 的都必須需要使用 utf-8 編碼，否則無法上傳成功。並在 source 屬性內加入 local=TRUE</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="keyword">source</span>(path , local=<span class="literal">TRUE</span>)</span><br></pre></td></tr></table></figure>

<h3 id="有用到其他檔案，但是無法推送給-server-成功"><a href="#有用到其他檔案，但是無法推送給-server-成功" class="headerlink" title="有用到其他檔案，但是無法推送給 server 成功"></a>有用到其他檔案，但是無法推送給 server 成功</h3><p>這就需要特別注意了，這邊我也是花了約 1 小時才找出問題，如果你需要用到其他檔案<strong>一定要在 server.R and ui.R 的目錄層下</strong>，不然他沒辦法跑動。<br>P.S. 我猜測她是會直接把 server.R and ui.R 裡面的資料全部推送給 shinyapps。</p>
<h3 id="如果你真的很需要很需要用到中文，那怎麼辦"><a href="#如果你真的很需要很需要用到中文，那怎麼辦" class="headerlink" title="如果你真的很需要很需要用到中文，那怎麼辦?"></a>如果你真的很需要很需要用到中文，那怎麼辦?</h3><p>目前根據我的嘗試，你只要能夠將中文放在 server.R 或是 其他 source，是可以成功出現中文字體。其他方式我還沒嘗試需要各位的努力拉!</p>
<h4 id="連結說明"><a href="#連結說明" class="headerlink" title="連結說明"></a>連結說明</h4><p><a href="https://dotblogs.com.tw/Im_sqz777/2017/07/26/220713" target="_blank" rel="noopener">Web 基本觀念 - 相對路徑 和 絕對路徑</a><br><a href="https://support.rstudio.com/hc/en-us/articles/229848967-Why-does-my-app-work-locally-but-not-on-shinyapps-io-" target="_blank" rel="noopener">為什麼我的應用程序可以在本地運行，而不能在Shinyapps.io上運行？</a></p>
<h3 id="程式若有提到路徑則全必須使用相對路徑"><a href="#程式若有提到路徑則全必須使用相對路徑" class="headerlink" title="程式若有提到路徑則全必須使用相對路徑"></a>程式若有提到路徑則全必須使用相對路徑</h3><p>如果你是使用絕對路徑，非常高的機率會出錯，可以去 shinyapps 的 log 檔查看，應該會出現</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Warning: Error in file: 無法開啟連結</span><br></pre></td></tr></table></figure>
<p>這裡使用相對路徑則沒有問題</p>
<h3 id="如果有從外部加入檔案，但檔案編碼並非是-utf-8-則需要特別注意"><a href="#如果有從外部加入檔案，但檔案編碼並非是-utf-8-則需要特別注意" class="headerlink" title="如果有從外部加入檔案，但檔案編碼並非是 utf-8 則需要特別注意"></a>如果有從外部加入檔案，但檔案編碼並非是 utf-8 則需要特別注意</h3><p>我這次的經驗為 csv 編碼是用 big5，所以當我程式碼都有使用 utf-8 編碼時，他還是跟我說這裡出現問題，在我花了許多時間去除錯後，根據其他大佬得出如果外部檔案並非使用 utf-8，必須先在將檔案讀入程式時增加 fileEncoding = “編碼代號”，即可完成。</p>
<h4 id="連結說明-1"><a href="#連結說明-1" class="headerlink" title="連結說明"></a>連結說明</h4><p><a href="https://www.ptt.cc/bbs/R_Language/M.1421390552.A.D5C.html" target="_blank" rel="noopener">讀取csv檔的小問題</a><br><a href="https://stackoverflow.com/questions/14363085/invalid-multibyte-string-in-read-csv" target="_blank" rel="noopener">Invalid multibyte string in read.csv</a></p>
<h2 id="我覺得這應該會很有用，但是我現在還用不到"><a href="#我覺得這應該會很有用，但是我現在還用不到" class="headerlink" title="我覺得這應該會很有用，但是我現在還用不到"></a>我覺得這應該會很有用，但是我現在還用不到</h2><p>由於我在翻找資料的過程中，找到一篇文章。感覺會對未來有幫助，所以先留下來<br><a href="https://d.cosx.org/d/412685-shinyapps" target="_blank" rel="noopener">[已解决] shinyapps 的中文显示问题</a></p>
<h2 id="R-shiny-一些小技巧"><a href="#R-shiny-一些小技巧" class="headerlink" title="R shiny 一些小技巧"></a>R shiny 一些小技巧</h2><p>可以的話，盡量不要將資料寫在 mainpanel，寫在 tabPanel，可以少掉一些使用者如果來回點擊網頁時，先前網頁的畫面內容殘留。</p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>其實要很感謝寫 shiny 套件，還讓我們免費發佈在 shinyapps 的強大團隊，才有辦法讓我僅僅只使用 R，就可以讓我獨自一人建立網站，雖然有很多坑、很多雷點，但是其實只要修復好了，我對於雷點甚麼的就沒那麼怨恨XD，雖然當下還是會不開心拉，但是現在的我因為有 shiny 幫助我，反而更開心！也謝謝北市大教授 <strong>魏惠貞</strong> 給我機會讓我學習到，真的很謝謝老師。</p>
<h2 id="更新日誌"><a href="#更新日誌" class="headerlink" title="更新日誌"></a>更新日誌</h2><p>2020-07-20 14:45:16 - 建立文章<br>2020-07-28 20:42:25 - 增加錯誤排除</p>
<ol>
<li>有用到其他檔案，但是無法推送給 server 成功</li>
<li>如果你真的很需要很需要用到中文，那怎麼辦?</li>
<li>所有程式碼都必須要用 utf-8 編碼</li>
</ol>
]]></content>
      <categories>
        <category>R語言</category>
      </categories>
      <tags>
        <tag>R語言</tag>
        <tag>學習筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>R-teach</title>
    <url>/2020/05/01/R/R-teach/</url>
    <content><![CDATA[<h2 id="主要"><a href="#主要" class="headerlink" title="主要"></a>主要</h2><p>此網頁主要是在幫助大衛在 北市大幼保系研究助理期間中所遇到的 R 語言問題。</p>
<p>並非教學用，但學習資源會在這並透過我加以整理。</p>
<ol>
<li><a href="https://cran.r-project.org/bin/windows/base/" target="_blank" rel="noopener">R download</a></li>
<li><a href="https://rstudio.com/products/rstudio/download/" target="_blank" rel="noopener">Rstudio download</a></li>
<li><a href="https://joe11051105.gitbooks.io/r_basic/content/environment_settings/RStudio_introduction.html" target="_blank" rel="noopener">Rstudio introduction</a></li>
<li><a href="https://cosx.org/2009/07/studying-notes-on-oop-in-r/" target="_blank" rel="noopener">R_oop</a></li>
<li><a href="https://blog.gtwang.org/r/r-vectors-matrices-and-arrays/" target="_blank" rel="noopener">R_vector</a></li>
<li><a href="https://ithelp.ithome.com.tw/articles/10197004" target="_blank" rel="noopener">使用 R 與 C# 開發網站</a></li>
<li><a href="https://molecular-service-science.com/2015/08/01/r-shiny-business-intelligence-tutorial/" target="_blank" rel="noopener">R shiny 套件可運用在網頁上</a></li>
<li><a href="https://shiny.rstudio.com/reference/shiny/latest/" target="_blank" rel="noopener">shiny 語法大全</a></li>
<li><a href="https://shiny.rstudio.com/gallery/" target="_blank" rel="noopener">shiny 套版</a></li>
<li><a href="https://github.com/daattali/shinyjs/issues/16" target="_blank" rel="noopener">useShinyjs() in navbarPage()</a></li>
<li><a href="https://stackoverflow.com/questions/40621393/disabling-buttons-in-shiny" target="_blank" rel="noopener">Disabling buttons in Shiny</a></li>
<li><a href="https://statistics.berkeley.edu/computing/r-t-tests" target="_blank" rel="noopener">R test 圖表繪製</a></li>
<li><a href="http://yanping.me/shiny-tutorial" target="_blank" rel="noopener">中文教程：用R构建Shiny应用程序</a></li>
</ol>
]]></content>
      <categories>
        <category>R語言</category>
      </categories>
      <tags>
        <tag>R語言</tag>
        <tag>學習筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa10050 - Combination Lock (水題)</title>
    <url>/2020/03/30/UVa/UVa10050/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意:"></a>題目大意:</h2><blockquote>
<p>解保險箱鎖盤，透過他獨家的開鎖方式，試問你需要轉幾度，</p>
<ol>
<li>先轉順時鐘兩圈</li>
<li>順時鐘轉到第 1 個密碼</li>
<li>逆時鐘再轉一圈</li>
<li>逆時鐘轉第二個密碼</li>
<li>順時鐘轉第三個密碼</li>
</ol>
</blockquote>
<a id="more"></a>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析:"></a>分析:</h2><p>在開鎖時，必定要轉 3 圈，所以角度 必定是 360*3。</p>
<font color="#dd0000">
當順時鐘在轉時，但表其實是逆時鐘，我理解了很久才能理解 (作者理解力還需加強)

<p>Ex: 0度 轉至 30度<br>A:  你會覺得 應該是轉了 30度，但不是這樣的。<br>    對於表的指針來說，實際上只轉了 10度。 (酷吧)</p>
<p>逆時鐘則將 0 , 30 互換即可，意思大同小異。<br></font></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">int</span> a, b, c, d ;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d &amp;&amp; (a + b + c + d) != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> calibration = <span class="number">120</span>;</span><br><span class="line">        calibration += (<span class="number">40</span> + a - b ) % <span class="number">40</span> ;</span><br><span class="line">        calibration += (<span class="number">40</span> - b + c ) % <span class="number">40</span> ;</span><br><span class="line">        calibration += (<span class="number">40</span> + c - d ) % <span class="number">40</span> ;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; calibration * <span class="number">9</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>水題</tag>
        <tag>UVa</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa10036 - Divisibility (動態規劃)</title>
    <url>/2020/03/17/UVa/UVa10036/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意:"></a>題目大意:</h2><blockquote>
<p>給你 n 個數字 與 x ，在 n 個數字中加上 - or + ， 判斷組合後的總合是否可以被 x 整除?</p>
</blockquote>
<a id="more"></a>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析:"></a>分析:</h2><p>可能很多人會想排列組合，但會TLE</p>
<p><font color="#dd0000"><strong>但是，想法其實只要在稍微思考一下就能想通了 <del>(除非你太笨)</del></strong></font></p>
<p>每一次在幫數字做 加減法後餘數儲存至二維陣列，狀態轉移即可 (是不是不難阿)</p>
<p>可寫成 DP 遞迴式， Dp[y + 1 , intNum[i] % x  ]= DP[ y , intNum[i] ]</p>
<p>其中 y 為第 n 個數字， intNum 為 數字隊列。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> intMap[<span class="number">10010</span>][<span class="number">110</span>] = &#123;<span class="number">0</span>&#125; ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">non_negative</span><span class="params">(<span class="keyword">int</span> intNum , <span class="keyword">int</span> K , <span class="keyword">int</span> J)</span></span>&#123;</span><br><span class="line">    <span class="comment">//debug</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; intNum &lt;&lt; ' ' ;</span></span><br><span class="line"></span><br><span class="line">    intNum = (intNum + J ) % K ;</span><br><span class="line">    <span class="keyword">while</span>(intNum &lt; <span class="number">0</span>)</span><br><span class="line">        intNum += K ;</span><br><span class="line">    <span class="keyword">return</span> intNum % K ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_map</span><span class="params">(<span class="keyword">int</span> *intMap , <span class="keyword">int</span> N , <span class="keyword">int</span> K)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; N ; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; K ; j++)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; *(intMap + i + j) &lt;&lt; <span class="string">' '</span> ;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> );</span><br><span class="line">    freopen(<span class="string">"out.txt"</span> , <span class="string">"w"</span> , <span class="built_in">stdout</span> );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">int</span> intCase , N , K ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; intCase ;</span><br><span class="line">    <span class="keyword">while</span>(intCase--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; K ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//debug</span></span><br><span class="line">        <span class="comment">//cout &lt;&lt; N &lt;&lt; K ;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> intNum[N] ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**&lt; debug</span></span><br><span class="line"><span class="comment">        for(int i = 0 ; i &lt; N ; i++)&#123;</span></span><br><span class="line"><span class="comment">            for(int j = 0 ; j &lt; K ; j++)</span></span><br><span class="line"><span class="comment">                cout &lt;&lt; intMap[i][j] &lt;&lt; ' ' ;</span></span><br><span class="line"><span class="comment">            cout &lt;&lt; '\n' ;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//debug</span></span><br><span class="line">        <span class="comment">//print_map((int *)intMap , N , K ) ;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; N ; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; K ; j++)</span><br><span class="line">                intMap[i][j] = <span class="number">0</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; N ; i++)</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; intNum[i] ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**&lt;//debug</span></span><br><span class="line"><span class="comment">        for(int i = 0 ; i &lt; N ; i++)</span></span><br><span class="line"><span class="comment">            cout &lt;&lt; intNum[i] &lt;&lt; ' ' ;</span></span><br><span class="line"><span class="comment">        cout &lt;&lt; '\n' ;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        intMap[<span class="number">0</span>][non_negative(intNum[<span class="number">0</span>], K , <span class="number">0</span> )] = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; N ; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; K ; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(intMap[i<span class="number">-1</span>][j])&#123;</span><br><span class="line">                    intMap[i][ non_negative(intNum[i], K , j ) ] = <span class="number">1</span> ;</span><br><span class="line">                    intMap[i][ non_negative(-intNum[i], K , j ) ] = <span class="number">1</span> ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//debug</span></span><br><span class="line">        <span class="comment">//print_map((int *)intMap , N , K ) ;</span></span><br><span class="line">        <span class="comment">//cout &lt;&lt; intMap[N-1][0] &lt;&lt; '\n' ;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(intMap[N<span class="number">-1</span>][<span class="number">0</span>])</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Divisible"</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Not divisible"</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>動態規劃 Dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa10101 - Bangla Numbers (水題)</title>
    <url>/2020/04/09/UVa/UVa10101/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>給一數字，用題目獨家的單位詞做輸出</p>
</blockquote>
<a id="more"></a>

<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>透過遞迴 (recursive)，來幫助 x lakh y kuti。<br>數字要開 long long</p>
<p><del>本人覺得這題我寫得很好，但可能會被其他大神嫌棄</del></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recursive</span><span class="params">(<span class="built_in">string</span> strInt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len , intCout ;</span><br><span class="line">    <span class="comment">// hajar 10000000</span></span><br><span class="line">    len = strInt.length() - <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">if</span>(len &gt; <span class="number">0</span> )&#123;</span><br><span class="line">        recursive(strInt.substr(<span class="number">0</span>,len));</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">" kuti"</span> ;</span><br><span class="line">        strInt = strInt.substr(strInt.length()<span class="number">-7</span> , <span class="number">7</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// lakh 100000</span></span><br><span class="line">    len = strInt.length() - <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">if</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        intCout = stoi(strInt.substr(<span class="number">0</span>,len));</span><br><span class="line">        <span class="keyword">if</span>(intCout)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; intCout &lt;&lt; <span class="string">" lakh"</span>;</span><br><span class="line">        strInt = strInt.substr(strInt.length()<span class="number">-5</span> , <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// hajar 1000</span></span><br><span class="line">    len = strInt.length() - <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        intCout = stoi(strInt.substr(<span class="number">0</span>, len));</span><br><span class="line">        <span class="keyword">if</span>(intCout)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; intCout &lt;&lt; <span class="string">" hajar"</span>;</span><br><span class="line">        strInt = strInt.substr(strInt.length()<span class="number">-3</span> , <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// shata 100</span></span><br><span class="line">    len = strInt.length() - <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        intCout = stoi(strInt.substr(<span class="number">0</span>,len));</span><br><span class="line">        <span class="keyword">if</span>(intCout)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; intCout &lt;&lt; <span class="string">" shata"</span>;</span><br><span class="line">        strInt = strInt.substr(strInt.length()<span class="number">-2</span> , <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(stoi(strInt))</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; stoi(strInt) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"out.txt"</span> , <span class="string">"w"</span> , <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="built_in">string</span> strInt;</span><br><span class="line">    <span class="keyword">int</span> intCase=<span class="number">1</span> , len , intTemp;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; strInt)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">4</span>- to_string(intCase).length() ; i++ )</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> ;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; intCase++ &lt;&lt; <span class="string">"."</span> ;</span><br><span class="line">        recursive(strInt);</span><br><span class="line">        <span class="keyword">if</span>(strInt == <span class="string">"0"</span>)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">" 0"</span> ;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>水題</tag>
        <tag>UVa</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa10010 - Where&#39;s Waldorf? (動態規劃)</title>
    <url>/2020/03/16/UVa/UVa10010/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意:"></a>題目大意:</h2><blockquote>
<p>給你一張圖，再給你x個單字，這些單字必定會在圖中出現，請輸入單字的第一個字母再圖中的哪個位置? ( 如果有重複的，輸出最左上的 )</p>
</blockquote>
<a id="more"></a>


<h2 id="分析"><a href="#分析" class="headerlink" title="分析:"></a>分析:</h2><p><font color = "dd0000">  <del>麻煩的</del> DFS </font></p>
<p>逐行檢查每一個字元，與8個方向，邏輯夠好，就能很快解出</p>
<p>Hint: 但第一個字元確定好方向，之後就必須依照這個方向檢查</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> arrGraph[<span class="number">52</span>][<span class="number">52</span>] = &#123;&#125; ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//debug</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_map</span><span class="params">(<span class="keyword">int</span> n , <span class="keyword">int</span> m )</span></span>&#123;</span><br><span class="line">    <span class="comment">//debug print map</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; i++ )&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= m ; j++)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; arrGraph[i][j] ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">intact_letter</span><span class="params">(<span class="built_in">string</span> strLine , <span class="keyword">int</span> intLine_Index , <span class="keyword">int</span> intDirection , <span class="keyword">int</span> n , <span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(strLine.length()<span class="number">-1</span> == intLine_Index )&#123;</span><br><span class="line">        <span class="comment">//debug</span></span><br><span class="line">        <span class="comment">//cout &lt;&lt; strLine &lt;&lt; intLine_Index &lt;&lt; '\n' ;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( intDirection == <span class="number">1</span>  &amp;&amp; arrGraph[n<span class="number">-1</span>][m<span class="number">-1</span>] == strLine[intLine_Index +<span class="number">1</span> ])</span><br><span class="line">        <span class="keyword">return</span> intact_letter(strLine , intLine_Index +<span class="number">1</span> , <span class="number">1</span> , n<span class="number">-1</span>,m<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( intDirection == <span class="number">2</span>  &amp;&amp; arrGraph[n<span class="number">-1</span>][m] == strLine[intLine_Index +<span class="number">1</span> ])</span><br><span class="line">        <span class="keyword">return</span> intact_letter(strLine , intLine_Index +<span class="number">1</span> , <span class="number">2</span> , n<span class="number">-1</span>,m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( intDirection == <span class="number">3</span>  &amp;&amp; arrGraph[n<span class="number">-1</span>][m+<span class="number">1</span>] == strLine[intLine_Index +<span class="number">1</span> ])</span><br><span class="line">        <span class="keyword">return</span> intact_letter(strLine , intLine_Index +<span class="number">1</span> , <span class="number">3</span> , n<span class="number">-1</span>,m+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( intDirection == <span class="number">4</span> &amp;&amp; arrGraph[n][m<span class="number">-1</span>] == strLine[intLine_Index +<span class="number">1</span> ])</span><br><span class="line">        <span class="keyword">return</span> intact_letter(strLine , intLine_Index +<span class="number">1</span> , <span class="number">4</span> , n,m<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( intDirection == <span class="number">5</span>  &amp;&amp; arrGraph[n+<span class="number">1</span>][m<span class="number">-1</span>] == strLine[intLine_Index +<span class="number">1</span> ])</span><br><span class="line">        <span class="keyword">return</span> intact_letter(strLine , intLine_Index +<span class="number">1</span> , <span class="number">5</span> , n+<span class="number">1</span>,m<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( intDirection == <span class="number">6</span>  &amp;&amp; arrGraph[n+<span class="number">1</span>][m] == strLine[intLine_Index +<span class="number">1</span> ])</span><br><span class="line">        <span class="keyword">return</span> intact_letter(strLine , intLine_Index +<span class="number">1</span> , <span class="number">6</span> , n+<span class="number">1</span>,m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( intDirection == <span class="number">7</span>  &amp;&amp; arrGraph[n+<span class="number">1</span>][m+<span class="number">1</span>] == strLine[intLine_Index +<span class="number">1</span> ])</span><br><span class="line">        <span class="keyword">return</span> intact_letter(strLine , intLine_Index +<span class="number">1</span> , <span class="number">7</span> , n+<span class="number">1</span>,m+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( intDirection == <span class="number">8</span>  &amp;&amp; arrGraph[n][m+<span class="number">1</span>] == strLine[intLine_Index +<span class="number">1</span> ])</span><br><span class="line">        <span class="keyword">return</span> intact_letter(strLine , intLine_Index +<span class="number">1</span> , <span class="number">8</span> , n,m+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search_letter</span><span class="params">( <span class="built_in">string</span> strLine , <span class="keyword">int</span> n , <span class="keyword">int</span> m )</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; i++ )&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= m ; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arrGraph[i][j] == strLine[<span class="number">0</span>] )&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span> ; k &lt; <span class="number">9</span> ; k++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(intact_letter(strLine , <span class="number">0</span> , k , i , j))&#123;</span><br><span class="line">                        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">' '</span> &lt;&lt; j &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">                        <span class="keyword">return</span> ;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>,<span class="string">"r"</span> , <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">int</span> indicating , n , m , k , isInit= <span class="number">0</span> ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; indicating ;</span><br><span class="line">    <span class="built_in">string</span> strLine ;</span><br><span class="line">    <span class="keyword">while</span>(indicating--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(isInit)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">        isInit = <span class="number">1</span> ;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; strLine ;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= m ; j++)&#123;</span><br><span class="line">                arrGraph[i][j] = <span class="built_in">tolower</span>(strLine[j<span class="number">-1</span>]) ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//debug</span></span><br><span class="line">        <span class="comment">//print_map(n,m);</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; k ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; k ; i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; strLine ;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; k ; i++)</span><br><span class="line">                strLine[i] = <span class="built_in">tolower</span>(strLine[i]);</span><br><span class="line">            search_letter(strLine , n , m);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>圖論</tag>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>String Processing Problems</tag>
        <tag>Competitive Programming3</tag>
        <tag>動態規劃 Dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa10221 - Satellites (數論 Math theorm)</title>
    <url>/2020/03/17/UVa/UVa10221/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意:"></a>題目大意:</h2><blockquote>
<p>如圖，給你圓上兩點夾角，和點圓心的距離<br>求出兩點的弧長與弦長。</p>
</blockquote>
<a id="more"></a>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析:"></a>分析:</h2><p><font color = "#dd0000" >分水嶺，看出來你先學會數學在學會程式 還是 先學會程式在學會數學(我是後者 QQ ) </font></p>
<p>對於本人來說是，非常難的一題阿！！！！ (我真笨，想不到數學弦長，餘弦定理)</p>
<p>如果你也不知道餘弦定理，沒關係可以的，我幫你找到傳送門了 &rarr; <a href="https://zh.wikipedia.org/wiki/%E9%A4%98%E5%BC%A6%E5%AE%9A%E7%90%86" target="_blank" rel="noopener">餘弦定理</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> minutes = minute of angle not time minutes</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span>) ;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="built_in">string</span> strA ;</span><br><span class="line">    <span class="keyword">double</span> a , s , douArc , douChord ;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; s &gt;&gt; a &gt;&gt; strA )&#123;</span><br><span class="line">        <span class="keyword">if</span>(strA == <span class="string">"min"</span>)</span><br><span class="line">            a /= <span class="number">60</span> ;</span><br><span class="line">        s += <span class="number">6440</span> ;</span><br><span class="line">        <span class="keyword">if</span>(a &gt; <span class="number">180</span>)</span><br><span class="line">            a = <span class="number">360</span> - a ;</span><br><span class="line">        douArc = <span class="number">2</span> * s * <span class="number">2</span> * <span class="built_in">acos</span>(<span class="number">0</span>) * a / <span class="number">360</span> ;</span><br><span class="line">        douChord = <span class="built_in">sqrt</span>(s * s + s * s - <span class="number">2</span> * s * s * <span class="built_in">cos</span>(<span class="number">2</span>*<span class="built_in">acos</span>(<span class="number">0</span>) * a / <span class="number">180</span> ) ) ;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; fixed &lt;&lt; setprecision(<span class="number">6</span>) &lt;&lt; douArc &lt;&lt; <span class="string">' '</span> &lt;&lt; douChord &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>水題</tag>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>數論 Math theorm</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa10530 - Guessing Game (水題)</title>
    <url>/2020/03/17/UVa/UVa10530/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意:"></a>題目大意:</h2><blockquote>
<p><strong>玩猜數字</strong></p>
<p><font color = "#dd0000" > *<em>是得你沒看錯，這應該是我看過 UVa 最簡單的題目了 *</em> </font></p>
<p>不過要注意的是:<br>還要看這個小屁孩，要不要說謊www</p>
</blockquote>
<a id="more"></a> 

<h2 id="分析"><a href="#分析" class="headerlink" title="分析:"></a>分析:</h2><p>不斷更新上下界，如果她說謊了，就告訴他，他是 <font color="#dd0000">Lier </font></p>
<p>需要注意的是: 當我說 8 too high 的話， 8 也算是太高喔</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> ) ;</span><br><span class="line">    freopen(<span class="string">"out.txt"</span> , <span class="string">"w"</span> , <span class="built_in">stdout</span> );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">int</span> intMax= <span class="number">11</span> , intMin = <span class="number">0</span> , isRight = <span class="number">1</span> , n ;</span><br><span class="line">    <span class="built_in">string</span> strLine ;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d\n"</span> , &amp;n ) &amp;&amp; n )&#123;</span><br><span class="line">        getline(<span class="built_in">cin</span> , strLine ) ;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (strLine == <span class="string">"right on"</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(intMax &lt;= n || intMin &gt;= n)</span><br><span class="line">                isRight = <span class="number">0</span> ;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(isRight)</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"Stan may be honest"</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"Stan is dishonest"</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//debug</span></span><br><span class="line">            <span class="comment">//cout &lt;&lt; intMax &lt;&lt; ' ' &lt;&lt; intMin &lt;&lt; ' ' &lt;&lt; n &lt;&lt; '\n' ;</span></span><br><span class="line"></span><br><span class="line">            isRight = <span class="number">1</span> ;</span><br><span class="line">            intMax = <span class="number">11</span> ;</span><br><span class="line">            intMin = <span class="number">0</span> ;</span><br><span class="line">            <span class="keyword">continue</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(strLine == <span class="string">"too high"</span> &amp;&amp; intMax &gt; n )&#123;</span><br><span class="line">            intMax = n ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (strLine == <span class="string">"too low"</span> &amp;&amp; intMin &lt; n )&#123;</span><br><span class="line">            intMin = n ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>水題</tag>
        <tag>UVa</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa1056 - Degrees of Separation (Floyd)</title>
    <url>/2020/03/12/UVa/UVa1056/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意:"></a>題目大意:</h2><blockquote>
<p>有一個大型的人類組織社會，詢問人與人的最大距離為何? 如果沒有的話，輸出 “DISCONNECTED”。</p>
</blockquote>
<a id="more"></a> 

<h2 id="分析"><a href="#分析" class="headerlink" title="分析:"></a>分析:</h2><p><font color = "#dd0000"> 人名需要雜湊喔 ε٩(๑&gt; ₃ &lt;)۶з </font></p>
<p>由於是 All-Pairs Shortest Path 問題，所以這題使用 Floyd-Warshall algorithm 解題</p>
<p>甚麼!? 你不知道 Floyd! <a href="https://zh.wikipedia.org/wiki/Floyd-Warshall%E7%AE%97%E6%B3%95" target="_blank" rel="noopener"><del>那你先去看影片</del></a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 99999999</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span> , <span class="keyword">int</span>&gt; mapMember ;</span><br><span class="line"><span class="keyword">int</span> intPath[<span class="number">55</span>][<span class="number">55</span>] ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> );</span><br><span class="line">    freopen(<span class="string">"out.txt"</span> , <span class="string">"w"</span> , <span class="built_in">stdout</span> );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">int</span> P , R , intCase = <span class="number">1</span> , intHash ;</span><br><span class="line">    <span class="built_in">string</span> strNameA , strNameB ;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; P &gt;&gt; R)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!(P + R))</span><br><span class="line">            <span class="keyword">break</span> ;</span><br><span class="line">        mapMember.clear() ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= P ; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= P ; j++)</span><br><span class="line">                intPath[i][j] = INF ;</span><br><span class="line">        &#125;</span><br><span class="line">        intHash = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; R ; i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; strNameA &gt;&gt; strNameB ;</span><br><span class="line">            <span class="keyword">if</span>(!mapMember[strNameA])</span><br><span class="line">                mapMember[strNameA] = intHash++ ;</span><br><span class="line">            <span class="keyword">if</span>(!mapMember[strNameB])</span><br><span class="line">                mapMember[strNameB] = intHash++ ;</span><br><span class="line">            intPath[ mapMember[strNameA] ][ mapMember[strNameB] ] = <span class="number">1</span> ;</span><br><span class="line">            intPath[ mapMember[strNameA] ][ mapMember[strNameA] ] = <span class="number">0</span> ;</span><br><span class="line">            intPath[ mapMember[strNameB] ][ mapMember[strNameA] ] = <span class="number">1</span> ;</span><br><span class="line">            intPath[ mapMember[strNameB] ][ mapMember[strNameB] ] = <span class="number">0</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//floyd</span></span><br><span class="line">        <span class="keyword">int</span> intMax = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= P ; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j  = <span class="number">1</span> ; j &lt;= P ; j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span> ; k &lt;= P ; k++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(intPath[j][k] &gt; intPath[j][i] + intPath[i][k])&#123;</span><br><span class="line">                        intPath[j][k] = intPath[j][i] + intPath[i][k] ;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= P ; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= P ; j++)&#123;</span><br><span class="line">                intMax = max(intPath[i][j] , intMax);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(intMax == INF)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Network "</span> &lt;&lt; intCase++ &lt;&lt; <span class="string">": "</span> &lt;&lt; <span class="string">"DISCONNECTED"</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Network "</span> &lt;&lt; intCase++ &lt;&lt; <span class="string">": "</span> &lt;&lt; intMax &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>Floyd-Warshall algorithm</tag>
        <tag>UVa</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa10603 - Fill (Dijkstra)</title>
    <url>/2020/03/17/UVa/UVa10603/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意:"></a>題目大意:</h2><blockquote>
<p>有 3 個杯子， a , b , c ，以及目標水量 d ， 一開始只有 c 裝滿了水，其他為空，透過倒入杯子&gt;的方式，來讓其他的杯子加滿水，試問能否達到 d ，要是不行，給出最接近數。</p>
<p>輸出要求：輸出最符合 d 的水量與達到 d 的最小倒水量。</p>
</blockquote>
<a id="more"></a>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析:"></a>分析:</h2><p>膜拜 劉汝佳 大佬，邏輯分析師</p>
<img src="https://pic1.xuehuaimg.com/proxy/csdn/https://img-blog.csdn.net/20170804143214141?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzQ4NDUwODI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="UVa10603.jpg">

<p><font color= "#dd0000"> <del>要是你還是看不懂，我建議你跳過，這對現在的你太難了</del> </font></p>
<p>沒有拉，開玩笑地。 不過這題確實有點小難。</p>
<p>不過老實說，包裝得很好，這題由 Dijkstra’s 可以得出，不過要記得的是， Dijkstra’s 的缺點就是，容易造成效率的低落，權重很重要。 </p>
<p>所以善用 priority_queue ， priority_queue 寫得好，程式沒煩惱！</p>
<h3 id="備註"><a href="#備註" class="headerlink" title="備註:"></a>備註:</h3><p>這裡有兩個蠻推薦的網站，寫得不錯，有些我這裡沒有補充倒的，可以查看這裡的網頁</p>
<p><a href="https://theriseofdavid.github.io/2020/03/11/UVa929/" target="_blank" rel="noopener">大衛的筆記-UVa929 - Number Maze (圖論，Dijkstra’s，優先隊列)</a></p>
<p><a href="https://www.twblogs.net/a/5b87da1e2b71775d1cd945e5" target="_blank" rel="noopener">UVA 10603 Fill(狀態空間搜索，倒水問題)</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 220</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> visit[MAXN][MAXN] , ans[MAXN] , cap[<span class="number">5</span>] , d ;</span><br><span class="line"><span class="comment">// https://www.twblogs.net/a/5b87da1e2b71775d1cd945e5</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">status</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> jug[<span class="number">3</span>] , vol ;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> status&amp; rhs ) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> vol &gt; rhs.vol ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;status&gt; p ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update_ans</span><span class="params">(status s )</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">3</span> ; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> d = s.jug[i] ;</span><br><span class="line">        <span class="keyword">if</span>(ans[d] &lt; <span class="number">0</span> )</span><br><span class="line">            ans[d] = s.vol ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    status s , cs ; <span class="comment">// cs copy_s</span></span><br><span class="line">    s.jug[<span class="number">0</span>] = <span class="number">0</span> ; s.jug[<span class="number">1</span>] = <span class="number">0</span> ; s.jug[<span class="number">2</span>] = cap[<span class="number">2</span>] ; s.vol = <span class="number">0</span> ;</span><br><span class="line">    p.push(s) ;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">while</span>(!p.empty())&#123;</span><br><span class="line">        s = p.top() ;</span><br><span class="line">        p.pop() ;</span><br><span class="line">        update_ans(s);</span><br><span class="line">        visit[s.jug[<span class="number">0</span>]][s.jug[<span class="number">1</span>]] = <span class="number">1</span> ;</span><br><span class="line">        <span class="comment">//debug</span></span><br><span class="line">        <span class="comment">//cout &lt;&lt; "" &lt;&lt; s.jug[0] &lt;&lt; ' ' &lt;&lt; s.jug[1] &lt;&lt; ' ' &lt;&lt; s.jug[2] &lt;&lt; ' ' &lt;&lt; s.vol &lt;&lt; '\n' ;</span></span><br><span class="line">        <span class="keyword">if</span>(ans[d] &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span> ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">3</span> ; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; <span class="number">3</span> ; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i == j || s.jug[j] == cap[j] || s.jug[i] == <span class="number">0</span>) <span class="comment">// e.v[j] == cap[j] this cup water is full , so it doesn't have any water</span></span><br><span class="line">                    <span class="keyword">continue</span> ;</span><br><span class="line">                cs = s ;</span><br><span class="line">                temp = min(cap[j] , s.jug[i] + s.jug[j]) -s.jug[j] ;</span><br><span class="line">                cs.jug[i] -= temp ;</span><br><span class="line">                cs.jug[j] += temp ;</span><br><span class="line">                cs.vol += temp ;</span><br><span class="line">                <span class="keyword">if</span>(!visit[cs.jug[<span class="number">0</span>]][cs.jug[<span class="number">1</span>]])&#123;</span><br><span class="line">                    p.push(cs);</span><br><span class="line">                    <span class="comment">//debug</span></span><br><span class="line">                    <span class="comment">//cout &lt;&lt; cs.jug[0] &lt;&lt; ' ' &lt;&lt; cs.jug[1] &lt;&lt; ' ' &lt;&lt; cs.jug[2] &lt;&lt; ' ' &lt;&lt; cs.vol &lt;&lt; '\n' ;</span></span><br><span class="line">                    <span class="comment">//cout &lt;&lt; visit[cs.jug[0]][cs.jug[1]] &lt;&lt; '\n' ;</span></span><br><span class="line">                    <span class="comment">//cout &lt;&lt; &amp;s &lt;&lt; ' ' &lt;&lt; &amp;cs &lt;&lt; '\n' ;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(d&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ans[d] != <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; ans[d] &lt;&lt; <span class="string">' '</span> &lt;&lt; d &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">            <span class="keyword">break</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        d-- ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">int</span> n ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; cap[<span class="number">0</span>] &gt;&gt; cap[<span class="number">1</span>] &gt;&gt; cap[<span class="number">2</span>] &gt;&gt; d ;</span><br><span class="line">        <span class="built_in">memset</span>(visit , <span class="number">0</span> , <span class="keyword">sizeof</span>(visit)) ;</span><br><span class="line">        <span class="built_in">memset</span>(ans , <span class="number">-1</span> , <span class="keyword">sizeof</span>(ans)) ;</span><br><span class="line">        <span class="keyword">while</span>(!p.empty()) <span class="comment">// priority_queue doesn't have clear</span></span><br><span class="line">            p.pop() ;</span><br><span class="line">        bfs() ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>圖論</tag>
        <tag>UVa</tag>
        <tag>Dijkstra&#39;s</tag>
        <tag>優先隊列</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa10810 - Ultra-QuickSort</title>
    <url>/2020/03/18/UVa/UVa10810/</url>
    <content><![CDATA[<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意:"></a>題目大意:</h2><blockquote>
<p>排序一個數組，但只能左右交換，試問數組最少要交換幾次。</p>
</blockquote>
<a id="more"></a> 

<h2 id="分析"><a href="#分析" class="headerlink" title="分析:"></a>分析:</h2><p><font color = "#dd0000"> <del><strong>這題真的好賤，上面寫著 QuickSort 結果是 MergeSort， 這代表經驗真的還是只能相信，不能先入為主阿</strong></del> </font></p>
<p>QuickSort 是在每一次分治 (divide) 的時候，就已經分好大小邊，<br>但 MergeSort 是不斷分治，直到不能再做分治後，才開始進行排序，透過此優點，所以很容易推算出左右交換的次數，加上 MergeSort 的複雜度也跟 QuickSort 一樣，所以一樣可以完成此問題！</p>
<p>需要注意的點是: 由於他最大的是 500050 ， 最複雜的排序可能來到 O ( \({n^2}\) )， 所以要使用 long long 以防溢位(overflow) 。</p>
<p><a href="https://www.youtube.com/watch?v=mB5HXBb_HY8&t" target="_blank" rel="noopener">MergeSort - Abdul Bari</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long int</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> intNum[<span class="number">500050</span>] , intTemp[<span class="number">500050</span>] ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> l , <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="comment">//debug</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; l &lt;&lt; ' ' &lt;&lt; r &lt;&lt; '\n';</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    ll L , R ;</span><br><span class="line">    L = merge_sort(l , (r+l)/<span class="number">2</span>) ;</span><br><span class="line">    R = merge_sort( (r+l) /<span class="number">2</span> +<span class="number">1</span> , r );</span><br><span class="line">    <span class="keyword">int</span> intP_Start , intQ_Start , intP_End , intPosition ;</span><br><span class="line">    intP_Start = l ;</span><br><span class="line">    intP_End = (r+l) /<span class="number">2</span> ;</span><br><span class="line">    intQ_Start = intP_End +<span class="number">1</span> ;</span><br><span class="line">    intPosition = l ;</span><br><span class="line">    <span class="keyword">while</span>(intPosition &lt;= r )&#123;</span><br><span class="line">        <span class="keyword">if</span>(intQ_Start &lt;= r &amp;&amp; (intP_Start &gt; intP_End || intNum[intQ_Start] &lt; intNum[intP_Start] ) )&#123;</span><br><span class="line">            intTemp[intPosition++] = intNum[intQ_Start++] ;</span><br><span class="line">            L += intP_End - intP_Start + <span class="number">1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            intTemp[intPosition++] = intNum[intP_Start++] ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = l ; i &lt;= r ; i++)</span><br><span class="line">        intNum[i] = intTemp[i] ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//debug</span></span><br><span class="line">    <span class="comment">//for(int i = 0 ; i &lt; 10 ; i++)</span></span><br><span class="line">    <span class="comment">//    cout &lt;&lt; intNum[i] &lt;&lt; ' ' ;</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; '\n' ;</span></span><br><span class="line">    <span class="keyword">return</span> L + R ;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> );</span><br><span class="line">    freopen(<span class="string">"out.txt"</span> , <span class="string">"w"</span> , <span class="built_in">stdout</span> );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">int</span> n ;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n &amp;&amp; n )&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i++)</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; intNum[i] ;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; merge_sort(<span class="number">0</span> , n<span class="number">-1</span> ) &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>Merge-sort</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa11220 - Decoding the message (水題)</title>
    <url>/2020/03/19/UVa/UVa11220/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意:"></a>題目大意:</h2><blockquote>
<p>會給很多英文單字，第 x 個的英文單字中找出第 x 的字元，之後再將它印出。</p>
</blockquote>
<a id="more"></a> 

<h2 id="分析"><a href="#分析" class="headerlink" title="分析:"></a>分析:</h2><p><font color = "dd0000"> <strong>這題要是不會，我建議你先去看初學者影片 (良心推薦)</strong> </font></p>
<p>我覺得這題不需要解釋，也沒人看我解釋，模擬操作就好了，對吧?</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"out.txt"</span> , <span class="string">"w"</span> , <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">int</span> intCase , n , intPosition ;</span><br><span class="line">    <span class="built_in">string</span> strWord , strAns , strLine ;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vecAns ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; intCase ;</span><br><span class="line">    n = <span class="number">1</span> ;</span><br><span class="line">    getline(<span class="built_in">cin</span> , strLine ) ;</span><br><span class="line">    getline(<span class="built_in">cin</span> , strLine ) ;</span><br><span class="line">    <span class="keyword">while</span>(getline(<span class="built_in">cin</span> , strLine ))&#123;</span><br><span class="line">        <span class="comment">//debug</span></span><br><span class="line">        <span class="comment">//cout &lt;&lt; strLine &lt;&lt; '\n' ;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(strLine != <span class="string">""</span>)&#123;</span><br><span class="line">            <span class="built_in">stringstream</span> ss ;</span><br><span class="line">            ss.str(<span class="string">""</span>);</span><br><span class="line">            ss.clear() ;</span><br><span class="line">            ss &lt;&lt; strLine ;</span><br><span class="line">            intPosition = <span class="number">0</span> ;</span><br><span class="line">            strAns = <span class="string">""</span> ;</span><br><span class="line">            <span class="keyword">while</span>(ss &gt;&gt; strWord)&#123;</span><br><span class="line">                <span class="comment">//debug-</span></span><br><span class="line">                <span class="comment">//cout &lt;&lt; strWord &lt;&lt; '\n' ;</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(strWord.length() &gt; intPosition)&#123;</span><br><span class="line">                    strAns += strWord[intPosition++] ;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//debug</span></span><br><span class="line">                    <span class="comment">//cout &lt;&lt; strAns &lt;&lt; '\n' ;</span></span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            vecAns.push_back(strAns) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Case #"</span> &lt;&lt; n++ &lt;&lt; <span class="string">":"</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; vecAns.size()<span class="number">-1</span> ; i++)</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; vecAns[i] &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; vecAns[vecAns.size()<span class="number">-1</span>] ;</span><br><span class="line">            <span class="keyword">if</span>(n<span class="number">-1</span> != intCase)</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">            vecAns.clear() ;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>水題</tag>
        <tag>UVa</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa11349 - Symmetric Matrix</title>
    <url>/2020/03/19/UVa/UVa11349/</url>
    <content><![CDATA[<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意:"></a>題目大意:</h2><blockquote>
<p>給你一個正方形矩陣 M ， 你必須判斷矩陣是否對稱 (symmetric)</p>
<p>矩陣定義: 矩陣內部元素不會有負數，且是對中間點對稱</p>
</blockquote>
<a id="more"></a>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析:"></a>分析:</h2><p>這題的包裝手法，個人覺得非常之妙阿，小弟我的能力太差了!</p>
<p>由於此題的定義是僅限對 「中心點」 對稱，你可以發現，但你將它變成一維陣列表示時，會發現它其實是一個迴文！ 太神奇了，高手中的高手阿</p>
<p>解開的方式就中間切一半，然後開始判斷是否迴文就可以了。</p>
<h3 id="陷阱"><a href="#陷阱" class="headerlink" title=" 陷阱 : "></a><font color="#dd0000"> 陷阱 : </font ></h3><p>有兩點需要特別注意，這題有骯髒的手法wwww</p>
<ol>
<li>cin 的值會有負數，但矩陣內禁止有負號需特別注意</li>
<li>元素的值為 \({-2^{32} }\) &lt;= \(M_{ij} \) &lt;= \({2^{32}}\)，超出int的範圍(\({-2^{31}}\) &lt;= int &lt;= <font color = "dd0000"> \({2^{31}-1}\) </font >)，所以必須使用 long long 處理。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">ll llnNum[<span class="number">12100</span>] ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>,<span class="string">"r"</span> , <span class="built_in">stdin</span>) ;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">int</span> intCase , n , t , intLen ;</span><br><span class="line">    <span class="built_in">string</span> strNon ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; intCase ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//debug</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; intCase &lt;&lt; '\n' ;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> t = <span class="number">1</span> ; t &lt;= intCase ; t++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; strNon &gt;&gt; strNon &gt;&gt; n ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//debug</span></span><br><span class="line">        <span class="comment">//cout &lt;&lt; n &lt;&lt; '\n' ;</span></span><br><span class="line"></span><br><span class="line">        intLen = n * n ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; intLen ; i++)</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; llnNum[i] ;</span><br><span class="line">        <span class="keyword">int</span> isFlag = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; intLen /<span class="number">2</span>+<span class="number">1</span> ; i++)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//debug</span></span><br><span class="line">            <span class="comment">//cout &lt;&lt; intNum[i] &lt;&lt; ' ' &lt;&lt; intNum[intLen-i-1] &lt;&lt; '\n' ;</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(llnNum[i] != llnNum[intLen-i<span class="number">-1</span>] || llnNum[i] &lt; <span class="number">0</span> || llnNum[intLen-i<span class="number">-1</span>] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                isFlag = <span class="number">0</span> ;</span><br><span class="line">                <span class="keyword">break</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//debug</span></span><br><span class="line">        <span class="comment">//cout &lt;&lt; isFlag &lt;&lt; '\n' ;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isFlag)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Test #"</span> &lt;&lt; t &lt;&lt; <span class="string">": Symmetric."</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Test #"</span> &lt;&lt; t &lt;&lt; <span class="string">": Non-symmetric."</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>創新題</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa11541 - Decoding (水題)</title>
    <url>/2020/03/20/UVa/UVa11541/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意:"></a>題目大意:</h2><blockquote>
<p>輸入是一串 (英文，數字) * n 的組合</p>
<p>輸出 英文字 * n</p>
</blockquote>
<a id="more"></a> 

<h2 id="分析"><a href="#分析" class="headerlink" title="分析:"></a>分析:</h2><p><font color = "#dd0000"> <strong>簡單到一個不行的題目 <del>，這題千萬不要問我解釋</del></strong> </font></p>
<p>使用 for 即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">decode</span><span class="params">(<span class="built_in">string</span> strLetter , <span class="keyword">int</span> intCount )</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; intCount ; i++ )</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; strLetter ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>,<span class="string">"r"</span> , <span class="built_in">stdin</span>) ;</span><br><span class="line">    freopen(<span class="string">"out.txt"</span> , <span class="string">"w"</span> , <span class="built_in">stdout</span> ) ;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">int</span> intCase ;</span><br><span class="line">    <span class="built_in">string</span> strLine , strLetter , strCount ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; intCase ; <span class="built_in">cin</span>.ignore() ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> t = <span class="number">1</span> ; t &lt;= intCase ; t++)&#123;</span><br><span class="line">        getline(<span class="built_in">cin</span> , strLine) ;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Case "</span> &lt;&lt; t &lt;&lt; <span class="string">": "</span> ;</span><br><span class="line">        strCount = <span class="string">"0"</span> ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; strLine.length() ; i++ )&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isalpha</span>(strLine[i]))&#123;</span><br><span class="line">               decode(strLetter , stol(strCount)) ;</span><br><span class="line">               strLetter = strLine[i] ;</span><br><span class="line">               strCount = <span class="string">""</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                strCount += strLine[i] ;</span><br><span class="line">        &#125;</span><br><span class="line">        decode(strLetter , stol(strCount));</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>水題</tag>
        <tag>UVa</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa11636 - Hello World! (水題)</title>
    <url>/2020/03/30/UVa/UVa11636/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意:"></a>題目大意:</h2><blockquote>
<p>一開始給你一段句子，你只能透過 「複製 (copy)」 方式，複製出 x 段句子</p>
<p>給你一數字 x ，試問在幾次後可以複製可達到 x 個句子？</p>
</blockquote>
<a id="more"></a>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析:"></a>分析:</h2><p>只需要不斷複製 *2 即可完成，每一次都可以全句複製已達到複製的兩倍量。</p>
<p>再透過陣列預先處理即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> num[<span class="number">10010</span>] ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"out.txt"</span> , <span class="string">"w"</span> , <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">1</span> , step = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; <span class="number">10010</span> ; i++)&#123;</span><br><span class="line">        num[i] = step ;</span><br><span class="line">        <span class="keyword">if</span>(i == n)&#123;</span><br><span class="line">            n = n &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            step++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    step = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n &amp;&amp; n &gt;= <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Case "</span> &lt;&lt; step &lt;&lt; <span class="string">": "</span> &lt;&lt; num[n] &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">        step++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>水題</tag>
        <tag>UVa</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa11678 - Cards&#39; Exchange (水題)</title>
    <url>/2020/03/20/UVa/UVa11678/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意:"></a>題目大意:</h2><blockquote>
<p>兩個非常可愛的小女孩，想要玩交換卡片的遊戲 (ﾉ&gt;ω&lt;)ﾉ</p>
<p>可是他們不想拿到的重複卡片，試問他們最多可以交換幾張卡片。 </p>
</blockquote>
<a id="more"></a> 

<h2 id="分析"><a href="#分析" class="headerlink" title="分析:"></a>分析:</h2><p><font color = "#dd0000"> 水到不行的水題 </font></p>
<p>Step</p>
<ol>
<li>使用集合 (排除重複 (muliple) )</li>
<li>差集 (set_difference) </li>
<li>求差集後的總元素</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; A , B , diff_A , diff_B ;</span><br><span class="line">    <span class="keyword">int</span> x , y , intTemp ;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y &amp;&amp; x &amp;&amp; y)&#123;</span><br><span class="line">        A.clear() ;</span><br><span class="line">        B.clear() ;</span><br><span class="line">        diff_A.clear() ;</span><br><span class="line">        diff_B.clear() ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; x ; i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; intTemp ;</span><br><span class="line">            A.insert(intTemp) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; y ; i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; intTemp ;</span><br><span class="line">            B.insert(intTemp) ;</span><br><span class="line">        &#125;</span><br><span class="line">        set_difference(A.begin() , A.end() , B.begin() , B.end() , inserter(diff_A, diff_A.begin()) ) ;</span><br><span class="line">        set_difference(B.begin() , B.end() , A.begin() , A.end() , inserter(diff_B, diff_B.begin()) ) ;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; min(diff_A.size() , diff_B.size()) &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>水題</tag>
        <tag>UVa</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa11747 - Heavy Cycle Edges (Kruskal)</title>
    <url>/2020/03/20/UVa/UVa11747/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意:"></a>題目大意:</h2><blockquote>
<p>無向圖，之後生成 Minimum Spanning Tree (最小生成樹)</p>
</blockquote>
<a id="more"></a>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析:"></a>分析:</h2><p>Kruskal 是你最好的朋友，暴力簡單又方便</p>
<p><del>~ Prim</del> 禁止，會搞死你的 ，我一開始還想用 Prim 來解呢~~</p>
<h2 id="備註"><a href="#備註" class="headerlink" title="備註:"></a>備註:</h2><p>要是不知道 Kruskal 就看 <a href="https://www.youtube.com/watch?v=4ZlRH0eK-qQ" target="_blank" rel="noopener">Abdul Bari</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> parent[<span class="number">1020</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    ll n1 , n2 , w ;</span><br><span class="line">&#125;node[<span class="number">25020</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(edge A , edge B )</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> A.w &lt; B.w ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_root</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a != parent[a] )</span><br><span class="line">        <span class="keyword">return</span> parent[a] = find_root(parent[a]) ;</span><br><span class="line">    <span class="keyword">return</span> a ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> );</span><br><span class="line">    freopen(<span class="string">"out.txt"</span> , <span class="string">"w"</span> , <span class="built_in">stdout</span> );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">int</span> n , m , p_n1 , p_n2 ; <span class="comment">// parent_n1 , parent_n2</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; hce ; <span class="comment">//heavy edge circle</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &amp;&amp; n + m != <span class="number">0</span> )&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; m ; i++ )&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; node[i].n1 &gt;&gt; node[i].n2 &gt;&gt; node[i].w ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i++)</span><br><span class="line">            parent[i] = i ;</span><br><span class="line">        sort(node , node + m , compare ) ;</span><br><span class="line">        hce.clear() ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//kruskal</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; m ; i++)&#123;</span><br><span class="line">            p_n1 = find_root(node[i].n1) ;</span><br><span class="line">            p_n2 = find_root(node[i].n2) ;</span><br><span class="line">            <span class="keyword">if</span>(p_n1 != p_n2 )</span><br><span class="line">                parent[p_n2] = p_n1 ;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                hce.push_back(node[i].w) ;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//debug</span></span><br><span class="line">            <span class="comment">/**&lt;</span></span><br><span class="line"><span class="comment">            for(int i = 0 ; i &lt; n ; i++)</span></span><br><span class="line"><span class="comment">                cout &lt;&lt; parent[i] &lt;&lt; ' ' ;</span></span><br><span class="line"><span class="comment">            cout &lt;&lt; '\n' ;</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        &#125;</span><br><span class="line">        sort(hce.begin() , hce.end()) ;</span><br><span class="line">        <span class="keyword">if</span>(hce.size())&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; hce.size()<span class="number">-1</span> ; i++)</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; hce[i] &lt;&lt; <span class="string">' '</span> ;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; hce[hce.size()<span class="number">-1</span>] ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"forest"</span> ;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>Kruskal&#39;s algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa1207 - AGTC (LCS)</title>
    <url>/2020/03/13/UVa/UVa1207/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意:"></a>題目大意:</h2><blockquote>
<p>有 a , b 兩個字串求他們的 LCS(最長公共子序列) 最短修改數?</p>
</blockquote>
<a id="more"></a>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析:"></a>分析:</h2><p>LCS 與 LCS-less modify</p>
<img src = "https://imgur.com/pwPRhyI.jpg" alt ="UVa1207.jpg">

<p><font color = "dd0000"> 透過此圖可以了解 DP 原理 </font ></p>
<p>LCS 遞迴公式:</p>
<ul>
<li>LCS(x, y) =<ul>
<li>max( LCS( x-1, y ), LCS( x , y-1 ) ) , when str[x] != str[y]</li>
<li>LCS( x-1 , y-1 ) + e1                , when str[x] == sty[y]</li>
</ul>
</li>
</ul>
<p>LCS-less modify(LCS-lm) 遞迴公式:</p>
<ul>
<li>LCS-lm( x, y ) =<ul>
<li>min( LCS-lm( x , y ), LCS-lm( x , y) , LCS-lm( x-1 , y-1) ) +1 , when str[x] != str[y]</li>
<li>LCS-lm( x -1 , y -1 ) +1                , when str[x] == str[y]</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LCS</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> step , max_len ;</span><br><span class="line">&#125;Dp[<span class="number">5000</span>][<span class="number">5000</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">int</span> intX , intY , Min_step , Max_len ;</span><br><span class="line">    <span class="built_in">string</span> strX , strY ;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; intX &gt;&gt; strX &gt;&gt; intY &gt;&gt; strY )&#123;</span><br><span class="line">        <span class="comment">//init</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= intY ; i++)&#123;</span><br><span class="line">            Dp[<span class="number">0</span>][i].max_len = <span class="number">0</span> ;</span><br><span class="line">            Dp[<span class="number">0</span>][i].step = i ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= intX ; i++)&#123;</span><br><span class="line">            Dp[i][<span class="number">0</span>].max_len = <span class="number">0</span> ;</span><br><span class="line">            Dp[i][<span class="number">0</span>].step = i ;</span><br><span class="line">        &#125;</span><br><span class="line">        Max_len = <span class="number">0</span> ;</span><br><span class="line">        Min_step = <span class="number">0</span> ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//lcs</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= intX ; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= intY ; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(strX[i<span class="number">-1</span>] == strY[j<span class="number">-1</span>])&#123;</span><br><span class="line">                    Dp[i][j].max_len = Dp[i<span class="number">-1</span>][j<span class="number">-1</span>].max_len +<span class="number">1</span> ;</span><br><span class="line">                    Dp[i][j].step = Dp[i<span class="number">-1</span>][j<span class="number">-1</span>].step ;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//debug</span></span><br><span class="line">                    <span class="comment">//cout &lt;&lt; strX[i-1] &lt;&lt; ' ' &lt;&lt; strY[j-1] &lt;&lt; ' ' &lt;&lt; Dp[i][j].max_len &lt;&lt; '\n' ;</span></span><br><span class="line">                    <span class="comment">//cout &lt;&lt; strX[i-1] &lt;&lt; ' ' &lt;&lt; strY[j-1] &lt;&lt; ' ' &lt;&lt; Dp[i][j].step &lt;&lt; '\n' ;</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    Dp[i][j].max_len = max(Dp[i<span class="number">-1</span>][j].max_len , Dp[i][j<span class="number">-1</span>].max_len ) ;</span><br><span class="line">                    Dp[i][j].step = min( min(Dp[i<span class="number">-1</span>][j<span class="number">-1</span>].step , Dp[i][j<span class="number">-1</span>].step ) , Dp[i<span class="number">-1</span>][j].step ) +<span class="number">1</span> ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; Dp[intX][intY].step &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>最長共同子序列 Longest Common Subsequence</tag>
        <tag>動態規劃 Dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa12096 - The SetStack Computer</title>
    <url>/2020/03/23/UVa/UVa12096/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>模擬一個集合的堆疊計算機。該計算機有5種指令</p>
<ol>
<li>PUSH：新增一個{}空集合到 Stack</li>
<li>DUP：複製 Stack 的 Top 集合，再Push到 Stack</li>
<li>ADD：將 Stack Pop 2個集合，最先 Pop 的集合 a 和第 2 個 Pop 的集合 b，將集合 a 加入至集合 b 後再 Push 到 Stack</li>
<li>UNION：將 Stack Pop 2 個集合做 Union 後，再 Push 到 Stack</li>
<li>INTERSECT：將Stack Pop 2個集合做Intersect後，再Push到Stack</li>
</ol>
<p>輸入有T筆測資，每筆測資會有 n 個前面 5 種的指令，每當一個指令完成後，要輸出目前 Stack Top  的集合的元素數量。當N個指令完成後，輸出 ***。</p>
</blockquote>
<a id="more"></a>

<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p><font color="#dd0000">這題我也是看其他優秀大神寫出來的，高手太多了，小弟我只是一個小孩子罷了。</font></p>
<p>STL 真的棒，省去底層的操作。</p>
<p>在操作 set 的過程中，請記住，不要就傻傻可愛的直接用 set ( set 裡面又有 set 的話，交、聯集的函式庫無法被使用的！)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; , <span class="keyword">int</span>&gt; mapSet ;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span> , <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; &gt; mapSetReverse ;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vecStack ;</span><br><span class="line"><span class="keyword">int</span> intHash ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">set_hash</span><span class="params">(<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; setTemp)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> &amp;intTemp = mapSet[setTemp] ;</span><br><span class="line">    <span class="keyword">if</span>(!intTemp)&#123;</span><br><span class="line">        mapSetReverse[intHash] = setTemp ;</span><br><span class="line">        intTemp = intHash++ ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> intTemp ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> );</span><br><span class="line">    freopen(<span class="string">"out.txt"</span> , <span class="string">"w"</span> , <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">int</span> t , n ;</span><br><span class="line">    <span class="built_in">string</span> strCommand  ;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; setA , setB , setC ;</span><br><span class="line">    <span class="keyword">int</span> intA , intB , intC ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t ;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">        intHash = <span class="number">1</span> ;</span><br><span class="line">        vecStack.clear() ;</span><br><span class="line">        mapSet.clear() ;</span><br><span class="line">        mapSetReverse.clear() ;</span><br><span class="line">        <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; strCommand ;</span><br><span class="line">            <span class="keyword">if</span>(strCommand == <span class="string">"PUSH"</span>)&#123;</span><br><span class="line">                setA = &#123;&#125; ;</span><br><span class="line">                vecStack.push_back(set_hash(setA)) ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(strCommand == <span class="string">"DUP"</span>)&#123;</span><br><span class="line">                vecStack.push_back(vecStack.back()) ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (strCommand == <span class="string">"UNION"</span>)&#123;</span><br><span class="line">                setA = mapSetReverse[vecStack.back()] ;</span><br><span class="line">                vecStack.pop_back() ;</span><br><span class="line">                setB = mapSetReverse[vecStack.back()] ;</span><br><span class="line">                vecStack.pop_back() ;</span><br><span class="line">                setC = &#123;&#125; ;</span><br><span class="line">                set_union(setA.begin() , setA.end() , setB.begin() , setB.end() , inserter(setC , setC.begin())) ;</span><br><span class="line">                vecStack.push_back(set_hash(setC)) ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (strCommand == <span class="string">"INTERSECT"</span>)&#123;</span><br><span class="line">                setA = mapSetReverse[vecStack.back()] ;</span><br><span class="line">                vecStack.pop_back() ;</span><br><span class="line">                setB = mapSetReverse[vecStack.back()] ;</span><br><span class="line">                vecStack.pop_back() ;</span><br><span class="line">                setC = &#123;&#125; ;</span><br><span class="line">                set_intersection(setA.begin() , setA.end() , setB.begin() , setB.end() , inserter(setC , setC.begin())) ;</span><br><span class="line">                vecStack.push_back(set_hash(setC)) ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(strCommand == <span class="string">"ADD"</span>)&#123;</span><br><span class="line">                intA = vecStack.back() ;</span><br><span class="line">                vecStack.pop_back() ;</span><br><span class="line">                setB = mapSetReverse[vecStack.back()] ;</span><br><span class="line">                vecStack.pop_back() ;</span><br><span class="line">                setB.insert(intA) ;</span><br><span class="line">                vecStack.push_back(set_hash(setB)) ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; mapSetReverse[vecStack.back()].size() &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"***"</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>創新題</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa12299 - RMQ with Shifts (Segment Tree)</title>
    <url>/2020/03/23/UVa/UVa12299/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>給予一個數組，有兩種操作</p>
<ol>
<li>query l r : 查詢 l 到 r 的最小值</li>
<li>shift x1 , x2 , x3 : 原本的值都往前循環一個位置</li>
</ol>
</blockquote>
<a id="more"></a>

<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>透過線段樹來維護最小值查詢，加上 shift 的數字最多只有 30 位，透過單點修改的方式即可完成。</p>
<h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><p>shift 給的是位置，並不是數值，也不一定給你的位置會是照順序，所以必須要進行 sort</p>
<h2 id="備註："><a href="#備註：" class="headerlink" title="備註："></a>備註：</h2><p>要是不知道 RMQ (Range Minimum/Maximum Query)) 就看 <a href="https://www.youtube.com/watch?v=c5O7E_PDO4U" target="_blank" rel="noopener">Tushar Roy - Coding Made Simple</a></p>
<p><del>印度人教程式真的強，不知道為甚麼感覺看中文的教學影片都比較沒辦法聽得懂阿，難道真的是語言的關係嗎QQ</del></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Lson(x) ((x &lt;&lt; 1) +1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Rson(x) ((x &lt;&lt; 1) +2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 99999999</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100005</span> ;</span><br><span class="line"><span class="keyword">int</span> shift[<span class="number">35</span>] , num[N] , len_shift ;</span><br><span class="line"><span class="built_in">string</span> strLine ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> left , right , Min_Value  ;</span><br><span class="line">&#125;node[<span class="number">4</span> * N ];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> left , <span class="keyword">int</span> right , <span class="keyword">int</span> x = <span class="number">0</span> )</span></span>&#123;</span><br><span class="line">    node[x].left = left ;</span><br><span class="line">    node[x].right = right ;</span><br><span class="line">    <span class="keyword">if</span>(left == right)&#123;</span><br><span class="line">        node[x].Min_Value = num[left] ;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (left + right ) / <span class="number">2</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//debug</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; mid &lt;&lt; '\n' ;</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; node[x].left &lt;&lt; ' ' &lt;&lt; node[x].right &lt;&lt; ' ' &lt;&lt; '\n' ;</span></span><br><span class="line"></span><br><span class="line">    build(left , mid , Lson(x)) ;</span><br><span class="line">    build(mid + <span class="number">1</span> , right , Rson(x)) ;</span><br><span class="line">    node[x].Min_Value = min(node[Lson(x)].Min_Value  , node[Rson(x)].Min_Value ) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handle</span><span class="params">()</span></span>&#123;</span><br><span class="line">    len_shift = <span class="number">0</span> ;</span><br><span class="line">    shift[len_shift] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">6</span> ; i &lt; strLine.length() ; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(strLine[i] &gt;= <span class="string">'0'</span> &amp;&amp; strLine[i] &lt;= <span class="string">'9'</span> )&#123;</span><br><span class="line">            shift[len_shift] = shift[len_shift] * <span class="number">10</span> + (<span class="keyword">int</span>) (strLine[i] - <span class="string">'0'</span> ) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            shift[++len_shift ] = <span class="number">0</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//finaly char is ')' , so len_shift is right</span></span><br><span class="line">    sort(shift , shift + len_shift ) ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//debug</span></span><br><span class="line">    <span class="comment">/**&lt;</span></span><br><span class="line"><span class="comment">    for(int i = 0 ; i &lt; len_shift ; i++)</span></span><br><span class="line"><span class="comment">        cout &lt;&lt; shift[i] &lt;&lt; ' ' ;</span></span><br><span class="line"><span class="comment">    cout &lt;&lt; '\n' ;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> left , <span class="keyword">int</span> right , <span class="keyword">int</span> x = <span class="number">0</span> )</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node[x].left &gt;= left &amp;&amp; node[x].right &lt;= right)</span><br><span class="line">        <span class="keyword">return</span> node[x].Min_Value ;</span><br><span class="line">    <span class="keyword">int</span> mid = (node[x].left + node[x].right ) / <span class="number">2</span> ;</span><br><span class="line">    <span class="keyword">int</span> ans = INF ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//debug</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; node[x].left &lt;&lt; ' ' &lt;&lt; node[x].right &lt;&lt; ' ' &lt;&lt; node[x].Min_Value &lt;&lt; '\n' ;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( left &lt;= mid )</span><br><span class="line">        ans = min(ans , query(left , right , Lson(x))) ;</span><br><span class="line">    <span class="keyword">if</span>(mid &lt; right )</span><br><span class="line">        ans = min(ans , query(left , right , Rson(x))) ;</span><br><span class="line">    <span class="keyword">return</span> ans ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_num</span><span class="params">(<span class="keyword">int</span> position , <span class="keyword">int</span> value , <span class="keyword">int</span> x = <span class="number">0</span> )</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node[x].left == position &amp;&amp; node[x].right == position )&#123;</span><br><span class="line">       node[x].Min_Value = value ;</span><br><span class="line">       <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (node[x].left + node[x].right ) / <span class="number">2</span> ;</span><br><span class="line">    <span class="keyword">if</span>(position &lt;= mid )</span><br><span class="line">        set_num(position , value , Lson(x) );</span><br><span class="line">    <span class="keyword">if</span>(mid &lt; position )</span><br><span class="line">        set_num(position , value , Rson(x)) ;</span><br><span class="line">    node[x].Min_Value = min(node[Lson(x)].Min_Value , node[Rson(x)].Min_Value );</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n , q , intTemp ;</span><br><span class="line">    ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"out.txt"</span> , <span class="string">"w"</span> , <span class="built_in">stdout</span> ) ;</span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> ) ;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; q ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; i++)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; num[i] ;</span><br><span class="line">    build(<span class="number">1</span>,n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//debug</span></span><br><span class="line">    <span class="comment">/**&lt;</span></span><br><span class="line"><span class="comment">    for(int i = 0 ; i &lt; 13 ; i++)&#123;</span></span><br><span class="line"><span class="comment">        cout &lt;&lt; node[i].left &lt;&lt; ' ' &lt;&lt; node[i].right &lt;&lt; ' ' &lt;&lt; node[i].Min_Value &lt;&lt; '\n' ;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    return 0 ;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; strLine ;</span><br><span class="line">        <span class="keyword">if</span>(strLine[<span class="number">0</span>] == <span class="string">'q'</span>)&#123;</span><br><span class="line">            handle();</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; query(shift[<span class="number">0</span>] , shift[<span class="number">1</span>] ) &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (strLine[<span class="number">0</span>] == <span class="string">'s'</span>)&#123;</span><br><span class="line">            handle();</span><br><span class="line">            intTemp = num[shift[<span class="number">0</span>]] ;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; len_shift ; i++)&#123;</span><br><span class="line">                set_num(shift[i<span class="number">-1</span>] , num[shift[i]]) ;</span><br><span class="line">                num[shift[i<span class="number">-1</span>]] = num[shift[i]] ;</span><br><span class="line">            &#125;</span><br><span class="line">            num[shift[len_shift<span class="number">-1</span>]] = intTemp ;</span><br><span class="line">            set_num(shift[len_shift<span class="number">-1</span>] , intTemp );</span><br><span class="line"></span><br><span class="line">            <span class="comment">//debug</span></span><br><span class="line">            <span class="comment">//cout &lt;&lt; intTemp &lt;&lt; ' ' &lt;&lt; shift[len_shift-1] &lt;&lt; '\n' ;</span></span><br><span class="line">            <span class="comment">//for(int i = 1 ; i &lt;= n ; i++)</span></span><br><span class="line">             <span class="comment">//   cout &lt;&lt; num[i] &lt;&lt; ' ' ;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>線段樹 Segment Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa12385 - Interesting Sequences (水題)</title>
    <url>/2020/04/28/UVa/UVa12385/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>給你一個數列，請找出 「Interesting Sequences」共有幾組。</p>
</blockquote>
<a id="more"></a>

<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>唉，看來我的英文能力需要增加。</p>
<p>「Interesting Sequences」 定義如下:</p>
<ol>
<li>在 Interesting Sequences 中頭尾數字一樣</li>
<li><del>不是每個 Interesting Sequences 的數字都要一樣</del></li>
</ol>
<p>ex1: 4 2 3 5 9 2 1 </p>
<ol>
<li>2 3 5 9 2 </li>
</ol>
<p>ex2: 3 2 3 1 3 2 3 2 2 2 2</p>
<ol>
<li>2 3 1 3 2</li>
<li>2 2  index: 8 9 </li>
<li>2 2  index: 9 10</li>
<li>2 2  index: 10 11</li>
</ol>
<p><font color="#ff0000"><strong>就這麼簡單，用「動態規劃」解決這題即可</strong></font></p>
<h4 id="DP規則如下-透過-greedy-優化-："><a href="#DP規則如下-透過-greedy-優化-：" class="headerlink" title="DP規則如下( 透過 greedy 優化 )："></a>DP規則如下( 透過 greedy 優化 )：</h4><ol>
<li>透過陣列記住每個數字最後的位置</li>
<li>last 做為上次 Interesting Sequences 的最後 index，因為 Interesting Sequences 不可以重疊。</li>
<li>如果 數字最後的位置 &gt;= last , ans +=1  </li>
</ol>
<h5 id="題外話"><a href="#題外話" class="headerlink" title="題外話:"></a>題外話:</h5><p>這題幾乎沒什麼人寫過，資源量好少，然後英文真的是不太好理解阿，花了 2、3 天才理解這題題意是甚麼</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"out.txt"</span> , <span class="string">"w"</span> , <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n ,t , last , ans , temp ;</span><br><span class="line">    <span class="keyword">int</span> num[<span class="number">100020</span>] = &#123;&#125; ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t ;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        last = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">100020</span> ; i++)</span><br><span class="line">            num[i] = <span class="number">-1</span> ;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; temp ;</span><br><span class="line">            <span class="keyword">if</span>( num[temp] &gt;= last)&#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//debug</span></span><br><span class="line">                <span class="comment">//cout &lt;&lt; "debug: " &lt;&lt;  i &lt;&lt; " last: " &lt;&lt; last &lt;&lt; '\n' ;</span></span><br><span class="line"></span><br><span class="line">                ans++ ;</span><br><span class="line">                last = i ;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            num[temp] = i ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>水題</tag>
        <tag>UVa</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa1262 - Password (水題)</title>
    <url>/2020/04/13/UVa/UVa1262/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>給你兩個 5*6 的表格，尋找這兩個表格的第 n 個 column 一樣的字母。<br>輸出第 x 個組合(透過字典序順序排列)</p>
</blockquote>
<a id="more"></a>

<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>明顯第一直覺就是排列組合，時間複雜度最多為 (6^4)，合理可接受範圍內。</p>
<p>我原本的做法是只記錄共同的字母，然後進行排列組合。 =&gt; <font color="#dd0000">程式碼不好維護</font></p>
<p><a href="https://geniustanley.github.io/2017/02/26/UVa-1262-Password/" target="_blank" rel="noopener">參考他的寫法後，覺得很棒。雖然時間複雜度比較高，但比較好維護</a></p>
<p>用二維陣列紀錄 Array[A-Z][column]，易讀易維護。</p>
<p><strong>看來我對於 C++ 還是不夠了解，沒辦法當機立下用最好、最易讀的解法</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> ax[<span class="number">30</span>][<span class="number">7</span>] = &#123;&#125; ;</span><br><span class="line"><span class="keyword">int</span> ay[<span class="number">30</span>][<span class="number">7</span>] = &#123;&#125; ;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; Ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> j , <span class="built_in">string</span> strAns)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(j == <span class="number">5</span>)&#123;</span><br><span class="line">        Ans.push_back(strAns);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">26</span> ; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ax[i][j] &amp;&amp; ay[i][j])</span><br><span class="line">            dfs(j+<span class="number">1</span> , strAns+ (<span class="keyword">char</span>)(<span class="string">'A'</span> + i));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span>) ;</span><br><span class="line">    freopen(<span class="string">"out.txt"</span> , <span class="string">"w"</span> , <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n , x ;</span><br><span class="line">    <span class="built_in">string</span> strLine ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        Ans.clear();</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">26</span> ; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; <span class="number">6</span> ; j++)&#123;</span><br><span class="line">                ax[i][j] = <span class="number">0</span>;</span><br><span class="line">                ay[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">6</span> ; i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; strLine;</span><br><span class="line">             <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; strLine.length() ; j++)&#123;</span><br><span class="line">                ax[strLine[j] - <span class="string">'A'</span>][j] = <span class="number">1</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">6</span> ; i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; strLine;</span><br><span class="line">             <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; strLine.length() ; j++)&#123;</span><br><span class="line">                ay[strLine[j] - <span class="string">'A'</span>][j] = <span class="number">1</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dfs(<span class="number">0</span>, <span class="string">""</span>);</span><br><span class="line">        <span class="keyword">if</span>(Ans.size() &lt; x)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"NO"</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; Ans[x<span class="number">-1</span>] &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>水題</tag>
        <tag>UVa</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa12918 - Lucky Thief (水題)</title>
    <url>/2020/06/09/UVa/UVa12918/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>小偷有 a 把 key 與 b 的房子，小偷想要找出 key 於房間的配對，每個 key 只能跟一個房間配對。</p>
<p>請告訴小偷，在有邏輯分析的情況下，小偷最少需要失敗幾次才能成功知道每個 key 要配每個房間。<br>P.S. a &lt;= b </p>
</blockquote>
<a id="more"></a>

<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p><strong>最非常簡單的題目，但是我竟然卡關了 20 分鐘…，老人家不給力阿。</strong></p>
<p>最後是向一個對數學敏感的朋友，才發現他只需要「嘗試失敗」，不需要計算成功次數。害我在那邊思考半天rrrrr</p>
<p>使用梯形公式 (上底 + 下底 ) * 高 /2 即可。(等差公式)</p>
<p>上底：(house -1 ) 因為最多只會失敗 house -1<br>下底：(house - key) 因為 key 數量就只有這麼多，後面的房子不需要常識。<br>高： (key) 乘以 key 數量</p>
<p>非常簡單，你一定也可以地啦！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll t ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t ;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        ll a , b;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b ;</span><br><span class="line">        ll sum ;</span><br><span class="line">        sum = ((b-a) + (b<span class="number">-1</span>))* a / <span class="number">2</span> ;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; sum &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>水題</tag>
        <tag>UVa</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa1583 - Digit Generator(暴力搜尋 Brute force )</title>
    <url>/2020/03/13/UVa/UVa1583/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意:"></a>題目大意:</h2><blockquote>
<p>給你一個數字，求出此數的原本 + 每個位數的 sum(總和)，假如有同時兩個數字符合需求時輸出最小值。<br>example: 216<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = (198 + 1 + 9 + 8 )<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = (207 + 2 + 0 + 7 )</p>
</blockquote>
<a id="more"></a>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析:"></a>分析:</h2><p><font color = "dd0000"> <strong>暴力、枚舉，唯一信仰</strong> </font></p>
<p>你覺得效率很差? 沒關係！ 電腦不在意。</p>
<p>先透過字典得方式建表，之後查表就好。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 99999999</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> intDict[<span class="number">200010</span>] = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> );</span><br><span class="line">    freopen(<span class="string">"out.txt"</span> , <span class="string">"w"</span> , <span class="built_in">stdout</span> );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">int</span> n , num , sum , intTemp ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">100000</span> ; i &gt; <span class="number">0</span> ; i-- )&#123;</span><br><span class="line">        intDict[i] = INF ;</span><br><span class="line">        sum = i ;</span><br><span class="line">        intTemp = i ;</span><br><span class="line">        <span class="keyword">while</span>(intTemp)&#123;</span><br><span class="line">            sum += intTemp % <span class="number">10</span> ;</span><br><span class="line">            intTemp /= <span class="number">10</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(intDict[sum] &gt; i  )</span><br><span class="line">        intDict[sum] = i ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(intDict[n] == INF)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; intDict[n] &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>水題</tag>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>暴力搜尋 Brute force</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa1594 - Ducci Sequence (暴力搜尋 Brute force)</title>
    <url>/2020/03/16/UVa/UVa1594/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意:"></a>題目大意:</h2><blockquote>
<p>給你一個隊列，每一次計算後生成新的隊列，隊列規則如下:</p>
</blockquote>
<center> [a1,a1, ...., an] </center>
更新為:
<center > [|a1-an|, |a1-a2|, ...., |an-1-an|] </center>

<p>最多不生成超過1000個隊列</p>
<a id="more"></a>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析:"></a>分析:</h2><p><font color = "dd0000"> <strong>暴力、枚舉，唯一信仰</strong> </font></p>
<p>每一次生成隊列後，總計它的序列，要是為 0 輸出 “ZERO” ，不是的話，輸出 “LOOP” </p>
<p>複雜度最多 o(1000) 很安全</p>
<h3 id="備註"><a href="#備註" class="headerlink" title="備註:"></a>備註:</h3><p>這位大神的網站寫得很棒，要是看不懂可以看她的</p>
<p><a href="http://glj8989332.blogspot.com/2019/12/uva-1594-ducci-sequence.html" target="_blank" rel="noopener">http://glj8989332.blogspot.com/2019/12/uva-1594-ducci-sequence.html</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> intCase , n , intTemp , intNum[<span class="number">25</span>] , isFlag , intSum  ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; intCase ;</span><br><span class="line">    <span class="keyword">while</span>(intCase--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i++)</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; intNum[i] ;</span><br><span class="line"></span><br><span class="line">        isFlag = <span class="number">0</span> ;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">1010</span> ; i++)&#123;</span><br><span class="line">            intSum = <span class="number">0</span> ;</span><br><span class="line">            intNum[n] = intNum[<span class="number">0</span>] ;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; n ; j++ )</span><br><span class="line">                intNum[j] = <span class="built_in">abs</span>(intNum[j] - intNum[j+<span class="number">1</span>]) ;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i++)&#123;</span><br><span class="line">                <span class="comment">//debug</span></span><br><span class="line">                <span class="comment">//cout &lt;&lt; intNum[i] &lt;&lt; ' ' ;</span></span><br><span class="line"></span><br><span class="line">                intSum += intNum[i] ;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//debug</span></span><br><span class="line">            <span class="comment">//cout &lt;&lt; '\n' ;</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(!intSum)&#123;</span><br><span class="line">                isFlag = <span class="number">1</span> ;</span><br><span class="line">                <span class="keyword">break</span> ;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(isFlag)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"ZERO"</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"LOOP"</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>水題</tag>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>暴力搜尋 Brute force</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa255 - Correct Move (水題)</title>
    <url>/2020/03/07/UVa/UVa255/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>給定 queen 與 king 的位置， queen 下一步移動，判斷狀態和移動的合法性。</p>
</blockquote>
<a id="more"></a> 

<h2 id="分析"><a href="#分析" class="headerlink" title="分析:"></a>分析:</h2><p>水題</p>
<p>枚舉每個位置，並嘗試各種狀態與移動的合法性</p>
<p>tip: 1. 可以將二維陣列壓縮成一維陣列<br>     2. 四個角直接用if寫死即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> k , q1 , q2 ;</span><br><span class="line"><span class="keyword">int</span> q1x , q1y , q2x , q2y , kx , ky ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_between</span><span class="params">(<span class="keyword">int</span> a , <span class="keyword">int</span> b , <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> intMax , intMin  ;</span><br><span class="line">    <span class="keyword">if</span>(b &gt; a)</span><br><span class="line">        swap(a , b);</span><br><span class="line">    <span class="keyword">if</span>(a &gt; c &amp;&amp; c &gt; b)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_illegal_move</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k == q2 || q1 == q2)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span>(q1 % <span class="number">8</span> != q2 % <span class="number">8</span> &amp;&amp; q1 / <span class="number">8</span> != q2 / <span class="number">8</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span>((is_between(q1x , q2x , kx) &amp;&amp; q1y == ky ) || (is_between(q1y , q2y , ky) &amp;&amp; q1x == kx))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_move_not_allow</span><span class="params">()</span></span>&#123; <span class="comment">//由於是一維，因此不可將最右邊的格式與最左邊的格子視為相同</span></span><br><span class="line">    <span class="keyword">if</span>((k+<span class="number">1</span> == q2 &amp;&amp; q2 % <span class="number">8</span> != <span class="number">0</span> ) || (k<span class="number">-1</span> == q2 &amp;&amp; q2 % <span class="number">8</span> != <span class="number">7</span>) || (k<span class="number">-8</span> == q2) || k+<span class="number">8</span> == q2)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_stop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( (k == <span class="number">0</span> &amp;&amp; q2 == <span class="number">9</span>) || (k == <span class="number">7</span> &amp;&amp; q2 == <span class="number">14</span>) || \</span><br><span class="line">        (k == <span class="number">56</span> &amp;&amp; q2 == <span class="number">49</span> ) || (k == <span class="number">63</span>) &amp;&amp; (q2 == <span class="number">54</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; k &gt;&gt; q1 &gt;&gt; q2)&#123;</span><br><span class="line">        q1x = q1 / <span class="number">8</span> ;</span><br><span class="line">        q1y = q1 % <span class="number">8</span> ;</span><br><span class="line">        q2x = q2 / <span class="number">8</span> ;</span><br><span class="line">        q2y = q2 % <span class="number">8</span> ;</span><br><span class="line">        kx = k / <span class="number">8</span> ;</span><br><span class="line">        ky = k % <span class="number">8</span> ;</span><br><span class="line">        <span class="keyword">if</span>(k == q1)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Illegal state"</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(is_illegal_move())</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Illegal move"</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(is_move_not_allow())</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Move not allowed"</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(is_stop())</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Stop"</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Continue"</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>水題</tag>
        <tag>UVa</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa294 - Divisors (數論 Math theorm)</title>
    <url>/2020/04/09/UVa/UVa294/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>給你一段數字，求出範圍數字內可以被最多數字整除於 0。(如果有一樣，輸出最小)<br><strong>並透過格式輸出</strong></p>
</blockquote>
<a id="more"></a>

<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>這裡有一個地方我覺得很酷，就是</p>
<p>6 的除數有 1 2 4 6 總共為 4<br>6 = 2^1 * 3^1<br>=&gt; 2 * 2 =&gt; 4</p>
<p>一開始覺得很神奇，但後來想通了也沒什麼，但想出方法的真的很強呢。</p>
<p>Hint:<br>x ^ 0 = 1，能明白固中道理，這題目就簡單了。</p>
<p><a href="http://celinechiu0809.blogspot.com/2015/04/uva294-divisors.html" target="_blank" rel="noopener">教會我的blog</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Maxn_Num 1000000000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">enum</span> &#123;Maxn = Maxn_Num , sqrt_max = (<span class="keyword">int</span>)<span class="built_in">sqrt</span>(Maxn_Num)&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; prime ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count_div</span><span class="params">(<span class="keyword">int</span> x )</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> total =<span class="number">1</span> , j ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; prime.size() &amp;&amp; x ; i++)&#123;</span><br><span class="line">        j = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">while</span>(x % prime[i] ==<span class="number">0</span> )&#123;</span><br><span class="line">            x /= prime[i];</span><br><span class="line">            j++ ;</span><br><span class="line">        &#125;</span><br><span class="line">        total *= j ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span>) ;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> flag ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= sqrt_max ; i++)&#123;</span><br><span class="line">        flag = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span> ; j &lt;= <span class="built_in">sqrt</span>(i) ; j++ )&#123;</span><br><span class="line">            <span class="keyword">if</span>(i % j == <span class="number">0</span> )&#123;</span><br><span class="line">                flag = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)</span><br><span class="line">            prime.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**&lt;      //debug</span></span><br><span class="line"><span class="comment">    for(auto it : prime)</span></span><br><span class="line"><span class="comment">        cout &lt;&lt; it &lt;&lt; '\n' ;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">int</span> n , l , u, temp;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; l &gt;&gt; u ;</span><br><span class="line">        pair&lt;<span class="keyword">int</span> , <span class="keyword">int</span>&gt; divMax = &#123;<span class="number">0</span>,<span class="number">0</span>&#125; ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = l ; i &lt;= u ; i++)&#123;</span><br><span class="line">            temp = count_div(i);</span><br><span class="line">            <span class="keyword">if</span> ( temp &gt; divMax.second)&#123;</span><br><span class="line">                divMax.first = i ;</span><br><span class="line">                divMax.second = temp ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Between "</span> &lt;&lt; l &lt;&lt; <span class="string">" and "</span> &lt;&lt; u &lt;&lt; <span class="string">", "</span> &lt;&lt; divMax.first &lt;&lt; <span class="string">" has a maximum of "</span> &lt;&lt; divMax.second &lt;&lt; <span class="string">" divisors.\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>數論 Math theorm</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa544 - Heavy Cargo (Kruskal)</title>
    <url>/2020/03/08/UVa/UVa544/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>有一個載重無限的卡車從 a 地到 b 地路徑可乘載的最大重量為何?</p>
</blockquote>
<a id="more"></a> 

<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>圖論，最短路徑問題，最大生成樹。</p>
<p>使用kruskal特性，將權重最大的邊加入，當起點與終點為同一樹時，輸出答案</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">string</span> strA , strB ;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; mapHash;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> intSegments = <span class="number">20000</span>;</span><br><span class="line"><span class="keyword">int</span> intParent[<span class="number">250</span>] ,intHash ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="built_in">string</span> strA )</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!mapHash.count(strA))&#123;</span><br><span class="line">       mapHash[strA] = intHash++ ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//debug</span></span><br><span class="line">        <span class="comment">//cout &lt;&lt; strA &lt;&lt; ' ' &lt;&lt; intHash &lt;&lt; '\n' ;</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mapHash[strA] ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u , v , val ;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; strA &gt;&gt; strB &gt;&gt; val ;</span><br><span class="line">        u = get(strA);</span><br><span class="line">        v = get(strB);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;nodEdge[intSegments];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_root</span><span class="params">(<span class="keyword">int</span> intA)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> intA == intParent[intA] ?  intA : intParent[intA] = find_root(intParent[intA]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=<span class="number">4</span> , m=<span class="number">4</span> , intValue , intCase = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m  &amp;&amp; n + m != <span class="number">0</span>)&#123;</span><br><span class="line">        intCase++ ;</span><br><span class="line">        mapHash.clear();</span><br><span class="line">        intHash = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i++) intParent[i] = i ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; m ; i++) nodEdge[i].read() ;</span><br><span class="line">        <span class="built_in">string</span> strStart , strDestination ;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; strStart &gt;&gt; strDestination ;</span><br><span class="line">        sort(nodEdge , nodEdge+m , [](node nodA , node nodB)&#123;</span><br><span class="line">             <span class="keyword">return</span>  nodA.val &gt; nodB.val ;</span><br><span class="line">              &#125;</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**&lt;debug</span></span><br><span class="line"><span class="comment">        for(int i = 0 ; i &lt; m ; i++)</span></span><br><span class="line"><span class="comment">            cout &lt;&lt; nodEdge[i].u &lt;&lt; ' ' &lt;&lt; nodEdge[i].v &lt;&lt; ' ' &lt;&lt; nodEdge[i].val &lt;&lt; '\n' ;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; m ; i++)&#123;</span><br><span class="line">            <span class="comment">/**&lt;debug</span></span><br><span class="line"><span class="comment">            for(int i = 0 ; i &lt; n ; i++)&#123;</span></span><br><span class="line"><span class="comment">                cout &lt;&lt; nodEdge[i].u &lt;&lt; ' ' &lt;&lt; intParent[nodEdge[i].u] &lt;&lt; '\n' ;</span></span><br><span class="line"><span class="comment">                cout &lt;&lt; nodEdge[i].v &lt;&lt; ' ' &lt;&lt; intParent[nodEdge[i].v] &lt;&lt; '\n' ;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            cout &lt;&lt; '\n' ;</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> intRootU , intRootV ;</span><br><span class="line">            intRootU = find_root(nodEdge[i].u);</span><br><span class="line">            intRootV = find_root(intParent[nodEdge[i].v]);</span><br><span class="line">            <span class="keyword">if</span>( intRootU != intRootV)&#123;</span><br><span class="line">                intParent[intRootU] = find_root(intRootV) ;</span><br><span class="line">                <span class="comment">/**&lt; debug</span></span><br><span class="line"><span class="comment">                cout &lt;&lt; "start" &lt;&lt; intParent[mapHash[strStart]] &lt;&lt; ' ' \</span></span><br><span class="line"><span class="comment">                     &lt;&lt; "Destination" &lt;&lt; intParent[mapHash[strDestination]] &lt;&lt; '\n' ;</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(find_root(intParent[mapHash[strStart]]) == find_root(intParent[mapHash[strDestination]]))&#123;</span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Scenario #"</span> &lt;&lt; intCase &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; nodEdge[i].val &lt;&lt; <span class="string">" tons"</span> &lt;&lt; <span class="string">"\n\n"</span>;</span><br><span class="line">                    <span class="keyword">break</span> ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**&lt;debug</span></span><br><span class="line"><span class="comment">        for(int i = 0 ; i &lt; m ; i++)&#123;</span></span><br><span class="line"><span class="comment">            cout &lt;&lt; nodEdge[i].u &lt;&lt; ' ' &lt;&lt; intParent[nodEdge[i].u] &lt;&lt; '\n' ;</span></span><br><span class="line"><span class="comment">            cout &lt;&lt; nodEdge[i].v &lt;&lt; ' ' &lt;&lt; intParent[nodEdge[i].v] &lt;&lt; '\n' ;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        cout &lt;&lt; '\n' ;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>最小生成樹 MST</tag>
        <tag>程式解題</tag>
        <tag>Kruskal&#39;s algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa846 - Steps (數論 Math theorm)</title>
    <url>/2020/03/11/UVa/UVa846/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>給你兩個數字，每次走的步伐必須為上一步的 +1 , -1 , 0 步伐，試問最短的步伐為?</p>
</blockquote>
<a id="more"></a> 

<h2 id="分析"><a href="#分析" class="headerlink" title="分析:"></a>分析:</h2><p><font color= "%dd0000"> <strong>數學題。</strong> </font></p>
<p>設第一個數字為 x ，第二個數字為 y<br>最好的情況為 x+1 , x+2 , …. , r , y-3 , y-2 , y-1<br>數列看起來相似於 <font color= "%dd0000"> 梯形公式 </font></p>
<p>以此得出策略為 &rarr; 每次將 n * 2 ( n 為上一步的 +1)</p>
<p>圖示如下:</p>
<ul>
<li><code>1 2 3 2 1</code> 轉變為 <code>2 3 2</code></li>
</ul>
<p>以此類推，透過這種方式每一次的 Step += 2</p>
<h3 id="額外注意"><a href="#額外注意" class="headerlink" title="額外注意:"></a>額外注意:</h3><ul>
<li><p><code>4 5 4</code><br>將 4 刪除掉後，剩下 5 ，程式在下一次操作時，則會刪除掉兩個 5 ，但實際題目並沒有兩個 5 ，需要加上額外判斷</p>
<p>如果 只有一個 5 時 則 step += 1 </p>
</li>
<li><p><code>4 4</code><br>將 4 刪除掉後，並沒有剩下任何東西，則下次會刪除兩個 5 ，但實際題目並沒有 5 ，所以不增加 Step 直接輸出</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> intCase , x , y , intStep , intDistance , intSum , intLength ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; intCase ;</span><br><span class="line">    <span class="keyword">while</span>(intCase--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y ; </span><br><span class="line">        intStep = <span class="number">0</span> ;</span><br><span class="line">        intDistance = y - x ;</span><br><span class="line">        intSum = <span class="number">0</span> ;</span><br><span class="line">        intLength = <span class="number">0</span> ;</span><br><span class="line">        <span class="comment">//debug</span></span><br><span class="line">        <span class="comment">//cout &lt;&lt; intDistance &lt;&lt; '\n' &lt;&lt; '\n' ;</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        if(intDistance == 1)&#123;</span></span><br><span class="line"><span class="comment">            cout &lt;&lt; 1 &lt;&lt; '\n' ;</span></span><br><span class="line"><span class="comment">            continue ;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       </span><br><span class="line">        <span class="keyword">while</span>(++intLength)&#123;</span><br><span class="line">            <span class="keyword">if</span>(intSum + intLength * <span class="number">2</span> &gt; intDistance)</span><br><span class="line">                <span class="keyword">break</span> ;</span><br><span class="line">            intSum += intLength * <span class="number">2</span> ;</span><br><span class="line">            intStep +=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//debug</span></span><br><span class="line">        <span class="comment">//cout &lt;&lt; "intLength: " &lt;&lt; intLength &lt;&lt; '\n' ;</span></span><br><span class="line">        <span class="comment">//cout &lt;&lt; "intSum: " &lt;&lt; intSum &lt;&lt; '\n' ;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(intSum + intLength &lt; intDistance)</span><br><span class="line">            intStep += <span class="number">2</span> ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (intSum != intDistance )</span><br><span class="line">            intStep ++ ;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; intStep &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>數論 Math theorm</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa679 - Dropping Balls (tree)</title>
    <url>/2020/03/08/UVa/UVa679/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>有一顆二元樹，每次走訪會經過走訪次數最小的 node直到leaf node<br>試問在經過 x 次走訪後將會走到哪個 leaf node ?</p>
</blockquote>
<a id="more"></a> 

<h2 id="分析"><a href="#分析" class="headerlink" title="分析:"></a>分析:</h2><ol>
<li>寫樹模擬 -&gt; TLE!</li>
<li>依循規則找出規律 -&gt; AC!</li>
</ol>
<p>舉例： 假設 D 為 3 , I 為 3</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">     1                 </span><br><span class="line">   &#x2F;   \               </span><br><span class="line">  2     3              </span><br><span class="line"> &#x2F; \  &#x2F;  \             </span><br><span class="line">4  5  6  7</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">node</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">6</th>
<th align="center">7</th>
</tr>
</thead>
<tbody><tr>
<td align="center">num of time 1</td>
<td align="center">T</td>
<td align="center">T</td>
<td align="center"></td>
<td align="center">T</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">num of time 2</td>
<td align="center">T</td>
<td align="center"></td>
<td align="center">T</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">T</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">num of time 3</td>
<td align="center">T</td>
<td align="center">T</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">T</td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<blockquote>
<p>看得出來嗎?</p>
<p>在深度為 2 時:<br>當 I 為奇數時， 必定會經過數字 2<br>當 I 為偶數時， 必定會經過數字 3</p>
<p>已此類推，找到它的規律了! </p>
</blockquote>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 奇數則往左邊<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  ↗  <br>             
我每次將 I /2 後商數為&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  ↘<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 偶數則往右邊 <br>
<br>                

<p>但要記住的是，當 I /2 = 奇數時，之後在實際走訪時 要變成 (I + 1) /2 以預防 ( I = 1 ) / 2 = 0 的冏境<br>(會導致每一次的走訪都會走至另一邊)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> intCase , D , I , intNow ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; intCase ;</span><br><span class="line">    <span class="keyword">while</span>(intCase--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; D &gt;&gt; I ;</span><br><span class="line">        intNow = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; D ; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(I % <span class="number">2</span> )&#123;</span><br><span class="line">                intNow = intNow * <span class="number">2</span> ;</span><br><span class="line">                I = (I+<span class="number">1</span>) /<span class="number">2</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                intNow = intNow * <span class="number">2</span> +<span class="number">1</span> ;</span><br><span class="line">                I /= <span class="number">2</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; intNow &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>binary tree</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>Uva10420 - List of Conquests (水題)</title>
    <url>/2020/03/17/UVa/Uva10420/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意:"></a>題目大意:</h2><blockquote>
<p>給你 n 行話，第一個空白前是國家名，之後則全是人名。</p>
<p>非常水題，考你 string 語法熟不熟 <font color = "dd0000"> (寫 py 的孩子們，一定會很討厭吧www) </font></p>
</blockquote>
<a id="more"></a> 

<h2 id="分析"><a href="#分析" class="headerlink" title="分析:"></a>分析:</h2><p>dict 解決一切，還可以靠著 dict 紅黑樹，自動把資料排序完。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> );</span><br><span class="line">    freopen(<span class="string">"out.txt"</span> , <span class="string">"w"</span> , <span class="built_in">stdout</span> );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">int</span> n , p ;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span> , <span class="keyword">int</span> &gt; MapCountry ;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span> , <span class="keyword">int</span>&gt; MapName ;</span><br><span class="line">    <span class="built_in">string</span> strLine , strCountry , strName ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">    <span class="built_in">cin</span>.ignore() ;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        getline(<span class="built_in">cin</span> , strLine) ;</span><br><span class="line">        p = strLine.find(<span class="string">' '</span>) ;</span><br><span class="line">        strCountry = strLine.substr(<span class="number">0</span> , p ) ;</span><br><span class="line">        strName = strLine.substr(p+<span class="number">1</span> , strLine.length() ) ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//debug</span></span><br><span class="line">        <span class="comment">//cout &lt;&lt; strName &lt;&lt; ' ' &lt;&lt; strCountry &lt;&lt; '\n' ;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(MapCountry[strCountry])</span><br><span class="line">            MapCountry[strCountry]++ ;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            MapCountry[strCountry] = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">if</span>(!MapName[strName])</span><br><span class="line">            MapName[strName] = <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it : MapCountry )</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; it.first &lt;&lt; <span class="string">' '</span> &lt;&lt; it.second &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>水題</tag>
        <tag>UVa</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa929 - Number Maze (Dijkstra)</title>
    <url>/2020/03/11/UVa/UVa929/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>從左上角開始走，走至右下角，最短路徑為多少?</p>
</blockquote>
<a id="more"></a> 

<h2 id="分析"><a href="#分析" class="headerlink" title="分析:"></a>分析:</h2><p><font color= "%dd0000"> <strong><del>傻孩子都看的出來是用 Dijkstra’s 吧?</del></strong> </font></p>
<p><a href="https://zh.wikipedia.org/wiki/%E6%88%B4%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">戴克斯特拉演算法( Dijkstra’s algorithm ) from wiki </a> 使用類似廣度優先搜尋的方法解決賦權圖的單源最短路徑問題</p>
<p>如果是初學者，可以看看 <a href="https://www.youtube.com/channel/UCZCFT11CWBi3MHNlGf019nw" target="_blank" rel="noopener">Abdul Bari</a> 大神的影片，他總是可以把很玄的演算法(algorithm)，講到連小孩子都聽得懂，常讓我覺得要是我也有這麼聰明的頭腦就好了(唉</p>
<h3 id="額外注意"><a href="#額外注意" class="headerlink" title="額外注意:"></a>額外注意:</h3><p>Dijkstra’s algorithm 的問題在於他會有機率性重複回到某點搜尋(在搜尋過程中找到比原先更好的權重)，會造成效率大幅下降，此題必須使用 <a href="http://alrightchiu.github.io/SecondRound/priority-queueintrojian-jie.html" target="_blank" rel="noopener">優先隊列( Priority Queue)</a> 透過最小堆積樹 (Min Heap) 加速(否則會吃 TLE ， 小弟我就被搞了很久，甚至還複習了一下 c++ priority_queue 怎麼寫www)</p>
<h3 id="影片教學"><a href="#影片教學" class="headerlink" title="影片教學:"></a>影片教學:</h3><p><a href="https://www.youtube.com/watch?v=XB4MIexjvY0&t=316s&ab_channel=AbdulBari" target="_blank" rel="noopener">戴克斯特拉演算法( Dijkstra’s algorithm ) from Abdul Bari </a></p>
<p><a href="https://www.youtube.com/watch?v=HqPJF2L5h9U" target="_blank" rel="noopener">Heap - Heap Sort - Heapify - Priority Queues from Abdul Bari </a></p>
<p>我私心很喜歡他，於是放一張大神的圖片</p>
<img src="https://i.udemycdn.com/user/200_H/27878376_ce40_3.jpg" alt="Abdul Bari.jpg" >

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 99999999</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> intMap[<span class="number">1010</span>][<span class="number">1010</span>] = &#123;&#125; , intValue[<span class="number">1010</span>][<span class="number">1010</span>] = &#123;&#125;;</span><br><span class="line"><span class="keyword">int</span> m , n ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x , y , v ;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">( <span class="keyword">int</span> _x , <span class="keyword">int</span> _y , <span class="keyword">int</span> _v)</span></span>&#123;</span><br><span class="line">        x = _x ; y = _y ; v = _v ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp;a) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v &gt; a.v ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;nodNode;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_map</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= m ; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(intValue[i][j] == <span class="number">99999999</span>)</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">'r'</span> &lt;&lt; <span class="string">' '</span> ;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; intValue[i][j] &lt;&lt; <span class="string">' '</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x , y , intDirection[<span class="number">4</span>][<span class="number">2</span>] = &#123;<span class="number">-1</span>,<span class="number">0</span> ,<span class="number">0</span>,<span class="number">1</span> ,<span class="number">1</span>,<span class="number">0</span> ,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> intDx , intDy ;</span><br><span class="line">    Node nodTemp ;</span><br><span class="line">    priority_queue&lt;Node&gt; deqNode ;</span><br><span class="line">    nodTemp.read(<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    deqNode.push(nodTemp);</span><br><span class="line">    <span class="keyword">while</span>(deqNode.size())&#123;</span><br><span class="line">        x = deqNode.top().x ;</span><br><span class="line">        y = deqNode.top().y ;</span><br><span class="line">        deqNode.pop() ;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">4</span> ; i++)&#123;</span><br><span class="line">            intDx = intDirection[i][<span class="number">0</span>] + x ;</span><br><span class="line">            intDy = intDirection[i][<span class="number">1</span>] + y ;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//debug</span></span><br><span class="line">            <span class="comment">//cout &lt;&lt; intDx &lt;&lt; ' ' &lt;&lt; intDy &lt;&lt; ' ' &lt;&lt; intValue[x][y] + intMap[intDx][intDy] &lt;&lt; ' ' &lt;&lt; i &lt;&lt;  '\n' ;</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(intValue[x][y] + intMap[intDx][intDy] &lt; intValue[intDx][intDy]  )&#123;</span><br><span class="line">                intValue[intDx][intDy] = intValue[x][y] + intMap[intDx][intDy] ;</span><br><span class="line">                nodTemp.read(intDx , intDy , intValue[intDx][intDy]);</span><br><span class="line">                deqNode.push(nodTemp) ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//print_map() ;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> );</span><br><span class="line">    freopen(<span class="string">"out.txt"</span> , <span class="string">"w"</span> , <span class="built_in">stdout</span>) ;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">int</span> intCase ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; intCase ;</span><br><span class="line">    <span class="keyword">while</span>(intCase --)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= m ; j++)&#123;</span><br><span class="line">                 <span class="built_in">cin</span> &gt;&gt; intMap[i][j] ;</span><br><span class="line">                intValue[i][j] = INF ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; i++)&#123;</span><br><span class="line">            intValue[i][<span class="number">0</span>] = <span class="number">0</span> ;</span><br><span class="line">            intValue[i][m+<span class="number">1</span>] = <span class="number">0</span> ;</span><br><span class="line">            intMap[i][<span class="number">0</span>] = INF +<span class="number">1</span> ;</span><br><span class="line">            intMap[i][m+<span class="number">1</span>] = INF +<span class="number">1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; i++)&#123;</span><br><span class="line">            intValue[<span class="number">0</span>][i] = <span class="number">0</span> ;</span><br><span class="line">            intValue[n+<span class="number">1</span>][i] = <span class="number">0</span> ;</span><br><span class="line">            intMap[<span class="number">0</span>][i] = INF +<span class="number">1</span> ;</span><br><span class="line">            intMap[n+<span class="number">1</span>][i] = INF +<span class="number">1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        intValue[<span class="number">1</span>][<span class="number">1</span>] = intMap[<span class="number">1</span>][<span class="number">1</span>] ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//debug</span></span><br><span class="line">        <span class="comment">//cout &lt;&lt; intValue[1][1] &lt;&lt; '\n' ;</span></span><br><span class="line"></span><br><span class="line">        bfs();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; intValue[n][m] &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>圖論</tag>
        <tag>UVa</tag>
        <tag>Dijkstra&#39;s</tag>
        <tag>優先隊列</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>Uva11456 - Trainsorting (LIS)</title>
    <url>/2020/03/19/UVa/Uva11456/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意:"></a>題目大意:</h2><blockquote>
<p>有一台火車， x 輛汽車，目的是要讓火車上載滿最多汽車 (可以選擇不要加入這台汽車)，且要排序。</p>
<p>值得注意的是我們只能從前面或後面新增，火車是沒辦法讓我們從中間插入的，試問最多可以載幾台汽車？</p>
</blockquote>
<a id="more"></a>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析:"></a>分析:</h2><p>naivered 大大跟天才一樣，我都沒有想到可以前後面都增加，由於數字不會重複的特性，可以這樣子使用！</p>
<h3 id="舉例"><a href="#舉例" class="headerlink" title="舉例:"></a>舉例:</h3><p>1 2 3 4 =&gt; 4 3 2 1 1 2 3 4</p>
<p>分解成最初狀態後則:</p>
<p>1 =&gt; 1<br>2 =&gt; 2 1 2 </p>
<p>2 這樣子可以假設到加入前面與後面 (由於數字不會重複)</p>
<p>接著就算 <a href="http://www.csie.ntnu.edu.tw/~u91029/LongestIncreasingSubsequence.html" target="_blank" rel="noopener">LIS (之前我很喜歡看的演算法教學文章)</a> 即可。</p>
<h2 id="備註"><a href="#備註" class="headerlink" title="備註:"></a>備註:</h2><p>要是我寫得不好，就去看這位 <a href="http://naivered.github.io/2018/03/04/Problem_Solving/UVa/UVa-11456-Trainsorting/" target="_blank" rel="noopener">naivered</a> 大神這題的教學文，十分好理解</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"out.txt"</span> , <span class="string">"w"</span> , <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">int</span> intCase , n , intPosition ;</span><br><span class="line">    <span class="built_in">string</span> strWord , strAns , strLine ;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vecAns ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; intCase ;</span><br><span class="line">    n = <span class="number">1</span> ;</span><br><span class="line">    getline(<span class="built_in">cin</span> , strLine ) ;</span><br><span class="line">    getline(<span class="built_in">cin</span> , strLine ) ;</span><br><span class="line">    <span class="keyword">while</span>(getline(<span class="built_in">cin</span> , strLine ))&#123;</span><br><span class="line">        <span class="comment">//debug</span></span><br><span class="line">        <span class="comment">//cout &lt;&lt; strLine &lt;&lt; '\n' ;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(strLine != <span class="string">""</span>)&#123;</span><br><span class="line">            <span class="built_in">stringstream</span> ss ;</span><br><span class="line">            ss.str(<span class="string">""</span>);</span><br><span class="line">            ss.<span class="built_in">clear</span>() ;</span><br><span class="line">            ss &lt;&lt; strLine ;</span><br><span class="line">            intPosition = <span class="number">0</span> ;</span><br><span class="line">            strAns = <span class="string">""</span> ;</span><br><span class="line">            <span class="keyword">while</span>(ss &gt;&gt; strWord)&#123;</span><br><span class="line">                <span class="comment">//debug-</span></span><br><span class="line">                <span class="comment">//cout &lt;&lt; strWord &lt;&lt; '\n' ;</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(strWord.length() &gt; intPosition)&#123;</span><br><span class="line">                    strAns += strWord[intPosition++] ;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//debug</span></span><br><span class="line">                    <span class="comment">//cout &lt;&lt; strAns &lt;&lt; '\n' ;</span></span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            vecAns.push_back(strAns) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Case #"</span> &lt;&lt; n++ &lt;&lt; <span class="string">":"</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; vecAns.<span class="built_in">size</span>()<span class="number">-1</span> ; i++)</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; vecAns[i] &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; vecAns[vecAns.<span class="built_in">size</span>()<span class="number">-1</span>] ;</span><br><span class="line">            <span class="keyword">if</span>(n<span class="number">-1</span> != intCase)</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">            vecAns.<span class="built_in">clear</span>() ;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>LIS 最長遞增子序列</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>Uva11987 - Almost Union-Find (Disjoint Set)</title>
    <url>/2020/03/23/UVa/Uva11987/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>並查集，有三種操作</p>
<ol>
<li>Union: 把 x , y 加入同一集合</li>
<li>Move:  將 x 移動到 y 集合</li>
<li>Return:將 x 的集合總和，與多少元素</li>
</ol>
</blockquote>
<a id="more"></a>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析:"></a>分析:</h2><p>老實講，其實沒有很難，第二點比較特殊，我直接進行改點。</p>
<p>有個地方比較麻煩，算總和跟多少元素，原本是想要每一次都掃描陣列，發現會 TLE (廢話，但是作者太爛不知道阿<del>~</del>)</p>
<p>所以開陣列並在做 Union , Move 操作時，順便紀錄集合總和與內部元素。</p>
<h2 id="備註："><a href="#備註：" class="headerlink" title="備註："></a>備註：</h2><p>如果還不懂 disjoint set 的可以看<a href="https://theriseofdavid.github.io/\2021/02/02/Explain_Algorithm/disjoint-set/" target="_blank" rel="noopener">演算法知識 - Disjoint Set 並查集</a>或<a href="https://www.youtube.com/watch?v=wU6udHRIkcc" target="_blank" rel="noopener">Abdul Bari</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> intSum[<span class="number">200080</span>] , intParent[<span class="number">200080</span>] , intSet[<span class="number">200080</span>] ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_root</span><span class="params">(<span class="keyword">int</span> intA)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(intParent[intA] == intA)</span><br><span class="line">        <span class="keyword">return</span> intA ;</span><br><span class="line">    intParent[intA] = find_root(intParent[intA]) ;</span><br><span class="line">    <span class="keyword">return</span> intParent[intA] ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">each_debug</span><span class="params">(<span class="keyword">int</span> n )</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; i++)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">' '</span> &lt;&lt; intParent[i] &lt;&lt; <span class="string">' '</span>  \</span><br><span class="line">            &lt;&lt; intSet[find_root(i)] &lt;&lt; <span class="string">' '</span> &lt;&lt; intSum[find_root(i)] &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    system(<span class="string">"Pause"</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>,<span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"out.txt"</span> ,<span class="string">"w"</span> , <span class="built_in">stdout</span>) ;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n, m , operation , p , q  ;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; i++)&#123;</span><br><span class="line">            intParent[i] = i+n ;</span><br><span class="line">            intParent[i+n] = i+n ;</span><br><span class="line">            intSum[i+n] = i;</span><br><span class="line">            intSet[i+n] = <span class="number">1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; operation ;</span><br><span class="line">            <span class="keyword">if</span>(operation == <span class="number">1</span> )&#123;</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; p &gt;&gt; q ;</span><br><span class="line">                <span class="keyword">int</span> intRoot_p , intRoot_q ;</span><br><span class="line">                intRoot_p = find_root(intParent[p]) ;</span><br><span class="line">                intRoot_q = find_root(intParent[q]) ;</span><br><span class="line">                <span class="keyword">if</span>(intRoot_p != intRoot_q)&#123;</span><br><span class="line">                    intParent[intRoot_q] = intRoot_p ;</span><br><span class="line">                    intSum[intRoot_p] += intSum[intRoot_q] ;</span><br><span class="line">                    intSet[intRoot_p] += intSet[intRoot_q] ;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//debug</span></span><br><span class="line">                <span class="comment">//each_debug(n) ;</span></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (operation == <span class="number">2</span> )&#123;</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; p &gt;&gt; q ;</span><br><span class="line">                <span class="keyword">int</span> intRoot_p , intRoot_q ;</span><br><span class="line">                intRoot_p = find_root(intParent[p]) ;</span><br><span class="line">                intRoot_q = find_root(intParent[q]) ;</span><br><span class="line">                <span class="keyword">if</span>(intRoot_p != intRoot_q)&#123;</span><br><span class="line">                    intParent[p] = intRoot_q ;</span><br><span class="line">                    intSum[intRoot_q] += p ;</span><br><span class="line">                    intSum[intRoot_p] -= p ;</span><br><span class="line">                    intSet[intRoot_q] ++ ;</span><br><span class="line">                    intSet[intRoot_p] -- ;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//debug</span></span><br><span class="line">                <span class="comment">//each_debug(n) ;</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (operation == <span class="number">3</span>)&#123;</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; p ;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; intSet[find_root(p)] &lt;&lt; <span class="string">' '</span> &lt;&lt; intSum[find_root(p)] &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>Disjoint Set 並查集</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>部落格編排格式</title>
    <url>/2020/07/20/blog/blog-format/</url>
    <content><![CDATA[<h2 id="主要內容"><a href="#主要內容" class="headerlink" title="主要內容"></a>主要內容</h2><blockquote>
<p>礙於我每次寫完文章後，過一個月後總會對自己過去編排不滿意，於是我現在特此寫一篇文章來規定自己的部落格編排模式</p>
</blockquote>
<a id="more"></a>

<h2 id="關於全-BLOG"><a href="#關於全-BLOG" class="headerlink" title="關於全 BLOG"></a>關於全 BLOG</h2><ul>
<li>大標題必定都是使用 兩個 tag(##)</li>
<li>要先觀看 blog 的 tag 內容有哪些選擇後並加入</li>
<li>如果清單並沒有要用數字清單，如 1. 2. 3.，請先使用 * 在使用 - </li>
<li>寫完文章後，通常在最底下用一標題來寫心得，如 ##心得</li>
<li>通常每個 分類 他也都是一個 tag，需要注意</li>
<li>必須記得加入 !– more – ，需要再 - 旁加入&lt;&gt;</li>
<li>只要是數字、中文、英文切換，必定都要先透過空白來增加排版觀看度，但如果遇到標點符號則不用</li>
<li>如果要本地新增圖片 使用 <img src="%E6%9C%AC%E5%9C%B0%E8%B7%AF%E5%BE%91" alt=""> </li>
</ul>
<h2 id="關於解題程式"><a href="#關於解題程式" class="headerlink" title="關於解題程式"></a>關於解題程式</h2><ul>
<li>必要兩個章節<ol>
<li>題目大意：</li>
<li>分析：</li>
</ol>
</li>
<li>需放入程式碼</li>
</ul>
<h2 id="將-blog-當作字典時"><a href="#將-blog-當作字典時" class="headerlink" title="將 blog 當作字典時"></a>將 blog 當作字典時</h2><ul>
<li>必要一個章節<ol>
<li>主要內容</li>
</ol>
</li>
</ul>
<h2 id="關於需要更新的文章時"><a href="#關於需要更新的文章時" class="headerlink" title="關於需要更新的文章時"></a>關於需要更新的文章時</h2><ul>
<li>需加入一章節<ol>
<li>更新日誌，格式為 yyyy-mm-dd hh:mm:ss - 內容</li>
</ol>
</li>
</ul>
<h2 id="關於自己的心得"><a href="#關於自己的心得" class="headerlink" title="關於自己的心得"></a>關於自己的心得</h2><ul>
<li>必須加入 TAG ，人生紀錄</li>
</ul>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>人生旅途</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo d -g 指令錯誤 Deployer not found</title>
    <url>/2020/07/11/blog/hexo-d-g-error-to-deployer-not-found/</url>
    <content><![CDATA[<blockquote>
<p>當你在使用 hexo 建置屬於你的 Blog 時，發生 Deploy not found : git 的解決方式</p>
</blockquote>
<a id="more"></a>

<h2 id="問題描述"><a href="#問題描述" class="headerlink" title="問題描述"></a>問題描述</h2><p>我有在外層的 config.yml 加入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: </span><br><span class="line">    github: https:&#x2F;&#x2F;github.com&#x2F;XXX&#x2F;XXX.github.io.git</span><br></pre></td></tr></table></figure>
<p>但是在執行 <code>hexo d -g</code>時發生錯誤</p>
<h2 id="解決方法"><a href="#解決方法" class="headerlink" title="解決方法"></a>解決方法</h2><p>由於缺少 <code>hexo-deployer-git</code> 套件，在當前目錄安裝套件即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<p>接下來再使用 <code>hexo d -g</code> 就可以成功推送了！<br>很簡單對巴~</p>
<p><a href="https://blog.csdn.net/qq_21808961/article/details/84476504" target="_blank" rel="noopener">參考來源</a></p>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>大學程式能力檢定 CPE 2020/06/09 心得</title>
    <url>/2020/06/15/contest_experence/CPE20200609/</url>
    <content><![CDATA[<blockquote>
<p>僅此記錄在 2020/06/09 CPE 程式設計心得</p>
</blockquote>
<a id="more"></a>

<h2 id="國北教，連走路都能感受到青春的氣息"><a href="#國北教，連走路都能感受到青春的氣息" class="headerlink" title="國北教，連走路都能感受到青春的氣息"></a>國北教，連走路都能感受到青春的氣息</h2><p>09 日的下午三點，我在北市大旁的燒肉便當店用餐，便當普通，接著我進入國北教準備進入 CPE 的場地，由於武漢疫情的關係，大學有了出入管制，當我一進去大門時，就向駐警致意我是要來參加 CPE ，駐警先讓我填了一張居家、身體健康調查表，我就順利的進入國北教。當我進入國北教時，在往視聽館 (即 CPE 考試場所)，沿途上我都沒有看到任何男生。對於我高職、大學都在工科環境下長大，這還是我第一次看到一間大學會有那麼多的女生阿…，現在轉學還來的及嗎XD!</p>
<h2 id="考場前的準備"><a href="#考場前的準備" class="headerlink" title="考場前的準備"></a>考場前的準備</h2><p>老實說，那天我的狀態是不好的。<br>我的眼睛只要看到螢幕就會變得模糊，應該是最近用眼過度了，因為之前接了太多專案使自己壓力太大，導致我那天的精神狀況並不好、稍加疲累，但不得不稱讚的是，國北教的電腦設備比起北科資財系好蠻多的，不管是教室明亮度、電腦設備都比起我們系上好很多，老實說蠻喜歡的。但有一個很大缺點，對於左撇子的人並不有善，我坐在靠牆的位置，他的距離給得並不好，我的左手非常容易撞到牆壁，並不舒服。</p>
<p>我旁邊的朋友是一位師大大三的學長，他考第二次了，感覺他的能力蠻強。但她比較內向，我曾向他搭話幾句但她都是給著類程式的回應句，但她 CPE 成績挺不錯的，寫了 6 題。</p>
<h2 id="考試題目"><a href="#考試題目" class="headerlink" title="考試題目"></a>考試題目</h2><h4 id="Problem-A-11498-Division-of-Nlogonia-失敗"><a href="#Problem-A-11498-Division-of-Nlogonia-失敗" class="headerlink" title="Problem A 11498 Division of Nlogonia　失敗"></a>Problem A 11498 Division of Nlogonia　失敗</h4><p>當時的我</p>
<ul>
<li>由於我不想看長長的英文，我直接看 Input and Output，猜測題目再講甚麼，就直接寫了，但後來好像發現他其實是向量的感覺? 我想應該是我理解錯題目了</li>
</ul>
<p>現在的我</p>
<ul>
<li>待述</li>
</ul>
<h4 id="Problem-B-10189-Minesweeper-AC"><a href="#Problem-B-10189-Minesweeper-AC" class="headerlink" title="Problem B 10189 Minesweeper AC"></a>Problem B 10189 Minesweeper AC</h4><p>當時的我</p>
<ul>
<li>踩地雷，把地雷的旁邊格數都 +1，這題花了半小時寫。</li>
</ul>
<h4 id="Problem-C-1368-DNA-Consensus-String-未提交、找出-Bug"><a href="#Problem-C-1368-DNA-Consensus-String-未提交、找出-Bug" class="headerlink" title="Problem C 1368 DNA Consensus String 未提交、找出 Bug"></a>Problem C 1368 DNA Consensus String 未提交、找出 Bug</h4><p>當時的我</p>
<ul>
<li>他給與我們 N 個長度一樣字串，然後在每個字串的第 X 字元找出哪個英文字母是最多，並輸出，且紀錄非最多英文字母的其他字母出現次數，然後輸出。這題有一個很大的坑，是讓我這次只有寫兩題的最大問題，<strong>瘋狂成社沒辦法將字串陣列放在全域！</strong>，下面進行補述。</li>
</ul>
<p>現在的我</p>
<ul>
<li>待述</li>
</ul>
<h4 id="Problem-D-855-Lunch-in-Grid-City-未嘗試撰寫"><a href="#Problem-D-855-Lunch-in-Grid-City-未嘗試撰寫" class="headerlink" title="Problem D 855 Lunch in Grid City 未嘗試撰寫"></a>Problem D 855 Lunch in Grid City 未嘗試撰寫</h4><p>當時的我</p>
<ul>
<li>給你很多點，請將其中的一個點設為中心點，讓其他點到中心點的距離為最短。當時看到沒有頭緒，選擇直接跳過。直覺是需將程式碼寫得十分攏長，於是直接略過。</li>
</ul>
<p>現在的我</p>
<ul>
<li>待述</li>
</ul>
<h4 id="Problem-E-10191-Longest-Nap-AC"><a href="#Problem-E-10191-Longest-Nap-AC" class="headerlink" title="Problem E 10191 Longest Nap AC"></a>Problem E 10191 Longest Nap AC</h4><p>當時的我</p>
<ul>
<li>教授有固定的上班時間，請您找出它可以在上班時間可以休息的最大時間。</li>
<li>想法：最長區間覆蓋長，輕輕鬆鬆，花了半小時寫。</li>
</ul>
<h4 id="Problem-F-10130-SuperSale-未嘗試撰寫"><a href="#Problem-F-10130-SuperSale-未嘗試撰寫" class="headerlink" title="Problem F 10130 SuperSale 未嘗試撰寫"></a>Problem F 10130 SuperSale 未嘗試撰寫</h4><p>當時的我</p>
<ul>
<li>背包問題再給一些變化</li>
</ul>
<p>現在的我</p>
<ul>
<li>待述</li>
</ul>
<h4 id="Problem-G-10583-Ubiquitous-Religions-未嘗試撰寫"><a href="#Problem-G-10583-Ubiquitous-Religions-未嘗試撰寫" class="headerlink" title="Problem G 10583 Ubiquitous Religions 未嘗試撰寫"></a>Problem G 10583 Ubiquitous Religions 未嘗試撰寫</h4><p>當時的我</p>
<ul>
<li>連題目都沒看，到時候在補</li>
</ul>
<p>現在的我</p>
<ul>
<li>待述</li>
</ul>
<h2 id="瘋狂成設，我一生的敵人"><a href="#瘋狂成設，我一生的敵人" class="headerlink" title="瘋狂成設，我一生的敵人"></a>瘋狂成設，我一生的敵人</h2><p>「瘋狂成設是最爛的 IDE」，考完後的我真心對他超級不爽。<br>原因如下：</p>
<ol>
<li><p>無法 Debug<br> 雖然我本來就已經對 Debug 無感，已經習慣 cout &gt;&gt; “Hello World!\n” ; ，但她在執行編譯再啟動後的語法錯誤提示十分不直觀，與 Code Block 比較下，我需要花很多時間去思考哪裡語法錯誤。</p>
</li>
<li><p>沒有提示<br>這點對我就特別重要了！因為我並不是天天寫 C++ 這門語言，我其他的專案用的是其他語言，沒辦法完全記的起 C++ 全部語法，時常會忘記一些單字。很需要提示來告訴我，我要用這個語法，我將舉例一個因為沒有提示而讓我花費許多時間去找出這個語法。 EX: string.subString (ERROR) =&gt; string.substr (RIGHT)</p>
</li>
<li><p>不方便 Debug<br>這我後來有逐漸克服與習慣，但前期我在印出來時，由於他的輸出區都在左側且排版不友善，需要花點時間習慣。</p>
</li>
<li><p><font color ="#dd0000"> ** String 陣列不能放在 global **</font><br>這點我就很納悶了，我在寫 1368 DNA Consensus String 時，在 cin 字串時，發現如果你將 String 陣列放在 global 且字串陣列 index 為 5 時，就再也沒辦法 cin 進去了！我原本認為這邊 cin 字串是最簡單並且我不可能錯的，所以我從來都不曾在這邊 Debug ，直到我在也想不出來我其他地方有 Bug 時，回頭檢查 cin 才找到 Bug !!!!! 這讓我當下十分生氣、十分無力且頭痛，一點都不想再碰瘋狂成設，因為他太難用、有地雷，再來她從來都沒跑出關於 ERROR 訊息!!!! 希望未來可以廢除瘋狂成設，非常感謝主辦方明智的選擇。也或許是只有我那台的電腦也說不定，還希望有其他人可以幫我認證。</p>
</li>
</ol>
<h2 id="檢討"><a href="#檢討" class="headerlink" title="檢討"></a>檢討</h2><p>如果你想要將 CPE 考好，我認為我需要再補強我對於英文的耐性與閱讀英文能力，我的英文能力還需要再加強，我旁邊的師大朋友看完一題的英文題目時，我才看到一半，再來，我認為我需要再將瘋狂成設熟練，畢竟我們是檢定的學生沒有權力可以請主辦方改變 CPE，只能希望主辦方意識到瘋狂成設的問題。那便是我最大的榮幸。</p>
<h2 id="更新日誌"><a href="#更新日誌" class="headerlink" title="更新日誌"></a>更新日誌</h2><p>2020-06-15 14:27:24 - 寫完 CPE 心得</p>
]]></content>
      <categories>
        <category>競賽心得</category>
      </categories>
      <tags>
        <tag>大學Life</tag>
        <tag>程式比賽</tag>
        <tag>競賽心得</tag>
        <tag>人生旅途</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 Hexo 搭建 Blog</title>
    <url>/2020/03/09/blog/hexo-install/</url>
    <content><![CDATA[<h2 id="使用Hexo-搭建-Blog"><a href="#使用Hexo-搭建-Blog" class="headerlink" title="使用Hexo 搭建 Blog :"></a>使用Hexo 搭建 Blog :</h2><blockquote>
<p>想怎麼用 Hexo 搭建 Blog 嗎? 那就觀看這篇文章就對喔~</p>
</blockquote>
<a id="more"></a> 

<p><a href="https://medium.com/@bebebobohaha/%E4%BD%BF%E7%94%A8-hexo-gitpage-%E6%90%AD%E5%BB%BA%E5%80%8B%E4%BA%BA-blog-5c6ed52f23db/" target="_blank" rel="noopener"> 如何搭建個人 Blog 使用 Hexo + Gitpage </a></p>
<h2 id="附註"><a href="#附註" class="headerlink" title="附註 :"></a>附註 :</h2><p>假如需要更換主題，且主題需要在透過 node.js 在下載其他套件時，須按照指示安裝。<br>若您將網頁放在 github 需要異地下載時，則需要先透過 git bash 輸入  <code>bash hexo init &lt;folder&gt;</code> ，否則無法成功將網頁呼叫成功。 </p>
<h2 id="此-Blog-使用主題"><a href="#此-Blog-使用主題" class="headerlink" title="此 Blog 使用主題 :"></a>此 Blog 使用主題 :</h2><p><a href="https://shen-yu.gitee.io/2019/ayer/" target="_blank" rel="noopener">Ayer Theme </a></p>
<img src="https://i.loli.net/2019/12/03/SHPinIAclMX1Gra.png" alt="ayer.jpg" >

<br>

<h3 id="tips"><a href="#tips" class="headerlink" title="tips :"></a>tips :</h3><p>這裡放上一些作者之前遇到的問題，且已被解決，感謝原文章的主人分享</p>
<p><font color ="dd0000" > <strong>警告: Node.js 如果沒有放在 C 槽時， Hexo 可能安裝不成功(玄學，小弟我猜是註冊表的原因)</strong></font></p>
<p><a href="https://yaoandy107.github.io/hexo-tutorial/" target="_blank" rel="noopener">Hexo+GitHub，新手也可以快速建立部落格</a>　<br><br><a href="https://wst24365888.github.io/hexo-tags/#%E5%B7%B2%E6%88%90%E5%8A%9F" target="_blank" rel="noopener">分類或標籤因為大小寫問題</a>　<br></p>
<h2 id="注意事項"><a href="#注意事項" class="headerlink" title="注意事項:"></a>注意事項:</h2><ol>
<li>此主題的分類<strong><font color="#dd0000">只能用一個</font></strong></li>
<li>如果 md 檔有空格再丟到外面網域時則無法連結成功</li>
</ol>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>第五屆全國科大程式競賽心得 - 金獎(5th)心得</title>
    <url>/2020/07/08/contest_experence/ncut2020-experience/</url>
    <content><![CDATA[<blockquote>
<p>僅此紀錄 2020/07/08 第五屆全國科大程式競賽心得。<br>「紀錄每個時刻，讓未來的自己不遺忘過去的自己」<br>只有自己才能體會自己的過去<br>獲得了第五屆全國科大程式競賽金獎 (5th)<br><strong>此心得並不包含解題，將額外再另外一篇特別說明</strong></p>
</blockquote>
<a id="more"></a>

<h4 id="名詞解釋"><a href="#名詞解釋" class="headerlink" title="名詞解釋"></a>名詞解釋</h4><ul>
<li>駕駛<br>Coding、上機寫程式</li>
<li>駕駛員<br>駕駛的人員，駕駛為上述意思</li>
</ul>
<h2 id="比賽前的規劃"><a href="#比賽前的規劃" class="headerlink" title="比賽前的規劃"></a>比賽前的規劃</h2><p>比賽前，其實我們每周的一、六晚上都會花 3 小時來學習或複習新的演算法，Bill and Entroy 負責思考題目，當他們將題目思考完畢後交予給我進行 Coding ，看到這裡？有些人可能會有疑惑，那這樣是不是因為我太爛才會讓我來負責寫程式呢？其實不然，主要負責上機寫程式勢必要能夠最快速理解題目與隊友的想法，並抓出隊友的思考盲點並給予想法討論，直到我們想法達成共識後，我在進行 Coding 。</p>
<p>這樣有兩個好處，第一，由於我會與負責思考題目者進行想法討論，有時可以注意到題目思考者沒有注意到的細節，而不導致題目思考者在寫程式寫到一半時或 debug 時才發現自己想法上的漏洞。第二，我們其實有思考過一策略為每個人各自解題，會的就上機撰寫的模式。但我認為每個人都獨自在進行一個解題週期過於浪費時間，也容易使隊友感到疲乏，為甚麼呢？我定義的解題週期如下：</p>
<ol>
<li>看懂題目 -&gt; 閱讀能力</li>
<li>提出想法 -&gt; 透過過去的演算法知識進行思考</li>
<li>思考可行性 -&gt; 程式會不會太難寫、我是不是沒有注意到一些細節</li>
<li>上機撰寫 -&gt; 開始進行撰寫、Debug</li>
<li>解題成功 -&gt; 上傳後 AC</li>
</ol>
<p>我個人在解題目的經驗中，要自己再不休息的情況中重複解題週期至 4 題其實就已經感到疲憊，而其中要是在第四點才發現到一些重大問題時往往需要再回到第三點再來思考到底可不可行，對於腦袋會感到相當的疲憊，於是第二好處則是可以減少每個人的疲憊感，由於每個人進行專業分工了，大家只要在自己所負責的那項做好自己的工作就好，就能完美的分工完成解題週期。但第四點的執行者通常抗壓性要是最大、撰寫程式的能力必須要是全隊最優秀的。</p>
<h2 id="到底要當天去呢？還是提前一天去呢"><a href="#到底要當天去呢？還是提前一天去呢" class="headerlink" title="到底要當天去呢？還是提前一天去呢"></a>到底要當天去呢？還是提前一天去呢</h2><p>先說結論好了，提前一天去。因為我沒去過雲林阿，當然會想要去雲林看看搂。不過其實路途費比我想像的便宜住宿費只要 1280 元(3人房)，高鐵來回票也只要 1160元，有種突然覺得國內旅遊好便宜(不過雲林好像也沒什麼好玩的？哈哈哈哈)，也能給自己一天休息的機會，不會因為比賽早上睡過頭而導致特別敢的狀況發生在<a href="https://theriseofdavid.github.io/2020/03/23/contest_experence/Skill-Contest/" target="_blank" rel="noopener">2018 (107) 學年金手獎技藝競賽程式設計 - 金手第六心得</a>那次印象真的很深刻阿QQ。</p>
<ul>
<li>出發至雲林高鐵站<br><img src="/images/ncut2020_experience/1.jpg" alt=""></li>
</ul>
<h2 id="比賽前一天，緊張的前夕"><a href="#比賽前一天，緊張的前夕" class="headerlink" title="比賽前一天，緊張的前夕"></a>比賽前一天，緊張的前夕</h2><h3 id="漂亮的高鐵-and-疑？-沒有公車嘛！？"><a href="#漂亮的高鐵-and-疑？-沒有公車嘛！？" class="headerlink" title="漂亮的高鐵 and 疑？　沒有公車嘛！？"></a>漂亮的高鐵 and 疑？　沒有公車嘛！？</h3><p>我與隊友們相約在台北車站的南3門，大家都不太會迷路花蠻快的時間就找到了，不愧都讀北科，哈哈哈哈。我們透過高鐵到雲林時已經是 11:39 ，不得不說的是雲林高鐵站真的很漂亮，頗有機場的感覺，雲林縣政府讚讚，但是外面好荒涼QQ，我原本以為會是很熱鬧的地方結果沒有阿，公車客運也不像台北一樣方便，他們的公車反而不太像是公車是路與路之間的距離就一站，比較像是鎮與鎮的距離一站，有夠遠的…。</p>
<h3 id="路途中的小插曲"><a href="#路途中的小插曲" class="headerlink" title="路途中的小插曲"></a>路途中的小插曲</h3><p>後來我們搭計程車從雲林高鐵站到民宿(近虎尾科技大學，布拉格民宿)，這裡有一點跟台北不太一樣，台北的計程車是 70 元開始跳表，但雲林是從 100 開始，一開始有種心痛感，不過因為司機態度蠻不錯的，所以其時多給 30 元我還是可以接受拉，然後搭計程車其實感覺很不錯跟在台北搭計程車的感覺不同，離開了水泥叢林，到了田野間的地方，看著一路上的風景心情也不自覺得好了起來。</p>
<p>抵達民宿大約為 200 元，司機也提醒我說以後可以直接說到家樂福(民宿對面)，司機們都比較好知道地點在倆，到達民宿後我才發現我們可以入房的時間為下午 4 點阿，可是現在的時間是下午 1 點阿，這中間 3 個小時我要怎麼辦阿阿阿阿，這<font color="#dd0000"><strong>提醒以後的我以後住民宿必須先問幾點可以入住</strong></font>，不然的話就會發生跟我一樣的窘境QQ。</p>
<h3 id="小女孩是全世界最可愛的了！"><a href="#小女孩是全世界最可愛的了！" class="headerlink" title="小女孩是全世界最可愛的了！"></a>小女孩是全世界最可愛的了！</h3><p>幸好客服人員願意先讓我們把行李先寄放在民宿那不然我們就要拖著行李箱到處流浪了 ಥ⌣ಥ，樓下有很多夾娃娃機店，其中竟然有一個是夾蓮蓬頭的！有夠酷的，竟然還被我花 10 元夾到我超開心的而且雲林的夾娃娃機店可以夾一堆東西！例如：泡麵、舒跑…等。</p>
<div class="video-container"><iframe src="https://www.youtube.com/embed/evHanigiKq4" frameborder="0" loading="lazy" allowfullscreen></iframe></div>

<p>但是雲林的夾娃娃機店比便利商店還多很多害我很意外，還是雲林人如果家裡沒東西都是跑去夾娃娃機夾而不是去便利商店買阿XD。然後雲林縣立仁國小校舍好漂亮阿，害我也好想進去裡面就讀，然後小女孩真的是世界上最可愛的生物了٩(^ᴗ^)۶，不管是哪裡的小女孩。</p>
<h3 id="看完虎尾反觀北科？"><a href="#看完虎尾反觀北科？" class="headerlink" title="看完虎尾反觀北科？"></a>看完虎尾反觀北科？</h3><p>之後我們走到虎尾科技大學去參訪，虎尾科大比起台北科大來說大了許多，北科看起來真的就像小學一樣，而且他們還可以把機車停到校園裡面去真的是太棒了！北科甚麼時候也要跟進阿，外面的停車位還有夠難找的，我的愛車都被刮了 n 遍了 ಠ︵ಠ。不過他們廁所我覺得就沒有比北科好了，我們北科的廁所真的是非常漂亮 and 非常乾淨阿！每間廁所還都會有衛生紙，要是希望自己的廁所 always 都是乾淨的就來讀北科大吧！(<del>業配</del>)，開玩笑這是我的 Blog 幹嘛還要業配阿。</p>
<h3 id="雲林的夜生活"><a href="#雲林的夜生活" class="headerlink" title="雲林的夜生活"></a>雲林的夜生活</h3><p>回來的路上我們還去 KTV 唱歌 and 喝酒，這在高中的我不可能會這樣做的，考前就是要完全的嚴肅和認真準備阿，不過我的兩個隊友似乎不這麼覺得，來比賽還是要來體驗一下雲林的生活阿。我這次竟然下來雲林都沒有看程式阿…，罪惡感好重，不過 Entroy 唱歌真的很好聽，找他唱歌真得棒。</p>
<p>我們住的套房似乎是愛情套房，一進來就有一隻粉紅大熊，好可愛，我一直抱著他好想就這樣把她帶回家喔，對於分手後的我算是很大的精神安慰了 ಠ︵ಠ，然後這次睡覺我還搶了 Bill 的棉被QQ，對不起，我下次會意識到我睡覺會搶棉被得我也會注意<font color="#dd0000"><strong>下次在外面住雙人房時先跟客房人員要兩件棉被</strong></font>，辛苦你了嗚嗚嗚嗚嗚嗚。</p>
<ul>
<li>可愛的粉紅大熊<br><img src="/images/ncut2020_experience/2.jpg" alt=""></li>
</ul>
<h2 id="比賽當天，想法與思考的碰撞"><a href="#比賽當天，想法與思考的碰撞" class="headerlink" title="比賽當天，想法與思考的碰撞"></a>比賽當天，想法與思考的碰撞</h2><h3 id="開幕式"><a href="#開幕式" class="headerlink" title="開幕式"></a>開幕式</h3><p>比賽當天，我們先在虎尾科大資訊大樓外進行報到，之後進到階梯教室等待開幕式，其中開幕式的主辦單位曾說我們這比賽能夠讓一些無法勝過台清交成的科大學校也有機會得名次，當下真得是超級感動的 ಥ⌣ಥ，然後中午的便當我覺得還不錯吃只是飯有點乾再用筷子時不太方便，我也喝了能量飲料，希望能夠將自己體力充足在考試期間不會因為疲累而寫不好，但是能量飲料 75 元真的太貴了拉。</p>
<ul>
<li>比賽隊伍<br><img src="/images/ncut2020_experience/3.jpg" alt=""><br><img src="/images/ncut2020_experience/4.jpg" alt=""></li>
</ul>
<h3 id="甚麼-notebook-只能10頁！"><a href="#甚麼-notebook-只能10頁！" class="headerlink" title="甚麼 notebook 只能10頁！"></a>甚麼 notebook 只能10頁！</h3><p>我們在開幕時，接受到一個訊息是我們的筆記只能夠有 10 頁，但是我們準備了 20 頁阿！所以我們直接在當場臨時進行刪除大法，有夠緊張的。還因為沒有 latex 導致沒辦法快速生成 pdf，幸好後來 Entroy 急中生智用 online linux 來解決此危機，不然就要出事啦！</p>
<h3 id="比賽前的緊張"><a href="#比賽前的緊張" class="headerlink" title="比賽前的緊張"></a>比賽前的緊張</h3><p>當我們進去比賽的電腦教室，我發現到我周遭的其他隊們都非常吵鬧，給予我一種非常緊張的感覺，有種覺得自己是不是因為準備不足才會這麼緊張？但其實我這麼緊張也是合理的，畢竟我連歷屆試題都只有寫 4 題，肯定會緊張的吧！當下的自己只希望能夠盡量讓自己發揮自己的本事就好，不過 scoreboard 就在我的面前壓力還真的是挺大的XD。</p>
<h3 id="考試時的小插曲"><a href="#考試時的小插曲" class="headerlink" title="考試時的小插曲"></a>考試時的小插曲</h3><p>時間到，每隊開始準備進入解題環境時卻沒辦法進入，每隊幾乎都出現一個狀況為「比賽已開始，你需要輸入特定指令才能進入比賽」之類的狀況，幸好很快就解決，不到 10 mins ，主辦單位就將每台電腦輸入指令讓大家都能繼續比賽，不得不說主辦單位還挺不賴的。</p>
<h3 id="比賽開始了，顯現自己實力的時候到了！"><a href="#比賽開始了，顯現自己實力的時候到了！" class="headerlink" title="比賽開始了，顯現自己實力的時候到了！"></a>比賽開始了，顯現自己實力的時候到了！</h3><p>比賽的過程中，我開始負責駕駛，其他隊友開始進行解決與思考題目，我們在解題的過程中，一開始順利地解開 4 題。其中一開始我對於讀取一行字串中所有的數字是想用 stringstream 但我卻對那語法忘記不熟，如果再查會太浪費時間，後來 Entroy 想到用 getchar() 來解決這個問題真的是聰明，度過了最一開始的危機。</p>
<p><strong>在最後的 90 分鐘，突然我腦袋異常清醒，告訴我自己現在正是你要發揮、拯救團隊的時候，將自己所學的知識都運用上、放手一搏吧！</strong></p>
<p>在剩下 1 hr 30 min，開始卡關，有兩題並不難的題目卡關，其中 ProblemB 關於遞迴因為解不開，導致隊友開始設想要使用暴力解法，直接建立答案表，就可以達到 \( O(1)\)，原本這想法我有嘗試著跟他們溝通這想法並不好，因為我們有看到其他隊在解此題都特別快，只有我們卡關，所以我一直覺得是我們缺少了哪部分的想法，才會使我們一直 WA。</p>
<p>但是隊友有點不太能夠聽進我的想法，一直以自己的角度去思考，認為我們只要能夠把題目解開就好，所花費的時間成本再多都沒關係。結果則是發現實現上具有根本上的問題，所以不可以使用，後來我在最後半小時急中生智想到有可能是因為題目說數字最大只會到 \(2^{32}\)，但並沒有說中間計算時不會超過，於是我就使用 long long 解決了這問題，在危險中找到出路。</p>
<p>另外一題卡關的部分，就是 Problem C 題目是想要對樹進行追蹤，我第一直覺就是樹壓縮成一維陣列，然後再將資料向下延伸找回，Bill 的想法似乎跟我一樣，但他的想法我覺得錯誤了，他寫成一個 struct ，有點類似於線段樹，但其實不用那麼麻煩，我們後來在實現此方法時發現非常不友善，程式會花費太多時間。</p>
<p>後來我的另外兩位隊友想用 struct + pointer 來解決問題，當下的我聽到時是十分震驚的，因為我覺得這是個瘋狂的舉動，在比賽的時候寫 pointer 不確定性太大、Debug 時不方便，在不容易知道自己問題會在哪部分的情況下，不應該要用 pointer，在他們後來發現不可行後。根據我的想法將樹壓縮一維陣列並透過遞迴實現，透過 Bill and Entroy 在我旁邊 Debug 與檢查錯誤讓我們在最後半小時內也對了這題，隊友也是很重要的！ </p>
<h3 id="比賽結束了，名次到底是第幾呢"><a href="#比賽結束了，名次到底是第幾呢" class="headerlink" title="比賽結束了，名次到底是第幾呢"></a>比賽結束了，名次到底是第幾呢</h3><p>由於最後一小時比賽會凍結排名，我們最後一次看到我們自己的成績是第 17 名，我非常緊張，感覺這樣有失自己的自尊，不過後來有在最後半小時解出兩題，應該名次會往前，當時的猜測是自己會是第五名 or 第六名，因為都是比較晚的時間送出應該會成績不會太漂亮，果不其然，跟我的預估一樣拿到第五名、金獎。而且金獎還是最後一個名額阿，運氣真的很好。也謝謝自己的隊友可以幫助我能夠拿到金獎，沒有他們我說不定連金獎也都沒有吧！</p>
<ul>
<li><p>頒獎拉，金獎的我們<br><img src="/images/ncut2020_experience/5.jpg" alt=""></p>
</li>
<li><p>很乖的 Entroy<br><img src="/images/ncut2020_experience/6.jpg" alt=""></p>
</li>
</ul>
<h2 id="賽後，回歸的旅途總是讓人疲憊"><a href="#賽後，回歸的旅途總是讓人疲憊" class="headerlink" title="賽後，回歸的旅途總是讓人疲憊"></a>賽後，回歸的旅途總是讓人疲憊</h2><p>我在比完賽後，認識到了一位就讀虎尾科大的工作人員，原因是因為我們在最後半小時成功解出兩題時太激動，才會不小心認識到的XD，對不起啦我下次不會那麼激動的QQ，而且他們個性也都很好願意可以讓我們將程式碼帶回來做檢討跟讓我放在 Blog 可以讓未來的我觀看，也讓她告訴我哪裡有好吃的，真的，認識新朋友的感覺真的很棒。<del>但是我們都在互嘴，哈哈哈哈</del></p>
<p>由於閉幕式後，我們的高鐵是晚上 9 點，但時間才 5 點，於是我們去虎尾附近逛逛，不得不說其實虎尾的路很大條、很好走，車流量也不多挺舒服的。但是我們在比賽的過程中卻收到空汙警報，讓我覺得這裡的人好可憐阿QQ，希望台灣的每個工廠與人們都能有良心，守護好台灣人的健康與生態環境。</p>
<p>最後回到高鐵站時，我與 Bill 在虎尾高鐵站外走走聊天，晚上的雲林其實空氣挺不錯的，而且讓我對雲林的印象很加分，東西好吃、便宜，人也都蠻熱情、計程車司機們也都很友善，讓我很喜歡這裡的人事物，突然有種不想回台北的感覺呢！</p>
<ul>
<li>晚間的雲林高鐵站<br><img src="/images/ncut2020_experience/7.jpg" alt=""></li>
<li>返程的高鐵車票<br><img src="/images/ncut2020_experience/8.jpg" alt=""></li>
</ul>
<h2 id="浪漫的情話"><a href="#浪漫的情話" class="headerlink" title="浪漫的情話"></a>浪漫的情話</h2><p>我在回程的過程中，突然想到一段話，如下：<br>A: 北港在嘉義，那南港在哪裡呢？<br>B: 台北嗎?<br>A: 而我現在就在中間當南港與北港的橋梁，把南北港的思念相互傳達到彼此。</p>
<p>天阿，自己真的好浪漫喔，哈哈哈哈。<del>神經病</del></p>
<h2 id="賽後檢討"><a href="#賽後檢討" class="headerlink" title="賽後檢討"></a>賽後檢討</h2><p>每次的比賽都需要檢討才能讓自己更完美，我個人在這次賽後有想要提出一些檢討，如下:</p>
<ol>
<li>相信駕駛員的判斷、信任駕駛員<br>為甚麼會這樣說呢？因為我覺得我在這次比賽時發現一個問題，如果想法者思考錯誤時他並不會發現錯誤，但當駕駛員無法在當下提出有力證據時，容易造成衝突，勢必要給想法者去實際駕駛一遍才能夠讓他理會，但是這樣可能會浪費多餘時間。但我也無法保證駕駛員是對的，所以駕駛員必須學會一件事情就是，要是自己沒有足夠的把握就不要否定他人想法。</li>
<li>練習時，盡量讓想法者也可以寫些題目<br>因為想法者在思考題目時，大多只有思考重點的想法，忽略掉一些小細節，而往往魔鬼藏在細節裡，常常都是因為細節而讓 Coding 變得窒礙難行，或是在原本完整的程式必須要加上現在才發現的細節但卻沒有空間讓程式修改，所造成的麻煩，於是建議隊友都能寫一些來了解題目，不需要很多。比例大約駕駛員 4 : 想法者 1 即可。</li>
<li>需要有副駕駛員<br>駕駛員思考的路上真的會累，需要有第二人來輪替會更好。</li>
<li>需要更多練習<br>我們練習的時間真的不夠多，科大程式競賽歷屆試題連完整的一年都沒有實際寫過。下次要把他寫完</li>
<li><del>不要看到太漂亮的女生就呆住</del><br><del>容易今天戀愛，今天失戀。真的好難過QQ，但是皮膚白白的女生真的好可愛 (◍•ᴗ•◍)❤️</del></li>
<li>團隊氣氛更好<br>這點 Bill 做得還不錯，很感謝他 ಥ⌣ಥ</li>
<li>必須先詢問民宿幾點可以入住</li>
<li>如果睡雙人床準備兩個棉被QQ</li>
</ol>
<p><strong>希望我的未來能夠變得更好，與我的夥伴朋友共同努力。</strong></p>
<h2 id="後記"><a href="#後記" class="headerlink" title="後記"></a>後記</h2><p>也感謝系主任願意補助我經費讓我去參加比賽，讓我無後顧之憂放心大膽一博。然後與我無關真的好好聽，我聽了 4 小時都不會膩，打這篇心得也花了我 4 小時跟打比賽一樣久呢！不說了要去睡覺了拉，下台一鞠躬。</p>
<h2 id="競賽結凍後的總成績"><a href="#競賽結凍後的總成績" class="headerlink" title="競賽結凍後的總成績"></a>競賽結凍後的總成績</h2><p><img src="/images/ncut2020_experience/9.jpg" alt=""></p>
<h2 id="金獎"><a href="#金獎" class="headerlink" title="金獎"></a>金獎</h2><img src="/images/ncut2020_experience/10.jpg" style="border:2px black solid ;box-shadow:12px 12px 12px gray;padding:5px;">

<h2 id="第五名"><a href="#第五名" class="headerlink" title="第五名"></a>第五名</h2><img src="/images/ncut2020_experience/11.jpg" style="border:2px black solid ;box-shadow:12px 12px 12px gray;padding:5px;">

<h2 id="北科資財官網恭賀得獎"><a href="#北科資財官網恭賀得獎" class="headerlink" title="北科資財官網恭賀得獎"></a>北科資財官網恭賀得獎</h2><p><img src="/images/ncut2020_experience/12.PNG" alt=""></p>
]]></content>
      <categories>
        <category>競賽心得</category>
      </categories>
      <tags>
        <tag>大學Life</tag>
        <tag>ICPC</tag>
        <tag>第五屆全國科技大專校院程式競賽</tag>
        <tag>程式比賽</tag>
        <tag>競賽心得</tag>
        <tag>人生旅途</tag>
      </tags>
  </entry>
  <entry>
    <title>2018 (107) 學年金手獎技藝競賽程式設計 - 金手第六心得</title>
    <url>/2020/03/23/contest_experence/Skill-Contest/</url>
    <content><![CDATA[<h2 id="程式設計競賽心得："><a href="#程式設計競賽心得：" class="headerlink" title="程式設計競賽心得："></a>程式設計競賽心得：</h2><blockquote>
<p>這篇是打給未來、或是已經是程式設計技藝競賽選手的你。</p>
<p>我之前是 107 程式設計技藝競賽金手獎第六名的選手，我覺得過程中需要的是毅力與耐心，程式設計是很機車的技藝競賽，你只有兩種狀況，會與不會。</p>
<p>所以你必須要有一個覺悟，把不會的都學會，透過腦袋與紙筆將程式一一推導出來</p>
<p>學長那年是用 visual basic 撰寫，我個人偏希望改使用 C++ ，我認為對於未來學生的學習會有更好的體驗與幫助</p>
</blockquote>
<a id="more"></a>

<h2 id="對於程式的初學者："><a href="#對於程式的初學者：" class="headerlink" title="對於程式的初學者："></a>對於程式的初學者：</h2><p>建議先不要從歷屆試題開始寫，難度應該對你來說有點高(<strong>要是不會的話證明你太強了，跳下一 part 吧</strong>)，如果初期就不太能將 simple 程式寫出來的話，挫折感會很重，你不看網路、不看學長姐之前所留下的資料基本上你很難寫出來(除非你是愛因斯坦，那你也不會看到我這篇文章了，對吧！)，先試這閱讀學長姐的 code ，不會的就問學長姐，當年是怎麼構思的，熟悉學長姐的思路後，之後看學長姐的程式碼會如魚得水。</p>
<p>要是沒有學長的幫助話，建議可以將歷屆前 3 名的程式檔案都下載下來，仔細閱讀與品嘗(短可 10 秒鐘，長可 10 小時)，我在學習之路上有一句話對我獲益良多 <font color="#dd000">模仿是最好的學習</font> ，也希望大家能體驗到箇中滋味！</p>
<h2 id="程式路途中："><a href="#程式路途中：" class="headerlink" title="程式路途中："></a>程式路途中：</h2><h3 id="資料結構-Tree-："><a href="#資料結構-Tree-：" class="headerlink" title="資料結構(Tree)："></a>資料結構(Tree)：</h3><p>對於技藝競賽來說，她十分單純又十分好懂(天啊，我都想戀愛了)，熟悉結構、走訪一遍，對你來說就不會是一個難題。<br>真的不懂就找老師，千萬不要硬撐。如果覺得沒人問的話，可以來找作者(在關於我可以看到我的連絡資訊)</p>
<h3 id="演算法與動態規劃-Algorithm-and-Dynamic-programming-："><a href="#演算法與動態規劃-Algorithm-and-Dynamic-programming-：" class="headerlink" title="演算法與動態規劃(Algorithm and Dynamic programming )："></a>演算法與動態規劃(Algorithm and Dynamic programming )：</h3><p>我建議你可以先嘗試自己寫寫看或自己慢慢推導出來，這很有趣(如果是只為了拿獎找國立科大的人來說，這裡會是一個死穴，會對你們 so boring)，但<font color="#dd0000">前提是有足夠時間練習</font>，不然就放棄掉，反正技藝競賽演算法最多只有兩題。</p>
<h2 id="賽前建議："><a href="#賽前建議：" class="headerlink" title="賽前建議："></a>賽前建議：</h2><p>可以在重寫一遍全部的歷屆試題(學術科)，在重寫中，也許會讓你體驗到新領悟，這在當時的我給予了我很大幫助，不過建議你改成用原子筆開始作圖，因為我這屆限定只能用考場提供的原子筆來 做圖，不可私下帶文具。</p>
<p><font color = "#dd0000">健保卡、身分證一定要帶。</font>我當年就是忘記帶，還特地在板橋火車站請爸媽幫我送過來，到現在還是很謝謝母親願意放下手邊的事物照顧一個不成材的兒子，真的十分感謝。</p>
<h2 id="感謝的話："><a href="#感謝的話：" class="headerlink" title="感謝的話："></a>感謝的話：</h2><p>在這邊還是有些感謝的話要說，畢竟我不是只靠著我一個人努力上來的。</p>
<h3 id="吳勝雄老師："><a href="#吳勝雄老師：" class="headerlink" title="吳勝雄老師："></a>吳勝雄老師：</h3><p>幫助我排除很多關於程式設計的問題，也給予我許多在學習上的建議，就算在獨自一人的情況下也可以藉由網路排除些學習上的障礙，也陪伴我磨練。 <del>還會拿他的早餐給你吃</del><br>在技藝競賽後，我也跟著他學習了許多其他知識，受益良多。</p>
<h3 id="高鈺成學長："><a href="#高鈺成學長：" class="headerlink" title="高鈺成學長："></a>高鈺成學長：</h3><p>由於我上一屆是空缺，加上科上並沒有留下甚麼資料給我，我當年的環境十分刻苦且艱辛，學長(高鈺成學長比我大兩屆)願意回來提點我程式，並毫不客氣地將之前他寫得作品給予我，讓我在不懂時可以品嘗他的程式碼、了解思路、解惑我的疑問。</p>
<h3 id="孫龍生老師："><a href="#孫龍生老師：" class="headerlink" title="孫龍生老師："></a>孫龍生老師：</h3><p>我程式的啟蒙老師，他奠定了我寫程式的基礎，也是他在程式初期給予了我信心，度過前陣子的難關。</p>
<h3 id="勞裕安老師："><a href="#勞裕安老師：" class="headerlink" title="勞裕安老師："></a>勞裕安老師：</h3><p>勞裕安老師使我的不成熟與稚氣逐建消失，取代而之的是穩重與成長。要是沒有他對我的諄諄教誨，或許我沒有辦法成長到讓老師們放心讓我參加技藝競賽吧！</p>
<h3 id="陳建名："><a href="#陳建名：" class="headerlink" title="陳建名："></a>陳建名：</h3><p>陪伴我高 2,3 ，最重要的人呢，要是沒有你也許我甚麼都不是，生命中的貴人，比賽好戰友。<br>也謝謝你願意將選手的位置退讓給我，讓我有一個發展的舞台。</p>
<h3 id="在選手室中陪伴我的各位："><a href="#在選手室中陪伴我的各位：" class="headerlink" title="在選手室中陪伴我的各位："></a>在選手室中陪伴我的各位：</h3><p>我想，可能會有人不喜歡我將名字透露出來，於是就不透露了。</p>
<p>在選手室的練習中，我度過很愉快的時光，在難過時有陪伴，在開心時有玩伴。<br>大家互相支援、互相努力的感覺真的不錯，有時真的懷念起來。</p>
<h3 id="看這篇文章的朋友們："><a href="#看這篇文章的朋友們：" class="headerlink" title="看這篇文章的朋友們："></a>看這篇文章的朋友們：</h3><p>如果有看到這份文章，希望能夠記得我，我不求甚麼利益回饋，我只求當我看到新的程式大神曾看過我的文章並在我文章中獲得新知識，我就很滿足了。</p>
<h2 id="最後："><a href="#最後：" class="headerlink" title="最後："></a>最後：</h2><p>最後的最後，還是要放上一張照片來做總結吧。</p>
<img src="https://i.imgur.com/eAtInHR.jpg" alt="Skill-Contest me and teacher.jpg">

]]></content>
      <categories>
        <category>競賽心得</category>
      </categories>
      <tags>
        <tag>高中Life</tag>
        <tag>程式比賽</tag>
        <tag>競賽心得</tag>
        <tag>人生旅途</tag>
      </tags>
  </entry>
  <entry>
    <title>git 在使用其他電腦 remote 同網址時問題</title>
    <url>/2020/07/11/git/git-branch-problem/</url>
    <content><![CDATA[<h2 id="文章大意"><a href="#文章大意" class="headerlink" title="文章大意"></a>文章大意</h2><blockquote>
<p>當你在使用 git remote 一個曾被其他電腦 remote 的 Repositories 時，發生該 branch 已存在時的解決方式</p>
</blockquote>
<a id="more"></a>

<h2 id="問題概述"><a href="#問題概述" class="headerlink" title="問題概述"></a>問題概述</h2><p>使用者遇到先前有對一個網址進行 remote ，接下來在新電腦使用 remote 就不能 remote 時該怎麼辦?</p>
<h2 id="解決問題"><a href="#解決問題" class="headerlink" title="解決問題"></a>解決問題</h2><p>換新的分支，也就是原先可能是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote add A &lt;url&gt;</span><br></pre></td></tr></table></figure>
<p>變成</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote add B &lt;url&gt;</span><br></pre></td></tr></table></figure>
<p>就可以把此問題解決，沒想到我之前都沒遇過這問題，今天才遇到啊！</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>git 教學 - 與作者的金魚腦</title>
    <url>/2020/03/09/git/git-tutorial/</url>
    <content><![CDATA[<h2 id="git-教學"><a href="#git-教學" class="headerlink" title="git 教學 :"></a>git 教學 :</h2><blockquote>
<p>想怎麼學會使用 git 操作 github ? 那就觀看這篇文章就對喔~</p>
</blockquote>
<a id="more"></a> 

<p><a href="https://gitbook.tw/chapters/github/push-to-github.html" target="_blank" rel="noopener"> Git教學 </a></p>
<img src="https://coder.tw/wp-content/uploads/2017/02/github-825x510.png" alt="github.png" >

<p><a href="https://stackoverflow.com/questions/8044675/pull-is-not-possible-because-you-have-unmerged-files-git-stash-doesnt-work-do/25453407" target="_blank" rel="noopener">git pull</a> 遇到狀況時排解</p>
<h4 id="git-push-強制接案"><a href="#git-push-強制接案" class="headerlink" title="git push 強制接案"></a>git push 強制接案</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>


<h2 id="附註"><a href="#附註" class="headerlink" title="附註 :"></a>附註 :</h2><p>大神寫得太好，小弟我只能自嘆不如</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>手機探險記(大一)</title>
    <url>/2020/04/13/life_experence/Lost-Phone-In-20200413/</url>
    <content><![CDATA[<h2 id="一天一口氣丟掉兩次手機"><a href="#一天一口氣丟掉兩次手機" class="headerlink" title="一天一口氣丟掉兩次手機"></a>一天一口氣丟掉兩次手機</h2><p>今天早上騎車的時候手機跳海了，我去到北科才發現，我以為是我放在家裡面。結果不是！</p>
<p>後來我查了手機定位竟然定不到，在此奉獻各位台灣之星的網路真的沒事不要亂用，警察叔叔的保險櫃是沒辦法收到訊號的喔！</p>
<p>再來，感謝的話，<br>嗚嗚嗚嗚，幫我撿手機到警察局的人真的好感謝(◍•ᴗ•◍)❤️<br>我從現在開始實施有禮貌運動（不說髒話，說好話，行善事）<br>然後警察真的很友善。真的<br>然後謝謝realme, 跳海了之後還會回到主人身邊。<br>愛你啦♡(&gt; ਊ &lt;)♡</p>
<p>警局的部分:<br><img src="https://i.imgur.com/C5m5OSU.jpg"></p>
<h2 id="題外話的部分："><a href="#題外話的部分：" class="headerlink" title="題外話的部分："></a>題外話的部分：</h2><ol>
<li><p>意識到自己手機可能在警察局時，我打電話過去給了警察，警察叫我過去一趟時，我詢問下「不好意思，警察局大約什 麼時候會休息了？」，一群警察大笑，我們警察局不休息喔~<br>24小時都在營業。<br>我覺得我需要補充我的常識.</p>
</li>
<li><p>在警察局時，警察說我很幸運，在騎車的情況下，手機跳海還沒事，重點是尖峰時段，你的手機避開了其他人的車子沒被碾壓，看來你的手機求生慾很高很高，我跟警察說「對啊，因為他很愛我」，怕我沒了他就不行。</p>
</li>
<li><p>晚上回到家後，我又發現我的手機又不見了，於是我又在定位了一次，發現我的手機丟在了機車上，又忘記拿回來。看起來手機不太喜歡主人呢！一天跑走兩次。</p>
</li>
</ol>
<p>手機根本不愛我吧！他只是想要換主人而已ಥ‿ಥ</p>
<p>在這邊我像手機懺悔。對不起，我不應該讓你每個月都傳輸近500g。不應該讓你清明連假24小時都被操。<br>怕你以後又逃走。我以後會增強用量，目標一個月800G，讓你忙到沒辦法逃走的 ಥ╭╮ಥ, 不過我還是很愛你的(◍•ᴗ•◍)❤️(*＾3＾)/～♡</p>
]]></content>
      <categories>
        <category>人生旅途</category>
      </categories>
      <tags>
        <tag>大學Life</tag>
        <tag>人生旅途</tag>
        <tag>旅遊日記</tag>
      </tags>
  </entry>
  <entry>
    <title>BLOG 經驗分享</title>
    <url>/2020/07/20/life_experence/blog-experience/</url>
    <content><![CDATA[<h2 id="我為甚麼會寫-BLOG"><a href="#我為甚麼會寫-BLOG" class="headerlink" title="我為甚麼會寫 BLOG"></a>我為甚麼會寫 BLOG</h2><blockquote>
<p>因為我在高中的時候，練習科展、專題、演算法，大都是看網路上大神的 BLOG，學習他們的程式、邏輯概念、思考模式，這讓我在 2020/03/07 時有了動機，我應該幫助我自己建立一個 BLOG，來整理自己的思緒、也將自己遇到的一些狀況記錄下來，未來如果有用到也不會忘記，用俗話一點說就是不想要把知識再還給老師，知識還要是我的!</p>
</blockquote>
<a id="more"></a>

<h2 id="BLOG-一開始遇到的狀況"><a href="#BLOG-一開始遇到的狀況" class="headerlink" title="BLOG 一開始遇到的狀況"></a>BLOG 一開始遇到的狀況</h2><p>老實說，一開始在撰寫 BLOG 時，我的文字表達能力並不是很好，時常打出來的文字都不滿意，詞不達意，可能現在也是一樣XD。於是這讓我在一開始寫 BLOG 時遇到了些許障礙，有點沒有動力寫，因為我寫一個題目的時間比我打出一份我的解題心得還要久時我就有點卻步了。</p>
<h2 id="那為甚麼還有動力繼續寫"><a href="#那為甚麼還有動力繼續寫" class="headerlink" title="那為甚麼還有動力繼續寫?"></a>那為甚麼還有動力繼續寫?</h2><p>這就真的是件很神奇的事情了，通常大家都說人在做一件事情時 3個月就會把他的熱情降低至百分之 50%，可能就不再願意繼續做。但為甚麼我會繼續做呢?因為我用到了！在科大程式競賽時，我需要做一些快速複習演算法的時候，這 BLOG 就派上用場了！很神奇，因為我會對我打過的心得有印象，於是我只需要大概看一下就可以恢復很大的記憶，這在我之前沒有寫 BLOG 時是不一樣的，我常常忘記就要再上網翻資料，但上網的資料有時候營養成分又不高會很浪費時間，所以現在我就一樣繼續寫 BLOG 寫到現在~</p>
<h2 id="BLOG-伴隨著我成長的鏡子"><a href="#BLOG-伴隨著我成長的鏡子" class="headerlink" title="BLOG 伴隨著我成長的鏡子"></a>BLOG 伴隨著我成長的鏡子</h2><p>因為我會把我所學到的知識放入 BLOG 內，於是當我想跟別人說我會甚麼東西時，我可以直接快速的從 BLOG 翻閱給他看，讓他知道我是有這個實力，但要是這項事情是我沒有學過，而我將它學起來時，我則可以幫我的 BLOG 增加內容，也幫我記錄下許多資料，讓我又成長了些。或是朋友們想要跟我學些東西時，我就可以將我的 BLOG 給他看，減少溝通上的失誤，也避免掉浪費時間。畢竟時間一長很多事情是會忘記的，但記錄下來後可以快速瀏覽紀錄來喚起回憶。</p>
<h2 id="甚麼，大衛！你竟然還把你的-BLOG-丟掉-google-上！"><a href="#甚麼，大衛！你竟然還把你的-BLOG-丟掉-google-上！" class="headerlink" title="甚麼，大衛！你竟然還把你的 BLOG 丟掉 google 上！"></a>甚麼，大衛！你竟然還把你的 BLOG 丟掉 google 上！</h2><p>這…其實只是我想要拉XD，因為我在學習的過程中我都是看著大家的 BLOG 才使我成長、前進。於是我也希望我可以抱持著這種精神，充足這個世界的知識量，也許我的知識可能淺薄，沒有營養。但我相信有些文章還是具有一定的影響程度，希望大家在觀看我的 BLOG、瀏覽我的知識時不要罵我怎麼那麼爛 QQ。</p>
<h2 id="整理-BLOG-真的很難"><a href="#整理-BLOG-真的很難" class="headerlink" title="整理 BLOG 真的很難"></a>整理 BLOG 真的很難</h2><p>整理 BLOG 真的是一件難事情，我到現在都還沒有抓到整理的重點，常常都要把我的文章全部打開(大約有 70 篇，在編寫此文章這時間點)，將分類與標籤重新改過，重新分類。打造出好讓我也好讓使用者可以快速查閱到他想要的資料，到現在我還不太確定我的分類到底能不能友善的讓使用者快速抓到他想要的文章，但是我正努力朝著邁進。</p>
<h2 id="提供-BLOG-主題的大神，非常感謝"><a href="#提供-BLOG-主題的大神，非常感謝" class="headerlink" title="提供 BLOG 主題的大神，非常感謝"></a>提供 BLOG 主題的大神，非常感謝</h2><p>有了這些提供 BLOG 主題的大神，我才可以致力於編寫文章，而不用受限於其他技術之苦。 hexo 幫助了我可以快速將文章發布在 github，ayer 主題則幫助我打造出漂亮的網站，我都十分感謝。要是未來我有機會，我也想要回饋你們，謝謝。</p>
<h2 id="更新日誌"><a href="#更新日誌" class="headerlink" title="更新日誌"></a>更新日誌</h2><p>2020/07/20 00:50:23 - 完成 6 段落</p>
<ul>
<li>BLOG 一開始遇到的狀況</li>
<li>那為甚麼還有動力繼續寫?</li>
<li>BLOG 伴隨著我成長的鏡子</li>
<li>甚麼，大衛！你竟然還把你的 BLOG 丟掉 google 上！</li>
<li>整理 BLOG 真的很難</li>
<li>提供 BLOG 主題的大神，非常感謝</li>
</ul>
]]></content>
      <categories>
        <category>人生旅途</category>
      </categories>
      <tags>
        <tag>Blog</tag>
        <tag>人生旅途</tag>
      </tags>
  </entry>
  <entry>
    <title>不應該讓女朋友做的事情，男朋友應該要做的事</title>
    <url>/2020/05/20/life_experence/heart-break-with-girl-friend/</url>
    <content><![CDATA[<h2 id="致感情路上受傷的各位："><a href="#致感情路上受傷的各位：" class="headerlink" title="致感情路上受傷的各位："></a>致感情路上受傷的各位：</h2><blockquote>
<p>今天，我被分手了。<br>於是今天的我沒有什麼心情寫程式，就讓我來抒發我的情緒吧</p>
</blockquote>
<a id="more"></a>

<ol>
<li><p>絕對不可以玩交友軟體<br> 透過交友軟體上認識的男生，一定會讓你安全感很不足吧！我就是，我會時常懷疑我女朋友有沒有背著我偷腥，有沒有亂來，時常活在這種陰影下（加上我之前有被劈腿的經驗），一朝被蛇咬，十年怕草繩，這種事情千萬不准讓女朋友做。</p>
</li>
<li><p>相信女朋友<br>相信女朋友是件很重要的事，如果懷疑了，一發現，當下除了暴怒以外真的沒有什麼好說；雖然我做出了衝動的事，但是我覺得我沒錯；但是分手了，我很難過。至少相信會比不相信來的開心吧！</p>
</li>
<li><p>學會說話<br>也許可能看起來會很壞吧！但這就是我啊！不可否認的。我喜歡親親抱抱摸摸，但女朋友不一定喜歡，如果你真的很喜歡的話，請想進一切辦法哄他，讓女友願意陪你做，不要像這個笨蛋一樣，不會哄只會明白地說，搞的女朋友越來越不喜歡我….，也是因為我是寫演算法的吧，習慣性白話不會扭扭捏捏。</p>
</li>
</ol>
<h2 id="剩下就是想對自己說的話"><a href="#剩下就是想對自己說的話" class="headerlink" title="剩下就是想對自己說的話"></a>剩下就是想對自己說的話</h2><p>大衛，我覺得你已經很努力想把自己做的更完美了，也許只是自己真的不夠優秀吧。<br>其實，老實講，我生長在一個不是很健全的環境，雖然有兩個很努力要給予我好環境的父母，但是他們時常爭執，已經對我的心靈早就造成了很大的影響，如果你看過我應該就會知道我其實是個有點幽默感又有點正義感的人，但其實我的內心是很想要有一個人陪伴我，我想要有人可以保護我，在我努力時對我說辛苦了，在我難過時可以抱抱我，能對於我的直白不感到生氣，我喜歡把我當下的情緒訴說出來，我不擅長掩飾，我的難過就是難過。我也想要被人疼愛阿…。不是被分手、被說白目、因為其他男生而吃醋。</p>
<p>也許，我們在一起的時間不久。但是我真的很喜歡妳，還沒改變過。雖然我並不是、並不能擁有平淡幸福的人(我真的覺得我不配，我生長的環境，就是建立在別人的痛苦上。透過人的慾望來滋潤我成長)，曾經最好也是最棒的女朋友，謝謝你的陪伴。也許我還是沒辦法變的優秀，至少我還曾經被你相信過，我可能應該要感到非常慶幸…。</p>
<h2 id="也許痛苦才是愛情的本質"><a href="#也許痛苦才是愛情的本質" class="headerlink" title="也許痛苦才是愛情的本質"></a>也許痛苦才是愛情的本質</h2><p>由感而發的創作才會讓人感人肺腑吧。</p>
<p><strong>馬車總有一天會變回南瓜的，我們的愛情也總有一天會結束，期待下次的見面，我最愛也最想擁抱的人。</strong><br><strong>在下次見面之前，我會在夢中與現實長大，讓你不後悔我們的相遇。</strong></p>
<h2 id="題外話"><a href="#題外話" class="headerlink" title="題外話"></a>題外話</h2><p>雖然很不道德，但是我覺得我蠻支持婚後性行為的，我會害怕，我會想佔有我女朋友的全部。這樣會很自私嗎？會的話我很抱歉，但是要是沒有這樣的話，我會做惡夢，活在深淵之中阿…</p>
<h2 id="這是在痛苦與難過中，寫出來的。文筆絕對是不好的，但是這是我的內心世界，我必須要學會接納自己。"><a href="#這是在痛苦與難過中，寫出來的。文筆絕對是不好的，但是這是我的內心世界，我必須要學會接納自己。" class="headerlink" title="這是在痛苦與難過中，寫出來的。文筆絕對是不好的，但是這是我的內心世界，我必須要學會接納自己。"></a>這是在痛苦與難過中，寫出來的。文筆絕對是不好的，但是這是我的內心世界，我必須要學會接納自己。</h2>]]></content>
      <categories>
        <category>人生旅途</category>
      </categories>
      <tags>
        <tag>大學Life</tag>
        <tag>人生旅途</tag>
      </tags>
  </entry>
  <entry>
    <title>經驗談 - 備審資料 (高中升大學)</title>
    <url>/2020/03/24/life_experence/enrollment_to_university/</url>
    <content><![CDATA[<h2 id="人生，只是一張單程票，且選擇不會在你"><a href="#人生，只是一張單程票，且選擇不會在你" class="headerlink" title="人生，只是一張單程票，且選擇不會在你"></a>人生，只是一張單程票，且選擇不會在你</h2><p>製作備審資料，真的要求的不多，只要求作者願意做，讀者願意聽。足矣。</p>
<p>高三下時，我獲獎算還多的 (在高職生中應該有算到前 5 %，可能對於高中生來說，可能是前 10 % 的經歷吧，不清楚)，明明事實證明有了十足的把握一定有國立科大可以上，但做為人，對於人生大事還是會害怕的。於是我在做備審資料時，還是十分努力的。</p>
<h2 id="備審資料製作注意事項："><a href="#備審資料製作注意事項：" class="headerlink" title="備審資料製作注意事項："></a>備審資料製作注意事項：</h2><ol>
<li>字要清楚</li>
<li>重要的要讓讀者能閱讀到</li>
<li>將自己表達清楚</li>
<li><del>讀者願意觀看</del></li>
</ol>
<h2 id="作者的話："><a href="#作者的話：" class="headerlink" title="作者的話："></a>作者的話：</h2><p>看完我的備審資料，也許你會得到新的領悟，我認為，有些東西還是用作品才能表達出來。</p>
<p>作者曾經很努力的做過備審資料，但自認為回報給予得太少 (可能是我太貪心)，哈哈哈哈，當初為了想備審資料的排版、封面，那真的很難。對於一個會寫點程式設計的小孩卻沒有任美感的小孩，做出一份讓他人賞心悅目的作品非常困難。</p>
<p>最後這份備審資料的戰績公布給大家：</p>
<p>台科 不錄取  資訊管理系<br>北科 正取    資訊與財金管理系<br>北商 備5     資訊管理系<br>中科 備3     資訊管理系<br>高科 備7     資訊管理系</p>
<p>有時候這就是命運的安排，由不得自己，明明一心只想寫程式，卻只有一間學校正取，科系對於程式的比例又不高，也許這就是緣分吧</p>
<h2 id="警告："><a href="#警告：" class="headerlink" title="警告："></a>警告：</h2><p>此備審資料嚴禁抄襲，僅供使用者參考。</p>
<p><a href="https://drive.google.com/file/d/1hO9-citl3ywVZuq4Mea4a0nFHNLLIm7m/view?usp=sharing" target="_blank" rel="noopener">大衞的備審資料 - 台北科大</a></p>
]]></content>
      <categories>
        <category>人生旅途</category>
      </categories>
      <tags>
        <tag>高中Life</tag>
        <tag>人生旅途</tag>
      </tags>
  </entry>
  <entry>
    <title>2019 新北市薦送高中職學生赴日本技職研習參訪活動</title>
    <url>/2020/07/20/life_experence/japan-experience-for-skill-contest/</url>
    <content><![CDATA[<h2 id="主要內容"><a href="#主要內容" class="headerlink" title="主要內容"></a>主要內容</h2><blockquote>
<p>紀錄我在高三下時因為參加 2018（107）學年度全國高級中等學校商業類學生技藝競賽程式設計職種 金手獎［第六名］，而赴日本技職研習參訪活動，透過 Pdf 呈現。<br>花了5個小時的嘔心瀝血之作，十分漂亮</p>
</blockquote>
<a id="more"></a>

<h2 id="封面預覽"><a href="#封面預覽" class="headerlink" title="封面預覽"></a>封面預覽</h2><p><img src="/images/japan-experience-for-skill-contest/1.jpg" alt=""></p>
<h2 id="PDF-LINK"><a href="#PDF-LINK" class="headerlink" title="PDF LINK"></a>PDF LINK</h2><p><a href="https://drive.google.com/file/d/1WoWHRXa7AHoaa6X6kIyEKEe1-W6_x1ZA/view?usp=sharing" target="_blank" rel="noopener">2019 新北市薦送高中職學生赴日本技職研習參訪活動旅遊日誌</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>我很喜歡金手獎遇到的人事物，也跟他們都成為了好朋友，希望未來的我可以更加優秀，能夠和他們一起耀眼，也謝謝大雄老師不厭其煩地陪我、開導我的人生，您說的那份愛情與故事我銘記在心。</p>
]]></content>
      <categories>
        <category>人生旅途</category>
      </categories>
      <tags>
        <tag>高中Life</tag>
        <tag>日本</tag>
        <tag>人生旅途</tag>
        <tag>旅遊日記</tag>
      </tags>
  </entry>
  <entry>
    <title>與國小好朋友高雄屏東四天行</title>
    <url>/2020/08/18/life_experence/kaohsiung-playing20200804/</url>
    <content><![CDATA[<h2 id="說明"><a href="#說明" class="headerlink" title="說明"></a>說明</h2><blockquote>
<p>記錄我從台北到高雄與國小四位好朋友的遊玩紀錄<br>張智翔<br>郭人豪<br>劉威廷<br>謝謝你們的陪伴，沒有你們還真不行</p>
</blockquote>
<a id="more"></a>

<h2 id="8-月-4-日，用下雨來歡迎我的高雄"><a href="#8-月-4-日，用下雨來歡迎我的高雄" class="headerlink" title="8 月 4 日，用下雨來歡迎我的高雄"></a>8 月 4 日，用下雨來歡迎我的高雄</h2><p>哇哇哇，每站皆停的高鐵從台北一路坐到高雄真的屁股好痛啊…，不過其實很平穩的，高鐵讚讚。</p>
<p>我們感覺智翔老大，給我們可以住漢來大飯店，漢來真的高級，真的。至少我看那個大廳可以把我家的房子重蓋 10 遍都不是問題吧！我們住在 29 樓，視野真的不賴。</p>
<p>漢來大飯店視野<br><img src="/images/kaohsiung-playing20200804/1.jpg" alt=""></p>
<p>然後這也是我第一次操作咖啡機…，咖啡機好難操作，台北俗表示難過 ಥ⌣ಥ</p>
<p>之後我們去試試看漢來的三溫暖，跟日本的一樣要全裸，看來是我要比大小的時候了！沒拉，大家都差不多…，三溫暖的熱水真的好舒服、冷水我不敢碰，之後則是進去蒸氣室，蒸氣室裡面有鹽巴，可以抹在自己身上，我不小心抹太多，讓自己吃到鹽巴…，好鹹。</p>
<p>晚上是個下雨天，我們威廷老大也在這時候開始登場了，我們先去租借明天要去墾丁的汽車，之後去買消夜與酒來看著海景在一起吃飯蠻浪漫的，我很喜歡。</p>
<p>結束之前來一張合照。<br><img src="/images/kaohsiung-playing20200804/2.jpg" alt=""></p>
<h2 id="8-月-5-日，我的第一次墾丁"><a href="#8-月-5-日，我的第一次墾丁" class="headerlink" title="8 月 5 日，我的第一次墾丁"></a>8 月 5 日，我的第一次墾丁</h2><h3 id="白天的墾丁"><a href="#白天的墾丁" class="headerlink" title="白天的墾丁"></a>白天的墾丁</h3><p>起床梳洗後，我們則準備離開漢來要前往墾丁，其中我們智翔在當司機時，我們威廷哥哥倒是很想要當司機，兩個人不斷在講誰要開車，真的蠻有趣 XD。其中，他們在某一次紅綠燈有了這段對話，太有趣了！<br><img src="/images/kaohsiung-playing20200804/3.jpg" alt=""></p>
<p>再前往墾丁的路上先去吃了一間海產店，不得不說高雄的海產都很便宜。還有我們人豪哥哥願意幫忙剝蝦，這樣我就不用說我對蝦過敏了 XD。在墾丁的路上，我們劉董事長一直很期望可以住進夏都，但我們翔老大一句話解決，「靠我們威董 joe 一下了」。</p>
<p>剛到民宿後的張董<br><img src="/images/kaohsiung-playing20200804/4.jpg" alt=""></p>
<p>到了墾丁後，在民宿休息下後，我想要買泳衣，但是後面卻忘記買了，老人家事不記得的事情太多了。我們翔哥表示淺水灣太多人，要去白沙灣，那裏沒人玩起來才舒服(我有點忘記地名了，搞錯了抱歉Q)，我們似乎還遇到浩子，我還以為是阿翔XD，阿浩，我對不起你。</p>
<p>印象深刻的海景<br><img src="/images/kaohsiung-playing20200804/7.jpg" alt=""></p>
<p>那天是禁止游泳的，風浪太大了。所以我們只能踏踏水，親吻海浪。一開始我們都站在浪打不到我們大腿的地方，後來越來越想挑戰浪，之後坐下來，直接讓浪打過我們全身。好舒服阿，只是感覺自己的身體也快斷了，浪超大的，如果我原本斜率是 0，那可以把我的斜率變成 1。</p>
<p>在白沙灣的合照<br><img src="/images/kaohsiung-playing20200804/5.jpg" alt=""></p>
<h3 id="夜晚的墾丁"><a href="#夜晚的墾丁" class="headerlink" title="夜晚的墾丁"></a>夜晚的墾丁</h3><p>時候晚了，於是我們一夥人上來要把身上的沙粒洗乾淨，看到有一處可以清洗(需要付費)，蠻感動的，不然我們就要帶一堆沙粒回家了，嗚嗚嗚嗚。傍晚的蚊子真的很多，我在那邊一口氣被叮了 10 個包，蚊子的移動血庫，教官，我對蚊子捐血可以給我嘉獎嗎。</p>
<p>傍晚的墾丁，令人陶醉<br><img src="/images/kaohsiung-playing20200804/6.jpg" alt=""></p>
<p>夜晚，我們進入墾丁大街，準備消費，吃了一家好吃的泰式餐廳。之後大家就在墾丁逛街，我想買雙拖鞋，但發現墾丁賣的拖鞋都不太適合我，我腳太大了…。腳大錯了嗎 ಥ⌣ಥ</p>
<p>我們劉董事長對於墾丁大街的名言<br><img src="/images/kaohsiung-playing20200804/8.mp4" alt=""></p>
<p>我們逛完時，在街上想買一碳烤披薩，但卻臨時突然下大雨!!!!!我濕的跟下雨天沒人要的孩子一樣，過不久後，雨停了，在過不久後，雨下了。濕了又乾，乾了又濕，墾丁的天氣跟女孩子一樣讓人捉摸不定。</p>
<h3 id="人豪呢"><a href="#人豪呢" class="headerlink" title="人豪呢"></a>人豪呢</h3><p>你問我，人豪呢? 你們不是 3 個人出去玩嗎?<br>恩，對阿。<br>他在跟他女朋友聊天，OFFLINE。</p>
<p>✖️ 沒有照片可以放的人豪</p>
<h2 id="8-月-6-日，向屏東探險"><a href="#8-月-6-日，向屏東探險" class="headerlink" title="8 月 6 日，向屏東探險"></a>8 月 6 日，向屏東探險</h2><h3 id="國家公園-and-鵝鑾鼻"><a href="#國家公園-and-鵝鑾鼻" class="headerlink" title="國家公園 and 鵝鑾鼻"></a>國家公園 and 鵝鑾鼻</h3><p>整理好後，我們就再往南出發，途中看到很多人騎著腳踏車，勇士，都是勇士。我們先去一座國家公園拍照，終於像觀光客了orz，風景很漂亮。</p>
<p>人豪的照片，第一次<br><img src="/images/kaohsiung-playing20200804/9.jpg" alt=""></p>
<p>我們的合照，人豪照片的第二次<br><img src="/images/kaohsiung-playing20200804/10.jpg" alt=""></p>
<p>接著，前往鵝鑾鼻燈塔，鵝鑾鼻是需要收費的，但因為武漢肺炎。原本我們應該是不用收費的!結果他說滿 19 歲以上都要收費，可惡，我應該早點來的 ಥ⌣ಥ。因為是正中午，正熱的天氣我光走幾步路就滿身大汗了，好可怕…。之後到了鵝鑾鼻燈塔，其實他跟我想像的差有點多，沒想到她其實沒有很高，感覺只有 4、5 層樓，有點小可惜。</p>
<p>之後我們進行了觀光客必備，拍照！✧(&gt;o&lt;)ﾉ，接著就前往海生館拉。</p>
<p>智翔終於拍出一張像樣的成績單了<br><img src="/images/kaohsiung-playing20200804/11.jpg" alt=""></p>
<p>團隊大合照<br><img src="/images/kaohsiung-playing20200804/12.jpg" alt=""></p>
<h3 id="海生館與跟鹿鹿玩"><a href="#海生館與跟鹿鹿玩" class="headerlink" title="海生館與跟鹿鹿玩"></a>海生館與跟鹿鹿玩</h3><p>接著，我們順著路到了海生館，海生館也是需要門票的。但是，這次不一樣摟！只要你是 2001/07/01 後出生的小孩都不用收費，嘻嘻，兩位老人去旁邊買票吧。</p>
<p>成功進去海生館之後，我發現海生館有好多生魚片，每個看起來都好好吃，害我肚子馬上就餓了。(理組人思考方式 XD，魚魚，對不起啦)</p>
<p>附上我最想吃的生魚片XD<br><img src="/images/kaohsiung-playing20200804/13.jpg" alt=""></p>
<p>後來我們繼續逛逛，有個議題是在講關於海洋生態環保，而當中有一面牆是希望大家用便利貼來訴說怎麼樣可以對海洋更好。正當我因為很多人都在表示要怎麼環保時，對！就是這個 moment，我看到了一張便利貼，感覺是一個很善良的小孩寫的一張便利貼，我卻不自覺的開懷大笑。</p>
<p>可愛的小孩寫的 (◍•ᴗ•◍)❤️<br><img src="/images/kaohsiung-playing20200804/14.jpg" alt=""></p>
<p>之後逛到了禮品店，對，沒錯。是我執意要逛的XD，我想說我對我的前女友保有歉意，於是想要買一個可愛吊飾送給他，他們卻一直在講魚餌魚餌的，討厭死了。<br>這可是我發自內心的真誠道歉呀。</p>
<p>選購玩偶中..<br><img src="/images/kaohsiung-playing20200804/15.jpg" alt=""></p>
<p>中間，我們吃了一家海產店。生魚片只要 180 元 10 片，我只要省下兩杯麥香的錢就可以吃ㄟ，屏東的食物好讚好便宜好好吃。我還不把我體重弄到破百，對不起這些魚。ε٩(๑&gt; ₃ &lt;)۶з<br><del>希望我死掉以後，可以不要被魚魚們欺負…</del></p>
<p>接下來跑去看鹿鹿，鹿鹿很可愛，但是我手上拿著飼料的時候，他們就像喪屍般不斷的去找你，吞食你的生命(飼料)，我一開始的策略是選擇逃跑，但跑著發現我被逼到一個小角落…，那些凶狠的鹿絲毫感覺不到我的害怕，繼續用著他的鹿角戳我的肚子，幸好我肚子夠軟，不然我的內臟早就被鹿角戳的亂七八糟的吧 QQ。最終還是輸給了鹿鹿，把生命給了他…。然後<br>然後呢?<br>.<br>.<br>.<br>然後他就不理我了…，一群現實鬼呀。</p>
<p>對，然後情侶很多，要有被閃的風險。很多大便，你閃不過的。</p>
<h3 id="晚餐與尋找高中摯友"><a href="#晚餐與尋找高中摯友" class="headerlink" title="晚餐與尋找高中摯友"></a>晚餐與尋找高中摯友</h3><p>晚餐後我們去吃汕頭火鍋，就是我們國瑜寧可不要開記者會也要吃到的火鍋XD，雖然我對他並沒有太大興趣，因為我對於火鍋沒有到很喜歡。不過他真的是蠻好吃的，店長人不錯，難怪我們國瑜也要吃。<br>「高雄可以輸，火鍋必須吃」– 市長韓國瑜留<br>.<br>.<br>.<br>當然不可能啦，開玩笑的。國瑜你會原諒我的吧，我們家有投票給你的！♡(&gt; ਊ &lt;)♡</p>
<p>回家的過程中，我還把我的提袋忘在汕頭…，這可能就是開國瑜玩笑的後果吧qq，大家還是不要亂開玩笑喔</p>
<p>回到了智翔的家後，我去了一趟陪我高中成長 3 年，幫助我變強的那個男人，陳建名。畢竟他在高科讀書，不找他還是不行的，跟他閒話家常憶當年，當時的我還真神勇阿，不像現在只能退在這邊打 blog，嗚嗚，也只有科大金獎，我們一同在高雄的街道漫步，直到太陽再次升上天空。</p>
<h2 id="8-月-7-日，玩命關頭機車版"><a href="#8-月-7-日，玩命關頭機車版" class="headerlink" title="8 月 7 日，玩命關頭機車版"></a>8 月 7 日，玩命關頭機車版</h2><p>早起與建名道別後，搭著智翔的機車回到了智翔家，然後去吃了一間鍋燒意麵，好吃。真的好吃，但是憑甚麼只有高科有加麵的機會，生氣，哼！之後我們提議去打保齡球，再去草衙道，我原本以為我保齡球沒有變爛，結果我已經爛到連球都不會拿了…，下次還是不要說大話阿，說自己很會打。唉</p>
<p>再晚點，我們去了草衙道，這個時候呢！對，我們那位 OFFLINE 的人豪終於上線了，我們去逛 NET，正當我們威廷想要買自己所看重的衣服時，我們人豪跟祥哥直接否決掉他，之後我們的人豪帥氣地幫我們威廷智翔選配衣服，我也在人豪的推薦下買了一個帽子，幸好不是綠帽 XD</p>
<p>回程時，由於我們可能對高鐵來不及，我們智翔用迅雷不及掩耳的速度，把我載到了北科，這真的是讓我嚇了一伸冷汗阿，智翔你有幫我保保險，對吧，對吧！高雄騎車真的沒有交通規則的，都是生存規則的…。其中我們智翔曾說了一句名言。<br>「禁行機車道，盡情騎機車」– 飆仔張智翔</p>
<p>但幸好我們還是平安地來到高鐵站，原本 20 分鐘 -&gt; 變成了 10 分鐘，你真的是時間管理大師，智翔。</p>
<p>之後我們到了板橋車站，搭了計程車。度過了這段開心又愉快的時光，也謝謝各位都願意陪伴在我身邊。</p>
]]></content>
      <categories>
        <category>人生旅途</category>
      </categories>
      <tags>
        <tag>大學Life</tag>
        <tag>人生旅途</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa12538 - Version Controlled IDE (Rope)</title>
    <url>/2020/09/01/UVa/UVa12538/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>我們需要版本控制一份文件，類型如下：<br>type 1 ，插入字串在 p 位置<br>type 2 ，移除字串從 p 位置開始移除 c 個字元<br>type 3 ，查詢 v 版本從 p 位置開始輸出 c 個字元<br>每進行一次 type 1 or 2 的動作，就增加一版本。<br>我們順便進行加密混淆的動作，每一次只要 type 3 輸出的字元中擁有 ‘c’，則接下來 除了 type 以外的數字都會因為前面 type 3 輸出字元中有多少的 c，則會增加多少數字。</p>
</blockquote>
<a id="more"></a>

<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>通常大家看到這題直覺都會是用 string 來寫這題吧！但這題不是 QAQ。<br>這題要用 string 的另外一個好朋友 rope 來解決，rope 的結構為「可持久化平衡樹」，他在加入資料時不破壞舊有狀態，這樣使得每次在插入新增時效率來比 string 更優秀。</p>
<p>下圖為 <a href="https://en.wikipedia.org/wiki/Rope_(data_structure)" target="_blank" rel="noopener">wiki string 與 rope 的複雜度比較圖</a><br><img src="/images/UVa12538/1.PNG" alt=""></p>
<p>在這需要大量插入移除的題目中，rope 是再好不過的了！且他語法也跟 string 大同小異，上手起來也不至於太久。</p>
<h3 id="小提醒"><a href="#小提醒" class="headerlink" title="小提醒:"></a>小提醒:</h3><p>type 2 and type 3 的 p 都是從 1 開始，所以必須要 -1，因為電腦從 0 開始呀！</p>
<p>rope.insert()，裡面放的是字元陣列！所以如果是 string，需要變成 string.c_str()，才有辦法讀進去喔！</p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>查了下 string 中文是細繩，rope 是粗繩，嗯? 怎麼感覺好像特斯拉與愛迪生的感覺呢wwww，主流都是 string 沒有 rope 阿 ಥ⌣ಥ。不過被我學了一課，嗯! 我又多學了一些知識，開心。</p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="stl之rope大法好及可持久化并查集用法">rope大法好</a><br><a href="http://sunmoon-template.blogspot.com/2015/01/c-rope.html" target="_blank" rel="noopener">c++ rope 基本應用</a><br><a href="https://en.wikipedia.org/wiki/Rope_(data_structure)" target="_blank" rel="noopener">Rope (data structure)</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ext/rope&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 50020</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> __gnu_cxx ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">int</span> n , t , a , b , c , d=<span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">int</span> v = <span class="number">0</span> ;</span><br><span class="line">    <span class="built_in">string</span> strA ;</span><br><span class="line">    rope&lt;<span class="keyword">char</span>&gt; r[MAXN] , rtmp ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; t ;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(t==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a ;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; strA ;</span><br><span class="line">            a -= d ;</span><br><span class="line">            r[++v] = r[v] ;</span><br><span class="line">            r[v].insert(a,strA.c_str());</span><br><span class="line">            <span class="comment">//debug</span></span><br><span class="line">            <span class="comment">//cout &lt;&lt; r[v] &lt;&lt; '\n' ;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(t==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b ;</span><br><span class="line">            a -= d ; b -= d ;</span><br><span class="line">            r[++v] = r[v] ;</span><br><span class="line">            r[v].erase(a<span class="number">-1</span>,b);</span><br><span class="line">            <span class="comment">//debug</span></span><br><span class="line">            <span class="comment">//cout &lt;&lt; r[v] &lt;&lt; ' ' &lt;&lt; r[v-1] &lt;&lt; '\n' ;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(t==<span class="number">3</span>)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c ;</span><br><span class="line">            a -= d ; b -= d ; c -= d ;</span><br><span class="line">            rtmp = r[a].substr(b<span class="number">-1</span>,c) ;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; rtmp &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">            d += count(rtmp.begin() , rtmp.end() , <span class="string">'c'</span> );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>rope</tag>
        <tag>String Processing Problems</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces 1397A - Juggling Letters(水題)</title>
    <url>/2020/08/31/Codeforces/Codeforces%201397A/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>給你 x 組字串，試問能不能把這些字串進行重組後，能夠再重新分成 x 組字串，但字串內容則是全部一樣，可以輸出 YES，不行輸出 NO。</p>
</blockquote>
<a id="more"></a>

<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><blockquote>
<p>水題，這題真的水題，還是有點巧思的水題。喜歡這種水題</p>
</blockquote>
<p>由於他會給你一些字串，但這些字串的字母可以全部移動，而他詢問說要讓重組後的字串全部一樣，於是只要確認<strong>每個字母</strong>除以 x 剛好是整除時就可以輸出 YES，如果不行就輸出 NO。</p>
<h2 id="心得："><a href="#心得：" class="headerlink" title="心得："></a>心得：</h2><p>這題其實不難，但我在閱讀時也花了許多時間。以及我在思考題目時其實也不太能夠馬上很直觀了解，但進行假設與觀察後即可發現規律，我認為這題放在第一題是很不賴的設計。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">char</span> , <span class="keyword">int</span>&gt; dict ;</span><br><span class="line"><span class="built_in">string</span> strTemp ;</span><br><span class="line"><span class="keyword">int</span> t , n  ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ans</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it : dict)&#123;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; it.second &lt;&lt; '\n' ;</span></span><br><span class="line">        <span class="keyword">if</span>(it.second % n)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"NO"</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"YES"</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//#ifdef LOCAL</span></span><br><span class="line"><span class="comment">//    freopen("in1.txt" , "r" , stdin );</span></span><br><span class="line"><span class="comment">//#endif // LOCAL</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t ;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">        dict.clear();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; strTemp ;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; strTemp.length() ; j++)&#123;</span><br><span class="line">                dict[strTemp[j]] +=<span class="number">1</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>水題</tag>
        <tag>程式解題</tag>
        <tag>Codeforces Round .#666 (Div. 2)</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces 1397D - Stoned Game(暴力搜尋 Brute force)</title>
    <url>/2020/08/31/Codeforces/Codeforces%201397D/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>T、HL 在玩遊戲。遊戲規則如下，有 x 堆石頭，每堆石頭數量不定，每次都是 T 先從其中一堆拿石頭，H 再拿一顆石頭，每位玩家則不可以拿上位玩家拿石頭的石頭堆。<br><del>這到底是甚麼原始人遊戲 XD，好像舊石器時代的人會玩的遊戲</del></p>
</blockquote>
<a id="more"></a>

<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><blockquote>
<p>這題真的很難啊…，這題目與我之前碰過的經驗不同，讓我搞錯方向去思考，好題好題。<br>幸好有解開啦…，不然我就會很生氣了 XD。</p>
</blockquote>
<p>每次都選擇最大的兩堆石頭出來，然後兩堆石頭各減一。之後再放回去 priority_queue 內，假如 priority_queue size 只有一堆代表 T win，若剛好 0 堆則代表 HL win。</p>
<p>至於我為甚麼會這樣想呢？我建議讀者都先從我的初步想法慢慢讀起，我認為會比直接看我的正確想法來的更好理解些。</p>
<h3 id="初步想法"><a href="#初步想法" class="headerlink" title="初步想法"></a>初步想法</h3><h4 id="錯誤想法-奇偶數堆"><a href="#錯誤想法-奇偶數堆" class="headerlink" title="錯誤想法 - 奇偶數堆"></a>錯誤想法 - 奇偶數堆</h4><p>一開始，稍微推斷一下。<br>他可能是甚麼透過偶奇數來判斷的，個人在猜應該是用偶數堆與奇數堆來進行判斷。<br>後來自己在紙筆推導時，發現 2 2 2 這測資是 HL win。但 2 2 4 則是 T 贏。</p>
<h4 id="錯誤想法-T-從最小堆石頭拿取，HL-從最大堆石頭拿取"><a href="#錯誤想法-T-從最小堆石頭拿取，HL-從最大堆石頭拿取" class="headerlink" title="錯誤想法 - T 從最小堆石頭拿取，HL 從最大堆石頭拿取"></a>錯誤想法 - T 從最小堆石頭拿取，HL 從最大堆石頭拿取</h4><p>這是根據題目給的測資進行判斷，比較有點根據了XD<br>只要只剩一堆石頭必定會是 T 贏，HL 則是要盡量讓石頭堆數達到兩堆且兩堆數量一樣。(從題目測資進行判斷)，於是我寫了一程式關於 T 從小石頭開始拿，當 T 從小石頭堆的提取數量已經大於 HL 的最大堆時，則 HL 在往次大堆進行提取，看最後是 T 還是 HL 的石頭比較多，我在進行判斷。(此想法透過遞迴撰寫)。</p>
<p>由於是錯誤想法因此我用圖片來給大家看我的錯誤遞迴，以免誤導大家以為這也是正確的一部份。</p>
<p><img src="/images/Codeforces-Round-666-Div-2-pD/1.PNG" alt=""></p>
<p>但後來證明我是錯誤的，測資怎麼樣都沒過，卡在第二筆。我後來仔細想想，每次都只拿一顆，經驗告訴我，消去法不一定適用。在使用 2 2 2 測資時得到啟發。</p>
<h4 id="正確想法-T-只提取最大堆石頭，HL-則提取次大堆石頭"><a href="#正確想法-T-只提取最大堆石頭，HL-則提取次大堆石頭" class="headerlink" title="正確想法 - T 只提取最大堆石頭，HL 則提取次大堆石頭"></a>正確想法 - T 只提取最大堆石頭，HL 則提取次大堆石頭</h4><p>為甚麼會這樣想呢？ 是 1 5 1 這測資啟發我的，我只要 T 直接拿取最大堆，那 HL 要拿甚麼石頭我都不需要在意阿 XD，反正我只要拿我的最大堆，剩下的石頭隨 HL 拿就行。那如果最大堆沒有呢？那就拿次大堆吧，把問題丟給 HL 就可以了 XD。</p>
<p>那有人會好奇說，為甚麼 HL 怎麼會每次都拿最大堆石頭？這樣 HL 真的是聰明的嗎？其實阿，這場遊戲 HL 完全沒有優勢，她為了要把自己的優勢找回來，所以她要拿次大堆的石頭，來希望當最大堆的石頭用完時，次大堆的石頭還在，這樣他就會是贏家 XD。</p>
<h2 id="心得："><a href="#心得：" class="headerlink" title="心得："></a>心得：</h2><p>暴力解法，這題讓我很意外啊！我以為會是很優秀的解法，沒想到被我這個程式笨蛋給用暴力解法解出來，如果這並不是作者想的方法，作者會被我給氣死吧! XD</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 120</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> t , n ;</span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>&gt; num;</span><br><span class="line"><span class="keyword">int</span> a , b ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">judge</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a , b ;</span><br><span class="line">    <span class="keyword">while</span>(num.size())&#123;</span><br><span class="line">        a = num.top() ;</span><br><span class="line">        a-- ;</span><br><span class="line">        num.pop();</span><br><span class="line">        <span class="keyword">if</span>(!num.size())&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"T"</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        b = num.top() ;</span><br><span class="line">        b-- ;</span><br><span class="line">        num.pop();</span><br><span class="line">        <span class="keyword">if</span>(a &gt; <span class="number">0</span>)</span><br><span class="line">            num.push(a);</span><br><span class="line">        <span class="keyword">if</span>(b &gt; <span class="number">0</span>)</span><br><span class="line">            num.push(b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"HL"</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//#ifdef LOCAL</span></span><br><span class="line"><span class="comment">//    freopen("in1.txt" , "r" , stdin );</span></span><br><span class="line"><span class="comment">//#endif // LOCAL</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t ;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">        <span class="keyword">int</span> intTemp ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; intTemp ;</span><br><span class="line">            num.push(intTemp) ;</span><br><span class="line">        &#125;</span><br><span class="line">        judge();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>程式解題</tag>
        <tag>Codeforces Round .#666 (Div. 2)</tag>
        <tag>暴力搜尋 Brute force</tag>
      </tags>
  </entry>
  <entry>
    <title>R if else 的用法</title>
    <url>/2020/09/03/R/R-ifelse/</url>
    <content><![CDATA[<h2 id="內容說明"><a href="#內容說明" class="headerlink" title="內容說明"></a>內容說明</h2><blockquote>
<p>內容記錄關於 R if else 中的用法</p>
</blockquote>
<a id="more"></a>

<h2 id="正常，普通寫法"><a href="#正常，普通寫法" class="headerlink" title="正常，普通寫法"></a>正常，普通寫法</h2><p>相信大家都會，不用我在都說 XD</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="R-if-一行寫法，通常在-lambda-function-中使用"><a href="#R-if-一行寫法，通常在-lambda-function-中使用" class="headerlink" title="R if 一行寫法，通常在 lambda function 中使用"></a>R if 一行寫法，通常在 lambda function 中使用</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">ifelse( test_expression , <span class="literal">TRUE</span> , <span class="literal">FALSE</span> )</span><br></pre></td></tr></table></figure>
<p>test_expression =&gt; 判斷的式子<br>TRUE =&gt; 條件符合的執行<br>FALSE =&gt; 條件不符合的執行</p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://www.datamentor.io/r-programming/ifelse-function/" target="_blank" rel="noopener">R ifelse() Function</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>程式語言的世界博大精神，要是沒有他們的付出我能走上現在的路嗎?<br>肯定是沒辦法的，於是我也需要更努力地去為社會付出。</p>
]]></content>
      <categories>
        <category>R語言</category>
      </categories>
      <tags>
        <tag>R語言</tag>
        <tag>學習筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>QUESTION! data_frame 要怎麼搜尋欄位中的值</title>
    <url>/2020/09/03/R/R-data-frame-search/</url>
    <content><![CDATA[<h2 id="內容說明"><a href="#內容說明" class="headerlink" title="內容說明"></a>內容說明</h2><blockquote>
<p>寫程式的時候是不可能沒遇到 bug 的，bug 紀錄整理</p>
</blockquote>
<a id="more"></a>

<h2 id="QUESTION-data-frame-要怎麼搜尋欄位中的值"><a href="#QUESTION-data-frame-要怎麼搜尋欄位中的值" class="headerlink" title="QUESTION! data_frame 要怎麼搜尋欄位中的值"></a>QUESTION! data_frame 要怎麼搜尋欄位中的值</h2><p>假如有一 dataframe 長這樣 (變數命名為 df )</p>
<table>
<thead>
<tr>
<th>Quiz</th>
<th>Score</th>
</tr>
</thead>
<tbody><tr>
<td>math</td>
<td>60</td>
</tr>
<tr>
<td>chinese</td>
<td>70</td>
</tr>
<tr>
<td>english</td>
<td>80</td>
</tr>
</tbody></table>
<p>我要尋找 english 的分數，那我應該語法要怎麼打比較好？</p>
<h3 id="answer"><a href="#answer" class="headerlink" title="answer:"></a>answer:</h3><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">print(df[df[<span class="string">'Quiz'</span>==<span class="string">'english'</span>],<span class="number">2</span>])</span><br></pre></td></tr></table></figure>
<p>這樣就可以搞定了！我在查這語法時真的花很多時間查詢。而且網站還是寫 python 的 XD，但他啟發了我，很謝謝他。</p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://www.edureka.co/community/43215/how-to-find-the-index-of-a-particular-value-in-a-dataframe" target="_blank" rel="noopener">How to find the index of a particular value in a dataframe?</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>程式語言的世界博大精神，要是沒有他們的付出我能走上現在的路嗎?<br>肯定是沒辦法的，於是我也需要更努力地去為社會付出。</p>
]]></content>
      <categories>
        <category>R語言</category>
      </categories>
      <tags>
        <tag>R語言</tag>
        <tag>學習筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>unlist 用法說明</title>
    <url>/2020/09/03/R/R-unlist/</url>
    <content><![CDATA[<h2 id="內容說明"><a href="#內容說明" class="headerlink" title="內容說明"></a>內容說明</h2><blockquote>
<p>寫程式的時候是不可能沒遇到 bug 的，bug 紀錄整理</p>
</blockquote>
<a id="more"></a>

<h2 id="ERROR-將-list-gt-unlist-後元素變少"><a href="#ERROR-將-list-gt-unlist-後元素變少" class="headerlink" title="ERROR! 將 list %&gt;% unlist 後元素變少"></a>ERROR! 將 list %&gt;% unlist 後元素變少</h2><blockquote>
<p>有非常高機率是因為 unlist 他在將 list 解開時，會「自動」將 character(0) 等只要 型態(0) 之類的元素會直接移除掉</p>
</blockquote>
<h3 id="solution-1"><a href="#solution-1" class="headerlink" title="solution 1:"></a>solution 1:</h3><p>那我們應該要怎麼辦？要是每次都這樣我就不用寫程式拉！<br>還是有辦法的，unlist 之後在加 lapply 做判斷，例如</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">unlist(lapply( list_object , <span class="keyword">function</span>(x) ifelse(length(x) &gt; <span class="number">0</span> , x , <span class="literal">NA</span>)  ))</span><br></pre></td></tr></table></figure>
<p>這樣就不會有元素被移除的問題出現。</p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://stackoverflow.com/questions/44659559/unlist-a-column-while-retaining-character0-as-empty-strings-in-r?noredirect=1&lq=1" target="_blank" rel="noopener">Unlist a column while retaining character(0) as empty strings in R</a><br><a href="https://stackoverflow.com/questions/51518592/how-to-unlist-a-numeric-list-in-r-and-keep-all-the-empty-rows" target="_blank" rel="noopener">How to unlist a numeric list in R and keep all the empty rows?</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>程式語言的世界博大精神，要是沒有他們的付出我能走上現在的路嗎?<br>肯定是沒辦法的，於是我也需要更努力地去為社會付出。</p>
]]></content>
      <categories>
        <category>R語言</category>
      </categories>
      <tags>
        <tag>R語言</tag>
        <tag>學習筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>list 用法說明</title>
    <url>/2020/09/04/R/R-list/</url>
    <content><![CDATA[<h2 id="內容說明"><a href="#內容說明" class="headerlink" title="內容說明"></a>內容說明</h2><blockquote>
<p>寫程式的時候是不可能沒遇到 bug 的，bug 紀錄整理<br>這裡介紹的非一般 list 普通用法，而是來展現一些神奇的操作 XD</p>
</blockquote>
<a id="more"></a>

<h2 id="list-是甚麼"><a href="#list-是甚麼" class="headerlink" title="list 是甚麼?"></a>list 是甚麼?</h2><p>一個讓我非常訝異的 object，他可以變形成 array、dict…等，讓你驚奇的狀態</p>
<h2 id="用-list-實作-dict"><a href="#用-list-實作-dict" class="headerlink" title="用 list 實作 dict"></a>用 list 實作 dict</h2><p>很簡單，R 的 list 不只可以用數字當作索引，<strong>文字</strong>也可以！所以就像下方範例即可。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">#簡單物件，其中 a 只能是簡單物件，如 cha , num ,logic , list一層 </span></span><br><span class="line">list[<span class="string">'test'</span>] &lt;- a</span><br></pre></td></tr></table></figure>

<p>但需要注意的是，這時候的 list 裡面只能放入簡單物件，不能有複雜型態。如: list 裡面又有 list…。</p>
<h3 id="教練，可是我想要讓-list-更好用呀！他應該沒有像-C-Map-一樣那麼不方便吧！"><a href="#教練，可是我想要讓-list-更好用呀！他應該沒有像-C-Map-一樣那麼不方便吧！" class="headerlink" title="教練，可是我想要讓 list 更好用呀！他應該沒有像 C++ Map 一樣那麼不方便吧！"></a>教練，可是我想要讓 list 更好用呀！他應該沒有像 C++ Map 一樣那麼不方便吧！</h3><p>當然沒有。他是 R，你痛苦的時候會想要，RRRRRRR 的叫呀~</p>
<p>如果想要這時候的 list 可以放入複雜型態時，可看下方舉例：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">#複雜物件，其中裡面想要多複雜都可以完成</span></span><br><span class="line">list[[<span class="string">'test'</span>]] &lt;- list(a=<span class="number">4</span> , b=list())</span><br></pre></td></tr></table></figure>
<p>這樣子後 list 裡面就可以在放入 list，達到許多完美的操作！</p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>程式語言的世界博大精神，要是沒有他們的付出我能走上現在的路嗎?<br>肯定是沒辦法的，於是我也需要更努力地去為社會付出。</p>
<p>這裡也要感謝牛哥(牛維方) 給我看了許多神奇又酷的 R 操作，讓我在學習 R 的路上突飛猛進，非常謝謝他。省去了我在網路上翻找文章解決問題的時間。</p>
<p><del>R 語言跟 C 真的差太多…，當初寫 R 的人腦袋到底是吸了甚麼，可以讓 R 跟祖先語言(c) 差那麼多wwww ~</del></p>
]]></content>
      <categories>
        <category>R語言</category>
      </categories>
      <tags>
        <tag>R語言</tag>
        <tag>學習筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>centOS 基礎指令教學</title>
    <url>/2020/07/25/linux/centOS-command/</url>
    <content><![CDATA[<h2 id="內容說明"><a href="#內容說明" class="headerlink" title="內容說明"></a>內容說明</h2><blockquote>
<p>記錄我在 centOS 上遇到的指令困難，讓我以後不忘記XD<br>此版本為: centOS 6</p>
</blockquote>
<a id="more"></a>

<h2 id="成為-root-的使用者"><a href="#成為-root-的使用者" class="headerlink" title="成為 root 的使用者"></a>成為 root 的使用者</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">su</span><br></pre></td></tr></table></figure>
<p>接下來會輸入密碼，密碼在 ternimal 上不會顯示，但他還是有運作的，用力地按下 ENTER 吧!之後應該會看到自己的 ternimal 中會出現 <code>[user @ path] #</code> 就代表你成功了!</p>
<h2 id="查看底下資料夾"><a href="#查看底下資料夾" class="headerlink" title="查看底下資料夾"></a>查看底下資料夾</h2><p>因為是在 ternimal 所以沒有 gui 介面告訴你裡面有哪些資料夾，這時候輸入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls</span><br></pre></td></tr></table></figure>
<p>之後會出現許多子目錄接下來如果文字顯現是，<strong><font color="#0000FF">藍色，代表是資料夾</font></strong>、<strong><font color="#ff0000">紅色，代表是檔案</font></strong>。</p>
<h2 id="新增資料夾"><a href="#新增資料夾" class="headerlink" title="新增資料夾"></a>新增資料夾</h2><p>如果要在 centOS 底下新增資料夾輸入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir folder_name</span><br></pre></td></tr></table></figure>
<p>就會產生了</p>
<h2 id="查看電腦的-RAM"><a href="#查看電腦的-RAM" class="headerlink" title="查看電腦的 RAM"></a>查看電腦的 RAM</h2><p>以 MB 顯示記憶體</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">free -m</span><br></pre></td></tr></table></figure>
<p>以 GB 顯示記憶體</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">free -g</span><br></pre></td></tr></table></figure>
<h4 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h4><p><a href="https://www.opencli.com/linux/linux-check-ram-usage-spec" target="_blank" rel="noopener">Linux 查看記憶體 (RAM) 使用狀況及規格</a></p>
<h2 id="查看安裝歷史"><a href="#查看安裝歷史" class="headerlink" title="查看安裝歷史"></a>查看安裝歷史</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">history</span><br></pre></td></tr></table></figure>

<h2 id="移除套件"><a href="#移除套件" class="headerlink" title="移除套件"></a>移除套件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum remove vlc</span><br></pre></td></tr></table></figure>
<h4 id="參考連結-1"><a href="#參考連結-1" class="headerlink" title="參考連結"></a>參考連結</h4><p><a href="https://darkranger.no-ip.org/archives/v5/document/linux/yum.htm" target="_blank" rel="noopener">How-To：用 yum 進行軟體安裝移除與更新</a></p>
<h2 id="查看更新"><a href="#查看更新" class="headerlink" title="查看更新"></a>查看更新</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc --version</span><br></pre></td></tr></table></figure>

<h2 id="查看電腦-ip"><a href="#查看電腦-ip" class="headerlink" title="查看電腦 ip"></a>查看電腦 ip</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ip a</span><br></pre></td></tr></table></figure>
<h4 id="參考連結-2"><a href="#參考連結-2" class="headerlink" title="參考連結"></a>參考連結</h4><p><a href="https://www.opencli.com/linux/ip-command" target="_blank" rel="noopener">ip 指令 — 取代 ifconfig 的工具</a></p>
<h2 id="將程式放後台執行"><a href="#將程式放後台執行" class="headerlink" title="將程式放後台執行"></a>將程式放後台執行</h2><p>命令後 + &amp;<br>EX:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">R &amp;</span><br></pre></td></tr></table></figure>

<h2 id="查看現在有那些後台"><a href="#查看現在有那些後台" class="headerlink" title="查看現在有那些後台"></a>查看現在有那些後台</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jobs</span><br></pre></td></tr></table></figure>

<h2 id="將後台指令刪除"><a href="#將後台指令刪除" class="headerlink" title="將後台指令刪除"></a>將後台指令刪除</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kill -9 %i</span><br></pre></td></tr></table></figure>
<p>i = jobs上的數字</p>
<h4 id="參考連結-3"><a href="#參考連結-3" class="headerlink" title="參考連結"></a>參考連結</h4><p><a href="http://linux.vbird.org/linux_basic/0440processcontrol.php" target="_blank" rel="noopener">第十六章、程序管理與 SELinux 初探</a><br><a href="https://blog.csdn.net/YuZhiHui_No1/article/details/44564963" target="_blank" rel="noopener">Linux任务/进程前后台切换</a></p>
<h2 id="排成-使電腦在特定時段啟動此程式"><a href="#排成-使電腦在特定時段啟動此程式" class="headerlink" title="排成(使電腦在特定時段啟動此程式)"></a>排成(使電腦在特定時段啟動此程式)</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">crontab -e 編輯排成</span><br><span class="line"><span class="number">00</span> <span class="number">03</span> * * * Rscript /home/archcopilot/public_html/david53133/v2.0/main.R</span><br><span class="line">crontab -l 檢查</span><br></pre></td></tr></table></figure>
<h4 id="參考連結-4"><a href="#參考連結-4" class="headerlink" title="參考連結"></a>參考連結</h4><p><a href="https://stackoverflow.max-everyday.com/2017/08/centos-crontab/" target="_blank" rel="noopener">CentOS 的cron自動排程</a></p>
<h2 id="如何更改時間"><a href="#如何更改時間" class="headerlink" title="如何更改時間"></a>如何更改時間</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo date -s &quot;2020&#x2F;08&#x2F;20 17:37:32&quot;</span><br><span class="line">sudo date -s &quot;Thu, 20 Aug 2020 17:40:32 CST&quot;</span><br></pre></td></tr></table></figure>
<h4 id="參考連結-5"><a href="#參考連結-5" class="headerlink" title="參考連結"></a>參考連結</h4><p><a href="https://blog.gtwang.org/linux/howto-set-date-time-from-linux-command-prompt/" target="_blank" rel="noopener">Linux 手動更改系統時間：date、hwclock 與 timedatectl 指令用法教學</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>centOS我也是第一次摸過並不太認識他阿，現在慢慢熟悉希望可以把它變成自己的技能之一。</p>
<h2 id="更新日誌"><a href="#更新日誌" class="headerlink" title="更新日誌"></a>更新日誌</h2><p>2020-07-25 20:48:32 - 完成</p>
<ol>
<li>成為 root 的使用者</li>
<li>查看底下資料夾</li>
<li>新增資料夾</li>
</ol>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>linux</tag>
        <tag>centOS</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 刪除已被監聽的 port</title>
    <url>/2020/08/20/linux/linux-kill-port/</url>
    <content><![CDATA[<h2 id="內容說明"><a href="#內容說明" class="headerlink" title="內容說明"></a>內容說明</h2><blockquote>
<p>記錄我在 LINUX 上遇到的問題</p>
<p>會寫這篇的原因是因為我在寫 R 的 api 並且架在 godaddy 的 server 時，常常遇到自己想使用的 port 被監聽，但那 port 有沒有用。</p>
</blockquote>
<a id="more"></a>

<h2 id="解決方法"><a href="#解決方法" class="headerlink" title="解決方法"></a>解決方法</h2><h3 id="查詢自己的-port"><a href="#查詢自己的-port" class="headerlink" title="查詢自己的 port"></a>查詢自己的 port</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo netstat -lpn |grep 3000</span><br></pre></td></tr></table></figure>
<p>3000 為數字，可以自行更改，之後看他跳出的資訊最後面應該會有 5 數字，記住那五數字。</p>
<h3 id="把監聽-port-刪除"><a href="#把監聽-port-刪除" class="headerlink" title="把監聽 port 刪除"></a>把監聽 port 刪除</h3><p>知道自己的 port 後，就將那 5 數字記起來</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kill 12345</span><br></pre></td></tr></table></figure>
<p>這樣就完成了！</p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://andy6804tw.github.io/2018/02/09/kill-port/" target="_blank" rel="noopener">如何清除系統上被佔用的Port?</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>LINUX 好多事情真的需要我學，跟 WINDOWS 又是完全不一樣的東西，學起來我就又多一把刷子了 XD</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>在 centOS6 安裝 Python 3.6</title>
    <url>/2020/09/05/linux/centOS-install-python36/</url>
    <content><![CDATA[<h2 id="內容說明"><a href="#內容說明" class="headerlink" title="內容說明"></a>內容說明</h2><blockquote>
<p>如何在 centOS 上安裝 Python 教學</p>
</blockquote>
<a id="more"></a>

<h2 id="安裝教學"><a href="#安裝教學" class="headerlink" title="安裝教學"></a>安裝教學</h2><h3 id="第一步，安裝前置作業必要套件"><a href="#第一步，安裝前置作業必要套件" class="headerlink" title="第一步，安裝前置作業必要套件"></a>第一步，安裝前置作業必要套件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum install gcc bzip2-devel libffi-devel  </span><br><span class="line">sudo yum install pcre pcre-devel</span><br><span class="line">sudo yum install zlib zlib-devel</span><br><span class="line">sudo yum install openssl openssl-devel</span><br></pre></td></tr></table></figure>

<h3 id="第二步，去-python-官網下載-python，之後解壓縮"><a href="#第二步，去-python-官網下載-python，之後解壓縮" class="headerlink" title="第二步，去 python 官網下載 python，之後解壓縮"></a>第二步，去 python 官網下載 python，之後解壓縮</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;www.python.org&#x2F;ftp&#x2F;python&#x2F;3.6.1&#x2F;Python-3.6.1.tgz</span><br><span class="line">tar -zxvf Python-3.6.1.tgz</span><br></pre></td></tr></table></figure>

<h3 id="第三步，在-centOS-上編譯-python-source"><a href="#第三步，在-centOS-上編譯-python-source" class="headerlink" title="第三步，在 centOS 上編譯 python source"></a>第三步，在 centOS 上編譯 python source</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd Python-3.6.1</span><br><span class="line"> .&#x2F;configure --with-ssl</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<h3 id="第四步，建立-python3-路徑"><a href="#第四步，建立-python3-路徑" class="headerlink" title="第四步，建立 python3  路徑"></a>第四步，建立 python3  路徑</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ln -s &#x2F;usr&#x2F;local&#x2F;bin&#x2F;python3 &#x2F;usr&#x2F;bin&#x2F;python3</span><br></pre></td></tr></table></figure>

<h3 id="第五步，檢查-python-是否安裝成功"><a href="#第五步，檢查-python-是否安裝成功" class="headerlink" title="第五步，檢查 python 是否安裝成功"></a>第五步，檢查 python 是否安裝成功</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python3 -V</span><br></pre></td></tr></table></figure>
<p>以上全部都完成後，那在 centOS6 上就沒有問題了！</p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>可能由於有安裝過 R 的關係，這次 PY 沒有在像之前一樣難安裝。不過也是要謝謝這些願意把 Python 交付給大家的人們，沒有他們，我絕對沒辦法安裝的這麼快！</p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://medium.com/ianyc/python-%E5%9C%A8-centos7-%E4%B8%8A%E5%AE%89%E8%A3%9D-python3-6-f3c3a6f28e2f" target="_blank" rel="noopener">[CentOS][Python] 在 CentOS7 上安裝 python3.6</a></p>
]]></content>
      <categories>
        <category>linux</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>linux</tag>
        <tag>centOS</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>ERROR! Can&#39;t connect to HTTPS URL because the SSL module is not available</title>
    <url>/2020/09/05/linux/centOS-ERROR-openssl/</url>
    <content><![CDATA[<h2 id="內容說明"><a href="#內容說明" class="headerlink" title="內容說明"></a>內容說明</h2><blockquote>
<p>由於 python 3.6 中的 pip 套件要求 openssl 版本需要大於 1.0.2，但 centOS6 可更新的最高版本只能到 1.0.1，於是必須重新安裝。<br><del>centOS6，跟 python 都好麻煩…</del></p>
</blockquote>
<a id="more"></a>
<h2 id="ERROR-Can’t-connect-to-HTTPS-URL-because-the-SSL-module-is-not-available"><a href="#ERROR-Can’t-connect-to-HTTPS-URL-because-the-SSL-module-is-not-available" class="headerlink" title="ERROR: Can’t connect to HTTPS URL because the SSL module is not available"></a>ERROR: Can’t connect to HTTPS URL because the SSL module is not available</h2><p>我是在進行 <code>pip install requests</code>時發生，內容大意是指說 pip 不能夠用 SSL，所以找不到套件可以安裝。<del>其實是說沒有相對應的版本，但我覺得這樣講很爛</del></p>
<h2 id="solution-update-openssl-and-vim-file"><a href="#solution-update-openssl-and-vim-file" class="headerlink" title="solution: update openssl and vim file"></a>solution: update openssl and vim file</h2><p>由於此問題是 SSL，在我花了約 1 小時查找文件後找出是因為 openssl 版本需要大於 1.0.2，但 centOS6 可更新的最高版本只能到 1.0.1，所以需要進行更新。</p>
<p>如果是 os 為 centOS6 可參考此篇<br><a href="https://theriseofdavid.github.io/2020/09/05/linux/linux-openssl1.1.0-update/" target="_blank" rel="noopener">CentOS6 安裝與更新 openssl 1.1.0 教學</a></p>
<h3 id="更新完-openssl-後，怎麼做"><a href="#更新完-openssl-後，怎麼做" class="headerlink" title="更新完 openssl 後，怎麼做?"></a>更新完 openssl 後，怎麼做?</h3><p>重新編譯一次 python ，cd 回 python</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd Python-a.b.c</span><br><span class="line">.&#x2F;configure --with-ssl</span><br></pre></td></tr></table></figure>

<h3 id="修改文件，讓-pip-可以抓到-openssl-路徑"><a href="#修改文件，讓-pip-可以抓到-openssl-路徑" class="headerlink" title="修改文件，讓 pip 可以抓到 openssl 路徑"></a>修改文件，讓 pip 可以抓到 openssl 路徑</h3><p><strong>需要先找到自己的 openssl 資料夾，驗證可以看 openssl 資料夾內有沒有 include..等資料夾，記住此路徑，接下來會用到。</strong></p>
<p>先不要急著輸入 make 指令，先修改文件 Python-a.b.c/Modules/Setup</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim .&#x2F;Modules&#x2F;Setup</span><br></pre></td></tr></table></figure>
<p>應該會出現一堆開頭井字的程式碼，之後搜尋 SSL=，方法為 <code>/SSL=</code><br>如果正確的話視窗應顯示在這裡</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># Socket module helper for SSL support; you must comment out the other</span><br><span class="line"># socket line above, and possibly edit the SSL variable:</span><br><span class="line">SSL&#x3D;&#x2F;usr&#x2F;local&#x2F;lab&#x2F;openssl-1.0.2j&#x2F;    #將這行註解取消，並把 openssl 的路徑放入 SSL&#x3D; 之後</span><br><span class="line">_ssl _ssl.c \     #將這行註解取消</span><br><span class="line">-DUSE_SSL -I$(SSL)&#x2F;include -I$(SSL)&#x2F;include&#x2F;openssl \      #將這行註解取消</span><br><span class="line">-L$(SSL)&#x2F;lib -lssl -lcrypto      #將這行註解取消</span><br><span class="line"></span><br><span class="line"># The crypt module is now disabled by default because it breaks builds</span><br><span class="line"># on many systems (where -lcrypt is needed), e.g. Linux (I believe).</span><br><span class="line"></span><br><span class="line">#_crypt _cryptmodule.c # -lcrypt    # crypt(3); needs -lcrypt on some systems</span><br></pre></td></tr></table></figure>

<h3 id="修改完成後，編譯與安裝"><a href="#修改完成後，編譯與安裝" class="headerlink" title="修改完成後，編譯與安裝"></a>修改完成後，編譯與安裝</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make </span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<h3 id="驗證"><a href="#驗證" class="headerlink" title="驗證"></a>驗證</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip3 install requests</span><br></pre></td></tr></table></figure>

<p>以上全部都沒問題驗證也成功話，那在 centOS6 上就沒有問題了！太強了你，我花了兩小時才解決此問題..</p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://www.cnblogs.com/reblue520/p/11103311.html" target="_blank" rel="noopener">centos6.8安装python3.7.3报错Can’t connect to HTTPS URL because the SSL module is not available问题解决</a><br><a href="https://blog.csdn.net/rongDang/article/details/102871874" target="_blank" rel="noopener">Centos7安装uwsgi出现关于SSL错误的问题</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>環境的問題時常把新手搞得喘不過氣，幸好這次我能克服此困難。希望以後 python 的版本控制能夠更好，centOS6 提供的相容性也可以更棒！雖然他 2020/11 就要停止更新了…<br>不過還是謝謝能在網路上提供資源的大神們，沒有他們，我連解決都不能解決！</p>
<p>尤其是國人，技術資源國人比起台灣資源多很多。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>linux</tag>
        <tag>centOS</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>在 centOS6 安裝 Python 3.8</title>
    <url>/2020/08/28/linux/centOS-install-python38/</url>
    <content><![CDATA[<h2 id="內容說明"><a href="#內容說明" class="headerlink" title="內容說明"></a>內容說明</h2><blockquote>
<p>如何在 centOS 上安裝 Python 教學</p>
</blockquote>
<a id="more"></a>

<h2 id="安裝教學"><a href="#安裝教學" class="headerlink" title="安裝教學"></a>安裝教學</h2><h3 id="第一步，安裝前置作業必要套件"><a href="#第一步，安裝前置作業必要套件" class="headerlink" title="第一步，安裝前置作業必要套件"></a>第一步，安裝前置作業必要套件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum install gcc openssl-devel bzip2-devel libffi-devel</span><br></pre></td></tr></table></figure>

<h3 id="第二步，去-python-官網下載-python，之後解壓縮"><a href="#第二步，去-python-官網下載-python，之後解壓縮" class="headerlink" title="第二步，去 python 官網下載 python，之後解壓縮"></a>第二步，去 python 官網下載 python，之後解壓縮</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;www.python.org&#x2F;ftp&#x2F;python&#x2F;3.8.5&#x2F;Python-3.8.5.tgz</span><br><span class="line">tar xzf Python-3.8.5.tgz</span><br></pre></td></tr></table></figure>

<h3 id="第三步，在-centOS-上編譯-python-source"><a href="#第三步，在-centOS-上編譯-python-source" class="headerlink" title="第三步，在 centOS 上編譯 python source"></a>第三步，在 centOS 上編譯 python source</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd Python-3.8.5</span><br><span class="line">sudo .&#x2F;configure --enable-optimizations</span><br><span class="line">sudo make altinstall</span><br></pre></td></tr></table></figure>

<h3 id="第四步，解除安裝-python-壓縮檔"><a href="#第四步，解除安裝-python-壓縮檔" class="headerlink" title="第四步，解除安裝 python 壓縮檔"></a>第四步，解除安裝 python 壓縮檔</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo rm Python-3.8.5.tgz</span><br></pre></td></tr></table></figure>

<h3 id="第五步，檢查-python-是否安裝成功"><a href="#第五步，檢查-python-是否安裝成功" class="headerlink" title="第五步，檢查 python 是否安裝成功"></a>第五步，檢查 python 是否安裝成功</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python3.8 -V</span><br></pre></td></tr></table></figure>

<p>以上全部都完成後，那在 centOS6 上就沒有問題了！</p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>可能由於有安裝過 R 的關係，這次 PY 沒有在像之前一樣難安裝。不過也是要謝謝這些願意把 Python 交付給大家的人們，沒有他們，我絕對沒辦法安裝的這麼快！</p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://packaging.python.org/guides/installing-using-linux-tools/" target="_blank" rel="noopener">Installing pip/setuptools/wheel with Linux Package Managers</a></p>
]]></content>
      <categories>
        <category>linux</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>linux</tag>
        <tag>centOS</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>在 centOS 上安裝 R 3.2.0</title>
    <url>/2020/07/15/linux/install-R3.2.0-centOS6/</url>
    <content><![CDATA[<h2 id="內容說明"><a href="#內容說明" class="headerlink" title="內容說明"></a>內容說明</h2><blockquote>
<p>如何在 centOS 上安裝 R ，並記錄所有的坑與雷點<br>sudo apt-get install build-essential (OS: ubuntu) 與 yum install gcc gcc-c++ make (OS : centOS ) 不同需要特別注意<br>此版本為: centOS 6</p>
</blockquote>
<a id="more"></a>

<h2 id="安裝教學"><a href="#安裝教學" class="headerlink" title="安裝教學"></a>安裝教學</h2><ol>
<li><p>先卸載，怕有之前的遺毒存在</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo make uninstall</span><br></pre></td></tr></table></figure>
</li>
<li><p>刪除文件夾</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rm -rf 文件夾名</span><br></pre></td></tr></table></figure>
</li>
<li><p>安裝前置作業必要套件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install gcc-gfortran     </span><br><span class="line">yum install gcc gcc-c++ </span><br><span class="line">yum install readline-devel    </span><br><span class="line">yum install libXt-devel</span><br><span class="line">yum install libpng libpng-devel libtiff libtiff-devel libjpeg-turbo libjpeg-turbo-devel</span><br></pre></td></tr></table></figure>
</li>
<li><p>下載 R-3.5.0.tag.gz </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget http:&#x2F;&#x2F;cran.r-project.org&#x2F;src&#x2F;base&#x2F;R-3&#x2F;R-3.5.0.tar.gz</span><br></pre></td></tr></table></figure>
</li>
<li><p>解壓縮並且移動路徑至 R-3.5.0 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -zxvf R-3.5.0.tar.gz</span><br><span class="line">cd R-3.5.0</span><br></pre></td></tr></table></figure>
</li>
<li><p>編譯，如果前面動作並未絕對正確，有高機率出錯，必先檢查</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;configure --enable-R-shlib --with-libpng --with-jpeglib --with-libtiff --with-x</span><br></pre></td></tr></table></figure>
</li>
<li><p>安裝</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>輸入指令後須等一段時間</strong>，這裡其實已完成安裝，可執行檔在 /home/R/R-3.5.0/bin 底下，此時 /user/local/bin 還沒有可執行的 R </p>
<ol start="8">
<li><p>將 R 登錄</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make install</span><br></pre></td></tr></table></figure>
</li>
<li><p>退出並測試</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exit()</span><br><span class="line">R</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="錯誤排除"><a href="#錯誤排除" class="headerlink" title="錯誤排除"></a>錯誤排除</h2><h3 id="安裝套件問題"><a href="#安裝套件問題" class="headerlink" title="安裝套件問題"></a>安裝套件問題</h3><ol>
<li>嘗試重新安裝 gcc and g++ </li>
</ol>
<p>如果出現這樣，就代表正確了！<br><img src="/images/install-R-centOS/1.png" alt=""></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>我在上班時，試圖下載 R 3.4.2，但是因為電腦裡面缺少了 f77 complier 於是我再補足裡面缺少的套件，安裝時我才發現他的作業系統是centOS (要用 yum)，然後安裝完後發現為甚麼還是沒辦法執行R，剛剛才剛查到R3.4.2 在centOS上無法安裝，於是我現在安裝 R3.2.0 就成功了，真的很感動! ಥ⌣ಥ</p>
<p>查資料是件非常痛苦的方式，從 0 到 1 阿，嗚嗚。</p>
<h2 id="學習連結"><a href="#學習連結" class="headerlink" title="學習連結"></a>學習連結</h2><p>我在尋找的過程中，受到這幾個網站的幫助，如下:<br><a href="https://www.itdaan.com/tw/afce024b1d217e38d0c893a33e26908c" target="_blank" rel="noopener">centos 6.5下安裝R 3.2.0</a><br><a href="https://www.jianshu.com/p/08d90cb4ed8b" target="_blank" rel="noopener">安装R语言包的各种坑</a><br><a href="https://stackoverflow.com/questions/20752307/error-in-install-previous-versions-of-r-on-ubuntu/31036155" target="_blank" rel="noopener">error in Install previous versions of R on ubuntu</a><br><a href="https://uiop7890.pixnet.net/blog/post/29385923-%5B%E8%BD%89%E8%B2%BC%5D-xxx-is-not-in-the-sudoers-file%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95" target="_blank" rel="noopener">xxx-is-not-in-the-sudoers-file解决方法</a></p>
]]></content>
      <categories>
        <category>R語言</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>R語言</tag>
        <tag>學習筆記</tag>
        <tag>linux</tag>
        <tag>centOS</tag>
      </tags>
  </entry>
  <entry>
    <title>在 centOS6 上安裝 R 3.6.0</title>
    <url>/2020/08/12/linux/install-R3.6.0-centOS6/</url>
    <content><![CDATA[<h2 id="內容說明"><a href="#內容說明" class="headerlink" title="內容說明"></a>內容說明</h2><blockquote>
<p>如何在 centOS 上安裝 R ，並記錄所有的坑與雷點<br>sudo apt-get install build-essential (OS: ubuntu) 與 yum install gcc gcc-c++ make (OS : centOS ) 不同需要特別注意<br>此版本為: centOS 6<br>為甚麼會寫兩篇文章關於 R 的安裝呢，很簡單！因為之前 3.2.0 不支援太多套件了，只好來重新安裝 R 的新版本(P.S. 不歸路阿…都是坑)<br><strong>注意:如果不需要，建議還是<a href="https://theriseofdavid.github.io/2020/07/15/linux/install-R3.2.0-centOS6/" target="_blank" rel="noopener">安裝 3.2.0</a> 較為方便</strong><br>centOS6 在安裝 R新版本會有非常大問題出錯。<br><strong><font color="#dd0000">警告:這篇文章實用性不高，對於可信度請不要太過於相信，太多事情沒有紀錄確實。在此獻上歉意</font></strong><br>為甚麼實用性不高，還要放在網路上呢? 因為就算實用性不高這些錯誤我曾踩過，也許未來的我能從這邊啟發一些事情</p>
</blockquote>
<a id="more"></a>

<h2 id="安裝教學"><a href="#安裝教學" class="headerlink" title="安裝教學"></a>安裝教學</h2><ol>
<li><p>安裝前置作業必要套件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install gcc-gfortran     </span><br><span class="line">yum install gcc gcc-c++ </span><br><span class="line">yum install readline-devel    </span><br><span class="line">yum install libXt-devel</span><br><span class="line">yum install libpng libpng-devel libtiff libtiff-devel libjpeg-turbo libjpeg-turbo-devel</span><br><span class="line">yum install libgfortran4</span><br><span class="line">yum install libxml2-devel</span><br></pre></td></tr></table></figure>
</li>
<li><p>安裝使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum install epel-release</span><br><span class="line">sudo yum install R</span><br><span class="line">sudo .&#x2F;configure --prefix&#x3D;&#x2F;opt&#x2F;R&#x2F;3.6.0 --enable-R-shlib</span><br></pre></td></tr></table></figure>




</li>
</ol>
<h2 id="錯誤排除"><a href="#錯誤排除" class="headerlink" title="錯誤排除"></a>錯誤排除</h2><h3 id="R-如果-ERROR-並且你的-linux-系統-c-lt-11-or-nullptr-不可用-就必須要安裝-c-11"><a href="#R-如果-ERROR-並且你的-linux-系統-c-lt-11-or-nullptr-不可用-就必須要安裝-c-11" class="headerlink" title="R 如果 ERROR 並且你的 linux 系統 c++ &lt; 11 or nullptr 不可用 就必須要安裝 c++ 11"></a>R 如果 ERROR 並且你的 linux 系統 c++ &lt; 11 or nullptr 不可用 就必須要安裝 c++ 11</h3><p>如果你在安裝套件上遇到錯誤時，仔細閱讀可以發現似乎有 bug 關於說 nullptr 不可使用，這時候你可能知道了一件事，對！centOS6 的 complier 是 C99，不是 C11，生不生氣!所以我們就要來安裝 C11</p>
<h4 id="Answer"><a href="#Answer" class="headerlink" title="Answer:"></a>Answer:</h4><p><a href="https://forums.centos.org/viewtopic.php?t=68077" target="_blank" rel="noopener">run a c++ program with c++11 support in older CentOS machine</a> 參考此文章，這文章寫得很好。</p>
<h3 id="ERROR-C-11-standard-requested-but-CXX11-is-not-defined"><a href="#ERROR-C-11-standard-requested-but-CXX11-is-not-defined" class="headerlink" title="ERROR : C++11 standard requested but CXX11 is not defined"></a>ERROR : C++11 standard requested but CXX11 is not defined</h3><p>試圖加入這些命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CXX11 &#x3D; g++</span><br><span class="line">CXX11FLAGS &#x3D; -O2 -g $(LTO)</span><br><span class="line">CXX11PICFLAGS &#x3D; -fPIC</span><br><span class="line">CXX11STD &#x3D; -std&#x3D;c++11</span><br></pre></td></tr></table></figure>
<h4 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h4><p><a href="https://github.com/rstudio/httpuv/issues/82" target="_blank" rel="noopener">Installing hits ‘C++11 standard requested but CXX11 is not defined</a></p>
<h3 id="Error-Protected-multilib-versions"><a href="#Error-Protected-multilib-versions" class="headerlink" title="Error: Protected multilib versions"></a>Error: Protected multilib versions</h3><p>如果遇到有不同版本的問題，則將版本移除即可。下面是我遇到的錯誤訊息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Error: Protected multilib versions: libRmath-3.5.2-2.el6.i686 !&#x3D; libRmath-3.6.0-1.el6.x86_64</span><br><span class="line">Error: Protected multilib versions: R-java-devel-3.5.2-2.el6.i686 !&#x3D; R-java-devel-3.6.0-1.el6.x86_64</span><br></pre></td></tr></table></figure>
<p>解決方案</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum remove openssh</span><br><span class="line">sudo yum remove libRmath</span><br><span class="line">sudo yum remove R-java-devel</span><br></pre></td></tr></table></figure>

<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>老實說，這篇文章我並沒有打得很好，因為我花了太多時間在 debug，以及這是我第一次花時間去完整地找出 bug，然後各個擊破。我在 bug 的過程中沒有紀錄確實，導致紀錄的不好。有許多我知道我曾經有錯的地方我也有找出 solutation，但我卻沒有紀錄。我覺得這點不好，這樣我在以後如果有遇到類似問題時會遇到一樣久的時間。</p>
<p>但是有了這次經驗，我知道我應該要怎麼來做 debug 會更好。應該在邊學中碰到 Error 就做紀錄，這樣才是最好的。</p>
<h2 id="學習連結"><a href="#學習連結" class="headerlink" title="學習連結"></a>學習連結</h2><p>我在尋找的過程中，受到這幾個網站的幫助，如果我解釋得不好可以考慮從這些網站下尋求幫助，如下:<br><a href="https://centos.pkgs.org/6/centos-x86_64/libcurl-devel-7.19.7-53.el6_9.x86_64.rpm.html" target="_blank" rel="noopener">libcurl-devel-7.19.7-53.el6_9.x86_64.rpm</a><br><a href="https://blog.csdn.net/weixin_41929524/article/details/85008392" target="_blank" rel="noopener">在CentOS服务器上配置RStudio Server</a><br><a href="https://caozhilong.github.io/2019/06/12/install-R-language/" target="_blank" rel="noopener">linux下R 3.6.0的安装手册</a><br><a href="https://stackoverflow.com/questions/56325771/unable-to-install-r-3-6-0-on-centos" target="_blank" rel="noopener">Unable to install R 3.6.0 on centos</a><br><a href="http://hk.uwenku.com/question/p-pyanccch-bch.html" target="_blank" rel="noopener">本地安裝R-devel的Gfortran錯誤</a><br><a href="https://unix.stackexchange.com/questions/426161/updating-gfortran-on-scientific-linux-7" target="_blank" rel="noopener">Updating GFortran on Scientific Linux 7?</a><br><a href="https://centos.pkgs.org/6/epel-testing-x86_64/R-devel-3.6.0-1.el6.x86_64.rpm.html" target="_blank" rel="noopener">R-devel-3.6.0-1.el6.x86_64.rpm</a></p>
<h2 id="我在-debug-時做的簡單紀錄"><a href="#我在-debug-時做的簡單紀錄" class="headerlink" title="我在 debug 時做的簡單紀錄"></a>我在 debug 時做的簡單紀錄</h2><p>由於太簡單了，反而導致我很難做紀錄。需要改進</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">#install.packages("magrittr")</span></span><br><span class="line"><span class="comment">#install.packages("devtools") </span></span><br><span class="line">install.packages(<span class="string">"igraph"</span>)</span><br><span class="line"><span class="comment">#install.packages("RJSONIO")</span></span><br><span class="line">install.packages(<span class="string">"doBy"</span>)</span><br><span class="line"><span class="comment">#install.packages("ggplot2")</span></span><br><span class="line">install.packages(<span class="string">"jsonlite"</span>)</span><br><span class="line">install.packages(<span class="string">"plumber"</span>)</span><br><span class="line"></span><br><span class="line">sudo ./configure --prefix=/opt/R/<span class="number">3.5</span><span class="number">.0</span> --enable-R-shlib</span><br><span class="line">roxygen2</span><br><span class="line">BiocManager</span><br><span class="line">lintr</span><br><span class="line">rmarkdown</span><br><span class="line">spelling</span><br><span class="line">pkgdown</span><br><span class="line">devtools</span><br><span class="line">devtools::install_github(<span class="string">"gaborcsardi/pkgconfig"</span> , force=<span class="literal">TRUE</span>)</span><br><span class="line">devtools::install_github(<span class="string">"igraph/rigraph"</span>)</span><br><span class="line"></span><br><span class="line">yum remove libgfortran4</span><br><span class="line">yum install libgfortran4</span><br><span class="line">install_url(<span class="string">"http://igraph.googlecode.com/files/igraph_nightly_0.6-2689-20120412.tar.gz"</span>) </span><br><span class="line"><span class="keyword">library</span>(devtools)</span><br><span class="line"><span class="keyword">library</span>(remotes)</span><br><span class="line">install.packages(<span class="string">"igraph"</span>, dependencies = <span class="literal">TRUE</span>) <span class="comment"># R 版本必須大於 3.2.3</span></span><br><span class="line">install.packages(<span class="string">"devtools"</span>, repos = <span class="string">"http://cran.rstudio.com"</span>)</span><br><span class="line">remotes::install_version(<span class="string">'igraph'</span>, version = <span class="string">'1.1.1'</span> )</span><br><span class="line">install.packages(<span class="string">"remotes"</span>)</span><br><span class="line">install.packages(<span class="string">"readxl"</span>)</span><br><span class="line">install.packages(<span class="string">"igraph"</span>, repos = <span class="string">"http://cran.rstudio.com"</span>)</span><br><span class="line">install.packages(<span class="string">"RJSONIO"</span>, repos = <span class="string">"http://cran.rstudio.com"</span>)</span><br><span class="line">install.packages(<span class="string">"doBy"</span>, repos = <span class="string">"http://cran.rstudio.com"</span>)</span><br><span class="line">install.packages(<span class="string">"ggplot2"</span>, repos = <span class="string">"http://cran.rstudio.com"</span>)</span><br><span class="line">install.packages(<span class="string">"jsonlite"</span>, repos = <span class="string">"http://cran.rstudio.com"</span>)</span><br><span class="line">install.packages(<span class="string">"plumber"</span>, repos = <span class="string">"http://cran.rstudio.com"</span>)</span><br><span class="line"></span><br><span class="line">url &lt;- <span class="string">"https://cran.r-project.org/src/contrib/Archive/igraph/igraph_1.1.1.tar.gz"</span></span><br><span class="line">install.packages(url, repos=<span class="literal">NULL</span> , type=<span class="string">"source"</span>)</span><br><span class="line"></span><br><span class="line">install.packages(<span class="string">"devtools"</span>)</span><br><span class="line">install.packages(<span class="string">"later"</span>)</span><br><span class="line"></span><br><span class="line">install_version(“ggplot2”, version = “<span class="number">2.0</span><span class="number">.0</span>”, repos = “https://cran.r-project.org/src/contrib/Archive/ggplot2/”)</span><br><span class="line"></span><br><span class="line">install.versions(c(<span class="string">'checkpoint'</span>, <span class="string">'devtools'</span>), c(<span class="string">'0.3.3'</span>, <span class="string">'1.6.1'</span>))</span><br><span class="line">install.packages(<span class="string">"version"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">原文網址：https://kknews.cc/news/2q495g9.html</span><br><span class="line">wget http://cran.r-project.org/src/base/R-<span class="number">3</span>/R-<span class="number">3.5</span><span class="number">.0</span>.tar.gz</span><br><span class="line"></span><br><span class="line">tar -zxvf R-<span class="number">3.5</span><span class="number">.0</span>.tar.gz</span><br><span class="line">cd R-<span class="number">3.5</span><span class="number">.0</span></span><br><span class="line">原文網址：https://kknews.cc/news/2q495g9.html</span><br><span class="line"></span><br><span class="line">root密碼: +Z_F~Q!=mHch</span><br><span class="line">yum install libxml2-devel</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">In install.packages(<span class="string">"igraph"</span>, dependencies = <span class="literal">TRUE</span>) :</span><br><span class="line">  installation of package ‘later’ had non-zero exit status</span><br><span class="line"></span><br><span class="line">Warning messages:</span><br><span class="line"><span class="number">1</span>: In system2(cmd0, args, env = env, stdout = outfile, stderr = outfile) :</span><br><span class="line">  system call failed: Cannot allocate memory</span><br><span class="line"><span class="number">2</span>: In install.packages(<span class="string">"magrittr"</span>) :</span><br><span class="line">  installation of package ‘magrittr’ had non-zero exit status</span><br><span class="line"></span><br><span class="line">packageVersion(<span class="string">"magrittr"</span>)</span><br><span class="line"></span><br><span class="line">R -e <span class="string">'install.packages("magrittr")'</span></span><br><span class="line"></span><br><span class="line">http://<span class="number">192.168</span><span class="number">.10</span><span class="number">.39</span>:<span class="number">8551</span>/sum</span><br><span class="line"></span><br><span class="line"><span class="comment"># R 如果 ERROR 並且你的 linux 系統 c++ &lt; 11 or nullptr 不可用 就必須要安裝 c++ 11</span></span><br><span class="line">curl version <span class="number">7.70</span><span class="number">.0</span></span><br><span class="line"></span><br><span class="line">tar xzvf pcre-<span class="number">8.42</span>.tar.gz</span><br><span class="line">tar xzvf xz-<span class="number">5.2</span><span class="number">.5</span>.tar.gz </span><br><span class="line">tar xzvf zlib-<span class="number">1.2</span><span class="number">.11</span>.tar.gz</span><br><span class="line">tar xzvf R-<span class="number">3.5</span><span class="number">.0</span>.tar.gz</span><br><span class="line"></span><br><span class="line">delete /usr/lib64/pkgconfig/zlib.pc</span><br><span class="line"></span><br><span class="line">CXX11 = g++</span><br><span class="line">CXX11FLAGS = -O2 -g $(LTO)</span><br><span class="line">CXX11PICFLAGS = -fPIC</span><br><span class="line">CXX11STD = -std=c++<span class="number">11</span></span><br><span class="line"></span><br><span class="line">用一個指令就可以下載到最新版的，但可能有問題。要安裝一些指令</span><br><span class="line">Error <span class="keyword">in</span> .shlib_internal(args) : C++<span class="number">11</span> standard requested but CXX11 is not defined R 要 vim echo $(R RHOME)/etc/Makeconf 然後改其來</span><br><span class="line"></span><br><span class="line">yum remove gcc-gfortran</span><br><span class="line"></span><br><span class="line">igraph 下載 <span class="number">1.2</span><span class="number">.4</span><span class="number">.1</span> </span><br><span class="line"></span><br><span class="line">sudo find RConfig.h</span><br><span class="line"></span><br><span class="line">zU;7a%MXaH5Q</span><br><span class="line"></span><br><span class="line">plumber::plumb(file=<span class="string">'./plumber.R'</span>)$run()</span><br><span class="line"></span><br><span class="line">In file included from CHOLMOD/Supernodal/cholmod_super_numeric.c:<span class="number">80</span>:<span class="number">0</span>:</span><br><span class="line">CHOLMOD/Supernodal/t_cholmod_super_numeric.c:<span class="number">25</span>:<span class="number">21</span>: fatal error: Rconfig.h: No such file or directory</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">wget https://github.com/igraph/rigraph/archive/v1.1.0.tar.gz</span><br><span class="line">tar -zxvf v1.1.0.tar.gz</span><br><span class="line"></span><br><span class="line">rigraph-<span class="number">1.1</span><span class="number">.0</span></span><br><span class="line">install.packages(<span class="string">"./v1.1.0.tar.gz"</span>, repos = <span class="literal">NULL</span>, type = <span class="string">"source"</span>)</span><br><span class="line"></span><br><span class="line">install.packages(<span class="string">"https://cran.r-project.org/src/contrib/Archive/igraph/igraph_1.0.0.tar.gz"</span>, repo=<span class="literal">NULL</span>, type=<span class="string">"source"</span>)</span><br><span class="line">install.packages(u, type = <span class="string">"binary"</span>, repos = <span class="literal">NULL</span>)</span><br><span class="line">install.packages(<span class="string">"v1.1.0.tar.gz"</span>, repos = <span class="literal">NULL</span>, type=<span class="string">"source"</span>)</span><br><span class="line">R CMD INSTALL v1.1.0.tar.gz</span><br><span class="line"></span><br><span class="line">+Z_F~Q!=mHch</span><br><span class="line"></span><br><span class="line">/usr/include/R</span><br><span class="line"></span><br><span class="line">&gt; R.home(<span class="string">"lib"</span>)</span><br><span class="line">[<span class="number">1</span>] <span class="string">"/usr/lib64/R/lib"</span></span><br><span class="line"></span><br><span class="line">Error: Protected multilib versions</span><br><span class="line"></span><br><span class="line"><span class="comment">#yum install R-devel</span></span><br><span class="line"></span><br><span class="line">Error: Protected multilib versions: libRmath-<span class="number">3.5</span><span class="number">.2</span>-<span class="number">2.</span>el6.i686 != libRmath-<span class="number">3.6</span><span class="number">.0</span>-<span class="number">1.</span>el6.x86_64</span><br><span class="line">Error: Protected multilib versions: R-java-devel-<span class="number">3.5</span><span class="number">.2</span>-<span class="number">2.</span>el6.i686 != R-java-devel-<span class="number">3.6</span><span class="number">.0</span>-<span class="number">1.</span>el6.x86_64</span><br><span class="line"></span><br><span class="line">sudo yum remove openssh</span><br><span class="line">sudo yum remove libRmath</span><br><span class="line">sudo yum remove R-java-devel</span><br><span class="line"></span><br><span class="line">yum --enablerepo=epel-testing install R-devel</span><br><span class="line"></span><br><span class="line">install.packages(<span class="string">"igraph"</span>)</span><br><span class="line"></span><br><span class="line">yum remove  gcc-gfortran</span><br><span class="line">gfortran --version</span><br><span class="line">yum remove R-devel</span><br><span class="line"></span><br><span class="line">yum --enablerepo=epel-testing install gcc-gfortran</span><br><span class="line"></span><br><span class="line">yum remove devtoolset*</span><br><span class="line">gcc --version</span><br><span class="line"></span><br><span class="line"><span class="keyword">in</span> this c++ version is <span class="number">2010</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">../build_gcc_4.8.1/configure --enable-checking=release --enable-languages=c,c++ --disable-multilib</span><br><span class="line">./configure --enable-checking=release --enable-languages=c,c++ --disable-multilib </span><br><span class="line"></span><br><span class="line">tar -zxvf gcc-<span class="number">4.8</span><span class="number">.5</span>.tar.bz2 </span><br><span class="line">CentOS <span class="number">6</span>將於<span class="number">2020</span>年<span class="number">11</span>月死亡-遷移宜早不宜遲！ https://forums.centos.org/viewtopic.php?t=<span class="number">68077</span></span><br><span class="line"></span><br><span class="line">install.packages(<span class="string">"readxl"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">library</span>(plumber)</span><br><span class="line"><span class="keyword">library</span>(igraph)</span><br><span class="line">plumber::plumb(file=<span class="string">'./plumber.R'</span>)$run( port = <span class="number">442</span>,host=<span class="string">"0.0.0.0"</span>)</span><br><span class="line">plumber::plumb(file=<span class="string">'./test.R'</span>)$run( port = <span class="number">58903</span>,host=<span class="string">"0.0.0.0"</span>)</span><br><span class="line"></span><br><span class="line">install.packages(<span class="string">"plumber"</span>)</span><br><span class="line"></span><br><span class="line">```R  test.py</span><br><span class="line">library(plumber)</span><br><span class="line"></span><br><span class="line">#* @method /url</span><br><span class="line"></span><br><span class="line">#* Echo provided text</span><br><span class="line">#* @param text The text to be echoed in the response</span><br><span class="line">#* @get /echo</span><br><span class="line">function(text = "") &#123;</span><br><span class="line">  list(</span><br><span class="line">    message_echo = paste("The text is:", text)</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Starting server to listen on port 5762<br>Running the swagger UI at <a href="http://127.0.0.1:5762/__swagger__/" target="_blank" rel="noopener">http://127.0.0.1:5762/__swagger__/</a></p>
<p>curl “<a href="http://127.0.0.1:5762/echo&quot;" target="_blank" rel="noopener">http://127.0.0.1:5762/echo&quot;</a> –header “Content-type:application/json” -X POST -d @path/file</p>
<p>curl –data “text=hi_my_friend” “<a href="http://127.0.0.1:3000/echo&quot;" target="_blank" rel="noopener">http://127.0.0.1:3000/echo&quot;</a></p>
<p><a href="https://arch-backend.com:58903" target="_blank" rel="noopener">https://arch-backend.com:58903</a></p>
<p>人生真的好不公平，我好想自殺。</p>
<p>不是我的錯八.. 為甚麼我會有這種際遇</p>
<p>{standard input}:161003: Error: unknown pseudo-op: ‘.lbb’<br>{standard input}:161003: Error: open CFI at the end of file; missing .cfi_endproc directive</p>
<p>install.packages(“nloptr”)<br>ERROR: configuration failed for package ‘nloptr’</p>
<p>ERROR: no information for variable ‘AR’ cru .libs/libutil.a .libs/mt19937ar.o .libs/sobolseq.o .libs/timer.o .libs/stop.o .libs/redblack.o .libs/qsort_r.o .libs/rescale.o<br>../libtool: line 1102: ERROR:: command not found</p>
<p>library(remotes)<br>remotes::install_version(‘doBy’, version = ‘4.5-15’ )<br>library(doBy)</p>
<p><a href="http://132.148.26.6:58903/echo?text=123" target="_blank" rel="noopener">http://132.148.26.6:58903/echo?text=123</a></p>
<p>Rscript plumber::plumb(file=’./plumber.R’)$run( port = 58903,host=”0.0.0.0”)<br>Rscript demo.R &amp;<br>```</p>
]]></content>
      <categories>
        <category>R語言</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>R語言</tag>
        <tag>學習筆記</tag>
        <tag>linux</tag>
        <tag>centOS</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS6 安裝與更新 openssl 1.1.0 教學</title>
    <url>/2020/09/05/linux/linux-openssl1.1.0-update/</url>
    <content><![CDATA[<h2 id="內容說明"><a href="#內容說明" class="headerlink" title="內容說明"></a>內容說明</h2><blockquote>
<p>記錄我在 LINUX 上遇到的問題</p>
<p>會寫這篇的原因是因為公司的 Server，CentOS6 安裝 pthon3.6版本後，需要安裝套件，但 pip 要求 openssl version 必須大於 1.0.2，但 centOS6 內建只能到 1.0.1，於是上網查資料解決方案，因而在這邊紀錄</p>
</blockquote>
<a id="more"></a>

<h2 id="解決方法"><a href="#解決方法" class="headerlink" title="解決方法"></a>解決方法</h2><h3 id="第一步-檢查-openssl-的位置與移除舊版-openssl"><a href="#第一步-檢查-openssl-的位置與移除舊版-openssl" class="headerlink" title="第一步 檢查 openssl 的位置與移除舊版 openssl"></a>第一步 檢查 openssl 的位置與移除舊版 openssl</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yun remove openssl</span><br><span class="line">which openssl</span><br></pre></td></tr></table></figure>


<h3 id="第二步-下載-opensssl-1-1-0"><a href="#第二步-下載-opensssl-1-1-0" class="headerlink" title="第二步 下載 opensssl 1.1.0"></a>第二步 下載 opensssl 1.1.0</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;www.openssl.org&#x2F;source&#x2F;openssl-1.1.0f.tar.gz</span><br><span class="line">tar -xzf openssl-1.1.0f.tar.gz</span><br></pre></td></tr></table></figure>

<h3 id="第三步-編譯與安裝-openssl"><a href="#第三步-編譯與安裝-openssl" class="headerlink" title="第三步 編譯與安裝 openssl"></a>第三步 編譯與安裝 openssl</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd openssl-1.1.0f</span><br><span class="line">.&#x2F;config</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>

<h3 id="QUESTION-可能在過程中你在執行-openssl，可能會遇到此錯誤"><a href="#QUESTION-可能在過程中你在執行-openssl，可能會遇到此錯誤" class="headerlink" title="QUESTION: 可能在過程中你在執行 openssl，可能會遇到此錯誤"></a>QUESTION: 可能在過程中你在執行 openssl，可能會遇到此錯誤</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;usr&#x2F;local&#x2F;bin&#x2F;openssl version</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;bin&#x2F;openssl: error while loading shared libraries: libcrypto.so.1.1: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure>
<h3 id="SOLUTION-新增新的連結指向-libssl"><a href="#SOLUTION-新增新的連結指向-libssl" class="headerlink" title="SOLUTION: 新增新的連結指向 libssl"></a>SOLUTION: 新增新的連結指向 libssl</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo ln -s &#x2F;usr&#x2F;local&#x2F;lib64&#x2F;libssl.so.1.1 &#x2F;usr&#x2F;lib64&#x2F;</span><br><span class="line">sudo ln -s &#x2F;usr&#x2F;local&#x2F;lib64&#x2F;libcrypto.so.1.1 &#x2F;usr&#x2F;lib64&#x2F;</span><br></pre></td></tr></table></figure>

<h3 id="第四步-新增新連結指向-openssl"><a href="#第四步-新增新連結指向-openssl" class="headerlink" title="第四步 新增新連結指向 openssl"></a>第四步 新增新連結指向 openssl</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo ln -s &#x2F;usr&#x2F;local&#x2F;bin&#x2F;openssl &#x2F;usr&#x2F;bin&#x2F;openssl</span><br></pre></td></tr></table></figure>

<h3 id="第五步-檢查"><a href="#第五步-檢查" class="headerlink" title="第五步 檢查"></a>第五步 檢查</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">openssl version</span><br><span class="line">OpenSSL 1.1.0f 25 May 2017</span><br></pre></td></tr></table></figure>

<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://linuxscriptshub.com/update-openssl-1-1-0-centos-6-9-7-0/" target="_blank" rel="noopener">HOW TO UPDATE OPENSSL 1.1.0 IN CENTOS 6.9/7.0</a><br><a href="https://blog.csdn.net/rongDang/article/details/102871874" target="_blank" rel="noopener">Centos7安装uwsgi出现关于SSL错误的问题</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>我在找資料時其實花了非常多的時間，但其實只有參考連結中的此網站對我有所幫助，我很感謝這網頁。</p>
<p>LINUX 好多事情真的需要我學，跟 WINDOWS 又是完全不一樣的東西，學起來我就又多一把刷子了 XD</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>ERROR! bad interpreter No such file or directory</title>
    <url>/2020/09/05/linux/centOS-ERROR-bad_interpreter/</url>
    <content><![CDATA[<h2 id="內容說明"><a href="#內容說明" class="headerlink" title="內容說明"></a>內容說明</h2><blockquote>
<p>如果同時安裝 python3 兩種版本，那 pip 通常會選擇其中一種來進行安裝套件，但如果之後你移除了 pip 選擇的 python 版本，那以後 pip 沒辦法將套件安裝到剩下 python 版本。<br><del>centOS6，跟 python 都好麻煩…</del></p>
</blockquote>
<a id="more"></a>
<h2 id="ERROR-bad-interpreter-No-such-file-or-directory"><a href="#ERROR-bad-interpreter-No-such-file-or-directory" class="headerlink" title="ERROR! bad interpreter: No such file or directory"></a>ERROR! bad interpreter: No such file or directory</h2><p>如果同時安裝 python3 兩種版本，那 pip 通常會選擇其中一種來進行安裝套件，但如果之後你移除了 pip 選擇的 python 版本，那以後 pip 沒辦法將套件安裝到剩下 python 版本。</p>
<p>是不是覺得跟內容說明很像wwww，因為都是問題描述，如果描述不一樣我怕會造成讀者誤解。</p>
<h3 id="solution-尋找-python-位置，然後將-pip-指定到此位置"><a href="#solution-尋找-python-位置，然後將-pip-指定到此位置" class="headerlink" title="solution: 尋找 python 位置，然後將 pip 指定到此位置"></a>solution: 尋找 python 位置，然後將 pip 指定到此位置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">which python </span><br><span class="line">&#x2F;home&#x2F;path...</span><br></pre></td></tr></table></figure>
<p>之後複製 <code>/home/path...</code> 此路徑</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">which pip</span><br><span class="line">&#x2F;home&#x2F;path...</span><br></pre></td></tr></table></figure>
<p>之後 vim <code>which pip</code> 此指令下輸出的路徑</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;home&#x2F;path...</span><br></pre></td></tr></table></figure>
<p>接下來第一行應該會出現</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;home&#x2F;path....&#x2F;bin&#x2F;python3.8</span><br></pre></td></tr></table></figure>
<p>在將 <code>which python</code>輸出的路徑放在 #!，之後保存並退出就可以了！</p>
<p>以上全部都沒問題驗證也成功話，那在 centOS6 上就沒有問題了！太強了你，我花了一小時才解決此問題..</p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://blog.csdn.net/qq_38486203/article/details/100103434" target="_blank" rel="noopener">【python】使用pip出现/bin/python: bad interpreter: No such file or directory</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>環境的問題時常把新手搞得喘不過氣，幸好這次我能克服此困難。希望以後 python 的版本控制能夠更好，centOS6 提供的相容性也可以更棒！雖然他 2020/11 就要停止更新了…<br>不過還是謝謝能在網路上提供資源的大神們，沒有他們，我連解決都不能解決！</p>
<p>尤其是國人，技術資源國人比起台灣資源多很多。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>linux</tag>
        <tag>centOS</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>centOS 排成教學</title>
    <url>/2020/09/09/linux/centOS-crontab/</url>
    <content><![CDATA[<h2 id="內容說明"><a href="#內容說明" class="headerlink" title="內容說明"></a>內容說明</h2><blockquote>
<p>記錄我在 linux 上學習排成時遇到的困難，排成自學真的好麻煩呀 QQ<br>教學示範作業系統 centOS6</p>
</blockquote>
<a id="more"></a>

<h2 id="排成主要功能"><a href="#排成主要功能" class="headerlink" title="排成主要功能"></a>排成主要功能</h2><p>簡單來說就是有一個機器人幫你服務，在你設定的時間執行你想要的指令，通常限定一行。</p>
<h3 id="如何進入排成"><a href="#如何進入排成" class="headerlink" title="如何進入排成"></a>如何進入排成</h3><p>在  ternimal 輸入 <code>crontab -e</code> 即可。</p>
<h2 id="排成的語法規則"><a href="#排成的語法規則" class="headerlink" title="排成的語法規則"></a>排成的語法規則</h2><table>
<thead>
<tr>
<th>指令語法</th>
<th>分鐘</th>
<th>小時</th>
<th>日期</th>
<th>月份</th>
<th>周</th>
<th>命令</th>
</tr>
</thead>
<tbody><tr>
<td>可接受數字範圍</td>
<td>0~59</td>
<td>0~23</td>
<td>1~31</td>
<td>1~12</td>
<td>0~7</td>
<td>執行命令</td>
</tr>
</tbody></table>
<p><strong><font color="#dd0000">在周這欄時不管打 0 or 7 都是代表星期日的意思</font></strong></p>
<h3 id="排成特殊字元"><a href="#排成特殊字元" class="headerlink" title="排成特殊字元"></a>排成特殊字元</h3><p>有些字元有著特殊意義，如下表：</p>
<table>
<thead>
<tr>
<th>字元</th>
<th>中文解釋</th>
<th>意義</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>星號</td>
<td>代表任何時段，舉例: 排成如果 月、日、周都是 * ，則代表每月每日每周都會執行此命令，但<strong>注意:如果有大單位已經有數字時，則建議小單位不要用 * ，假設日期是 4，則小時、分鐘就建議不要用 * 號</strong></td>
</tr>
<tr>
<td>,</td>
<td>逗號</td>
<td>分隔時段，舉例:如果想要在 13:00 and 16:00 都執行命令，就輸入指令 0 13,16 * * * command，醬子(◍•ᴗ•◍)❤️</td>
</tr>
<tr>
<td>-</td>
<td>減號</td>
<td>在 A-B 段單位時間內，都會執行指令，舉例: 想要在 8 點到 12 點的 10 分之間都執行指令，則輸入指令 10 8-12 * * * command，比起逗號在跟方便一些的指令</td>
</tr>
<tr>
<td>/n</td>
<td>斜線</td>
<td>n = 數字，代表每隔 n 單位時間的意思，例如每 3 分鐘執行指令，則輸入指令 */3 * * * * command，也可以寫成 0-59/5，意思相同，但 0-30/5 意義就不相同XD，變成 0~30 分的每 5 分鐘執行指令</td>
</tr>
</tbody></table>
<h3 id="舉例"><a href="#舉例" class="headerlink" title="舉例:"></a>舉例:</h3><table>
<thead>
<tr>
<th>命令</th>
<th>解釋</th>
</tr>
</thead>
<tbody><tr>
<td>5 * * * *</td>
<td>每小時的第五分鐘執行命令</td>
</tr>
<tr>
<td>30 8 * * *</td>
<td>每天 8:30 執行命令</td>
</tr>
<tr>
<td>15 8-10 * * *</td>
<td>每天的 8 到 11 點的 15 分執行命令</td>
</tr>
<tr>
<td>*/5 * * * *</td>
<td>每 5 分鐘執行命令</td>
</tr>
<tr>
<td>30 6 /10 * *</td>
<td>每個月中，每 10 天的 6:30 執行命令，也就是每月的 1, 11, 21, 31 日的 6:30 執行命令</td>
</tr>
</tbody></table>
<h2 id="QUESTION-排成需要多行指令那要怎麼辦呢？"><a href="#QUESTION-排成需要多行指令那要怎麼辦呢？" class="headerlink" title="QUESTION: 排成需要多行指令那要怎麼辦呢？"></a>QUESTION: 排成需要多行指令那要怎麼辦呢？</h2><p>用括號 + 分號來解決這問題，括號來放入全部指令，分號則用來分隔命令。<br>舉例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*&#x2F;5 * * * *  (cd &#x2F;home&#x2F;archcopilot&#x2F;public_html&#x2F;david53133&#x2F;v1.0&#x2F; ; &#x2F;usr&#x2F;local&#x2F;bin&#x2F;python3.6 climb.py)</span><br></pre></td></tr></table></figure>

<h2 id="QUESTION-如果我想要透過執行檔執行文件該怎麼辦呢"><a href="#QUESTION-如果我想要透過執行檔執行文件該怎麼辦呢" class="headerlink" title="QUESTION: 如果我想要透過執行檔執行文件該怎麼辦呢?"></a>QUESTION: 如果我想要透過執行檔執行文件該怎麼辦呢?</h2><p>舉例，例如我想要執行 python 程式，那我是不是應該要 <code>python3 test.py</code>，在某些情況下是可以的。但如果你的 <code>python3</code> 並沒有放在系統預設的位置 <code>/usr/bin</code>就不行！<br>因此我建議的操作如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">which python3 # 先尋找執行檔的路徑</span><br><span class="line">&#x2F;home&#x2F;path&#x2F;... # 輸出的路徑</span><br><span class="line">&#x2F;home&#x2F;path&#x2F;..&#x2F;python3 test.py #執行命令</span><br></pre></td></tr></table></figure>

<h2 id="QUESTION-我想要看我的排成有沒有被執行？"><a href="#QUESTION-我想要看我的排成有沒有被執行？" class="headerlink" title="QUESTION: 我想要看我的排成有沒有被執行？"></a>QUESTION: 我想要看我的排成有沒有被執行？</h2><p>排成執行的紀錄在 <code>/var/log/cron</code>，再透過 <code>cat</code> 找出來即可。舉例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &#x2F;var&#x2F;log&#x2F;cron</span><br></pre></td></tr></table></figure>


<h2 id="QUESTION-為甚麼我排成的指令有被執行，但我看卻沒有？"><a href="#QUESTION-為甚麼我排成的指令有被執行，但我看卻沒有？" class="headerlink" title="QUESTION: 為甚麼我排成的指令有被執行，但我看卻沒有？"></a>QUESTION: 為甚麼我排成的指令有被執行，但我看卻沒有？</h2><h3 id="situation-1-你沒有-cd-路徑"><a href="#situation-1-你沒有-cd-路徑" class="headerlink" title="situation 1: 你沒有 cd 路徑"></a>situation 1: 你沒有 cd 路徑</h3><p>為甚麼會這樣說呢？因為其實你在執行路徑時，基本上都是從 <code>/user_name</code>出發，因此如果你的指令文件內有提到關於路徑，且路徑又是相對路徑是則極高機率遇到此問題。<br>建議使用 cd 到路徑後，在執行命令。舉例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*&#x2F;5 * * * *  (cd &#x2F;home&#x2F;archcopilot&#x2F;public_html&#x2F;david53133&#x2F;v1.0&#x2F; ; &#x2F;usr&#x2F;local&#x2F;bin&#x2F;python3.6 climb.py)</span><br></pre></td></tr></table></figure>
<h3 id="situation-2-指令本身有誤"><a href="#situation-2-指令本身有誤" class="headerlink" title="situation 2: 指令本身有誤"></a>situation 2: 指令本身有誤</h3><p>這也是一種可能，但我幫不了忙，對不起QQ。</p>
<h2 id="QUESTION-因為排成執行如果有問題是不會顯示，但我想要知道問題出在哪裡。排成可以提供日誌嗎？"><a href="#QUESTION-因為排成執行如果有問題是不會顯示，但我想要知道問題出在哪裡。排成可以提供日誌嗎？" class="headerlink" title="QUESTION: 因為排成執行如果有問題是不會顯示，但我想要知道問題出在哪裡。排成可以提供日誌嗎？"></a>QUESTION: 因為排成執行如果有問題是不會顯示，但我想要知道問題出在哪裡。排成可以提供日誌嗎？</h2><p>當然可以。我一開始研究還花很多時間XD，因為我一開始看不太懂，後面資料查久了才懂得wwww<br>透過 <code>&gt;&gt; test.log 2&amp;&gt;1</code>即可。舉例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 0 *&#x2F;1 * *  (cd &#x2F;home&#x2F;archcopilot&#x2F;public_html&#x2F;david53133&#x2F;v1.0&#x2F; ; &#x2F;usr&#x2F;local&#x2F;bin&#x2F;python3.6 climb.py)  &gt;&gt; &#x2F;home&#x2F;archcopilot&#x2F;public_html&#x2F;david53133&#x2F;v1.0&#x2F;crontab.log 2&gt;&amp;1</span><br></pre></td></tr></table></figure>

<h2 id="QUESITON-我要想排成好麻煩，有沒有比較簡單的排成方法"><a href="#QUESITON-我要想排成好麻煩，有沒有比較簡單的排成方法" class="headerlink" title="QUESITON: 我要想排成好麻煩，有沒有比較簡單的排成方法"></a>QUESITON: 我要想排成好麻煩，有沒有比較簡單的排成方法</h2><p>其實是有，但我個人覺得要記那些語法對我言太麻煩了。<br>這裡有一推薦的排成計算機，可以幫助你對你想要的時間點進行排成的指令計算出來。<br>連結就<a href="https://crontab.guru/" target="_blank" rel="noopener">請點這裡</a></p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://blog.csdn.net/liaoyanyunde/article/details/86572370" target="_blank" rel="noopener">查看crontab任务是否执行以及执行日志</a><br><a href="https://blog.gtwang.org/linux/linux-crontab-cron-job-tutorial-and-examples/" target="_blank" rel="noopener">Linux 設定 crontab 例行性工作排程教學與範例</a><br><a href="https://freesilo.com/?p=1083" target="_blank" rel="noopener">crontab的语法规则格式（每分钟、每小时、每天、每周、每月、每年定时执行 规则）</a><br><a href="https://crontab.guru/" target="_blank" rel="noopener">crontab calculator</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>排成真的有點難呀，不過我認為是我閱讀文章的能力不夠，還沒辦法閱讀一次就能看懂網路上大神的文章，於是我在這邊做些筆記紀錄，也希望幫助現在跟我一樣還不夠看懂大神的文章人可以透過我這篇文章而了解排成的用法。<br>希望能夠幫助到別人，這是我最大的心願。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>linux</tag>
        <tag>centOS</tag>
      </tags>
  </entry>
  <entry>
    <title>大衞愛用的表情符號</title>
    <url>/2020/07/20/blog/Emoticons/</url>
    <content><![CDATA[<h2 id="表情符號，為甚麼要記錄這個！"><a href="#表情符號，為甚麼要記錄這個！" class="headerlink" title="表情符號，為甚麼要記錄這個！"></a>表情符號，為甚麼要記錄這個！</h2><blockquote>
<p>因為這些表情符號是我愛用的，我也覺得很可愛。於是我想收集起來</p>
</blockquote>
<a id="more"></a>

<h2 id="以下就是大衛愛用的表情符號"><a href="#以下就是大衛愛用的表情符號" class="headerlink" title="以下就是大衛愛用的表情符號"></a>以下就是大衛愛用的表情符號</h2><table>
<thead>
<tr>
<th>表情符號</th>
</tr>
</thead>
<tbody><tr>
<td>QwQ</td>
</tr>
<tr>
<td>٩(^ᴗ^)۶</td>
</tr>
<tr>
<td>ಠ︵ಠ</td>
</tr>
<tr>
<td>✧(&gt;o&lt;)ﾉ</td>
</tr>
<tr>
<td>╰(⸝⸝⸝´꒳`⸝⸝⸝)╯</td>
</tr>
<tr>
<td>(◍•ᴗ•◍)❤️</td>
</tr>
<tr>
<td>♡(&gt; ਊ &lt;)♡</td>
</tr>
<tr>
<td>(*＾3＾)/～♡</td>
</tr>
<tr>
<td>ಥ⌣ಥ</td>
</tr>
<tr>
<td>ε٩(๑&gt; ₃ &lt;)۶з</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>表情符號</tag>
      </tags>
  </entry>
  <entry>
    <title>mathjax 用法紀錄</title>
    <url>/2020/07/20/blog/about-mathjax/</url>
    <content><![CDATA[<h2 id="主要內容"><a href="#主要內容" class="headerlink" title="主要內容"></a>主要內容</h2><blockquote>
<p>幫助大衛在 blog 中使用 mathjax 時忘記用法的時候直接快速使用，省去找文章的麻煩<br>雙斜線代表 mathjax 的用法，因為這裡我若完整照打會直接變成 mathjax 格式，於是我都只打內容<br>如下 &amp;&amp;(內容 &amp;&amp;) ，將 &amp;消除後放入內容即可使用</p>
</blockquote>
<a id="more"></a>

<h2 id="數學用法"><a href="#數學用法" class="headerlink" title="數學用法"></a>數學用法</h2><p><strong>普通英文字母若前面未加入反斜線則代表可隨意帶入數值</strong></p>
<table>
<thead>
<tr>
<th>數學用法</th>
<th>mathjax 打法</th>
<th>備註</th>
</tr>
</thead>
<tbody><tr>
<td>次方</td>
<td>a^{b}</td>
<td></td>
</tr>
<tr>
<td>x項</td>
<td>a_{b}</td>
<td></td>
</tr>
<tr>
<td>字與字的空格</td>
<td>a \ b</td>
<td></td>
</tr>
<tr>
<td>大括號</td>
<td>\&amp;{ , \&amp;}</td>
<td>&amp;需消除</td>
</tr>
<tr>
<td>分式寫法</td>
<td>\frac{分子}{分母}</td>
<td></td>
</tr>
<tr>
<td>套入文字</td>
<td>\text{文字}</td>
<td></td>
</tr>
<tr>
<td>總和</td>
<td>\sum_{i=1}^n a_n</td>
<td>如果不需要其他係數，只需要符號時使用 \Sigma</td>
</tr>
<tr>
<td>大於等於</td>
<td>\geq</td>
<td></td>
</tr>
<tr>
<td>小於等於</td>
<td>\leq</td>
<td></td>
</tr>
<tr>
<td>乘法</td>
<td>\cdot</td>
<td></td>
</tr>
<tr>
<td>百分比</td>
<td>\ \ %</td>
<td>須將斜線 與 % 中間的空白消去</td>
</tr>
<tr>
<td>註解</td>
<td>\ %</td>
<td>須將斜線 與 % 中間的空白消去</td>
</tr>
<tr>
<td>對數</td>
<td>\log_2 x</td>
<td></td>
</tr>
<tr>
<td>在文字上面加一橫線</td>
<td>\bar{x}</td>
<td></td>
</tr>
<tr>
<td>Union(聯集)</td>
<td>\cup</td>
<td></td>
</tr>
<tr>
<td>Intersection(交集)</td>
<td>\cap</td>
<td></td>
</tr>
<tr>
<td>+-(加減)</td>
<td>\pm</td>
<td></td>
</tr>
<tr>
<td>文字上面加一槓</td>
<td>\bar{}</td>
<td></td>
</tr>
<tr>
<td>大約</td>
<td>\approx</td>
<td></td>
</tr>
<tr>
<td>變異數符號</td>
<td>\sigma</td>
<td></td>
</tr>
<tr>
<td>根號</td>
<td>\sqrt[ n ]{}</td>
<td>裡面的 n 為開幾次跟號</td>
</tr>
<tr>
<td>換行</td>
<td>\ \ \ \</td>
<td>四個斜線，需要把中間空格消除</td>
</tr>
<tr>
<td>相關係數</td>
<td>\rho</td>
<td></td>
</tr>
<tr>
<td>beta</td>
<td>\beta</td>
<td></td>
</tr>
<tr>
<td>\(\mu \)</td>
<td>\mu</td>
<td></td>
</tr>
<tr>
<td>\(\lambda \)</td>
<td>\lambda</td>
<td></td>
</tr>
<tr>
<td>在字母上方有 ^</td>
<td>\hat{}</td>
<td></td>
</tr>
<tr>
<td>\(\theta\)</td>
<td>\theta</td>
<td></td>
</tr>
<tr>
<td>⇒</td>
<td>複製就好</td>
<td></td>
</tr>
</tbody></table>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="http://detexify.kirelabs.org/classify.html" target="_blank" rel="noopener">透過手寫來找出適合的 mathjax </a><br><a href="https://blog.csdn.net/mage_ee/article/details/75309174" target="_blank" rel="noopener">MathJax 基础 (1)：基础语法</a><br><a href="https://blog.csdn.net/yang_csdnForOBTS/article/details/81228365" target="_blank" rel="noopener">Latex：大于等于号和小于等于号</a><br><a href="https://math.meta.stackexchange.com/questions/22443/how-to-markup-expression-using-sigma-notation-for-sum-in-mathjax" target="_blank" rel="noopener">How to markup expression using sigma notation for sum in MathJax</a><br><a href="https://blog.csdn.net/bi_hu_man_wu/article/details/70207695" target="_blank" rel="noopener">Latex中点乘、叉乘、除以</a><br><a href="https://phabricator.wikimedia.org/T38855" target="_blank" rel="noopener">MathJax treats percent sign (%) as start of a comment</a><br><a href="https://blog.csdn.net/qq_17528659/article/details/82152530" target="_blank" rel="noopener">LaTeX 特殊符号、加帽子符号、横线和波浪线</a><br><a href="https://timmurphy.org/2010/05/22/union-and-intersection-symbols-in-latex/" target="_blank" rel="noopener">Union and Intersection symbols in LaTeX</a><br><a href="https://math.meta.stackexchange.com/questions/26403/how-to-write-plus-minus-sign-in-mathjax" target="_blank" rel="noopener">How to write plus-minus sign in MathJax? [duplicate]</a><br><a href="https://16sixteen.github.io/jekyll-study/mathjax" target="_blank" rel="noopener">常用的mathjax符号</a><br><a href="https://math.meta.stackexchange.com/questions/29609/how-to-type-sigma-and-other-symbols-in-mathjax" target="_blank" rel="noopener">How to type Sigma and other symbols in MathJax [duplicate]</a><br><a href="https://blog.csdn.net/xm_ovo/article/details/107536132" target="_blank" rel="noopener">解决mathjax公式不换行问题</a><br><a href="https://www.jianshu.com/p/ca46b67933ab" target="_blank" rel="noopener">Latex 字母上面加符号 波浪线 横线 角号</a><br>齊笎詳解</p>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>mathjax</tag>
      </tags>
  </entry>
  <entry>
    <title>tidytext ERROR! Input must be a character vector of any length or a list of character vectors, each of which has a length of 1.</title>
    <url>/2020/09/10/R/R-ERROR-tinytext-unnset-token/</url>
    <content><![CDATA[<h2 id="內容說明"><a href="#內容說明" class="headerlink" title="內容說明"></a>內容說明</h2><blockquote>
<p>寫程式的時候是不可能沒遇到 bug 的，bug 紀錄整理</p>
</blockquote>
<a id="more"></a>

<h2 id="ERROR-Input-must-be-a-character-vector-of-any-length-or-a-list-of-character-vectors-each-of-which-has-a-length-of-1"><a href="#ERROR-Input-must-be-a-character-vector-of-any-length-or-a-list-of-character-vectors-each-of-which-has-a-length-of-1" class="headerlink" title="ERROR! Input must be a character vector of any length or a list of character vectors, each of which has a length of 1."></a>ERROR! Input must be a character vector of any length or a list of character vectors, each of which has a length of 1.</h2><blockquote>
<p>當我們在使用 tidytest 此套件中的 unnest_tokens 時遇到此問題，要怎麼解決呢？</p>
</blockquote>
<h3 id="situation-1-input-的-data-裡面的字串型態並不是-character-而是-factor"><a href="#situation-1-input-的-data-裡面的字串型態並不是-character-而是-factor" class="headerlink" title="situation 1: input 的 data 裡面的字串型態並不是 character 而是 factor"></a>situation 1: input 的 data 裡面的字串型態並不是 character 而是 factor</h3><p>先看看你給予 unnest_tokens 的 data，然後透過 print 來查看型態，如果有查看到關於型態為 factor 而不是 character 且這是你需要使用 unnest_tokens 的 data，強烈建議先將他轉成 character，再重跑一次 unnest_tokens，這樣或許能夠解決問題。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xDomino.Title &lt;- tibble(line&#x3D;1:nrow(x.Domino),text &#x3D; as.character(x.Domino$Title) )</span><br><span class="line">xDomino.Title.word &lt;- xDomino.Title %&gt;% tidytext::unnest_tokens(word, text)</span><br></pre></td></tr></table></figure>

<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://stackoverflow.com/questions/46341840/how-do-i-solve-the-following-errorinput-must-be-a-character-vector-of-any-lengt" target="_blank" rel="noopener">How do I solve the following error?Input must be a character vector of any length or a list of character vectors, each of which has a length of 1.</a><br><a href="https://juliasilge.github.io/tidytext/reference/unnest_tokens.html" target="_blank" rel="noopener">Split a column into tokens using the tokenizers package</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>有時候文章看得不夠多，真的沒有安全感呀，有時候網路充斥著太多過時訊息會使人誤解正確資訊，於是我特地寫一篇文章來增加資訊的正確程度，我也希望我這篇文章可以幫助到別人且此文章沒有錯誤，謝系大家。<br>P.S. 我再找這 bug 也是花了很多時間…，大概一小時，找 bug 應該可以排行在世界十大麻煩之中了 QwQ。</p>
]]></content>
      <categories>
        <category>R語言</category>
      </categories>
      <tags>
        <tag>R語言</tag>
        <tag>學習筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>R character 與 factor 比較</title>
    <url>/2020/09/10/R/R-factor_vs_character/</url>
    <content><![CDATA[<h2 id="內容說明"><a href="#內容說明" class="headerlink" title="內容說明"></a>內容說明</h2><blockquote>
<p>說明 R 語言中 factor 跟 character 他們彼此有甚麼好處又有甚麼不一樣。</p>
</blockquote>
<a id="more"></a>

<h2 id="character-介紹"><a href="#character-介紹" class="headerlink" title="character 介紹"></a>character 介紹</h2><p>基本上它就是 string，並不是 C 語言的 char，如果他是 C 語言的 char 那就很難用了www。<br>是 R 語言中最好用也是最基礎的型態之一。</p>
<p>字串的用法，相信只要 google 就好，我來講的話或許有點太失字串面子了。</p>
<h2 id="factor-介紹"><a href="#factor-介紹" class="headerlink" title="factor 介紹"></a>factor 介紹</h2><p>我對於 factor 比較不熟，如果沒有介紹的很晚整抱歉 QQ。<br>factor 用一句話來表示就是專門給文字用的 vector，且他還帶有層級(Levels) 的 vector。</p>
<h3 id="factor-比起-vectior-多兩個要素"><a href="#factor-比起-vectior-多兩個要素" class="headerlink" title="factor 比起 vectior 多兩個要素:"></a>factor 比起 vectior 多兩個要素:</h3><p>ordered</p>
<ul>
<li>決定要不要有排序，如果沒有指定順序方式，則會使用字母順序來排序。<br>levels</li>
<li>決定排序的方式</li>
</ul>
<p>舉例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">temperatures &lt;- c(&quot;warm&quot;, &quot;hot&quot;, &quot;cold&quot;)</span><br><span class="line">temp_factors &lt;- factor(temperatures, ordered &#x3D; TRUE, levels &#x3D; c(&quot;cold&quot;, &quot;warm&quot;, &quot;hot&quot;))</span><br><span class="line">temp_factors</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">## [1] warm hot  cold</span><br><span class="line">## Levels: cold &lt; warm &lt; hot</span><br></pre></td></tr></table></figure>

<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://bookdown.org/tonykuoyj/eloquentr/vector-factor.html" target="_blank" rel="noopener">10 多樣的資料結構：向量與因素向量</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>為甚麼會突然寫一篇關於 factor 與 character 的差別呢，因為在 linux 上我遇到的<a href="https://theriseofdavid.github.io/2020/09/10/R/R-unexpected_error_to_Data_Transformation/" target="_blank" rel="noopener">第一個將程式移植到 linux 的錯誤</a>上就是關於這個，也讓我認識到 factor，雖然我想不懂為甚麼再將程式移植時會遇到此問題，但是有問題就是要解決，於是在這裡紀錄經驗，不讓我忘記也希望其他人可以盡快解決此 bug。</p>
]]></content>
      <categories>
        <category>R語言</category>
      </categories>
      <tags>
        <tag>R語言</tag>
        <tag>學習筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>BUG! Data_Transformation_to_OS</title>
    <url>/2020/09/10/R/R-unexpected_error_to_Data_Transformation/</url>
    <content><![CDATA[<h2 id="內容說明："><a href="#內容說明：" class="headerlink" title="內容說明："></a>內容說明：</h2><blockquote>
<p>R 語言將程式碼從 A os to B os 會出一些差錯，在這邊進行紀錄</p>
</blockquote>
<a id="more"></a>

<h2 id="BUG-Data-Transformation-to-OS"><a href="#BUG-Data-Transformation-to-OS" class="headerlink" title="BUG! Data_Transformation_to_OS"></a>BUG! Data_Transformation_to_OS</h2><p>當我再 windows10 上把寫好的 R 程式放到 centOS6 上時卻執行出 ERROR，但在 windows 不會出錯呀！為甚麼會這樣呢？</p>
<h3 id="solution-1-可能是型態不同"><a href="#solution-1-可能是型態不同" class="headerlink" title="solution 1: 可能是型態不同"></a>solution 1: 可能是型態不同</h3><p>在我的經驗中，R 的 tribble 的字串可能會在 windows 是 character 型態，但在 linux 上則是 factor，因此如果要讓程式可以繼續跑，就在 linux 上的程式特意再將 factor 再轉成 character 即可。</p>
<h4 id="補述"><a href="#補述" class="headerlink" title="補述:"></a>補述:</h4><p>在 2020/09/14 的 Debug 經驗中發現，只要是字串陣列在 linux 極高機率是 factor，如果不想要 factor，個人建議可以在每一個宣告字元陣列時加上 <code>as.character()</code>。</p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>老實講，這種問題我第一次遇到，這也讓我很頭疼。因為其實只有一份程式碼讓我遇到，於是我都沒有往這方向去思考，直到我不斷尋找問題時，腦袋靈光一閃才讓我找出此錯誤。</p>
<p>在這邊推薦一種除錯方式，雖然應該很多人都知道，但這除錯方式是我自己想的，可以將你每份程式碼都先複製 4、5 行進入 R console，這樣會相對好除錯很多。因為我在公司沒有人教我怎麼除錯，我當時也過有自信的說我會寫 R，導致變成讓我少從主管們學到一些經驗，讓我多踩一些坑，有時候這確實也不太好QQ。</p>
]]></content>
      <categories>
        <category>R語言</category>
      </categories>
      <tags>
        <tag>R語言</tag>
        <tag>學習筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>linux /usr/bin 與 /usr/local/bin 有甚麼差別?</title>
    <url>/2020/09/10/linux/linux-locan_bin_vs_bin/</url>
    <content><![CDATA[<h2 id="內容說明"><a href="#內容說明" class="headerlink" title="內容說明"></a>內容說明</h2><blockquote>
<p>記錄我在 linux 上關於執行檔路徑位置的觀念澄清。<br>作業系統為: centOS6</p>
</blockquote>
<h2 id="問題概述："><a href="#問題概述：" class="headerlink" title="問題概述："></a>問題概述：</h2><p>通常我們在將某份程式文件 <code>make &amp;&amp; make install</code> 之後，我們只要輸入執行檔的 key，就可以直接輸入指令。例如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python3 test.py</span><br><span class="line">yum install openssl</span><br></pre></td></tr></table></figure>

<p>這種感覺，而其中的 yum and python3，就是執行檔的 key，但神奇的是你 <code>which</code> 他們路徑時卻不一樣</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># yum 執行檔路徑</span><br><span class="line">which yum</span><br><span class="line">&#x2F;usr&#x2F;bin</span><br><span class="line"></span><br><span class="line"># 在 python 執行檔路徑</span><br><span class="line">which python3</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;bin</span><br></pre></td></tr></table></figure>
<p>他們的位置是不一樣的！這讓我覺得神奇也特別去查了下這兩個的用法。</p>
<h2 id="usr-bin-下通常是放甚麼呢"><a href="#usr-bin-下通常是放甚麼呢" class="headerlink" title="usr/bin 下通常是放甚麼呢?"></a>usr/bin 下通常是放甚麼呢?</h2><p>通常放置可執行程式，基本上 linux 內建的所有可執行程式都放置於此。</p>
<h2 id="usr-local-bin-下通常是放甚麼呢"><a href="#usr-local-bin-下通常是放甚麼呢" class="headerlink" title="usr/local/bin 下通常是放甚麼呢?"></a>usr/local/bin 下通常是放甚麼呢?</h2><p>由於軟體會隨著時間推移而可以進行更新，例如要升級 python，那通常軟體預設安裝的地方在 /usr/local (local 是表示本機) 之間，但同時由於電腦內有新舊版的程式可執行檔，所以通常會把升級後的程式放在 usr/local/bin 資料夾內。</p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>linux 在自學的過程中其實個人覺得有點難呀！可能是因為我比較不敢亂來 XD，都是先看很多文章直到看到了有安全感才會下手，導致我常常把一件事情學習很久 QQ。因為我會怕如果做錯要返回很麻煩 QwQ，疫點都沒有年輕人的幹勁呀，欸！</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>linux</tag>
        <tag>centOS</tag>
      </tags>
  </entry>
  <entry>
    <title>QUESTION! HEXO 可以多個 categories 嗎?</title>
    <url>/2020/07/20/blog/blog-categories/</url>
    <content><![CDATA[<h2 id="內容說明"><a href="#內容說明" class="headerlink" title="內容說明:"></a>內容說明:</h2><blockquote>
<p>關於我在撰寫 blog 時遇到的問題經驗，並留下紀錄來解決。</p>
</blockquote>
<a id="more"></a>

<h2 id="QUESTION-HEXO-可以多個-categories-嗎"><a href="#QUESTION-HEXO-可以多個-categories-嗎" class="headerlink" title="QUESTION: HEXO 可以多個 categories 嗎?"></a>QUESTION: HEXO 可以多個 categories 嗎?</h2><p>當然可以。<del>雖然我應該一開始還覺得不行，因為看到了其他文章說不行 QQ</del></p>
<h3 id="situation-1-子分類"><a href="#situation-1-子分類" class="headerlink" title="situation 1: 子分類"></a>situation 1: 子分類</h3><p>如果你想要有一種分類是在 a 分類底下還有 b 分類，那就要使用此寫法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">categories: [Language,Chinese]</span><br></pre></td></tr></table></figure>

<h3 id="situation-2-一篇文章放在多分類中"><a href="#situation-2-一篇文章放在多分類中" class="headerlink" title="situation 2: 一篇文章放在多分類中"></a>situation 2: 一篇文章放在多分類中</h3><p>如果你想要一篇文章可以再多種分類下，但並不是 situation 1 那種情況，而是要那些分類的 level 等級都是一樣時，可以使用這種寫法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">categories:</span><br><span class="line">  - [English]</span><br><span class="line">  - [Chinese]</span><br></pre></td></tr></table></figure>

<h3 id="situation-3-我想要上述兩種方法我同時都要使用怎麼辦？"><a href="#situation-3-我想要上述兩種方法我同時都要使用怎麼辦？" class="headerlink" title="situation 3: 我想要上述兩種方法我同時都要使用怎麼辦？"></a>situation 3: 我想要上述兩種方法我同時都要使用怎麼辦？</h3><p>那就將他們綜合起來運用就可以了！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">categories:</span><br><span class="line">  - [Language]</span><br><span class="line">  - [Sport]</span><br></pre></td></tr></table></figure>

<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://aiellochan.com/2018/02/13/hexo/Hexo-%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%A4%9A%E4%B8%AA-categories/" target="_blank" rel="noopener">Hexo 一篇文章多个 categories</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>老實講，因為我的英文能力不好，所以我大部分的學習都是仰賴國人的文章，我很感謝他們，如果沒有他們我或許學習的速度並沒有那麼快八，雖然可能少了學習英文的機會，但我本來主意就是要學習好程式技術，所以我對願意撰寫技術的每個人，只要是這個世界的人我都保持著謝意與尊敬。</p>
<p>我自己也希望可以變成這種人，但我技術還不強，目前邊寫邊紀錄，希望能讓自己成長蛻變。</p>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>人生旅途</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces 161D - Distance in Tree (點分治講解)</title>
    <url>/2020/09/11/Codeforces/Codeforces%20161D/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>給你一棵樹，保證他們不會形成迴路。詢問這棵樹中有多少 x 的距離。<br><strong>以下用到的都是使用<a href="https://www.luogu.com.cn/blog/user9012/dian-fen-zhi-lve-xie#blog-comments" target="_blank" rel="noopener">Dispwnl 博客的點分治講解</a>的圖片，如果 Dispwnl 大大不允許我使用我將會自行刪除，向 Dispwnl 道歉 QQ，也很謝謝他寫的詳細點分治教學讓我對點分治有了解</strong><br>此篇程式碼大多從 <a href="https://blog.csdn.net/The___Flash/article/details/101099955" target="_blank" rel="noopener">Distance in Tree （CodeForces - 161D，点分治）</a> 學習而來，謝謝作者釋放自己的程式碼，讓我可以完整學習到點分治。</p>
</blockquote>
<a id="more"></a>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>這要使用一種我從來沒有學過的演算法「點分治」，我們先來說說看點分治通常用於甚麼題目。</p>
<blockquote>
<p>他專門來解決給定一棵樹和一個整數 k，求此樹上兩點路徑等於小於 k 的有多少？<br>由於此題是點分治的模板題，只要能夠了解點分治就能解決此問題。<br>這題為教學題，我們將問題簡單化，只詢問「樹上兩點路徑等於 = k」</p>
</blockquote>
<h2 id="點分治介紹"><a href="#點分治介紹" class="headerlink" title="點分治介紹"></a>點分治介紹</h2><p><strong>點分治的精隨: 就是不斷把一顆樹拆成子樹來處理，並考慮路徑合併</strong><br><strong>分治點的選擇: 樹的重心</strong></p>
<h3 id="QUESTION-1-分治點是甚麼"><a href="#QUESTION-1-分治點是甚麼" class="headerlink" title="QUESTION 1: 分治點是甚麼?"></a>QUESTION 1: 分治點是甚麼?</h3><p>分治點就是可以把一顆樹拆成兩棵樹的點。</p>
<h3 id="QUESTION-2-樹的重心是甚麼"><a href="#QUESTION-2-樹的重心是甚麼" class="headerlink" title="QUESTION 2: 樹的重心是甚麼?"></a>QUESTION 2: 樹的重心是甚麼?</h3><p>樹重心的所有子樹大小不超過整個樹大小的一半。</p>
<h3 id="QEUSTION-3-此演算法的複雜度呢"><a href="#QEUSTION-3-此演算法的複雜度呢" class="headerlink" title="QEUSTION 3: 此演算法的複雜度呢?"></a>QEUSTION 3: 此演算法的複雜度呢?</h3><p>\(O(\log n)\)</p>
<h3 id="名詞解釋-公式"><a href="#名詞解釋-公式" class="headerlink" title="名詞解釋: 公式"></a>名詞解釋: 公式</h3><p>樹的重心到左子樹中的路徑 + 樹的重心到右子樹的路徑 = k </p>
<h2 id="點分治原理操作"><a href="#點分治原理操作" class="headerlink" title="點分治原理操作"></a>點分治原理操作</h2><p><img src="/images/Codeforces161D/1.png" alt=""><br>如圖，我們先找出樹的重心，在將從樹的重心到左子樹中的路徑 + 樹的重心到右子樹的路徑加起來如果等於 k 我們就加一條路徑，再透過分治的方式，再從子樹的重心在重複一樣動作。<del>可以寫出很玄的遞迴</del></p>
<h2 id="選樹的重心"><a href="#選樹的重心" class="headerlink" title="選樹的重心"></a>選樹的重心</h2><p><img src="/images/Codeforces161D/2.png" alt=""><br>樹的重心不可以亂選，如果沒有選好是很浪費效率的，如上圖。</p>
<h3 id="QUESTION-你想想看如果選到-y-會多浪費時間www。"><a href="#QUESTION-你想想看如果選到-y-會多浪費時間www。" class="headerlink" title="QUESTION : 你想想看如果選到 y 會多浪費時間www。"></a>QUESTION : 你想想看如果選到 y 會多浪費時間www。</h3><p>當讀者學會以後，可以自行回答此問題，也順便增加自己對點分治的能力 XD。</p>
<p>開玩笑的，這篇是要讓讀者能了解點分治的，選 y 的話找路徑需要遞迴 4 次，但選 x 只需要遞迴 2 次，可以得知要找的點要盡量讓遞迴的次數最少為最優，樹的重心是最好的。</p>
<h2 id="建構樹"><a href="#建構樹" class="headerlink" title="建構樹"></a>建構樹</h2><p>建構點分治的樹比較抽象，因此拉出來獨立討論：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span> </span><br><span class="line">    <span class="keyword">int</span> v , nx ;</span><br><span class="line">     <span class="comment">//v = x 可以到此點，路徑為一 , nx 為 x 可以到此點的另外一個 Edge index，一樣是路徑為一 </span></span><br><span class="line">&#125;Edge[MAXN*<span class="number">2</span>]; </span><br><span class="line"><span class="comment">// 由於無向邊，但此結構是有向所以必須 *2， u -&gt; v , v &lt;- u 各一條。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n )</span></span>&#123;</span><br><span class="line">    Max[<span class="number">0</span>] = n ; </span><br><span class="line">    <span class="comment">// Max 是此點最大子樹中的點加起來，0 我們不採用於是就將它設為題目初始長度</span></span><br><span class="line">    ans = cnt = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= n ; i++)&#123;</span><br><span class="line">        head[i] = <span class="number">-1</span> ; </span><br><span class="line">        <span class="comment">//head 為 i 可以到某個點，路徑為一的 Edge index </span></span><br><span class="line">        <span class="comment">// head = -1 是因為下面的遞迴停止關鍵為 ~i ， ~(-1) = 0  </span></span><br><span class="line">        vis[i] = <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="尋找樹的重心"><a href="#尋找樹的重心" class="headerlink" title="尋找樹的重心"></a>尋找樹的重心</h2><p>透過 DFS + BFS，DFS 來尋找路徑長，BFS 來檢索子樹即可寫出這份遞迴來得知樹的重心：<br>我相信各位應該看不太懂這程式碼在寫甚麼於是我逐行增加註解。<del>寫得不好，大神請無視</del></p>
<p>也提供看我之前用紙筆實作的筆記來方便讀者學習，如果還是看不太懂註解那就看看我的實作筆記希望能看懂QQ<br><a href="#寫作筆記-1-get-root-note-1"> 寫作筆記 1 get_root (note 1) </a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//rt = root </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_rt</span><span class="params">(<span class="keyword">int</span> u , <span class="keyword">int</span> fa )</span></span>&#123;</span><br><span class="line">    sz[u] = <span class="number">1</span> ; Max[u] = <span class="number">0</span> ; </span><br><span class="line">    <span class="comment">//sz 是此點子樹的大小 // Max 是此點最大子樹中的點加起來</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u] ; ~i ; i=Edge[i].nx)&#123; </span><br><span class="line">        <span class="comment">// 枚舉次點進行的兒子 = 進行長度為一的 BFS(玄學版)</span></span><br><span class="line">        <span class="comment">// 由於 i = Edge[i].nx 於是可以直接找到下一個 i to v 路徑為一的節點</span></span><br><span class="line">        <span class="keyword">int</span> v = Edge[i].v ; </span><br><span class="line">        <span class="keyword">if</span>(vis[v] || v == fa )  <span class="keyword">continue</span> ; </span><br><span class="line">        <span class="comment">// vis 表示此點用過了，在第一次找重心時無用。之後會用到。</span></span><br><span class="line">        get_rt(v,u); <span class="comment">// 向下延伸</span></span><br><span class="line">        Max[u] = max(Max[u] , sz[v]); </span><br><span class="line">        <span class="comment">// 判斷這顆子樹有沒有比此點最大的子樹還要大</span></span><br><span class="line">        sz[u] += sz[v] ; <span class="comment">//更新 sz</span></span><br><span class="line">    &#125;</span><br><span class="line">    Max[u] = max(Max[u] , n - sz[u]); </span><br><span class="line">    <span class="comment">//用此點將樹分割，分割的兩部分是從此點展開的子樹與另外一個從父節點延伸的子樹 (n - sz[u])</span></span><br><span class="line">    <span class="keyword">if</span>(Max[rt] &gt; Max[u]) </span><br><span class="line">    <span class="comment">// 如果現在的最大子樹比較小那就採用現在的點</span></span><br><span class="line">        rt =  u ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">## 尋找從此點到所有子樹中所有點的距離</span><br><span class="line">這遞迴將我們從 u 點到所有點的距離都會求出來。</span><br><span class="line">一樣會每行進行註解，但前面有講到則不再贅述。</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_dis</span><span class="params">(<span class="keyword">int</span> u , <span class="keyword">int</span> fa , <span class="keyword">int</span> d)</span></span>&#123; <span class="comment">// fa = father , d = distance</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u] ; ~i ; i= Edge[i].nx)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = Edge[i].v ;</span><br><span class="line">        <span class="keyword">if</span>(vis[v] || v == fa ) <span class="keyword">continue</span> ; </span><br><span class="line">        <span class="comment">//如果 v == fa ，代表這點已經沒辦法再向下延伸</span></span><br><span class="line">        <span class="comment">// vis 如果此點有被用到就返回</span></span><br><span class="line">        dis[++cnt] = d + <span class="number">1</span> ; </span><br><span class="line">        <span class="comment">// 由於這裡我們並不在意是哪個點到哪個點的路徑長，我們只在意此路徑長多少，於是我們就用 ++cnt，循序填滿。</span></span><br><span class="line">        get_dis(v,u,dis[cnt]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="求通過此點的子樹們相加起來的路徑長來求答案"><a href="#求通過此點的子樹們相加起來的路徑長來求答案" class="headerlink" title="求通過此點的子樹們相加起來的路徑長來求答案"></a>求通過此點的子樹們相加起來的路徑長來求答案</h2><p>透過樹的重心將一顆完整的樹在分割成子樹，詢問如果從 子樹 A 到樹重心 + 子樹 B 到樹重心 = k 的有多少。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_ans</span><span class="params">(<span class="keyword">int</span> u , <span class="keyword">int</span> d )</span></span>&#123;</span><br><span class="line">    dis[cnt=<span class="number">1</span>] = d ;</span><br><span class="line">    get_dis(u,<span class="number">0</span>,d) ;</span><br><span class="line">    sort(dis+<span class="number">1</span> , dis+cnt+<span class="number">1</span>) ; </span><br><span class="line">    <span class="comment">// 由於 dis 裡面每一個都是從任意一個點到樹重心，透過公式(子樹 A 到樹重心 + 子樹 B 到樹重心 = k)，</span></span><br><span class="line">    <span class="comment">// 我們並不需要在意哪個點只需要在意距離長</span></span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span> , ans = <span class="number">0</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(l &lt; cnt &amp;&amp; dis[l] + dis[cnt] &lt; k ) l++ ; </span><br><span class="line">    <span class="comment">// 這時候的 cnt 因為 get_dis 不斷增加數量於是當前的 cnt 也會等於 dis 的右邊界。</span></span><br><span class="line">    <span class="comment">// 我們假設我們先使用 dis[l] 也就是最小路徑去跟其他條進行配合看是否能夠等於 k</span></span><br><span class="line">    <span class="comment">//如果 dis[l] + dis[cnt] 都沒有大於 k 就代表，怎樣都不會大於 k，於是將 l 範圍縮小增進，優化效率。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(l &lt; cnt &amp;&amp; dis[l] &lt;= k - dis[l])&#123; </span><br><span class="line">        ans += upper_bound(dis + l + <span class="number">1</span> , dis + cnt + <span class="number">1</span> , k - dis[l]) -  \ </span><br><span class="line">                lower_bound(dis+l+<span class="number">1</span> , dis+cnt+<span class="number">1</span> , k-dis[l]);</span><br><span class="line">        <span class="comment">// 因為我們的 dis 右邊界是一，所以所有 dis +1</span></span><br><span class="line">        <span class="comment">// k - dis[l]，可以找出我們 k = dis[l] + x， x 為任意變數能夠滿足前述公式即可。</span></span><br><span class="line">        l++ ; <span class="comment">// 再換新的 dis[l] 來進行配合</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="扣掉重複算到的路徑，用-DFS-實現"><a href="#扣掉重複算到的路徑，用-DFS-實現" class="headerlink" title="扣掉重複算到的路徑，用 DFS 實現"></a>扣掉重複算到的路徑，用 DFS 實現</h2><p><img src="/images/Codeforces161D/3.png" alt=""><br>我們從 A 到 root + B 到 root，路徑為 4，但這樣是不正確的，因為 A , B 都在同一個子樹並沒有符合我們一直強調的公式。於是我們需要做一個 BFS + DFS，再將重心的點分割成子樹再進行 <code>get_dis</code> and <code>get_ans</code> 的動作，就可以避免掉圖片中的問題。</p>
<p>如果還有點疑問，看程式碼八，也許程式碼的註解可以幫助到你。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u )</span></span>&#123;</span><br><span class="line">    vis[u] = <span class="number">1</span> ; <span class="comment">// 被用過的點，也是我們用來分割子樹的標準</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; rt &lt;&lt; ' ' &lt;&lt; u &lt;&lt; '\n' ;</span></span><br><span class="line">    ans += get_ans(u , <span class="number">0</span>); <span class="comment">// 得到公式中的 k，裡面會有不合法狀態，圖片中的問題。 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u] ; ~i ; i = Edge[i].nx)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = Edge[i].v ;</span><br><span class="line">        <span class="keyword">if</span>(vis[v]) <span class="keyword">continue</span> ;</span><br><span class="line">        ans -= get_ans(v , <span class="number">1</span>) ; <span class="comment">// 移除掉不合法的狀態 </span></span><br><span class="line">        <span class="comment">// QUESTION: 為甚麼這行可以移除掉不合法狀態呢?</span></span><br><span class="line">        <span class="comment">/* 我們看看上面的圖，他們是不是共用了至少同一條路徑？，如果共用很多條也沒關係</span></span><br><span class="line"><span class="comment">        ，之後的 DFS 就會注意到他們並解決這些問題。</span></span><br><span class="line"><span class="comment">        於是我們就可以用 get_ans(v,1) 用子樹的下一個點來進行一次 DFS，</span></span><br><span class="line"><span class="comment">        我們在假設 x -&gt; v 這條路徑會被共用，所以先直接設定成 1，</span></span><br><span class="line"><span class="comment">        這樣只要是不合法的答案在這邊都會被發現，就可以直接減掉就剩下合法答案了！</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        讀者如果還是不懂，可以嘗試將途中橘色的線(共用路徑)進行 +1 後再用 son 去算 dis_ans(son,1)</span></span><br><span class="line"><span class="comment">         去算 a, b 看 k = 4 時是不是也會有一條 XD。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        n = sz[v] , rt = <span class="number">0</span> , get_rt(v,u); <span class="comment">//由於子樹被切割，所以 n 的 size 也必須減少成子樹的大小。</span></span><br><span class="line">        <span class="comment">//由於樹被切割，所以必須重新尋找被切割樹後重心。</span></span><br><span class="line">        dfs(rt); <span class="comment">//再將樹進行切割，來配合公式。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也提供看我之前用紙筆實作的筆記來方便讀者學習，如果還是看不太懂註解那就看看我的實作筆記希望能看懂QQ<br><a href="#寫作筆記-2-dfs-and-get-ans-and-get-dis-note-2"> 寫作筆記 2 dfs and get_ans and get_dis (note 2) </a></p>
<h3 id="小貼心-由於我認為會有讀者對於在程式碼裡面放-QUESTION，閱讀不太方便，所以拉出來再寫一遍"><a href="#小貼心-由於我認為會有讀者對於在程式碼裡面放-QUESTION，閱讀不太方便，所以拉出來再寫一遍" class="headerlink" title="小貼心:由於我認為會有讀者對於在程式碼裡面放 QUESTION，閱讀不太方便，所以拉出來再寫一遍"></a>小貼心:由於我認為會有讀者對於在程式碼裡面放 QUESTION，閱讀不太方便，所以拉出來再寫一遍</h3><h4 id="QUESTION-為甚麼這行可以移除掉不合法狀態呢"><a href="#QUESTION-為甚麼這行可以移除掉不合法狀態呢" class="headerlink" title="QUESTION: 為甚麼這行可以移除掉不合法狀態呢?"></a>QUESTION: 為甚麼這行可以移除掉不合法狀態呢?</h4><h5 id="SOLUTION"><a href="#SOLUTION" class="headerlink" title="SOLUTION :"></a>SOLUTION :</h5><p>我們看看上面的圖，他們是不是共用了至少同一條路徑？，如果共用很多條也沒關係，之後的 DFS 就會注意到他們並解決這些問題。<br>於是我們就可以用 get_ans(v,1) 用子樹的下一個點來進行一次 DFS，我們在假設 x -&gt; v 這條路徑會被共用，所以先直接設定成 1，這樣只要是不合法的答案在這邊都會被發現，就可以直接減掉就剩下合法答案了！</p>
<p>讀者如果還是不懂，可以嘗試將途中橘色的線(共用路徑)進行 +1 後再用 son 去算 dis_ans(son,1) 去算 a, b 看 k = 4 時是不是也會有一條 XD。</p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://www.luogu.com.cn/blog/user9012/dian-fen-zhi-lve-xie#blog-comments" target="_blank" rel="noopener">Dispwnl 的博客-点分治略解</a><br><a href="https://zhuanlan.zhihu.com/p/56692947" target="_blank" rel="noopener">点分治学习笔记</a><br><a href="https://blog.csdn.net/The___Flash/article/details/101099955" target="_blank" rel="noopener">Distance in Tree （CodeForces - 161D，点分治）</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>老實講，我其實學習起來是很吃力的。可能是因為我的基礎知識還不足以讓我可以閱讀我參考連結所放的文章，畢竟我的程式能力跟各位大神比還只是一個還在吃奶的小孩，很多大神可能都懂的東西，我都不懂，所以理解起來也會特別吃力，總是要先看一遍講解在自己用紙筆實作一遍程式碼才可以懂大神們的思維，但我真的很感謝大神，如果沒有他們，我連學習的機會都沒有。</p>
<p>雖然說用紙筆實作一遍程式碼很浪費時間，大概花了 5 小時理解吧，但它確實是最容易理解的，我只實作一遍我就能理解大神們的操作，如再 DFS 的遞迴中加入 BFS，使用那種 for 寫法www。</p>
<p>雖然每次在學習演算法總是會讓我覺得難過，因為是自學很容易遇到學習障礙，但我認為這是我應該要學會的基礎。我並不是幸運的孩子，我勢必要先做出一些成果，讓資源跟大神可以關注到我，在提拔我或幫助我成長。在還沒有大神們關注到我之前，我會默默耕耘，繼續努力的！</p>
<p>為了讓讀者與未來的我看到之前的我學習是怎麼學習的，我就在這邊放入我為了學習這份演算法而在紙上實作的紀錄吧！</p>
<h3 id="寫作筆記-1-get-root-note-1"><a href="#寫作筆記-1-get-root-note-1" class="headerlink" title="寫作筆記 1 get_root (note 1)"></a>寫作筆記 1 get_root (note 1)</h3><p><img src="/images/Codeforces161D/4.jpg" alt=""></p>
<h3 id="寫作筆記-2-dfs-and-get-ans-and-get-dis-note-2"><a href="#寫作筆記-2-dfs-and-get-ans-and-get-dis-note-2" class="headerlink" title="寫作筆記 2 dfs and get_ans and get_dis (note 2)"></a>寫作筆記 2 dfs and get_ans and get_dis (note 2)</h3><p><img src="/images/Codeforces161D/6.jpg" alt=""></p>
<h2 id="此題目程式碼"><a href="#此題目程式碼" class="headerlink" title="此題目程式碼"></a>此題目程式碼</h2><p>還真虧讀者可以讀到這邊，我也花了三個小時撰寫文章，如果是已經懂點分治的朋友們應該會覺得很煩吧！<del>雖然我覺得懂點分治的大神並不會對這題感到困難www，就不會來看我的文章了 XD</del></p>
<p>對，如題目大意所說，這題就只是個模板題，於是剩下的就是一些標頭檔跟題目給的資料範圍限制了 XD。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 50005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n , k , a , b ;</span><br><span class="line"><span class="keyword">int</span> ans , cnt ;</span><br><span class="line"><span class="keyword">int</span> Max[MAXN] , sz[MAXN] , rt ;</span><br><span class="line"><span class="keyword">int</span> head[MAXN], dis[MAXN];</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v , nx ;</span><br><span class="line">&#125;Edge[MAXN*<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n )</span></span>&#123;</span><br><span class="line">    Max[<span class="number">0</span>] = n ;</span><br><span class="line">    ans = cnt = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= n ; i++)&#123;</span><br><span class="line">        head[i] = <span class="number">-1</span> ;</span><br><span class="line">        vis[i] = <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u , <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    Edge[cnt].v = v ;</span><br><span class="line">    Edge[cnt].nx = head[u] ;</span><br><span class="line">    head[u] = cnt++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_rt</span><span class="params">(<span class="keyword">int</span> u , <span class="keyword">int</span> fa )</span></span>&#123;</span><br><span class="line">    sz[u] = <span class="number">1</span> ; Max[u] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u] ; ~i ; i=Edge[i].nx)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = Edge[i].v ;</span><br><span class="line">        <span class="keyword">if</span>(vis[v] || v == fa )  <span class="keyword">continue</span> ;</span><br><span class="line">        get_rt(v,u);</span><br><span class="line">        sz[u] += sz[v] ;</span><br><span class="line">        Max[u] = max(Max[u] , sz[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    Max[u] = max(Max[u] , n - sz[u]);</span><br><span class="line">    <span class="keyword">if</span>(Max[rt] &gt; Max[u])</span><br><span class="line">        rt =  u ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_dis</span><span class="params">(<span class="keyword">int</span> u , <span class="keyword">int</span> fa , <span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u] ; ~i ; i= Edge[i].nx)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = Edge[i].v ;</span><br><span class="line">        <span class="keyword">if</span>(vis[v] || v == fa ) <span class="keyword">continue</span> ;</span><br><span class="line">        dis[++cnt] = d + <span class="number">1</span> ;</span><br><span class="line">        get_dis(v,u,dis[cnt]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_ans</span><span class="params">(<span class="keyword">int</span> u , <span class="keyword">int</span> d )</span></span>&#123;</span><br><span class="line">    dis[cnt=<span class="number">1</span>] = d ;</span><br><span class="line">    get_dis(u,<span class="number">0</span>,d) ;</span><br><span class="line">    sort(dis+<span class="number">1</span> , dis+cnt+<span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span> , ans = <span class="number">0</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(l &lt; cnt &amp;&amp; dis[l] + dis[cnt] &lt; k ) l++ ;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; cnt &amp;&amp; dis[l] &lt;= k - dis[l])&#123;</span><br><span class="line">        ans += upper_bound(dis + l + <span class="number">1</span> , dis + cnt + <span class="number">1</span> , k - dis[l]) - lower_bound(dis+l+<span class="number">1</span> , dis+cnt+<span class="number">1</span> , k-dis[l]);</span><br><span class="line">        l++ ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u )</span></span>&#123;</span><br><span class="line">    vis[u] = <span class="number">1</span> ;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; rt &lt;&lt; ' ' &lt;&lt; u &lt;&lt; '\n' ;</span></span><br><span class="line">    ans += get_ans(u , <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u] ; ~i ; i = Edge[i].nx)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = Edge[i].v ;</span><br><span class="line">        <span class="keyword">if</span>(vis[v]) <span class="keyword">continue</span> ;</span><br><span class="line">        ans -= get_ans(v , <span class="number">1</span>) ;</span><br><span class="line">        n = sz[v] , rt = <span class="number">0</span>  , get_rt(v,u);</span><br><span class="line">        dfs(rt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//#ifdef LOCAL</span></span><br><span class="line"><span class="comment">//    freopen("in1.txt" , "r" , stdin);</span></span><br><span class="line"><span class="comment">//#endif // LOCAL</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k ;</span><br><span class="line">    init(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>; i &lt; n ; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b ;</span><br><span class="line">        add(a,b);</span><br><span class="line">        add(b,a);</span><br><span class="line">    &#125;</span><br><span class="line">    rt = <span class="number">0</span> ; get_rt(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    dfs(rt);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Codeforces</category>
        <category>演算法知識</category>
      </categories>
      <tags>
        <tag>程式解題</tag>
        <tag>點分治</tag>
        <tag>演算法知識</tag>
      </tags>
  </entry>
  <entry>
    <title>QUESTION! HEXO 可以使用錨點嗎？</title>
    <url>/2020/09/11/blog/markdown-anchor/</url>
    <content><![CDATA[<h2 id="內容說明"><a href="#內容說明" class="headerlink" title="內容說明:"></a>內容說明:</h2><blockquote>
<p>關於我在撰寫 blog 時遇到的問題經驗，並留下紀錄來解決。</p>
</blockquote>
<a id="more"></a>

<h2 id="QUESTION-HEXO-可以使用錨點嗎？"><a href="#QUESTION-HEXO-可以使用錨點嗎？" class="headerlink" title="QUESTION: HEXO 可以使用錨點嗎？"></a>QUESTION: HEXO 可以使用錨點嗎？</h2><p>我會寫的文章還會不行嗎 XD。</p>
<p>markdown 中常用 # 來建立段落標題，於是就利用段落標題來添加錨點</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">標題1</span>](<span class="link">#標題1</span>)</span><br><span class="line">[<span class="string">標題2</span>](<span class="link">#標題2</span>)</span><br><span class="line">[<span class="string">標題3</span>](<span class="link">#標題3</span>)</span><br><span class="line"></span><br><span class="line"><span class="section"># 標題一</span></span><br><span class="line"><span class="section">## 標題二</span></span><br><span class="line"><span class="section">### 標題三</span></span><br></pre></td></tr></table></figure>

<h3 id="需要注意的小細節"><a href="#需要注意的小細節" class="headerlink" title="需要注意的小細節:"></a>需要注意的小細節:</h3><p><strong>如果我們的標題有空白時則使用 - 號代替，如果標題有小括號則不須寫出。</strong></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">標題2 Test</span>](<span class="link">#標題2-test</span>)</span><br><span class="line"></span><br><span class="line"><span class="section">### 標題2 Test</span></span><br></pre></td></tr></table></figure>

<h3 id="快速找到錨點的小步驟"><a href="#快速找到錨點的小步驟" class="headerlink" title="快速找到錨點的小步驟"></a>快速找到錨點的小步驟</h3><p>如果你是用來寫 blog 文章，建議可以 localhost 後直接點標題(圖片中的 1)，就可以看到 url 上有錨點(圖片中的二)，就可以直接貼在 markdown 中，是不是很方便呢！<br><img src="/images/markdown-anchor/1.PNG" alt=""></p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://www.jishuwen.com/d/2uT8/zh-tw" target="_blank" rel="noopener">Github markdown 錨點</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>畢竟 markdown 要是沒有錨點，那 markdown 在寫那種比較長的文章就相對吃力拉，幸好有錨點，也謝謝 markdown 的發明團隊們可以讓我在寫文章時減少撰寫網頁的麻煩。</p>
<p>也謝謝 Clloz 大大在網路上分享此技術，讓英文不好的我也可以快速學習，非常謝謝他。</p>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>人生旅途</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces 1406A - Subset Mex (水題)</title>
    <url>/2020/09/14/Codeforces/Codeforces%201406A/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>定義 mex: 這集合裡面缺少的最小負整數。<br>如 \(mex(  \{ 1,4,0,2,2,1 \}  ) = 3\)，缺少 \(3\)<br>如 \(mex(\{3,2,3,1,3,0,0\}) = 4\)，缺少 \(4\)</p>
<p>給你一組數列，要把它拆成 A , B 兩個子集，如果此數列裡面有重複的數字時需要平均分配給 A , B。試問如何讓 \(mex(a) + mex(b) \) 最大？</p>
</blockquote>
<a id="more"></a>

<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>依序把數列讀入，之後排序，再透過 a , b 兩個變數紀錄這數列裡面缺少的最小與次小的負整數就是答案。</p>
<h3 id="為甚麼可以這樣做？"><a href="#為甚麼可以這樣做？" class="headerlink" title="為甚麼可以這樣做？"></a>為甚麼可以這樣做？</h3><p>由於 mex 的定義，是集合裡面缺少的最小負整數，而再根據題目拆子集的要求只要有重複的就要分配給 a,b 兩個集合。</p>
<p>然後我們來舉個例:</p>
<ul>
<li><p>\( \{ 0,1,2,3 \} \)</p>
<blockquote>
<p> \(A = \{1,2,3 \}  , mex(A)=4 \)<br> \(B = \{\} , mex(B)=0 \)</p>
</blockquote>
</li>
<li><p>\(\{0,0,1,1,2,4\}\)</p>
<blockquote>
<p>\(A = \{0,1,2,4\} , mex(A) = 3 \)<br>\(B = \{0,1\} , mex(B) = 2 \)<br>這裡的 4 放在 A 或 B 都沒關係，不影響</p>
</blockquote>
</li>
</ul>
<h3 id="得出結論"><a href="#得出結論" class="headerlink" title="得出結論"></a>得出結論</h3><p>數列中，如果此數列中沒有重複的最小整數，那最小整數就會是 \(mex(B)\)，A 則是排序中第一個缺失的最小整數。</p>
<p>於是我們排序好，直接用一個 for，只要根據數字順序判斷這數列哪裡數字缺失就是 A 的位置，而 B 就是沒有重複的最小整數。</p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://www.cnblogs.com/RioTian/p/13659464.html" target="_blank" rel="noopener">Codeforces Round #670 (Div. 2) 深夜掉分（A - C题补题）</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>其實這場比賽我一題都沒有解出來www，實力不好啊！也不太會分配時間，這點我還需要再學習。然後這題有個很大的重點讓當時的我沒有解出來，就是<font color="#dd0000"><strong>我看不懂他的英文</strong></font> ，導致我在讀懂題目就花了 30 分鐘卻還沒有讀懂題目，浪費掉了許多時間。英文能力真的很重要，一定要學好。</p>
<p>等我 ICPC 2020 taipei 比完後我一定要來好好惡補我的英文能力，<del>演算法也要好嗎= = ~</del>。我還有好多事情要努力要學習，好希望自己的學習能力能夠好點。</p>
<p>感謝 <strong>RioTian</strong> 大神分享程式碼讓我可以看到這種程式解法，我知道中文題目後我沒有想到這種解法，而且這種解法更有效率更好懂！讓我學習了一課，謝謝大神讓我能夠往前成長一步。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 110</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> t , n , num[MAXN] =&#123;&#125; ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//#ifdef LOCAL</span></span><br><span class="line"><span class="comment">//    freopen("in1.txt" ,"r" , stdin ) ;</span></span><br><span class="line"><span class="comment">//#endif // LOCAL</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t ;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i++)</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; num[i] ;</span><br><span class="line">        sort(num,num+n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> a=<span class="number">0</span> , b = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num[i] == a ) a++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (num[i] == b ) b++ ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a + b &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>水題</tag>
        <tag>程式解題</tag>
        <tag>Codeforces Round .#670 (Div. 2)</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces 1406B - Maximum Product (暴力搜尋 Brute force)</title>
    <url>/2020/09/14/Codeforces/Codeforces%201406B/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>給你一組數列裡面含有正、負整數，試問從中找出 5 個數字乘起來數字最大</p>
</blockquote>
<a id="more"></a>

<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>先排序讀進來的全部數列，之後進行窮舉。</p>
<h3 id="窮舉共有三種方法："><a href="#窮舉共有三種方法：" class="headerlink" title="窮舉共有三種方法："></a>窮舉共有三種方法：</h3><blockquote>
<p>全部 5 個數字選最大的正整數<br>選 3 個最大正整數 + 2 個最小負整數<br>選 1 個最大正整數 + 4 個最小負整數</p>
</blockquote>
<h3 id="Why-怎麼是這樣做呢"><a href="#Why-怎麼是這樣做呢" class="headerlink" title="Why? 怎麼是這樣做呢?"></a>Why? 怎麼是這樣做呢?</h3><p>由於我們負負得正，我們沒辦法確定說到底選誰比較好，但我們可以用窮舉的方式來找出最好的解法。<br>只要進行排序，最小的兩個負數相乘肯定會比其他的負數相乘來的更大，以此類推，最大的兩個正整數相乘肯定會比其他的正整數相乘更大。</p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://www.cnblogs.com/RioTian/p/13659464.html" target="_blank" rel="noopener">Codeforces Round #670 (Div. 2) 深夜掉分（A - C题补题）</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>這題其實很簡單的，但是我把它想得太複雜了。<del>這…這就是社會的歷練嗎</del>，明明小學生都可以解開的簡單題目，我花了一小時半都沒有解出來。這題出的好呀，直接打中的思考盲點，好過癮，讓我學起來了！</p>
<p>我原本是想要用遞迴解開但我一直錯呀，真的比賽思考很久都還是沒有解開，好討厭。結果我把她想得太困難了，用簡單的小技巧就能解開了。</p>
<p>遞迴解法是選出 9 個數字，其中 5 個為正整數最大，4 個為負整數最小，然後進行遞迴判斷，之後進行優化，但只能過題目的測資，之後就不行了XD，我的技術還是不夠承受呀XD</p>
<p>感謝 <strong>RioTian</strong> 大神分享程式碼讓我可以看到這種程式解法，讓我可以了解到這種窮舉解法，讓我學習了一課，謝謝大神讓我能夠往前成長一步。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 200010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">ll t , n , a[MAXN] = &#123;&#125; ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//#ifdef LOCAL</span></span><br><span class="line"><span class="comment">//    freopen("in1.txt" , "r" , stdin );</span></span><br><span class="line"><span class="comment">//#endif // LOCAL</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t ;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i++)</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a[i] ;</span><br><span class="line">        sort(a , a + n);</span><br><span class="line"></span><br><span class="line">        ll ans[<span class="number">5</span>] = &#123;&#125; ;</span><br><span class="line">        ans[<span class="number">0</span>] = a[n<span class="number">-1</span>] * a[n<span class="number">-2</span>] * a[n<span class="number">-3</span>] * a[n<span class="number">-4</span>] * a[n<span class="number">-5</span>] ;</span><br><span class="line">        ans[<span class="number">1</span>] = a[n<span class="number">-1</span>] * a[n<span class="number">-2</span>] * a[n<span class="number">-3</span>] * a[<span class="number">0</span>] * a[<span class="number">1</span>] ;</span><br><span class="line">        ans[<span class="number">2</span>] = a[n<span class="number">-1</span>] * a[<span class="number">0</span>] * a[<span class="number">1</span>] * a[<span class="number">2</span>] * a[<span class="number">3</span>] ;</span><br><span class="line">        sort(ans,ans+<span class="number">3</span>);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans[<span class="number">2</span>] &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="題外話"><a href="#題外話" class="headerlink" title="題外話"></a>題外話</h2><p>這裡是我的遞迴解法，有人要幫我修改這程式幫助我通過嗎？如果通過私訊我告訴我好嗎XD，謝謝你啦</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lln</span>&#123;</span></span><br><span class="line">    ll num , neg ;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">deque</span>&lt;lln&gt; dnum;</span><br><span class="line"><span class="keyword">int</span> t , n ;</span><br><span class="line">ll maxn = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(lln a , lln b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span>  a.num &lt; b.num ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">p</span><span class="params">(<span class="keyword">int</span> index , ll sum , <span class="keyword">int</span> i , ll intNeg )</span></span>&#123;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; index &lt;&lt; ' ' &lt;&lt; sum &lt;&lt; ' ' &lt;&lt; i &lt;&lt; ' ' &lt;&lt; intNeg &lt;&lt; '\n' ;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(index &gt;= <span class="number">5</span>)&#123;</span><br><span class="line">        maxn = max(sum,maxn) ;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; sum &lt;&lt; '\n' ;</span></span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">0</span> )</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    p(index +<span class="number">1</span> , sum * dnum[i].num * (dnum[i].neg? <span class="number">-1</span> : <span class="number">1</span>) , i<span class="number">-1</span> , intNeg+dnum[i].neg);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((intNeg+dnum[i].neg) % <span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">        p(index, sum , i<span class="number">-1</span> , intNeg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span> , <span class="built_in">stdin</span> );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line"></span><br><span class="line">    lln temp ;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t ;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">        dnum.clear();</span><br><span class="line">        maxn = <span class="number">-1e15</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; temp.num ;</span><br><span class="line">            <span class="keyword">if</span>(temp.num &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                temp.neg = <span class="number">1</span> ;</span><br><span class="line">                temp.num *= <span class="number">-1</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                temp.neg = <span class="number">0</span> ;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; temp.num &lt;&lt; ' ' &lt;&lt; temp.neg &lt;&lt; '\n';</span></span><br><span class="line">            dnum.push_back(temp) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; '\n' ;</span></span><br><span class="line">        sort(dnum.begin() , dnum.end(), compare ) ;</span><br><span class="line">        p(<span class="number">0</span>,<span class="number">1</span>,n<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; maxn &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>水題</tag>
        <tag>程式解題</tag>
        <tag>Codeforces Round .#670 (Div. 2)</tag>
        <tag>暴力搜尋 Brute force</tag>
      </tags>
  </entry>
  <entry>
    <title>R string 取代文字語法與教學</title>
    <url>/2020/09/14/R/R-string-replace/</url>
    <content><![CDATA[<h2 id="內容說明"><a href="#內容說明" class="headerlink" title="內容說明"></a>內容說明</h2><blockquote>
<p>說明 R 語言中 string 怎麼做到取代 (replace) 功能。</p>
</blockquote>
<a id="more"></a>

<h2 id="QUESTION-R-有沒有一種語法關於字串中取代文字呢？"><a href="#QUESTION-R-有沒有一種語法關於字串中取代文字呢？" class="headerlink" title="QUESTION! R 有沒有一種語法關於字串中取代文字呢？"></a>QUESTION! R 有沒有一種語法關於字串中取代文字呢？</h2><blockquote>
<p>有，但他有兩種方法，好麻煩wwww。<br>但我們這邊只介紹最簡單的方法，其中另外一方法必須要安裝額外套件因而略過。</p>
</blockquote>
<h3 id="soultion"><a href="#soultion" class="headerlink" title="soultion:"></a>soultion:</h3><p>使用 <code>gsub</code> 方法。</p>
<p>gsub 基本上與其他語言中的 replace 相同，只是換了一個名字..。<del>這些程式語言就不能再互相好好整理一下嗎..</del></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">strA &lt;- <span class="string">"I can to sleep"</span></span><br><span class="line">gsub(<span class="string">"cab"</span> , <span class="string">"want"</span> , strA)</span><br><span class="line"><span class="comment">#"I want to sleep"</span></span><br></pre></td></tr></table></figure>

<h3 id="tip"><a href="#tip" class="headerlink" title="tip:"></a>tip:</h3><p>基本上任何符號與空格、tab、換行都是可以被識別的，但還是有些例外。<br>這邊只附上一些常用的例外，還有些例外可以點此<a href="https://blog.csdn.net/lztttao/article/details/82086346" target="_blank" rel="noopener">連結</a></p>
<table>
<thead>
<tr>
<th>取代寫法</th>
<th>實際取代</th>
<th>說明</th>
</tr>
</thead>
<tbody><tr>
<td>//.</td>
<td>.</td>
<td>取代 , 必須先加//</td>
</tr>
<tr>
<td>//+</td>
<td>+</td>
<td>取代 + 必須先加//</td>
</tr>
<tr>
<td>[:blank:]</td>
<td>取代空白字元，如 space or tab</td>
<td>這真的很好用欸，超讚</td>
</tr>
<tr>
<td>[:digit:]</td>
<td>所有阿拉伯數字 1~9</td>
<td>這也是非常好用欸。<del>C 有沒有考慮跟進一下</del></td>
</tr>
</tbody></table>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://blog.csdn.net/lztttao/article/details/82086346" target="_blank" rel="noopener">R语言-gsub替换字符工具</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>原本都很喜歡寫 C，現在越來越喜歡寫 R，R 真的好好用一堆方便的寫法，<del>還有一堆堪稱是神奇的操作，給喜歡 C 的人看是玩壞www</del>，不過我也要好好努力學會更多的語言，造就自己的優勢！</p>
]]></content>
      <categories>
        <category>R語言</category>
      </categories>
      <tags>
        <tag>R語言</tag>
        <tag>學習筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces 126B - Password (Z-algorithm 講解)</title>
    <url>/2020/09/18/Codeforces/Codeforces%20126B/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>給你一字串 X，試問有沒有一個子字串 S，在 X 的頭、尾巴、中間都出現。<br>                                ，在 X 的 prefix , suffix and Beside prefix and suffix appear。</p>
</blockquote>
<a id="more"></a>

<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>這題是 Z algorithm 的模板題，先介紹 Z-algorithm。<br><strong>此題有多種解，這裡使用 Z-algorithm 解</strong></p>
<blockquote>
<p>專門解決在線性時間中在一段文字 (text) 中找到我們所需要的段落 (pattern)<br>與此類似的演算法: KMP algorithm<br>由於此題是 Z-algorithm 的模板題，只要能夠了解 Z-algorithm 就能解決此問題。<br>這題為教學題，但此問題還有一點點的小設計，需要稍加解釋才能完全理解。</p>
</blockquote>
<h2 id="Z-algorithm-介紹"><a href="#Z-algorithm-介紹" class="headerlink" title="Z-algorithm 介紹"></a>Z-algorithm 介紹</h2><blockquote>
<p><strong>Z-algorithm 精隨: 透過 x,y 兩變數與 「Z 陣列」找出此字串中「最長共同前綴總和 (Longest Common Prefix)」</strong></p>
</blockquote>
<h3 id="QUESTION-1-x-y-and-「Z-陣列」是甚麼"><a href="#QUESTION-1-x-y-and-「Z-陣列」是甚麼" class="headerlink" title="QUESTION 1: x,y and 「Z 陣列」是甚麼?"></a>QUESTION 1: x,y and 「Z 陣列」是甚麼?</h3><p>等下會解釋XD，很快，看不到 1 分鐘就能知道了。</p>
<h3 id="QUESTION-2-此演算法的複雜度呢"><a href="#QUESTION-2-此演算法的複雜度呢" class="headerlink" title="QUESTION 2: 此演算法的複雜度呢?"></a>QUESTION 2: 此演算法的複雜度呢?</h3><p>複雜度 \(O(text + pattern)\)</p>
<h2 id="Z-algorithm-原理"><a href="#Z-algorithm-原理" class="headerlink" title="Z-algorithm 原理"></a>Z-algorithm 原理</h2><h3 id="Z-Array"><a href="#Z-Array" class="headerlink" title="Z Array"></a>Z Array</h3><p>在實現 Z-algorithm 需要用到一陣列，「Z Array」。</p>
<p>我們查看字串的長度，並建立一陣列與字串長度相當，其就是 Z Array，Z 陣列中的 i 表示當前「最長共同前綴總和 (Longest Common Prefix)」</p>
<p>\(Z[0]\) 毫無幫助XD，由於 Z[0] 只有自己他沒辦法達到共同，<del>他們都是自己</del>，即為都是「同一個字串」，因而無意義。</p>
<h3 id="x-and-y"><a href="#x-and-y" class="headerlink" title="x and y"></a>x and y</h3><p>在實現 Z-algorithm <strong>還</strong>需要用到兩變數 \( x , y\)。</p>
<blockquote>
<p>x = 目前<strong>共同前綴</strong>的第一個字元<br>y = 目前<strong>共同前綴</strong>的最後一字元在字串中的 index</p>
</blockquote>
<h3 id="Z-algorithm-再除了此題目以外的應用"><a href="#Z-algorithm-再除了此題目以外的應用" class="headerlink" title="Z-algorithm 再除了此題目以外的應用"></a>Z-algorithm 再除了此題目以外的應用</h3><p>通常是應用在尋找段落 (pattern)，將文本字串 (text) 與段落連接起來，視段落為「P」、文字為「T」，並加上一個沒有在 P and T 出現過的字元，假設為「\$」，產生出「P\$T」，最後產生 Z array，如果 Z array 中的某個值等於 P 的長度，則段落出現在此處。</p>
<p>因為從未出現過的字元使得「最長共同前綴總和 (Longest Common Prefix)」最大只能到 P，從未出現的字元阻斷了增加的可能性，才能應用在此。</p>
<h3 id="Z-algorithm-實現與說明"><a href="#Z-algorithm-實現與說明" class="headerlink" title="Z-algorithm 實現與說明"></a>Z-algorithm 實現與說明</h3><p>由於我認為在程式碼中加上好懂得註解十分好懂，所以我就根據每一行程式碼進行說明，相信會讓讀者更好學會此演算法。<br>如果對下方說明還是不了解，可以點擊此<a href="https://personal.utdallas.edu/~besp/demo/John2010/z-algorithm.htm" target="_blank" rel="noopener">連結</a>觀看動畫，也許能夠讓你更了解 Z-algorithm 運作。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> s ;</span><br><span class="line"><span class="keyword">int</span> z[s.length()] = &#123;&#125; ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; s.length() ; i++ )&#123; </span><br><span class="line">    z[i] = max(<span class="number">0</span>,min(z[i-x] , y - i + <span class="number">1</span>));</span><br><span class="line">    <span class="comment">// z[i-x] 直接詢問 z[i-x] 共同前綴嘗是多少，</span></span><br><span class="line">    <span class="comment">// 如果當前是在目前的共同前綴中，那理所當然現在的 i 必會等於最初的共同前綴 i-x 值，</span></span><br><span class="line">    <span class="comment">// 如果不是，那必定會是 0。</span></span><br><span class="line">    <span class="comment">// y-i+1  此共同前綴理應只會有 y-i+1 個</span></span><br><span class="line">    <span class="comment">//如果 z[i-x] 比較小，代表沒有從 i 位置開始的前綴字串，否則 z[i-x] 應該要更大，所以</span></span><br><span class="line">    <span class="comment">//也就表示 z[i] == z[k]。</span></span><br><span class="line">    <span class="comment">// 如果 y-i+1 比較小，代表這次的共同前綴比較小，因為 z[i-x] 更大，也就代表應該有從這</span></span><br><span class="line">    <span class="comment">//裡開始的共同前綴</span></span><br><span class="line">    <span class="keyword">while</span>(i + z[i] &lt; s.length() &amp;&amp; s[z[i]] == s[i+z[i]] )&#123;</span><br><span class="line">        x = i ;</span><br><span class="line">        y = i + z[i] ;</span><br><span class="line">        z[i]++ ;</span><br><span class="line">        <span class="comment">//進行比對，查看 s[z[i]] 的位置是否等於 s[i+z[i]] 的位置是的話就比對下一個</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>這樣 Z-algorithm 就完成了！</p>
<h2 id="焦點回到題目上，解開題目的小設計"><a href="#焦點回到題目上，解開題目的小設計" class="headerlink" title="焦點回到題目上，解開題目的小設計"></a>焦點回到題目上，解開題目的小設計</h2><p>我們可以透過 Z-algorithm 找到「最長共同前綴總和 (Longest Common Prefix)」，但題目的要求字串後面也需要前綴呀，有可能共同最長前綴是 abcabcabc，但是這樣會是 6 呀，應該要是 abc、長度 3，才行的！</p>
<p>於是我們需要加一個 if 來找出 3，來防止我們的程式出現瑕疵，這裡用程式碼來解釋會更好解釋，逆向思考有時候會比普通的思考方式來的更好。我們一樣根據每一行程式碼進行說明。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; s.length() ; i++)</span><br><span class="line">    <span class="keyword">if</span>(z[i] == s.length() - i &amp;&amp; maxn &gt;= s.length()-i )&#123;</span><br><span class="line">    <span class="comment">// z[i] == s.length() - i -&gt; 如果 z[i] 等於字串剩下的長度那保證會有</span></span><br><span class="line">    <span class="comment">//後綴，通常 i 都會接近 s.length() 時才會符合</span></span><br><span class="line">    <span class="comment">// maxn &gt;= s.length()-i -&gt; 再從 0 to s.length() 時勢必會找到並經過</span></span><br><span class="line">    <span class="comment">//「最長共同前綴總和 (Longest Common Prefix)」，只要他比後綴還要長或相等 </span></span><br><span class="line">    <span class="comment">//(還需要先滿足第一個條件，才能判斷到此條件)，就肯定代表中間已經也有經</span></span><br><span class="line">    <span class="comment">//過「最長共同前綴總和 (Longest Common Prefix)」，尾巴這個並不會是第一次經過，</span></span><br><span class="line">    <span class="comment">//如果尾巴是那就代表他只有兩次的共同前綴。</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; s.substr(<span class="number">0</span>,z[i]); <span class="comment">// 輸出答案</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    maxn = max(maxn , z[i]);</span><br><span class="line">    <span class="comment">//經過時更新 「最長共同前綴總和 (Longest Common Prefix)」</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://wangwilly.github.io/willywangkaa/2018/03/19/Algorithm-Z-%E6%BC%94%E7%AE%97%E6%B3%95/" target="_blank" rel="noopener">Algorithm - Z 演算法</a><br><a href="https://personal.utdallas.edu/~besp/demo/John2010/z-algorithm.htm" target="_blank" rel="noopener">Z Algorithm</a><br><a href="https://codeforces.com/blog/entry/3107" target="_blank" rel="noopener">Z Algorithm_codeforces</a><br><a href="https://blog.csdn.net/weixin_30362801/article/details/101855543" target="_blank" rel="noopener">Codeforces 126B Password（Z算法）</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>老實講，這題學習很快www，<del>廢話，程式碼很少呀</del>，但撰寫文章倒是花了很多時間，補了許多學習時沒有注意到的漏洞。此演算法寫起來十分簡單，但它裡面蘊藏著許多小細節，我花了很多時間去整理。沒想到快要跟學「點分治」的時間快要一樣久了，看來我的學習能力還挺不好，還需要多加強了 QAQ</p>
<p>不過也要感謝網路上已經有許多優秀的人放了教學文章在上面可以讓我學習與思考，要是沒有他們我應該也沒辦法順利推出來這些想法，還是習慣用紙筆去理解一次演算法，雖然很花時間，但印象深刻。<del>RAM 太少常常忘記自己迴圈是做到第幾次，然後就一直鬼打牆</del></p>
<p>不過也對自己表示一點小失望，學習能力有點偏差呀！好希望自己的頭腦可以再清楚一點，能夠可以讀懂優秀大神寫的演算法，而不是每次都要花上 5,6 個小時來理解，在撞牆期中常常會覺得自己很沒用呀。</p>
<p><strong>那怕是一點點的進步也好，都可以給在學習路上的我很大的自信。</strong></p>
<p>雖然每次在學習演算法總是會讓我覺得難過，因為是自學很容易遇到學習障礙，但我認為這是我應該要學會的基礎。我並不是幸運的孩子，我勢必要先做出一些成果，讓資源跟大神可以關注到我，在提拔我或幫助我成長。在還沒有大神們關注到我之前，我會默默耕耘，繼續努力的！</p>
<p>為了讓讀者與未來的我看到之前的我學習是怎麼學習的，我就在這邊放入我為了學習這份演算法而在紙上實作的紀錄吧！</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>其實就是沒有附上說明的程式碼，我也花了三個小時撰寫文章，看得懂跟說得出來真的是兩回事，<del>也許還有人覺得我說的很差</del>，不過我已經盡力解釋拉。希望可以幫助到各位。</p>
<p>於是這裡就補述一些題目給的資料範圍限制與標頭檔了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1000020</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> z[MAXN] = &#123;&#125; ;</span><br><span class="line"><span class="keyword">int</span> x=<span class="number">0</span> , y=<span class="number">0</span> , maxn = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">string</span> s ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; s.length() ; i++ )&#123;</span><br><span class="line">        z[i] = max(<span class="number">0</span>,min(z[i-x] , y - i + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">while</span>(i + z[i] &lt; s.length() &amp;&amp; s[z[i]] == s[i+z[i]] )&#123;</span><br><span class="line">            x = i ;</span><br><span class="line">            y = i + z[i] ;</span><br><span class="line">            z[i]++ ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; s.length() ; i++)</span><br><span class="line">        <span class="keyword">if</span>(z[i] == s.length() - i &amp;&amp; maxn &gt;= s.length()-i )&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; s.substr(<span class="number">0</span>,z[i]);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        maxn = max(maxn , z[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Just a legend"</span> ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Codeforces</category>
        <category>演算法知識</category>
      </categories>
      <tags>
        <tag>程式解題</tag>
        <tag>Codeforces Round .#666 (Div. 2)</tag>
        <tag>Z-algorithm</tag>
        <tag>字串處理</tag>
        <tag>演算法知識</tag>
      </tags>
  </entry>
  <entry>
    <title>統計學(一) 筆記 - 初次介紹</title>
    <url>/2020/09/16/NTUT_note/statistics-begin/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊與財金管理系大二上統計學重點整理<br><font color="#dd0000">並非所有人都適用，部分對我而言稍加容易的內容並不會寫在此內。</font></p>
</blockquote>
<a id="more"></a>

<h2 id="Bloomberg"><a href="#Bloomberg" class="headerlink" title="Bloomberg"></a>Bloomberg</h2><h3 id="QUESTION-and-SOLUTION"><a href="#QUESTION-and-SOLUTION" class="headerlink" title="QUESTION and SOLUTION"></a>QUESTION and SOLUTION</h3><blockquote>
<p>Bloomberg 如何利用資料</p>
</blockquote>
<ul>
<li>分析股市</li>
<li>觀察使用者消費習慣</li>
<li>程式設計</li>
<li>行業系類資訊</li>
</ul>
<blockquote>
<p>這些資料可以帶來甚麼價值</p>
</blockquote>
<ul>
<li>平台隨時更新資訊</li>
<li>透明的資訊來源</li>
<li>幫客戶降低風險</li>
<li>投資決策</li>
</ul>
<blockquote>
<p>除了影片所述，Bloomberg 還可以如何進一步使用資料</p>
</blockquote>
<ul>
<li>預測未來經濟走勢</li>
<li>賣資料給其他需要客戶</li>
<li>預測股市趨勢</li>
</ul>
<h2 id="QUESTION-SET"><a href="#QUESTION-SET" class="headerlink" title="QUESTION SET"></a>QUESTION SET</h2><h3 id="甚麼是統計？"><a href="#甚麼是統計？" class="headerlink" title="甚麼是統計？"></a>甚麼是統計？</h3><p>透過數值表達，蒐集、分析、表現並解釋結果。</p>
<h3 id="找一份統計分析資料"><a href="#找一份統計分析資料" class="headerlink" title="找一份統計分析資料"></a>找一份統計分析資料</h3><p>手機電量，長條圖</p>
<h3 id="統計在商業與經濟的應用"><a href="#統計在商業與經濟的應用" class="headerlink" title="統計在商業與經濟的應用"></a>統計在商業與經濟的應用</h3><ul>
<li>會計<ul>
<li>本益比</li>
</ul>
</li>
<li>經濟<ul>
<li>就業</li>
<li>GDP</li>
</ul>
</li>
<li>金融<ul>
<li>股票</li>
<li>投資分析</li>
</ul>
</li>
<li>行銷<ul>
<li>同業資訊</li>
<li>通路</li>
<li>廣告</li>
<li>消費者喜愛</li>
</ul>
</li>
<li>產品<ul>
<li>產能</li>
<li>良率 </li>
</ul>
</li>
<li>資訊系統<ul>
<li>資料庫</li>
</ul>
</li>
<li><a href="https://tradingvalley.com" target="_blank" rel="noopener"><strong>機器人理財</strong></a><br>詢問妳問題，之後給你最好的組合。</li>
</ul>
<h3 id="DataSet-名詞介紹"><a href="#DataSet-名詞介紹" class="headerlink" title="DataSet 名詞介紹"></a>DataSet 名詞介紹</h3><ul>
<li>Elements 單位名稱，如:公司名稱</li>
<li>Variables  想查看的變數，如:公司盈餘<ul>
<li>變數歸類，如：「種類」、「數字」、「有無」</li>
</ul>
</li>
<li>Observations 單筆元素的變數資料</li>
<li>DataSet 全部元素的變數資料，不包含 Elements and Variables</li>
</ul>
<h3 id="Scales-of-Measurement-衡量此度-必考"><a href="#Scales-of-Measurement-衡量此度-必考" class="headerlink" title="Scales of Measurement 衡量此度 *必考 "></a><strong><font color="#dd0000">Scales of Measurement 衡量此度 *必考 </font></strong></h3><ul>
<li>Nominal 名目尺度，歸類用。<br>  只能計算次數，不能做其他使用。</li>
<li>Ordinal 順序尺度，歸類用<br>  只能知道相對程度。</li>
<li>Interval 等距尺度，可進行分析<br>  加減可以進行分析。</li>
<li>Ratio 等比尺度，可進行分析<br>  加減乘除都可以進行分析。</li>
</ul>
<h2 id="Time-Series-Data-時間序列"><a href="#Time-Series-Data-時間序列" class="headerlink" title="Time Series Data 時間序列"></a>Time Series Data 時間序列</h2><p>透過時間的變化做成的統計</p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>第一周的統計課就讓我覺得好難的感覺呀！我希望我能夠不被當，開學新希望XD。人生好難，讀書、比賽、工作都要兼顧，希望我能兼顧好 QwQ，統計的報告與測驗都能順利。</p>
]]></content>
      <categories>
        <category>北科上課筆記</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>統計學筆記</tag>
        <tag>北科大二上統計學筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>ERROR! Your local changes to the following files would be overwritten by merge</title>
    <url>/2020/09/25/git/git-error-local-changes-to-the-following-files-would-be-overwritten/</url>
    <content><![CDATA[<h2 id="文章大意："><a href="#文章大意：" class="headerlink" title="文章大意："></a>文章大意：</h2><blockquote>
<p>如果本地已經有修改資料，但遠端也同時也有修改過這份資料，我這邊要 <code>git pull</code> 則會遇到此問題的解決方式。</p>
</blockquote>
<a id="more"></a>

<h2 id="ERROR-Your-local-changes-to-the-following-files-would-be-overwritten-by-merge"><a href="#ERROR-Your-local-changes-to-the-following-files-would-be-overwritten-by-merge" class="headerlink" title="ERROR! Your local changes to the following files would be overwritten by merge"></a>ERROR! Your local changes to the following files would be overwritten by merge</h2><p>在 <code>git pull</code> 時遇到一個 ERROR 關於上方標題所述，要怎麼解決？</p>
<h3 id="situlation-A-放棄本地修改程式碼直接將伺服器程式碼抓下來"><a href="#situlation-A-放棄本地修改程式碼直接將伺服器程式碼抓下來" class="headerlink" title="situlation A - 放棄本地修改程式碼直接將伺服器程式碼抓下來:"></a>situlation A - 放棄本地修改程式碼直接將伺服器程式碼抓下來:</h3><p>那我們則是輸入指令直接退回到伺服器的版本，之後再重新 pull。我個人猜測當我們在修改的時候就已經脫離了伺服器的版本，git 會視為我們已經修改可能還會想要 <code>git push</code>，所以才不准我們 <code>git pull</code> 吧！</p>
<p>以下是所需要用到的指令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reset --hard</span><br><span class="line">git pull origin master</span><br><span class="line"></span><br><span class="line"># 其中 origin master 是 git 的分支</span><br></pre></td></tr></table></figure>

<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://www.itread01.com/content/1545046022.html" target="_blank" rel="noopener">git pull遇到錯誤：error: Your local changes to the following files would be overwritten by merge:解決方法</a></p>
<h2 id="心得："><a href="#心得：" class="headerlink" title="心得："></a>心得：</h2><p>git 真的好好用XD，但我是自學的基礎不穩，很多東西都是需要用到才會學，基礎不穩阿，要好好多讓自己嘗試找到缺失之處，然後補足。才可以讓自己獨當一面！</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>NCPC2020 109年度全國大專電腦軟體設計初賽 - 18th 心得</title>
    <url>/2020/09/27/contest_experence/ncpc2020_preliminary/</url>
    <content><![CDATA[<blockquote>
<p>僅此紀錄 2020/09/27 109年度全國大專電腦軟體設計初賽心得。<br>「紀錄每個時刻，讓未來的自己不遺忘過去的自己」<br>只有自己才能體會自己的過去<br>僅只有 18th，約 pr 40 ~ 50</p>
</blockquote>
<a id="more"></a>

<h2 id="賽前日誌"><a href="#賽前日誌" class="headerlink" title="賽前日誌"></a>賽前日誌</h2><p>當天我去我師大朋友(蘇子權) 的家吃消夜，突然想吃金鋒滷肉飯www，又想到好朋友家就在師大旁邊就想說過去那邊臨時聊天，敘敘舊聯幫感情升溫XD，互相加油打氣。順便改下 notebook。<del>結果還走錯地址，可惡。我到底還是不是台北人阿XD</del></p>
<blockquote>
<p>比賽前再等師大好朋友時拍的照片</p>
</blockquote>
<p><img src="/images/ncpc2020_preliminary/4.jpg" alt=""></p>
<p>這場比賽，我其實心情異常平靜。我也不太懂為甚麼會這樣..，開始對比賽麻痺了嗎？我想不是，而是因為一直都沒有好的成果，對自己沒有期待了嗎？</p>
<p>是個下雨天，我騎車前往師大，昨天在 109 模擬比賽把可不可紅茶弄倒在安全帽裡，果然今天帶安全帽很有可不可紅茶的味道呢wwww，將車停在古亭站準備前往與隊友會合，不過下雨天要整理那些雨具也是蠻麻煩的，好希望台北能夠少點下雨，或是在我出門的時候都不要下雨，可以嗎，天空(◍•ᴗ•◍)❤️ 。</p>
<p>之後在路上看到爭鮮想說還沒吃午餐，<del>抱歉，太晚起來了</del>，不然就簡單買兩個壽司來吃，恩..，玉子燒還不錯吃，但真的對冰冰的飯還是沒有那麼喜歡，之後就一路前往師大的路上，不過就算是下雨天，穿著雨衣走路還是蠻會流汗的，下次可以考慮脫掉放在機車上之類的。一個經驗，學起來了。</p>
<p>最後學長(陳風平) 願意給我機會吃飯，讓我買個便當。嗚嗚，好感謝，我不應該遲到的。</p>
<blockquote>
<p>比賽大樓的出口</p>
</blockquote>
<p><img src="/images/ncpc2020_preliminary/3.jpg" alt=""></p>
<h2 id="比賽當下"><a href="#比賽當下" class="headerlink" title="比賽當下"></a>比賽當下</h2><p>考試一開始時，我們將試題卷拿出來後，發現他竟然是雙面列印(差評，它讓我的迴紋針策略無法實現 QAQ，(迴紋針策略：把每題都用迴紋針收好，以防桌面雜亂要找題目不好找)，確實之後真的很常發生找不到題目試卷或是針對那題而做的筆記，希望下此主辦單位可以單面列印。<del>不要省紙，破壞我的策略</del></p>
<p>考試過程中想要透過印表機列印卻一直印不出來，詢問了主辦單位，主辦單位當下不太能夠解決。我們原本想選擇放棄，先不處理印表機的問題，但他們後來還「主動」詢問我們能不能夠使用印表機，好感動QQ。師大的人都好溫暖，北科這點可以再好點就更好了！之後好像換了「幾台印表機」後就成功可以用了，感謝師大，讚嘆師大。</p>
<p>解題的過程中，確實有一個策略還不賴，就是在封面寫每題的「標籤」，讓大家有興趣的人去選擇解題。我選擇的是我認為最簡單的 pF，但我的英文能力不好，當時為了解決格式問題，嘗試了 15 次的測試..，對不起我就爛。他的格式部分我搞很久…，拖到隊伍解題時間，真的蠻抱歉的，我個人認為在 11 月 ICPC 演算法台灣區決賽比完後，必須增加自己的英文能力。基礎不好真的很吃虧，希望我國高中當時能夠在努力點八。</p>
<p>後來 pF 格式的問題讓我的腦袋卡關，之後漢軒幫助我去解決格式上的問題，真的超級謝謝他的！要是沒有他我那個沒有用的小腦袋一定還想不出來，果然還是需要 #include&lt;別人的知識&gt;，會比自己一個人蠻幹還要更好。</p>
<p>學長則是選擇 pC 來解，一次就解對。佩服佩服，旁邊我師大朋友那隊還在賽後問我們學長怎麼解決的www，看來學長的策略跟想法還是略勝我一籌XD，還是是我英文能力太差導致我沒辦法發揮實力(?，不過我覺得我英文能力變好一定會幫助隊伍更多。不過看別人 Debug 心真的會緊張XD，好怕她抓不到 bug，為他捏把冷汗。</p>
<h2 id="比賽結果"><a href="#比賽結果" class="headerlink" title="比賽結果"></a>比賽結果</h2><p>其實比賽結果對我來說蠻意外的，竟然只有寫兩題還可以到 18 名(此比賽並沒有加入台清交)，雖然我覺得主要是我太浪費時間不然或許可以解到 3 題？假如學長對於 pE 的想法是正確的話，雖然有點爛拉，畢竟至少有一題正解的隊伍只有 34 隊，然後我們也只有解決兩題所以名次也相對沒有那麼好看。雖然覺得自己有點小沒價值，但我認為未來一定會有需要我的地方，只要在需要我的地方我能發揮能力並成功，那就是我的福氣了。</p>
<p>期望我未來可以有更好的表現，隊伍能夠發揮得更棒。</p>
<h2 id="賽後日誌"><a href="#賽後日誌" class="headerlink" title="賽後日誌"></a>賽後日誌</h2><p>賽後稍微去逛一下師大夜市，師大夜市還是跟以往一樣賣很多衣服www，可惡，我不太會穿搭。不然師大夜市就會是我的天堂了，我可能在那邊 1、2 個小時都不會走呢。不過比完賽後異常的累，回家就先睡了 3 個小時，看來我的體力不太好呢..。</p>
<p>不過在回來的路上，突然靈機一動想到一個點子，今天我到了這個學校，希望下次是這個學校要我。於是玩了一個鬼抓人，現在我抓到師大了！希望以後師大可以抓我回他們學校演講之類的嗎(?，我應該是沒有那麼優秀拉我，哈哈哈。</p>
<blockquote>
<p>抓！師大換你當鬼</p>
</blockquote>
<p><img src="/images/ncpc2020_preliminary/1.jpg" alt=""></p>
<h2 id="賽後檢討"><a href="#賽後檢討" class="headerlink" title="賽後檢討"></a>賽後檢討</h2><p>對於我參加這次比賽，我將針對幾點進行檢討：</p>
<ul>
<li>如果英文有問題，就直接問學長或學弟。不要浪費時間自己閱讀，會造成隊伍的時間損失。</li>
<li>別人在 Debug 不要一直緊張，不要想著要怎麼抓出他的 Bug，也許她被我看他 Debug 會緊張。</li>
<li>盡量可以做好比賽當下的文書處理工作，才不會時常導致自己想要某張紙卻找不到的狀況。</li>
</ul>
<h2 id="內心"><a href="#內心" class="headerlink" title="內心"></a>內心</h2><p><strong>希望我的未來能夠變得更好，與我的夥伴朋友共同努力。</strong></p>
<p>英文一定要學好，學長耳提面命的提醒我。我不能夠忘記，現在是大學了，你不會英文就算專業再優秀也有很高機率會被面試官心中減分，我為了要達到至少不再面試官心中扣分的機會，英文一定要學好。</p>
<p>　 </p>
]]></content>
      <categories>
        <category>競賽心得</category>
      </categories>
      <tags>
        <tag>大學Life</tag>
        <tag>ICPC</tag>
        <tag>程式比賽</tag>
        <tag>競賽心得</tag>
        <tag>人生旅途</tag>
      </tags>
  </entry>
  <entry>
    <title>與大學好朋友宜蘭三星三天行</title>
    <url>/2020/09/28/life_experence/Yilan_in_2020summer/</url>
    <content><![CDATA[<h2 id="說明"><a href="#說明" class="headerlink" title="說明"></a>說明</h2><blockquote>
<p>記錄我從 2020/08/24 ~ 2020/08/26 去宜蘭的旅行紀錄<br>謝謝在程式社團中認識的好朋友<br>它們在我的暑假增添了一段美好回憶</p>
</blockquote>
<a id="more"></a>

<h2 id="懺悔"><a href="#懺悔" class="headerlink" title="懺悔.."></a>懺悔..</h2><p>由於最近的事情太忙，上班與學習相提並重讓我時在沒有心情撰寫 Blog，回到家就想睡覺…，體力越來越不好了。</p>
<p>加上其實最近我的內心其實也不太穩定..，怎麼講呢，有點太喜歡一個女生，只要是那女生傳來的文字訊息我的神經都會放大 1000 倍，也因為這樣我常常會因為她的某封訊息開心或難過。這樣其實並不太好，我應該要能夠多關心自己而不是被情緒給操控。如果可以，我想寫一篇關於他的事。</p>
<p>如果有甚麼事情我忘記寫的，希望未來的我都能夠想起來，<strong>我不願意因為年紀的增長而失去了對於過去的記憶</strong>。</p>
<h2 id="出發前的準備"><a href="#出發前的準備" class="headerlink" title="出發前的準備"></a>出發前的準備</h2><p>其實這場宜蘭行籌畫了蠻久這裡蠻感謝胡紹宇的，他願意免費提供住宿(讚嘆他的爸媽)與行程規劃，讓我在忙碌的暑假中可以放心的學習工作與事業。</p>
<h2 id="8-月-24-日，大學第一次去宜蘭三星鄉玩"><a href="#8-月-24-日，大學第一次去宜蘭三星鄉玩" class="headerlink" title="8 月 24 日，大學第一次去宜蘭三星鄉玩"></a>8 月 24 日，大學第一次去宜蘭三星鄉玩</h2><h3 id="啟程"><a href="#啟程" class="headerlink" title="啟程"></a>啟程</h3><p>當天的 12 點我出發前往南港轉運站，原本是想要當捷運去的，但後來想想覺得捷運可能比火車還更浪費些時間。於是就想搭火車去南港火車站再轉車，確認好想法後我就從家中一路出發到萬華火車站，很不幸的是我找不到車位…，於是我把車停在離火車站稍遠的距離，特意拍了一張照片再去搭火車，以免我忘記我把我的機車放哪裡，把我的機車搞丟wwww。</p>
<blockquote>
<p>要去宜蘭前國小被朋友看到的我</p>
</blockquote>
<p><img src="/images/Yilan_in_2020summer/1.png" alt=""></p>
<p>到了南港火車站後，我前往南港轉運站。老實講蠻近的，但我覺得他的道路規劃路線沒有很好啊..，迷路了一陣子，甚至還走到了被封閉的出口..，如果因為新冠肺炎的關係而把路口封閉的話，至少也要在路標上面說路口被封閉呀！</p>
<blockquote>
<p>在南港轉運站等待時的照片</p>
</blockquote>
<p><img src="/images/Yilan_in_2020summer/2.jpg" alt=""></p>
<p>上了公車，朋友們跟我說從台北到宜蘭只需要約 1 小時的行程，一開始真的還挺不相信的，但經歷過後才知道原來台北到宜蘭真的這麼快！<del>怪不得被別人稱台北後花園</del>，但我在前往宜蘭的路上我卻還在忙工作的案子，工作的資料沒有用完阿阿阿阿，根本不敢放心玩，就在車上忙碌地進行我的工作，而朋友們大多都在睡覺或玩手機，讓我覺得自己好像社畜阿QwQ，不過工作能讓我學到東西，就不太會讓我對工作感到反感，也謝謝這份工作可以讓我學習到很多知識。</p>
<p>中午去了一趟寶雅買泳衣，這是我人生第一次去寶雅，寶雅有點類似於大潤發的感覺，不過主打女性市場，它讓我覺得一定會有很多小女生會在這裡逛至少兩、三個小時的錯覺阿，我在挑泳衣時一直被嫌棄胖QQQ，我很抱歉我說我要減肥到現在都還是沒有瘦下來，一定是我太幸福了才會一直都沒有瘦下來呢(內心:並沒有大衞，你每天晚上都在哭自己不好)</p>
<blockquote>
<p>在寶雅戴上奇怪帽子的我</p>
</blockquote>
<p><img src="/images/Yilan_in_2020summer/4.png" alt=""></p>
<p>到了宜蘭後去租了一輛機車(GP125)，還是沒想到租一輛機車非常便宜阿！很不賴呢，一台機車兩天只要 700 元，讓我對宜蘭的好感度大增(◍•ᴗ•◍)❤️，車況也還蠻不賴，基本上都沒什麼大問題，只是我對於股煞還是不太能諒解www，我已經習慣碟煞的感覺臨時操控股煞的車還真不習慣呢！對了，安全帽是西瓜皮ಥ⌣ಥ，不太行阿，當我騎車將近約 60km/h 時我只能聽得到風聲了，這點到可以再改進，可以的話給大家 3/4 安全帽可能會讓大家的頭部比較有安全感XD。</p>
<h3 id="夜晚"><a href="#夜晚" class="headerlink" title="夜晚"></a>夜晚</h3><p>晚餐我們去羅東夜市覓食，羅東夜市其實蠻多蠻好吃的。可惜胃只有一個不然好像都吃遍，大推羅東夜市門口前的花生捲冰淇淋，真的好好吃，<del>說不定只是我愛吃</del>。路上也蠻多好看的女生，好想認識(誤，要是這篇給我未來的女朋友看到應該會被討厭死吧XD，夜晚的羅東夜市人越多也越擁擠，其實不一定只有台北才會熱熱鬧鬧，很多地方也會。也算是讓我開開眼界吧！</p>
<p>把肚子填飽以後一行人就慢慢騎車前往了三星，不得不說朋友的民宿真的很棒呢，聽說內部裝潢都是他媽媽一手包辦，女…女中豪傑呀！由於那房間是 4 人房，我們一行人有 5 人，必須要有一人去睡沙發，在經過一翻廝殺(剪刀石頭布)後，我竟然是最輸的只能睡沙發ಥ⌣ಥ，好難過…。</p>
<blockquote>
<p>民宿內部裝潢在一二樓的樓梯轉角處</p>
</blockquote>
<p><img src="/images/Yilan_in_2020summer/2.jpg" alt=""></p>
<blockquote>
<p>可愛的貓貓湯匙</p>
</blockquote>
<p><img src="/images/Yilan_in_2020summer/5.jpg" alt=""></p>
<p>隨後進行洗澡環節，洗澡真的好舒服，我最喜歡洗澡了XD。朋友們出去買點消夜，另一朋友(張洸銘)則在房間裡面打LOL，喂不行啊，都來民宿了還來打LOL，太浪費了拉，就算你是宜蘭人也不能這樣子啦。隨後大家則在民宿裏面看 netflex，我也跟女生稍微打了通電話聯絡聯絡感情，配上宜蘭三星夜晚的民宿，真能夠使人放鬆。</p>
<blockquote>
<p>夜晚的民宿夜景</p>
</blockquote>
<p><img src="/images/Yilan_in_2020summer/6.jpg" alt=""></p>
<h2 id="8-月-25-日令人快樂的三星"><a href="#8-月-25-日令人快樂的三星" class="headerlink" title="8 月 25 日令人快樂的三星"></a>8 月 25 日令人快樂的三星</h2><h3 id="三星的早上讓人心曠神怡"><a href="#三星的早上讓人心曠神怡" class="headerlink" title="三星的早上讓人心曠神怡"></a>三星的早上讓人心曠神怡</h3><p>本前天晚上我想要去看日出的，但沒想到我卻睡過頭，天阿。太浪費了吧大衛，要去睡覺就回去台北睡阿(捏自己的臉頰，之後與紹宇騎著機車在三星的河邊跑動，三星的河邊很美，比起台北多了輕鬆慢活的步調，少了都市壅擠特意使河邊綠意盎然的感覺，可以感覺得出來那種幸福的美，在河邊稍微戲水，去了趟三星市場買個傳統甜點(草仔粿)，老闆人也很熱情挺不賴的。路上也看到專門給情侶掛愛情鎖的地方，我也好想掛的愛情鎖阿…。</p>
<h3 id="泛舟之旅"><a href="#泛舟之旅" class="headerlink" title="泛舟之旅"></a>泛舟之旅</h3><p>接近中午時紹宇叫大家起床準備前往泛舟，泛舟要先穿他們的救生衣與鞋子和安全帽，鞋子要避免大家被底下的石頭刮傷，一開始先給我們一些簡單的救生呼籲。似乎今天有一高中生們班游他們看起來好漂亮啊..，我明明才畢業一年為甚麼就覺得我自己老的跟甚麼一樣…，應該是自己的高中沒有像他們一樣青春吧XD，明明讀台北的高中卻沒有像苗栗的高中一樣青春阿，有點小可惜呢！</p>
<p>教練也蠻有趣的，不愧是有在運動的人，我都認為擅長運動的人看起來比較陽光也比較幽默，也許是我的錯覺吧，但我真的有這種感覺。可惜我好像沒辦法是這種人呢。我可能還是比較適合在這邊打打文章學些科技來讓自己混一口飯被社會滋潤再回去給社會付出的人。</p>
<p>聽完救生須知後，我們一行人搭著遊覽車前往高處，也是泛舟的起點，它讓我們走在河邊，老實講走在河邊真的挺舒服的，因為我喜歡水，只要能夠與水親近我都不會討厭，下雨的除外，水量太少。隨後我們走到了泛舟起點跳下水中享受被水推動的感覺好舒服呀，被水推動可以讓我的內心完全放鬆享受在自然生活之中即使明知道這些都是靠著工人們辛辛苦苦堆建而成我也能夠放鬆，我可能內心還有點不夠體貼別人呢XD。</p>
<p>隨著水推動也即將到了中繼點，要準備搭船泛舟了，我們與一小家庭一同泛舟，由於我最重被大家要求移到最前面QAQ，不要逼我喔，再這樣下去我真的會減肥喔..。泛舟的過程都配上一教練，那教練負責移動橡皮的方向，<del>負責去撞其他橡皮艇</del>，一路上我們「被」跌跌撞撞蠻刺激的，晃來晃去比起搭船的海浪又更刺激了些，加上可以拿船槳去潑別人蠻好玩的！雖然我一開始不太敢潑水，但隨著被別人潑後就慢慢地放開了！雖然之後被收走了QAQ。</p>
<blockquote>
<p>在中繼點拍照時的我們</p>
</blockquote>
<p><img src="/images/Yilan_in_2020summer/7.jpg" alt=""></p>
<p>因為當天的水量太少，到了下流時泛舟其實就很平穩沒有甚麼激烈的搖晃，甚至還卡在石頭上，嗚嗚，對於宜蘭三星來說，如果下的雨太少真的會讓很多人的工作不好做也容易失業阿..，之後到了第三個中繼點可以讓我們選擇要不要讓橡皮艇翻船，我一定是選擇要的啊！但其實跟我們同行的小家庭似乎沒有那麼想要，但在我的內心渴望下他們還是答應了XD，對不起啦。</p>
<p>翻船時教練告訴我們很多規則，也告訴我們突發狀況時我們應該要怎麼辦，好讓我們在遇到危險時，給予我們安全感，讓我們怎麼應對。他讓重的人都做一邊後就直接翻船了！我似乎有撞到一個人，頭有點小暈眩，然後我還被關在橡皮艇裏面QAQ，剛好翻船的時候，可能因為我太重所以水的衝擊力沒辦法把我衝遠，剛好橡皮艇翻船的距離足夠讓我在被翻船的裏面，我就被橡皮艇壓著根本出不來，我當時害怕極了ಥ⌣ಥ，一直想要站穩但卻一直被橡皮艇衝撞頭都快要暈眩了QQ，之後聽到教練說一聲可以起來了，讓我求生意志大增，直接把頭往水裏面縮，讓橡皮艇流過我，大衛智慧+1，開心！雖然起來的時候有點狼狽…。</p>
<blockquote>
<p>翻船前的遺照</p>
</blockquote>
<p><img src="/images/Yilan_in_2020summer/8.jpg" alt=""></p>
<p>但小家庭的爸爸可就沒有那麼幸運了，他似乎在翻船時被我撞到後因為是老人家，骨頭不太好，鼻子流了點鼻血，他的老婆似乎有些許緊張，幸好在包紮後有讓他的鼻子變好。不過當下我並不覺得是我撞到他，因為我沒有那個感覺，但後來根據邏輯與常理看看應該有百分之80% 是我撞到他，當時沒有跟他道歉還蠻感到抱歉的，希望下次可以有機會跟他道歉，請他吃點東西能夠當作補償那是再幸運不過的事了。</p>
<blockquote>
<p>翻船後 QwQ</p>
</blockquote>
<p><img src="/images/Yilan_in_2020summer/9.jpg" alt=""></p>
<p>翻船後上岸，跟著另外一個很幽默的教練走，那教練講話真的蠻好笑的，它讓我印象最深刻的話就是：「你踩石頭會痛，那你有想過石頭的感受嗎」，我覺得我講起來就沒有那麼好笑，我想應該是他的個人魅力使這句話好笑吧XD，抑或是那個當下講出這句話才讓人有開心的感覺吧，之後我們滑行約 100 公尺的滑水道，好好玩，還有一堆教練跟你擊掌XD，他讓我覺得泛舟的教練應該當下也是開心的吧！並不會覺得自己所做的只是「工作」。</p>
<p>由於水流不夠，我們沒辦法泛舟泛到終點，中途就必須給大卡車接送，被大卡車接送的感覺其實很不賴，涼涼的風吹過來，又有漂亮的風景可以觀看，讓我覺得活在宜蘭的孩子或許比台北在更幸福些。</p>
<p>回到終點後我們沖洗下身體，沖洗的時候有某些是只有冷水要特別小心！如果是冬天的話真的會冷死你喔..，不過也有可能冬天沖洗的水就會都是熱水了也說不定呢！在吃了我覺得超好吃的冰棒「蘭陽冰棒」，他應該是我覺得最美味的食物之一了吧，它讓我做好決定我一定還要買更多蘭陽冰棒來吃，超級大推。</p>
<h3 id="在三星的晚餐"><a href="#在三星的晚餐" class="headerlink" title="在三星的晚餐"></a>在三星的晚餐</h3><p>在三星時，我發現到他們的飲料全部都比北部的飲料少了「5元」！這讓我超級訝異也超級開心，這..這只能夠在 2年前的台北看到阿，好感動。我還不直接買爆XD，後來去了一間餐館吃飯，這是紹宇他很推薦的一家果真也沒有讓我失望，真的超級好吃。菜色我忘記了蠻多XD，對不起啦，時間過太久了菜名真的都忘了..，但他們的「阿嬤炒飯」可以嘗試，真的好吃，份量又多比起台北這邊貴貴的價格配上難民的份量，在宜蘭吃飯才真的有皇帝的感覺呢！</p>
<p>隨後買了些消夜，就準備打道回民宿，回民宿我向大家提議是不是該換床位了XD，這次大家願意包容我能夠讓我睡到高級床位真的好感動QQQ，我忘不了大家的，也對不起天佑，換你睡上了沙發..。當大家都洗澡完成後我們開始玩桌游，阿瓦隆好久沒有玩但還是沒什麼忘記呢，只是我原本想要把壞人的身分嫁禍給紹宇沒有嫁禍成功真的很可惜呢wwww，剛好因為她身分的特性而被識破。</p>
<p>晚點去了民宿的後院，後院很美、風景很漂亮。美到即使現在我還是沒辦法忘掉那景色，配上兩個鞦韆，真的很讚，佩服他爸媽的眼光，能夠選在此地蓋民宿，真的很不賴呢。</p>
<p>今晚，睡了一個好覺，很深很甜的美夢。</p>
<blockquote>
<p>當鞦韆的兩位朋友XD，共兩張</p>
</blockquote>
<p><img src="/images/Yilan_in_2020summer/15.jpg" alt=""><br><img src="/images/Yilan_in_2020summer/16.jpg" alt=""></p>
<blockquote>
<p>傍晚的民宿照片，太陽還在外面</p>
</blockquote>
<p><img src="/images/Yilan_in_2020summer/10.jpg" alt=""></p>
<blockquote>
<p>太陽剛下去的民宿照片</p>
</blockquote>
<p><img src="/images/Yilan_in_2020summer/11.jpg" alt=""></p>
<h2 id="8-月-26-日捨不得回去的宜蘭三星"><a href="#8-月-26-日捨不得回去的宜蘭三星" class="headerlink" title="8 月 26 日捨不得回去的宜蘭三星"></a>8 月 26 日捨不得回去的宜蘭三星</h2><p>由於昨天大家都累壞了一天，大家都睡到大約中午 12 點加上當天的天氣其實不太好一直有綿綿雨，不過我們其實蠻幸運的，幸好不是昨天下雨不然會讓我們的泛舟之旅增添一些陰影，由於我吵著要去吃蘭陽冰棒，於是我就特地騎車去探險，去蘭陽冰棒店買冰棒，我自己就吃了 6 隻，對不起過去的大衛，但是我真的需要那個很 cool 的東西..體重就先放一邊去吧XD，特別喜歡牛奶與米糕的味道，牛奶冰棒中牛奶的香氣配上葡萄乾，香氣與嚼勁都在而不容易使人吃膩，米糕冰棒中有許多米糕，<del>廢話</del>，嚼勁比起牛奶而更大推！重點價錢也很便宜，一隻才 15 元，它讓我越來越覺得我在台北的生活就是難民的感覺www，高物價少分量ಥ⌣ಥ。</p>
<blockquote>
<p>超級棒的蘭陽冰棒</p>
</blockquote>
<p><img src="/images/Yilan_in_2020summer/12.jpg" alt=""></p>
<p>下午則在民宿玩了些桌游，挺不賴的。而我則是吵著要去清水地熱谷探險XD，結果去的路上沒有去成(可惡，他們 5 點 30 就關門了，於是我就在附近繞一繞看看宜蘭的美景，其實宜蘭真的很漂亮不愧會被大家說是台北後花園，雖然很壞wwww。</p>
<blockquote>
<p>在騎車時隨手拍的照片，共兩張</p>
</blockquote>
<p><img src="/images/Yilan_in_2020summer/13.jpg" alt=""><br><img src="/images/Yilan_in_2020summer/14.jpg" alt=""></p>
<p>大約 7 點多，我們一行人陸續從民宿中出發到羅東車站的路上，騎車騎了蠻長一段距離，我都有點疲乏了，明明去三星的路上都沒有那麼累呀…。路上還遇到三寶！差點撞到我(哭，超級難過的，宜蘭的交通看起來還是跟台北差不多呢…，尤其我頭上戴西瓜皮，危機特別嚴重，廢話，西瓜皮安全帽被撞真的會死人欸，不適用交通規則都是生存規則。但一路上也是蠻克難的，兩台車塞四個行李www，還有一個笨蛋塞行李箱，抱歉拉就是我，哈哈哈。</p>
<p>搭上公車之後，稍微跟天佑聊了一下還蠻開心的，講講北科壞話XD，對不起啦北科，但我偶爾還是需要小抱怨一下，當客運抵達南港轉運站時卻沒有停下直接開走！我們一行人都驚訝，想說司機是不是忘記了QAQ，一群人都超緊張的！查了下原因才知道火車與客運不同，客運如果沒有按下車鈴的話他是會直接通過而不會留下，知道原因後的我們查這班客運的終點站是捷運圓山站，我們就乖乖坐著公車到捷運圓山站再從捷運圓山站搭捷運回家，但是因為捷運龍山寺站跟萬華火車站不在同個地方..，我走了大約快 15 分鐘才回到了停機車的地方，超累的QQ，拖著行李走路的累度比起一般走路還累 10 倍呀，幸好一路上有女生陪我加油打氣不然我可能真的會累倒在路上吧，之後也順利找到機車開開心心的回家了。</p>
<blockquote>
<p>台北俗，完全不知道有這種規則的我XD</p>
</blockquote>
<p><img src="/images/Yilan_in_2020summer/17.jpg" alt=""></p>
<blockquote>
<p>過站到已經可以看的到圓山大飯店了www</p>
</blockquote>
<p><img src="/images/Yilan_in_2020summer/18.jpg" alt=""></p>
<blockquote>
<p>順利看到車車的我，開心&gt;&lt;&gt;</p>
</blockquote>
<p><img src="/images/Yilan_in_2020summer/19.jpg" alt=""></p>
<h2 id="後來的我"><a href="#後來的我" class="headerlink" title="後來的我"></a>後來的我</h2><p>由於有了這份旅遊，它讓我的精神狀況比起過往好了許多，做事甚麼的也都很有效率！還蠻感謝紹宇願意帶我參加這份旅遊。回憶很美，但如果能夠透過文字紀錄讓未來的我在看到時能感到開心，就代表現在的我並沒有白活了！</p>
<p><strong>一路上經歷過的事情一變多，就常常會把許多回憶丟在路邊繼續往前走，當我走到這條路的終點時卻忘記自己到底過不過得開心快不快樂，自己活得這麼累的原因是甚麼。</strong></p>
]]></content>
      <categories>
        <category>人生旅途</category>
      </categories>
      <tags>
        <tag>大學Life</tag>
        <tag>人生旅途</tag>
      </tags>
  </entry>
  <entry>
    <title>統計學(一) 筆記 - 第二章A</title>
    <url>/2020/09/28/NTUT_note/statistics-ch2A/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊與財金管理系大二上統計學重點整理<br><font color="#dd0000">並非所有人都適用，部分對我而言稍加容易的內容並不會寫在此內。</font><br><strong>這是觀看影片心得後的筆記，老師上課可能不太適用會忘記抄到</strong></p>
</blockquote>
<a id="more"></a>

<h2 id="2A-介紹"><a href="#2A-介紹" class="headerlink" title="2A 介紹"></a>2A 介紹</h2><h3 id="類別型變數-Categorical-Data"><a href="#類別型變數-Categorical-Data" class="headerlink" title="類別型變數 Categorical Data"></a>類別型變數 Categorical Data</h3><p>類別型變數可以用符號、名稱來界定不同類別</p>
<h4 id="可呈現的表"><a href="#可呈現的表" class="headerlink" title="可呈現的表"></a>可呈現的表</h4><ul>
<li>次數分配</li>
<li>相對次數分配</li>
<li>百分比次數分配</li>
<li>長條圖</li>
<li>圓餅圖</li>
</ul>
<blockquote>
<p><img src="/images/statistics-ch2B/1.PNG" alt=""></p>
</blockquote>
<p>圖片當中</p>
<ul>
<li>\( \text{Relative Frequency} = \frac{\text{Frequency}}{\text{total Frequency}} \)</li>
<li><strong>Relative Frequency 總和一定會是1。</strong></li>
<li>\( \text{Percent Frequency} = \text{Relative Frequency} * 100 \)</li>
</ul>
<h4 id="Bar-Chart-長條圖"><a href="#Bar-Chart-長條圖" class="headerlink" title="Bar Chart 長條圖"></a>Bar Chart 長條圖</h4><p>他長這個樣子</p>
<blockquote>
<p><img src="/images/statistics-ch2A/1.PNG" alt=""></p>
</blockquote>
<ul>
<li>適合呈現 qualitative data(定值型資料)</li>
<li>通常 bar(長條) 都會是固定長度</li>
<li>每條 bar 必須要分開</li>
</ul>
<h4 id="Pareto-Chart-柏拉圖"><a href="#Pareto-Chart-柏拉圖" class="headerlink" title="Pareto Chart 柏拉圖"></a>Pareto Chart 柏拉圖</h4><p>一個長條圖配上百分比線，通常用在顯示產品品質管理。</p>
<h4 id="Pie-Chart-圓餅圖"><a href="#Pie-Chart-圓餅圖" class="headerlink" title="Pie Chart 圓餅圖"></a>Pie Chart 圓餅圖</h4><p>通常元素不可以太多，<strong>絕對</strong>不可以超過 10 個。</p>
<h3 id="數值型變數-Quantitative-Data"><a href="#數值型變數-Quantitative-Data" class="headerlink" title="數值型變數 Quantitative Data"></a>數值型變數 Quantitative Data</h3><h4 id="可呈現的表-1"><a href="#可呈現的表-1" class="headerlink" title="可呈現的表"></a>可呈現的表</h4><ul>
<li>次數分配</li>
<li>相對次數分配</li>
<li>百分比次數分配</li>
<li>點圖</li>
<li>直方圖</li>
<li>枝葉圖</li>
</ul>
<h4 id="Dot-Plot-點圖"><a href="#Dot-Plot-點圖" class="headerlink" title="Dot Plot 點圖"></a>Dot Plot 點圖</h4><p>一個點代表一筆資料，越多點代表越多資料。</p>
<blockquote>
<p><img src="/images/statistics-ch2A/2.PNG" alt=""></p>
</blockquote>
<h3 id="Frequency-Distribution-次數分配"><a href="#Frequency-Distribution-次數分配" class="headerlink" title="Frequency Distribution 次數分配"></a>Frequency Distribution 次數分配</h3><ul>
<li>決定類別、分類，分類不可以重疊還要包跨全部資料<ul>
<li>介於 5 到 20 組</li>
<li>每一組基本上都要有資料，並要看出分布，可能需要進行嘗試沒辦法一次到位。</li>
</ul>
</li>
<li>組距<ul>
<li>採用同樣寬度</li>
<li>寬度決定 = \( \frac{\text{最大值} - \text{最小值}}{組數}\)</li>
</ul>
</li>
<li>上下限<ul>
<li><strong>每一筆資料只能屬於某一組之間</strong></li>
<li>下限必須要涵蓋資料最小值，上限反之</li>
<li>通常最小或是最大可以是 *<em>open end *</em><br>open end 舉例：小於 x 值 or 大於 x 值</li>
</ul>
</li>
</ul>
<h3 id="資料頗析"><a href="#資料頗析" class="headerlink" title="資料頗析"></a>資料頗析</h3><p>我懶得打，直接看圖</p>
<blockquote>
<p><img src="/images/statistics-ch2A/3.PNG" alt=""></p>
</blockquote>
<h3 id="Histogram-直方圖"><a href="#Histogram-直方圖" class="headerlink" title="Histogram 直方圖"></a>Histogram 直方圖</h3><p>由於資料是數值並針對類別型資料，所以他們的 <strong>bar 必須黏在一起</strong></p>
<blockquote>
<p><img src="/images/statistics-ch2A/4.PNG" alt=""></p>
</blockquote>
<h4 id="Showing-Skewness-偏態"><a href="#Showing-Skewness-偏態" class="headerlink" title="Showing Skewness 偏態"></a>Showing Skewness 偏態</h4><p>通常只資料分布著重在某處。</p>
<ul>
<li>對稱 Symmetric<ul>
<li>資料對稱，舉例:身高分布</li>
</ul>
</li>
<li>左偏 Moderately Skewed Left<ul>
<li>資料左偏，舉例:分數</li>
</ul>
</li>
<li>右偏 Moderately Right Skewed <ul>
<li>資料右偏，舉例:房價</li>
</ul>
</li>
<li>Highly Skewed Right 右邊幾乎只有一點點<ul>
<li>資料極端左偏，舉例:管理階層薪水</li>
</ul>
</li>
</ul>
<h3 id="Stem-and-Leaf-Display"><a href="#Stem-and-Leaf-Display" class="headerlink" title="Stem-and-Leaf Display"></a>Stem-and-Leaf Display</h3><p>就長這樣</p>
<blockquote>
<p><img src="/images/statistics-ch2A/5.PNG" alt=""></p>
</blockquote>
<ul>
<li>會有排序與資料分布的型態</li>
<li>跟直方圖相似，但會呈現資料真正數值</li>
<li>葉子<ul>
<li>單位可調整</li>
<li>通常單位是 1，但可調整</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>北科上課筆記</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>統計學筆記</tag>
        <tag>北科大二上統計學筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>統計學(一) 筆記 - 第二章B</title>
    <url>/2020/09/20/NTUT_note/statistics-ch2B/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊與財金管理系大二上統計學重點整理<br><font color="#dd0000">並非所有人都適用，部分對我而言稍加容易的內容並不會寫在此內。</font><br><strong>這是觀看影片心得後的筆記，老師上課可能不太適用會忘記抄到</strong></p>
</blockquote>
<a id="more"></a>


<h2 id="2B-介紹"><a href="#2B-介紹" class="headerlink" title="2B 介紹"></a>2B 介紹</h2><p>著重在兩個變數關係。</p>
<h3 id="Crosstabulation-交叉表"><a href="#Crosstabulation-交叉表" class="headerlink" title="Crosstabulation 交叉表"></a>Crosstabulation 交叉表</h3><p>可以用交叉表來看兩個變數的關係。<br>不管是數值型資料或是類別型資料都可以用交叉表來表示。</p>
<h3 id="名詞解釋"><a href="#名詞解釋" class="headerlink" title="名詞解釋"></a>名詞解釋</h3><p>aggregated crosstabulation 已彙整的表<br>simpsons’s Paradox 辛普森悖論<br>aggregated 收集<br>Scatter Diagram and Trendline 散佈圖</p>
<h3 id="simpsons’s-Paradox-辛普森悖論"><a href="#simpsons’s-Paradox-辛普森悖論" class="headerlink" title="simpsons’s Paradox 辛普森悖論"></a>simpsons’s Paradox 辛普森悖論</h3><p>在分組比較中都佔優勢的一方，在總評(全部一起考量)有時會是劣勢的一方。<br>為了避免此勃論則需要斟酌各分組權重，並乘以一定係數消除分組數據差造成的影響</p>
<h3 id="Scatter-Diagram-and-Trendline-散佈圖"><a href="#Scatter-Diagram-and-Trendline-散佈圖" class="headerlink" title="Scatter Diagram and Trendline 散佈圖"></a>Scatter Diagram and Trendline 散佈圖</h3><blockquote>
<p><strong>散佈圖的 x,y 都必須是數值變數</strong><br>假如 x 變動很大但趨勢線卻沒有變動表示 x 與 y 沒有甚麼關係。如下圖：<br><img src="/images/statistics-ch2B/2.PNG" alt=""></p>
</blockquote>
<h3 id="Side-by-Side-Bar-Chart-長條圖"><a href="#Side-by-Side-Bar-Chart-長條圖" class="headerlink" title="Side-by-Side Bar Chart 長條圖"></a>Side-by-Side Bar Chart 長條圖</h3><p>可同時比較很多 Elements </p>
<h4 id="Stacked-Bar-Chart-堆疊長條圖"><a href="#Stacked-Bar-Chart-堆疊長條圖" class="headerlink" title="Stacked Bar Chart 堆疊長條圖"></a>Stacked Bar Chart 堆疊長條圖</h4><blockquote>
<p>將要比較的變數全部堆疊在一起，所以長度都會達到 100%，如下圖：<br>通常是要查看同個 elements 的 variables 誰比較高</p>
</blockquote>
<p><img src="/images/statistics-ch2B/3.PNG" alt=""></p>
<h3 id="Data-Visualization-資料視覺化"><a href="#Data-Visualization-資料視覺化" class="headerlink" title="Data Visualization 資料視覺化"></a>Data Visualization 資料視覺化</h3><ul>
<li>明確標題</li>
<li>簡潔表單</li>
<li>清楚標示 x,y 軸</li>
<li>顏色要明確，不可過度模糊。假如是黑白報表的話，建議使用符號來表示</li>
</ul>
<h3 id="建議圖表"><a href="#建議圖表" class="headerlink" title="建議圖表"></a>建議圖表</h3><h4 id="QEUSTION-想要兩個變數之間比較"><a href="#QEUSTION-想要兩個變數之間比較" class="headerlink" title="QEUSTION: 想要兩個變數之間比較"></a>QEUSTION: 想要兩個變數之間比較</h4><p>Side-by-Side Bar Chart or Stacked Bar Chart </p>
<h4 id="QEUSTION-想要看兩個變數之間的關係"><a href="#QEUSTION-想要看兩個變數之間的關係" class="headerlink" title="QEUSTION: 想要看兩個變數之間的關係"></a>QEUSTION: 想要看兩個變數之間的關係</h4><h5 id="solution-A-Scatter-Diagram-散佈圖"><a href="#solution-A-Scatter-Diagram-散佈圖" class="headerlink" title="solution A: Scatter Diagram 散佈圖"></a>solution A: Scatter Diagram 散佈圖</h5><p>但請記住，變數只能是數值變數</p>
<h5 id="solution-B-Trendline-趨勢線"><a href="#solution-B-Trendline-趨勢線" class="headerlink" title="solution B: Trendline 趨勢線"></a>solution B: Trendline 趨勢線</h5><p>來看在散佈圖上面的關聯行如何</p>
<h3 id="Data-Dashboards-資料儀表板"><a href="#Data-Dashboards-資料儀表板" class="headerlink" title="Data Dashboards 資料儀表板"></a>Data Dashboards 資料儀表板</h3><p>通常查看 KPI(關鍵績效指標)，能讓使用者方便閱讀了解。</p>
<h4 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h4><ul>
<li>盡量讓圖不要下拉或上移，可以完整呈現</li>
<li>減少不必要的視覺效果</li>
<li>圖要有明顯邊界<br>如下圖：<br><img src="/images/statistics-ch2B/4.PNG" alt=""></li>
</ul>
]]></content>
      <categories>
        <category>北科上課筆記</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>統計學筆記</tag>
        <tag>北科大二上統計學筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa11475 - Extend to Palindrome (KMP algorithm 詳解)</title>
    <url>/2020/10/03/UVa/UVa11475/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p><strong>給你一字串，請新增字元讓這字串變成迴文，但新增字元數量要最少。</strong><br>迴文：從左邊讀與從右邊讀意思都一樣<br>題目善意提示：這題不要給經驗不足的新手做 ^^</p>
</blockquote>
<a id="more"></a>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>這題是 KMP (Knuth-Morris-Pratt’s) Algorithm 的小變化題，先介紹 KMP algorithm。</p>
<blockquote>
<p>專門解決在線性時間中在一段文字 (text) 中找到我們所需要的段落 (pattern)<br>與此類似的演算法: <a href="https://theriseofdavid.github.io/2020/09/18/Codeforces/Codeforces%20126B/" target="_blank" rel="noopener">Z-algorithm</a><br>由於此題是 KMP algorithm 的模板題，只要能夠了解 KMP algorithm 就能解決此問題。<br>這題為教學題，但此問題還有一點點的小設計，需要稍加解釋才能完全理解。</p>
</blockquote>
<h2 id="KMP-algorithm-介紹"><a href="#KMP-algorithm-介紹" class="headerlink" title="KMP algorithm 介紹"></a>KMP algorithm 介紹</h2><blockquote>
<p>在線性時間內找出段落(Pattern) 在文字(text) 中哪裡出現過。<br>對 Pattern 找出<strong>次長相同前綴後綴</strong>，在使用 DP 將時間複雜度壓縮</p>
</blockquote>
<h3 id="QUESTION-1-Pattern-and-text-是甚麼意思"><a href="#QUESTION-1-Pattern-and-text-是甚麼意思" class="headerlink" title="QUESTION 1: Pattern and text 是甚麼意思"></a>QUESTION 1: Pattern and text 是甚麼意思</h3><p>如果用平常使用者較為了解的方式說明，就像是你在網頁搜尋(使用 <strong>ctrl + F</strong>) 某個特定文字時，某個特地文字就是 Pattern 而被搜尋的文字則是 text。</p>
<h3 id="QUESTION-2-此演算法的時間複雜度"><a href="#QUESTION-2-此演算法的時間複雜度" class="headerlink" title="QUESTION 2: 此演算法的時間複雜度"></a>QUESTION 2: 此演算法的時間複雜度</h3><p>複雜度 \(O(\text{text} + \text{pattern})\)</p>
<h2 id="KMP-algorithm-原理"><a href="#KMP-algorithm-原理" class="headerlink" title="KMP algorithm 原理"></a>KMP algorithm 原理</h2><p>在實現 KMP algorithm 前，必須要先對 Pattern 找出<strong>次長相同前綴</strong>，通常被稱為 KMP_process()，並透過一陣列紀錄，再根據文字去比對，如果在迴圈當下字元比對不正確時則回到 DP 當下 index 的 Value 去比對，確認現在的值是否為也是 Pattern 中的某部分。</p>
<h2 id="KMP-algorithm-實現與說明"><a href="#KMP-algorithm-實現與說明" class="headerlink" title="KMP algorithm 實現與說明"></a>KMP algorithm 實現與說明</h2><p>由於我認為在程式碼中加上好懂得註解十分好懂，所以我就根據每一行程式碼進行說明，相信會讓讀者更好學會此演算法。<br>如果對下方說明還是不了解，可以點擊此<a href="https://www.youtube.com/watch?v=V5-7GzOfADQ&ab_channel=AbdulBari" target="_blank" rel="noopener">Abdul Bari 所教導的 KMP algorithm </a>觀看影片，他會跟你說嗨喔！也許能夠讓你更了解 KMP algorithm 運作，<del>或許是我解釋不好</del>。</p>
<p>KMP 演算法主要由 kmp_process 與 kmp_search 這兩個 function 而成，讀者只要能看懂此兩 function 應該就能夠學會 KMP 的 80%。</p>
<h3 id="kmp-process"><a href="#kmp-process" class="headerlink" title="kmp_process"></a>kmp_process</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span>  strB ;</span><br><span class="line"><span class="keyword">int</span> b[MAXN] ;</span><br><span class="line"><span class="comment">// b[] value 表示 strB當下此字元上次前綴的 index，如果已經沒有前綴則設定 -1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kmp_process</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = strB.length() ,i = <span class="number">0</span> ,  j = <span class="number">-1</span> ;</span><br><span class="line">    <span class="comment">// j = 前綴的長度</span></span><br><span class="line">    <span class="comment">//strB 是 pattern , j = -1 時代表沒有辦法再回推到前一個次長相同前綴</span></span><br><span class="line">    b[<span class="number">0</span>] = <span class="number">-1</span> ;</span><br><span class="line">    <span class="comment">// 由於 strB[0] 絕對沒有前綴所以設定 -1 </span></span><br><span class="line">    <span class="keyword">while</span>(i &lt; n )&#123; <span class="comment">//對從 Pattern 的第 0 個字元到第 i 字元找出次長相同前綴</span></span><br><span class="line">        <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; strB[i] != strB[j]) j = b[j] ;</span><br><span class="line">        <span class="comment">// j &gt;= 0 代表還可以有機會找出 次長相同前綴</span></span><br><span class="line">        <span class="comment">// strB[i] != strB[j] 則代表他們字元不同，於是在這裡把 j 值設為 b[j]</span></span><br><span class="line">        <span class="comment">// 當 j 只要被設定成 -1 就代表完全沒有次長相同前綴</span></span><br><span class="line">        i++ ; j++ ;</span><br><span class="line">        b[i] = j ;</span><br><span class="line">        <span class="comment">// strB[i] 上次前綴的 index 值或是將 j 設定成 0 而不設定成 -1 是因為</span></span><br><span class="line">        <span class="comment">// 他有可能會是 strB[0] 長度只有 1 的前綴</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//debug 供應測試用</span></span><br><span class="line">    <span class="comment">//    for(int k = 0 ; k &lt;= n ; k++)</span></span><br><span class="line">    <span class="comment">//        cout &lt;&lt; b[k] &lt;&lt; ' ' ;</span></span><br><span class="line">    <span class="comment">//    cout &lt;&lt; '\n' ;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>這樣 kmp_process 就完成了！</p>
<h3 id="kmp"><a href="#kmp" class="headerlink" title="kmp"></a>kmp</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> strA ;</span><br><span class="line"><span class="comment">//strA 是 text</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kmp_search</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = strA.length() , m=strB.length() , i=<span class="number">0</span> , j=<span class="number">0</span>  ;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; n )&#123; <span class="comment">//對從 text 找出搜尋哪裡符合 Pattern </span></span><br><span class="line">        <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; strA[i] != strB[j]) j = b[j] ;</span><br><span class="line">        <span class="comment">// j &gt;= 0  代表還可以有機會是 pattern 的前綴</span></span><br><span class="line">        <span class="comment">// strA[i] != strB[j]  則代表他們字元不同，於是在這裡把 j 改為 b[j]</span></span><br><span class="line">        <span class="comment">// b[j] 說明請看 kmp_process 宣告 b[j] 時的解釋</span></span><br><span class="line">        i++ ; j++ ;</span><br><span class="line">        <span class="keyword">if</span> (j == m) &#123; <span class="comment">// j 已經跟 pattern 的長度相同了</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"P is found at index %d in T\n"</span>, i - j); </span><br><span class="line">            <span class="comment">// 告訴使用者在哪裡找出</span></span><br><span class="line">            j = b[j];</span><br><span class="line">            <span class="comment">// 將 j 設定成此字元上次前綴的 index</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="用紙筆去模擬-KMP"><a href="#用紙筆去模擬-KMP" class="headerlink" title="用紙筆去模擬 KMP"></a>用紙筆去模擬 KMP</h3><p>有時候用想或用看的可能不太能夠懂這演算法，那就用寫的吧！這裡有兩題，可以幫助你更好搞懂 KMP，如果你願意用紙筆去模擬。 </p>
<blockquote>
<p><strong>EXERCISE 2 Run kmp_preprocess() on P = ‘ABABA’ and show the b array !</strong><br><strong>EXERCISE 2 Run kmp_search() with P = ‘ABABA’ and T = ‘ACABAABABDABABA’. Explain how the KMP search looks like?</strong></p>
</blockquote>
<p>大衛我自己解這兩題練習的紀錄，不過後來因為有為了要讓自己在更釐清觀念而稍微改一下練習，所以不要認為我的是標準答案，可能只有近似於答案<br><img src="/images/UVa11475/1.jpg" alt=""></p>
<h2 id="焦點回到題目上，解開題目的小設計"><a href="#焦點回到題目上，解開題目的小設計" class="headerlink" title="焦點回到題目上，解開題目的小設計"></a>焦點回到題目上，解開題目的小設計</h2><p>題目是詢問迴文，那跟 KMP algorithm 有甚麼關係呢？這就是為甚麼題目有給一個善意題型的關係了，由於大部分讀者都會誤判這題為水題，所以才給這個提示以免花太多時間把程式碼寫的雜亂又不會 AC。如果將題目給的字串顛倒做為 pattern 則 KMP 最後的 j 就會是原本的字串已經有的迴文長度，我們只需要補足就好了！</p>
<p>是不是沒有一個舉例，會讓人很不好懂呢？那我們就來舉例吧！</p>
<h3 id="SITUATION-題目字串-xyz"><a href="#SITUATION-題目字串-xyz" class="headerlink" title="SITUATION : 題目字串 xyz :"></a>SITUATION : 題目字串 xyz :</h3><blockquote>
<p>正常字串 : xyz<br>顛倒字串 : zyx</p>
</blockquote>
<p>他們經過 KMP algorithm 後最後的 j 會是多少？答案是 1，所以我們只要將顛倒字元從 1 開始輸出顛倒字元就會是迴文了！(這裡字串的 index 一開始設定為 0，配合 C++)</p>
<blockquote>
<p>正確答案: xyzyx</p>
</blockquote>
<h2 id="參考連結："><a href="#參考連結：" class="headerlink" title="參考連結："></a>參考連結：</h2><p>Competitive Programming 3　(book)<br><a href="https://medium.com/nlp-tsupei/kmp%E7%AE%97%E6%B3%95%E8%A9%B3%E8%A7%A3-1b1050a45850" target="_blank" rel="noopener">KMP算法詳解</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>其實我在學習 KMP 的時候覺得我已經學會 Z-algorithm 拉，幹嘛還要在學其他的？但是我發現到如果只有學會其中一種演算法會使自己的思維能力受限，就像是井底之蛙一樣。那樣不好，所以我再花時間學習 KMP，KMP 我學習的時間也沒有很長大約花了 3 小時的時間，我想應該是<strong>風平</strong>學長介紹的書很好用的關係吧！讓我在學習此演算法時不需要自學，有一本書引導我可以讓我學習的更快！</p>
<p><strong>謝謝風平學長</strong></p>
<p>學習演算法的過程中通常都是無聊的，令人想睡的。大部分的人都認為學習演算法不如去學習網頁，因為學習網頁可以很快地得到回饋，不想演算法只能夠得到題目的「AC」罷了。但我不這麼認為，學習演算法可以讓自己獲得很多思維的想法，他們都可以應用在生活上，我不後悔學習演算法，不如說，我很高興可以學到演算法，可以讓自己在面對很多問題時之前過去的自己在學習演算法而擴展的思維可以幫助到自己，擁有比別人更傑出的想法。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>其實就是沒有附上說明的程式碼，我也花了兩個小時撰寫文章，看得懂跟說得出來真的是兩回事，也許還有人覺得我說的很差，不過我已經盡力解釋。希望可以幫助到各位。</p>
<p>也希望大家想要學習的知識都可以快速學習而成，不要因為自身的環境不足而學習不到。</p>
<p>於是這裡就補述一些題目給的資料範圍限制與標頭檔了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100020</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">string</span> strA , strB ;</span><br><span class="line"><span class="keyword">int</span> b[MAXN] , p[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kmp_process</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = strB.length() ,i = <span class="number">0</span> ,  j = <span class="number">-1</span> ;</span><br><span class="line">    b[<span class="number">0</span>] = <span class="number">-1</span> ;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; n )&#123;</span><br><span class="line">        <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; strB[i] != strB[j]) j = b[j] ;</span><br><span class="line">        i++ ; j++ ;</span><br><span class="line">        b[i] = j ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//debug</span></span><br><span class="line"><span class="comment">//    for(int k = 0 ; k &lt;= n ; k++)</span></span><br><span class="line"><span class="comment">//        cout &lt;&lt; b[k] &lt;&lt; ' ' ;</span></span><br><span class="line"><span class="comment">//    cout &lt;&lt; '\n' ;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kmp</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = strA.length() , m=strB.length() , i=<span class="number">0</span> , j=<span class="number">0</span>  ;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; n )&#123;</span><br><span class="line">        <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; strA[i] != strB[j]) j = b[j] ;</span><br><span class="line">        i++ ; j++ ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> j ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; strA)&#123;</span><br><span class="line">        strB = strA;</span><br><span class="line">        reverse(strB.begin() , strB.end());</span><br><span class="line">        kmp_process();</span><br><span class="line">        <span class="keyword">int</span> n = kmp() ;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; strA &lt;&lt; strB.substr(n) &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>UVa</category>
        <category>演算法知識</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>字串處理</tag>
        <tag>KMP Algorithm</tag>
        <tag>演算法知識</tag>
      </tags>
  </entry>
  <entry>
    <title>QUESTION! C++11 有沒有語法可以讓字串直接顛倒呢？</title>
    <url>/2020/10/03/C++/C++11_reverse/</url>
    <content><![CDATA[<h2 id="內容說明"><a href="#內容說明" class="headerlink" title="內容說明"></a>內容說明</h2><blockquote>
<p>說明我在寫 <a href="https://theriseofdavid.github.io/2020/10/03/UVa/UVa11475/" target="_blank" rel="noopener">UVa11475</a> 時想要透過語法怎麼讓字串顛倒</p>
</blockquote>
<a id="more"></a>

<h2 id="QUESTION-C-11-有沒有語法可以讓字串直接顛倒呢？"><a href="#QUESTION-C-11-有沒有語法可以讓字串直接顛倒呢？" class="headerlink" title="QUESTION! C++11 有沒有語法可以讓字串直接顛倒呢？"></a>QUESTION! C++11 有沒有語法可以讓字串直接顛倒呢？</h2><p>使用 <code>reverse</code> 即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::reverse(<span class="built_in">string</span>.begin() , <span class="built_in">string</span>.end());</span><br><span class="line"><span class="comment">// 不能這樣寫 string = std::reverse(string.begin() , string.end());</span></span><br><span class="line"><span class="comment">// 他本身就會改變了，不需要在前面放 string 多此一舉</span></span><br></pre></td></tr></table></figure>

<p>這樣就不需要自己手寫一個 for 輸出，太感動了 C++11，有這麼方便的函式，嗚嗚。</p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://shengyu7697.github.io/blog/2020/08/05/Cpp-string-reverse/" target="_blank" rel="noopener">C/C++ 字串反轉 reverse</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>有時候語言寫多常常會讓自己搞混很多語法，透過自己的 blog 紀錄這樣真的會讓自己學比較快阿！</p>
]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>Cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa526 - String Distance and Transform Process (Minimum Edit Distance 詳解)</title>
    <url>/2020/10/04/UVa/UVa526/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>給你兩個字串分別是 A,B 你可以用插入、刪除、替換，來將 A 字串轉換成為 B 字串，輸出需要幾次的轉換，也要將步驟輸出。</p>
<p>這題很毒瘤，A,B 都必須用 <code>getline</code> 實作，字串可以包括空白</p>
</blockquote>
<a id="more"></a>

<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><blockquote>
<p>這題為教學題，但此問題還有一點點的小設計，需要稍加解釋才能完全理解。<br>這題要用到<strong>最短修改距離 Minimum Edit Distance</strong>，這是一個動態規劃，遞迴式如下。</p>
</blockquote>
<p><img src="/images/UVa526/1.svg" alt=""></p>
<h2 id="Minimum-Edit-Distance-介紹"><a href="#Minimum-Edit-Distance-介紹" class="headerlink" title="Minimum Edit Distance 介紹"></a>Minimum Edit Distance 介紹</h2><blockquote>
<p>可以透過刪除、插入、替換字元來達到將 A 字串轉換到 B 字串，並且是最少編輯次數。<br>此演算法的時間複雜度 \(O(n^2)\)</p>
</blockquote>
<h2 id="最短修改距離-Minimum-Edit-Distance-應用"><a href="#最短修改距離-Minimum-Edit-Distance-應用" class="headerlink" title="最短修改距離 Minimum Edit Distance 應用"></a>最短修改距離 Minimum Edit Distance 應用</h2><ul>
<li>DNA 分析</li>
<li>拼寫檢查</li>
<li>語音辨識</li>
<li>抄襲偵測</li>
</ul>
<h2 id="MED-實現與說明"><a href="#MED-實現與說明" class="headerlink" title="MED 實現與說明"></a>MED 實現與說明</h2><p>由於 MED 此演算法是動態規劃原理的部分我個人認為沒有很難，因此沒有說明原理。<del>其實是作者很早以前就會了所以不想花時間寫XD</del></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> dis[MAXN][MAXN]; </span><br><span class="line"><span class="comment">//dis[A][B] 指在 strA 長度 0 to A 與 strB 長度 0 to B 的最短修改距離為多少</span></span><br><span class="line"><span class="comment">//這裡假設由 A 轉換 B</span></span><br><span class="line"><span class="built_in">string</span> strA , strB ;</span><br><span class="line"><span class="keyword">int</span> n , m ;</span><br><span class="line">n=strA.length() ;</span><br><span class="line">m=strB.length() ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">med</span><span class="params">()</span></span>&#123; <span class="comment">//Minimum Edit Distance</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= n ; i++) dis[i][<span class="number">0</span>] = i ;</span><br><span class="line">    <span class="comment">// 由於 B 是 0 ，所以 A 轉換成 B 時每個字元都要被進行刪除的動作</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt;= m ; j++) dis[<span class="number">0</span>][j] = j ;</span><br><span class="line">    <span class="comment">// 由於 A 是 0 ，所以 A 轉換成 B 時每個字元都需要進行插入的動作</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; i++)&#123; <span class="comment">// 對 strA 每個字元掃描</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= m ; j++)&#123; <span class="comment">// 對 strB 每個字元進行掃描</span></span><br><span class="line">            <span class="keyword">if</span>(strA[i<span class="number">-1</span>] == strB[j<span class="number">-1</span>]) dis[i][j] = dis[i<span class="number">-1</span>][j<span class="number">-1</span>] ;</span><br><span class="line">            <span class="comment">// 如果他們字元相同則代表不需要修改，因此修改距離直接延續先前</span></span><br><span class="line">            <span class="keyword">else</span> dis[i][j] = min(dis[i<span class="number">-1</span>][j<span class="number">-1</span>], min(dis[i<span class="number">-1</span>][j] , dis[i][j<span class="number">-1</span>]))+<span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 因為她們字元不相同，所以要詢問 replace , delete , insert 哪一個編輯距離</span></span><br><span class="line">            <span class="comment">// 最小，就選擇他 +1 來成為目前的最少編輯距離</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dis[n][m] ; <span class="comment">// 這就是最少編輯距離的答案</span></span><br></pre></td></tr></table></figure>

<h2 id="QUESTION-現在的我們知道最少編輯距離的答案，那我們可以回推有哪些字元被編輯嗎？"><a href="#QUESTION-現在的我們知道最少編輯距離的答案，那我們可以回推有哪些字元被編輯嗎？" class="headerlink" title="QUESTION: 現在的我們知道最少編輯距離的答案，那我們可以回推有哪些字元被編輯嗎？"></a>QUESTION: 現在的我們知道最少編輯距離的答案，那我們可以回推有哪些字元被編輯嗎？</h2><p>那當然是可以的阿XD，只是寫起來比較麻煩。通常這種答案會有很多種，依照題目的要求通常只需要你輸出一種方式即可。<del>除非是毒瘤</del></p>
<h3 id="實現方式如下："><a href="#實現方式如下：" class="headerlink" title="實現方式如下："></a>實現方式如下：</h3><p>由於這回推其實也就只是一個簡單的遞迴你能夠推得出 DP 就可以知道要怎麼回推哪些字元被編輯，於是我就在程式碼上旁寫下說明來幫助讀者閱讀。<del>希望能夠幫助到</del></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span> ;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span> i , <span class="keyword">int</span> j )</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">0</span> || j==<span class="number">0</span>)&#123;  <span class="comment">//表示 A or B 完全沒有字串</span></span><br><span class="line">        <span class="keyword">while</span>( i &gt; <span class="number">0</span> )&#123; </span><br><span class="line">            <span class="comment">// 由於 B 完全沒有字串，所以需要刪除 A 的所有字串</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; cnt++ &lt;&lt; <span class="string">" Delete "</span> &lt;&lt; i &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>( j &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 由於 A 完全沒有字串，所以需要增加 B 的所有字串</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; cnt++ &lt;&lt; <span class="string">" Insert "</span> &lt;&lt; i+<span class="number">1</span> &lt;&lt; <span class="string">","</span> &lt;&lt; strB[j<span class="number">-1</span>] &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">            j-- ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果字元相等代表這裡沒有增加修改距離</span></span><br><span class="line">    <span class="comment">// 特別注意：不可以使用　dis[i][j] == dis[i-1][j-1]</span></span><br><span class="line">    <span class="comment">// 有可能 dis[i-1][j]+1 = dis[i-1][j-1] 這樣就會導致 strB 的第 j 字元遺失</span></span><br><span class="line">    <span class="comment">// 而讓回推出錯</span></span><br><span class="line">    <span class="keyword">if</span>(strA[i<span class="number">-1</span>] == strB[j<span class="number">-1</span>])</span><br><span class="line">        backtracking(i<span class="number">-1</span>,j<span class="number">-1</span>); <span class="comment">// 往前推</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dis[i][j] == dis[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>)&#123; <span class="comment">// 這次是使用替換指令</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; cnt++ &lt;&lt; <span class="string">" Replace "</span> &lt;&lt; i &lt;&lt; <span class="string">","</span> &lt;&lt; strB[j<span class="number">-1</span>] &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">            backtracking(i<span class="number">-1</span>,j<span class="number">-1</span>); <span class="comment">// 回推替換</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 特別注意這裡要使用 else if ，不可以只有 if，這樣會讓回推變成 BFS 而不是 DFS</span></span><br><span class="line">        <span class="comment">// 答案就會變成輸出所有的替換可能而不是輸出一種「完整」的其中一種回推</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(dis[i][j] == dis[i<span class="number">-1</span>][j]+<span class="number">1</span>)&#123;  <span class="comment">// 這次是使用刪除指令</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; cnt++ &lt;&lt; <span class="string">" Delete "</span> &lt;&lt; i &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">            backtracking(i<span class="number">-1</span>,j) ; <span class="comment">// 回推刪除</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(dis[i][j] == dis[i][j<span class="number">-1</span>]+<span class="number">1</span>)&#123; <span class="comment">// 這次是使用插入指令</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; cnt++ &lt;&lt; <span class="string">" Insert "</span> &lt;&lt; i+<span class="number">1</span> &lt;&lt; <span class="string">","</span> &lt;&lt; strB[j<span class="number">-1</span>] &lt;&lt;<span class="string">'\n'</span>  ;</span><br><span class="line">            backtracking(i,j<span class="number">-1</span>); <span class="comment">// 回推插入</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="焦點回到題目上，解開題目的小設計"><a href="#焦點回到題目上，解開題目的小設計" class="headerlink" title="焦點回到題目上，解開題目的小設計"></a>焦點回到題目上，解開題目的小設計</h2><p>甚麼，這題好像沒有甚麼焦點！</p>
<p>還是有的，這題的輸入不一定要用字串，只要是那一行都可以，所以請記住要用<code>getline</code>，<del>不要像我這個大笨蛋一直用<code>cin &gt;&gt; strA &gt;&gt; strB</code>，然後一直找不出答案，還在想是不是自己 DP 寫不好</del></p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://blog.roy4801.tw/2019/06/14/uva/uva526/" target="_blank" rel="noopener">Uva 526 - String Distance and Transform Process</a><br><a href="https://zh.wikipedia.org/wiki/%E8%90%8A%E6%96%87%E6%96%AF%E5%9D%A6%E8%B7%9D%E9%9B%A2" target="_blank" rel="noopener">萊文斯坦距離</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>其實這演算法在我高中時就有學習過了，但是我高中的時候不懂得整理資料的重要性。讓我在高中學會的很多演算法一經過時間的摧殘就忘記這些演算法是甚麼了，可惡，應該高中就要學會整理資料的能力，這太重要了。</p>
<p>然後在此奉戒各位女朋友可以教，但是不要讓她影響到你的正業，我常常會因為女朋友而影響正業導致高三下的時候荒廢了我的程式，因為已經知道自己能保送上某間大學而每天跟女朋友打打鬧鬧，到最後跟女朋友分手還不是甚麼都沒有獲得。</p>
<p>不過如果你能跟她在一起到結婚的話，就當我沒說吧！這也是令我羨慕的結局，我也好想要。</p>
<p>謝謝新北市教育局能讓我在高三寒假時去板橋高中訓練程式設計，讓我可以增強我的演算法能力，也謝謝板橋高中的蝸牛老師，你的指導能力讓我在學習演算法的路上突飛猛進。老師您真的教得很好，高中沒有你真的沒辦法像現在這樣。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>其實就是沒有附上說明的程式碼，我也花了兩個小時撰寫文章，看得懂跟說得出來真的是兩回事，也許還有人覺得我說的很差，不過我已經盡力解釋。希望可以幫助到各位。</p>
<p>也希望大家想要學習的知識都可以快速學習而成，不要因為自身的環境不足而學習不到。</p>
<p>於是這裡就補述一些題目給的資料範圍限制與標頭檔了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">string</span> strA , strB ;</span><br><span class="line"><span class="keyword">int</span> dis[MAXN][MAXN] , back_table[MAXN][MAXN] ;</span><br><span class="line"><span class="keyword">int</span> cnt , m , n  ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span> i , <span class="keyword">int</span> j )</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">0</span> || j==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>( i &gt; <span class="number">0</span> )&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; cnt++ &lt;&lt; <span class="string">" Delete "</span> &lt;&lt; i &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>( j &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; cnt++ &lt;&lt; <span class="string">" Insert "</span> &lt;&lt; i+<span class="number">1</span> &lt;&lt; <span class="string">","</span> &lt;&lt; strB[j<span class="number">-1</span>] &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">            j-- ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(strA[i<span class="number">-1</span>] == strB[j<span class="number">-1</span>])</span><br><span class="line">        backtracking(i<span class="number">-1</span>,j<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dis[i][j] == dis[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; cnt++ &lt;&lt; <span class="string">" Replace "</span> &lt;&lt; i &lt;&lt; <span class="string">","</span> &lt;&lt; strB[j<span class="number">-1</span>] &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">            backtracking(i<span class="number">-1</span>,j<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(dis[i][j] == dis[i<span class="number">-1</span>][j]+<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; cnt++ &lt;&lt; <span class="string">" Delete "</span> &lt;&lt; i &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">            backtracking(i<span class="number">-1</span>,j) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(dis[i][j] == dis[i][j<span class="number">-1</span>]+<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; cnt++ &lt;&lt; <span class="string">" Insert "</span> &lt;&lt; i+<span class="number">1</span> &lt;&lt; <span class="string">","</span> &lt;&lt; strB[j<span class="number">-1</span>] &lt;&lt;<span class="string">'\n'</span>  ;</span><br><span class="line">            backtracking(i,j<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">med</span><span class="params">()</span></span>&#123; <span class="comment">//Minimum Edit Distance</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= n ; i++) dis[i][<span class="number">0</span>] = i ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt;= m ; j++) dis[<span class="number">0</span>][j] = j ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= m ; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(strA[i<span class="number">-1</span>] == strB[j<span class="number">-1</span>]) dis[i][j] = dis[i<span class="number">-1</span>][j<span class="number">-1</span>] ;</span><br><span class="line">            <span class="keyword">else</span> dis[i][j] = min(dis[i<span class="number">-1</span>][j<span class="number">-1</span>], min(dis[i<span class="number">-1</span>][j] , dis[i][j<span class="number">-1</span>]))+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> );</span><br><span class="line">    freopen(<span class="string">"out.txt"</span> , <span class="string">"w"</span> , <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">while</span>(getline(<span class="built_in">cin</span> ,strA) &amp;&amp; getline(<span class="built_in">cin</span> , strB))&#123;</span><br><span class="line">        n=strA.length() ;</span><br><span class="line">        m=strB.length() ;</span><br><span class="line">        cnt = <span class="number">1</span> ;</span><br><span class="line">        med();</span><br><span class="line">        <span class="keyword">if</span>(flag) <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">        flag = <span class="number">1</span> ;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; dis[n][m] &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">        backtracking(n,m);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>UVa</category>
        <category>演算法知識</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>最短修改距離 Minimum Edit Distance</tag>
        <tag>演算法知識</tag>
        <tag>動態規劃 Dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa11151 - Longest Palindrome (LCS)</title>
    <url>/2020/10/05/UVa/UVa11151/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>給你一個字串，詢問在這字串中能夠找到的最長迴文長度為多少。<br>迴文：從左邊讀與右邊讀相同</p>
</blockquote>
<a id="more"></a>

<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>這題可以使用兩種方式解，但我這裡只用其中一種方式解題，原因是解決速度較快，但缺點時間複雜度較高。</p>
<h3 id="QUESTION-1-哪兩種方式呢"><a href="#QUESTION-1-哪兩種方式呢" class="headerlink" title="QUESTION 1: 哪兩種方式呢"></a>QUESTION 1: 哪兩種方式呢</h3><ul>
<li><strong>最長共同子序列 Longest Common Subsequence</strong> (LCS)<br>時間複雜度為 \(O(n^2)\)</li>
<li><strong>馬拉車演算法 Manacher’s Algorithm</strong><br>時間複雜度為 \(O(n)\)</li>
</ul>
<blockquote>
<p>這裡我們使用時間複雜度比較高的演算法，最長共同子序列</p>
</blockquote>
<h3 id="QUESTION-2-那為甚麼我們會使用最長共同子序列，時間複雜度比較高呀！"><a href="#QUESTION-2-那為甚麼我們會使用最長共同子序列，時間複雜度比較高呀！" class="headerlink" title="QUESTION 2: 那為甚麼我們會使用最長共同子序列，時間複雜度比較高呀！"></a>QUESTION 2: 那為甚麼我們會使用最長共同子序列，時間複雜度比較高呀！</h3><p>因為這題的字串長度不超過 1000，且題目有說明 \(90 \% \) 的測試資料長度都小於 255。通常時間複雜度 \(O(n^2)\) 只要測試資料大小不大於 \(10^3\) 基本上都可以通過。加上如果只有 LCS 去寫這題目可以讓這題目簡單非常多。</p>
<p><del>也可以透過題目給的測試資料範圍大小來猜這題的時間複雜度</del></p>
<h3 id="QUESTION-3-通常-LCS-應該要有兩個字串來找出共同子序列但這題是迴文，哪裡有關係呢？"><a href="#QUESTION-3-通常-LCS-應該要有兩個字串來找出共同子序列但這題是迴文，哪裡有關係呢？" class="headerlink" title="QUESTION 3: 通常 LCS 應該要有兩個字串來找出共同子序列但這題是迴文，哪裡有關係呢？"></a>QUESTION 3: 通常 LCS 應該要有兩個字串來找出共同子序列但這題是迴文，哪裡有關係呢？</h3><p>嘿嘿，這個我其實一開始也想不到但後來我在 google 翻找文章時看到了一個超級優秀的想法！顛覆了我的想像。</p>
<p>必須要有兩個子串，第一個為題目給的字串，第二為題目反轉字串，並將他們進行 LCS 就可以把找到他們的共同子序列，那也就是迴文啦!</p>
<blockquote>
<p>Why?</p>
</blockquote>
<p>由於迴文的特性，你如果顛倒反著念也會一樣，剛好符合共同子序列，因為迴文就算顛倒還是一樣呀www。</p>
<h3 id="EXERCISE-A"><a href="#EXERCISE-A" class="headerlink" title="EXERCISE A:"></a>EXERCISE A:</h3><blockquote>
<p>求 ADAM 與 MADA 的 LCS</p>
</blockquote>
<p>答案是不是會是 3 呢！很神奇吧，國人的演算法思維真的大於大於我，我好爛嗚嗚ಥ⌣ಥ。</p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://blog.csdn.net/llx523113241/article/details/45536793" target="_blank" rel="noopener">uva 11151 Longest Palindrome （最长公共子序列）</a><br><a href="https://hackmd.io/@sa072686/SJCdfKC0M/https%3A%2F%2Fhackmd.io%2Fs%2FS1jJaysvQ" target="_blank" rel="noopener">APCS - 2018台南一中選修</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>其實我還沒有學好 Manacher’s Algorithm，有點怠惰阿我！還需要更努力，明明有一個中秋廉價我的努力卻沒有變多有點討厭啊！我需要讓我自己變得能夠專心，有時候我在打 blog 文章時，我都會有種腦袋已經想好要打甚麼，但手指卻沒有跟上QAQ，難道是老了嗎…，不會吧！</p>
<p>不過打心得的時候是快樂的，因為可以把自己想講的話抒發出來，認識的人不太會看到不會尷尬，也不會被他們覺得虛偽XD，我好希望我能夠把生活中的每件事情都記錄在 blog 上，但感覺還是有點難，有時候遇到一些討厭的事情通常都是會選擇跟朋友分享，有點少打在 Blog 上，我也希望我可以打打我的愛情故事在 Blog 上，但我又很怕之後被朋友們 judge。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1010</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> dp[MAXN][MAXN] = &#123;&#125; ;</span><br><span class="line"><span class="built_in">string</span> strA , strB ;</span><br><span class="line"><span class="keyword">int</span> n , m ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lcs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n = strA.length();</span><br><span class="line">    m = strB.length();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= n ; i++) dp[i][<span class="number">0</span>] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt;= m ; j++) dp[j][<span class="number">0</span>] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= m ; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(strA[i<span class="number">-1</span>] == strB[j<span class="number">-1</span>]) dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">else</span> dp[i][j] = max(dp[i<span class="number">-1</span>][j] , dp[i][j<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][m] ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">int</span> t ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t ;</span><br><span class="line">    <span class="built_in">cin</span>.ignore();</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        getline(<span class="built_in">cin</span>,strA);</span><br><span class="line">        strB = strA ;</span><br><span class="line">        reverse(strB.begin() , strB.end());</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; lcs() &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>最長共同子序列 Longest Common Subsequence</tag>
        <tag>最長迴文子字串 Longest Palindromic Substrings</tag>
        <tag>動態規劃 Dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title>統計學(一) 筆記 - 第三章A</title>
    <url>/2020/10/05/NTUT_note/statistics-ch3A/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊與財金管理系大二上統計學重點整理<br><font color="#dd0000">並非所有人都適用，部分對我而言稍加容易的內容並不會寫在此內。</font><br><strong>這是觀看影片心得後的筆記，老師上課可能不太適用會忘記抄到</strong></p>
</blockquote>
<a id="more"></a>

<h2 id="3A-介紹-Descriptive-Statistics-Numerical-Measures-數值方式"><a href="#3A-介紹-Descriptive-Statistics-Numerical-Measures-數值方式" class="headerlink" title="3A 介紹 - Descriptive Statistics: Numerical Measures(數值方式)"></a>3A 介紹 - Descriptive Statistics: Numerical Measures(數值方式)</h2><p>敘述統計。</p>
<h4 id="名詞解釋"><a href="#名詞解釋" class="headerlink" title="名詞解釋"></a>名詞解釋</h4><p>sample statistics 從資料中找出的某些資料<br>population parameters 母體參數，從母體的資料取得<br>point estimator 點估計量</p>
<h4 id="Measures-of-Location-位置量數如何"><a href="#Measures-of-Location-位置量數如何" class="headerlink" title="Measures of Location 位置量數如何"></a>Measures of Location 位置量數如何</h4><ul>
<li><p>mean 平均數<br>  平均數為資料中央量數，如果是樣本平均數則符號為 \(\bar{x}\)，母體平均數用 \(μ\)</p>
<blockquote>
<p><img src="/images/statistics-ch3A/1.PNG" alt=""></p>
</blockquote>
<p>  但如果有極端值時，平均數不適用。</p>
<ul>
<li>trimmed mean<br>刪掉極端值的平均數，常用方法，將最小 \(5\% \) 與最大 \(5\% \)去掉後算平均數。</li>
<li>標準差會變小</li>
</ul>
</li>
<li><p>median 中位數<br>  如果資料裡有極端值時試用 median，<del>例如白鳥麗次、中川圭一</del>。<br>  如果資料量是偶數就將最中間兩個數字加起來除以二</p>
</li>
<li><p>mode 眾數<br>  眾數不一定只有一個，可以有很多的</p>
</li>
<li><p>Weighted Mean 加權平均數<br>  根據重要性來加權重，例如根據學分數來判斷權重<br>  加權平均公式</p>
<blockquote>
<p><img src="/images/statistics-ch3A/2.PNG" alt=""><br><img src="/images/statistics-ch3A/3.PNG" alt=""></p>
</blockquote>
</li>
<li><p>Geometric Mean 幾何平均數<br>算法</p>
<blockquote>
<p><img src="/images/statistics-ch3A/4.PNG" alt=""></p>
</blockquote>
</li>
</ul>
<p>通常用在算財務報表成長率</p>
<p>舉例:</p>
<blockquote>
<p><img src="/images/statistics-ch3A/5.PNG" alt=""></p>
</blockquote>
<ul>
<li><p>Percentiles 百分位數<br>通常用第 p 的百分位數表示，至少有 p percent 比你差，其他比你好。<br>公式:\(L_{p} = (p/100)(n+1)\)<br>如果出來的數值是有小數點則將左右兩邊數字相減乘以小數位數即可</p>
</li>
<li><p>Quartiles 四分位數<br>用百分位數表示就是分成 25% , 50% , 75% 來區分公式一樣用百分位數公式，如果出來的數值有小數點也是如此。</p>
</li>
</ul>
<h3 id="Measures-of-Variability-變異程度"><a href="#Measures-of-Variability-變異程度" class="headerlink" title="Measures of Variability 變異程度"></a>Measures of Variability 變異程度</h3><ul>
<li><p>Range<br>\( \text{Range} = \text{Largest Value} - \text{Smallest Value} \)，<strong>對極端值敏感</strong></p>
</li>
<li><p>Interquartile Range (四分位距)<br>用 75% 的值與 25% 的值設為範圍，<strong>對極端值不敏感</strong></p>
</li>
<li><p>Variance (變異數)<br>數字大代表變異大，數字小代表變異小。公式如下：</p>
<blockquote>
<p><img src="/images/statistics-ch3A/6.PNG" alt=""></p>
</blockquote>
<ul>
<li>Degrees of Freedom 自由度 縮寫 df<br>如果是等比數列或是等差數列自由度為零。<br>樣本變數  \(n-1\)<br>母體變數  \(n\)<blockquote>
<p><img src="/images/statistics-ch3A/7.PNG" alt=""></p>
</blockquote>
</li>
</ul>
</li>
<li><p>Standard Deviation 標準差<br>標準差越小離散程度越小，標準差越大離散程度越大<br>把變異數開根號，所以值一定為正</p>
<blockquote>
<p><img src="/images/statistics-ch3A/8.PNG" alt=""></p>
</blockquote>
</li>
<li><p>Coefficient of Variation (變異系數)<br>標準差相較於平均數差距多大</p>
<blockquote>
<p><img src="/images/statistics-ch3A/9.PNG" alt=""></p>
</blockquote>
</li>
<li><p>Mean Absolute error 平均絕對誤差 MAE<br>數字越大代表離平均數遠，如果不是就離平均數近。公式如下</p>
<blockquote>
<p><img src="/images/statistics-ch3A/11.PNG" alt=""></p>
</blockquote>
</li>
</ul>
<h4 id="統整練習"><a href="#統整練習" class="headerlink" title="統整練習"></a>統整練習</h4><blockquote>
<p><img src="/images/statistics-ch3A/10.PNG" alt=""></p>
</blockquote>
]]></content>
      <categories>
        <category>北科上課筆記</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>統計學筆記</tag>
        <tag>北科大二上統計學筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa11362 - Phone List (字典樹 詳解)</title>
    <url>/2020/10/09/UVa/UVa11362/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>給你一組電話號碼，不超過 10 位數，如果這一組的電話號碼內只要有一個電話號碼是另外一個電話號碼的前綴就輸出 “NO”，否則就輸出 “YES”</p>
</blockquote>
<a id="more"></a>

<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>這題用 <strong>字典樹 trie</strong> 解決是再好不過的了，我們先來介紹 trie！</p>
<blockquote>
<p>trie 是一種有序樹，常用於搜尋提示，最好的比喻就是 google 的搜尋提示。<del>就是你打幾個 key word 上去下面就跑出一堆你不想要的那個</del><br>這題為教學題，但此問題並沒有把 trie 的全部能力都展現出來，若以後我有其他題目可以將 trie 展現，我會再寫一篇做為說明，但此問題還有一點點的小設計，需要稍加解釋才能完全理解。<br>由於是寫給初學者看於是這題不使用任何 <strong>指標 pointer</strong> 來幫助這份程式碼，希望可以讓其他沒學過 C++ 的使用者都能學會。</p>
</blockquote>
<h2 id="TRIE-字典樹-原理"><a href="#TRIE-字典樹-原理" class="headerlink" title="TRIE 字典樹 原理"></a>TRIE 字典樹 原理</h2><p>先看看圖片吧！這樣應該會比較有點概念</p>
<blockquote>
<p><img src="/images/UVa11362/1.jpg" alt=""></p>
</blockquote>
<p>TRIE 本身也是一種樹，可以試著把它當作有規則的樹理解。<del>畢竟他的發音跟 tree 根本沒有不一樣吧！</del><br>字串根據 TRIE 判斷，如果字串中的字元已經在 TRIE 擁有，則就在往 TRIE 的下一層判斷，假如沒有那我們就新增一個節點給予這個字元。</p>
<p>達到最後一層時則必須要有一個判斷表示這是某個單字的結尾。</p>
<h3 id="QUESTION-TRIE-的時間複雜度呢？"><a href="#QUESTION-TRIE-的時間複雜度呢？" class="headerlink" title="QUESTION: TRIE 的時間複雜度呢？"></a>QUESTION: TRIE 的時間複雜度呢？</h3><blockquote>
<p>新增字串的時間複雜度為 \(O(n)\)<br>搜尋的時間複雜度為 \(O(n)\)<br>搜尋關鍵字首的時間複雜度為 \(O(n)\)<br><del>算是還不錯用的資料結構之一，感覺學起來可以在很多地方用到，小弟我菜鳥還沒有實際用過</del></p>
</blockquote>
<h2 id="TRIE-字典樹的實現與說明"><a href="#TRIE-字典樹的實現與說明" class="headerlink" title="TRIE 字典樹的實現與說明"></a>TRIE 字典樹的實現與說明</h2><h3 id="資料結構"><a href="#資料結構" class="headerlink" title="資料結構"></a>資料結構</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">bool</span> isWord = <span class="literal">false</span> ; <span class="comment">// 判斷是否為單字結尾</span></span><br><span class="line">    <span class="keyword">int</span> next[alp_MAXN]; <span class="comment">// 到下個單字的索引，假如有 26 英文字母就設定 26</span></span><br><span class="line">    <span class="comment">// alp_MAXN = alphabet MAXN</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span></span>&#123; <span class="comment">//重新設定</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; alp_MAXN ; i++)</span><br><span class="line">            next[i] = <span class="number">-1</span> ; </span><br><span class="line">        isWord = <span class="literal">false</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;trie[arr_MAXN];</span><br></pre></td></tr></table></figure>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insrt</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c , cur = <span class="number">0</span>; <span class="comment">// c=字元的索引 cur = trie 現在這層，可以想像成樹的 root</span></span><br><span class="line">    <span class="comment">// cur =0，表示現在在 trie 的最一開始處</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; strA.length() ; i++)&#123; <span class="comment">//將字串加入 trie</span></span><br><span class="line">        c = strA[i] - <span class="string">'0'</span> ;</span><br><span class="line">        <span class="keyword">if</span>(trie[cur].next[c] == <span class="number">-1</span> )&#123; <span class="comment">//代表節點沒有被新增</span></span><br><span class="line">            trie[cnt].reset(); <span class="comment">//先重新設定節點，以免舊資料也加入</span></span><br><span class="line">            trie[cur].next[c] = cnt ; <span class="comment">//連接到下一層的 node</span></span><br><span class="line">            cur = cnt++ ; <span class="comment">//增加陣列長度</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cur = trie[cur].next[c]; <span class="comment">//因為已經有節點，可以直接往下層走就好</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    trie[cur].isWord = <span class="literal">true</span> ; <span class="comment">//由於已讀到字尾於是給他是字尾的標記</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="搜尋"><a href="#搜尋" class="headerlink" title="搜尋"></a>搜尋</h3><p>跟插入的算法差不多，只是不需要新增節點的 if，只需要 else 跟最後判斷當已經讀到字尾時有沒有被標記成是字尾。</p>
<h3 id="關鍵字查詢"><a href="#關鍵字查詢" class="headerlink" title="關鍵字查詢"></a>關鍵字查詢</h3><p>跟搜尋一樣，但只要搜到此字串最底層後就可以 return 了，不需要檢查是否到字尾，如果是在寫題目通常是用 return true or false。</p>
<h3 id="刪除"><a href="#刪除" class="headerlink" title="刪除"></a>刪除</h3><p>目前還沒有學到，隨後補上。打算要用遞迴嘗試創作看看，畢竟沒有用指標的 trie，在網路上的自學資源還很少見呢！XD</p>
<h2 id="焦點回到題目上，解開題目的小設計"><a href="#焦點回到題目上，解開題目的小設計" class="headerlink" title="焦點回到題目上，解開題目的小設計"></a>焦點回到題目上，解開題目的小設計</h2><p>由於這題是問「前綴」，且只要一個就好，於是我們就用一個 flag 與一個 if 來進行判斷，只要當現在的電話號碼再依序插入 trie 中如果剛好字尾有被標記就表示已經有一個電話號碼已經是這個電話的前綴了就 <code>return</code>；另一個則是假如這個電話號碼字元已經全部被插入 trie 中表示，這組電話號碼是先前某個電話的前綴，所以也需要 <code>return</code>。 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> flag = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">if</span>(trie[cur].isWord || i == strA.length()<span class="number">-1</span> ) &#123;flag = <span class="number">1</span> ;<span class="keyword">return</span> ;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://epmahfuz.blogspot.com/2016/10/solution-of-uva-11362-phonebook.html" target="_blank" rel="noopener">Solution of UVa 11362-Phone List</a><br><a href="https://www.mdeditor.tw/pl/2iwz/zh-tw" target="_blank" rel="noopener">[翻譯]資料結構——trie樹介紹</a><br><a href="https://zh.wikipedia.org/wiki/Trie" target="_blank" rel="noopener">Trie</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>應該是我這題選得不好，我原本是想要完整地把 trie 都學起來的，結果這題只需要用到 trie 的插入就好，刪除、搜尋都不需要用到，害我的心情很差：(，有種覺得沒有把全部資料都學起來的感覺，以後在挑選題目時需要謹慎挑選，要是挑到這種題目會覺得一個演算法沒有完整學習，有點小難過。</p>
<p>不過 trie 算是簡單易學的演算法，以自學來說。我就讀的大學演算法資源基本上是零，我都覺得我在這種環境下自學演算法可能也算是個抖 M 了吧XD，希望我在學習的路上能夠填補些自學的資源讓接下來想學習的人不要想我一樣這麼辛苦，我到現在才學有點太慢了呢，等我最近忙完後我再補上刪除的程式碼，補足自己的知識與空白之處。等學習完後看自己有沒有更多心得再補上。<del>希望是有</del></p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>其實就是沒有附上說明的程式碼，我也花了兩個小時撰寫文章，看得懂跟說得出來真的是兩回事，也許還有人覺得我說的很差，不過我已經盡力解釋。希望可以幫助到各位。</p>
<p>也希望大家想要學習的知識都可以快速學習而成，不要因為自身的環境不足而學習不到。</p>
<p>於是這裡就補述一些題目給的資料範圍限制與標頭檔了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> alp_MAXN 15</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> arr_MAXN 1000009</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span> , flag = <span class="number">0</span> ;</span><br><span class="line"><span class="built_in">string</span> strA ;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">bool</span> isWord = <span class="literal">false</span> ;</span><br><span class="line">    <span class="keyword">int</span> next[alp_MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; alp_MAXN ; i++)</span><br><span class="line">            next[i] = <span class="number">-1</span> ;</span><br><span class="line">        isWord = <span class="literal">false</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;trie[arr_MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insrt</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c , cur = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; strA.length() ; i++)&#123;</span><br><span class="line">        c = strA[i] - <span class="string">'0'</span> ;</span><br><span class="line">        <span class="keyword">if</span>(trie[cur].next[c] == <span class="number">-1</span> )&#123;</span><br><span class="line">            trie[cnt].reset();</span><br><span class="line">            trie[cur].next[c] = cnt ;</span><br><span class="line">            cur = cnt++ ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cur = trie[cur].next[c];</span><br><span class="line">            <span class="keyword">if</span>(trie[cur].isWord || i == strA.length()<span class="number">-1</span> ) &#123;flag = <span class="number">1</span> ;<span class="keyword">return</span> ;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag) <span class="keyword">break</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    trie[cur].isWord = <span class="literal">true</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> );</span><br><span class="line">    <span class="comment">//freopen("out.txt" , "w" , stdout );</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> t , n ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">        cnt = <span class="number">1</span> ;</span><br><span class="line">        flag = <span class="number">0</span> ;</span><br><span class="line">        trie[<span class="number">0</span>].reset();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; strA ;</span><br><span class="line">            insrt();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; (flag? <span class="string">"NO"</span> : <span class="string">"YES"</span>) &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//debug</span></span><br><span class="line"><span class="comment">//        for(int i = 0 ; i &lt; 20 ; i++)&#123;</span></span><br><span class="line"><span class="comment">//            for(int j = 0 ; j &lt; 10 ; j++)</span></span><br><span class="line"><span class="comment">//                cout &lt;&lt; trie[i].next[j] &lt;&lt; ' ' ;</span></span><br><span class="line"><span class="comment">//            cout &lt;&lt; trie[i].isWord ;</span></span><br><span class="line"><span class="comment">//            cout &lt;&lt; '\n' ;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>UVa</category>
        <category>演算法知識</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>字典樹 trie</tag>
        <tag>演算法知識</tag>
      </tags>
  </entry>
  <entry>
    <title>NCPC2020 109年度全國大專電腦軟體設計決賽 - 34th(佳作) 心得</title>
    <url>/2020/10/09/contest_experence/ncpc2020_final/</url>
    <content><![CDATA[<blockquote>
<p>僅此紀錄 2020/10/09 109年度全國大專電腦軟體設計決賽心得。<br>「紀錄每個時刻，讓未來的自己不遺忘過去的自己」<br>只有自己才能體會自己的過去<br>僅只有 34th，還需要努力</p>
</blockquote>
<a id="more"></a>

<h2 id="出發拉"><a href="#出發拉" class="headerlink" title="出發拉"></a>出發拉</h2><p>通過了初賽之後，決賽的場地直到 10/07 才公佈，有點小慢，嗚嗚嗚，希望下次師大可以在更早公布些XD，不過也有可能是我們第一次參加這比賽可能不知道比賽地點都會在台灣師範大學，下次可以直接猜是在台灣師範大學比了，對！然後看到比賽的報到時間是早上 9 點整到 9 點 45 分，對一個貓頭鷹來說有點痛苦阿ಥ⌣ಥ，我早上醒來的時候雖然是 7 點 30 分，但依照我那愛賴床的爛個性硬是拖倒了 9 點整才出門XD，不過這個性要改拉，不要遲到，這真的很重要，遲到會讓自己緊張然後就忘記一些重要的事情了QQ，或是錯過一些資訊。</p>
<blockquote>
<p>賽前資訊 </p>
</blockquote>
<p><img src="/images/ncpc2020_final/1.jpg" alt=""></p>
<p>出門騎到台師大之後，路途中就在下雨，阿阿阿阿好煩阿，怎麼初賽跟決賽都要下雨拉QQ，我好討厭我騎車的時候下雨，其他的時候真的沒關係喔，管控天氣的神聽到了嗎XD。由於今天是假日的關係師大的停車位蠻多的，隨後停好車就直接前往比賽出發地點了。</p>
<blockquote>
<p><a href="https://www.youtube.com/watch?v=HQDDlgGy2hg&ab_channel=SKRpresents%E9%99%B6%E5%B1%B1%E9%9F%B3%E6%A8%82" target="_blank" rel="noopener">nothing change 還是討厭下雨天</a></p>
</blockquote>
<p><img src="/images/ncpc2020_final/2.jpg" alt=""></p>
<h2 id="進場報到"><a href="#進場報到" class="headerlink" title="進場報到"></a>進場報到</h2><p>進場之後順利報到，聽主持人一段漂亮的演講後就去四樓測試電腦，沒想到電腦有點小差QQ，他的編輯器只有 Esclipe 與另外一個文字編輯器，等等 CodeBlock 呢？去哪裡了？於是我們(學長-風平)對就舉手發問，沒想到主辦單位拿出賽事規則規則上面確實沒有 CodeBlock，只有電腦上所擁有的兩個軟體，等等等等等等，不對欸！我怎麼記得 CodeBlock 應該是這種比賽的<strong>必備</strong>阿！這點讓我很討厭拉，希望主辦單位下次可以給參加者更友善的環境。</p>
<blockquote>
<p>主辦單位提供的資料夾</p>
</blockquote>
<p><img src="/images/ncpc2020_final/3.jpg" alt=""></p>
<blockquote>
<p>主辦單位提供的考生辨識證</p>
</blockquote>
<p><img src="/images/ncpc2020_final/4.jpg" alt=""></p>
<p>後來學弟(漢軒)與他們的好朋友發現出一個 BUG XD，它們發現考生辨識證的中的吊帶英文有錯XD，程式的英文應該要是「programming」，但吊帶上面打的是「progrmming」，笑爛，考生還沒比賽就已經在幫這比賽 debug。師大下次可以注意一下，不然你們的英文程度要跟我一樣了拉 QwQ，不過辦比賽真的很辛苦，也謝謝你們可以讓我們比賽。</p>
<blockquote>
<p>考生辨識證吊帶中有錯誤的英文</p>
</blockquote>
<p><img src="/images/ncpc2020_final/5.jpg" alt=""></p>
<p>這裡有個小小的插曲，我們在座坐位的時候隔壁師大的學生座錯座位，我好心提醒他們如果這樣的話會有另外一隊少一個位置可以座，所以師大隊伍應該要座回自己隊伍，但沒想到師大隊伍說如果座回正確的位置會影響到他們比賽！HELLO？那你怎麼不想想你這樣就不會影響到別人嗎？我們是來比賽的，比賽要求的是公平，你讓其他隊伍不公平這樣還能叫做比賽嘛。那隻師大隊伍真的很自私，後來我朋友請工作人員來解決，他們才座回正確的位置，這讓我更生氣，硬要請階層更大的人講才會聽話，我們解釋道理給他不願意相信，我厭惡這種人，自私的人。</p>
<p><strong>當一個比賽不公平時，那早就失去了比賽的意義，那怕只是一個小小的權益受損</strong></p>
<p>準備完畢後，現場的走廊也掛上五彩繽紛的氣球，頓時超漂亮的！我們也在那時候想要拍幾張照片留為紀念，當我們這支隊伍正想著要如何自拍時有為很熱心的師大工作人員主動來幫我們拍照，超讓我感動的！師大的工作人員真的好好QQ，爛的是賽事規則不是那些友善的 NCPC 工作人員，給 NCPC 工作人員一個讚(◍•ᴗ•◍)❤️。</p>
<blockquote>
<p>與師大 NCPC 氣球牆留念</p>
</blockquote>
<p><img src="/images/ncpc2020_final/6.jpg" alt=""></p>
<h2 id="比賽當下"><a href="#比賽當下" class="headerlink" title="比賽當下"></a>比賽當下</h2><p>比賽入場後，突然走道上多了很多氣球飛在天花板上，超級酷的欸！有種走入了童話故事的感覺讓自己的心情都好上許多XD，於是我就想要在這氣氛下留下一張照片，內心決定了後，請學長(風平)幫我拍了一張，不得不說他拍照技術真的蠻不賴的，看來他的女生朋友 or 女朋友對於拍照技術指導的很不錯呢XD，幫我拍出了一張很漂亮得照片，謝拉學長！</p>
<blockquote>
<p>盡我可能，發揮最好 - 照片註解</p>
</blockquote>
<p><img src="/images/ncpc2020_final/7.jpg" alt=""></p>
<p>開始比賽後，我們打開題本，發現題本竟然還是雙面列印！！！天啊…，這樣太痛苦了吧，沒改進阿師大QQ，於是我們直接打開題本的 PDF 直接 print 出來，這樣就有單面題本拉XD，天啊，我們是生活智慧王吧(自己說)，後來主辦單位就可以幫我們印好單面題本 ♡(&gt; ਊ &lt;)♡，不過這樣不是更浪費紙吧..，下次真的要改進拉師大，不要讓我在說第三邊呦。不然我會大爆哭喔QQQQQQQQQ。</p>
<p>在開始比賽後，我們找不到 Esclipe！當下的我們真的傻眼，怎麼原本在測試的時候有結果到考試的時候沒有呢？我們項工作人員反應，隨後工作人員不知道對我們電腦下了甚麼指令，Esclipe 就跑出來了，只是他跟其他檔案重疊，於是我們直接刪掉其他檔案把 Esclipe 呼叫出來，開始進行比賽。</p>
<p>遇到一個很有趣的事情是原本 pJ 學長上傳一次程式碼回傳的答案是 WA，學長就開始不斷思考哪裡有錯，過了一陣子之後，漢軒重新整理了一次頁面就變成了 AC，So Excited，非常的酷啊，原來是官方測試資料有誤，之後修正後我們就變成 AC 了，既上次 TOPC 後我們又成功 Checker 一個題目，我們隊伍是 ICPC Check Hacker 吧www，連續兩次找到測資上的漏洞。</p>
<p>再來有一題是水題 pD，我們一直都沒有辦法搞定他，想了很多種方式去檢查卻都一直檢查失敗，由於我們一直不斷的在一開始的程式碼修補漏洞導致閱讀性極低，到最後反而是已經找到哪裡有漏洞，但在程式中卻看不出來哪裡有漏洞，後來直接砍掉重寫就 AC。下次可以考慮這方法，只要開始知道是錯在哪裡但程式卻想不太出來是哪個部份出問題時，當這環節重複到第三次就可以直接砍掉重寫一份，保持可讀性也好幫助自己接下來的 debug，如果能 AC 是最好啦。</p>
<p>在比賽中途由於紙張過多，當我們要找題目或是找出我們的題目 menu 時都異常困難，到最後甚至直接放棄，都是直接重新印一份，我覺得這樣非常不妥。經常浪費時間在查找紙張，我認為一定有方法可以幫助我們在整理印出來的紙張跟題目卷，這樣才可以有效的在考試當中找到自己所需要的資料也不容易遺失(被其他不相關資料隱藏)。目前想法是準備一個資料夾來放題目嗎？不知道行不行得通。</p>
<p>比賽比到第三小時左右，我與隊友的體力已經越來越差了，我甚至看電腦螢幕會模糊，這點我還需要訓練一下我的體力，太久沒有寫 3hr 以上的程式設計競賽從超過 3hr 以後我的 Coding 能力越來越差思緒也越來越不清楚，最後還需要先趴下來休息一陣子才可以能夠讓體力稍加恢復，但狀況還不是很優，看來運動對我來說也是很重要的一件事之一。</p>
<p>pG 的部分是一份水題，但由於溝通的問題，導致我對於題意理解錯誤而讓我的程式碼寫出來不會是標準答案，學長跟漢軒都在幫我 debug，後來學長直接上去重寫一份之就直接 AC，我覺得這是一個不錯的選擇，當她在重寫一份程式碼時有再重看一次題目就發現學長跟我在溝通上有瑕疵，抓到錯誤後，學長再重新寫一份程式碼上傳就成功 AC，我覺得這是一個很好的成功經驗、也很幸運能夠抓到。我想要複製這次的成功經驗，<strong>我想應該是當你在看寫程式的人想法是錯誤時可以考慮直接用自己的方法重新寫一次，但必須要對自己的想法很有把握，不然就只是在浪費時間寫兩次題目。</strong></p>
<p>如果累了可以去外面適當地走動可以讓自己放鬆或許也可以能夠讓隊友也稍稍放鬆XD。</p>
<p>剩下的題目說難不難，說簡單不簡單，但都有一次 AC，隊友太棒了✧(&gt;o&lt;)ﾉ</p>
<h2 id="比賽結果"><a href="#比賽結果" class="headerlink" title="比賽結果"></a>比賽結果</h2><p>這次比賽的名次其實沒有說到很好，但也沒有到太差。我覺得算是在我們隊伍的水準之間，34 就差不多是我們的區間，我們沒有表現沒有失常已經算是蠻幸運的事情，現在的狀況慢慢的在穩定當中，期望 11 月的 ICPC Region 比賽表現不失常也可以發揮得更好。也謝謝隊友們願意陪我參加演算法比賽，我們都知道這條路上不一定會成功還願意一起努力，真的謝謝各位。</p>
<blockquote>
<p>比賽名次</p>
</blockquote>
<p><img src="/images/ncpc2020_final/8.PNG" alt=""></p>
<h2 id="在-ICPC-2020-時進行頒獎典禮"><a href="#在-ICPC-2020-時進行頒獎典禮" class="headerlink" title="在 ICPC 2020 時進行頒獎典禮"></a>在 ICPC 2020 時進行頒獎典禮</h2><p>在頒獎時，我們的教練也過來一同拍合照，慶祝我們拿到此獎，拿到這獎項非常開心，代表我們又進步了一些，且這次是有加入普通大學的比賽，還有機會拿到 34th，代表我們實力被認可了吧！雖然 ICPC 2020 發揮失常，但還是可以的吧！還需要在加油，真的。</p>
<blockquote>
<p>比賽獎狀</p>
</blockquote>
<p><img src="/images/ncpc2020_final/10.jpg" alt=""></p>
<blockquote>
<p>頒獎典禮照片-A</p>
</blockquote>
<p><img src="/images/ncpc2020_final/12.JPG" alt=""></p>
<blockquote>
<p>頒獎典禮照片-B</p>
</blockquote>
<p><img src="/images/ncpc2020_final/13.JPG" alt=""></p>
<blockquote>
<p>頒獎典禮照片-C</p>
</blockquote>
<p><img src="/images/ncpc2020_final/11.jpg" alt=""></p>
<h2 id="賽後日誌"><a href="#賽後日誌" class="headerlink" title="賽後日誌"></a>賽後日誌</h2><p>比賽完畢後，主辦單位讓我們如果想要帶氣球回家就可以帶氣球回家，於是我就拿了一顆氣球回家綁在機車上，很像馬力歐賽車XD，我都好怕後面的機車騎士看了會覺得我超像智障的XD，但不幸的是她在我騎車的路上因為車速過快就爆炸了ಥ⌣ಥ，在這邊跟大家宣導一下，如果你有綁氣球在機車上需要盡量將低你的車速在約 40km/hr，不然很容易因為車速過快拉扯力道太強而讓氣球破掉…。</p>
<blockquote>
<p>馬力歐賽車</p>
</blockquote>
<div class="video-container"><iframe src="https://www.youtube.com/embed/MFJDjKzm3hI" frameborder="0" loading="lazy" allowfullscreen></iframe></div>

<p>後來學長去查看我們有沒有得獎，沒想到竟然還有！我們有佳作，好開心呀，這樣代表我們可以跟北科領取獎學金了，希望可以領取到拉，每次都覺得學校的行政效率很慢不知道獎學金到底能不能拿到，不過至少現在的我們狀況越來越好了，要繼續保持到 11 月呀，只剩下最後一場大戰 <strong>2020 ICPC TAIWAN　 REIGON</strong></p>
<h2 id="賽後檢討"><a href="#賽後檢討" class="headerlink" title="賽後檢討"></a>賽後檢討</h2><p>對於我參加這次比賽，我將針對幾點進行檢討：</p>
<ul>
<li>檔案整理很重要，我覺得今天檔案管理有點太亂，可以嘗試買一個資料夾管理。</li>
<li>針對每個比賽，要稍微看一下題目規章可以用的 IDE。</li>
<li>5個小時會讓自己的體力明顯不足，比賽的時候需要喝咖啡</li>
<li>滴眼藥水，不然眼睛會模糊</li>
<li>程式碼如果髒了評估後考量，給其他人評估會不會比較適當</li>
<li>適當的在中途進行debug，以免遇到問題</li>
</ul>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>這一次的比賽我並不是主力在負責解題，有點無用武之地，我負責 String，但那題 String 是難題只有一組解開，於是我不敢去嘗試。所以大部分都是在做 Support 的工作，幫助大家手邊的一些雜事，感覺這一次我在做雜事的時候效率並沒有到太好，沒有把雜事分工處理的很優秀，還需要改進。</p>
<p><strong>如果沒辦法成為主力上台打 Code 去 AC 題目，那就要做好 Support 的工作讓前方的主力在需要資源的時候可以最快速的給他不會讓他在思考的過程中還需要翻找答案讓他更加忙碌。我是他的隊友，不是他的敵人。</strong></p>
<p>最後要謝謝家人可以支持我參加演算法這條不歸路，雖然在讀書的過程中家庭沒有辦法讓我完全的去努力準備演算法，總還是有一些事情要溝通，不過還是很感謝自己跟父母可以讓我走到現在，雖然沒有很好的成就但也不是輸的那麼徹底。</p>
]]></content>
      <categories>
        <category>競賽心得</category>
      </categories>
      <tags>
        <tag>大學Life</tag>
        <tag>ICPC</tag>
        <tag>程式比賽</tag>
        <tag>競賽心得</tag>
        <tag>人生旅途</tag>
      </tags>
  </entry>
  <entry>
    <title>QUESTION! 如何在 Hexo or Markdown 插入 youtube 影片呢？</title>
    <url>/2020/10/10/blog/hexo-insert-movie/</url>
    <content><![CDATA[<h2 id="使用-Hexo-or-Markdown-插入影片："><a href="#使用-Hexo-or-Markdown-插入影片：" class="headerlink" title="使用 Hexo or Markdown 插入影片："></a>使用 Hexo or Markdown 插入影片：</h2><blockquote>
<p>此文章教學如何用 Hexo or Markdown 中放入 youtube 影片</p>
</blockquote>
<a id="more"></a>

<h2 id="QUESTION-如何在-Hexo-or-Markdown-插入-youtube-影片呢？"><a href="#QUESTION-如何在-Hexo-or-Markdown-插入-youtube-影片呢？" class="headerlink" title="QUESTION:　如何在 Hexo or Markdown 插入 youtube 影片呢？"></a>QUESTION:　如何在 Hexo or Markdown 插入 youtube 影片呢？</h2><p>把　youtube 的 video id 放入即可，舉例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% youtube video_id %&#125;</span><br></pre></td></tr></table></figure>

<p>video_id 就可以替代成這串 ID， X85DcsKHaUo<br>只要這樣給他就可以搂！</p>
<h2 id="參考連結："><a href="#參考連結：" class="headerlink" title="參考連結："></a>參考連結：</h2><p><a href="https://blog.liaosankai.com/2017/03/21/Hexo%20%E5%82%99%E5%BF%98%E9%8C%84/" target="_blank" rel="noopener">Hexo 備忘錄</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>有了 google 與 hexo 後我可以在 google 搜尋知識並在 hexo 紀錄，謝謝願意再網路上分享知識的各位，沒有你們，我一定沒有辦法讓自己變成現在一樣，肯定比現在還差。我也要努力分享知識，讓其他人可以對於知識更好取得，學得更快。</p>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>TOPC2020 ICPC Asia Taiwan Online Programming Contest - 30th 心得</title>
    <url>/2020/10/11/contest_experence/topc2020/</url>
    <content><![CDATA[<blockquote>
<p>僅此紀錄 2020/10/07 2020 ICPC Asia Taiwan Online Programming Contest 心得<br>「紀錄每個時刻，讓未來的自己不遺忘過去的自己」<br>只有自己才能體會自己的過去<br>僅只有 30th，還需要努力</p>
</blockquote>
<a id="more"></a>

<h2 id="賽前準備"><a href="#賽前準備" class="headerlink" title="賽前準備"></a>賽前準備</h2><p><del>其實根本沒有準備，只是前情概要XD</del><br>統計學下課後，稍微再台北科大第三教學大樓 109 教室準備一下，學長(風平)也過來準備與我一起去買晚餐來吃，不得不說北科往安東街的路上旁邊的公園與大樓真的超漂亮的，途中我們往我最喜歡吃的店<a href="https://www.google.com/search?q=%E5%96%AB%E4%B8%8A%E9%A3%B2&oq=%E5%96%AB%E4%B8%8A%E7%99%AE&aqs=chrome.1.69i57j0i10.11864j0j7&sourceid=chrome&ie=UTF-8" target="_blank" rel="noopener"><strong>喫上飲</strong></a>出發，沒想到她竟然沒開，嗚嗚。不過不能怪他拉，老闆娘在懷孕中不開也是合理的，只能說我沒有福氣可以吃到超級好吃的雞排咖哩飯，真的好想再吃一次！超級好吃的。</p>
<p>建議大家可以去吃，真的棒。但不要在我想吃的時候去吃，這樣讓我要排隊QQ。</p>
<p>由於<a href="https://www.google.com/search?q=%E5%96%AB%E4%B8%8A%E9%A3%B2&oq=%E5%96%AB%E4%B8%8A%E7%99%AE&aqs=chrome.1.69i57j0i10.11864j0j7&sourceid=chrome&ie=UTF-8" target="_blank" rel="noopener"><strong>喫上飲</strong></a>沒開，後來的我跟學長就繼續往安東街在想要吃甚麼，後來就想到好久沒吃的<a href="https://www.google.com/search?sxsrf=ALeKk00Uo0jqi-ozL2j87Hgk6sMkvuHyTg:1602349161886&ei=IueBX6LUDb3FmAWw_IroCQ&q=%E4%BD%90%E8%97%A4%E5%92%96%E5%93%A9&oq=%E4%BD%90%E8%97%A4%E5%92%96%E5%93%A9&gs_lcp=CgZwc3ktYWIQAzIHCCMQ6gIQJzIHCCMQ6gIQJzIHCCMQ6gIQJzIHCCMQ6gIQJzIHCCMQ6gIQJzIHCCMQ6gIQJzIHCCMQ6gIQJzIHCCMQ6gIQJzIHCCMQ6gIQJzIHCCMQ6gIQJzoECAAQRzoFCAAQzQI6BAgjECc6CAgAELEDEIMBOgIIADoECAAQQzoFCAAQsQM6BwgAELEDEEM6CggAELEDEIMBEENQ7-UTWLP0E2Cc9RNoAXACeACAAeADiAG_BZIBBTMuNC0xmAEAoAECoAEBqgEHZ3dzLXdperABCsgBBcABAQ&sclient=psy-ab&ved=2ahUKEwjOo-bkv6rsAhUoyosBHWrQC-4QvS4wAXoECAIQOA&uact=5&npsic=0&rflfq=1&rlha=0&rllag=25032725,121530641,2671&tbm=lcl&rldimm=13616574762961852372&lqi=CgzkvZDol6Tlkpblk6laHgoN5L2Q6JekIOWSluWTqSIN5L2Q6JekIOWSluWTqQ&phdesc=er6MAL0SvX0&rldoc=1&tbs=lrf:!1m4!1u3!2m2!3m1!1e1!1m4!1u2!2m2!2m1!1e1!2m1!1e2!2m1!1e3!3sIAE,lf:1,lf_ui:9&rlst=f#rlfi=hd:;si:6865186108294082278,l,CgzkvZDol6Tlkpblk6laHgoN5L2Q6JekIOWSluWTqSIN5L2Q6JekIOWSluWTqQ,y,Pw2SIZ3QwiA;mv:[[25.044765100000003,121.557935],[25.020686299999998,121.4913793]]" target="_blank" rel="noopener"><strong>佐藤咖哩</strong></a>，這家咖哩我也超喜歡的，超級推。不過由於我們步程較快，他下午 5 點 30 分才開始營業，於是我跟學長稍微聊一下天，等咖哩店營業，看到旁邊有一個肉圓店很有人在排隊，也許下次可以去吃看看呦，我也蠻喜歡吃肉圓的。</p>
<h2 id="比賽開始"><a href="#比賽開始" class="headerlink" title="比賽開始"></a>比賽開始</h2><p>我們還在回來的路上時，學弟(漢軒)就已經吃完晚餐等我們了，我們加緊腳步趕快帶晚餐回 109，當我們回到 109 時已經是比賽前 10 分鐘(17:50)，於是我們就邊吃晚餐邊準備比賽了XD，由於這次比賽是線上比賽所以我們就可以使用 109 的白版來做好我們的題目 MENU 與講解給隊員聽，有一個黑板真的很方便呀。</p>
<p>比賽開始後，漢軒先解決部分題目，漢軒真的好強QQ，他是我們隊伍的中堅呀！學長後來也送出幾題，比賽中非常的順利，我也在解決題目，途中看到一題是屬於我的題目，類型是關於字串的，我就嘗試要把這題給解開，這時候我運用我的演算法知識來解決這題，也順利被我解開了！</p>
<p>但微妙的是，這題只有我被解開，讓我覺得很有成就感XD，連參加過 ICPC world final 的台大都解不開嗎！難道終於可以讓台北科大再度驕傲了嗎(誤，一直到比賽的最後還是只有我把她解開，我的隊友們也都因為這樣而感到興奮，他們讓我講解這題為甚麼我能夠解開，我就告訴他們我怎麼解的，結果學長發現怪怪的，我寫的程式格式跟題目要求的格式不符合但卻可以 AC，我也突然感到意外，我跟隊友們再回去檢查題目卻發現我的程式真的沒有按照題目要求卻被我解開了！</p>
<p>抓到這個錯誤後，我頓時恍然大悟，不是我比其他隊伍優秀，是我比其他隊伍更看不懂英文阿XDDDD，題目說不可以輸出重複的答案，但因為我看不懂英文所以我重複輸出答案可是測資資料的疏忽讓我可以通過這題XD，再根據 TOPC 的規則只要是被送出 AC 的題目就不可以再收回 AC，於是我們還是有算是 AC，沒想到看不懂英文才能看懂題意阿XD，看來英文不好也是個福氣✧(&gt;o&lt;)ﾉ，沒有拉，開玩笑地。英文還是真的很重要，沒有學好英文真的很吃虧，只有這次意外讓我幸運。</p>
<p>比賽結束後，我們的成績是 30th，老實講，這成績對於我們而言是非常好的水準，我們其實從沒想過我們可以到這麼高的名次，希望我們可以好好維持住，讓我們的知識水平繼續維持在這，不要在掉下去，我覺得維持一件事情是非常困難的，因為維持需要耐心與時間，並不是你今天努力就好的。跟我的 blog 一樣，我有耐心維持到現在，也很感謝現在的自己可以為自己付出，也希望未來的自己也可以這麼努力。</p>
<blockquote>
<p>TOPC 比賽名次 30th </p>
</blockquote>
<p><img src="/images/topc2020/1.PNG" alt=""></p>
<h2 id="賽後日誌"><a href="#賽後日誌" class="headerlink" title="賽後日誌"></a>賽後日誌</h2><p>比完賽後，我跟隊員們一起笑我的那題假解，其中不乏出現了許多有趣的名言，例如：「北科英文 &gt; 台大英文」、「小孩子才須要讀好英文，大人都直接通靈題目」之類的有趣玩笑，賽後異常歡樂。真的很開心，好久沒有這麼快樂過了，也好久沒有在演算法這條路上笑得這麼開心了。也許，寫演算法不是為了要讓自己顯得更優秀，而是要從寫演算法的過程中獲得開心與更多創意思維，但由於「比賽」、「學校資源差距」讓我在學習演算法的過程中越來越不開心，今天的意外假解，讓我找回了我為甚麼會這麼努力地在學習演算法的原因。</p>
<p>希望我的演算法能夠越來越強，也能照顧到隊友。讓我的人際、學業、家庭、愛情都可以兼顧好，那應該就是我活著幸福的指標了！</p>
<p>希望我後天的 NCPC2020 final 可以打得漂亮，獲得好成績。</p>
]]></content>
      <categories>
        <category>競賽心得</category>
      </categories>
      <tags>
        <tag>大學Life</tag>
        <tag>ICPC</tag>
        <tag>程式比賽</tag>
        <tag>競賽心得</tag>
        <tag>人生旅途</tag>
      </tags>
  </entry>
  <entry>
    <title>NTUT_Kn1ghts 點點心聚餐</title>
    <url>/2020/10/11/life_experence/Dimdimsum20200920/</url>
    <content><![CDATA[<h2 id="說明"><a href="#說明" class="headerlink" title="說明"></a>說明</h2><blockquote>
<p>記錄我在 2020/09/20 跟參加ICPC 競賽的隊友去餐廳吃飯紀錄<br>謝謝學長(風平) and 學弟(漢軒) 陪我參加這場比賽<br>沒有它們我根本甚麼都沒辦法完成，有他們我才有機會去嘗試夢想</p>
</blockquote>
<a id="more"></a>

<h2 id="出發"><a href="#出發" class="headerlink" title="出發"></a>出發</h2><p>由於學長希望我們隊伍向心力可以更佳凝聚於是請我們去吃頓高級餐廳聊天來增加隊伍的向心力，我們這次吃飯的地點是<a href="https://www.google.com/search?biw=1920&bih=937&sxsrf=ALeKk00uIcLDIAcPQLVWV5rxxC5druh9EQ:1602351132391&ei=IOSBX_ygFvyXr7wPwIOs6AE&q=%E9%BB%9E%E9%BB%9E%E5%BF%83&oq=%E9%BB%9E%E9%BB%9E%E5%BF%83&gs_lcp=CgZwc3ktYWIQAzIECCMQJzICCAAyCAgAELEDEIMBMggIABCxAxCDATIICAAQsQMQgwEyCAgAELEDEIMBMggIABCxAxCDATICCAAyAggAMgIIADoHCCMQ6gIQJzoFCAAQsQM6BAgAEEM6CggAELEDEIMBEENQ4Iu7AVj8l7sBYPKbuwFoAXAAeACAAeUCiAGTCZIBCDEwLjEuMC4xmAEAoAEBqgEHZ3dzLXdperABCsABAQ&sclient=psy-ab&ved=2ahUKEwiisrSQx6rsAhWvxYsBHUzXA1UQvS4wAXoECAMQGg&uact=5&npsic=0&rflfq=1&rlha=0&rllag=25044050,121541722,2564&tbm=lcl&rldimm=1970465232929884137&lqi=Cgnpu57pu57lv4MiA4gBAVoYCgrpu54g6bue5b-DIgrpu54g6bue5b-D&rldoc=1&tbs=lrf:!1m4!1u3!2m2!3m1!1e1!2m1!1e3!3sIAE,lf:1,lf_ui:4&rlst=f#rlfi=hd:;si:13387368021916162519,l,Cgnpu57pu57lv4MiA4gBAVoYCgrpu54g6bue5b-DIgrpu54g6bue5b-D;mv:[[25.0488623,121.571217],[25.0252292,121.49056639999999]]" target="_blank" rel="noopener"><strong>點點心</strong></a>，在網路上評價還蠻不賴的中式料理店，由於信義店可以讓我們訂晚上 7 點的位置但中正店的點點心則不行，於是我們就選擇了信義店用餐，途中我們搭捷運前往點點心信義店。</p>
<p>由於吃飯地點離捷運市政府上最近，於是我們在市政府下車，下車後一往上走就是繁華熱鬧的東區，即使到了晚上也還是燈火通明，不愧是台北的市中心呢！與雖然也是台北的西區就有著些許差別，西區就有點稍微小落後，不過西區的文化與宗教就大於東區了呢。但東區真的好漂亮，蠻令人嚮往的。</p>
<blockquote>
<p>點點心餐廳附近街景</p>
</blockquote>
<p><img src="/images/Dimdimsum20200920/1.jpg" alt=""></p>
<p>途中我們看到一家看似是高級的家具店，裡面的家具與我家簡直是天壤之別阿！我不禁幻想要是我的房間內如果都是這些家具，我一定每天都很期待回家，只要一回家就能夠有好心情。雖然我現在每天也很期待回家，上學好累，讀書更累。ಥ⌣ಥ</p>
<blockquote>
<p>精緻的家具店</p>
</blockquote>
<p><img src="/images/Dimdimsum20200920/2.jpg" alt=""></p>
<h2 id="用餐拉"><a href="#用餐拉" class="headerlink" title="用餐拉"></a>用餐拉</h2><p>我們點了蠻多道菜的XD，詳細菜名已經有點忘記了，但有一道我印象非常深刻叫做龜兔賽跑，他是用兩個不同的包子組成，但價錢卻比單點那兩個不同的包子還貴XDDD，商人手法欸wwww，我把這兩個不同包子組合在一起，再多一個裝飾品就可以增加價錢了，YA。可惡，一定是我太窮了，才會注意到這種小細節，畢竟他們差額只差 30 元，有錢人應該不在意拉XD。</p>
<blockquote>
<p>龜兔賽跑的烏龜</p>
</blockquote>
<p><img src="/images/Dimdimsum20200920/3.jpg" alt=""></p>
<blockquote>
<p>龜兔賽跑的兔兔</p>
</blockquote>
<p><img src="/images/Dimdimsum20200920/5.jpg" alt=""></p>
<blockquote>
<p>只剩下一半的烏龜</p>
</blockquote>
<p><img src="/images/Dimdimsum20200920/4.jpg" alt=""></p>
<p>然後點點心只要是關於蝦子的菜色都點，點爆，超級好吃的、超級讚。點點心的蝦類我超喜歡，然後有一道飯對我而言有點貴而且沒有很好吃QQ，有點小雷。大家可以考慮避開他XD，如果你的口味偏好跟我差不多的話。</p>
<blockquote>
<p>我覺得不好吃的飯與超好吃的蝦蝦</p>
</blockquote>
<p><img src="/images/Dimdimsum20200920/6.jpg" alt=""></p>
<p>豆花很嫩，很好吃，那是我吃過的最棒的豆花之一了，可惜是我覺得分量有點太小一個大男生可能會覺得只是塞牙縫而已，好想用放大燈把豆花變大呀！吃飽喝足後沒想到這一餐價錢要 $2000，對不起學長，讓你破費了，希望我 ICPC 可以好好努力不讓你失望。</p>
<h2 id="飯後漫步"><a href="#飯後漫步" class="headerlink" title="飯後漫步"></a>飯後漫步</h2><p>吃飽後，由於很久沒有來東區逛逛了就在東區的街道上漫步，東區很多高級名牌貨，對於一個沒什麼錢的大學生來說每個包包都像是天價一樣，或許比我的價值還高呢！嗚嗚，我好廉價，我要努力讓我自己的價值提升，怎麼可以比一個包包還要便宜呢，不行啦。</p>
<blockquote>
<p>高級的包包 </p>
</blockquote>
<p><img src="/images/Dimdimsum20200920/7.jpg" alt=""></p>
<p>再往前走已經快要到 101 大樓了，在東區漫步是件很享受的事情，入秋的東區有著微微涼風吹拂，即使漫步也不會流汗，還看到一個很帥的男生在廣告牆上，可惡，他竟然可以讓我走在路上的時候內心直接冒出好帥的想法，難道..難道我比他不好看嗎ಥ⌣ಥ，途中看到某一棟大樓與 101 大樓快要一樣高了，他們兩個大樓是不是在互相較勁，比誰還要高呢XD，哈哈哈，一個工程師的奇怪幻想拉，也許我太小孩子了，才會有這種可愛想法吧！</p>
<blockquote>
<p>廣告牆上很帥的男生</p>
</blockquote>
<p><img src="/images/Dimdimsum20200920/8.jpg" alt=""></p>
<blockquote>
<p>兩棟互相比誰高的大樓</p>
</blockquote>
<p><img src="/images/Dimdimsum20200920/9.jpg" alt=""></p>
<h2 id="返程"><a href="#返程" class="headerlink" title="返程"></a>返程</h2><p>漫步結束後，我們再次回到捷運市政府站準備回家休息，在等車的過程中看到一個很嚇人的廣告呀，現在的廣告不是很嚇人就是很帥，不能來點溫馨的嗎QQ，何況這隻狗很逼真又很嚇人，他知道這對一個怕狗的男生來說可能會讓他連捷運都不敢搭呢ಥ⌣ಥ，明明只是一個狗糧廣告，不要這樣啦…</p>
<blockquote>
<p>很逼真的狗與狗糧廣告</p>
</blockquote>
<p><img src="/images/Dimdimsum20200920/10.jpg" alt=""></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>我很謝謝學長願意為了團隊這樣付出，我覺得學長絕對是支撐起這團隊的最大功臣，願意破費也願意花時間再行政付出，即使這對他可能不會有太多好處他也願意幫助我們這支團隊，我很感謝他。希望我在比賽時不會讓他失望讓他對這團隊的付出是有回報的，那就是我對他的責任。</p>
]]></content>
      <categories>
        <category>人生旅途</category>
      </categories>
      <tags>
        <tag>大學Life</tag>
        <tag>人生旅途</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa10163 - Storage Keepers (Knapsack Problem)</title>
    <url>/2020/10/12/UVa/UVa10163/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>有 X 的倉庫需要有人看守，每個人可以看守多個倉庫，但一個倉庫只能被一人看守，看守的規定如下：<br>每位看守人員的能力值與報酬相同<br>如果要讓一看守人員看多個倉庫則其能力值會依照此公式下降 <strong>\( \text{倉庫安全值} = \text{看守人員能力值} / \text{倉庫數量} \)</strong>，有小數點時取整數。<br>目標是要讓我們花費在看守人員的<strong>報酬最低</strong>並讓倉庫的<strong>安全值最高</strong>。</p>
</blockquote>
<a id="more"></a>

<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>這題是變化背包問題，不懂背包問題的觀眾可以看一下此<a href="https://www.csie.ntu.edu.tw/~sprout/algo2019/ppt_pdf/week09/DP-2-inclass.pdf" target="_blank" rel="noopener">連結</a>，不愧是台大的教學材料，質量好到一個極致阿。要是我高中有找點翻到這個資料我一定可以學得更快！，可惜現在的我已經學會了QAQ，想到過去學動態規劃就覺得好辛苦呀..orz。</p>
<p>不過這題必須要用兩個 DP 來解決…，太棒了！這還是我第一次遇到要用兩個 DP 問題去解決題目，我原本一開始以為用一個背包問題去記錄現在的最大安全就好，但沒有考慮到有可能相同的最大安全可能會有不同種的成本，老了，真的老人。已經不是那個刷題大師了。ಥ⌣ಥ</p>
<p>這題要用到兩個 DP，分別是尋找<strong>報酬最低</strong>與<strong>安全值最高</strong>。</p>
<h2 id="背包問題：安全值最高"><a href="#背包問題：安全值最高" class="headerlink" title="背包問題：安全值最高"></a>背包問題：安全值最高</h2><p>這裡其實應該是一個普通的背包問題，但有一個重點要考慮的是公式 \( \text{倉庫安全值} = \text{看守人員能力值} \ \text{倉庫數量} \)，所以這裡需要用到 <code>min(dp[j-k] , val[i] / k )</code>來確保有符合公式的條件。</p>
<p>而這段 min 程式碼是怎麼意思呢？分析一下吧！</p>
<ul>
<li><code>dp[j-k]</code><br>如果前面沒有的倉庫還沒有還沒有被人看守(沒有被看守設值為 0)，於是用這個去判定倉庫有沒有被人看守，如果沒有會因為 min 的關係把現在這個倉庫也先設定成無人看守。</li>
<li><code>val[i] / k</code><br>配合公式讓一個看守人員去管理多個倉庫</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max_safe</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; N ; i++) <span class="comment">//init</span></span><br><span class="line">        dp[i] = <span class="number">0</span> ;</span><br><span class="line">    dp[<span class="number">0</span>] = INF ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; m ; i++)&#123; <span class="comment">//worker</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = n ; j &gt; <span class="number">0</span> ; j--)&#123; <span class="comment">//storage</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span> ; k &lt;= j &amp;&amp; val[i] &gt;= k ; k++)&#123; <span class="comment">//看守幾個倉庫</span></span><br><span class="line">            <span class="comment">// val[i] &gt;= k 不讓公式的值小於 1</span></span><br><span class="line">                dp[j] = max(dp[j] , min(dp[j-k] , val[i] / k ));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n] ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="背包問題：01-PROBLEM、報酬最低"><a href="#背包問題：01-PROBLEM、報酬最低" class="headerlink" title="背包問題：01 PROBLEM、報酬最低"></a>背包問題：01 PROBLEM、報酬最低</h2><p>當我們已經有了安全值最高後接下來就要找出報酬最低的數值是多少了，這就是標準的 01 背包問題，我們要怎麼樣選擇工人才能達到報酬率最低。配合上一維陣列壓縮即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min_cost</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cost==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span> ; <span class="comment">//由於安全性為 0、題目說明工人成本等於安全性，於是安全性為 0 成本也為 0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= n ; i++) <span class="comment">//init</span></span><br><span class="line">        dp[i] = INF ;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; m ; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = n ; j &gt; <span class="number">0</span> ; j--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = min(j , val[i] / cost ) ; k &gt; <span class="number">0</span> ; k--)&#123;</span><br><span class="line">                dp[j] = min(dp[j] , dp[j-k] + val[i]);</span><br><span class="line">                <span class="comment">//debug</span></span><br><span class="line">                <span class="comment">//cout &lt;&lt; j &lt;&lt; ' ' &lt;&lt; dp[j] &lt;&lt; ' ' &lt;&lt; dp[j-k] + val[i] &lt;&lt; '\n' ;</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n] ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://blog.csdn.net/keshuai19940722/article/details/11861717" target="_blank" rel="noopener">uva 10163 - Storage Keepers(01背包）</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>這題背包問題其實難倒了我了qqq，我一開始寫真的沒有把它想得太深，誤把它當作背包問題的水題帶過(害自己花了 20 min 在思考我怎麼沒有寫對)，下次要能夠多想一點啊！剛好今天也刷了一個經驗值可以讓我在變更優秀些，知道更多知識。也謝謝網路上的大神們分享程式碼讓我可以學習，今天也從<strong>JeraKrs</strong>學習到了一些比我更棒的命名規則，讓我的腦袋瓜有了更多知識，也謝謝學弟(承恩)給我這題讓我磨練，讓我可以把我的動態規劃知識複習一下，已經好久沒有練習動態規劃，都在寫字串演算法，嗚嗚。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>其實就是沒有附上說明的程式碼，我也花了兩個小時撰寫文章，看得懂跟說得出來真的是兩回事，也許還有人覺得我說的很差，不過我已經盡力解釋。希望可以幫助到各位。</p>
<p>也希望大家想要學習的知識都可以快速學習而成，不要因為自身的環境不足而學習不到。</p>
<p>於是這裡就補述一些題目給的資料範圍限制與標頭檔了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 110</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 40</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 1 &lt;&lt; 30</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n , m , dp[N] , val[N] , cost ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max_safe</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; N ; i++)</span><br><span class="line">        dp[i] = <span class="number">0</span> ;</span><br><span class="line">    dp[<span class="number">0</span>] = INF ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; m ; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = n ; j &gt; <span class="number">0</span> ; j--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span> ; k &lt;= j &amp;&amp; val[i] &gt;= k ; k++)&#123;</span><br><span class="line">                dp[j] = max(dp[j] , min(dp[j-k] , val[i] / k ));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n] ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min_cost</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cost==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= n ; i++)</span><br><span class="line">        dp[i] = INF ;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; m ; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = n ; j &gt; <span class="number">0</span> ; j--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = min(j , val[i] / cost ) ; k &gt; <span class="number">0</span> ; k--)&#123;</span><br><span class="line">                dp[j] = min(dp[j] , dp[j-k] + val[i]);</span><br><span class="line">                <span class="comment">//debug</span></span><br><span class="line">                <span class="comment">//cout &lt;&lt; j &lt;&lt; ' ' &lt;&lt; dp[j] &lt;&lt; ' ' &lt;&lt; dp[j-k] + val[i] &lt;&lt; '\n' ;</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n] ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &amp;&amp; (n || m) )&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; m ; i++)</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; val[i] ;</span><br><span class="line">        cost = max_safe() ;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; cost &lt;&lt; <span class="string">' '</span> &lt;&lt; min_cost() &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="用紙筆去模擬-Knapsack-Problem"><a href="#用紙筆去模擬-Knapsack-Problem" class="headerlink" title="用紙筆去模擬 Knapsack Problem"></a>用紙筆去模擬 Knapsack Problem</h2><p>因為只是自己在思考過程中隨手做的筆記，覺得不是對讀者這麼有幫助，因此放在文章最下面。</p>
<p>有時候用想或用看的可能不太能夠懂這演算法，那就用寫的吧！這是大衛我自己解這題動態規劃的手稿，如果我文字沒有幫助的話可以考慮看看我的手稿來釐清觀念XD，希望可以幫助到你。</p>
<p><img src="/images/UVa10163/2.jpg" alt=""><br><img src="/images/UVa10163/1.jpg" alt=""></p>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>背包問題 Knapsack Problem</tag>
        <tag>動態規劃 Dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title>統計學(一) 筆記 - 第三章B</title>
    <url>/2020/10/15/NTUT_note/statistcs-ch3B/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊與財金管理系大二上統計學重點整理<br><font color="#dd0000">並非所有人都適用，部分對我而言稍加容易的內容並不會寫在此內。</font><br><strong>這是觀看影片心得後的筆記，老師上課可能不太適用會忘記抄到</strong></p>
</blockquote>
<a id="more"></a>

<h2 id="3B-介紹-Descriptive-Statistics-Numerical-Measures-數值方式"><a href="#3B-介紹-Descriptive-Statistics-Numerical-Measures-數值方式" class="headerlink" title="3B 介紹 - Descriptive Statistics: Numerical Measures(數值方式)"></a>3B 介紹 - Descriptive Statistics: Numerical Measures(數值方式)</h2><p>敘述統計,too。</p>
<h3 id="Measures-of-Distribution-Shape-分配形狀度量"><a href="#Measures-of-Distribution-Shape-分配形狀度量" class="headerlink" title="Measures of Distribution Shape 分配形狀度量"></a>Measures of Distribution Shape 分配形狀度量</h3><h4 id="Skewness-偏態"><a href="#Skewness-偏態" class="headerlink" title="Skewness 偏態"></a>Skewness 偏態</h4><p>公式如下:</p>
<blockquote>
<p><img src="/images/statistics-ch3B/1.PNG" alt=""></p>
</blockquote>
<p>如果圖片剛好是具有左右對稱性則 \(Skewness = 0 \)，往右偏則 \(Skewness &gt; 0 \) ，往左偏則是 \(Skewness &lt; 0 \)，負數表如下圖：</p>
<blockquote>
<p><img src="/images/statistics-ch3B/2.PNG" alt=""></p>
</blockquote>
<ul>
<li>Highly Skewed Right<br>右偏 &gt; 1，通常平均數會比中位數來的更高。</li>
<li>關於 Skewness 的平均數、中位數的比較如下：<blockquote>
<p><img src="/images/statistics-ch3B/3.PNG" alt=""></p>
</blockquote>
</li>
</ul>
<h5 id="QUESTION-左偏的意思是甚麼？"><a href="#QUESTION-左偏的意思是甚麼？" class="headerlink" title="QUESTION: 左偏的意思是甚麼？"></a>QUESTION: 左偏的意思是甚麼？</h5><p>就是左邊的資料比較少，重心在右邊則叫左偏。</p>
<h4 id="Z-Scores-Z-分數"><a href="#Z-Scores-Z-分數" class="headerlink" title="Z-Scores Z 分數"></a>Z-Scores Z 分數</h4><p>某一數值離母體平均值差幾個標準差，標準差公式如下：</p>
<blockquote>
<p><img src="/images/statistics-ch3B/4.PNG" alt=""></p>
</blockquote>
<ul>
<li>Z-Score &gt; 0 表示數值比平均數大，Z-Score 則代表離幾個標準差遠</li>
<li>Z-Score &lt; 0 表示數值比平均數小，Z-Score 則代表離幾個標準差遠</li>
</ul>
<h4 id="Chebyshev’s-Theorem-柴比雪夫定理"><a href="#Chebyshev’s-Theorem-柴比雪夫定理" class="headerlink" title="Chebyshev’s Theorem 柴比雪夫定理"></a>Chebyshev’s Theorem 柴比雪夫定理</h4><p>用於知道資料分布位置，<strong>用心看圖片裡面文字XD</strong>。</p>
<blockquote>
<p><img src="/images/statistics-ch3B/5.PNG" alt=""></p>
</blockquote>
<h5 id="Chebyshev’s-Theorem-舉例"><a href="#Chebyshev’s-Theorem-舉例" class="headerlink" title="Chebyshev’s Theorem 舉例"></a>Chebyshev’s Theorem 舉例</h5><blockquote>
<p><img src="/images/statistics-ch3B/6.PNG" alt=""></p>
</blockquote>
<p>可以得知 Chebyshev’s Theorem 預估有 509 ~ 673 裡面有百分之 56% 的資料，但事實上有 86% 的資料在 509 ~ 673 之間，Chebyshev’s Theorem 屬於比較保守的知道資料分布位置。</p>
<h4 id="Empirical-Rule-經驗法則"><a href="#Empirical-Rule-經驗法則" class="headerlink" title="Empirical Rule 經驗法則"></a>Empirical Rule 經驗法則</h4><p>當資料大約是鐘型分布時可以用 Empirical Rule 來查看有有多少資料分布在某個特定的標準差裡面，此原理是用常態分配推算出。</p>
<p>看圖說故事拉XD</p>
<blockquote>
<p><img src="/images/statistics-ch3B/7.PNG" alt=""></p>
</blockquote>
<h4 id="Detecting-Outliers-離群值"><a href="#Detecting-Outliers-離群值" class="headerlink" title="Detecting Outliers 離群值"></a>Detecting Outliers 離群值</h4><p>找出極端數值使用離群值，也可用於找出資料錯誤，看圖說明：</p>
<blockquote>
<p><img src="/images/statistics-ch3B/8.PNG" alt=""></p>
</blockquote>
<h4 id="Five-Number-Summary-and-Box-Plox-五數彙整-和-箱型圖"><a href="#Five-Number-Summary-and-Box-Plox-五數彙整-和-箱型圖" class="headerlink" title="Five-Number Summary and Box Plox 五數彙整 和 箱型圖"></a>Five-Number Summary and Box Plox 五數彙整 和 箱型圖</h4><h5 id="QUESTION-Five-Number-Summary-哪五數"><a href="#QUESTION-Five-Number-Summary-哪五數" class="headerlink" title="QUESTION: Five-Number Summary 哪五數?"></a>QUESTION: Five-Number Summary 哪五數?</h5><ul>
<li>Smallest Value 最小值</li>
<li>First Quartile 第一分位(25%)</li>
<li>Median 中位數</li>
<li>Thrid Quartile 第三分位(75%)</li>
<li>Larget Value 最大值</li>
</ul>
<h5 id="Box-Plox-箱型圖"><a href="#Box-Plox-箱型圖" class="headerlink" title="Box Plox 箱型圖"></a>Box Plox 箱型圖</h5><p>基礎是 Five-Number Summary，也可看出離群值的圖。<br>箱型圖怎麼畫，在這裡！</p>
<blockquote>
<p><img src="/images/statistics-ch3B/9.PNG" alt=""></p>
</blockquote>
<h3 id="Measures-of-Association-Between-Two-Variables-兩個變數的關係"><a href="#Measures-of-Association-Between-Two-Variables-兩個變數的關係" class="headerlink" title="Measures of Association Between Two Variables 兩個變數的關係"></a>Measures of Association Between Two Variables 兩個變數的關係</h3><p>把散佈圖切成4塊，如果散佈圖數值集中在一、三象限代表有線性關係，二、四象限也是，如果數值散步則代表沒有線性關系。</p>
<h3 id="Covariance-共變異數"><a href="#Covariance-共變異數" class="headerlink" title="Covariance 共變異數"></a>Covariance 共變異數</h3><p>當共變異數為負時表示當一方正成長另一方則會反向成長，反之亦同。</p>
<p>公式如下：</p>
<blockquote>
<p><img src="/images/statistics-ch3B/10.PNG" alt=""></p>
</blockquote>
<p>舉例如下：</p>
<blockquote>
<p><img src="/images/statistics-ch3B/11.PNG" alt=""></p>
</blockquote>
<h3 id="Correlation-Coefficient-相關係數"><a href="#Correlation-Coefficient-相關係數" class="headerlink" title="Correlation Coefficient 相關係數"></a>Correlation Coefficient 相關係數</h3><p>只能說兩變數有相關性，不可以說哪個變數影響誰。<br>公式如下：</p>
<blockquote>
<p><img src="/images/statistics-ch3B/12.PNG" alt=""></p>
</blockquote>
<p>Correlation Coefficient 介於 1 與 -1 之間，越接近 -1 代表有很強烈的負相關、接近 1 代表有強烈的正相關，如果是 0 代表沒關係，<del>與我無關</del>。</p>
<p>舉例：</p>
<blockquote>
<p><img src="/images/statistics-ch3B/13.PNG" alt=""><br><img src="/images/statistics-ch3B/14.PNG" alt=""></p>
</blockquote>
<h2 id="Data-Dashboards-資料儀表板"><a href="#Data-Dashboards-資料儀表板" class="headerlink" title="Data Dashboards 資料儀表板"></a>Data Dashboards 資料儀表板</h2><p>把圖表或是數值分析放在同一塊螢幕上。</p>
]]></content>
      <categories>
        <category>北科上課筆記</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>統計學筆記</tag>
        <tag>北科大二上統計學筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>演算法知識 - Suffix Array 後綴陣列</title>
    <url>/2020/10/19/Explain_Algorithm/Suffix-Array/</url>
    <content><![CDATA[<h2 id="Suffix-Array-介紹"><a href="#Suffix-Array-介紹" class="headerlink" title="Suffix Array 介紹"></a>Suffix Array 介紹</h2><blockquote>
<p>對某一字串的所有後綴進行字典排序，常用於全文索引、數據壓縮算法與生物資訊學。<br>這裡介紹的演算法寫法時間複雜度為 \(O(n \log n)\)</p>
</blockquote>
<h2 id="Suffix-Array-原理"><a href="#Suffix-Array-原理" class="headerlink" title="Suffix Array 原理"></a>Suffix Array 原理</h2><p>Suffix Array 主要是用 \(sa\) and \(rk\) 這兩個陣列組合而成。<br>且滿足此性質 \(sa[rk[i]] = rk[sa[i]] = i \)</p>
<p>Suffix Array 圖示說明：<br><img src="/images/Suffix-Array/1.png" alt=""></p>
<h3 id="QUESTION-1-sa-suffix-array-用途是甚麼呢？"><a href="#QUESTION-1-sa-suffix-array-用途是甚麼呢？" class="headerlink" title="QUESTION 1: sa (suffix array) 用途是甚麼呢？"></a>QUESTION 1: sa (suffix array) 用途是甚麼呢？</h3><p>\(sa[i]\) 表示此字串所有後綴排序後第 i 大的 index。</p>
<h3 id="QUESTION-2-rk-rank-array-用途是甚麼呢？"><a href="#QUESTION-2-rk-rank-array-用途是甚麼呢？" class="headerlink" title="QUESTION 2: rk (rank array) 用途是甚麼呢？"></a>QUESTION 2: rk (rank array) 用途是甚麼呢？</h3><p>\(rk[i]\) 表示此字串所有後綴排序後，字串中 index 後綴的排名。</p>
<h3 id="QUESTION-3-甚麼是所有後綴？"><a href="#QUESTION-3-甚麼是所有後綴？" class="headerlink" title="QUESTION 3: 甚麼是所有後綴？"></a>QUESTION 3: 甚麼是所有後綴？</h3><blockquote>
<p>從第 i 個字元開始到最後一個字元的字串，i 的範圍是 string[0] ~ string.length()<br>所有後綴舉例如下，舉例單字為 <strong>apple</strong>：</p>
</blockquote>
<ul>
<li>apple</li>
<li>pple </li>
<li>ple</li>
<li>le</li>
<li>e</li>
</ul>
<a id="more"></a>

<h2 id="Suffix-Array-實現與說明"><a href="#Suffix-Array-實現與說明" class="headerlink" title="Suffix Array 實現與說明"></a>Suffix Array 實現與說明</h2><p>在實現這個做法時需要用到倍增思想。</p>
<h3 id="QUESTION-倍增是甚麼？"><a href="#QUESTION-倍增是甚麼？" class="headerlink" title="QUESTION: 倍增是甚麼？"></a>QUESTION: 倍增是甚麼？</h3><p>倍增是寫程式中經常用到的一種加速程式執行效率的想法之一，通常是把一個問題拆成兩個子問題且這兩個子問題的問題邏輯相同，於是就使用一次寫法來加速效率。</p>
<p>倍增經典範例：<a href="https://oi-wiki.org/math/quick-pow/" target="_blank" rel="noopener">快速冪 OI wiki</a></p>
<h3 id="回歸焦點"><a href="#回歸焦點" class="headerlink" title="回歸焦點"></a>回歸焦點</h3><p>OK，解釋完倍增的想法後就要繼續探討 Suffix Array，我們先對字串中每個字元(長度為\(1\))進行排序，再來我們對字串中以每個字元開始長度為 2 的倍數開始進行排序，這裡我們假設字串除了原先的字元之外，之後的 index 全部都是空字元，方便我們對演算法的編寫。<del>記憶體很大，我們從沒在怕的，科技真讚</del></p>
<p><strong>我們這裡字串的第一個 index 由 1 開始，方便我們程式編寫，建議使用者也這樣做</strong>，只需要在 string A 前面加一空格。</p>
<p>倍增排序圖示說明：<br><img src="/images/Suffix-Array/2.png" alt=""></p>
<p>其中如果黑線只有一條而沒有類似於勾勾的黑線(通常都在字串右方)，可以直接把她想像成此字串後面其實還有字元，但都是「空白字元」，如果這樣假設那讀者勢必會更快理解XD。我自己把她這樣解釋後才能理解，我腦袋真笨QQQQ，雜牌軍日常呀。</p>
<h3 id="基數排序"><a href="#基數排序" class="headerlink" title="基數排序"></a>基數排序</h3><p>如果不懂基數排序可以先看<a href="https://theriseofdavid.github.io/2020/10/20/Explain_Algorithm/radix-sort/" target="_blank" rel="noopener">演算法知識 - Radix Sort 基數排序</a></p>
<p>由於字串比較的時間複雜度是 \(O(n)\)，跟一般數字比較不一樣，因此如果這裡直接使用 STL 函數庫中的 std::sort 會讓此演算法時間複雜度來到 \(O(n \log^2 n)\)，於是這裡推薦使用非比較型排序，<strong>基數排序</strong>，透過這種排序方式來躲開字串的時間比較複雜度才可以讓 Suffix Array 的時間複雜度降到 \(O(n \log n)\)</p>
<p>是不是已經被冗長的文字敘述搞到頭暈了？沒關係，這裡準備了程式碼已經逐行註解，希望可以讓各位讀者都能比我更快速的讀懂 Suffix Array</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> sa[N] , rk[N&lt;&lt;<span class="number">1</span>] , oldrk[N&lt;&lt;<span class="number">1</span>] , id[N] , cnt[N] ;</span><br><span class="line"><span class="comment">// id = 舊的 sa 排名 , cnt 在 radix sort 時幫助</span></span><br><span class="line"><span class="keyword">int</span> n , m , maxn , lenA , lenB , flag =<span class="number">0</span> ;</span><br><span class="line"><span class="comment">// n 字串長度 , m 文字的最大長度</span></span><br><span class="line"><span class="built_in">string</span> strA ;</span><br><span class="line"><span class="comment">// 要進行 suffix array 的字串，請記住這裡的字串第一個 index 為 1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_sa</span><span class="params">()</span></span>&#123; <span class="comment">//build suffix array</span></span><br><span class="line">    <span class="keyword">int</span> i , m , p , w ; </span><br><span class="line">    <span class="comment">// 在這邊把常在迴圈使用的變數名稱拉出來宣告，以避免不斷宣告造成的效率浪費</span></span><br><span class="line">    n = strA.length()<span class="number">-1</span> ; <span class="comment">//減去 string[0] 的空格</span></span><br><span class="line">    m = max(n , <span class="number">300</span> ); <span class="comment">// 由於 ascii 上限是 255，我們這邊直接開 300</span></span><br><span class="line">    <span class="comment">// 也省去把字元 hash 的麻煩</span></span><br><span class="line">    <span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="keyword">sizeof</span>(cnt)); <span class="comment">//重設 cnt 陣列以免多次使用時與上次使用的值混亂在其中</span></span><br><span class="line">    <span class="built_in">memset</span>(rk,<span class="number">0</span>,<span class="keyword">sizeof</span>(rk)); <span class="comment">//重設 rk 陣列以免多次使用時與上次使用的值混亂在其中</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// **** radix sort 排序開始 ****</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span> ; i &lt;= n ; i++) ++cnt[rk[i] = (<span class="keyword">int</span>)strA[i]] ;</span><br><span class="line">    <span class="comment">// rk[i] = (int) strA[i] 每一個字元在字串中排名</span></span><br><span class="line">    <span class="comment">//++cnt[rk[i] = (int)strA[i]] radix sort 分類</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span> ; i &lt;= m ; i++) cnt[i] += cnt[i<span class="number">-1</span>] ; </span><br><span class="line">    <span class="comment">//將 cnt 遞增排序方便之後找出數值排在第幾位</span></span><br><span class="line">    <span class="keyword">for</span>(i = n ; i &gt;= <span class="number">1</span> ; i--) sa[cnt[rk[i]]--] = i ;</span><br><span class="line">    <span class="comment">// cnt[rk[i]] 先找出字元在字串中排名再透過 cnt 找出他應該排在第幾位</span></span><br><span class="line">    <span class="comment">// 隨後進行 cnt[rk[i]]--，方便下一個值得排序位置。</span></span><br><span class="line">    <span class="comment">// **** radix sort 排序結束 ****</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(w = <span class="number">1</span> ; w &lt; n ; w &lt;&lt;= <span class="number">1</span>)&#123; <span class="comment">// 倍增思想開始</span></span><br><span class="line">        <span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="keyword">sizeof</span>(cnt)); <span class="comment">//第一次 radix sort 開始，排序關鍵為後者</span></span><br><span class="line">        <span class="comment">// 最好範例：倍增排序圖中黑色粗線類似於勾勾的斜線，下方解釋 A 圖中</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span> ; i &lt;= n ; i++) id[i] = sa[i] ;</span><br><span class="line">        <span class="comment">// id 用來記錄現在排序的順序，配合這次的 radix sort 再進行更動</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span> ; i &lt;= n ; i++) ++cnt[rk[id[i]+w]] ;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span> ; i &lt;= m ; i++) cnt[i] += cnt[i<span class="number">-1</span>] ;</span><br><span class="line">        <span class="keyword">for</span>(i = n ; i &gt;= <span class="number">1</span> ; i--) sa[cnt[rk[id[i]+w]]--] = id[i] ;</span><br><span class="line">        <span class="comment">// radix sort 與一開始相同，只是多增加 w，因為排序關鍵為後者</span></span><br><span class="line">        <span class="comment">// 第一次 radix sort 結束</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二次 radix sort 開始，排序關鍵為前者</span></span><br><span class="line">        <span class="built_in">memset</span>(cnt, <span class="number">0</span> , <span class="keyword">sizeof</span>(cnt));</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span> ; i &lt;= n ; i++) id[i] = sa[i] ;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span> ; i &lt;= n ; i++) ++cnt[rk[id[i]]] ;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span> ; i &lt;= m ; i++) cnt[i] += cnt[i<span class="number">-1</span>] ;</span><br><span class="line">        <span class="keyword">for</span>(i = n ; i &gt;= <span class="number">1</span> ; i--) sa[cnt[rk[id[i]]]--] = id[i] ;</span><br><span class="line">        <span class="comment">// 第二次 radix sort 結束</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根據 radix sort 在排列一次 rank </span></span><br><span class="line">        <span class="built_in">memcpy</span>(oldrk , rk , <span class="keyword">sizeof</span>(rk)); <span class="comment">//複製 rank 來幫助 rank 間的交換</span></span><br><span class="line">        <span class="keyword">for</span>(p = <span class="number">0</span> , i = <span class="number">1</span> ; i &lt;= n ; i++)&#123; <span class="comment">// p 為 rank 的等級，i 則是資料</span></span><br><span class="line">            <span class="keyword">if</span>(oldrk[sa[i]] == oldrk[sa[i<span class="number">-1</span>]] &amp;&amp; </span><br><span class="line">               oldrk[sa[i] + w] == oldrk[sa[i<span class="number">-1</span>] + w])</span><br><span class="line">               <span class="comment">//如果與前一個 rank 值是相同則理應現在應該也要相同</span></span><br><span class="line">               <span class="comment">//最好範例：倍增排序圖示說明第一次排序的 rank[4~7], index 從 1 開始，</span></span><br><span class="line">               <span class="comment">//下方解釋 B 圖中</span></span><br><span class="line">                rk[sa[i]] = p ; <span class="comment">//rank 字典排序不變</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                rk[sa[i]] = ++p ; <span class="comment">//rank 字典排序增加</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//debug 輸出測試，以驗證是否正確</span></span><br><span class="line"><span class="comment">//    cout &lt;&lt; "Suffix Array is:\n" ;</span></span><br><span class="line"><span class="comment">//    for(int i = 1 ; i &lt;= n ; i++)&#123;</span></span><br><span class="line"><span class="comment">//        cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; strA.substr(sa[i]) &lt;&lt; ' ' &lt;&lt;sa[i] &lt;&lt; '\n' ;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>解釋 A 圖<br><img src="/images/Suffix-Array/3.PNG" alt=""></li>
<li>解釋 B 圖<br><img src="/images/Suffix-Array/4.PNG" alt=""></li>
</ul>
<h2 id="最長共同前綴-Longest-Common-Prefix-Array-LCP"><a href="#最長共同前綴-Longest-Common-Prefix-Array-LCP" class="headerlink" title="最長共同前綴 Longest Common Prefix Array (LCP)"></a>最長共同前綴 Longest Common Prefix Array (LCP)</h2><p>定義 height = Longest Common Prefix Array<br>道理其實相當簡單，我們的 Suffix Array 是字典排序，於是我們可以推出一公式 \(height[i] = lcp(sa[i],sa[i-1]\)，也就是讓第 i 名的後綴去跟前一名後綴算出最長共同前綴。</p>
<p>\(height[1] = 0\)，由於我們的 string index 是從 1 開始，所以 1 只能夠跟 0 比無意義因而設成 0。</p>
<p>因為 height 他每個 index 都是獨立並沒有相關性，我們的比較方式是根據字串中的每個後綴由字串 index 順序，去找出他的 sa -1 位置去找出 lcp 長度，下一次則是找 index +1 的後綴與他的 sa-1 位置去找出 lcp 長度，由於比較的字串只是刪除上一個前綴的第一個字元，於是 lcp 長度最差則是 lcp -1(前提為 lcp &gt; 0)，所以可以直接從 index + lcp 的長度直接比較，可以減少重複比較，以達到降低時間複雜度。</p>
<p>時間複雜度是 \(O(n)\)。</p>
<p>如果還是聽不太懂，感覺有點紙上談兵，就讓我用程式碼來解釋吧！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_lcp</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lcp[N] = &#123;&#125; ;</span><br><span class="line">    <span class="keyword">int</span> max_lcp = <span class="number">0</span> ; <span class="comment">// max_lcp 最大長度</span></span><br><span class="line">    <span class="comment">//k 為現在 i 名的後綴與前一名後綴長度算出的最長共同前綴</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> , k = <span class="number">0</span> ; i &lt;= n ; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(k) k-- ; </span><br><span class="line">        <span class="comment">// 由於我們下次是把字串 index 在往後一個 index，所以 lcp 最差的情況則會是 x-1</span></span><br><span class="line">        <span class="comment">// 因為其實要比較的字串只是刪除上一個後綴的第一個字元</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(strA[i+k] == strA[sa[rk[i]<span class="number">-1</span>]+k]) ++k ;</span><br><span class="line">        <span class="comment">//比較順序較為特殊，因為他每個陣列都可以分開進行討論，</span></span><br><span class="line">        <span class="comment">//於是我們比較字串的 index 開始的後綴與他的 sa 前一項找出 lcp</span></span><br><span class="line">        <span class="comment">// strA[i] = 字串的 index 開始的後綴</span></span><br><span class="line">        <span class="comment">// strA[sa[rk[i]-1]] = 字串的 index 開始的後綴的 sa 前一項</span></span><br><span class="line">        <span class="comment">// while 裡面的 +k 則是減少重複比較，如果上次的 lcp 已經找出長度為 x 的 lcp</span></span><br><span class="line"></span><br><span class="line">        lcp[rk[i]] = k ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>((sa[i] &lt; lenA &amp;&amp; sa[i<span class="number">-1</span>] &lt; n+<span class="number">1</span> &amp;&amp; sa[i<span class="number">-1</span>] &gt; lenA ) ||</span><br><span class="line">            (sa[i] &gt; lenA &amp;&amp; sa[i<span class="number">-1</span>] &lt; n+<span class="number">1</span> &amp;&amp; sa[i<span class="number">-1</span>] &lt; lenA))</span><br><span class="line">            max_lcp = max(max_lcp , lcp[i]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>以上，Suffix Array 與 LCP 到此介紹結束，謝謝各位不嫌棄我的文筆閱讀到此。</p>
<h2 id="Suffix-Array-應用"><a href="#Suffix-Array-應用" class="headerlink" title="Suffix Array 應用"></a>Suffix Array 應用</h2><p>我在學習此演算法的過程中如果有題目讓我應用到此演算法我則收錄在此，連結則是我的詳解如果想要去看題目的就搜尋一下吧！</p>
<h3 id="最長共同前綴-Longest-Common-Prefix-Array"><a href="#最長共同前綴-Longest-Common-Prefix-Array" class="headerlink" title="最長共同前綴 Longest Common Prefix Array"></a>最長共同前綴 Longest Common Prefix Array</h3><ul>
<li><a href="https://theriseofdavid.github.io/2020/10/19/UVa/UVa760/" target="_blank" rel="noopener">UVa 760</a></li>
</ul>
<h2 id="參考連結："><a href="#參考連結：" class="headerlink" title="參考連結："></a>參考連結：</h2><p><a href="https://oi-wiki.org/math/quick-pow/" target="_blank" rel="noopener">快速冪 OI wiki</a><br><a href="https://turing13.com/2017/06/03/uva-760-dna-sequencing/" target="_blank" rel="noopener">UVa 760 – DNA Sequencing</a><br><a href="https://blog.csdn.net/ld_lin/article/details/52344384" target="_blank" rel="noopener">常用ASCII码详细对照表 （0—255）</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>學習演算法真的是 CP 值不高又很浪費時間的東西呢(無誤XD)，除了 ACM ICPC 之外，你很難知道甚麼時候可以用到，又或者當你想用時卻已經忘記怎麼用了，也有可能到時已經有現成套件可以用，那你為甚麼還要學習演算法呢？</p>
<p>因為有趣，可以增加思維，我自認我從演算法學習到了許多不同新事物，透過演算法來認識這個世界，這些演算法都是優秀的電腦科學家研究出來，透過他們的思維來引道我來看待事物，我相信，會讓我變得更加優秀。</p>
<p>也希望我在學習演算法的路上可以更加優秀，不被打倒，學習速度更快更容易讓我獲得新知識擴展自己腦袋的世界觀，也同時保持著舊有知識不遺忘。</p>
<p>最後要感謝 OI WIKI，他讓對於英文不好的我可以有更多機會去接觸演算法，將各個演算法收錄在此且無私的開放給大家學習，讓我有機會可以學習到此演算法。</p>
<p>也謝謝我自己的努力付出，即使我沒有機會成為一個優秀的人但或許可以成為他人的基礎吧XD。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>其實就是沒有附上說明的程式碼，我也花了三個小時撰寫文章，看得懂跟說得出來真的是兩回事，也許還有人覺得我說的很差，不過我已經盡力解釋。希望可以幫助到各位。</p>
<p>也希望大家想要學習的知識都可以快速學習而成，不要因為自身的環境不足而學習不到。</p>
<p>於是這裡就補述一些變數宣告與資料範圍限制與標頭檔了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 2000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sa[N] , rk[N&lt;&lt;<span class="number">1</span>] , oldrk[N&lt;&lt;<span class="number">1</span>] , id[N] , cnt[N] ;</span><br><span class="line"><span class="keyword">int</span> n , m  ;</span><br><span class="line"><span class="built_in">string</span> strA ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_sa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i , m , p , w ;</span><br><span class="line">    n = strA.length()<span class="number">-1</span> ;</span><br><span class="line">    m = max(n , <span class="number">300</span> );</span><br><span class="line">    <span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="keyword">sizeof</span>(cnt));</span><br><span class="line">    <span class="built_in">memset</span>(rk,<span class="number">0</span>,<span class="keyword">sizeof</span>(rk));</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span> ; i &lt;= n ; i++) ++cnt[rk[i] = (<span class="keyword">int</span>)strA[i]] ;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span> ; i &lt;= m ; i++) cnt[i] += cnt[i<span class="number">-1</span>] ;</span><br><span class="line">    <span class="keyword">for</span>(i = n ; i &gt;= <span class="number">1</span> ; i--) sa[cnt[rk[i]]--] = i ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(w = <span class="number">1</span> ; w &lt; n ; w &lt;&lt;= <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="keyword">sizeof</span>(cnt));</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span> ; i &lt;= n ; i++) id[i] = sa[i] ;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span> ; i &lt;= n ; i++) ++cnt[rk[id[i]+w]] ;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span> ; i &lt;= m ; i++) cnt[i] += cnt[i<span class="number">-1</span>] ;</span><br><span class="line">        <span class="keyword">for</span>(i = n ; i &gt;= <span class="number">1</span> ; i--) sa[cnt[rk[id[i]+w]]--] = id[i] ;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(cnt, <span class="number">0</span> , <span class="keyword">sizeof</span>(cnt));</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span> ; i &lt;= n ; i++) id[i] = sa[i] ;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span> ; i &lt;= n ; i++) ++cnt[rk[id[i]]] ;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span> ; i &lt;= m ; i++) cnt[i] += cnt[i<span class="number">-1</span>] ;</span><br><span class="line">        <span class="keyword">for</span>(i = n ; i &gt;= <span class="number">1</span> ; i--) sa[cnt[rk[id[i]]]--] = id[i] ;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memcpy</span>(oldrk , rk , <span class="keyword">sizeof</span>(rk));</span><br><span class="line">        <span class="keyword">for</span>(p = <span class="number">0</span> , i = <span class="number">1</span> ; i &lt;= n ; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(oldrk[sa[i]] == oldrk[sa[i<span class="number">-1</span>]] &amp;&amp;</span><br><span class="line">               oldrk[sa[i] + w] == oldrk[sa[i<span class="number">-1</span>] + w])</span><br><span class="line">                rk[sa[i]] = p ;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                rk[sa[i]] = ++p ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//debug</span></span><br><span class="line"><span class="comment">//    cout &lt;&lt; "Suffix Array is:\n" ;</span></span><br><span class="line"><span class="comment">//    for(int i = 1 ; i &lt;= n ; i++)&#123;</span></span><br><span class="line"><span class="comment">//        cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; strA.substr(sa[i]) &lt;&lt; ' ' &lt;&lt;sa[i] &lt;&lt; '\n' ;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_lcp</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lcp[N] = &#123;&#125; ;</span><br><span class="line">    <span class="keyword">int</span> max_lcp = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> , k = <span class="number">0</span> ; i &lt;= n ; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(k) k-- ;</span><br><span class="line">        <span class="keyword">while</span>(strA[i+k] == strA[sa[rk[i]<span class="number">-1</span>]+k]) ++k ;</span><br><span class="line">        lcp[rk[i]] = k ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="用紙筆去模擬-Suffix-Array-and-LCP"><a href="#用紙筆去模擬-Suffix-Array-and-LCP" class="headerlink" title="用紙筆去模擬 Suffix Array and LCP"></a>用紙筆去模擬 Suffix Array and LCP</h2><p>因為只是自己在思考過程中隨手做的筆記，覺得不是對讀者這麼有幫助，因此放在文章最下面。</p>
<p>有時候用想或用看的可能不太能夠懂這演算法，那就用寫的吧！這是大衛我自己學習的手稿，紀錄者我的學習過程。</p>
<p><img src="/images/Suffix-Array/5.jpg" alt=""><br><img src="/images/Suffix-Array/6.jpg" alt=""></p>
]]></content>
      <categories>
        <category>演算法知識</category>
      </categories>
      <tags>
        <tag>程式解題</tag>
        <tag>字串處理</tag>
        <tag>演算法知識</tag>
        <tag>最長共同前綴 Longest Common Prefix Array</tag>
        <tag>Suffix Array</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa760 - DNA Sequencing (最長共同前綴 Longest Common Prefix)</title>
    <url>/2020/10/19/UVa/UVa760/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>給你兩組字串，想請你找出裡面其中最長的共同子字串，如果有複數最長的子字串則透過字典序輸出。</p>
<p>注意：這題的輸出格式有特別要求</p>
</blockquote>
<a id="more"></a>

<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>這題使用 Suffix Array 來找出最長共同前綴 Longest Common Prefix 是我認為最理想的解法，將兩組字串結合後透過 Suffix Array 的後綴排序來找出最長共同前序可以有效的把此問題給解決。</p>
<p>如果不懂 Suffix Array or Longest Common Prefix 可以參考此<a href="https://theriseofdavid.github.io/2020/10/19/Explain_Algorithm/Suffix-Array/" target="_blank" rel="noopener">演算法說明</a>，因為我的這演算法說明基本上是用此題進行範例，我想會加速你再學習的腳步，如果我的寫作可以讓你好理解的話XD。</p>
<p>學會了 Suffix Array 與理解 LCP 原理後就可以把這題解決掉了！</p>
<h2 id="焦點回到題目上，解開題目的小設計"><a href="#焦點回到題目上，解開題目的小設計" class="headerlink" title="焦點回到題目上，解開題目的小設計"></a>焦點回到題目上，解開題目的小設計</h2><h3 id="QUESTION-題目是要找出兩組字串中最長的共同子字串，跟-LCP-有甚麼關係呢？"><a href="#QUESTION-題目是要找出兩組字串中最長的共同子字串，跟-LCP-有甚麼關係呢？" class="headerlink" title="QUESTION : 題目是要找出兩組字串中最長的共同子字串，跟 LCP 有甚麼關係呢？"></a>QUESTION : 題目是要找出兩組字串中最長的共同子字串，跟 LCP 有甚麼關係呢？</h3><p>當你把兩組字串結合成一組字串後透過 Suffix Array + LCP 的特性就可以找出相似前綴，舉個例子好了：<br>有兩組字串 atgc , tga，我們用兩個比英文小寫字母還小的符號去連接他們則 Suffix Array 看起來會像這樣：<br>merge string : <strong>atgc$tga#</strong><br>Suffix Array is:</p>
<table>
<thead>
<tr>
<th>index</th>
<th>string</th>
<th>sa[i]</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>#</td>
<td>9</td>
</tr>
<tr>
<td>2</td>
<td>$tga#</td>
<td>5</td>
</tr>
<tr>
<td>3</td>
<td>a#</td>
<td>8</td>
</tr>
<tr>
<td>4</td>
<td>atgc$tga#</td>
<td>1</td>
</tr>
<tr>
<td>5</td>
<td>$tga#</td>
<td>4</td>
</tr>
<tr>
<td>6</td>
<td>ga#</td>
<td>7</td>
</tr>
<tr>
<td>7</td>
<td>gc$tga#</td>
<td>3</td>
</tr>
<tr>
<td>8</td>
<td>tga#</td>
<td>6</td>
</tr>
<tr>
<td>9</td>
<td>tgc$tga#</td>
<td>2</td>
</tr>
</tbody></table>
<p>是不是知道 LCP 怎麼用了，對吧！<del>不知道該打</del></p>
<p>之後透過 sa[i] 的值查詢他們分布在哪個位置，如果兩個都分布在 \($\) 字號前面則代表他們其實都是第一組字串的子字串，並不是我們要的答案，反之如果都分布在 \($\) 字號後面亦是如此。但如果其中一個在 \($\) 字號前面而另一個在 \($\) 和 # 字號的中間就代表這兩組字串都有此子字串這就是我們要的答案！P.S. # 字號似乎沒辦法給他 mathjax</p>
<p>於是第一次迴圈先找出 max_lcp，第二次迴圈找出長度等於 max_lcp 的子字串輸出。 </p>
<p>值得需要小注意的就是題目有要求我們要用字典序輸出，但由於 Suffix Array 特性已經幫我們做好所以我們就不需要特別在留意，但還是需要注意到有可能會是重複輸出，即此子字串可能在兩個字串中都重複兩次，所以需要用 map 來檢查。</p>
<p>如果還是不懂就讓我用程式碼來輔助吧！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 找出 max_lcp 的長度</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>((sa[i] &lt; lenA &amp;&amp; sa[i<span class="number">-1</span>] &lt; n+<span class="number">1</span> &amp;&amp; sa[i<span class="number">-1</span>] &gt; lenA ) ||</span><br><span class="line">        (sa[i] &gt; lenA &amp;&amp; sa[i<span class="number">-1</span>] &lt; n+<span class="number">1</span> &amp;&amp; sa[i<span class="number">-1</span>] &lt; lenA))</span><br><span class="line">        <span class="comment">// 檢查結合的 string 共同前綴是不是都是同一個題目字串的</span></span><br><span class="line">        max_lcp = max(max_lcp , lcp[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 輸出長度等於 max_lcp 的子字串</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; mp ;</span><br><span class="line"><span class="keyword">if</span>(max_lcp == <span class="number">0</span>) <span class="comment">//如果是 0 就輸出題目要求格式</span></span><br><span class="line">    &#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"No common sequence.\n"</span> ; <span class="keyword">return</span> ;&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>((sa[i] &lt; lenA &amp;&amp; sa[i<span class="number">-1</span>] &lt; n+<span class="number">1</span> &amp;&amp; sa[i<span class="number">-1</span>] &gt; lenA ) ||</span><br><span class="line">       (sa[i] &gt; lenA &amp;&amp; sa[i<span class="number">-1</span>] &lt; n+<span class="number">1</span> &amp;&amp; sa[i<span class="number">-1</span>] &lt; lenA))</span><br><span class="line">       <span class="comment">// 檢查結合的 string 共同前綴是不是都是同一個題目字串的</span></span><br><span class="line">       <span class="keyword">if</span>(lcp[i] == max_lcp)&#123;</span><br><span class="line">            <span class="built_in">string</span> temp = strA.substr(sa[i] , max_lcp);</span><br><span class="line">            <span class="keyword">if</span>(mp[temp]) <span class="keyword">continue</span> ; <span class="comment">//檢查有沒有重複輸出</span></span><br><span class="line">            <span class="keyword">else</span> mp[temp] = <span class="number">1</span> ; <span class="comment">//紀錄已經被輸出過</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; temp &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>強烈建議搭配<a href="https://theriseofdavid.github.io/2020/10/19/Explain_Algorithm/Suffix-Array/" target="_blank" rel="noopener">演算法知識 - Suffix Array 後綴陣列</a>，裡面的程式碼基本上都是配合這題而寫的非常建議讀者學會。</p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://oi-wiki.org/math/quick-pow/" target="_blank" rel="noopener">快速冪 OI wiki</a><br><a href="https://turing13.com/2017/06/03/uva-760-dna-sequencing/" target="_blank" rel="noopener">UVa 760 – DNA Sequencing</a><br><a href="https://blog.csdn.net/ld_lin/article/details/52344384" target="_blank" rel="noopener">常用ASCII码详细对照表 （0—255）</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>這題的學習難度好高阿…，這題我應該總讀書時間應該有高達 8 小時了吧ಥ⌣ಥ！嗚嗚，我真笨，希望我未來在學習演算法的路上狀況可以越來越好，也可以磨練好我自學的能力，這很重要，讀書基本上只需要百分之 20% 與老師溝通剩下的都是需要學生自己去摸索探討，希望我未來可以找到好老師讓我成長，在我自學學到盲點時可以幫助我一把。</p>
<p>題外話，CSDN 與大陸資源真的是我學習的主要材料呀，大陸在於資訊的知識比起台灣多蠻多的，這樣也讓我在自學演算法的路上輕鬆了些很謝謝大家都願意把技術下放給我們這些菜鳥。</p>
<p>補足我身心的缺陷，讓我更加優秀、生活更加快樂應該是我人生中的其中一個目的吧！XD</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>其實就是沒有附上說明的程式碼，我也花了兩個小時撰寫文章，看得懂跟說得出來真的是兩回事，也許還有人覺得我說的很差，不過我已經盡力解釋。希望可以幫助到各位。</p>
<p>也希望大家想要學習的知識都可以快速學習而成，不要因為自身的環境不足而學習不到。</p>
<p>於是這裡就補述一些題目給的資料範圍限制與標頭檔了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 2000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">string</span> strA=<span class="string">""</span> , strB=<span class="string">""</span> , strC=<span class="string">""</span> ;</span><br><span class="line"><span class="keyword">int</span> sa[N] , rk[N&lt;&lt;<span class="number">1</span>] , oldrk[N&lt;&lt;<span class="number">1</span>] , id[N] , cnt[N] ;</span><br><span class="line"><span class="keyword">int</span> n , m , maxn , lenA , lenB , flag =<span class="number">0</span> ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_sa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i , m , p , w ;</span><br><span class="line">    n = strA.length()<span class="number">-1</span> ;</span><br><span class="line">    m = max(n , <span class="number">300</span> );</span><br><span class="line">    <span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="keyword">sizeof</span>(cnt));</span><br><span class="line">    <span class="built_in">memset</span>(rk,<span class="number">0</span>,<span class="keyword">sizeof</span>(rk));</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span> ; i &lt;= n ; i++) ++cnt[rk[i] = (<span class="keyword">int</span>)strA[i]] ;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span> ; i &lt;= m ; i++) cnt[i] += cnt[i<span class="number">-1</span>] ;</span><br><span class="line">    <span class="keyword">for</span>(i = n ; i &gt;= <span class="number">1</span> ; i--) sa[cnt[rk[i]]--] = i ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(w = <span class="number">1</span> ; w &lt; n ; w &lt;&lt;= <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="keyword">sizeof</span>(cnt));</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span> ; i &lt;= n ; i++) id[i] = sa[i] ;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span> ; i &lt;= n ; i++) ++cnt[rk[id[i]+w]] ;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span> ; i &lt;= m ; i++) cnt[i] += cnt[i<span class="number">-1</span>] ;</span><br><span class="line">        <span class="keyword">for</span>(i = n ; i &gt;= <span class="number">1</span> ; i--) sa[cnt[rk[id[i]+w]]--] = id[i] ;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(cnt, <span class="number">0</span> , <span class="keyword">sizeof</span>(cnt));</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span> ; i &lt;= n ; i++) id[i] = sa[i] ;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span> ; i &lt;= n ; i++) ++cnt[rk[id[i]]] ;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span> ; i &lt;= m ; i++) cnt[i] += cnt[i<span class="number">-1</span>] ;</span><br><span class="line">        <span class="keyword">for</span>(i = n ; i &gt;= <span class="number">1</span> ; i--) sa[cnt[rk[id[i]]]--] = id[i] ;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memcpy</span>(oldrk , rk , <span class="keyword">sizeof</span>(rk));</span><br><span class="line">        <span class="keyword">for</span>(p = <span class="number">0</span> , i = <span class="number">1</span> ; i &lt;= n ; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(oldrk[sa[i]] == oldrk[sa[i<span class="number">-1</span>]] &amp;&amp;</span><br><span class="line">               oldrk[sa[i] + w] == oldrk[sa[i<span class="number">-1</span>] + w])</span><br><span class="line">                rk[sa[i]] = p ;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                rk[sa[i]] = ++p ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//debug</span></span><br><span class="line"><span class="comment">//    cout &lt;&lt; "Suffix Array is:\n" ;</span></span><br><span class="line"><span class="comment">//    for(int i = 1 ; i &lt;= n ; i++)&#123;</span></span><br><span class="line"><span class="comment">//        cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; strA.substr(sa[i]) &lt;&lt; ' ' &lt;&lt;sa[i] &lt;&lt; '\n' ;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_lcp</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lcp[N] = &#123;&#125; ;</span><br><span class="line">    <span class="keyword">int</span> max_lcp = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> , k = <span class="number">0</span> ; i &lt;= n ; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(k) k-- ;</span><br><span class="line">        <span class="keyword">while</span>(strA[i+k] == strA[sa[rk[i]<span class="number">-1</span>]+k]) ++k ;</span><br><span class="line">        lcp[rk[i]] = k ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>((sa[i] &lt; lenA &amp;&amp; sa[i<span class="number">-1</span>] &lt; n+<span class="number">1</span> &amp;&amp; sa[i<span class="number">-1</span>] &gt; lenA ) ||</span><br><span class="line">            (sa[i] &gt; lenA &amp;&amp; sa[i<span class="number">-1</span>] &lt; n+<span class="number">1</span> &amp;&amp; sa[i<span class="number">-1</span>] &lt; lenA))</span><br><span class="line">            max_lcp = max(max_lcp , lcp[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//debug</span></span><br><span class="line"><span class="comment">//    cout &lt;&lt; "max_lcp is " &lt;&lt; max_lcp &lt;&lt; '\n' ;</span></span><br><span class="line"><span class="comment">//    for(int i = 0 ; i &lt;= n ; i++)</span></span><br><span class="line"><span class="comment">//        cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; lcp[i] &lt;&lt; '\n' ;</span></span><br><span class="line"><span class="comment">//    cout &lt;&lt; "lenA =" &lt;&lt; lenA &lt;&lt; "\nn is" &lt;&lt; n &lt;&lt; '\n' ;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(flag)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    flag = <span class="number">1</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; mp ;</span><br><span class="line">    <span class="keyword">if</span>(max_lcp == <span class="number">0</span>)</span><br><span class="line">        &#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"No common sequence.\n"</span> ; <span class="keyword">return</span> ;&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>((sa[i] &lt; lenA &amp;&amp; sa[i<span class="number">-1</span>] &lt; n+<span class="number">1</span> &amp;&amp; sa[i<span class="number">-1</span>] &gt; lenA ) ||</span><br><span class="line">           (sa[i] &gt; lenA &amp;&amp; sa[i<span class="number">-1</span>] &lt; n+<span class="number">1</span> &amp;&amp; sa[i<span class="number">-1</span>] &lt; lenA))</span><br><span class="line">           <span class="keyword">if</span>(lcp[i] == max_lcp)&#123;</span><br><span class="line">                <span class="built_in">string</span> temp = strA.substr(sa[i] , max_lcp);</span><br><span class="line">                <span class="keyword">if</span>(mp[temp]) <span class="keyword">continue</span> ;</span><br><span class="line">                <span class="keyword">else</span> mp[temp] = <span class="number">1</span> ;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; temp &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">           &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> );</span><br><span class="line">    <span class="comment">//freopen("out.txt" , "w" , stdout );</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; strA &gt;&gt; strB)&#123;</span><br><span class="line">        lenA = strA.length()+<span class="number">1</span>;</span><br><span class="line">        lenB = strB.length();</span><br><span class="line">        strA = <span class="string">' '</span> + strA + <span class="string">'$'</span> + strB + <span class="string">'#'</span> ;</span><br><span class="line">        <span class="comment">//debug</span></span><br><span class="line">        <span class="comment">//cout &lt;&lt; "strA is " &lt;&lt;strA &lt;&lt; "\nstrA.length() is " &lt;&lt; strA.length() &lt;&lt; '\n' ;</span></span><br><span class="line"></span><br><span class="line">        build_sa();</span><br><span class="line">        build_lcp();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>字串處理</tag>
        <tag>Suffix Array</tag>
        <tag>最長共同前綴 Longest Common Prefix</tag>
      </tags>
  </entry>
  <entry>
    <title>由於語言隔閡造成我被外國人怒罵</title>
    <url>/2020/04/11/life_experence/language-barrier-by-foreigner/</url>
    <content><![CDATA[<h2 id="說明"><a href="#說明" class="headerlink" title="說明"></a>說明</h2><blockquote>
<p>記錄我在 2020/10/18 與外籍學生(越南)由於語言隔閡造成我被怒罵<br>透過了這次事件讓我成長了許多<br>深刻的經驗會讓我學習到更多知識也會補足我的缺點<br>由於目前在風頭上，我期望大約在兩個月後再將此日期改回正確日期，現在先不讓人這麼容易找到免得吵架</p>
</blockquote>
<a id="more"></a>

<h2 id="事件描述"><a href="#事件描述" class="headerlink" title="事件描述"></a>事件描述</h2><p>2020/10/18 (六) 我跟一同陪與我參加 ICPC 演算法的外籍學生一同讀書練習演算法，事件大概可以分成兩部分描述。</p>
<h2 id="scold-怒罵-1-金錢分配事件"><a href="#scold-怒罵-1-金錢分配事件" class="headerlink" title="scold(怒罵) 1 金錢分配事件 :"></a>scold(怒罵) 1 金錢分配事件 :</h2><p>晚上我們在北科學餐吃飯，我像學長分享我們資財系對於比賽經費較充裕肯願意將經費花費在學生身上，但資工系則沒有，以及資財系主任跟我分享再開學校大會時電資學院院長則直接說出他們在<a href="https://theriseofdavid.github.io/2020/07/08/contest_experence/ncut2020-experience/" target="_blank" rel="noopener">科大競賽2020</a>中獲得金獎時，然後說到資工經費並沒有下放給學生，我認為這是一個非常可怕的問題是，外籍學生直接對我進行怒罵，怒罵內容如下：「這是資工系主任給我的經費(1000)，我為甚麼要分給 3 個人，你(資財)拿到的錢(1600)也沒有分阿，你如果分給 3 個人那我也就分給 3 個人阿」。</p>
<h3 id="My-Thoughts-我的想法-："><a href="#My-Thoughts-我的想法-：" class="headerlink" title="My Thoughts(我的想法)："></a>My Thoughts(我的想法)：</h3><p>莫名其妙。</p>
<p>我不懂為甚麼當我在跟他講 A 時他竟然拿 B 事情跟我吵，莫名其妙，我本來的個性就很注重公平這件事情，外籍學生並不是不知道我的個性可是他竟然拿這件事情跟我吵架，這讓我非常傻眼，當下的反應是：「??? 我是在跟你講這件事情嗎」，我想可能是我的遣詞用句讓他誤會了吧？</p>
<p>不過從另外一個角度來想，當時的我的語氣是沒有具有惡意的，就算他誤會了但他理應要從我的語氣中判斷現在的我是具有惡意還是善意，竟然直接怒罵，讓我百思不得其解，莫名其妙的被罵，到現在我竟然還沒有一點悔意，這還是我第一次感覺沒做錯事的罵得這麼莫名其妙。</p>
<h3 id="self-criticize-自我檢討-："><a href="#self-criticize-自我檢討-：" class="headerlink" title="self-criticize(自我檢討)："></a>self-criticize(自我檢討)：</h3><p>語言是很重要的，外國人學習語言固然辛苦，但我認為語氣則大致上是相同的，兩個互相不懂彼此的語言但一定可以透過語氣得知對話是開心還是難過或是痛苦，外籍學生直接怒罵我，讓我得知一件重要性，如果我認為外國人踩到我的底線，我必須先判斷是不是語言所造成的誤會，在看他是不是開我玩笑，從他的語氣去判斷，在考慮我是否要不要生氣。</p>
<p>不過這讓我覺得外籍學生的內心素質教育其實並沒有台灣的好，遇到衝突是先選擇暴力解決，雖然沒有選擇打架但是選擇了言語暴力個人還是覺得不太好的，要是每個人都這樣社會怎麼進步，這世界只剩下衝突沒有包容。</p>
<h2 id="scold-怒罵-2-語言的請教："><a href="#scold-怒罵-2-語言的請教：" class="headerlink" title="scold(怒罵) 2 語言的請教："></a>scold(怒罵) 2 語言的請教：</h2><p>晚上我們在北科的教室讀書，途中我向他聊到韓國有韓文、英國有英文、日本有日文、中國有中文、越南是用羅馬拼音，那越南之前用的文字是甚麼？而外籍學生則說：「你現在是不是瞧不起越南，越南人戰勝敵人美國多強，你們台灣人打敗仗，台灣是國家嗎？你們台灣人現在能這樣還不是國民黨帶黃金才發展起來的，你懂歷史嗎？你讀的歷史有比我多嗎，你英文好嗎，你奧林匹亞有打得比我優秀嗎？」(用一張非常瞧不起的臉看著我)</p>
<h3 id="y-Thoughts-我的想法-："><a href="#y-Thoughts-我的想法-：" class="headerlink" title="y Thoughts(我的想法)："></a>y Thoughts(我的想法)：</h3><p>在一次莫名其妙。</p>
<p>不過這個可能我能體會？這種感覺讓我覺得有點像是中國某些特定愛國極端人士會說的話，由於自卑所以需要去怒罵別人講別人缺點才能讓自己在當下獲得優越感以保持自我尊嚴，這種感覺八。</p>
<p>我在日本讀書時我個人沒有發生過這種情況，我覺得在日本雖然我覺得我在某些情況下我會被受到歧視，但我認為那是事實沒必要去爭辯，只要好好努力去做好當下我應該要去做的事情即可。畢竟這是國家的事，我能改變甚麼？我只不過是一個學生，連自己生存的意義都還沒找到，就為了國家的事情再跟其他國家人爭論，就算爭贏了能夠贏的對方內心的想法嗎？我想不會，我被他怒罵後我只覺得他這個人好暴力、好沒素質，如果要用一句話形容就是希特勒的感覺吧，只看的到自己想看的視角。</p>
<p>不過透過他的怒罵後，我似乎可以得知有時候這種人的禮貌都是表面禮貌，講的話都很官腔對我而言有點太虛偽了，這種人必須跟他保持適當距離並且爬得比他還高，在他想要傷害別人時先阻止他，不然這個世界只會越來越暴力，我想有可能變成南越跟北越一樣吧。</p>
<p>我不想從他的怒罵中反駁，這沒意義。生氣改變不了事實，那何必生氣？大方承認有很難嗎？更何況我根本就不是在嘲笑你，你就自己突然破口大罵，蠻可憐的愛國思想吧。這種人就是炸彈，你不知道他甚麼時候會爆炸，具傷害性。如果他是我的敵人我會非常喜歡。</p>
<h3 id="self-criticize-自我檢討-：-1"><a href="#self-criticize-自我檢討-：-1" class="headerlink" title="self-criticize(自我檢討)："></a>self-criticize(自我檢討)：</h3><p>英文很重要，不然會被別人怒罵說自己英文不好呦，恩當下的結論。</p>
<p>沒有拉，開玩笑地。避免跟外國人講他們國家的事情，特別是越南，當他們如果講他們國家怎樣你就隨便應付就好在搞得好像自己很喜歡他們國家之後適當保持距離，除非你能保證他的文化素質夠高，不會因為別人的某個舉動就直接破口大罵、降低自己的國格，連一個不是國的台灣人都可以比他有素質，真為我自己慶幸我不是生存在那個環境下長大，不然我真的會瘋掉。</p>
<p>如果喜歡越南那就適著把越南改變得更好而不是對一個學生怒罵，這樣很像 1980 時的作風，如果再 2020 但人民素質卻還在 1980 時只能顯現出自己的無知吧。</p>
<p>不過我還是有學到東西的，對於極端政權的國家盡量不談政治、不講他們不好，以免他們生氣，為達到表面上的和平以及減少自己的麻煩這樣做我想應該是最好的，雖然說他們會自我肥大起來，不過這不會是我去解決的事情，有更多的學生現在正在學習這樣的知識，我只要做好我的螺絲釘，找尋自己的生存意義較為實際些。</p>
<h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><ul>
<li>對於外國人友善、包容，拿出人的氣度</li>
<li>當外國人讓你不舒服時，先看他是有意還是無意的</li>
<li>盡量對極端政權的人民只說好話，並跟他們保持距離，除非你能認為他們的文化素養夠高</li>
<li>讓自己優秀，以免當世界被極端政權征服時自己沒辦法出來抗爭，只剩服從的義務，連權利都不算。</li>
</ul>
<p>以上四點，要好好記住呀大衛！對你來說應該是很重要的。</p>
<p>然後我等等就先去跟那外籍學生說抱歉吧，只是還要想要怎麼抱歉，真的好麻煩，明明不是我的錯卻還要道歉，後來想想當個極端政權的人民好可憐，要因為一件他改變不了的事情而生氣，那我就勉為其難地為了我能改變的了得事情去改變吧！加油，大衛！</p>
]]></content>
      <categories>
        <category>人生旅途</category>
      </categories>
      <tags>
        <tag>大學Life</tag>
        <tag>人生旅途</tag>
      </tags>
  </entry>
  <entry>
    <title>演算法知識 - Radix Sort 基數排序</title>
    <url>/2020/10/20/Explain_Algorithm/radix-sort/</url>
    <content><![CDATA[<h2 id="Radix-Sort-介紹與應用"><a href="#Radix-Sort-介紹與應用" class="headerlink" title="Radix Sort 介紹與應用"></a>Radix Sort 介紹與應用</h2><blockquote>
<p>Radix Sort 與我們一般常見的比較排序不同，採用分配式排序法(透過特定方式將值分別放入不同的  array)，Radix Sort 是特殊的整數排序法，Radix Sort 是根據每一位的數值放入相對應的 index。</p>
<p>時間複雜度為 \(O(dn)\)</p>
</blockquote>
<a id="more"></a>

<h2 id="Radix-Array-原理"><a href="#Radix-Array-原理" class="headerlink" title="Radix Array 原理"></a>Radix Array 原理</h2><p>這裡用數字來舉範例，假設要排序的數值有：(1, 254 ,6932 ,24 )</p>
<ul>
<li>先創建 10 個 queue，因為數字主要是透過 0~9 組合</li>
<li>從個位數開始進行排序，假設個位數是 1，則放入 queue[1] </li>
<li>從 queue[0] ~ queue[9] 開始依序將數值取出來並依序存入陣列</li>
<li>再來從十、百、千…位數開始進行排序，重複第二點及以下動作，直到沒有數值大於的位數。</li>
</ul>
<h3 id="名詞解釋："><a href="#名詞解釋：" class="headerlink" title="名詞解釋："></a>名詞解釋：</h3><ul>
<li>位數<br>指數字中某一特定數字字元(一個數字)所在的位置。EX:個位數、百分位</li>
</ul>
<h3 id="QUESTION-為甚麼是從個位數開始進行排序？"><a href="#QUESTION-為甚麼是從個位數開始進行排序？" class="headerlink" title="QUESTION: 為甚麼是從個位數開始進行排序？"></a>QUESTION: 為甚麼是從個位數開始進行排序？</h3><p>如果從最大位數開始進行排序，會出現 8 &gt; 126，變成了字典排序而不是順序排序，在百分位與十分位時都沒有問題，但到個分位時會變成 8 在比較後面的 queue，導致排序不正確。排序成 (126,8)</p>
<p><strong>從最小位數開始依序排序，因為數學排序的邏輯是先根據位數進行排序才根據個數進行排序，</strong><br>而 Radix Sort 排序則是權重越不高先排序，如果從最大位數排序則會變成字典順序。</p>
<h2 id="Radix-Sort-實作與說明"><a href="#Radix-Sort-實作與說明" class="headerlink" title="Radix Sort 實作與說明"></a>Radix Sort 實作與說明</h2><p>找出數列中最大的數，只要位數比他還小就直接跳出迴圈，剩下就與原理相同，直接在程式碼進行說明。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num[<span class="number">10</span>] = &#123;<span class="number">24</span>,<span class="number">6239</span> ,<span class="number">249</span> , <span class="number">465935</span> , <span class="number">4353</span> ,<span class="number">543</span> , <span class="number">9352</span> ,<span class="number">2154</span> , <span class="number">953</span> , <span class="number">3952</span>&#125; ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">radix_sort</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; buckets[<span class="number">10</span>] ; <span class="comment">// 創建存放位置</span></span><br><span class="line">    <span class="comment">// 如果是 0-9 就創建 10，A-Z(特別指大寫)就創建 26</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span> ,j = <span class="number">1</span> ; <span class="comment">// j 用來找出現在的位數</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++) k = max(num[i] , k );</span><br><span class="line">    <span class="comment">// k = 找出數列最大值 </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(k/j)&#123; <span class="comment">//檢測還有沒有數值大於我們現在當下要檢測的位數</span></span><br><span class="line">        <span class="comment">// 如果沒有就代表已經檢測、排序完畢</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++) <span class="comment">//將位數的值依序放入不同的 queue</span></span><br><span class="line">            buckets[(num[i] /j)%<span class="number">10</span>].push(num[i]); </span><br><span class="line">            <span class="comment">//(num[i] /j)%10 找出當下位數的數值(一個數字)</span></span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span> ; <span class="comment">//p 排序位數的標準</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!buckets[i].empty())&#123; <span class="comment">//直到這個 queue 沒有任何數字</span></span><br><span class="line">                num[p++] =buckets[i].front(); <span class="comment">// 將根據此位數排序的值放回 num 中</span></span><br><span class="line">                <span class="comment">// p++ 準備讓下一個值放入下一個位置</span></span><br><span class="line">                buckets[i].pop(); <span class="comment">//已經被放入 num 所以退出</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        j *= <span class="number">10</span>; <span class="comment">// 找下一個位數</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span> ;i++) <span class="comment">// 輸出答案，檢測是否正確</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">' '</span> &lt;&lt; num[i] &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="放一份乾淨無註解的程式碼在此，方便讀者直接拿來使用"><a href="#放一份乾淨無註解的程式碼在此，方便讀者直接拿來使用" class="headerlink" title="放一份乾淨無註解的程式碼在此，方便讀者直接拿來使用"></a>放一份乾淨無註解的程式碼在此，方便讀者直接拿來使用</h2><p>程式碼如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num[<span class="number">10</span>] = &#123;<span class="number">24</span>,<span class="number">6239</span> ,<span class="number">249</span> , <span class="number">465935</span> , <span class="number">4353</span> ,<span class="number">543</span> , <span class="number">9352</span> ,<span class="number">2154</span> , <span class="number">953</span> , <span class="number">3952</span>&#125; ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">radix_sort</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; buckets[<span class="number">10</span>] ; </span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span> ,j = <span class="number">1</span> ; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++) k = max(num[i] , k );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(k/j)&#123; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++) </span><br><span class="line">            buckets[(num[i] /j)%<span class="number">10</span>].push(num[i]); </span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span> ; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!buckets[i].empty())&#123; </span><br><span class="line">                num[p++] =buckets[i].front();</span><br><span class="line">                buckets[i].pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        j *= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span> ;i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">' '</span> &lt;&lt; num[i] &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://rust-algo.club/sorting/radix_sort/" target="_blank" rel="noopener">基數排序 Radix sort</a><br><a href="https://dreamisadream97.pixnet.net/blog/post/168570825-radix-sort-%28%E5%9F%BA%E5%BA%95%E6%8E%92%E5%BA%8F%E6%B3%95%29" target="_blank" rel="noopener">radix sort (基底排序法)</a><br><a href="https://magiclen.org/radix-sort/" target="_blank" rel="noopener">基數排序法</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>老實講我排序學的沒有很多呀XD，那時候在比賽只練過幾個最有名氣的排序法後就直接去學習其他演算法，但當我學到 <a href="(https://theriseofdavid.github.io/2020/10/19/Explain_Algorithm/Suffix-Array/)">Suffix Array</a>，卻發現自己不懂這個演算法阿阿阿阿阿，<del>自己真爛</del>。幸好有 Suffix Array 幫我補足過去的知識，由於我的演算法並不是透過專業的老師訓練而成，80% 都是透過我的自學而成，但自學有個很大的問題就是，容易基礎不紮實，很有可能在學到進階演算法時還要再回來補過去基礎。</p>
<p>不過沒關係，我會努力完成演算法的知識，我覺得學習演算法是一件很有趣的事情，它可以增加我的很多思維在我人生中都有稍微用到的時候，不敢說幫助很大，但至少學習的過程是不會後悔的。也希望我可以在參加 ICPC 時可以獲得好的名次，給予自己更大的信心與動力。</p>
]]></content>
      <categories>
        <category>演算法知識</category>
      </categories>
      <tags>
        <tag>程式解題</tag>
        <tag>演算法知識</tag>
        <tag>數論 Math theorm</tag>
      </tags>
  </entry>
  <entry>
    <title>統計學(一) 筆記 - 第四章</title>
    <url>/2020/10/27/NTUT_note/statistcs-ch4A/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊與財金管理系大二上統計學重點整理<br><font color="#dd0000">並非所有人都適用，部分對我而言稍加容易的內容並不會寫在此內。</font><br><strong>這是觀看影片心得後的筆記，老師上課可能不太適用會忘記抄到</strong></p>
</blockquote>
<a id="more"></a>

<h2 id="4A-介紹-Introduction-to-Probability-機率導論"><a href="#4A-介紹-Introduction-to-Probability-機率導論" class="headerlink" title="4A 介紹 - Introduction to Probability(機率導論)"></a>4A 介紹 - Introduction to Probability(機率導論)</h2><p>一共介紹</p>
<ul>
<li>Random Experiments(隨機時間)、Counting Rules(技術法則)、Assigning Probabilities(指派機率)</li>
<li>Event and Their Probability(事件與事件機率)</li>
<li>Bayes’ Theorem </li>
<li>Conditional Probability(條件機率)</li>
</ul>
<h3 id="Probability-機率值"><a href="#Probability-機率值" class="headerlink" title="Probability 機率值"></a>Probability 機率值</h3><ul>
<li>當機率越接近 \(1\) 表示發生越高，接近\(0\) 則代表發生機率越低</li>
</ul>
<h3 id="Statistcal-Experiments-統計實驗"><a href="#Statistcal-Experiments-統計實驗" class="headerlink" title="Statistcal Experiments(統計實驗)"></a>Statistcal Experiments(統計實驗)</h3><p>我們知道他的結果發生可能，但我們沒辦法知道下次的結果是甚麼。</p>
<ul>
<li>Random Experiment(隨機實驗)<br>可以清楚知道他的實驗結果可能</li>
<li>Sample Space(樣本空間)<br>此實驗所有可能性結果的集合</li>
<li>Sample Point(樣本點)<br><strong>這一次</strong>實驗發生的結果</li>
</ul>
<h3 id="Counting-Rule-for-Multiple-Step-Experiments-多重步驟實驗"><a href="#Counting-Rule-for-Multiple-Step-Experiments-多重步驟實驗" class="headerlink" title="Counting Rule for Multiple-Step Experiments(多重步驟實驗)"></a>Counting Rule for Multiple-Step Experiments(多重步驟實驗)</h3><p>簡單說就是用 \(C_{n}^{m}\) or \(P_{n}^{m} \) 的應用。</p>
<h3 id="Assigning-Probabilities-指派結果"><a href="#Assigning-Probabilities-指派結果" class="headerlink" title="Assigning Probabilities(指派結果)"></a>Assigning Probabilities(指派結果)</h3><ul>
<li>實驗結果機率必須介在\(0~1\)之間，\(E_{i}\)為第幾次的結果。</li>
<li>假如有 n 種不同的實驗結果，加總起來必等於 \(1\)</li>
</ul>
<h4 id="Classical-Method-古典法"><a href="#Classical-Method-古典法" class="headerlink" title="Classical Method(古典法)"></a>Classical Method(古典法)</h4><p>每一個實驗結果發生可能性都相同時使用，每一個 sample point 機率都是 \(\frac{1}{n}\)。</p>
<h4 id="Relative-Frequency-Method-相對次數法"><a href="#Relative-Frequency-Method-相對次數法" class="headerlink" title="Relative Frequency Method(相對次數法)"></a>Relative Frequency Method(相對次數法)</h4><p>根據實驗結果的歷史資料來決定機率多少，設實驗總次數為 n，x 實驗結果為 y，則機率是\(\frac{y}{n}\。</p>
<h4 id="Subjective-Method-主觀法"><a href="#Subjective-Method-主觀法" class="headerlink" title="Subjective Method(主觀法)"></a>Subjective Method(主觀法)</h4><p>用主觀判斷、經驗來判斷機率。<br><strong>有資料一定要盡量引用資料</strong></p>
<h3 id="Event-and-Their-Probability-事件與事件機率"><a href="#Event-and-Their-Probability-事件與事件機率" class="headerlink" title="Event and Their Probability(事件與事件機率)"></a>Event and Their Probability(事件與事件機率)</h3><p>在實驗裡面找出所有樣本點並對所有的樣本點指出機率，就可以找出此實驗的機率。</p>
<h4 id="Some-Relationships-of-Probability"><a href="#Some-Relationships-of-Probability" class="headerlink" title="Some Relationships of Probability"></a>Some Relationships of Probability</h4><ul>
<li>\(A^c\) Complement(餘集)</li>
<li>\(A \cup B \) Union(聯集)</li>
<li>Mutually Exclusive Event(互斥)，即 \(P(A \cup B) = 0 \)</li>
</ul>
<h3 id="Conditional-Probability-條件機率"><a href="#Conditional-Probability-條件機率" class="headerlink" title="Conditional Probability(條件機率)"></a>Conditional Probability(條件機率)</h3><p>在 B 已發生的情況中 A 發生的情況機率是多少，數學符號則是用 \(P(A|B) \)，公式則是 <br>(P(A|B) = \frac{P(A \cap B)}{P(B)}\)</p>
<ul>
<li>Multiplication Law(乘法律)<br>\(P(A \cup B) = P(B)P(A|B) \) or \(P(A \cup B) = P(A)P(B|A) \)</li>
</ul>
<h3 id="Independent-Events-獨立事件"><a href="#Independent-Events-獨立事件" class="headerlink" title="Independent Events(獨立事件)"></a>Independent Events(獨立事件)</h3><p>A 事件發生跟 B 事件會不會發生無關，反之也是。<br>用邏輯式來說就是 \(P(A|B) = P(A) \) or \(P(B|A) = P(B) \)</p>
<h3 id="Mutual-Exclusiveness-and-Independence-互斥事件"><a href="#Mutual-Exclusiveness-and-Independence-互斥事件" class="headerlink" title="Mutual Exclusiveness and Independence(互斥事件)"></a>Mutual Exclusiveness and Independence(互斥事件)</h3><p>假如 A 發生則 B 不發生，反之也是，但因為他們有反向關係，所以他們有相依關係。</p>
<h3 id="Bayes’-Theorem-貝氏定理"><a href="#Bayes’-Theorem-貝氏定理" class="headerlink" title="Bayes’ Theorem (貝氏定理)"></a>Bayes’ Theorem (貝氏定理)</h3><p>在已知的一些條件下，某事件的發生機率。</p>
<h4 id="Bayes’-Theorem-貝氏定理-公式"><a href="#Bayes’-Theorem-貝氏定理-公式" class="headerlink" title="Bayes’ Theorem (貝氏定理) 公式"></a>Bayes’ Theorem (貝氏定理) 公式</h4><blockquote>
<p><img src="/images/statistics-ch4A/2.PNG" alt=""></p>
</blockquote>
<h4 id="Example-A"><a href="#Example-A" class="headerlink" title="Example A"></a>Example A</h4><p>\(A_1 = True = 0.7 \), \(A_2 = False = 0.3 \)<br>\(P(B|A_1) = 0.2 \) and \(P(B|A_2) = 0.9 \)</p>
<h5 id="Hence"><a href="#Hence" class="headerlink" title="Hence"></a>Hence</h5><p>\(P(B^c|A_1) = 0.2 \) and \(P(B|A_2) = 0.9 \)<br>\(P(B|A_1) = 0.8 \) and \(P(B^c|A_2) = 0.1 \)</p>
<blockquote>
<p><img src="/images/statistics-ch4A/1.PNG" alt=""></p>
</blockquote>
<h5 id="Example-apply-Bayes’-Theorem"><a href="#Example-apply-Bayes’-Theorem" class="headerlink" title="Example apply Bayes’ Theorem"></a>Example apply Bayes’ Theorem</h5><blockquote>
<p><img src="/images/statistics-ch4A/3.PNG" alt=""></p>
</blockquote>
<h5 id="表格表示貝氏定理與結論"><a href="#表格表示貝氏定理與結論" class="headerlink" title="表格表示貝氏定理與結論"></a>表格表示貝氏定理與結論</h5><blockquote>
<p><img src="/images/statistics-ch4A/4.PNG" alt=""></p>
</blockquote>
<h5 id="Example-B"><a href="#Example-B" class="headerlink" title="Example B"></a>Example B</h5><p>\(A_1\) 與 \(A_2\) 是互斥事件</p>
<blockquote>
<p><img src="/images/statistics-ch4A/6.PNG" alt=""></p>
</blockquote>
]]></content>
      <categories>
        <category>北科上課筆記</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>統計學筆記</tag>
        <tag>北科大二上統計學筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>惠特產學合作心得與紀錄</title>
    <url>/2020/10/30/life_experence/fittech_experence/</url>
    <content><![CDATA[<blockquote>
<p>僅此紀錄大衛大一下至大二上參加惠特科技產學合作心得。<br>「紀錄每個時刻，讓未來的自己不遺忘過去的自己」<br>只有自己才能體會自己的過去<br>謝謝惠特副總經理與洪揮霖老師與官齊笎陪伴我成長。</p>
</blockquote>
<a id="more"></a>

<h2 id="自我反省"><a href="#自我反省" class="headerlink" title="自我反省"></a>自我反省</h2><p>老實講，在我做產學合作時其實我並沒有想要做 Blog 紀錄所以有很多部分可能已經在我的印象中遺失，蠻對不起未來的大衞的…，那就讓現在當下的我把僅剩的印象記錄下來吧，不然這份回憶可能就被我丟失在成長的路上了。</p>
<h2 id="惠特的初次見面"><a href="#惠特的初次見面" class="headerlink" title="惠特的初次見面"></a>惠特的初次見面</h2><p>在大一上時，我滿腔熱血但我卻不知道要怎麼樣發展，台北科大的老師們可能不太擅長去找出幾個比較有想法的學生來幫助他成長，<del>對不起，我又黑北科</del>，可是我真的覺得北科的老師有些真的很混，以後可以多一篇文章來描述此事情。講太多了，回歸正題，那時候我的系上學長(方宇)問我要不要來參加專案，再有內推的關係之下果不其然我就進入了這次的產學合作XD。</p>
<p>人脈真的要打好，但能力一定要有。沒有能力只有人脈就像人力仲介一樣，我不想當那樣的人。</p>
<p>之後惠特公司副總就來到北科與我們說明這次的產學合作有 3 個專案，分別來讓北科的學習去嘗試與實習，我選擇的是專題一，聽起來我較有把握去解決此題目，對我而言我對這題的方向感也比起其他兩題的方向感更為踏實些。</p>
<h2 id="專案實踐-初期"><a href="#專案實踐-初期" class="headerlink" title="專案實踐 - 初期"></a>專案實踐 - 初期</h2><p>專案一(資料內插)，主要是給我們一個已經遺失的圖片(其實不是圖片是LED，但這樣講可能不太好懂，以下我就用圖片來講)，遺失率可能達到 80%，我們試著用 Laplace Interpolation (資料內插) 的方式來解決此問題。</p>
<p>一開始我們知道要用 Laplace Interpolation 來解決問題，聽起來很專業對不對？但其實還好主要就是有 15 個方程式去解決此問題。</p>
<blockquote>
<p>Laplace Interpolation 介紹</p>
</blockquote>
<p><img src="/images/fittech_experence/1.jpg" alt=""></p>
<p>但我們就算知道了題目的要求與需求我們還是不知道要怎麼去解決它，<del>對不起我就爛</del>，主要是因為我們的背景知識不足，線性代數、理論與證明…等，導致我們初期是一直在想要用自己的方式去把這題給完成，但實在是沒辦法完成，一個孩子哪有辦法蓋好一棟大房子，在我們百思不得其解時，就慢慢進入惠特第二次來北科督察的時候…。</p>
<p>第二次來北科督察後，惠特副總人很好他並沒有因為我們不會這些背後的理論而給予我們壓力，他給了我們一些解決的想法，讓我們去從中想出如何解出這題，也在這次的會議中提點我們當自己無法解決此能力時，先去外面爬一些相關資料，再根據一些相關資料找出其相關的論文。於是一開始她告訴我們像解決此問題時我們可以使用<strong>高斯消去法</strong>來解決相關問題。</p>
<h2 id="專案實踐-中期"><a href="#專案實踐-中期" class="headerlink" title="專案實踐 - 中期"></a>專案實踐 - 中期</h2><p>既然已經被別人提點了，那我理應要透過別人提點的方法去嘗試，於是我就先試寫了一遍高斯消去法並自行測試，測試成功後，在詢問惠特公司的數據最大量是多少，多少我已經有點記不得了(當時沒有紀錄，可惡)，當最普通的高斯消去法是一定沒有辦法解決的，必須要再去找出更好的方法。</p>
<p>既然我已經知道要去找出更好的方法，那就是先去 google 一些比起高斯消去法效率更好的解法，在 google 中得知 Gauss-Seidel 方法比起高斯消去法效率更好，高斯消去法是 \(O(n^5)\)， Gauss-Seidel 方法則是 \(O(n^3)\)。</p>
<p>我知道方法後，我就要去實踐它，但這時候遇到一些麻煩點，我不知道怎麼實踐QQ，我雖然知道這方法也懂這方法在做甚麼，理論跟證明也都大概了解，但當我要把它寫成程式時我卻卡關，只好再問問 google 有沒有 Gauss-Seidel 的舉例，讓我可以更好了解。我有一個壞毛病，光看理論與證明通常我的腦袋還不太會有想法去怎麼實踐他，但只要給我範例我就有辦法去實踐它，很奇怪吧！但我透過舉例的學習能力真的比看證明的學習能力還強許多，可能我應該要讀台北工專吧XD。</p>
<blockquote>
<p>數值線性方程式演算法介紹       </p>
</blockquote>
<p><img src="/images/fittech_experence/2.jpg" alt=""></p>
<p>後來在 Google 那個衣櫃翻資料時找到一個非常棒的網站，此網站縮寫是<strong>MAA(美國數學協會)</strong>，他們有著非常詳細的說明與講解來增加大家對於數學的知識，他們超棒、超讚，我一看完他們的教學在配上我自己動手寫一遍，我馬上就完全理解 Gauss-Seidel 幸好有他們這個網站加速我學習的速度，不然我可能還要再 Google 這個雜亂衣櫃找到有用的資訊可能還要再花一段時間XD，不過 Google 真的很棒，沒他我連沒有用的資訊都找不到呢！</p>
<p>我原本是要在這邊放上我自己手寫 Gauss-Seidel 的圖片，但是那時候自己還沒有意識到紀錄的重要性，我很難過。</p>
<p>其實專題二原本是另一位學長製作但他可能太忙了就沒有來接手此問題，於是我希望齊笎來幫助我們解決這次的大問題，齊笎直接肯定與願意幫助我的問題讓我超級感動的 ಥ⌣ಥ，齊笎真的是我的最佳幫手，從高中如果還沒有在中途就遺失的朋友真的都是真心的，幸好我身邊還有一堆好朋友願意幫助我。齊笎願意來扛下第二題的重責大任並且也負責第一題的介面，再跟他討論第一題的介面時我是快樂的、相處起來也是，加上他的 UI 介面設計功能算蠻不錯用，真的是辛苦她了，沒有他我一定要做得更辛苦甚至有可能做不好。</p>
<blockquote>
<p> 齊笎的背影照</p>
</blockquote>
<p><img src="/images/fittech_experence/12.jpg" alt=""></p>
<p>原本這裡應該是要放下跟他一起的合照的，但我發現我竟然沒有跟他合照，看來我太不喜歡拍照了之後要好好補足這個能力，拜科技之賜社會在進步我的思想卻沒有進步，自己也太差了吧XD。</p>
<h2 id="專案實踐-後期"><a href="#專案實踐-後期" class="headerlink" title="專案實踐 - 後期"></a>專案實踐 - 後期</h2><p>其實中間遇到兩個大麻煩，一個是陣列沒辦法開那麼大，這裡我們假設陣列應該要開到 8000*8000 但是 C# 裡面其實是沒有辦法開到這麼大的，所以翻找了許多技術文章來解決此問題，這裡就不贅述翻找資料的痛苦了，如果也有夥伴們像我一樣遇到問題可以查看此文章 <a href="https://theriseofdavid.github.io/2020/06/16/C_sharp/C-sharp-big-array/" target="_blank" rel="noopener">C# 開超大陣列解決方法</a>。</p>
<p>另一個問題則是個人認為 Gauss-Seidel 方法可能還是有些許的慢，還想要更加增進自己，於是我自己就上網再去問問 Google 有沒有更好的解答，答案是有，要用 <strong>SOR(逐次超鬆馳法)</strong>，以下就簡稱 SOR，它可以幫助我們效率在更加提升，加速收斂，但有要特別注意的點就是 \(\omega \) 必須要找好不然就可能沒辦法有很好的收斂效果。</p>
<blockquote>
<p>SOR(逐次超鬆馳法) 方法介紹</p>
</blockquote>
<p><img src="/images/fittech_experence/3.jpg" alt=""></p>
<p>隨後我們就去實踐它，發現真的有更好的效果，當下真的是充滿喜悅，透過自己的雙手去完成一件事情，不敢說自己做的是很優秀的事，但總感覺自己完成了一件原本自己並不太懂的東西真的是很令人振奮呢！學會每一件事情都會讓自己的視野更加遼闊，但就像我 Blog 說的 <strong>After climbing a great hill, one only finds that there are many more hills to climb.</strong>，看來還有很多的 hills 等待我去攀爬。</p>
<blockquote>
<p>Gauss-Seidel 在此專題中的時間複雜度，請注意，這裡的陣列遺失率並不一定等於 50%</p>
</blockquote>
<p><img src="/images/fittech_experence/4.jpg" alt=""></p>
<blockquote>
<p>SOR(逐次超鬆馳法) 在此專題中的時間複雜度，請注意，這裡的陣列遺失率並不一定等於 50%</p>
</blockquote>
<p><img src="/images/fittech_experence/5.jpg" alt=""></p>
<p>有些比較細心的讀者應該有看到為甚麼 PPT 的陣列遺失率並不一定等於 50 % 呢，其實很簡單，因為我是對陣列每一個元素隨機 1~100 ，只要是偶數就遺失奇數就表示存在，所以在<strong>最理想</strong>情況遺失機率應該是 50%。</p>
<h2 id="參觀台中公司"><a href="#參觀台中公司" class="headerlink" title="參觀台中公司"></a>參觀台中公司</h2><p>過程中我們要去台中惠特公司參訪，老師讓我先去訂車，我打了好多通電話都沒有預約到車，好難過…，幸好最後還是有預約到車，不然我就尷尬呢我XD，於是我們預約到車後就等待參訪時間來臨，前往台中其實並不算塞，但屁股還是有點坐到痛痛的，沒想到台中工業區與台中高鐵站有相當長的一段時間，原本還想說先到台中高鐵站在搭計程車就好，老師決定租車直接前往惠特公司果然是正確的選擇，我還是有點太年輕了QQ，用台北的思維看台灣呀，不過過程中有跟老師聊天也是相當開心的一件事情。</p>
<p>惠特公司貼著一排關於業務以及認真表現員工的嘉許，總覺得那看起來就是用自己的辛苦堆疊起來的，很偉大呀！</p>
<p>我們有點太早到惠特科技，我們先坐在會議室裏面吃午餐，隨後等待惠特工作人員來像我們介紹公司，他們有分研發部門與生產部門，研發部門我蠻有興趣的，有種讓我眼睛突然亮起來，而到他們的生產部門時則看到許多機台正在努力運作一點都不會累，<del>機器怎麼會累</del>，看著那些高精密儀器又聽到他們的價錢時，心裡想著：「天啊，我這輩子能不能賺到這麼多錢呢？」，希望我自己有能力可以變成優秀的人，幫助別人也可以養活自己，不然連自己都養不活有點沒用呀！</p>
<p>回來的過程到新竹時則有點塞，原因是新竹的工程師都正準備下班，恩，我聞到整條高速公路都是台灣生產著的味道呢XD，開玩笑的，大家都為了自己的夢想或現實在努力的工作吧！我以後應該也會成為這樣的人度過一生吧，希望我能做出些幫助到大家的事情，不管是認識或是不認識的那是再好不過的！</p>
<blockquote>
<p>在參訪回程時隨意拍的一張照片</p>
</blockquote>
<p><img src="/images/fittech_experence/6.jpg" alt=""></p>
<p>由於我們租車的時間過長，為甚麼會過長呢？因為我誤算來回時間導致我們要離開惠特公司時是 15:30，但我們租車結束的時間是 21:00，這點我還需要再<strong>改進</strong>，不然就會像這次一樣浪費經費，讓我很對不起大家，為了拖長租車時間於是我們就讓老師和每位學生都可以在自己的住所附近直接下車，有楊梅、鶯歌與北科，沒想到楊梅－鶯歌這一段特別塞車，有點討厭呀！</p>
<h2 id="專案後期-報告"><a href="#專案後期-報告" class="headerlink" title="專案後期 - 報告"></a>專案後期 - 報告</h2><p>在昨天，也就是 2020/10/29，即將接近專案結案，於是我們要報告目前進度，專題一的進度目前接近於成熟，但專案二礙於技術問題不斷遇到障礙還需要克服就比較麻煩了，專題二就花了蠻多的時間在講解理論與探討，而專案一則就是 PPT 報告與實際 demo，由於我對此專案有很深的了解，<del>畢竟是我做的XD</del>，我就把我的心得與技術全部都說出，當我講出 C# 如何開出超大陣列時副總有說出一句「我這一趟沒有白來」時，我的內心是非常開心與擁有成就感的，能夠被大公司的副總經理給認同這對一個大學生來說是有多大的榮幸呀！</p>
<blockquote>
<p>專題二老師與副總正在講解與理論與探討 (第一張，共二張)</p>
</blockquote>
<p><img src="/images/fittech_experence/10.jpg" alt=""></p>
<blockquote>
<p>專題二老師與副總正在講解與理論與探討 (第二張，共二張)</p>
</blockquote>
<p><img src="/images/fittech_experence/11.jpg" alt=""></p>
<blockquote>
<p>應用程式介紹 - 輸入資料</p>
</blockquote>
<p><img src="/images/fittech_experence/8.jpg" alt=""></p>
<blockquote>
<p>應用程式介紹 - 輸入完成</p>
</blockquote>
<p><img src="/images/fittech_experence/9.jpg" alt=""></p>
<p>在過程中副總也與我們閒聊了一些，關於我們學習的觀念，有些部分與我的經驗相同有些則我還需要去磨練可能才能理解，最有共鳴的應該就是<strong>做中學</strong>，只要去實踐一次就肯定能懂那些高深的理論在講甚麼，理解之後就能存在自己的記憶中在需要時被提出，但我報告也有部分缺失，例如 Gauss-Seidel 的 inverse 我並沒有講的很好，這點我還需要特別注意，下次再報告時不要對自己太有信心，還是要把所有的理論仔細地都檢查一次才不會讓<strong>自己之前看得懂，現在看不懂的窘境</strong>。</p>
<p>不知為何，被副總稱讚是一件令人開心的事情，可能是我的努力被肯定了吧XD。</p>
<blockquote>
<p>我沒有講好的部分，紅色圈圈的部分</p>
</blockquote>
<p><img src="/images/fittech_experence/7.PNG" alt=""></p>
<p>而我還需要在做一些專案一的驗證與調整，例如我們的矩陣要改成可以掃描圓形，並不要只能掃描正方形，以及驗證，但我相信應該是沒有問題的。</p>
<p>其中也要謝謝胡小姐過程中可以幫我許多忙，這一路上要是沒有他，我在行政上的問題會非常棘手，真的要謝謝他幫助我許多事情，我原本還怕因為我是大學生可能還會被瞧不起QQ，但其實不會的！他人最好，YA。</p>
<h2 id="對自己說的話"><a href="#對自己說的話" class="headerlink" title="對自己說的話"></a>對自己說的話</h2><p>原本是想寫些心得的，但其實這整篇都是我的心得也都是我的心路歷程，硬是要在心得裡面再寫些心得似乎有點太多於了，不如就寫點加油的話來對自己增加信心吧！</p>
<p>在這路上有學到蠻多知識的，但我發現我的知識都是破碎不完全，我可能會是知道這個概念，但我不知道這個專有名詞是甚麼，這是我的一個大問題，我需要去改進。也謝謝自己的努力可以讓我一路堅持到這裡，也希望我自己可以繼續努力，現在放棄就輸了，只要我對我的未來好，那現在就會好！</p>
<p>感謝在此產學合作中幫助過我的每一個人，沒有你們就沒有現在的我，謝謝你們幫助我更好，謝謝！</p>
<h2 id="附加檔案"><a href="#附加檔案" class="headerlink" title="附加檔案"></a>附加檔案</h2><p><a href="https://drive.google.com/file/d/177h1DF0Zc4YsdLKJEPb5uWLHF0dvMD1g/view?usp=sharing" target="_blank" rel="noopener">專案一期末報告</a><br><a href="https://drive.google.com/file/d/1Trv-hVrCShLBD_nhSaQORkx1B3pEqX8r/view?usp=sharing" target="_blank" rel="noopener">專案一期中報告</a></p>
]]></content>
      <categories>
        <category>人生旅途</category>
      </categories>
      <tags>
        <tag>大學Life</tag>
        <tag>產學合作</tag>
        <tag>人生旅途</tag>
      </tags>
  </entry>
  <entry>
    <title>QUESTION! 如何回到之前的 commit 版本呢？</title>
    <url>/2020/10/31/git/git-reset-to-commit/</url>
    <content><![CDATA[<h2 id="文章大意："><a href="#文章大意：" class="headerlink" title="文章大意："></a>文章大意：</h2><blockquote>
<p>如果發現最後一次的 commit 並不是最好的版本，想要回去之前的版本要如何做比較好？</p>
</blockquote>
<a id="more"></a>


<h2 id="QUESTION-如何回到之前的-commit-版本呢？"><a href="#QUESTION-如何回到之前的-commit-版本呢？" class="headerlink" title="QUESTION! 如何回到之前的 commit 版本呢？"></a>QUESTION! 如何回到之前的 commit 版本呢？</h2><p>先用 <code>git log --oneline</code> 在找出自己想要復原的版本輸入 <code>git reset --soft XXXXXX</code> 就可以成功復原了，其中<code>XXXXXX</code> 是 <code>git log --oneline</code> 所出來前面的數字則是我們想要復原哪個版本的要求之一。</p>
<p>這裡是應該指令的集中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git log --oneline</span><br><span class="line">git reset --soft XXXXXX</span><br></pre></td></tr></table></figure>

<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://blog.poychang.net/git-how-to-remove-file-and-commit-from-history/" target="_blank" rel="noopener">移除 Git 歷史紀錄</a><br><a href="https://gitbook.tw/chapters/branch/how-git-know-what-current-branch-is.html" target="_blank" rel="noopener">【冷知識】Git 怎麼知道現在是在哪一個分支？</a></p>
<h2 id="心得："><a href="#心得：" class="headerlink" title="心得："></a>心得：</h2><p>git 真的好好用XD，但我是自學的基礎不穩，很多東西都是需要用到才會學，基礎不穩阿，要好好多讓自己嘗試找到缺失之處，然後補足。才可以讓自己獨當一面！</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>演算法知識 - Suffix Automaton 後綴自動機</title>
    <url>/2020/10/31/Explain_Algorithm/suffix-automaton/</url>
    <content><![CDATA[<h2 id="Suffix-Automaton-介紹"><a href="#Suffix-Automaton-介紹" class="headerlink" title="Suffix Automaton 介紹"></a>Suffix Automaton 介紹</h2><blockquote>
<p>Suffix Automaton，簡稱 SAM，(以下內文都簡稱 SAM)，是一個能解決許多字串特定問題的資料結構。</p>
<p>只要關於這兩個字串問題都可以使用 \(O(n)\) 時間複雜度解決：</p>
<ul>
<li>在另一個字串中查詢另一個字串的所有出現位置</li>
<li>計算此字串中裡面有多少不同的子字串</li>
</ul>
<p>簡單來說 SAM 可以理解成字串壓縮，一個 SAM 最多只會有 \(2n-1\) 個節點與 \(3n-4\) 個轉移邊。</p>
<p><strong>建立 SAM 的時間複雜度為 \(O(n)\)</strong></p>
<p>此文章跳開蠻多理論與證明，如果想要知道可再從下方參考連結點選即可</p>
</blockquote>
<a id="more"></a>

<h2 id="Suffix-Automaton-原理"><a href="#Suffix-Automaton-原理" class="headerlink" title="Suffix Automaton 原理"></a>Suffix Automaton 原理</h2><p>需要用到 struct，此 struct 需要 len , link , next，這些的意義為：</p>
<ul>
<li>len 目前的最長長度</li>
<li>link 為當前子字串中第一個<strong>最長</strong>後綴結束位置 </li>
<li>next 連結其他的點的邊，方向是 -&gt;</li>
</ul>
<h3 id="Suffix-Automaton-圖示說明："><a href="#Suffix-Automaton-圖示說明：" class="headerlink" title="Suffix Automaton 圖示說明："></a>Suffix Automaton 圖示說明：</h3><p>我們假設此字串為 “aabbabd”，下方圖片的線為：</p>
<ul>
<li>link 為綠色線</li>
<li>next 為藍色線</li>
<li>len 從起點到終點的最長長度</li>
</ul>
<blockquote>
<p>我們感謝一下畫這張圖的大神，不得不說話的超棒</p>
</blockquote>
<img src="/images/suffix-automaton/1.png" style="border:2px black solid;">

<h3 id="重大的三個特性"><a href="#重大的三個特性" class="headerlink" title="重大的三個特性"></a>重大的三個特性</h3><ul>
<li>跟著<font color="#0000FF">藍色線</font>走到終點時會是必定是 “aabbabd” 的後綴</li>
<li>跟著<font color="#0000FF">藍色線</font>走到任意點必定會是此字串的子字串</li>
<li>發明這個的演算法大師太強了，跟神一般的存在</li>
</ul>
<p><del>好啦，其實是兩個，但是沒有第三個前面兩個都不會成立XD</del><br>根據這張圖大概就能夠理解後綴自動機在說甚麼了<del>，</del>不懂別打我~~。</p>
<h2 id="程式碼實現與說明"><a href="#程式碼實現與說明" class="headerlink" title="程式碼實現與說明"></a>程式碼實現與說明</h2><p>程式碼實現與說明分成三大部分，建構、初始化、SAM 擴增長度。</p>
<h3 id="建構"><a href="#建構" class="headerlink" title="建構"></a>建構</h3><p>一個 SAM 必須要有從出發點到此的最長長度，離起點最近的位置、與連結其他點的邊。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SAMN N*10 </span></span><br><span class="line"><span class="comment">// N 為字串最長長度</span></span><br><span class="line"><span class="keyword">int</span> sz , last ; <span class="comment">// 到 SAM 初始化說明</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">state</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> len , link ; <span class="comment">// len = 最長長度 , link = 當前子字串中第一個最長後綴結束位置 </span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; next ;</span><br><span class="line">&#125;st[SAMN];</span><br></pre></td></tr></table></figure>

<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>先給予一開始的起點，由於起點(當前狀態為空字串)並不會有後綴於是我們 link 直接設為 -1，且長度(len)為 0。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sam_init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    sz = <span class="number">0</span> ;</span><br><span class="line">    st[<span class="number">0</span>].len = <span class="number">0</span> ;</span><br><span class="line">    st[<span class="number">0</span>].link = <span class="number">-1</span> ;</span><br><span class="line">    st[<span class="number">0</span>].next.clear();</span><br><span class="line">    sz++ ;</span><br><span class="line">    last = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SAM-增加長度"><a href="#SAM-增加長度" class="headerlink" title="SAM 增加長度"></a>SAM 增加長度</h3><p>這裡就比較複雜了，應該是說超級複雜，我在程式中一行一行註解相信會更容易許多。</p>
<p><strong>請讀者特別注意，「子字串」跟「字串」要仔細分別，不要忽略會很嚴重</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sam_extend</span><span class="params">(<span class="keyword">char</span> c )</span></span>&#123; <span class="comment">//char c 要擴增的字元</span></span><br><span class="line">    <span class="keyword">int</span> cur = sz++ ; <span class="comment">//sz++ 增加 sam array 長度 , cur 為當前的 sam 節點</span></span><br><span class="line">    st[cur].next.clear() ; <span class="comment">//先把當前的 sam 連接點狀態移除</span></span><br><span class="line">    st[cur].len = st[last].len+<span class="number">1</span> ; <span class="comment">//為前一個 sam 節點 len +1 表示其長度</span></span><br><span class="line">    <span class="keyword">int</span> p = last ; <span class="comment">// p = 查詢當前字串的「所有子字串」與新增加 c 後的字串是否有共同後綴，</span></span><br><span class="line">    <span class="comment">//將跑到他們有共同後綴的「前一個位置」</span></span><br><span class="line">    <span class="comment">//注意：這裡的共同後綴只要有一個字元是就可以是共同後綴</span></span><br><span class="line">    <span class="comment">//舉例："abca" and "abcab" 中的 'b' 就是共同後綴</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(p != <span class="number">-1</span> &amp;&amp; !st[p].next.count(c))&#123; <span class="comment">// p = -1 表示已經到起點，</span></span><br><span class="line">        <span class="comment">// !st[p].next.count(c) 則是詢問增加此字元後是否會有共同後綴的情形，</span></span><br><span class="line">        <span class="comment">// 如果有則需要額外處理</span></span><br><span class="line">        st[p].next[c] = cur ; <span class="comment">// 將前面的點與現在的 sam 節點做連結</span></span><br><span class="line">        p = st[p].link ; <span class="comment">// 由於現在的字元並沒有和前面的子字串有共同後綴，</span></span><br><span class="line">        <span class="comment">// 於是他們的 link 就向上追蹤</span></span><br><span class="line">        <span class="comment">// 如果有則 st[p].next.count(c) == TRUE 不符合迴圈要求</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="number">-1</span>)&#123; </span><br><span class="line">        <span class="comment">// p = -1 表示沒有共同後綴且此字元在當前字串中從沒出現過，</span></span><br><span class="line">        <span class="comment">//才回到了起始點，所以將 link 設置為 0 </span></span><br><span class="line">        st[cur].link = <span class="number">0</span> ; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> q = st[p].next[c] ; <span class="comment">// q 為他們共同後綴的位置</span></span><br><span class="line">        <span class="keyword">if</span>(st[p].len + <span class="number">1</span> == st[q].len)&#123; </span><br><span class="line">            <span class="comment">//如果 st[p].len + 1 == st[q].len 表示「不同位置但相同字元」的共同後綴長度大於一</span></span><br><span class="line">            <span class="comment">//只需要直接將當前的 sam[cur].link 設定成 q 也就是共同後綴的位置 </span></span><br><span class="line">            st[cur].link = q ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123; <span class="comment">// 如果不同位置但相同字元的共同後綴如果等於一，則需要連創建新的 sam 節點，</span></span><br><span class="line">            <span class="comment">// 建立以 c + 字串前一個字元的後綴(前一個並不包括我們現在新增的 c)，</span></span><br><span class="line">            <span class="comment">// 並同時放棄另一個不同位置但也是 c 字元的後綴，但要持續存在以保護先前做好的 sam</span></span><br><span class="line">            <span class="keyword">int</span> clone = sz++ ; <span class="comment">// 創建新節點</span></span><br><span class="line">            st[clone].len = st[p].len + <span class="number">1</span> ; <span class="comment">// 表示從共同後綴的前一個位置 +1，</span></span><br><span class="line">            <span class="comment">//用來建立以 c + 字串前一個字元的後綴</span></span><br><span class="line">            st[clone].next = st[q].next ; <span class="comment">//複製 q 的 next，因為前面已經設定好連接的點，</span></span><br><span class="line">            <span class="comment">//但是因為共同後綴不同，後面還需要一個 while 迴圈進行調整</span></span><br><span class="line">            st[clone].link = st[q].link ; <span class="comment">//將他們 link 先設置相同，</span></span><br><span class="line">            <span class="comment">//之後用 while 迴圈再移動到正確的 link</span></span><br><span class="line">            <span class="keyword">while</span>(p != <span class="number">-1</span> &amp;&amp; st[p].next[c] == q)&#123; </span><br><span class="line">                <span class="comment">//p != -1 是不可以讓她更改起始點的位置</span></span><br><span class="line">                <span class="comment">//st[p].next[c] == q 接下來的點是從 clone 繼續擴展而不是原先的 q，</span></span><br><span class="line">                <span class="comment">//所以要將原先連接到 q 的點全部改連接至 clone</span></span><br><span class="line">                st[p].next[c] = clone ; <span class="comment">//更改連接點至 clone</span></span><br><span class="line">                p = st[p].link ; <span class="comment">// 繼續往上層追蹤</span></span><br><span class="line">            &#125;</span><br><span class="line">            st[q].link = st[cur].link = clone ;</span><br><span class="line">            <span class="comment">// 最後則是也要把 q and cur 的 link 改到 clone，</span></span><br><span class="line">            <span class="comment">// 原因則是因為接下來的點是從 clone 繼續擴展而不是原先的 q</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    last = cur ; <span class="comment">//準備下一次的擴展</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>想必蠻多讀者看完還是不知道這到底是甚麼鬼對不對？<del>沒關係，我自己在寫這個註解花了三小時，我自己都不太知道怎麼說明比較好，這有點太抽象了</del></p>
<p>我在這邊<strong>強烈希望讀者</strong>可以根據我的 Exercise 練習，就可以知道不容易寫以及其抽象的原因。</p>
<h4 id="EXERCISE-A-劃出-SAM-的圖，字串是-“abccba”"><a href="#EXERCISE-A-劃出-SAM-的圖，字串是-“abccba”" class="headerlink" title="EXERCISE A: 劃出 SAM 的圖，字串是 “abccba”"></a>EXERCISE A: 劃出 SAM 的圖，字串是 “abccba”</h4><h4 id="EXERCISE-B-根據-Exercise-A-甚麼時後會用到-if-st-p-len-1-st-q-len-的-else-情況？"><a href="#EXERCISE-B-根據-Exercise-A-甚麼時後會用到-if-st-p-len-1-st-q-len-的-else-情況？" class="headerlink" title="EXERCISE B: 根據 Exercise A 甚麼時後會用到 if(st[p].len + 1 == st[q].len) 的 else 情況？"></a>EXERCISE B: 根據 Exercise A 甚麼時後會用到 <code>if(st[p].len + 1 == st[q].len)</code> 的 <code>else</code> 情況？</h4><p>在現在新增字元與現在的 SAM 圖中字元一樣但後綴不大於一時，新增 clone 點，並放棄原本的 q 點，但必須保留以保證先前的 SAM 狀態正確。</p>
<h2 id="SAM-應用"><a href="#SAM-應用" class="headerlink" title="SAM 應用"></a>SAM 應用</h2><p>我在學習此演算法的過程中如果有題目讓我應用到此演算法我則收錄在此，連結則是我的詳解如果想要去看題目的就搜尋一下吧！</p>
<h3 id="最小循環移位"><a href="#最小循環移位" class="headerlink" title="最小循環移位"></a>最小循環移位</h3><ul>
<li><a href="https://theriseofdavid.github.io/2020/11/01/UVa/UVa719/" target="_blank" rel="noopener">UVa719 - Glass Beads (Suffix Automaton 後綴自動機 - 最小循環移位 Lexicographically minimum string rotation)</a></li>
</ul>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://oi-wiki.org/string/sam/#_17" target="_blank" rel="noopener">后缀自动机 (SAM)</a><br><a href="https://blog.csdn.net/stevensonson/article/details/81748438?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param" target="_blank" rel="noopener">后缀自动机学习笔记</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>感覺 SAM 沒有學得很好啊 ಥ⌣ಥ，沒辦法把一個抽象的事物說明的很清楚是我的問題呀，嗚嗚嗚嗚，這次就算有手寫程式碼以後還是有很多的學習盲點沒有意識到，慢慢再看其他教導 SAM 的文章才搞懂了些，SAM 是一個很酷、很強大的資料結構，發明 SAM 的人是一個大神吧。</p>
<p>這一次我不會說學習 SAM 會增加我的思維，因為我在寫完 blog 的感覺並沒有幫助我擴展我的思維，我想是我理解的不夠深或是依我當前的背景知識學習 SAM，會讓我自己不懂優秀的人們背後的學習理論，而導致我可能是用<strong>死背</strong>的方式得出結論。</p>
<p>雖然我有可能是用死背的方式得出結論，但我也花了一個禮拜在嘗試與思考此問題，我的腦袋沒有辦法好好描述 SAM 的程式碼，但我的腦袋卻告訴我她已經熟悉這個算法，但我無法肯定是不是用背的還是理解的，希望我自己是有理解到但只是我的腦袋還沒辦法用口語述說。</p>
<p>自學很好，但自學常常會遇到很多思考盲點；因為自學比較難有系統地去學習，學習方式是用跳躍的，常常是自己在學習其他觀念時才會想到，對欸！我之前學的哪個演算法就是用這個基礎去延伸的，這樣其實不太好，有點討厭，但我一路以來的學習方法也都是如此，可能也沒有辦法再去讓自己習慣另一種模式，就繼續堅持下去吧！我相信只要我堅持，美好的成果我一定也能品嘗到的！</p>
<p>也謝謝 OI WIKI 與 stevensonson 一個用證明與理論來讓我學習 SAM、優質的 SAM 程式碼讓我對此演算法學習速度更快，另一個則是使用圖加速了我對 SAM 的理解，謝謝二位大神，也還希望 stevensonson 願意讓我用此圖來對未來可能會忘記這演算法的我、其他想學的人進行說明，謝謝！</p>
<p>我也花了七個小時撰寫文章，看得懂跟說得出來真的是兩回事，也許還有人覺得我說的很差，不過我已經盡力解釋。希望可以幫助到各位。</p>
<p>也希望大家想要學習的知識都可以快速學習而成，不要因為自身的環境不足而學習不到。</p>
<h2 id="SAM-無註解程式碼"><a href="#SAM-無註解程式碼" class="headerlink" title="SAM 無註解程式碼"></a>SAM 無註解程式碼</h2><p>這裡則放置沒有註解的程式碼，如果讀者想要複製就從這裡進行複製吧！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">state</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> len, link;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXLEN = <span class="number">100000</span>;</span><br><span class="line">state st[MAXLEN * <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> sz, last;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sam_init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  st[<span class="number">0</span>].len = <span class="number">0</span>;</span><br><span class="line">  st[<span class="number">0</span>].link = <span class="number">-1</span>;</span><br><span class="line">  sz++;</span><br><span class="line">  last = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sam_extend</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> cur = sz++;</span><br><span class="line">  st[cur].len = st[last].len + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> p = last;</span><br><span class="line">  <span class="keyword">while</span> (p != <span class="number">-1</span> &amp;&amp; !st[p].next.count(c)) &#123;</span><br><span class="line">    st[p].next[c] = cur;</span><br><span class="line">    p = st[p].link;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (p == <span class="number">-1</span>) &#123;</span><br><span class="line">    st[cur].link = <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> q = st[p].next[c];</span><br><span class="line">    <span class="keyword">if</span> (st[p].len + <span class="number">1</span> == st[q].len) &#123;</span><br><span class="line">      st[cur].link = q;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">int</span> clone = sz++;</span><br><span class="line">      st[clone].len = st[p].len + <span class="number">1</span>;</span><br><span class="line">      st[clone].next = st[q].next;</span><br><span class="line">      st[clone].link = st[q].link;</span><br><span class="line">      <span class="keyword">while</span> (p != <span class="number">-1</span> &amp;&amp; st[p].next[c] == q) &#123;</span><br><span class="line">        st[p].next[c] = clone;</span><br><span class="line">        p = st[p].link;</span><br><span class="line">      &#125;</span><br><span class="line">      st[q].link = st[cur].link = clone;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  last = cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="用紙筆去模擬-SAM"><a href="#用紙筆去模擬-SAM" class="headerlink" title="用紙筆去模擬 SAM"></a>用紙筆去模擬 SAM</h2><p>因為只是自己在思考過程中隨手做的筆記，覺得不是對讀者這麼有幫助，因此放在文章最下面。</p>
<p>有時候用想或用看的可能不太能夠懂這演算法，那就用寫的吧！這是大衛我自己學習的手稿，紀錄者我的學習過程。</p>
<blockquote>
<p>這裡的舉例是用 “daviddavid”</p>
</blockquote>
<p><img src="/images/suffix-automaton/2.jpg" alt=""><br><img src="/images/suffix-automaton/3.jpg" alt=""></p>
<blockquote>
<p>最後一張則是我自己其他幫助我自己內心釐清的手稿，非常沒用，不要看，我純紀念用</p>
</blockquote>
<p><img src="/images/suffix-automaton/4.jpg" alt=""></p>
]]></content>
      <categories>
        <category>演算法知識</category>
      </categories>
      <tags>
        <tag>程式解題</tag>
        <tag>字串處理</tag>
        <tag>演算法知識</tag>
        <tag>最小循環移位 Lexicographically minimum string rotation</tag>
        <tag>Suffix Automation 後綴自動機</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa719 - Glass Beads (Suffix Automation 後綴自動機 - 最小循環移位 Lexicographically minimum string rotation)</title>
    <url>/2020/11/01/UVa/UVa719/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>有一串項鍊由於線繩脆弱，可能會在最重與最輕的珠子的中間因為重力關係而導致繩線裂開，這些珠子的權重分別用英文字母表示，由於這些英文字母是循環的，給你一組字串試問怎麼樣找出此字串<strong>字典序</strong>最小的循環字串。</p>
<p>循環字串：假如字串有 “abc”，那則會 abcabcabc… 不斷循環下去，但總長度必定為原本字串長度，類似於項鍊。</p>
</blockquote>
<a id="more"></a>

<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>這題使用 Suffix Automation 做<strong>最小循環移位(Lexicographically minimum string rotation)</strong>是不錯的選擇，Suffix Automation 是甚麼？那你可以看看<a href="https://theriseofdavid.github.io/2020/10/31/Explain_Algorithm/suffix-automaton/" target="_blank" rel="noopener">演算法知識 - Suffix Automaton 後綴自動機</a>，裡面有對於 Suffix Automation 做出還不賴的說明，也可以利用他的參考連結去找到更適合你的說明方式。</p>
<h3 id="QUESTION-最小循環移位-Lexicographically-minimum-string-rotation-是甚麼？"><a href="#QUESTION-最小循環移位-Lexicographically-minimum-string-rotation-是甚麼？" class="headerlink" title="QUESTION: 最小循環移位(Lexicographically minimum string rotation) 是甚麼？"></a>QUESTION: 最小循環移位(Lexicographically minimum string rotation) 是甚麼？</h3><p>給你一組字串，找出字典序最小的循環字串，<del>沒錯，就是這題的題目，非常純粹的模板題</del>。</p>
<h4 id="要怎麼解開呢？"><a href="#要怎麼解開呢？" class="headerlink" title="要怎麼解開呢？"></a>要怎麼解開呢？</h4><p>其實容易想到，只需要將原本的字串複製一次給原本的字串，即<code>string += string</code>，透過從起始點一路跟著當下可以走的最小字典序節點走，走到原先字串的長度，在<code>k-string.length()+1</code>，就是最小循環移位了。</p>
<h4 id="QUESTION-A-為甚麼只要原本的字串複製一次給原本的字串呢？"><a href="#QUESTION-A-為甚麼只要原本的字串複製一次給原本的字串呢？" class="headerlink" title="QUESTION A: 為甚麼只要原本的字串複製一次給原本的字串呢？"></a>QUESTION A: 為甚麼只要原本的字串複製一次給原本的字串呢？</h4><p>由於第一次的字串長度結束位置 + 字串長度(即第二次循環) &lt; 連續三次循環長度，就算從最後一個字元開始循環也不會大於三次循環，即可證明我們不需要第三次循環，只要循環一次就好。 </p>
<h4 id="簡單的程式碼說明"><a href="#簡單的程式碼說明" class="headerlink" title="簡單的程式碼說明"></a>簡單的程式碼說明</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//st 是 sam、now 是還要再找幾次，一開始為原本字串長度</span></span><br><span class="line"><span class="keyword">while</span>(now--)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it : st[u].next)&#123; <span class="comment">//跟著字典續追蹤</span></span><br><span class="line">        u = it.second ;</span><br><span class="line">        <span class="keyword">break</span> ; <span class="comment">//找到了就往下個節點移動，類似於 DFS</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; st[u].len - len + <span class="number">1</span> &lt;&lt; <span class="string">'\n'</span> ; </span><br><span class="line"><span class="comment">//找到當下的節點後，找出它的長度並且扣掉原始長度並加一即是答案</span></span><br></pre></td></tr></table></figure>

<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://blog.csdn.net/keshuai19940722/article/details/39062669" target="_blank" rel="noopener">uva 719 - Glass Beads(最小表示法 | 后缀自动机)</a><br><a href="https://oi-wiki.org/string/sam/#_17" target="_blank" rel="noopener">后缀自动机 (SAM)</a><br><a href="https://theriseofdavid.github.io/2020/10/31/Explain_Algorithm/suffix-automaton/" target="_blank" rel="noopener">演算法知識 - Suffix Automaton 後綴自動機</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>其實學會了 SAM 之後，發現這個應用沒有難度欸XD，SAM 太讚了，SAM 不知道是哪個優秀的演算法大神發明的，真的非常棒，只是我不爭氣了解的不夠透徹、不夠多，我要繼續努力學習演算法，使我變強也能夠獨當一面！也還要複習英文，不然題目可能都看不懂，嗚嗚。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>其實就是沒有附上說明的程式碼，我也花了兩個小時撰寫文章，看得懂跟說得出來真的是兩回事，也許還有人覺得我說的很差，不過我已經盡力解釋。希望可以幫助到各位。</p>
<p>也希望大家想要學習的知識都可以快速學習而成，不要因為自身的環境不足而學習不到。</p>
<p>於是這裡就補述一些題目給的資料範圍限制與標頭檔了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SAMN N*10</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> sz , last ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">state</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> len , link ;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; next ;</span><br><span class="line">&#125;st[SAMN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sam_init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    sz = <span class="number">0</span> ;</span><br><span class="line">    st[<span class="number">0</span>].len = <span class="number">0</span> ;</span><br><span class="line">    st[<span class="number">0</span>].link = <span class="number">-1</span> ;</span><br><span class="line">    st[<span class="number">0</span>].next.clear();</span><br><span class="line">    sz++ ;</span><br><span class="line">    last = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sam_extend</span><span class="params">(<span class="keyword">char</span> c )</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cur = sz++ ;</span><br><span class="line">    st[cur].next.clear() ;</span><br><span class="line">    st[cur].len = st[last].len+<span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">int</span> p = last ;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="number">-1</span> &amp;&amp; !st[p].next.count(c))&#123;</span><br><span class="line">        st[p].next[c] = cur ;</span><br><span class="line">        p = st[p].link ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="number">-1</span>)&#123;</span><br><span class="line">        st[cur].link = <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> q = st[p].next[c] ;</span><br><span class="line">        <span class="keyword">if</span>(st[p].len + <span class="number">1</span> == st[q].len)&#123;</span><br><span class="line">            st[cur].link = q ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> clone = sz++ ;</span><br><span class="line">            st[clone].len = st[p].len + <span class="number">1</span> ;</span><br><span class="line">            st[clone].next = st[q].next ;</span><br><span class="line">            st[clone].link = st[q].link ;</span><br><span class="line">            <span class="keyword">while</span>(p != <span class="number">-1</span> &amp;&amp; st[p].next[c] == q)&#123;</span><br><span class="line">                st[p].next[c] = clone ;</span><br><span class="line">                p = st[p].link ;</span><br><span class="line">            &#125;</span><br><span class="line">            st[q].link = st[cur].link = clone ;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    last = cur ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAl</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAl</span></span></span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n , len;</span><br><span class="line">    <span class="built_in">string</span> strA ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; strA ;</span><br><span class="line">        len = strA.length() ;</span><br><span class="line">        strA += strA ;</span><br><span class="line">        sam_init() ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; strA.length() ; i++) sam_extend(strA[i]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> u = <span class="number">0</span> , now = len  ;</span><br><span class="line">        <span class="keyword">while</span>(now--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> it : st[u].next)&#123;</span><br><span class="line">                u = it.second ;</span><br><span class="line">                <span class="keyword">break</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; st[u].len - len + <span class="number">1</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>程式解題</tag>
        <tag>字串處理</tag>
        <tag>演算法知識</tag>
        <tag>最小循環移位 Lexicographically minimum string rotation</tag>
        <tag>Suffix Automation 後綴自動機</tag>
      </tags>
  </entry>
  <entry>
    <title>演算法知識 - Suffix Tree 後綴樹 (Using Ukkonen Algorithm)</title>
    <url>/2020/11/03/Explain_Algorithm/suffix-tree/</url>
    <content><![CDATA[<h2 id="Suffix-Tree-介紹"><a href="#Suffix-Tree-介紹" class="headerlink" title="Suffix Tree 介紹"></a>Suffix Tree 介紹</h2><blockquote>
<p>Suffix Tree 是字典樹(Trie) 的延伸，透過對一字串的所有後綴去建構樹，是一個能解決許多字串特定問題的資料結構。</p>
<p>以下是 Suffix Tree 能解決的問題：</p>
<ul>
<li>尋找 A 字串是否在字串 B 中</li>
<li>找出 B 在 A 字串重複的次數</li>
<li>最長共同子字串</li>
</ul>
<p>簡單來說 Suffix Tree 是將字串的所有後綴建構成 Trie，再將其壓縮(沒有分支的節點都放在同個節點)。</p>
<p><strong>建立 Suffix Tree 的時間複雜度為 \(O(n)\)，使用 Ukkonen Algorithm</strong><br>通常建構 Suffix Tree 有兩種方法，一種時間複雜度為 \(O(n)\)，另一種為 \(O(n^2)\)，這裡只介紹普遍比賽會經用的演算法(Ukkonen Algorithm)</p>
<p>此文章跳開蠻多證明與理論，如果想要知道可再從下方參考連結點選即可</p>
</blockquote>
<a id="more"></a>

<h2 id="Suffix-Tree-原理-正確來說應該是Ukkonen-Algorithm-原理"><a href="#Suffix-Tree-原理-正確來說應該是Ukkonen-Algorithm-原理" class="headerlink" title="Suffix Tree 原理 (正確來說應該是Ukkonen Algorithm 原理)"></a>Suffix Tree 原理 (正確來說應該是Ukkonen Algorithm 原理)</h2><p>這裡我們借助 Tushar Roy 的 Youtube 影片教學，此教學影片非常棒，連結將放在下方標題的參考連結<br><strong>這裡我們將透過一字串 “xyzxyaxyz$” 來進行解說，有些地方會跟影片不一樣，因為我個人認為這樣寫對學習更有幫助，請不要理會右邊的變數</strong>，EX: remaining , active_Node…。 </p>
<h3 id="名詞介紹"><a href="#名詞介紹" class="headerlink" title="名詞介紹"></a>名詞介紹</h3><p>先來介紹一些我們會用到的名詞</p>
<ul>
<li>remaining 隱藏在 Suffix Tree 中的後綴節點</li>
<li>root = Suffix Tree 的最主要根節點</li>
<li>active_node 活動節點，主要是用來生長葉節點 (leaf)</li>
<li>active_e 隱藏節點的第一個字元</li>
<li>active_len 隱藏在 Suffix Tree 中節點的長度</li>
<li>node 一個 struct 用來存入 Suffix Tree 節點<ul>
<li>start 此節點開始的位置(index)</li>
<li>end 此節點結束的位置(end)<br>舉例： node.start = 3 and node.end = 5，則 string 的長度是 <code>string.substr(3,2)</code>，用數學表示則是 \((start , end ]\)</li>
<li>next 用來指出下一個節點的位置，個人習慣用 map</li>
<li>slink 指出此節點的最長後綴節點，EX: XYZ 則指出 YZ。</li>
<li>edge_length() 公式為 \(min(end,pos+1) - start \)<br>用來找出此節點的字串長度</li>
</ul>
</li>
</ul>
<h3 id="原理說明-初始建構"><a href="#原理說明-初始建構" class="headerlink" title="原理說明 - 初始建構"></a>原理說明 - 初始建構</h3><p>我們必須先建構 Suffix Tree Root，才可以讓 Suffix Tree 慢慢變長，Suffix Tree Root 的 start and end 都是 -1，Root 是起始點且並不包含任何資料。</p>
<ul>
<li>remaining = 0<br>一開始不會有隱藏在 Suffix Tree 中的後綴節點於是設定成 0</li>
<li>root = 1<br>我們捨棄從 0 開始，從 1 開始會更好建構，於是起始點是 1 </li>
<li>active_node = 1<br>由於一開始生長葉節點只能先從 root 開始，所以設定 active_node = root </li>
<li>active_e = 0<br>一開始沒有隱藏節點於是設定成 0</li>
<li>active_len = 0<br>一開始沒有隱藏在 Suffix Tree 中節點的長度，所以設定 0 </li>
</ul>
<h3 id="原理說明-“x”"><a href="#原理說明-“x”" class="headerlink" title="原理說明 - “x”"></a>原理說明 - “x”</h3><p>由於一開始樹中並沒有 x 此字元，直接產生新節點(葉節點)，由於有產生節點，沒有隱藏節點所以 remaining = 0</p>
<ul>
<li>葉節點(node) 建構設定<ul>
<li>start 等於此<strong>字元</strong>位置</li>
<li>end 等於<strong>字串</strong>長度</li>
<li>slink 設定為 0</li>
<li>next.clear()</li>
</ul>
</li>
</ul>
<blockquote>
<p>原理說明 - “x”</p>
</blockquote>
<p><img src="/images/suffix-tree/1.PNG" alt=""></p>
<h3 id="原理說明-“xy”"><a href="#原理說明-“xy”" class="headerlink" title="原理說明 - “xy”"></a>原理說明 - “xy”</h3><p>樹中沒有 y 字元，也直接產生新節點，跟上個步驟一樣。</p>
<blockquote>
<p>原理說明 - “xy”，這裡無法截圖到 remaining 為 0 的狀態，於是自己寫 </p>
</blockquote>
<p><img src="/images/suffix-tree/2.PNG" alt=""></p>
<h3 id="原理說明-“xyz”"><a href="#原理說明-“xyz”" class="headerlink" title="原理說明 - “xyz”"></a>原理說明 - “xyz”</h3><p>樹中沒有 z 字元，也直接產生新節點，跟上個步驟一樣。</p>
<blockquote>
<p>原理說明 - “xyz”，這裡無法截圖到 remaining 為 0 的狀態，於是自己寫 </p>
</blockquote>
<p><img src="/images/suffix-tree/3.PNG" alt=""></p>
<h3 id="原理說明-“xyzx”"><a href="#原理說明-“xyzx”" class="headerlink" title="原理說明 - “xyzx”"></a>原理說明 - “xyzx”</h3><p>樹中已經有 x 字元，且是在 active_node 底下，於是我們不新增節點，以符合壓縮原理，而我們多了一個隱藏節點並將隱藏節點長度則 +1，因為增加 x，且 remaining 也要 +1 表示增加一個隱藏節點。</p>
<blockquote>
<p>原理說明 - “xyzx”</p>
</blockquote>
<p><img src="/images/suffix-tree/4.PNG" alt=""></p>
<h3 id="原理說明-“xyzxy”"><a href="#原理說明-“xyzxy”" class="headerlink" title="原理說明 - “xyzxy”"></a>原理說明 - “xyzxy”</h3><p>樹中已經有 y 字元，且是在 active_node 底下，於是我們不新增節點，以符合壓縮原理，而我們多了一個隱藏節點並將隱藏節點長度則 +1，因為增加 y，且 remaining 也要 +1 表示增加一個隱藏節點。</p>
<p>這時隱藏節點長度(active_len)則變成 2<br>remainging = 2<br>隱藏字元有 “xy”</p>
<blockquote>
<p>原理說明 - “xyzxy”</p>
</blockquote>
<p><img src="/images/suffix-tree/5.PNG" alt=""></p>
<h3 id="原理說明-“xyzxya”"><a href="#原理說明-“xyzxya”" class="headerlink" title="原理說明 - “xyzxya”"></a>原理說明 - “xyzxya”</h3><p>這裡需要比較長的說明，共三個步驟。</p>
<h4 id="step-1"><a href="#step-1" class="headerlink" title="step 1:"></a>step 1:</h4><p>此時的隱藏長度為 2，我們無法因為字元 a 而增加隱藏長度，因為前面是 “xy<strong>z</strong>“(先從隱藏字元方向 “xy” )，而不是 “xy<strong>a</strong>“，所以我們這邊要做出一個切割節點，切割方式為 root 往 x 的邊且長度為 2；來保持 “xyzxya” 後綴與 “xya” 後綴，分裂完成後 remaining 必須 -1，因為 x 此隱藏節點已經產生，隱藏長度(active_len)也需 -1。</p>
<p>這時隱藏節點長度(active_len)則變成 1<br>remainging = 1<br>隱藏字元有 “y”</p>
<blockquote>
<p>原理說明 - “xyzxya” 切割點為 xy </p>
</blockquote>
<p><img src="/images/suffix-tree/6.PNG" alt=""></p>
<h4 id="step-2"><a href="#step-2" class="headerlink" title="step 2:"></a>step 2:</h4><p>此時的隱藏長度為 1，我們無法因為字元 a 而增加隱藏長度，因為前面是 “y<strong>z</strong>“，而不是 “y<strong>a</strong>“，所以我們這邊要做出一個切割節點，切割方式為 root 往 y 的邊且長度為 2；來保持 “yzxya” 後綴與 “ya” 後綴，分裂完成後 remaining 必須 -1，因為 y 此隱藏節點已經產生，隱藏長度(active_len)也需 -1。</p>
<p>此時的 slink 則派上用場，需要指回在隱藏字元 “xy” 時所切割的節點，表示如果 xy 的葉節點們如果也需要更改時則表示隱藏字元 “y” 時所切割的葉節點也需要更改。</p>
<p>這時隱藏節點長度(active_len)則變成 0<br>remainging = 0<br>隱藏字元無</p>
<blockquote>
<p>原理說明 - “xyzxya” 切割點為 y </p>
</blockquote>
<p><img src="/images/suffix-tree/7.PNG" alt=""></p>
<h4 id="step-3"><a href="#step-3" class="headerlink" title="step 3:"></a>step 3:</h4><p>由於一開始樹中並沒有 a 此字元，直接產生新節點(葉節點)，由於有產生節點，沒有隱藏節點所以 remaining = 0</p>
<blockquote>
<p>原理說明 - 新增 a 節點</p>
</blockquote>
<p><img src="/images/suffix-tree/7.PNG" alt=""></p>
<h3 id="原理說明-“xyzxyax”"><a href="#原理說明-“xyzxyax”" class="headerlink" title="原理說明 - “xyzxyax”"></a>原理說明 - “xyzxyax”</h3><p>樹中已經有 x 字元，且是在 active_node 底下，於是我們不新增節點，以符合壓縮原理，而我們多了一個隱藏節點並將隱藏節點長度則 +1，因為增加 x，且 remaining 也要 +1 表示增加一個隱藏節點。</p>
<p>與第一個步驟相似</p>
<p>這時隱藏節點長度(active_len)則變成 1<br>remainging = 1<br>隱藏字元有 “x”</p>
<blockquote>
<p>原理說明 - “xyzxyax”</p>
</blockquote>
<p><img src="/images/suffix-tree/8.PNG" alt=""></p>
<h3 id="原理說明-“xyzxyaxy”"><a href="#原理說明-“xyzxyaxy”" class="headerlink" title="原理說明 - “xyzxyaxy”"></a>原理說明 - “xyzxyaxy”</h3><p>樹中已經有 y 字元，且是在 active_node 底下，於是我們不新增節點，以符合壓縮原理，而我們多了一個隱藏節點並將隱藏節點長度則 +1，因為增加 y，且 remaining 也要 +1 表示增加一個隱藏節點。</p>
<p>這時隱藏節點長度(active_len)則變成 2<br>remainging = 2<br>隱藏字元有 “xy”</p>
<blockquote>
<p>原理說明 - “xyzxyaxy”</p>
</blockquote>
<p><img src="/images/suffix-tree/9.PNG" alt=""></p>
<h3 id="原理說明-“xyzxyaxyz”"><a href="#原理說明-“xyzxyaxyz”" class="headerlink" title="原理說明 - “xyzxyaxyz”"></a>原理說明 - “xyzxyaxyz”</h3><p>樹中已經有 z 字元，且是在 active_node 底下，於是我們不新增節點，以符合壓縮原理，而我們多了一個隱藏節點並將隱藏節點長度則 +1，因為增加 z，且 remaining 也要 +1 表示增加一個隱藏節點。</p>
<p>這時隱藏節點長度(active_len)則變成 3<br>remainging = 3<br>隱藏字元有 “xyz”</p>
<blockquote>
<p>原理說明 - “xyzxyaxyz”</p>
</blockquote>
<p><img src="/images/suffix-tree/10.PNG" alt=""></p>
<h3 id="原理說明-“xyzxyaxyz-”"><a href="#原理說明-“xyzxyaxyz-”" class="headerlink" title="原理說明 - “xyzxyaxyz$”"></a>原理說明 - “xyzxyaxyz$”</h3><p>由於我們希望只要是後綴樹的後綴都可以有一個節點而不被隱藏，於是我們增加一個從未出現的符號，來把這些隱藏節點全部都拉出來新增節點，有點類似於新增 a 的步驟，但在複雜一些，共有四步 。</p>
<h4 id="step-1-1"><a href="#step-1-1" class="headerlink" title="step 1"></a>step 1</h4><p>此時的隱藏長度為 3，我們無法因為字元 $ 而增加隱藏長度，因為前面是 “xyz<strong>x</strong>“，而不是 “xyz<strong>$</strong>“，所以我們這邊要做出一個切割節點，切割方式為 root 往 z 的邊且長度為 1，這是因為前面 xy 已經是一個節點，所以我們就必須先將 active_len 先減 2 的節點在往 z 的方向切割；來保持 “<font color="    #ADADAD" >xy</font>zxyaxyz$” 後綴與 “<font color="    #ADADAD" >xy</font>z$” 後綴，分裂完成後 remaining 必須 -1，因為 z 此隱藏節點已經產生，隱藏長度(active_len)也需 -1。</p>
<p>這時隱藏節點長度(active_len)則變成 2<br>remainging = 2<br>隱藏字元有 “yz”</p>
<blockquote>
<p>原理說明 - “xyzxyaxyz$” 切割點為 <font color="#ADADAD" >xy</font>z，這裡 remainding 應該為 2</p>
</blockquote>
<p><img src="/images/suffix-tree/11.PNG" alt=""></p>
<h4 id="step-2-1"><a href="#step-2-1" class="headerlink" title="step 2"></a>step 2</h4><p>此時的隱藏長度為 2，我們無法因為字元 $ 而增加隱藏長度，因為前面是 “yz<strong>x</strong>“，而不是 “yz<strong>$</strong>“，所以我們這邊要做出一個切割節點，切割方式為 root 往 z 的邊且長度為 1，這是因為前面 y 已經是一個節點，所以我們就必須先將 active_len 先減 1 的節點在往 z 的方向切割；來保持 “<font color="    #ADADAD" >yz</font>xyaxyz$” 後綴與 “<font color="#ADADAD" >yz</font>$” 後綴，分裂完成後 remaining 必須 -1，因為 z 此隱藏節點已經產生，隱藏長度(active_len)也需 -1。</p>
<p>此時的 slink 則派上用場，需要指回在隱藏字元 “xyz” 時所切割的節點，表示如果 xyz 的葉節點們如果也需要更改時則表示隱藏字元 “yz” 時所切割的葉節點也需要更改。</p>
<p>這時隱藏節點長度(active_len)則變成 1<br>remainging = 1<br>隱藏字元有 “z”</p>
<blockquote>
<p>原理說明 - “yzxyaxyz$” 切割點為 <font color="#ADADAD" >y</font>z，這裡 remainding 應該為 1，沒辦法擷取到完整畫面，只好犧牲</p>
</blockquote>
<p><img src="/images/suffix-tree/12.PNG" alt=""></p>
<h4 id="step-3-1"><a href="#step-3-1" class="headerlink" title="step 3"></a>step 3</h4><p>此時的隱藏長度為 1，我們無法因為字元 $ 而增加隱藏長度，因為前面是 “z<strong>x</strong>“，而不是 “z<strong>$</strong>“，所以我們這邊要做出一個切割節點，切割方式為 root 往 z 的邊且長度為 1；來保持 “<font color="    #ADADAD" >z</font>xyaxyz$” 後綴與 “<font color="#ADADAD" >z</font>$” 後綴，分裂完成後 remaining 必須 -1，因為 z 此隱藏節點已經產生，隱藏長度(active_len)也需 -1。</p>
<p>此時的 slink 則派上用場，需要指回在隱藏字元 “yz” 時所切割的節點，表示如果 yz 的葉節點們如果也需要更改時則表示隱藏字元 “z” 時所切割的葉節點也需要更改。</p>
<p>這時隱藏節點長度(active_len)則變成 0<br>remainging = 0<br>隱藏字元無</p>
<blockquote>
<p>原理說明 - “zxyaxyz$” 切割點為 z，這裡 remainding 應該為 0，沒辦法擷取到完整畫面，只好犧牲</p>
</blockquote>
<p><img src="/images/suffix-tree/13.PNG" alt=""></p>
<h4 id="step-4"><a href="#step-4" class="headerlink" title="step 4"></a>step 4</h4><p>由於一開始樹中並沒有 $ 此字元，直接產生新節點(葉節點)，由於有產生節點，沒有隱藏節點所以 remaining = 0</p>
<blockquote>
<p>原理說明 - “xyzxyaxyz$” 切割點為 $</p>
</blockquote>
<p><img src="/images/suffix-tree/14.PNG" alt=""></p>
<h3 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h3><p>以上，就是 Suffix Tree 原理，謝謝各位觀看，如果還是看不太懂可以看Tushar Roy - Coding Made Simple 大神的影片教學，一定比我講得更棒。</p>
<div class="video-container"><iframe src="https://www.youtube.com/embed/aPRqocoBsFQ" frameborder="0" loading="lazy" allowfullscreen></iframe></div>

<h2 id="程式碼實現與說明"><a href="#程式碼實現與說明" class="headerlink" title="程式碼實現與說明"></a>程式碼實現與說明</h2><p>程式碼實現與說明分成三大部分，建構、初始化、SAM 擴增長度。</p>
<h3 id="建構"><a href="#建構" class="headerlink" title="建構"></a>建構</h3><p>這裡比較簡單，於是請直接看此就沒問題的XD。<br><a href="#原理說明-初始建構">原理說明 - 初始建構</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> start , end ,slink ; </span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; next ;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">edge_length</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> min(end , pos+<span class="number">1</span>) - start ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> st , <span class="keyword">int</span> ed = oo)</span></span>&#123;</span><br><span class="line">        start = st ;</span><br><span class="line">        end = ed ;</span><br><span class="line">        slink = <span class="number">0</span> ;</span><br><span class="line">        next.clear() ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;tree[<span class="number">2</span>*N];</span><br></pre></td></tr></table></figure>

<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>建議搭配 <a href="#名詞介紹">名詞介紹</a> 會更好理解。<br>cnt 為我們 Suffix Tree 的總長度</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">st_init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//tree root is 1 not zero</span></span><br><span class="line">    needSL = remainder_ = <span class="number">0</span> ;</span><br><span class="line">    active_node = active_e = active_len = <span class="number">0</span> ;</span><br><span class="line">    pos = <span class="number">-1</span> ;</span><br><span class="line"></span><br><span class="line">    cnt = root = <span class="number">1</span> ;</span><br><span class="line">    active_node = <span class="number">1</span> ;</span><br><span class="line">    tree[cnt++].init(<span class="number">-1</span>,<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Suffix-Tree-擴增長度"><a href="#Suffix-Tree-擴增長度" class="headerlink" title="Suffix Tree 擴增長度"></a>Suffix Tree 擴增長度</h3><p>建議搭配 <a href="#原理說明-“x”">原理說明-“x”</a> 以下全部的<strong>原理說明</strong>會更好理解。<br>這份程式碼與影片教學方式有些許差別，原因是因為這份程式碼我是用簡潔的方式寫，而影片則是用好理解的方式去教導。</p>
<p><strong>請注意 remainder 進入迴圈後是從 1 開始，之後再到迴圈的最後做 -1 的動作，上述原理說明有省略此步</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">active_edge</span><span class="params">()</span></span>&#123; <span class="comment">//隱藏字元的第一個</span></span><br><span class="line">    <span class="keyword">return</span> text[active_e] ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_SL</span><span class="params">(<span class="keyword">int</span> node)</span></span>&#123; <span class="comment">// slink 指回上一個隱藏節點的位置，如果上一個後綴節點的葉節點需要被更改時，</span></span><br><span class="line"><span class="comment">// 這裡的下方葉節點也能被迅速被更改，達到 O(1) 效果</span></span><br><span class="line">    <span class="keyword">if</span>(needSL &gt; <span class="number">0</span> ) tree[needSL].slink = node ;</span><br><span class="line">    needSL = node ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">walkdown</span><span class="params">(<span class="keyword">int</span> node)</span></span>&#123; <span class="comment">//即 原理說明 - "xyzxyaxyz$" 的 step 1， xyz 但 xy 是一個節點，</span></span><br><span class="line"><span class="comment">// 需要在往下一個子節點前進</span></span><br><span class="line">    <span class="keyword">if</span>(active_len &gt;= tree[node].edge_length())&#123;</span><br><span class="line">        active_e += tree[node].edge_length() ; <span class="comment">//找到此長度後的第一個隱藏字元 </span></span><br><span class="line">        active_len -= tree[node].edge_length() ; <span class="comment">//減少長度</span></span><br><span class="line">        active_node = node ; <span class="comment">//往後方前進</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">st_extend</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123; <span class="comment">//擴增 suffix tree </span></span><br><span class="line">    pos++; <span class="comment">// 往下個字串前進</span></span><br><span class="line">    needSL = <span class="number">0</span> ; <span class="comment">// 紀錄上一個切割點的位置，用來 slink 的前一個點</span></span><br><span class="line">    remainder_++ ; <span class="comment">// 先 +1，如果這個點有被增加之後做 -1 的動作</span></span><br><span class="line">    <span class="keyword">while</span>(remainder_ &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(active_len == <span class="number">0</span> ) active_e = pos ; </span><br><span class="line">        <span class="comment">// 如果 active len 等於 0，就表示沒有隱藏長度，所以我們要判斷的就是當前字元</span></span><br><span class="line">        <span class="comment">// 是否存在此 active_node 節點中</span></span><br><span class="line">        <span class="keyword">if</span>(tree[active_node].next[active_edge()] == <span class="number">0</span>)&#123; </span><br><span class="line">            <span class="comment">// active_node 沒有此字元的節點，新增節點</span></span><br><span class="line">            <span class="keyword">int</span> leaf = cnt ;</span><br><span class="line">            tree[cnt++].init(pos) ;</span><br><span class="line">            tree[active_node].next[active_edge()] = leaf ;</span><br><span class="line">            add_SL(active_node) ;　<span class="comment">// 紀錄 slink 的位置，以防下次用到</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123; <span class="comment">// active_node 有此字元的節點</span></span><br><span class="line">            <span class="keyword">int</span> nxt = tree[active_node].next[active_edge()] ;</span><br><span class="line">            <span class="keyword">if</span>(walkdown(nxt)) <span class="keyword">continue</span> ; <span class="comment">// 如果還需要在往下一個節點走，就減少隱藏長度，</span></span><br><span class="line">            <span class="comment">//然後回去重新查詢</span></span><br><span class="line">            <span class="keyword">if</span>(text[tree[nxt].start + active_len] == c)&#123; </span><br><span class="line">                <span class="comment">// 如果此節點有包含到此字元，代表隱藏長度可以+1，因為後綴還是在節點長裡面</span></span><br><span class="line">                active_len++ ; <span class="comment">// 隱藏長度可以 +1</span></span><br><span class="line">                add_SL(active_node) ; <span class="comment">// 紀錄 slink 的位置，以防下次用到</span></span><br><span class="line">                <span class="keyword">break</span> ; <span class="comment">//由於隱藏節點是 +1，所以我們沒必要減</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 需要做切割點</span></span><br><span class="line">            <span class="keyword">int</span> split = cnt ; </span><br><span class="line">            tree[cnt++].init(tree[nxt].start , tree[nxt].start + active_len) ;</span><br><span class="line">            <span class="comment">//製作切割點中...，結束位置就是當前節點的 start + 隱藏長度</span></span><br><span class="line">            tree[active_node].next[active_edge()] = split ;</span><br><span class="line">            <span class="comment">// 需要將 active_node 指向我們的切割點，而不是原來的點</span></span><br><span class="line">            <span class="keyword">int</span> leaf = cnt ; <span class="comment">// 需要葉節點</span></span><br><span class="line">            tree[cnt++].init(pos) ;</span><br><span class="line">            <span class="comment">// 製作葉節點</span></span><br><span class="line">            tree[split].next[c] = leaf ; <span class="comment">// 把葉節點指向我們的切割點</span></span><br><span class="line">            tree[nxt].start += active_len ; <span class="comment">//原本的節點 start 往後到切割點的 end</span></span><br><span class="line">            tree[split].next[text[tree[nxt].start]] = nxt ; <span class="comment">//將原本節點指向我們的切割點</span></span><br><span class="line">            add_SL(split) ; <span class="comment">// 紀錄 slink 的位置，以防下次用到</span></span><br><span class="line">        &#125;</span><br><span class="line">        remainder_-- ; <span class="comment">// 由於有增加節點，所以 -1</span></span><br><span class="line">        <span class="keyword">if</span>(active_node == root &amp;&amp; active_len &gt; <span class="number">0</span> )&#123; </span><br><span class="line">            <span class="comment">//active_len &gt; 0 表示我們現在做的是把隱藏節點新增，所以要減掉</span></span><br><span class="line">            <span class="comment">//active_node == root 確保有回到根節點才做隱藏節點減掉，否則 </span></span><br><span class="line">            <span class="comment">//text[node.start + active_len ] 就會亂掉</span></span><br><span class="line">            active_len-- ;</span><br><span class="line">            <span class="comment">//由於我們減少了一個隱藏長度，所以 -1 </span></span><br><span class="line">            active_e = pos - remainder_ + <span class="number">1</span> ;</span><br><span class="line">            <span class="comment">//找到減少後隱藏長度的第一個隱藏字元，此時如果 active_len == 0，</span></span><br><span class="line">            <span class="comment">// 則下次迴圈則在 active_e 會被重新定義成 pos</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 跟著 slink 走去改動其他的後綴在 tree[active_node].slink &gt; 0 時，</span></span><br><span class="line">            <span class="comment">// 否則則回到 root，繼續建立後綴樹</span></span><br><span class="line">            active_node = tree[active_node].slink &gt; <span class="number">0</span> ? tree[active_node].slink : root ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Suffix-Array-應用"><a href="#Suffix-Array-應用" class="headerlink" title="Suffix Array 應用"></a>Suffix Array 應用</h2><p>我在學習此演算法的過程中如果有題目讓我應用到此演算法我則收錄在此，連結則是我的詳解如果想要去看題目的就搜尋一下吧！</p>
<h3 id="最長重複子字串-longest-repeated-substring"><a href="#最長重複子字串-longest-repeated-substring" class="headerlink" title="最長重複子字串 longest repeated substring"></a>最長重複子字串 longest repeated substring</h3><ul>
<li><a href="https://theriseofdavid.github.io//2020/11/04/UVa/UVa11512/" target="_blank" rel="noopener">UVa11512 - GATTACA </a></li>
<li><a href="https://theriseofdavid.github.io/2020/11/05/UVa/UVa1223/" target="_blank" rel="noopener">UVa1223 - Editor </a></li>
</ul>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://www.youtube.com/watch?v=aPRqocoBsFQ&ab_channel=TusharRoy-CodingMadeSimple" target="_blank" rel="noopener">Suffix Tree using Ukkonen’s algorithm</a><br><a href="https://www.tracholar.top/2018/02/22/ukkonens-suffix-tree-algorithm-in-plain-english/" target="_blank" rel="noopener">简单的英语中的Ukkonen后缀树算法</a><br>上述兩個為我學習此演算法的學習重點<br><a href="https://gist.github.com/makagonov/f7ed8ce729da72621b321f0ab547debb" target="_blank" rel="noopener">github makagonov/ST.cpp Secret</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>學習這演算法花了我很多時間還耗盡了很多腦細胞呢…嗚嗚，太笨了，看網路上的資源都還看不太懂，其實在網路上找資料是一件很花時間的事情，有些 blog 的資訊是錯誤亦或是寫得過於簡單，於是希望我這篇是可以不誤導他人，<del>我想應該很難，不過我的 blog 不太容易被找到吧XD，應該不會禍害大家</del>，學習 Suffix Tree 可能是我方法不對，讓我這次的學習演算法之路非常痛苦，我不會說這一次的學習是快樂的，但確實是在困難中的演算法學習最快的，因為我有壓力，壓力大到連睡覺都睡不著，身體一直記著要趕快學好此演算法。</p>
<p>我想聊一些關於寫演算法的事情，寫演算法是快樂的，但在<strong>學習</strong>演算法的過程中其實是非常痛苦的，因為你想不透可又不想認輸是件非常痛苦的事情，你會懷疑自己，在這時候我突然認為許多書上講得符合在我的經驗中，「比賽，最大的敵人是你自己」，你在學習演算法時常會遇到新的困境，當你突破時又有可能遇到新的問題，過程中你會不斷詢問自己，自己是對的嗎？我是不是對演算法沒有天賦，到現在就算我學習了這個演算法還是覺得自己很沒有天賦，需要花很多時間學習與準備。</p>
<p>老實講，我很羨慕台灣頂大的學生，有很好的機會可以遇到好老師發展，在台北科大，會演算法的老師其實並不多，這是一個非常可怕的問題，他導致整間學校的演算法水準都停擺在會 Sort 的情況，這樣寫出來的程式品質怎麼會是好的，然後老師們也不熱心於去學習新的演算法，不在意學生的程式知識水準這樣怎麼可以培養出優秀的人才，當我向老師詢問比較進階的演算法時老師都保持消極的態度導致我只能在網路上自學，不斷遇到錯誤、遇到挫折，懷疑自己。</p>
<p><strong>如果可以，有誰會想要遇到挫折，我只想要快樂的活著</strong></p>
<p>總之，我希望台灣頂大的學生都可以好好把握住自己的機會，不然困在北科的我會很難過QQ，之後有空再讓我說說我認為台灣教育制度的不公平。</p>
<h2 id="Suffix-Tree-無註解程式碼"><a href="#Suffix-Tree-無註解程式碼" class="headerlink" title="Suffix Tree 無註解程式碼"></a>Suffix Tree 無註解程式碼</h2><p>這裡則放置沒有註解的程式碼，如果讀者想要複製就從這裡進行複製吧！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> T 110</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100100</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> root , cnt , pos , needSL , remainder_ , <span class="comment">// note:remainder is cmath function</span></span><br><span class="line">    active_node , active_e , active_len ;</span><br><span class="line"><span class="built_in">string</span> text ;</span><br><span class="line"><span class="keyword">int</span> oo ;</span><br><span class="line"><span class="keyword">int</span> max_lrs = <span class="number">0</span> , lrs_index = <span class="number">0</span> , lrs_repeat = <span class="number">0</span> ;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> start , end ,slink ;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; next ;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">edge_length</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> min(end , pos+<span class="number">1</span>) - start ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> st , <span class="keyword">int</span> ed = oo)</span></span>&#123;</span><br><span class="line">        start = st ;</span><br><span class="line">        end = ed ;</span><br><span class="line">        slink = <span class="number">0</span> ;</span><br><span class="line">        next.clear() ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;tree[<span class="number">2</span>*N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">active_edge</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> text[active_e] ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_SL</span><span class="params">(<span class="keyword">int</span> node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(needSL &gt; <span class="number">0</span> ) tree[needSL].slink = node ;</span><br><span class="line">    needSL = node ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">walkdown</span><span class="params">(<span class="keyword">int</span> node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(active_len &gt;= tree[node].edge_length())&#123;</span><br><span class="line">        active_e += tree[node].edge_length() ;</span><br><span class="line">        active_len -= tree[node].edge_length() ;</span><br><span class="line">        active_node = node ;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">st_init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//tree root is 1 not zero</span></span><br><span class="line">    needSL = remainder_ = <span class="number">0</span> ;</span><br><span class="line">    active_node = active_e = active_len = <span class="number">0</span> ;</span><br><span class="line">    pos = <span class="number">-1</span> ;</span><br><span class="line"></span><br><span class="line">    cnt = root = <span class="number">1</span> ;</span><br><span class="line">    active_node = <span class="number">1</span> ;</span><br><span class="line">    tree[cnt++].init(<span class="number">-1</span>,<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">st_extend</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">    pos++;</span><br><span class="line">    needSL = <span class="number">0</span> ;</span><br><span class="line">    remainder_++ ;</span><br><span class="line">    <span class="keyword">while</span>(remainder_ &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(active_len == <span class="number">0</span> ) active_e = pos ;</span><br><span class="line">        <span class="keyword">if</span>(tree[active_node].next[active_edge()] == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> leaf = cnt ;</span><br><span class="line">            tree[cnt++].init(pos) ;</span><br><span class="line">            tree[active_node].next[active_edge()] = leaf ;</span><br><span class="line">            add_SL(active_node) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> nxt = tree[active_node].next[active_edge()] ;</span><br><span class="line">            <span class="keyword">if</span>(walkdown(nxt)) <span class="keyword">continue</span> ;</span><br><span class="line">            <span class="keyword">if</span>(text[tree[nxt].start + active_len] == c)&#123;</span><br><span class="line">                active_len++ ;</span><br><span class="line">                add_SL(active_node) ;</span><br><span class="line">                <span class="keyword">break</span> ;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> split = cnt ;</span><br><span class="line">            tree[cnt++].init(tree[nxt].start , tree[nxt].start + active_len) ;</span><br><span class="line">            tree[active_node].next[active_edge()] = split ;</span><br><span class="line">            <span class="keyword">int</span> leaf = cnt ;</span><br><span class="line">            tree[cnt++].init(pos) ;</span><br><span class="line">            tree[split].next[c] = leaf ;</span><br><span class="line">            tree[nxt].start += active_len ;</span><br><span class="line">            tree[split].next[text[tree[nxt].start]] = nxt ;</span><br><span class="line">            add_SL(split) ;</span><br><span class="line">        &#125;</span><br><span class="line">        remainder_-- ;</span><br><span class="line">        <span class="keyword">if</span>(active_node == root &amp;&amp; active_len &gt; <span class="number">0</span> )&#123;</span><br><span class="line">            active_len -- ;</span><br><span class="line">            active_e = pos - remainder_ + <span class="number">1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            active_node = tree[active_node].slink &gt; <span class="number">0</span> ? tree[active_node].slink : root ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; cnt ; i++)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">' '</span> &lt;&lt; tree[i].start &lt;&lt; <span class="string">' '</span> &lt;&lt; tree[i].end &lt;&lt; <span class="string">' '</span> &lt;&lt; tree[i].slink &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it : tree[i].next)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; it.first &lt;&lt; <span class="string">' '</span> &lt;&lt; it.second &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="用紙筆去模擬-Suffix-Tree"><a href="#用紙筆去模擬-Suffix-Tree" class="headerlink" title="用紙筆去模擬 Suffix Tree"></a>用紙筆去模擬 Suffix Tree</h2><p>因為只是自己在思考過程中隨手做的筆記，覺得不是對讀者這麼有幫助，因此放在文章最下面。</p>
<p>有時候用想或用看的可能不太能夠懂這演算法，那就用寫的吧！這是大衛我自己學習的手稿，紀錄者我的學習過程。</p>
<blockquote>
<p>“xyzxyaxyz$” 圖解步驟表，不含最後一步</p>
</blockquote>
<p><img src="/images/suffix-tree/17.jpg" alt=""></p>
<blockquote>
<p>“xyzxyaxyz$” 程式實際跑一遍圖表 A</p>
</blockquote>
<p><img src="/images/suffix-tree/16.jpg" alt=""></p>
<blockquote>
<p>“xyzxyaxyz$” 程式實際跑一遍圖表 B，加上 Suffix Tree 最後一步圖表</p>
</blockquote>
<p><img src="/images/suffix-tree/15.jpg" alt=""></p>
]]></content>
      <categories>
        <category>演算法知識</category>
      </categories>
      <tags>
        <tag>程式解題</tag>
        <tag>字串處理</tag>
        <tag>演算法知識</tag>
        <tag>最長重複子字串 Longest Repeated Substring</tag>
        <tag>後綴樹 Suffix Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>統計學(一) 筆記 - 第五章 離散機率分配(Discrete Probability Distributions)</title>
    <url>/2020/11/04/NTUT_note/statistics-ch5/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊與財金管理系大二上統計學重點整理<br><font color="#dd0000">並非所有人都適用，部分對我而言稍加容易的內容並不會寫在此內。</font><br><strong>這是觀看影片心得後的筆記，老師上課可能不太適用會忘記抄到</strong></p>
</blockquote>
<a id="more"></a>

<h2 id="Random-Variables-隨機變數"><a href="#Random-Variables-隨機變數" class="headerlink" title="Random Variables 隨機變數"></a>Random Variables 隨機變數</h2><h3 id="使用哪一個機率分配的用法教學"><a href="#使用哪一個機率分配的用法教學" class="headerlink" title="使用哪一個機率分配的用法教學"></a>使用哪一個機率分配的用法教學</h3><p>離散均勻 發生n次 則每一次的機率就是1/n<br>二項         N次試驗中成功的次數<br>負二項     N次試驗中r次成功的次數<br>幾何         在第一次成功的次數<br>卜瓦松     在特定的空間內發生的次數<br>超幾何     N次試驗中成功的機率(但取後不放回)</p>
<p>隨機變數共有三種，如下圖：</p>
<h3 id="Discrete-Random-Variable-離散隨機變數"><a href="#Discrete-Random-Variable-離散隨機變數" class="headerlink" title="Discrete Random Variable 離散隨機變數"></a>Discrete Random Variable 離散隨機變數</h3><ul>
<li>Finite Number of Values<br>在已知的集合中隨機抽出的元素。</li>
<li>Infinite Sequence of Values<br>在<strong>無限</strong>的集合中隨機抽出的元素，此集合大小為<strong>Infinite</strong>。</li>
</ul>
<h3 id="Continuous-Random-Variable-連續隨機變數"><a href="#Continuous-Random-Variable-連續隨機變數" class="headerlink" title="Continuous Random Variable 連續隨機變數"></a>Continuous Random Variable 連續隨機變數</h3><ul>
<li>元素是取區間，類似此概念 \([a,b]\)</li>
<li>或數值無法一一列舉，例如關於小數點的實驗</li>
</ul>
<h3 id="Discrete-Probability-Distributions-離散機率"><a href="#Discrete-Probability-Distributions-離散機率" class="headerlink" title="Discrete Probability Distributions 離散機率"></a>Discrete Probability Distributions 離散機率</h3><ul>
<li>用指派來指派每一個元素的機率</li>
<li>用<strong>公式</strong>推出，且要符合此公式 \(f(x) \geq 0\) and \( \sum_{}^{} f(x) = 1 \)</li>
</ul>
<h4 id="Expected-Value-期望值"><a href="#Expected-Value-期望值" class="headerlink" title="Expected Value 期望值"></a>Expected Value 期望值</h4><p>期望值不一定是集中中的元素，通常時多次實驗結果將其加權平均，平均的結果即是期望值。<br>期望值公式如下：</p>
<blockquote>
<p><img src="/images/statistics-ch5/2.PNG" alt=""></p>
</blockquote>
<h4 id="Variance-and-Standard-Deviation-變異程度與標準差"><a href="#Variance-and-Standard-Deviation-變異程度與標準差" class="headerlink" title="Variance and Standard Deviation 變異程度與標準差"></a>Variance and Standard Deviation 變異程度與標準差</h4><p>變異數公式如下：</p>
<blockquote>
<p><img src="/images/statistics-ch5/3.PNG" alt=""></p>
</blockquote>
<p>再將變異程度開根號即是標準差，圖片說明如下：</p>
<blockquote>
<p><img src="/images/statistics-ch5/4.PNG" alt=""></p>
</blockquote>
<h4 id="Discrete-Uniform-Probability-Distribution-離散均勻分配"><a href="#Discrete-Uniform-Probability-Distribution-離散均勻分配" class="headerlink" title="Discrete Uniform Probability Distribution 離散均勻分配"></a>Discrete Uniform Probability Distribution 離散均勻分配</h4><p>表示他的每一種實驗結果機率分配都一樣</p>
<h3 id="Bivariate-Distributions-二元分配"><a href="#Bivariate-Distributions-二元分配" class="headerlink" title="Bivariate Distributions 二元分配"></a>Bivariate Distributions 二元分配</h3><p>用兩種實驗，來找出他們的關係。</p>
<p>這兩次實驗我用 x,y 來代稱，先算出 x 的變異數與期望值，再算出 y 的變異數與期望值。</p>
<p>用圖片進行解釋，圖片說明如下：</p>
<blockquote>
<p><img src="/images/statistics-ch5/5.PNG" alt=""></p>
</blockquote>
<p>其中的 Covariance(共變異數) 怎麼算呢？</p>
<blockquote>
<p><img src="/images/statistics-ch5/6.PNG" alt=""></p>
</blockquote>
<p>透過範例投資組合結果如下表：</p>
<blockquote>
<p><img src="/images/statistics-ch5/7.PNG" alt=""></p>
</blockquote>
<p><strong>通常共變異數比變異數更重要</strong></p>
<h3 id="Binomial-Probability-Distribution-二項機率分配"><a href="#Binomial-Probability-Distribution-二項機率分配" class="headerlink" title="Binomial Probability Distribution 二項機率分配"></a>Binomial Probability Distribution 二項機率分配</h3><ul>
<li>包含 n 次試驗，這裡用 X 表示成功、Y 表示失敗</li>
<li>實驗結果不會因為時間而改變</li>
<li>每次的試驗是獨立的</li>
</ul>
<p>公式如下：</p>
<blockquote>
<p><img src="/images/statistics-ch5/10.PNG" alt=""></p>
</blockquote>
<p>舉例實驗如下：</p>
<blockquote>
<p><img src="/images/statistics-ch5/8.PNG" alt=""><br><img src="/images/statistics-ch5/9.PNG" alt=""><br><img src="/images/statistics-ch5/11.PNG" alt=""><br><img src="/images/statistics-ch5/12.PNG" alt=""><br><img src="/images/statistics-ch5/13.PNG" alt=""></p>
</blockquote>
<h3 id="Negative-Binomial-Probability-Distribution-負二項機率分配"><a href="#Negative-Binomial-Probability-Distribution-負二項機率分配" class="headerlink" title="Negative Binomial Probability Distribution 負二項機率分配"></a>Negative Binomial Probability Distribution 負二項機率分配</h3><ul>
<li>此實驗包括 n 次相同試驗</li>
<li>實驗獨立</li>
<li>只有成功與失敗</li>
<li>通常是找出在第 r 次時，失敗與成功的機率與多少</li>
</ul>
<p>公式如下：</p>
<blockquote>
<p><img src="/images/statistics-ch5/14.PNG" alt=""></p>
</blockquote>
<p>假設我們要找出可以兩次的正面實驗機率，圖表如下：<br>注意：你可能會有一個疑問是應該擲越多次機率越高阿？假設在第二次就擲成功時，那就是在第二次成功，往上的每次都不會紀錄</p>
<blockquote>
<p><img src="/images/statistics-ch5/15.PNG" alt=""><br><img src="/images/statistics-ch5/16.PNG" alt=""></p>
</blockquote>
<h3 id="Geometric-Probability-Distribution-幾何機率分配"><a href="#Geometric-Probability-Distribution-幾何機率分配" class="headerlink" title="Geometric Probability Distribution 幾何機率分配"></a>Geometric Probability Distribution 幾何機率分配</h3><ul>
<li>此實驗包括 n 次相同試驗</li>
<li>實驗獨立</li>
<li>只有成功與失敗</li>
<li>找出<strong>第一次成功</strong>的機率分配</li>
</ul>
<p>公式如下：</p>
<blockquote>
<p><img src="/images/statistics-ch5/17.PNG" alt=""></p>
</blockquote>
<p>舉例如下：</p>
<blockquote>
<p><img src="/images/statistics-ch5/18.PNG" alt=""><br><img src="/images/statistics-ch5/19.PNG" alt=""></p>
</blockquote>
<h4 id="統整負二項機率分配-and-幾何機率分配"><a href="#統整負二項機率分配-and-幾何機率分配" class="headerlink" title="統整負二項機率分配 and 幾何機率分配"></a>統整負二項機率分配 and 幾何機率分配</h4><blockquote>
<p><img src="/images/statistics-ch5/20.PNG" alt=""></p>
</blockquote>
<h3 id="Poisson-Probability-Distribution-卜瓦松機率分配"><a href="#Poisson-Probability-Distribution-卜瓦松機率分配" class="headerlink" title="Poisson Probability Distribution 卜瓦松機率分配"></a>Poisson Probability Distribution 卜瓦松機率分配</h3><p>在一個時段內找出有 x 個一樣結果的機率為和，例如在一個期間有多少車子通過高速公路收費站</p>
<h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ul>
<li>任一個長度區間兩個發生事件的機率相同</li>
<li>在各個區間發生的事件都是獨立</li>
</ul>
<p>公式如下：</p>
<blockquote>
<p><img src="/images/statistics-ch5/21.PNG" alt=""></p>
</blockquote>
<h4 id="舉例："><a href="#舉例：" class="headerlink" title="舉例："></a>舉例：</h4><p>在 30 分鐘來 4 個病人的機率是多少，且平均一小時會來 6 個病人</p>
<blockquote>
<p><img src="/images/statistics-ch5/22.PNG" alt=""></p>
</blockquote>
<h3 id="Hypergeometric-Probability-Distribution-超幾何機率分配"><a href="#Hypergeometric-Probability-Distribution-超幾何機率分配" class="headerlink" title="Hypergeometric Probability Distribution 超幾何機率分配"></a>Hypergeometric Probability Distribution 超幾何機率分配</h3><p>在 n 個試驗中成功的機率。</p>
<ul>
<li>實驗並不獨立</li>
<li>只要做完一個實驗就會影響到其他機率</li>
</ul>
<p>公式如下：</p>
<blockquote>
<p><img src="/images/statistics-ch5/23.PNG" alt=""><br><img src="/images/statistics-ch5/24.PNG" alt=""></p>
</blockquote>
<h4 id="舉例：-1"><a href="#舉例：-1" class="headerlink" title="舉例："></a>舉例：</h4><blockquote>
<p><img src="/images/statistics-ch5/25.PNG" alt=""><br><img src="/images/statistics-ch5/26.PNG" alt=""></p>
</blockquote>
]]></content>
      <categories>
        <category>北科上課筆記</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>統計學筆記</tag>
        <tag>北科大二上統計學筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa1223 - Editor (Suffix Tree 後綴樹 - 最長重複子字串 Longest Repeated Substring)</title>
    <url>/2020/11/05/UVa/UVa1223/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>有一位優秀的程式設計師想要寫出一個 Editor，他希望你幫他寫出一個功能關於在一個字串中找出最長重複子字串，並輸出總共出現幾次。</p>
</blockquote>
<a id="more"></a>

<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>標準的<strong>最長重複子字串 Longest Repeated Substring</strong>問題，使用 Suffix Tree 是不錯的選擇，如果你不知道 Suffix Tree 是甚麼？那你可以去看看<a href="https://theriseofdavid.github.io/2020/11/03/Explain_Algorithm/suffix-tree/" target="_blank" rel="noopener">演算法知識 - Suffix Tree 後綴樹 (Using Ukkonen Algorithm)</a>，裡面有對於 Suffix Tree 做出還不賴的說明，也可以利用他的參考連結去找到更適合你的說明方式。</p>
<h3 id="QUESTION-A-最長重複子字串-Longest-Repeated-Substring-是甚麼？"><a href="#QUESTION-A-最長重複子字串-Longest-Repeated-Substring-是甚麼？" class="headerlink" title="QUESTION A: 最長重複子字串 (Longest Repeated Substring) 是甚麼？"></a>QUESTION A: 最長重複子字串 (Longest Repeated Substring) 是甚麼？</h3><p>給你一組字串，找出最長的重複子字串，<del>就跟字面上的意思一樣</del>，這題可以算是一個模板題。</p>
<h3 id="那要怎麼解題呢？"><a href="#那要怎麼解題呢？" class="headerlink" title="那要怎麼解題呢？"></a>那要怎麼解題呢？</h3><p>其實容易想到，做一次 DFS，由於 Suffix Tree 的特性是只要不是 leaf(葉節點)就表示至少此節點下面有兩個 leaf，透過此特性可以知道<strong>重複的特性</strong>，再透過 DFS 向下追蹤的特性可以找出 <strong>最長重複子字串</strong>，再利用此節點下有多少個 leaf，就可以知道重複幾次了！</p>
<h3 id="QUESTION-B-那要怎麼找到最長重複子字串-Longest-Repeated-Substring-開的-index-呢？"><a href="#QUESTION-B-那要怎麼找到最長重複子字串-Longest-Repeated-Substring-開的-index-呢？" class="headerlink" title="QUESTION B: 那要怎麼找到最長重複子字串 (Longest Repeated Substring) 開的 index 呢？"></a>QUESTION B: 那要怎麼找到最長重複子字串 (Longest Repeated Substring) 開的 index 呢？</h3><p>簡單，只需要用葉節點的 start 減掉 <strong>LRS(最長重複子字串) 長度</strong>就可以知道是從哪個 index 開始了！</p>
<h3 id="簡單的程式碼說明"><a href="#簡單的程式碼說明" class="headerlink" title="簡單的程式碼說明"></a>簡單的程式碼說明</h3><p>請注意，這題只需要輸出 max_lrs 即可，但我為了 debug 方便因此全部都先寫出來方便除錯。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lrs_dfs</span><span class="params">(<span class="keyword">int</span> r , <span class="keyword">int</span> len , <span class="keyword">int</span> repeats )</span></span>&#123; <span class="comment">//dfs for suffix tree</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it : tree[r].next)&#123; <span class="comment">// 向下追蹤節點</span></span><br><span class="line">        lrs_dfs(it.second , len + tree[r].edge_length() , tree[r].next.size());</span><br><span class="line">        <span class="comment">// len + tree[r].edge_length()  當前最長重複長度</span></span><br><span class="line">        <span class="comment">//  tree[r].next.size() 下面有幾個節點表示至少重複幾次 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tree[r].slink == <span class="number">0</span> &amp;&amp; len &gt; max_lrs)&#123; </span><br><span class="line">        <span class="comment">//走訪到根節點且當前最長重複長度 &gt; 最長重複子字串 則將當前的資料都換成 LRS 表示</span></span><br><span class="line">        lrs_repeat = repeats ; <span class="comment">// 重複次數</span></span><br><span class="line">        max_lrs = len ; <span class="comment">// 長度</span></span><br><span class="line">        lrs_index = tree[r].start - len ; <span class="comment">// 初始的 index</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://theriseofdavid.github.io/2020/11/03/Explain_Algorithm/suffix-tree/" target="_blank" rel="noopener">演算法知識 - Suffix Tree 後綴樹 (Using Ukkonen Algorithm)</a><br><a href="https://theriseofdavid.github.io/2020/11/04/UVa/UVa11512/" target="_blank" rel="noopener">UVa11512 - GATTACA (Suffix Tree 後綴樹 - 最長重複子字串 Longest Repeated Substring)</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>老實講學完了 Suffix Tree 感覺真的很不賴，這題可以馬上解開讓我自己有滿滿的成就感呢XD，希望以後遇到我有學過的題目都可以這樣迅速解開那是最棒的了！也希望我所學的演算法知識都能應用在實務上，這樣一定會讓我更肯定學習演算法是正確也是必要的事情！</p>
<p>總感覺自己把成功視為理所當然，失敗視為禁忌，失敗的心得總是在檢討自己，成功時都在為自己感到自信，感覺有點不太好呢！不過如果這樣可以讓自己進步的話，似乎也不錯嗎？讓我慢慢長大慢慢檢視我自己吧！<del>好像有點用太多驚嘆號了</del></p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>其實就是沒有附上說明的程式碼，希望可以幫助到各位，也期望大家想要學習的知識都可以快速學習而成，不要因為自身的環境不足而學習不到。</p>
<p>於是這裡就補述一些題目給的資料範圍限制與標頭檔了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5020</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> root , cnt , pos , needSL ,remainder_ ,</span><br><span class="line">    active_node , active_e , active_len ;</span><br><span class="line"><span class="built_in">string</span> text ;</span><br><span class="line"><span class="keyword">int</span> oo ;</span><br><span class="line"><span class="keyword">int</span> max_lrs = <span class="number">0</span> , lrs_index = <span class="number">0</span> , lrs_repeat = <span class="number">0</span> ;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> start , end , slink ;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; next ;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">edge_length</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> min(end,pos+<span class="number">1</span>) - start ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> st , <span class="keyword">int</span> ed = oo)</span></span>&#123;</span><br><span class="line">        start = st ;</span><br><span class="line">        end = ed ;</span><br><span class="line">        slink = <span class="number">0</span> ;</span><br><span class="line">        next.clear() ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;tree[<span class="number">2</span>*N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">active_edge</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> text[active_e] ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_SL</span><span class="params">(<span class="keyword">int</span> node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(needSL &gt; <span class="number">0</span> ) tree[needSL].slink = node;</span><br><span class="line">    needSL = node ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">walkdown</span><span class="params">(<span class="keyword">int</span> node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(active_len &gt;= tree[node].edge_length())&#123;</span><br><span class="line">        active_e += tree[node].edge_length() ;</span><br><span class="line">        active_len -= tree[node].edge_length();</span><br><span class="line">        active_node = node ;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">st_init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    needSL = remainder_ = <span class="number">0</span> ;</span><br><span class="line">    active_node = active_e = active_len = <span class="number">0</span> ;</span><br><span class="line">    pos = <span class="number">-1</span> ;</span><br><span class="line"></span><br><span class="line">    cnt = root = <span class="number">1</span> ;</span><br><span class="line">    active_node = <span class="number">1</span> ;</span><br><span class="line">    tree[cnt++].init(<span class="number">-1</span>,<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">st_extend</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">    pos++ ;</span><br><span class="line">    needSL = <span class="number">0</span> ;</span><br><span class="line">    remainder_++ ;</span><br><span class="line">    <span class="keyword">while</span>(remainder_ &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(active_len == <span class="number">0</span> ) active_e = pos ;</span><br><span class="line">        <span class="keyword">if</span>(tree[active_node].next[active_edge()] == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> leaf = cnt ;</span><br><span class="line">            tree[cnt++].init(pos) ;</span><br><span class="line">            tree[active_node].next[active_edge()] = leaf ;</span><br><span class="line">            add_SL(active_node) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> nxt = tree[active_node].next[active_edge()] ;</span><br><span class="line">            <span class="keyword">if</span>(walkdown(nxt)) <span class="keyword">continue</span> ;</span><br><span class="line">            <span class="keyword">if</span>(text[tree[nxt].start + active_len] == c)&#123;</span><br><span class="line">                active_len++ ;</span><br><span class="line">                add_SL(active_node) ;</span><br><span class="line">                <span class="keyword">break</span> ;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> split = cnt;</span><br><span class="line">            tree[cnt++].init(tree[nxt].start , tree[nxt].start + active_len) ;</span><br><span class="line">            tree[active_node].next[active_edge()] = split ;</span><br><span class="line">            <span class="keyword">int</span> leaf = cnt;</span><br><span class="line">            tree[cnt++].init(pos) ;</span><br><span class="line">            tree[split].next[c] = leaf ;</span><br><span class="line">            tree[nxt].start += active_len ;</span><br><span class="line">            tree[split].next[text[tree[nxt].start]] = nxt ;</span><br><span class="line">            add_SL(split) ;</span><br><span class="line">        &#125;</span><br><span class="line">        remainder_-- ;</span><br><span class="line">        <span class="keyword">if</span>(active_node == root &amp;&amp; active_len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            active_len--;</span><br><span class="line">            active_e = pos - remainder_ + <span class="number">1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            active_node = tree[active_node].slink &gt; <span class="number">0</span> ? tree[active_node].slink : root ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; cnt ; i++)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">' '</span> &lt;&lt; tree[i].start &lt;&lt; <span class="string">' '</span> &lt;&lt; tree[i].end &lt;&lt; <span class="string">' '</span> &lt;&lt; tree[i].slink &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it : tree[i].next)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; it.first &lt;&lt; <span class="string">' '</span> &lt;&lt; it.second &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lrs_dfs</span><span class="params">(<span class="keyword">int</span> r , <span class="keyword">int</span> len , <span class="keyword">int</span> repeats)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it : tree[r].next)&#123;</span><br><span class="line">        lrs_dfs(it.second , len + tree[r].edge_length() , tree[r].next.size()) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tree[r].slink == <span class="number">0</span> &amp;&amp; len &gt; max_lrs)&#123;</span><br><span class="line">        lrs_repeat = repeats ;</span><br><span class="line">        max_lrs = len ;</span><br><span class="line">        lrs_index = tree[r].start - len ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">int</span> n ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; text ;</span><br><span class="line">        st_init() ;</span><br><span class="line">        text += <span class="string">"$"</span> ;</span><br><span class="line">        oo = text.length() ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; text.length() ; i++) st_extend(text[i]);</span><br><span class="line"></span><br><span class="line">        max_lrs = lrs_index = lrs_repeat = <span class="number">0</span> ;</span><br><span class="line">        lrs_dfs(root,<span class="number">0</span>,<span class="number">0</span>) ;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; max_lrs &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>程式解題</tag>
        <tag>字串處理</tag>
        <tag>演算法知識</tag>
        <tag>最長重複子字串 Longest Repeated Substring</tag>
        <tag>Suffix Tree 後綴樹</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa11512 - GATTACA (Suffix Tree 後綴樹 - 最長重複子字串 Longest Repeated Substring)</title>
    <url>/2020/11/04/UVa/UVa11512/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>生物學家們要透過 DNA bases(A,C,G,T) 在人類的 DNA 片段中找出最長重複的子字串並且告訴生物學家出現幾遍。</p>
</blockquote>
<a id="more"></a>

<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>這題使用 Suffix Tree 做<strong>最長重複子字串 Longest Repeated Substring</strong>是不錯的選擇，Suffix Tree 是甚麼？那你可以去看看<a href="https://theriseofdavid.github.io/2020/11/03/Explain_Algorithm/suffix-tree/" target="_blank" rel="noopener">演算法知識 - Suffix Tree 後綴樹 (Using Ukkonen Algorithm)</a>，裡面有對於 Suffix Tree 做出還不賴的說明，也可以利用他的參考連結去找到更適合你的說明方式。</p>
<h3 id="QUESTION-A-最長重複子字串-Longest-Repeated-Substring-是甚麼？"><a href="#QUESTION-A-最長重複子字串-Longest-Repeated-Substring-是甚麼？" class="headerlink" title="QUESTION A: 最長重複子字串 (Longest Repeated Substring) 是甚麼？"></a>QUESTION A: 最長重複子字串 (Longest Repeated Substring) 是甚麼？</h3><p>給你一組字串，找出最長的重複子字串，<del>就跟字面上的意思一樣</del>，這題可以算是一個模板題。</p>
<h3 id="那要怎麼解題呢？"><a href="#那要怎麼解題呢？" class="headerlink" title="那要怎麼解題呢？"></a>那要怎麼解題呢？</h3><p>其實容易想到，做一次 DFS，由於 Suffix Tree 的特性是只要不是 leaf(葉節點)就表示至少此節點下面有兩個 leaf，透過此特性可以知道<strong>重複的特性</strong>，再透過 DFS 向下追蹤的特性可以找出 <strong>最長重複子字串</strong>，再利用此節點下有多少個 leaf，就可以知道重複幾次了！</p>
<h3 id="QUESTION-B-那要怎麼找到最長重複子字串-Longest-Repeated-Substring-開的-index-呢？"><a href="#QUESTION-B-那要怎麼找到最長重複子字串-Longest-Repeated-Substring-開的-index-呢？" class="headerlink" title="QUESTION B: 那要怎麼找到最長重複子字串 (Longest Repeated Substring) 開的 index 呢？"></a>QUESTION B: 那要怎麼找到最長重複子字串 (Longest Repeated Substring) 開的 index 呢？</h3><p>簡單，只需要用葉節點的 start 減掉 <strong>LRS(最長重複子字串) 長度</strong>就可以知道是從哪個 index 開始了！</p>
<h3 id="簡單的程式碼說明"><a href="#簡單的程式碼說明" class="headerlink" title="簡單的程式碼說明"></a>簡單的程式碼說明</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lrs_dfs</span><span class="params">(<span class="keyword">int</span> r , <span class="keyword">int</span> len , <span class="keyword">int</span> repeats )</span></span>&#123; <span class="comment">//dfs for suffix tree</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it : tree[r].next)&#123; <span class="comment">// 向下追蹤節點</span></span><br><span class="line">        lrs_dfs(it.second , len + tree[r].edge_length() , tree[r].next.size());</span><br><span class="line">        <span class="comment">// len + tree[r].edge_length()  當前最長重複長度</span></span><br><span class="line">        <span class="comment">//  tree[r].next.size() 下面有幾個節點表示至少重複幾次 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tree[r].slink == <span class="number">0</span> &amp;&amp; len &gt; max_lrs)&#123; </span><br><span class="line">        <span class="comment">//走訪到根節點且當前最長重複長度 &gt; 最長重複子字串 則將當前的資料都換成 LRS 表示</span></span><br><span class="line">        lrs_repeat = repeats ; <span class="comment">// 重複次數</span></span><br><span class="line">        max_lrs = len ; <span class="comment">// 長度</span></span><br><span class="line">        lrs_index = tree[r].start - len ; <span class="comment">// 初始的 index</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://theriseofdavid.github.io/2020/11/03/Explain_Algorithm/suffix-tree/" target="_blank" rel="noopener">演算法知識 - Suffix Tree 後綴樹 (Using Ukkonen Algorithm)</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>其實學會了 Suffix Tree 後此 最長重複子字串 Longest Repeated Substring 是我自己看著網路上的說明文章就學會的，內心其實還是有一點點小成就感的，能夠靠著自己的雙手把它解決不依賴他人，雖然這是需要花上時間大量學習才能夠達到這樣的成就，但怎麼講，能夠靠著自己的雙手解決真的很不賴押！</p>
<p>雖然還是希望自己可以加速迎頭趕上他人，我不想再輸。</p>
<p>雖然我在抓這題的 bug 花了大量時間，這題其實我想一小時就解出來，自己領悟出 LRS，但錯在一個自己從來沒有錯的點才讓我自己在抓 bug 花了大量時間，請大家記住一件事情，在 C++11 中 <code>struct</code> 內的 function 如果沒有要回傳值要記得打 <code>void</code> 而不是 <code>int</code>，在 Uva Online Judge 是會出現 <strong>runtime error</strong>，UVa Online Judge 是不通情理的押，不像我家 Windows 人很好，如果你在裡面寫 int 沒有 return 照樣可以跑，還一樣快的QQ。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>其實就是沒有附上說明的程式碼，我也花了七個小時撰寫文章(Suffix Tree + 此題題解)，看得懂跟說得出來真的是兩回事，也許還有人覺得我說的很差，不過我已經盡力解釋。希望可以幫助到各位。</p>
<p>也希望大家想要學習的知識都可以快速學習而成，不要因為自身的環境不足而學習不到。</p>
<p>於是這裡就補述一些題目給的資料範圍限制與標頭檔了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> T 110</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100100</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> root , cnt , pos , needSL , remainder_ , <span class="comment">// note:remainder is cmath function</span></span><br><span class="line">    active_node , active_e , active_len ;</span><br><span class="line"><span class="built_in">string</span> text ;</span><br><span class="line"><span class="keyword">int</span> oo ;</span><br><span class="line"><span class="keyword">int</span> max_lrs = <span class="number">0</span> , lrs_index = <span class="number">0</span> , lrs_repeat = <span class="number">0</span> ;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> start , end ,slink ;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; next ;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">edge_length</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> min(end , pos+<span class="number">1</span>) - start ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> st , <span class="keyword">int</span> ed = oo)</span></span>&#123;</span><br><span class="line">        start = st ;</span><br><span class="line">        end = ed ;</span><br><span class="line">        slink = <span class="number">0</span> ;</span><br><span class="line">        next.clear() ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;tree[<span class="number">2</span>*N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">active_edge</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> text[active_e] ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_SL</span><span class="params">(<span class="keyword">int</span> node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(needSL &gt; <span class="number">0</span> ) tree[needSL].slink = node ;</span><br><span class="line">    needSL = node ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">walkdown</span><span class="params">(<span class="keyword">int</span> node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(active_len &gt;= tree[node].edge_length())&#123;</span><br><span class="line">        active_e += tree[node].edge_length() ;</span><br><span class="line">        active_len -= tree[node].edge_length() ;</span><br><span class="line">        active_node = node ;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">st_init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//tree root is 1 not zero</span></span><br><span class="line">    needSL = remainder_ = <span class="number">0</span> ;</span><br><span class="line">    active_node = active_e = active_len = <span class="number">0</span> ;</span><br><span class="line">    pos = <span class="number">-1</span> ;</span><br><span class="line"></span><br><span class="line">    cnt = root = <span class="number">1</span> ;</span><br><span class="line">    active_node = <span class="number">1</span> ;</span><br><span class="line">    tree[cnt++].init(<span class="number">-1</span>,<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">st_extend</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">    pos++;</span><br><span class="line">    needSL = <span class="number">0</span> ;</span><br><span class="line">    remainder_++ ;</span><br><span class="line">    <span class="keyword">while</span>(remainder_ &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(active_len == <span class="number">0</span> ) active_e = pos ;</span><br><span class="line">        <span class="keyword">if</span>(tree[active_node].next[active_edge()] == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> leaf = cnt ;</span><br><span class="line">            tree[cnt++].init(pos) ;</span><br><span class="line">            tree[active_node].next[active_edge()] = leaf ;</span><br><span class="line">            add_SL(active_node) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> nxt = tree[active_node].next[active_edge()] ;</span><br><span class="line">            <span class="keyword">if</span>(walkdown(nxt)) <span class="keyword">continue</span> ;</span><br><span class="line">            <span class="keyword">if</span>(text[tree[nxt].start + active_len] == c)&#123;</span><br><span class="line">                active_len++ ;</span><br><span class="line">                add_SL(active_node) ;</span><br><span class="line">                <span class="keyword">break</span> ;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> split = cnt ;</span><br><span class="line">            tree[cnt++].init(tree[nxt].start , tree[nxt].start + active_len) ;</span><br><span class="line">            tree[active_node].next[active_edge()] = split ;</span><br><span class="line">            <span class="keyword">int</span> leaf = cnt ;</span><br><span class="line">            tree[cnt++].init(pos) ;</span><br><span class="line">            tree[split].next[c] = leaf ;</span><br><span class="line">            tree[nxt].start += active_len ;</span><br><span class="line">            tree[split].next[text[tree[nxt].start]] = nxt ;</span><br><span class="line">            add_SL(split) ;</span><br><span class="line">        &#125;</span><br><span class="line">        remainder_-- ;</span><br><span class="line">        <span class="keyword">if</span>(active_node == root &amp;&amp; active_len &gt; <span class="number">0</span> )&#123;</span><br><span class="line">            active_len -- ;</span><br><span class="line">            active_e = pos - remainder_ + <span class="number">1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            active_node = tree[active_node].slink &gt; <span class="number">0</span> ? tree[active_node].slink : root ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; cnt ; i++)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">' '</span> &lt;&lt; tree[i].start &lt;&lt; <span class="string">' '</span> &lt;&lt; tree[i].end &lt;&lt; <span class="string">' '</span> &lt;&lt; tree[i].slink &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it : tree[i].next)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; it.first &lt;&lt; <span class="string">' '</span> &lt;&lt; it.second &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lrs_dfs</span><span class="params">(<span class="keyword">int</span> r , <span class="keyword">int</span> len , <span class="keyword">int</span> repeats )</span></span>&#123; <span class="comment">//dfs for suffix tree</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it : tree[r].next)&#123;</span><br><span class="line">        lrs_dfs(it.second , len + tree[r].edge_length() , tree[r].next.size());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tree[r].slink == <span class="number">0</span> &amp;&amp; len &gt; max_lrs)&#123;</span><br><span class="line">        lrs_repeat = repeats ;</span><br><span class="line">        max_lrs = len ;</span><br><span class="line">        lrs_index = tree[r].start - len ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> );</span><br><span class="line">    <span class="comment">//freopen("out.txt" , "w" , stdout );</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">int</span> n ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; text ;</span><br><span class="line"></span><br><span class="line">        st_init() ;</span><br><span class="line">        text += <span class="string">"$"</span> ;</span><br><span class="line">        oo = text.length() ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; text.length() ; i++) st_extend(text[i]);</span><br><span class="line"></span><br><span class="line">        max_lrs = <span class="number">0</span> , lrs_index = <span class="number">0</span> , lrs_repeat = <span class="number">0</span> ;</span><br><span class="line">        lrs_dfs(root , <span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(max_lrs)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; text.substr(lrs_index , max_lrs) &lt;&lt; <span class="string">' '</span> &lt;&lt; lrs_repeat &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"No repetitions found!\n"</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>程式解題</tag>
        <tag>字串處理</tag>
        <tag>演算法知識</tag>
        <tag>最長重複子字串 Longest Repeated Substring</tag>
        <tag>Suffix Tree 後綴樹</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa10192 - Vacation (LCS)</title>
    <url>/2020/11/07/UVa/UVa10192/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>爸媽想要出國出去玩，<del>可是今年有疫情欸，拔麻</del>，反正爸媽不管且還要求出國的遊玩順序一定要按照他們想法，這讓我非常煩惱，但他們願意略過一些他們想去的地方，但順序必須一樣，試問如果爸媽都有自己的出國遊玩順序再不影響他們順序時他們可以去的最大長度？</p>
<p>注意：這題輸入字串會有 space , uppercase letters , lowercase letters<br>所以要使用 <code>getline(string,cin)</code> 會是最好的方法</p>
</blockquote>
<a id="more"></a>

<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>這題是標準的 LCS 問題，可以用 \(O(n^2\) and \(O(n \log n) \) 解開，這裡使用 \(O(n \log n)\) 來解決此問題。</p>
<p>如果還不太懂 LCS 是甚麼問題，建議看看 <a href="https://theriseofdavid.github.io/2020/11/11/Explain_Algorithm/LCS/" target="_blank" rel="noopener">演算法知識 - Longest Common Subsequence 最長共同子序列(時間複雜度 O(nlogn))</a>，這裡有對於此演算法有完整的介紹</p>
<h2 id="焦點回到題目上，解開題目的小設計"><a href="#焦點回到題目上，解開題目的小設計" class="headerlink" title="焦點回到題目上，解開題目的小設計"></a>焦點回到題目上，解開題目的小設計</h2><p>記住他的輸出還要輸出一些文字，不是只直接輸出 LCS 的長度即可。</p>
<p>P.S. 下方題目程式碼的 string index 由 1 開始方便編寫程式碼，主要方便用來 LIS 如果要更改 cur 成 0 時會造成 <code>t[-1]</code> ，只需要在 <code>string = &quot;$&quot; + string</code>，即可達到此功效</p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>這題其實沒有很難，但是我搞了很久因為 udebug 壞掉了，嗚嗚嗚，沒有 Udebug 我就超像一個白癡一樣甚麼都不會，不可以阿大衛，這樣你打 ICPC 怎麼會進步呢QQ，讓我發現我對 Udebug 就像是小孩子依賴麻麻一般，要是沒有了她我則甚麼都不會。</p>
<p>盡量不要這樣，可能需要增進自己去 hack 測試資料的能力並想出自己程式碼的漏洞，不過明明寫出自己覺得沒有錯的程式碼然後想錯誤，其實也是一件蠻痛苦的事情呢XD。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>其實就是沒有附上說明的程式碼，看得懂跟說得出來真的是兩回事，也許還有人覺得我說的很差，不過我已經盡力解釋。希望可以幫助到各位。</p>
<p>也希望大家想要學習的知識都可以快速學習而成，不要因為自身的環境不足而學習不到。</p>
<p>於是這裡就補述一些題目給的資料範圍限制與標頭檔了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 120</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n ;</span><br><span class="line"><span class="built_in">string</span> strA , strB ;</span><br><span class="line"><span class="keyword">int</span> t[N*N] , d[N*N] , num[N*N] ; <span class="comment">//determine</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dict ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bs</span><span class="params">(<span class="keyword">int</span> l , <span class="keyword">int</span> r , <span class="keyword">int</span> v )</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m ;</span><br><span class="line">    <span class="keyword">while</span>(r&gt;l)&#123;</span><br><span class="line">        m = (l+r) /<span class="number">2</span> ;</span><br><span class="line">        <span class="keyword">if</span>(num[v] &gt; num[t[m]]) l = m+<span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (num[v] &lt; num[t[m]]) r = m ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> m ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lcs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    dict.clear() ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = strA.length()<span class="number">-1</span> ; i &gt; <span class="number">0</span> ; i--) dict[strA[i]].push_back(i) ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; strB.length() ; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; dict[strB[i]].size() ; j++)</span><br><span class="line">            num[++k] = dict[strB[i]][j] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    <span class="comment">//memset(t ,-1 , sizeof(t));</span></span><br><span class="line">    d[<span class="number">1</span>] = <span class="number">0</span> , t[<span class="number">1</span>] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">1</span>, cur ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= k ; i++ )&#123;</span><br><span class="line">        <span class="keyword">if</span>(num[i] &gt; num[t[len]]) t[++len] = i , d[i] = t[len<span class="number">-1</span>] ;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cur = bs(<span class="number">1</span>,len,i);</span><br><span class="line">            t[cur] = i ;</span><br><span class="line">            d[i] = t[cur<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//debug</span></span><br><span class="line"><span class="comment">//        for(int i = 1 ; i &lt;= k ; i++)</span></span><br><span class="line"><span class="comment">//            cout &lt;&lt; num[t[i]] &lt;&lt; ' ' ;</span></span><br><span class="line"><span class="comment">//        cout &lt;&lt; '\n' ;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len ;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> ) ;</span><br><span class="line">    freopen(<span class="string">"out.txt"</span> , <span class="string">"w"</span> , <span class="built_in">stdout</span>) ;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    n = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span>(getline(<span class="built_in">cin</span>,strA) &amp;&amp; strA != <span class="string">"#"</span>)&#123;</span><br><span class="line">        getline(<span class="built_in">cin</span>,strB);</span><br><span class="line">        strA = <span class="string">"$"</span> + strA;</span><br><span class="line">        strB = <span class="string">"$"</span> + strB;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; lcs() &lt;&lt; '\n' ;</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Case #"</span> &lt;&lt; n++ &lt;&lt; <span class="string">": you can visit at most "</span> &lt;&lt; lcs() &lt;&lt; <span class="string">" cities.\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>字串處理</tag>
        <tag>最長共同子序列 Longest Common Subsequence</tag>
        <tag>演算法知識</tag>
        <tag>動態規劃 Dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title>演算法知識 - Longest Common Subsequence 最長共同子序列(時間複雜度 O(nlogn))</title>
    <url>/2020/11/11/Explain_Algorithm/LCS/</url>
    <content><![CDATA[<h2 id="Longest-Common-Subsequence-介紹"><a href="#Longest-Common-Subsequence-介紹" class="headerlink" title="Longest Common Subsequence 介紹"></a>Longest Common Subsequence 介紹</h2><blockquote>
<p>以下簡稱 LCS，在兩個序列中找出最長子序列的問題，序列是甚麼？只要順序一致即可，舉例：</p>
<ul>
<li>people</li>
<li>apple</li>
</ul>
<ul>
<li>這兩個的 LCS 就是 pple，長度為 4，子序列為 pple。</li>
</ul>
<p>看懂了嗎？ pple 在前面兩個字串中順序都是保持一致的。<br>被廣泛應用於生物資訊學與版本控制。</p>
<p>這裡我們是教導時間複雜度為 \(O(n \log n)\) 的寫法，而非 \(O(n^2)\) 的寫法</p>
<p>Longest Increasing Subsequence 最長遞增子序列，以下簡稱 LIS</p>
</blockquote>
<a id="more"></a>

<h2 id="Longest-Common-Subsequence-原理"><a href="#Longest-Common-Subsequence-原理" class="headerlink" title="Longest Common Subsequence 原理"></a>Longest Common Subsequence 原理</h2><p>先將 A 字串的值逆向輸入到一個 <code>map&lt;char,vector&lt;int&gt;&gt;</code>裡面，再根據 B 字串的字元依序將 <code>map&lt;char,vector&lt;int&gt;&gt;</code> 取出，之後做 LIS 遞增。</p>
<p>如果不懂 LIS 是甚麼可以先看<a href=""></a></p>
<h3 id="QUESTION-太驚人了！-為甚麼可以用-O-n-log-n-去解？"><a href="#QUESTION-太驚人了！-為甚麼可以用-O-n-log-n-去解？" class="headerlink" title="QUESTION: 太驚人了！ 為甚麼可以用 \(O(n \log n )\) 去解？"></a>QUESTION: 太驚人了！ 為甚麼可以用 \(O(n \log n )\) 去解？</h3><p>因為這世界天才太多了。<del>正解</del></p>
<p>開玩笑的，還記得 (\ O(n^2))\ 的解法怎麼解嗎？是用動態規劃，可是他是不是有點浪費效率，因為她只有在 <code>A[i] == B[i]</code>，才會增加長度，剩下時間都是在延續之前的狀態，我們從這裡進行補強。</p>
<p>我們只要把 A 字串的每個字元的 index 做紀錄，並將同個字元出現的多個位置放入 <code>vector</code>，放入的順序是大到小，再根據 B 字串的每個字元對應同字元的 <code>vector</code>，在做 LIS 即可，這樣我們就減少了此情況 <code>A[i] != B[i]</code>。</p>
<h2 id="Longest-Common-Subsequence-說明與舉例"><a href="#Longest-Common-Subsequence-說明與舉例" class="headerlink" title="Longest Common Subsequence 說明與舉例"></a>Longest Common Subsequence 說明與舉例</h2><h3 id="舉例"><a href="#舉例" class="headerlink" title="舉例"></a>舉例</h3><p>先舉個例子，以免被說是騙人XD。</p>
<p>String A = “abdba”<br>String B = “dbaaba” </p>
<p>對應 A 字串的每個字元的 index 做紀錄，並將同個字元出現的多個位置放入 <code>vector</code>，字串  index 從 0 開始，<strong>記住是逆序</strong>，如下：</p>
<p>a(4,0) b(3,1) d(2)</p>
<p>再來，我們根據根據 B 字串的每個字元對應同字元的 <code>vector</code>，產生序列，於是就變成</p>
<table>
<thead>
<tr>
<th>index</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
</tr>
</thead>
<tbody><tr>
<td>value</td>
<td>2</td>
<td>3</td>
<td>1</td>
<td>4</td>
<td>0</td>
<td>4</td>
<td>0</td>
<td>3</td>
<td>1</td>
<td>4</td>
<td>0</td>
</tr>
<tr>
<td>char</td>
<td>d</td>
<td>b</td>
<td></td>
<td>a</td>
<td></td>
<td>a</td>
<td></td>
<td>b</td>
<td></td>
<td>a</td>
<td></td>
</tr>
</tbody></table>
<p>看懂了？對吧！</p>
<p>而此時，這裡的 LIS 最大長度為 3，其中一種方式為 2 3 4，但這裡也只有這種XD，記住，在其他情況下 LCS 不只有一種表達方式。</p>
<p>且 d 的 vector 有 2、b 的 vector 有 3、a 的 vector 有 4，剛好能夠組成 dba，符合答案。</p>
<h3 id="QUESTION-那為甚麼要是逆序？"><a href="#QUESTION-那為甚麼要是逆序？" class="headerlink" title="QUESTION: 那為甚麼要是逆序？"></a>QUESTION: 那為甚麼要是逆序？</h3><p>很簡單，為了要避免重複判斷，一樣用剛剛的例子如下，那 <code>vector</code>會變成。</p>
<p>a(0,4) b(1,3) d(2)</p>
<table>
<thead>
<tr>
<th>index</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
</tr>
</thead>
<tbody><tr>
<td>value</td>
<td>2</td>
<td>1</td>
<td>3</td>
<td>0</td>
<td>4</td>
<td>0</td>
<td>4</td>
<td>1</td>
<td>3</td>
<td>0</td>
<td>4</td>
</tr>
<tr>
<td>char</td>
<td>d</td>
<td>b</td>
<td></td>
<td>a</td>
<td></td>
<td>a</td>
<td></td>
<td>b</td>
<td></td>
<td>a</td>
<td></td>
</tr>
</tbody></table>
<p>這樣出來的最長長度為 4，其中一種方式為 0 1 3 4，但這裡組成的字串會變成 dbba，是不是中間的 b 被重複算到了，因為 LIS 是遞增，如果我們的 <code>vector</code> 也是遞增排序時，則中間的每一個 <code>vector</code> 的 element 都會被我們選中長度會被無限放大，因此在 <code>vector</code> 時要是逆序的元素。</p>
<h3 id="OK-現在問題被我們解決成是-LIS-了，那我們就來做吧！"><a href="#OK-現在問題被我們解決成是-LIS-了，那我們就來做吧！" class="headerlink" title="OK, 現在問題被我們解決成是 LIS 了，那我們就來做吧！"></a>OK, 現在問題被我們解決成是 LIS 了，那我們就來做吧！</h3><p><a href="https://theriseofdavid.github.io/2020/11/13/Explain_Algorithm/LIS/" target="_blank" rel="noopener">關於 LIS 的部分就先去看大衞的筆記即可</a>。</p>
<h2 id="LCS-實作與說明"><a href="#LCS-實作與說明" class="headerlink" title="LCS 實作與說明"></a>LCS 實作與說明</h2><p>P.S. 這裡的 string index 由 1 開始方便編寫程式碼，主要方便用來 LIS 如果要更改 cur 成 0 時會造成 <code>t[-1]</code> ，只需要在 <code>string = &quot;$&quot; + string</code>，即可達到此功效</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 120</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n ;</span><br><span class="line"><span class="built_in">string</span> strA , strB ;</span><br><span class="line"><span class="keyword">int</span> t[N*N] , d[N*N] , num[N*N] ; <span class="comment">//t and d 是 LIS 要用到 </span></span><br><span class="line"><span class="comment">// d 用來記住 LIS 中此數字的前一個數字</span></span><br><span class="line"><span class="comment">// t 當前 LIS 的數列位置</span></span><br><span class="line"><span class="comment">// num 則是我們根據 strB 的字元生成數列，用來找出最長 LIS 長度 </span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dict ; <span class="comment">//記住每個字串出現的 index 位置</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bs</span><span class="params">(<span class="keyword">int</span> l , <span class="keyword">int</span> r , <span class="keyword">int</span> v )</span></span>&#123; <span class="comment">//binary search </span></span><br><span class="line">    <span class="keyword">int</span> m ;</span><br><span class="line">    <span class="keyword">while</span>(r&gt;l)&#123;</span><br><span class="line">        m = (l+r) /<span class="number">2</span> ;</span><br><span class="line">        <span class="keyword">if</span>(num[v] &gt; num[t[m]]) l = m+<span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (num[v] &lt; num[t[m]]) r = m ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> m ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lcs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    dict.clear() ; <span class="comment">//先將 dict 先清空</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = strA.length()<span class="number">-1</span> ; i &gt; <span class="number">0</span> ; i--) dict[strA[i]].push_back(i) ;</span><br><span class="line">    <span class="comment">// 將每個字串的位置紀錄並放入 vector 中，請記住 i = strA.length() -1 才可以達到逆續效果</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span> ; <span class="comment">//紀錄生成數列的長度的最長長度</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; strB.length() ; i++)&#123; <span class="comment">// 依據 strB 的每個字元來生成數列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; dict[strB[i]].size() ; j++) </span><br><span class="line">        <span class="comment">//將此字元在 strA 出現的位置放入數列</span></span><br><span class="line">            num[++k] = dict[strB[i]][j] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span> ; <span class="comment">//如果 k = 0 就表示他們沒有共同字元都沒有於是就直接輸出 0</span></span><br><span class="line"></span><br><span class="line">    d[<span class="number">1</span>] = <span class="number">-1</span> , t[<span class="number">1</span>] = <span class="number">1</span> ; <span class="comment">//LIS init</span></span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">1</span>, cur ; <span class="comment">// len 由於前面已經把 LCS = 0 的機會排除，於是這裡則從 1 開始</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 標準的 LIS 作法，不斷嘗試將 LCS 生長</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= k ; i++ )&#123;</span><br><span class="line">        <span class="keyword">if</span>(num[i] &gt; num[t[len]]) t[++len] = i , d[i] = t[len<span class="number">-1</span>] ;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cur = bs(<span class="number">1</span>,len,i);</span><br><span class="line">            t[cur] = i ;</span><br><span class="line">            d[i] = t[cur<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//debug</span></span><br><span class="line"><span class="comment">//        for(int i = 1 ; i &lt;= k ; i++)</span></span><br><span class="line"><span class="comment">//            cout &lt;&lt; num[t[i]] &lt;&lt; ' ' ;</span></span><br><span class="line"><span class="comment">//        cout &lt;&lt; '\n' ;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len ;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LCS-應用"><a href="#LCS-應用" class="headerlink" title="LCS 應用"></a>LCS 應用</h2><p>我在學習此演算法的過程中如果有題目讓我應用到此演算法我則收錄在此，連結則是我的詳解如果想要去看題目的就搜尋一下吧！</p>
<ul>
<li><a href="https://theriseofdavid.github.io/2020/11/07/UVa/UVa10192/" target="_blank" rel="noopener">UVa10192 - Vacation (LCS)</a></li>
<li><a href="https://theriseofdavid.github.io/2020/03/13/UVa/UVa1207/" target="_blank" rel="noopener">UVa1207 - AGTC (LCS)</a> - 這裡採用的是 \(O(n^2)\) 做法。</li>
</ul>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://blog.51cto.com/karsbin/966387" target="_blank" rel="noopener">lcs 最长公共子序列 O(nlogn)算法</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>Binary Search 好難，嗚嗚，太過於依賴 C++ STL 函數，原本心血來潮想說要來寫一遍 Binary Search 沒想到花了 6 小時都還沒寫出來(完全是透過心想)，原本想說這麼簡單的演算法我應該連紙筆都不用吧！沒想到還是需要，嗚嗚，我腦袋的 RAM 是不是連 1 KB 都沒有呀，好討厭喔。</p>
<p>不過又學了一個新演算法，用於改進 LCS 的時間複雜度其實感覺蠻開心的呢！</p>
<h2 id="LCS-無註解程式碼"><a href="#LCS-無註解程式碼" class="headerlink" title="LCS 無註解程式碼"></a>LCS 無註解程式碼</h2><p>這裡則放置沒有註解的程式碼，如果讀者想要複製就從這裡進行複製吧！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 120</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n ;</span><br><span class="line"><span class="built_in">string</span> strA , strB ;</span><br><span class="line"><span class="keyword">int</span> t[N*N] , d[N*N] , num[N*N] ; </span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dict ; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bs</span><span class="params">(<span class="keyword">int</span> l , <span class="keyword">int</span> r , <span class="keyword">int</span> v )</span></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> m ;</span><br><span class="line">    <span class="keyword">while</span>(r&gt;l)&#123;</span><br><span class="line">        m = (l+r) /<span class="number">2</span> ;</span><br><span class="line">        <span class="keyword">if</span>(num[v] &gt; num[t[m]]) l = m+<span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (num[v] &lt; num[t[m]]) r = m ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> m ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lcs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    dict.clear() ; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = strA.length()<span class="number">-1</span> ; i &gt; <span class="number">0</span> ; i--) dict[strA[i]].push_back(i) ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; strB.length() ; i++)&#123; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; dict[strB[i]].size() ; j++) </span><br><span class="line"></span><br><span class="line">            num[++k] = dict[strB[i]][j] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line"></span><br><span class="line">    d[<span class="number">1</span>] = <span class="number">0</span> , t[<span class="number">1</span>] = <span class="number">1</span> ; </span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">1</span>, cur ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= k ; i++ )&#123;</span><br><span class="line">        <span class="keyword">if</span>(num[i] &gt; num[t[len]]) t[++len] = i , d[i] = t[len<span class="number">-1</span>] ;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cur = bs(<span class="number">1</span>,len,i);</span><br><span class="line">            t[cur] = i ;</span><br><span class="line">            d[i] = t[cur<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len ;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>演算法知識</category>
      </categories>
      <tags>
        <tag>程式解題</tag>
        <tag>字串處理</tag>
        <tag>最長共同子序列 Longest Common Subsequence</tag>
        <tag>演算法知識</tag>
        <tag>動態規劃 Dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title>2020 International Collegiate Programming Contest Asia Taipei-Hsinchu Site (ICPC2020) - 65th 心得</title>
    <url>/2020/11/10/contest_experence/ICPC2020/</url>
    <content><![CDATA[<blockquote>
<p>僅此紀錄 2020/11/08 2020 ICPC 心得。<br>「紀錄每個時刻，讓未來的自己不遺忘過去的自己」<br>只有自己才能體會自己的過去<br>沒有得獎拉，只是很可惜自己還不夠好吧。</p>
<p><strong>明天要保持笑容，面對每個挑戰，因為不優秀的人是沒有資格哭泣的。</strong></p>
</blockquote>
<a id="more"></a>

<h2 id="第一天的報到"><a href="#第一天的報到" class="headerlink" title="第一天的報到"></a>第一天的報到</h2><h3 id="報到"><a href="#報到" class="headerlink" title="報到"></a>報到</h3><p>由於 ICPC 是非常正式的國際賽事，比賽前必須將自己明天要比賽的資料都<strong>事先</strong>放入考試會場內，才可以進行比賽，於是比賽的前一天 2020/11/07 就要先去報到。</p>
<p>早上大約 10:00 起床，寫了一下 UVa 的題目，一直 WA 但卻找不出問題所在，嗚嗚，我真沒用。一路寫到 12 點則從家裡出發前往北商，這是我第二次比 ICPC，這次的比賽地點也還是台北商大(北商)，與學長和漢軒在北商的司令台會合後就前往報到。</p>
<blockquote>
<p>報到時拍的北商畫面 - A</p>
</blockquote>
<p><img src="/images/ICPC2020/1.jpg" alt=""></p>
<blockquote>
<p>報到時拍的北商畫面 - B</p>
</blockquote>
<p><img src="/images/ICPC2020/2.jpg" alt=""></p>
<blockquote>
<p>隊伍留念拍照</p>
</blockquote>
<p><img src="/images/ICPC2020/11.JPG" alt=""></p>
<h3 id="進場與開幕典禮"><a href="#進場與開幕典禮" class="headerlink" title="進場與開幕典禮"></a>進場與開幕典禮</h3><p>報到時先給工作人員查看自己的學生證，確認身分無誤後給予我們參賽資料，內容有：比賽手冊、背包、衣服，這次的背包與上次不同，上次的是束口袋，這此則是布背包，讓我感覺到這次的比賽的高級感阿，好開心！之後換上今年的選手衣服後，到這次 ICPC2020 的 logo 前合照，完成了報告的全部事宜。</p>
<blockquote>
<p>進場時拍下的比賽場地照片 (Please Do Not Touch Anything)</p>
</blockquote>
<p><img src="/images/ICPC2020/2.jpg" alt=""></p>
<p>接下來上樓後學長放上我們的 NoteBook 與資料夾，整理一下環境隨後就準備要進行開幕典禮，由於今年的開幕典禮沒有國際隊伍，而沒有國際隊伍的原因是因為今年新冠肺炎疫情，因此這次的開幕典禮是用<strong>中文</strong>來開幕，蠻驚奇的，下次應該不會這樣吧www，看來我今年聽到了限量場次的 ICPC 中文演講XD。</p>
<p>這次的主辦單位總喜歡威脅隊伍www，時常聽到主辦單位說，「只要你XXXXX，我們就取消你的參賽資格。」，就像是國中老師恐嚇學生要記警告一樣XD，讓我想起了國中的恐懼www，沒，我好像到國三就沒有再害怕警告了，太屁孩了。當時不愛讀書，才導致現在只能讀北科，老實講，心情還是有點難過吧，後悔當時沒有再讀點書，想跟未來的自己說對不起，是過去的自己不努力。</p>
<blockquote>
<p>選手證</p>
</blockquote>
<p><img src="/images/ICPC2020/4.jpg" alt=""></p>
<h3 id="電腦測試"><a href="#電腦測試" class="headerlink" title="電腦測試"></a>電腦測試</h3><p>開幕典禮結束後，就準備要來寫程式啦！主要是 Demo 電腦有沒有壞掉或是出現異常的情況發生，很幸運地這次沒有，主辦單位這次有提醒我們說由於電腦是<strong>最新的 Ubuntu and CodeBlock</strong>，如果電腦當掉的話我們不負責任，嗚嗚嗚，這樣不好啦，用穩定的版本不是很好嗎，我覺得可以在稍稍改進，臨時突然用新的 IDE 真的不太習慣，不過這次同時我們也注意到這場比賽的椅子有軟墊！鍵盤也不再是那種買桌電會贈送的鍵盤，而是聯想的普通鍵盤，這讓我感到更開心，這場的硬體水準大幅提升，太開心啦，經濟回升了，對吧！</p>
<p>這一次測試電腦我們有抓出比較有趣的地方，例如我們在 C++ 中寫出 index -1 或是大於陣列的最大 index，都是沒有問題的！且送上去主辦單位的 Judge (Dom Judge) 也都可以順利編譯！這讓我超開心的拉，因為 UVa 是不會通過的，所以有些小地方都還需要注意一下，如果 C++ 會幫我注意那就太好啦，不過會導致我寫程式時越來越不小心XD，我很抱歉，不過話說 C++ 是不是要逐漸 Python 化拉。<del>越來越軟</del></p>
<p>由於中午太趕都沒有吃午餐，到大概下午 2:00 時肚子就咕嚕咕嚕地叫了，那時候我的肚子感到難過，幸好學長有說後面有一些簡單的小餅乾，我趕快去把那些餅乾吃一些，恩，好吃，好好吃，有我愛吃的，好讚！吃飽了以後就回到比賽位置坐下等待下一個程序。</p>
<h3 id="小插曲"><a href="#小插曲" class="headerlink" title="小插曲"></a>小插曲</h3><p>由於我們測試完電腦也覺得沒有問題後，我們就在等待測試的時間結束，這一次的比賽有點冷，不對，是每次的比賽都很冷XDDD，這也讓我下定決心明天一定要帶北科資財系的外套，他超級保暖，保暖到我以為這是下雪才可以穿出來的，沒有，只要是 ICPC 都可以穿，因為冷氣都會很冷，北極雄們，我對不起你們QQQ。</p>
<p>這一次比賽有提到可以帶英漢字典，但我們一開始不知道這些資訊於是沒有事先準備，但這對於英文不好的我是一大福音，於是我就臨時想到家裡小時後把我送去何嘉仁美語補習班補英文時所用的英漢字典，我就趕緊回家再把他帶過來，當我送來後則發現剛好比賽測試時間也剛好結束，時間算得剛剛好，運氣不錯XD。</p>
<h3 id="回家休息"><a href="#回家休息" class="headerlink" title="回家休息"></a>回家休息</h3><p>大約在下午 4:50 主辦單位則說我們可以準備回去，並回答一些 Q&amp;A 問題，我們稍微聆聽一下問題的回答後就回家進行休息，準備明天比賽。</p>
<p>但其實我那天睡不太著，凌晨樓下的音樂一直震動使我翻來覆去無法入眠，晚上其實也都在練習 UVa 題目希望可以把他解開，但還是解不太開，我的程式能力真的好弱，好希望可以變強，我可能需要從這一次的經驗中找出最適合我的學習成長方法。</p>
<h2 id="比賽當天"><a href="#比賽當天" class="headerlink" title="比賽當天"></a>比賽當天</h2><h3 id="報到-1"><a href="#報到-1" class="headerlink" title="報到"></a>報到</h3><p>早上起床後，我稍稍得有點賴床，起床後我則準備出門去吃我的麥當勞早餐，這應該是我人生不到五次的麥當勞早餐吧XD，麥當勞早餐其實蠻好吃的，以後可以多吃一點，而且還看到早上 8:30 竟然有大人在教小孩寫數學，這些小孩真是優秀呀，也感動大人可以從小就引導他們長大。</p>
<p>吃完了之後則順利地前往北商，由於今天是禮拜日，沒有甚麼塞車，很順利的就抵達拉。</p>
<h3 id="比賽過程"><a href="#比賽過程" class="headerlink" title="比賽過程"></a>比賽過程</h3><p>比賽時我們透過策略用資料夾來放置我們的題目，我覺得還蠻有效的，真的沒有資料亂掉，讚讚。當發現這一次的題目本都是 1/2 都是圖論題的時候心有涼了一半，不是說圖論題不好，而是我們的策略是以數學、圖論、字串這樣區分，如果這次都是以圖論為重心時則會發現那這次對其中一位隊友的負擔量特別高，如果他遇到難題或是掉進思考深淵時就非常容易讓整個隊伍進入停擺狀態。</p>
<p>比賽前期我們順利解完 3 題，雖然時間稍微輸別人一些但並不差，我先拿了一題 game 題來解，但是因為英文問題導致我在閱讀題目時有了些許浪費時間 Coding 錯方向，後來漢軒有幫我引導到對的方向真的要感謝他，嗚嗚。但其實只有小方向不對我很快就修正回來，但是遇到一個難題就是他還是 WA，我們百思不得其解為甚麼會 WA，到現在還是沒有想出來，只能趁比賽結束後去找答案了，過程中也有點對題目分配感到不公平，這一次圖論的比例非常高，讓我們隊伍原本是平均分配的重心失衡，但反過來也有可能是我們的策略有些許的問題還需要再修正，因為這樣就表示我們的 model 並沒有符合這次 ICPC 的題目本。</p>
<p>寫到後面時，學長也不斷的在 Coding Problem H 但那題一直不斷的 TLE，學長陷入的思考深淵想不出這題為甚麼會超時也不斷在賽程中優化但還是沒有成功 AC，到賽後結束時向其他隊伍詢問卻發現明明方法卻是相同的！但只有我們的 TLE，真的有點可惜，如果我的題目或是學長的題目有成功解出一題那我們一定會有銅獎的，但是這一出的 String 題過難也讓我相當難過，我沒辦法在自己的能力範圍內做出貢獻，而是當場直接測試自己的想法卻無法驗證。</p>
<p>這場比賽五小時過得飛快，腦力激盪相當過癮但也讓比賽結束後的我相當難過。</p>
<blockquote>
<p>比賽過程時，主辦單位拍下的照片</p>
</blockquote>
<p><img src="/images/ICPC2020/12.JPG" alt=""></p>
<h3 id="賽後結束-晚宴時間"><a href="#賽後結束-晚宴時間" class="headerlink" title="賽後結束 - 晚宴時間"></a>賽後結束 - 晚宴時間</h3><p>今年的晚宴相當不賴，雖然隊員們都提早離開，但我還是想留在台北商大沉思，一邊想著自己哪裡還有地方可以改進一邊吃著食物，雖然非常的不甘心，但是我知道比賽本來就是贏者全拿，我只要能夠當上贏者我也可以贏者全拿，一邊吃著食物邊默默想著未來要怎麼拿到銀獎。</p>
<blockquote>
<p>晚宴的甜點</p>
</blockquote>
<p><img src="/images/ICPC2020/5.jpg" alt=""></p>
<h2 id="比賽心得"><a href="#比賽心得" class="headerlink" title="比賽心得"></a>比賽心得</h2><p>老實說，我很難過，真的非常非常難過，難過到話都說不出來。</p>
<p>不是氣隊友，是氣自己沒有用處，這一次的題目中 String 只有一題且那題並沒有人解開，使我無用武之地，只能想 Game 題，讓我今天真的很難過，沒有派上用場，也讓我大嘆不公平，我明明是一個想要變得優秀的人卻礙於學校限制而沒辦法變的優秀，今天領悟最深的是，<strong>不是我不努力，是我連努力的資格都沒有</strong>，你說你想要考好 ICPC，那你要怎麼考好？我不知道，台北科大知道嗎？他不知道，我們有資源可以扭轉困境嗎，我感覺不到，已經努力了一年去改變這個困境但這過程很痛苦，至現在又還沒找到方法，你覺得是我們爛嗎？或許是吧，我們不是優秀的人物，可以去更那些已經有學長傳承下來的人競爭、抗戰。</p>
<p>當然，我不否認，你可以說在網路上真的可以找到很多資料自學，那換我問你？</p>
<ul>
<li>你知道怎麼抓資料嗎？</li>
<li>你有辦法在你對這個演算法都不了解時可以找到一篇沒有錯誤完全正確的資訊網頁嗎？</li>
<li>你能夠只看資訊網頁就能理解那些演算法的奧妙嗎？</li>
<li>資訊網頁所述說的邏輯你都能夠看懂嗎？</li>
<li>資訊網頁的程式碼你不需要解釋就能夠完全理解嗎？</li>
<li>你能透過上網查到上面這些問題，而不透過別人的教導嗎？</li>
</ul>
<p>就算你完成了以上所有問題，你也已經輸了那些有學長有老師的學生們，他們資質比你強、又有學長、老師指導幫你快速解決你的思考盲點，當你學完時發現別人已經學完兩個演算法時，你不會氣餒、你不會難過嗎？</p>
<p>不是台北科大不好，只是我怨恨我自己在我不懂事的年代沒有多懂事一點，如果真的有讀者願意讀到這裡，我用我那潰不成氣的聲音說，<strong>這過程有多少的痛苦，是永遠沒辦法用比賽成績去衡量的</strong>，比賽永遠不是比你的努力，比賽就像出生一樣，是有貧富差距的，<strong>你是窮人你只能夠比別人懂事，才能贏過那些比你好的人</strong>，憑甚麼沒資源的人一定要用痛苦才能換來有錢人習以為常的事物，我也是人，我也想要資源、我也想要尊嚴。</p>
<p>管理、NoteBook、練習等，全部都需要一個隊伍包辦，我們都靠著 3 人隊伍硬撐著，沒有人看到我們的辛勞，我們也看不到別人的辛勞，不覺得這很不公平嗎？明明都有最佳女隊伍獎，就不能對於這些沒有資源的隊伍作出一些讚美嗎？我們是不是沒有出名、沒有成就就永遠沒有人看見我們？</p>
<p>說太多了，但我真的好難過，我好想哭，我不怨恨別人比我強，我只是對我自己的弱小感到難過，憑甚麼我是一個這麼沒有能力的人，沒有辦法與他人競爭，只能打這 BLOG 難過，而不是找到強者與強者一同讀書、成功。</p>
<p>也許是資源不均，讓我的學習之路已經成為偏差了吧？現在的我真的不知道我還有沒有辦法聽著講師上課來讓我快速學習知識？如果有，我一定要好好把握，<strong>他人習以為常的事物，在我眼中卻像黃金一樣珍貴</strong>。</p>
<p>很感謝隊伍願意陪我一起練習，包容著這麼沒用的我，即使比賽結束也沒有對隊員做出負面行為，也都將情緒留在自身消化，特別是學長，這一路以來應該最辛苦的就是他了吧，他也都不曾抱怨，願意付出一切，沒有他真的沒辦法，補足了我的缺陷，教導了我許多應該要在未來才能學到的觀念，他提前教倒了我，這一路以來真的很謝謝他，如果可以，我也想為他做些甚麼。</p>
<p>總而言之，這是一篇負面文，我很抱歉讓大家接受我現在的負面情緒，但是我也不知道我該怎麼辦…，像個走失的小男孩因為找不到媽媽而不安心的四處盼望媽媽身影卻還是不到，那著急著、眼框放紅，強忍著哭意的男孩。</p>
<p><strong>明天要保持笑容，面對每個挑戰，因為不優秀的人是沒有資格哭泣的。</strong></p>
<p>今天最有感觸的話了吧，從自己內心中那最真實的聲音。</p>
<blockquote>
<p>激勵自己的話 - 成功不是憑夢想和希望而是憑努力和實踐</p>
</blockquote>
<p><img src="/images/ICPC2020/6.jpg" alt=""></p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://drive.google.com/drive/folders/1fJutJ9MN6THv0MeKBPWvk8Jy2TJsWzSF" target="_blank" rel="noopener">ICPC2020 照片</a></p>
]]></content>
      <categories>
        <category>競賽心得</category>
      </categories>
      <tags>
        <tag>大學Life</tag>
        <tag>ICPC</tag>
        <tag>程式比賽</tag>
        <tag>競賽心得</tag>
        <tag>人生旅途</tag>
      </tags>
  </entry>
  <entry>
    <title>演算法知識 - Longest Increasing Subsequence 最長遞增子序列(時間複雜度 O(nlogn))</title>
    <url>/2020/11/13/Explain_Algorithm/LIS/</url>
    <content><![CDATA[<h2 id="Longest-Increasing-Subsequence-介紹"><a href="#Longest-Increasing-Subsequence-介紹" class="headerlink" title="Longest Increasing Subsequence 介紹"></a>Longest Increasing Subsequence 介紹</h2><blockquote>
<p>以下簡稱 LIS，在一個陣列中找出最長遞增的序列，序列是甚麼？舉例：</p>
<ul>
<li>1 3 4 2 5<br>則此 LIS 的長度為 3，符合最長長度的有三種：</li>
</ul>
<ul>
<li>1,3,4</li>
<li>1,2,5</li>
<li>1,4,5</li>
</ul>
<p>只要相對位置有達到遞增，且數值也有遞增則符合<strong>遞增序列</strong>的意思。</p>
<p>在一些數學研究會涉及此演算法，且此演算法有兩種不一樣的時間複雜度，一種為 \(O(N^2)\) 另一種則為 \(O(n /log n)\)</p>
<p><strong>這裡我們則是介紹比較快的方法，\(O(n \log n) \)</strong></p>
</blockquote>
<a id="more"></a>

<h2 id="Longest-Increasing-Subsequence-原理"><a href="#Longest-Increasing-Subsequence-原理" class="headerlink" title="Longest Increasing Subsequence 原理"></a>Longest Increasing Subsequence 原理</h2><p>二分搜尋 + 陣列 = LIS，這是最好的解釋了XD。</p>
<p>產生兩個陣列 t , d ， t 用來記錄當前最長序列，d 則用來記錄當前 LIS 有包括此數值的前一個數值位置。</p>
<h3 id="QUESTION-你在解釋甚麼，太爛了吧XD。"><a href="#QUESTION-你在解釋甚麼，太爛了吧XD。" class="headerlink" title="QUESTION: 你在解釋甚麼，太爛了吧XD。"></a>QUESTION: 你在解釋甚麼，太爛了吧XD。</h3><p><del>我也覺得</del>，所以我們用舉例的。</p>
<p>假設我們要在 10 30 20 40 50 找出 LIS，那透過我們的原理要怎麼做呢？</p>
<h4 id="Step1-初始化-t-d-並-i-1-放入-10"><a href="#Step1-初始化-t-d-並-i-1-放入-10" class="headerlink" title="Step1: 初始化 t , d 並 i = 1 , 放入 10"></a>Step1: 初始化 t , d 並 i = 1 , 放入 10</h4><p>由於 t 是紀錄最長陣列，且我們一定能夠保證 LIS 最長長度一定有 1，則是因為隨機在數列中拿出一個元素都可以是 LIS 長度為 1 而得證。</p>
<p>所以我們就在 t[1] 直接放入<strong>第一個數值的 index</strong>，<strong>這裡很重要，t and d 都是紀錄數值的 index</strong>。</p>
<p>由於 d[1] 是數列中的第一個 LIS 長度一定只有 1，所以設定成 0，表示他沒有前一個數值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">t[<span class="number">1</span>] = <span class="number">1</span> ; </span><br><span class="line">d[<span class="number">1</span>] = <span class="number">0</span> ;</span><br></pre></td></tr></table></figure>

<h3 id="Step-2-i-2-放入-30"><a href="#Step-2-i-2-放入-30" class="headerlink" title="Step 2 : i = 2 , 放入 30"></a>Step 2 : i = 2 , 放入 30</h3><p>因為 30 有比 10 大，因此只需要在 LIS 增加長度即可，因此 LIS 的第二個長度放入數值的 index。</p>
<p>d[2] 則記錄當前最長的 LIS 此數值的前一個值，表示 d[2] 如果要往前回朔就是找此值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">t[<span class="number">2</span>] = <span class="number">2</span> ; </span><br><span class="line">d[<span class="number">2</span>] = t[<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h3 id="Step-3-i-3-放入-20"><a href="#Step-3-i-3-放入-20" class="headerlink" title="Step 3 : i = 3 , 放入 20"></a>Step 3 : i = 3 , 放入 20</h3><p>由於 20 沒有比 30 大，於是我們必須要使用<strong>二分搜尋</strong>法，找出 2 在 t 這個陣列中適合放入哪個位置，由於二分搜尋的時間複雜度是 \(O(\log n)\)，因此再根據此陣列的長度 \(* n \)，就會符合此演算法的時間複雜度 \(O(n \log \ n)\)。</p>
<p>我們找到 t[2] = 3，所以我們把 t[2] 的值改成 2，為甚麼要這樣做呢？很簡單，因為如果 t[] 的數值越小代表之後可以放進去的數值會<strong>有可能</strong>比現在的數值還更多機會擴增 LIS，假如下一個是 25，那如果這邊沒有先將數值改成 20，25 就沒辦法擴增 LIS 了，因此才要做改值。</p>
<p>這裡為甚麼 <code>d[3] = t[1]</code> 呢？因為我們將 t[2] 放入當前的值，因此在現在的 t[1] 則是我們現在 d[3] 要記錄的前一個 LIS 數值，之後從 d[3] 不斷回推時可以發現只要回推 2 次就會回到 d[0]。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">t[<span class="number">2</span>] = <span class="number">3</span> ;</span><br><span class="line">d[<span class="number">3</span>] = t[<span class="number">1</span>] ;</span><br></pre></td></tr></table></figure>

<h3 id="Step-4-i-4-放入-40"><a href="#Step-4-i-4-放入-40" class="headerlink" title="Step 4: i = 4 , 放入 40"></a>Step 4: i = 4 , 放入 40</h3><p>因為 40 有比 20 大，因此只需要在 LIS 增加長度即可，因此 LIS 的第三個長度放入數值的 index。</p>
<p>d[4] 則記錄當前最長的 LIS 此數值的前一個值，表示 d[4] 如果要往前回朔就是找此值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">t[<span class="number">3</span>] = <span class="number">4</span> ; </span><br><span class="line">d[<span class="number">4</span>] = t[<span class="number">2</span>] ;</span><br></pre></td></tr></table></figure>

<h3 id="Step-5-i-5-放入-50"><a href="#Step-5-i-5-放入-50" class="headerlink" title="Step 5: i = 5 , 放入 50"></a>Step 5: i = 5 , 放入 50</h3><p>道理與 Step4 相同<br>因為 50 有比 40 大，因此只需要在 LIS 增加長度即可，因此 LIS 的第四個長度放入數值的 index。</p>
<p>d[5] 則記錄當前最長的 LIS 此數值的前一個值，表示 d[5] 如果要往前回朔就是找此值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">t[<span class="number">4</span>] = <span class="number">5</span> ;</span><br><span class="line">d[<span class="number">5</span>] = t[<span class="number">3</span>] ;</span><br></pre></td></tr></table></figure>

<h3 id="Step-6-完成了！此時我們簡單檢查一下，t-陣列裡的數值是不是最長-LIS"><a href="#Step-6-完成了！此時我們簡單檢查一下，t-陣列裡的數值是不是最長-LIS" class="headerlink" title="Step 6: 完成了！此時我們簡單檢查一下，t 陣列裡的數值是不是最長 LIS"></a>Step 6: 完成了！此時我們簡單檢查一下，t 陣列裡的數值是不是最長 LIS</h3><table>
<thead>
<tr>
<th>array</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody><tr>
<td>t</td>
<td>0</td>
<td>1</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>-</td>
</tr>
<tr>
<td>value</td>
<td>0</td>
<td>10</td>
<td>20</td>
<td>40</td>
<td>50</td>
<td>-</td>
</tr>
</tbody></table>
<p>OK，沒錯，LIS 正確無誤。</p>
<h3 id="OK-現在問題被我們解決成是-Binary-Search-了，那我們就來做吧！"><a href="#OK-現在問題被我們解決成是-Binary-Search-了，那我們就來做吧！" class="headerlink" title="OK, 現在問題被我們解決成是 Binary Search 了，那我們就來做吧！"></a>OK, 現在問題被我們解決成是 Binary Search 了，那我們就來做吧！</h3><p>關於 <a href="https://theriseofdavid.github.io/2020/11/15/Explain_Algorithm/binary_search/" target="_blank" rel="noopener">Binary Search 的部分就先去看大衞的筆記</a>即可。</p>
<h2 id="LIS-實作與說明"><a href="#LIS-實作與說明" class="headerlink" title="LIS 實作與說明"></a>LIS 實作與說明</h2><h3 id="版本一-學習版"><a href="#版本一-學習版" class="headerlink" title="版本一 學習版"></a>版本一 學習版</h3><p>在程式碼進行說明，相信會比較好理解些。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N </span></span><br><span class="line"><span class="keyword">int</span> b[N] , t[N] , d[N] , n ; </span><br><span class="line"><span class="comment">// b 是原本的數列</span></span><br><span class="line"><span class="comment">// t 則是當前 LIS 的數列</span></span><br><span class="line"><span class="comment">// d 則是在 LIS 中此數值的前一個數值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bs</span><span class="params">(<span class="keyword">int</span> l , <span class="keyword">int</span> r , <span class="keyword">int</span> v)</span></span>&#123; <span class="comment">//二分搜尋法</span></span><br><span class="line">    <span class="keyword">int</span> m ;</span><br><span class="line">    <span class="keyword">while</span>(r&gt;l)&#123;</span><br><span class="line">        m = (r+l) / <span class="number">2</span> ;</span><br><span class="line">        <span class="keyword">if</span>(b[v] &gt; b[t[m]] ) l = m+<span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">else</span> r = m ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lis</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">1</span> , cur ; <span class="comment">//LIS 最小長度為 1，因此 len = 1</span></span><br><span class="line">    <span class="comment">//cur 則是二分搜尋中找到的位置</span></span><br><span class="line">    d[<span class="number">1</span>] = <span class="number">0</span> , t[<span class="number">1</span>] = <span class="number">1</span> ; <span class="comment">//初始化 LIS 需要用到的兩個陣列</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= n ; i++)&#123; <span class="comment">//</span></span><br><span class="line">        <span class="keyword">if</span>(b[i] &gt; b[t[len]] )&#123; <span class="comment">//如果此數值比 LIS 中最長的數值還大時就直接增長</span></span><br><span class="line">            d[i] = t[len] ; <span class="comment">//d[i] 就則是在 LIS 中此數值的前一個數值</span></span><br><span class="line">            t[++len] = i ; <span class="comment">//增長 t 的長度</span></span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span>&#123; <span class="comment">// 表示目前的數值可以替換此 LIS 中某個數值</span></span><br><span class="line">            cur = bs(<span class="number">1</span>,len,i);  <span class="comment">// 二分搜尋找出此位置</span></span><br><span class="line">            t[cur] = i ; <span class="comment">//將原本 LIS 的 cur 值替換成 i </span></span><br><span class="line">            d[i] = t[cur<span class="number">-1</span>] ; <span class="comment">// 由於我們將 i 放入 t[cur]，所以我們的 d 就是找 t[cur-1]</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len ; <span class="comment">//回傳最長 LIS</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="版本二-實踐版"><a href="#版本二-實踐版" class="headerlink" title="版本二 實踐版"></a>版本二 實踐版</h3><p>此版比較好實踐，但並沒有辦法了解深刻意思，建議大家先學習舊版的再看新版的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 5020</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[MAXN];</span><br><span class="line"><span class="keyword">int</span> T, n, len = <span class="number">0</span>, cur;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lis</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; b; <span class="comment">//用來產生 LIS 長度</span></span><br><span class="line">    b.push_back(a[<span class="number">0</span>]); <span class="comment">//先放入一個數值，以避免 b.back() 找不到值</span></span><br><span class="line">    <span class="keyword">int</span> temp; <span class="comment">//紀錄二分搜尋後找到的位置</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] &gt; b.back())&#123; <span class="comment">//如果現在這個數字大於此數列中最大的數字</span></span><br><span class="line">            b.push_back(a[i]); <span class="comment">//LIS push back</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            temp = upper_bound(b.begin(), b.end(), a[i]) - b.begin(); </span><br><span class="line">            <span class="comment">//二分搜尋，找到他適合的位置，前面數字比她小或相等，後面數字大</span></span><br><span class="line">            b.insert(b.begin()+temp , a[i]); <span class="comment">//插入數值在此位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b.size(); <span class="comment">//輸出最長 LIS 長度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LCS-應用"><a href="#LCS-應用" class="headerlink" title="LCS 應用"></a>LCS 應用</h2><p>我在學習此演算法的過程中如果有題目讓我應用到此演算法我則收錄在此，連結則是我的詳解如果想要去看題目的就搜尋一下吧！</p>
<ul>
<li><a href="https://theriseofdavid.github.io/2020/11/14/UVa/UVa111/" target="_blank" rel="noopener">UVa 111 - History Grading (LIS)</a></li>
</ul>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://www.youtube.com/watch?v=S9oUiVYEq7E&t=0s" target="_blank" rel="noopener">Longest Increasing Subsequence in nlogn time - Tushar Roy - Coding Made Simple </a><br><a href="https://forgoal.gitbooks.io/-/content/longest_increasing_subsequence.html" target="_blank" rel="noopener">Longest Increasing Subsequence (LIS)</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>複習一些之前所學習的演算法並加入我的 blog 中感覺其實還真不賴呢！感覺以後如果有些忘記就可以直接拿過來用了XD，而且又是變相地複習我的演算法知識，只是在打演算法解釋有點麻煩QQ，語言障礙不太行阿，希望之後可以把自己的文字表達能力練強，才不會讓別人都聽不懂我在說甚麼…。</p>
<p>總感覺自學就像盲人摸象一般，有時候別人跟你說專業的你反而聽不懂呢。因為你學習並不是一個完整的系統導致有些部分會 miss，但教授都會假設你是完整的學過，所以要盡量補起來這些坑呢！</p>
<h2 id="LCS-無註解程式碼"><a href="#LCS-無註解程式碼" class="headerlink" title="LCS 無註解程式碼"></a>LCS 無註解程式碼</h2><p>這裡則放置沒有註解的程式碼，如果讀者想要複製就從這裡進行複製吧！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N </span></span><br><span class="line"><span class="keyword">int</span> b[N] , t[N] , d[N] , n ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bs</span><span class="params">(<span class="keyword">int</span> l , <span class="keyword">int</span> r , <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m ;</span><br><span class="line">    <span class="keyword">while</span>(r&gt;l)&#123;</span><br><span class="line">        m = (r+l) / <span class="number">2</span> ;</span><br><span class="line">        <span class="keyword">if</span>(b[v] &gt; b[t[m]] ) l = m+<span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">else</span> r = m ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lis</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">1</span> , cur ;</span><br><span class="line">    d[<span class="number">1</span>] = <span class="number">0</span> , t[<span class="number">1</span>] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= n ; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b[i] &gt; b[t[len]] )&#123;</span><br><span class="line">            d[i] = t[len] ;</span><br><span class="line">            t[++len] = i ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cur = bs(<span class="number">1</span>,len,i);</span><br><span class="line">            t[cur] = i ;</span><br><span class="line">            d[i] = t[cur<span class="number">-1</span>] ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>演算法知識</category>
      </categories>
      <tags>
        <tag>程式解題</tag>
        <tag>演算法知識</tag>
        <tag>最長遞增子序列 Longest Increasing Subsequence</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa 111 - History Grading (LIS)</title>
    <url>/2020/11/14/UVa/UVa111/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>老師要改考卷關於歷史的事件排序，我們要寫程式幫老師解決其中一道題目，簡單來說，歷史有很多事件，只要學生們排序歷史事件順序有對，就給予相對應的分數，我們將歷史事件定義成數字，順序則就是數學的遞增。</p>
<p>1,2,3,4 得四分 因為遞增的數列最長可以來到 4<br>2,1,3,4 得三分，因為 1,3,4 or 2,3,4 這樣的順序都有正確，但順序長度只有 3，所以就輸出 3 分<br>4,3,2,1 得一分，有這四種 1 or 2 or 3 or 4，而他們遞增長度最高都只能來到 1，因此只有一分。</p>
<p>我們就是要找出，最長的數值遞增長度。</p>
<p>這題的格式： 1 3 2 4 ，其中 1 是表示歷史事件 1 是在第 1 個位置、 3 則是表示歷史事件 <strong>2</strong> 是在第三個位置，全部的數值都是用此表達方式表達。</p>
</blockquote>
<a id="more"></a>

<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>看得出來嗎XD，這題其實就是詢問你最長的 LIS 長度。</p>
<p>這題就是標準的最長遞增子序列 Longest Increasing Subsequence (以下簡稱 LIS) 問題，這裡使用 \(O(n \log n)\) 來解決此問題。</p>
<p>如果還不太懂 LIS 是甚麼問題，建議看看 <a href="https://theriseofdavid.github.io/2020/11/13/Explain_Algorithm/LIS/" target="_blank" rel="noopener">演算法知識 - Longest Increasing Subsequence 最長遞增子序列(時間複雜度 O(nlogn))</a>，這裡有對於此演算法有完整的介紹 </p>
<h2 id="焦點回到題目上，解開題目的小設計"><a href="#焦點回到題目上，解開題目的小設計" class="headerlink" title="焦點回到題目上，解開題目的小設計"></a>焦點回到題目上，解開題目的小設計</h2><p>這題有個巨大的坑，他並不是一開始就排好順序的，他有一個特殊格式，還有在題目卷下寫一個 <strong>warning</strong>，要你好好看懂。<del>那時候我還以為我自己有看懂了，英文差的人就是這麼爛嘛 ಥ⌣ಥ</del></p>
<p>重點是我還花了兩小時！完全沒有找出錯誤…，看別人的解答才知道…，我好爛QQ。</p>
<p>於是我們要怎麼解決這個問題呢，index 上的值是 rank(他們的順序)，其實這裡有點腦筋急轉彎，我還以為出題者可能就是要考這個呢XD。</p>
<p>先直接將老師的答案直接存到陣列中，我們舉例一下：</p>
<p>正確解答： 3 2 1 4 ，我們定義正確解答為 a[]<br>你的答案： 2 1 3 4 ，我們定義你的答案為 b[]</p>
<p>於是我們先這樣做</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">a[<span class="number">1</span>] = <span class="number">3</span> <span class="comment">//因為 1 應該要排在第 3 個位置，我們先透過 a 進行記錄</span></span><br><span class="line">a[<span class="number">2</span>] = <span class="number">2</span></span><br><span class="line">a[<span class="number">3</span>] = <span class="number">1</span></span><br><span class="line">a[<span class="number">4</span>] = <span class="number">4</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">// 透過此方式可以直接產生符合題目要求且方便 LIS 撰寫的陣列</span></span><br><span class="line">b[<span class="number">2</span>] = a[<span class="number">1</span>] = <span class="number">3</span>  <span class="comment">// 由於你的答案歷史事件 1 的 rank 是 2，表示他應該是要在生成數列中的第二個位置，因此設定成 b[2]</span></span><br><span class="line"><span class="comment">// a[1] 則是 1 事件的 rank 位置，也就是他其實是第 3 個發生的事情，所以 b[2] = 3</span></span><br><span class="line">b[<span class="number">1</span>] = a[<span class="number">2</span>] = <span class="number">2</span> </span><br><span class="line">b[<span class="number">3</span>] = a[<span class="number">3</span>] = <span class="number">1</span></span><br><span class="line">b[<span class="number">4</span>] = a[<span class="number">4</span>] = <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>透過此方式可以得知，b[] 按照 index 順序並從 1 開始應該是這樣的 2 3 1 4，肉眼不難找出最長的 LIS 有 3，且為 2 1 4，我們再來驗證看是否正確，對的，沒錯正確解答與你的解答確實 2 1 4 有符合順序，因此得證。</p>
<p>OK，解開題目得小設計後，其他就與 LIS 沒有不同拉XD，記住要用迴圈寫就好，不可以手寫喔，會累死你的。</p>
<h2 id="參考連結："><a href="#參考連結：" class="headerlink" title="參考連結："></a>參考連結：</h2><p><a href="https://www.itdaan.com/tw/ff7a789caa729620e32dffbb7eed755c" target="_blank" rel="noopener">UVa 111 History Grading （簡單DP，LIS或LCS）</a></p>
<h2 id="心得："><a href="#心得：" class="headerlink" title="心得："></a>心得：</h2><p>老話一句，英文很重要QQ，我到底因為英文不好吃了幾次虧啦…，好討厭。這麼簡單的一個題目我也可以拖 3 個小時都沒辦法解開而且還是錯在這種腦筋急轉彎的部分，是欺負我英文不好跟嫌我腦袋太笨嘛ಥ⌣ಥ，不行，我要讀好英文、增加自己的思維，成為一個優秀的人不會被再被這種問題給打倒，如果我沒辦法當一位聰明的人，至少我要當一個很有經驗的人！</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>其實就是沒有附上說明的程式碼，看得懂跟說得出來真的是兩回事，也許還有人覺得我說的很差，不過我已經盡力解釋。希望可以幫助到各位。</p>
<p>也希望大家想要學習的知識都可以快速學習而成，不要因為自身的環境不足而學習不到。</p>
<p>於是這裡就補述一些題目給的資料範圍限制與標頭檔了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 25</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[N] , b[N] , t[N] , d[N] , n ;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; dict ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bs</span><span class="params">(<span class="keyword">int</span> l , <span class="keyword">int</span> r , <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m ;</span><br><span class="line">    <span class="keyword">while</span>(r&gt;l)&#123;</span><br><span class="line">        m = (r+l) / <span class="number">2</span> ;</span><br><span class="line">        <span class="keyword">if</span>(b[v] &gt; b[t[m]] ) l = m+<span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">else</span> r = m ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lis</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">1</span> , cur ;</span><br><span class="line">    d[<span class="number">1</span>] = <span class="number">0</span> , t[<span class="number">1</span>] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= n ; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b[i] &gt; b[t[len]] )&#123;</span><br><span class="line">            d[i] = t[len] ;</span><br><span class="line">            t[++len] = i ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cur = bs(<span class="number">1</span>,len,i);</span><br><span class="line">            t[cur] = i ;</span><br><span class="line">            d[i] = t[cur<span class="number">-1</span>] ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="comment">//freopen("out.txt" , "w" , stdout);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">    <span class="keyword">int</span> j , temp ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; temp ;</span><br><span class="line">        a[i] = temp ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; j )&#123;</span><br><span class="line">        b[j] = a[<span class="number">1</span>]  ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= n ; i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; temp ;</span><br><span class="line">            b[temp] = a[i] ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//debug</span></span><br><span class="line">        <span class="comment">//for(int i = 1 ; i &lt;= n ; i++) cout &lt;&lt; b[i] &lt;&lt; ' ' ;</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; lis() &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>演算法知識</category>
      </categories>
      <tags>
        <tag>程式解題</tag>
        <tag>演算法知識</tag>
        <tag>最長遞增子序列 Longest Increasing Subsequence</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa245 - Uncompress (String Process)</title>
    <url>/2020/09/25/UVa/UVa245/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>給你一個經過壓縮的文本，文本中的數字則是代表是前面第幾個單字並輸出，但如果前面那些單字有重複到則只算一次並且是由後往前看的第一次遇到為準，請解壓縮此文本。</p>
<p>註:單字中間只要遇到非英文字母就全部都視為不一樣的單字。</p>
</blockquote>
<a id="more"></a>

<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>這題要用 Linked-List 由於每個單字的上一個單字與下一個單字都會隨著壓縮而變不同，剛好符合 Linked-List 的特色。再加上一些優秀的讀取字串技術，就可以輕鬆解決掉這題了XD。</p>
<p>如果不懂的話，下方程式碼有做解說。相信你會很快理解 Linked-List 的，我很努力想讓讀者都能懂啦。但是我個人不太喜歡在解題時使用指標，所以下面並不是指標實作。<del>對不起我就爛，debug 指標的技術很爛</del></p>
<h2 id="參考連結："><a href="#參考連結：" class="headerlink" title="參考連結："></a>參考連結：</h2><p><a href="https://www.codeleading.com/article/5927815599/" target="_blank" rel="noopener">UVA245 WF5184 POJ1885 Uncompress【文本】</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>這題應該看的出來他是用 Linked-List 拉XD，我一開始是想要用 vector 但是我卻卡關QQ，可惡腦袋不給力呀！之後就用 Linked-List 解決掉這題，不過太久沒有寫字串題目，讀取字串的能力特別差啊讀取字串的能力特別差啊，腦袋整個完全沒想法。後來看到參考連結中的那篇優秀程式碼文章，才讓我對於讀取字串又有了更新的領悟，好讚。非常感謝作者願意將他的程式碼技術公布出來！</p>
<p>也希望我自己也能成為獨當一面的演算法程式設計師，不要甚麼都不太會，未來只能領低薪，我要努力，直到看到夢想為止之前！也希望大家可以幫助我。</p>
<p>不過指標的 Linked-List 我還是覺得寫起來很麻煩阿，常常 Debug 都找不出錯誤，好討厭。我可能之後會變成愛用 C++，但不喜歡指標的怪人吧www。<del>C++ 的優勢根本沒有發揮出來</del></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> ch ;</span><br><span class="line"><span class="built_in">string</span> strTemp = <span class="string">""</span> ;</span><br><span class="line"><span class="keyword">int</span> wcnt = <span class="number">0</span> , head = <span class="number">0</span> , num =<span class="number">0</span>   ;</span><br><span class="line"><span class="comment">//wcnt linklist 的總量</span></span><br><span class="line"><span class="comment">//head 上一個單字的 index</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu_words</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> next ;</span><br><span class="line">    <span class="built_in">string</span> word ;</span><br><span class="line">&#125;word[MAXN] ;</span><br><span class="line"><span class="comment">// next 上一個單字的 index</span></span><br><span class="line"><span class="comment">// word 此單字</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> );</span><br><span class="line">    <span class="comment">//freopen("out.txt" , "w" , stdout );</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        ch = getchar() ;</span><br><span class="line">        <span class="keyword">if</span>(ch == <span class="string">'0'</span>)</span><br><span class="line">            <span class="keyword">break</span> ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">isalpha</span>(ch))&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">isalpha</span>(ch))&#123; <span class="comment">//不斷讀取單字，直到遇到其他</span></span><br><span class="line">                strTemp += ch ;</span><br><span class="line">                ch = getchar() ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; strTemp ;</span><br><span class="line">            word[wcnt].word = strTemp ; <span class="comment">//添加新單字</span></span><br><span class="line">            word[wcnt].next = head ; <span class="comment">//上一個單字 index</span></span><br><span class="line">            head = wcnt++ ; <span class="comment">//長度增加</span></span><br><span class="line">            strTemp = <span class="string">""</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">isdigit</span>(ch))&#123; </span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch))&#123; <span class="comment">//不斷讀取數字，直到遇到其他</span></span><br><span class="line">                num = num * <span class="number">10</span> + (ch - <span class="string">'0'</span>) ;</span><br><span class="line">                ch = getchar() ;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> cur = head , prev  ; </span><br><span class="line">            <span class="comment">//cur = 數字的那個單字</span></span><br><span class="line">            <span class="comment">//prev = 數字的下一個單字</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; num ; i++)&#123; <span class="comment">// 向上追蹤單字</span></span><br><span class="line">                prev = cur ;</span><br><span class="line">                cur = word[cur].next ;</span><br><span class="line">            &#125;</span><br><span class="line">            num = <span class="number">0</span> ;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; word[cur].word ;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(head != cur )&#123; <span class="comment">// 要將當前的單字搬到後面，所以單字的上一個 index 也需要更新</span></span><br><span class="line">                word[prev].next = word[cur].next ; </span><br><span class="line">                <span class="comment">// 因為要移動當前單字所以必須要將當前單字的下一個單字的 next，往前到現在這單字的 next</span></span><br><span class="line">                word[cur].next = head ;</span><br><span class="line">                <span class="comment">// 當前的單字 next 改為現在讀取中的上一個單字</span></span><br><span class="line">                head = cur ; <span class="comment">// 現在這個單字變成結尾</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">putchar</span>(ch) ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>String Processing Problems</tag>
        <tag>Competitive Programming3</tag>
      </tags>
  </entry>
  <entry>
    <title>演算法知識 - Binary Search 二分搜尋</title>
    <url>/2020/11/15/Explain_Algorithm/binary_search/</url>
    <content><![CDATA[<h2 id="Binary-Search-介紹與應用"><a href="#Binary-Search-介紹與應用" class="headerlink" title="Binary Search 介紹與應用"></a>Binary Search 介紹與應用</h2><blockquote>
<p>Binary Search 是我們常見的搜尋方式，相對簡單但也非常使用的演算法，其使用方式需要先在一個經過排序的陣列中找出我們想找出的值。</p>
<p>時間複雜度是 \(O(\log n)\)</p>
<p>應用類型相當廣泛，在常見的資料型態中都可以見到</p>
</blockquote>
<a id="more"></a>

<h2 id="Binary-Search-原理"><a href="#Binary-Search-原理" class="headerlink" title="Binary Search 原理"></a>Binary Search 原理</h2><p>在一個有排序的陣列中，假設我們要找出的是 x，找出最中間的值，與 x 進行比較，如果比中間的值大，那我們只需要再從此陣列中區間範圍 [ Mid , Right ] 即可，為甚麼可以這樣子呢？</p>
<p>因為是經過排序的，所以表示我們只要再往右邊的那些數值再去查詢，同樣地，如果比中間的值小那我們就只需要在從 [ Left , Mid] 去找即可。</p>
<p>其中 \( mid = (Left + Right ) / 2 \)</p>
<p>舉例一下，我們要在數列中 10 20 30 40 50，找出 1，要怎麼做呢？<br>P.S. 這裡的 index 從 1 開始</p>
<h3 id="Step1-這時-Left-1-Right-5-，找出此數列的中間值-30，並跟-10-比較"><a href="#Step1-這時-Left-1-Right-5-，找出此數列的中間值-30，並跟-10-比較" class="headerlink" title="Step1 : 這時 Left = 1 , Right = 5 ，找出此數列的中間值 30，並跟 10 比較"></a>Step1 : 這時 Left = 1 , Right = 5 ，找出此數列的中間值 30，並跟 10 比較</h3><p>\( Mid = (Left + Right ) / 2 = 3 \)<br>由於 10 &lt; 30，所以我們接下來要搜尋的範圍就是 \( [left=1 , Right=3 ] \)</p>
<h3 id="Step2-這時-Left-1-Right-3-，找出此數列的中間值-20，並跟-10-比較"><a href="#Step2-這時-Left-1-Right-3-，找出此數列的中間值-20，並跟-10-比較" class="headerlink" title="Step2 : 這時 Left = 1 , Right = 3 ，找出此數列的中間值 20，並跟 10 比較"></a>Step2 : 這時 Left = 1 , Right = 3 ，找出此數列的中間值 20，並跟 10 比較</h3><p>\( Mid = (Left + Right ) / 2 = 2 \)<br>由於 10 &lt; 20，所以我們接下來要搜尋的範圍就是 \( [left=1 , Right=2 ] \)</p>
<h3 id="Step3-這時-Left-1-Right-2-，找出此數列的中間值-10，並跟-10-比較"><a href="#Step3-這時-Left-1-Right-2-，找出此數列的中間值-10，並跟-10-比較" class="headerlink" title="Step3 : 這時 Left = 1 , Right = 2 ，找出此數列的中間值 10，並跟 10 比較"></a>Step3 : 這時 Left = 1 , Right = 2 ，找出此數列的中間值 10，並跟 10 比較</h3><p>\( Mid = (Left + Right ) / 2 = 1 \)，這裡是採用 C++，C++ 在整數除法時會無條件捨去。<br>由於 10 == 10，我們就可以知道我們想找的值在此數列中的 1 號位置。</p>
<h3 id="Situation-在寫二分搜尋時一些小注意"><a href="#Situation-在寫二分搜尋時一些小注意" class="headerlink" title="Situation: 在寫二分搜尋時一些小注意"></a>Situation: 在寫二分搜尋時一些小注意</h3><p>值得提醒的是，二分搜尋法固然簡單，但常常會有一些小問題自己沒有注意到，因此如果是系統已經有內建好的函數盡量使用系統內建函數會相對輕鬆一些。<del>簡單來說就是套件保證沒有 bug，但我不敢保證自己沒有 bug</del></p>
<p>容易出現的問題：數列中有重複的值，我想要的是找出此數列中大於 or 小於此數字的值</p>
<h2 id="C-語法介紹"><a href="#C-語法介紹" class="headerlink" title="C++ 語法介紹"></a>C++ 語法介紹</h2><p>在 C++ 中已經有函數可以方便我們直接套用分別是：</p>
<ul>
<li><code>lower_bound</code> 找出此數列中第一個數值是大於等於想查詢的值</li>
<li><code>upper_bound</code> 找出此數列中最後一個數值是大於等於想查詢的值<br>詳細用法請看 <a href="http://www.cplusplus.com/reference/algorithm/lower_bound/" target="_blank" rel="noopener">C++ Refence</a> 或是 <a href="https://www.cnblogs.com/cobbliu/archive/2012/05/21/2512249.html" target="_blank" rel="noopener">STL源码学习—-lower_bound和upper_bound算法</a></li>
</ul>
<p>如果看不太懂文字說明，可以看看這張圖，我想就了解了：</p>
<p><img src="/images/Binary_Search/1.png" alt=""></p>
<h2 id="Binary-Search-實作與說明"><a href="#Binary-Search-實作與說明" class="headerlink" title="Binary Search 實作與說明"></a>Binary Search 實作與說明</h2><p>在程式碼進行說明，相信會比較好理解些。</p>
<h3 id="找出此數列中第一個數值是大於等於想查詢的值，類似於-C-的-lower-bound"><a href="#找出此數列中第一個數值是大於等於想查詢的值，類似於-C-的-lower-bound" class="headerlink" title="找出此數列中第一個數值是大於等於想查詢的值，類似於 C++ 的 lower_bound"></a>找出此數列中第一個數值是大於等於想查詢的值，類似於 C++ 的 <code>lower_bound</code></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N </span></span><br><span class="line"><span class="keyword">int</span> num[n] <span class="comment">//以排序過且要進行查詢的數列</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bs</span><span class="params">(<span class="keyword">int</span> l , <span class="keyword">int</span> r , <span class="keyword">int</span> v)</span></span>&#123; <span class="comment">//bs binary search , l =left , r= right , v = value</span></span><br><span class="line">    <span class="keyword">int</span> m ; <span class="comment">// m = mid </span></span><br><span class="line">    <span class="keyword">while</span>(r&gt;l)&#123; <span class="comment">// 假如 r &gt; 1 表示尚未二分搜尋完畢</span></span><br><span class="line">        m = (r+l) / <span class="number">2</span> ; <span class="comment">// m 找出中間值 </span></span><br><span class="line">        <span class="keyword">if</span>(num[v] &gt; num[t[m]] ) l = m+<span class="number">1</span> ; <span class="comment">//如果要查詢的值大於中間值，那範圍將被改成[M id , Right]</span></span><br><span class="line">        <span class="comment">//但因為 mid 已經有被查詢過因此 mid +1</span></span><br><span class="line">        <span class="keyword">else</span> r = m ;</span><br><span class="line">        <span class="comment">//如果沒有那範圍則被改成 [Left , Mid]，沒有做 mid -1 是因為有可能是要查詢的值與 mid 值相同</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r ; <span class="comment">//回傳被查詢到的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="找出此數列中最後一個數值是大於等於想查詢的值，類似於-C-的-upper-bound"><a href="#找出此數列中最後一個數值是大於等於想查詢的值，類似於-C-的-upper-bound" class="headerlink" title="找出此數列中最後一個數值是大於等於想查詢的值，類似於 C++ 的 upper_bound"></a>找出此數列中最後一個數值是大於等於想查詢的值，類似於 C++ 的 <code>upper_bound</code></h3><p>讀者在觀看此程式碼前，必須先將前一個程式碼熟悉。</p>
<p>稍微要記住的是，這裡的區間範圍是 \( [ left , Right) \)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N </span></span><br><span class="line"><span class="keyword">int</span> num[n] <span class="comment">//以排序過且要進行查詢的數列</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bs</span><span class="params">(<span class="keyword">int</span> l , <span class="keyword">int</span> r , <span class="keyword">int</span> v)</span></span>&#123; <span class="comment">//bs binary search , l =left , r= right , v = value</span></span><br><span class="line">    <span class="keyword">int</span> m ;  <span class="comment">// m = mid </span></span><br><span class="line">    <span class="keyword">while</span>(r &gt; l)&#123; <span class="comment">// 假如 r &gt; 1 表示尚未二分搜尋完畢</span></span><br><span class="line">        m = (l+r) / <span class="number">2</span> ; <span class="comment">// m 找出中間值 </span></span><br><span class="line">        <span class="keyword">if</span>(num[m] &lt;= v) l = ++m; <span class="comment">//與上份程式碼章節相同</span></span><br><span class="line">        <span class="comment">//值得注意的是，因為區間範圍是 [ Mid , Right )，我們要防範 Right = mid 時，</span></span><br><span class="line">        <span class="comment">//會造成錯亂，於是我們先幫 mid+1，之後再減回來</span></span><br><span class="line">        <span class="keyword">else</span> r = m; <span class="comment">//與上份程式碼章節相同 </span></span><br><span class="line">        <span class="comment">//值得注意的是，因為區間範圍是 [ Left , Mid )，但因為 C++ 在計算 mid 時小數會捨取，</span></span><br><span class="line">        <span class="comment">//因此如果我們只要讓 else 只處理 中間值 &gt; 查詢值，就不會造成錯亂</span></span><br><span class="line">        <span class="comment">//我們在下方將會進行舉例，代號為 Q-A</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m<span class="number">-1</span> ; <span class="comment">//為甚麼要 m-1？</span></span><br><span class="line">    <span class="comment">//因為</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Q-A"><a href="#Q-A" class="headerlink" title="Q-A"></a>Q-A</h4><p>舉例：<br>L = 1 , R = 2 , M = 1 ，進入 if statement ， L = 2 , M = 2，此時區間是向 R 靠近，但 R 是 <strong>)</strong> 會超出查詢範圍，因此必須要 -1。<br>L = 1 , R = 2 , M = 1 ，進入 else statement ， R = 1 , M = 1，此時區間是向 L 靠近，L 本身範圍是 <strong>[</strong>，因此沒有問題。</p>
<p>主要就是這個樣子，希望讀者都能看懂XD。</p>
<h3 id="未來如果我還有寫更多版本，我將會放上"><a href="#未來如果我還有寫更多版本，我將會放上" class="headerlink" title="未來如果我還有寫更多版本，我將會放上"></a>未來如果我還有寫更多版本，我將會放上</h3><h2 id="Binary-Search-應用"><a href="#Binary-Search-應用" class="headerlink" title="Binary Search 應用"></a>Binary Search 應用</h2><ul>
<li><a href="https://theriseofdavid.github.io/2020/11/15/UVa/UVa957/" target="_blank" rel="noopener">UVa957 - Popes (Binary Search)</a></li>
</ul>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://www.cnblogs.com/cobbliu/archive/2012/05/21/2512249.html" target="_blank" rel="noopener">STL源码学习—-lower_bound和upper_bound算法</a><br><a href="http://www.cplusplus.com/reference/algorithm/lower_bound/" target="_blank" rel="noopener">std::lower_bound</a><br><a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%88%86%E6%90%9C%E5%B0%8B%E6%BC%94%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">二分搜尋演算法</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>二分搜尋好多毛病要解決，真麻煩，好想用套件XD，其實此演算法在我高中時就已經學會了，為甚麼會想打這一篇呢？主要是因為想要幫自己的演算法建立模板，方便未來的我用上，也害怕假如未來的我以後忘記怎麼寫時就在也真的想不起來了，因為找不到<strong>過去</strong>讓我參考，希望未來的我還能記住，也希望看到此篇的讀者不會忘記。</p>
<p>寫 Blog 真的非常吃力不討好，真的好累又好麻煩，學習速度比別人慢，別人可以在你打 Blog 的時間學習更多演算法、更多知識，那你為甚麼還要打呢？因為我笨，我學習差，我需要讓瞭解演算法的自己來幫助未來可能會遺忘此演算法的自己，幫助他，讓我的未來不遺失我的過去。</p>
<h2 id="Binary-Search-無助解程式碼"><a href="#Binary-Search-無助解程式碼" class="headerlink" title="Binary Search 無助解程式碼"></a>Binary Search 無助解程式碼</h2><p>這裡則放置沒有註解的程式碼，如果讀者想要複製就從這裡進行複製吧！</p>
<h3 id="找出此數列中第一個數值是大於等於想查詢的值，類似於-C-的-lower-bound-1"><a href="#找出此數列中第一個數值是大於等於想查詢的值，類似於-C-的-lower-bound-1" class="headerlink" title="找出此數列中第一個數值是大於等於想查詢的值，類似於 C++ 的 lower_bound"></a>找出此數列中第一個數值是大於等於想查詢的值，類似於 C++ 的 <code>lower_bound</code></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N </span></span><br><span class="line"><span class="keyword">int</span> num[n] </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bs</span><span class="params">(<span class="keyword">int</span> l , <span class="keyword">int</span> r , <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m ;</span><br><span class="line">    <span class="keyword">while</span>(r&gt;l)&#123;</span><br><span class="line">        m = (r+l) / <span class="number">2</span> ;</span><br><span class="line">        <span class="keyword">if</span>(b[v] &gt; b[t[m]] ) l = m+<span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">else</span> r = m ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="找出此數列中最後一個數值是大於等於想查詢的值，類似於-C-的-upper-bound-1"><a href="#找出此數列中最後一個數值是大於等於想查詢的值，類似於-C-的-upper-bound-1" class="headerlink" title="找出此數列中最後一個數值是大於等於想查詢的值，類似於 C++ 的 upper_bound"></a>找出此數列中最後一個數值是大於等於想查詢的值，類似於 C++ 的 <code>upper_bound</code></h3><p>讀者在觀看此程式碼前，必須先將前一個程式碼熟悉。</p>
<p>稍微要記住的是，這裡的區間範圍是 \( [ left , Right) \)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N </span></span><br><span class="line"><span class="keyword">int</span> num[n] </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bs</span><span class="params">(<span class="keyword">int</span> l , <span class="keyword">int</span> r , <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m ;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">        <span class="comment">//debug</span></span><br><span class="line">        <span class="comment">//cout &lt;&lt; num[l] &lt;&lt; ' ' &lt;&lt; num[r] &lt;&lt; '\n' ;</span></span><br><span class="line">        m = (l+r) / <span class="number">2</span> ;</span><br><span class="line">        <span class="keyword">if</span>(num[m] &lt;= v) l = ++m;</span><br><span class="line">        <span class="keyword">else</span> r = m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m<span class="number">-1</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>演算法知識</category>
      </categories>
      <tags>
        <tag>程式解題</tag>
        <tag>演算法知識</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa957 - Popes (Binary Search)</title>
    <url>/2020/11/15/UVa/UVa957/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>我們有過去歷史教皇選舉的資料，現在我們需要知道在 x 年期間中的教皇選舉最多次，並告訴我們期間開始選舉的教皇與期間最後選舉教皇</p>
<p>我們會給定<strong>已經排序</strong>好的選舉日期，就請寫出程式找出答案吧！</p>
</blockquote>
<a id="more"></a>

<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>這題可以用兩種方式去解，一種是最長區間覆蓋長，屬於動態規劃，另一種是 Binary Search，這裡我們使用 Binary Search 去 AC 此題。</p>
<p>如果還不太懂 LIS 是甚麼問題，建議看看 <a href="https://theriseofdavid.github.io/2020/11/15/Explain_Algorithm/binary_search/" target="_blank" rel="noopener">演算法知識 - Binary Search 二分搜尋</a>，這裡有對於此演算法有完整的介紹 </p>
<h2 id="焦點回到題目上，解開題目的小設計"><a href="#焦點回到題目上，解開題目的小設計" class="headerlink" title="焦點回到題目上，解開題目的小設計"></a>焦點回到題目上，解開題目的小設計</h2><p>這題總共需要求出 3 個答案，第一是期間內的最多選舉次數，再來是期間內的第一次選舉與最後一次選舉。</p>
<p>我們透過題目的公式 \( N+Y-1 \)，其中 N 等於 \(一開始可查詢選舉年份 + Y 期間 - 1 = 符合題目條件的最終可查詢選舉年份 \)，我們只需要對每一個選舉年份 + Y - 1，就可以找出每個期間的選舉次數，並記錄最大的選舉次數與一開始可選舉日期以及 Binary Search 找到的最後大於等於最終可查詢的選舉年份即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">last = bs(i,p,num[i]+y<span class="number">-1</span>) ; <span class="comment">//bs binary Search，以下簡稱 bs</span></span><br><span class="line"><span class="comment">// num[i]+y-1 表示最終可查詢年份 , last = 透過 bs 找出在此數列中的大於等於最終可查詢年份之選舉年份位置</span></span><br><span class="line">first = i ; <span class="comment">// first = 一開始可查詢選舉年份在此數列中的位置</span></span><br><span class="line">large = last - first +<span class="number">1</span> ; <span class="comment">// large = 最終可查詢年份 - 最初可查詢年份 + 1，表示裡面有多少選舉</span></span><br></pre></td></tr></table></figure>

<p>透過迴圈針對每一次的選舉進行查詢，並記錄最大即可。</p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>老話一句，英文很重要QQ，我到底因為英文不好吃了幾次虧啦…。</p>
<p>我看了很久QQ，查了好多英文單字，我竟然連 Popes 都不知道是甚麼QQ，我還需要好好磨練、好好讓自己的英文能力進步啦，英文真的好重要好重要，可是我每次只要回到家都沒有再讀英文…，我也太沒用了八。</p>
<p>好啦，題外話講多了，其實我在寫這一題時，我發現這題其實沒有很難寫，但是卡在解決二分搜尋的一些小毛病，例如要大於等於…之類的，最近在增強自己沒有透過紙筆也能夠進行表達以及程式思考的方式，加強我自己對於一些簡單判斷的基礎能力，如果可以將簡單判斷減少依賴，或許我在表達時就可以表達的流暢些，我常常在口述表達自己時長不完善，但只要透過文字我就可以很能夠表達我自己，因為文字我可以做 Review，但口述卻沒辦法。</p>
<p>之後也要好好努力，成為一位不愧對過去自己的人。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>其實就是沒有附上說明的程式碼，看得懂跟說得出來真的是兩回事，也許還有人覺得我說的很差，不過我已經盡力解釋。希望可以幫助到各位。</p>
<p>也希望大家想要學習的知識都可以快速學習而成，不要因為自身的環境不足而學習不到。</p>
<p>於是這裡就補述一些題目給的資料範圍限制與標頭檔了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 1000010</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> y , p , temp , num[MAX] ;</span><br><span class="line"><span class="keyword">int</span> max_large , max_first , max_last ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bs</span><span class="params">(<span class="keyword">int</span> l , <span class="keyword">int</span> r , <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m ;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">        <span class="comment">//debug</span></span><br><span class="line">        <span class="comment">//cout &lt;&lt; num[l] &lt;&lt; ' ' &lt;&lt; num[r] &lt;&lt; '\n' ;</span></span><br><span class="line">        m = (l+r) / <span class="number">2</span> ;</span><br><span class="line">        <span class="keyword">if</span>(num[m] &lt;= v) l = ++m;</span><br><span class="line">        <span class="keyword">else</span> r = m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m<span class="number">-1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> );</span><br><span class="line">    <span class="comment">//freopen("out.txt" , "w" , stdout);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">int</span> large , first , last ;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; y)&#123;</span><br><span class="line">        max_large = max_first = max_last = <span class="number">0</span> ;</span><br><span class="line">        large = first = last = <span class="number">0</span> ;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; p ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; p ; i++) <span class="built_in">cin</span> &gt;&gt; num[i] ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; p ; i++)&#123;</span><br><span class="line">            last = bs(i,p,num[i]+y<span class="number">-1</span>) ;</span><br><span class="line">            first = i ;</span><br><span class="line">            large = last - first +<span class="number">1</span> ;</span><br><span class="line">            <span class="comment">//debug</span></span><br><span class="line">            <span class="comment">//cout &lt;&lt; "i = " &lt;&lt; i &lt;&lt; " binary search range " &lt;&lt; num[first] &lt;&lt; "-" &lt;&lt; num[last] &lt;&lt; " result is " &lt;&lt; large &lt;&lt; '\n' ;</span></span><br><span class="line">            <span class="keyword">if</span>(large &gt;  max_large)&#123;</span><br><span class="line">                max_large = large ;</span><br><span class="line">                max_first = first ;</span><br><span class="line">                max_last = last ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; max_large &lt;&lt; <span class="string">" "</span> &lt;&lt; num[max_first] &lt;&lt; <span class="string">" "</span> &lt;&lt; num[max_last] &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>演算法知識</tag>
      </tags>
  </entry>
  <entry>
    <title>Rselenium 一些應用與教學</title>
    <url>/2020/11/15/R/R-Rselenium/</url>
    <content><![CDATA[<h2 id="內容說明"><a href="#內容說明" class="headerlink" title="內容說明"></a>內容說明</h2><blockquote>
<p>主要是透過 Rselenium 來模擬人類打開網頁並對其進行操作，以下是一些 Rselenium 下載的教學步驟</p>
</blockquote>
<a id="more"></a>

<h2 id="安裝-Rselenium"><a href="#安裝-Rselenium" class="headerlink" title="安裝 Rselenium"></a>安裝 Rselenium</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">install.packages(<span class="string">"RSelenium"</span>)</span><br></pre></td></tr></table></figure>

<h2 id="安裝-WebDriver"><a href="#安裝-WebDriver" class="headerlink" title="安裝 WebDriver"></a>安裝 WebDriver</h2><h3 id="Step-1"><a href="#Step-1" class="headerlink" title="Step 1:"></a>Step 1:</h3><p>由於我們安裝好 Selenium 後，Selenium 是程式語言與 browser 溝通的關鍵，於是我們還需要安裝一個機器人專用的<strong>瀏覽器</strong>來給他進行操控，目前支持機器人操控瀏覽器的有 Google Chrome and Firefox</p>
<p>首先先去<a href="https://www.selenium.dev/downloads/" target="_blank" rel="noopener">這裡</a>，找到目前最新的 Selenium Server 版本，作者在寫此文章時是這個版本。</p>
<p><strong>如果電腦沒有 java 必須先去下載 java 才能安裝成功，建議可以將命令先 cd 至爬蟲資料夾</strong></p>
<p><img src="/images/R-Rselenium/1.PNG" alt=""></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta"># java -jar selenium-server-standalone-X.XXX.XX.jar</span></span><br></pre></td></tr></table></figure>

<h3 id="Step-2"><a href="#Step-2" class="headerlink" title="Step 2:"></a>Step 2:</h3><p>下一步則是我們要將 Google Chrome 專用的瀏覽器進行下載，先在 R console 中輸入</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">binman::list_versions(<span class="string">"chromedriver"</span>)</span><br></pre></td></tr></table></figure>

<p>應該要能夠出現，以下的感覺</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="string">"85.0.4183.87"</span> <span class="string">"86.0.4240.22"</span> <span class="string">"87.0.4280.20"</span></span><br></pre></td></tr></table></figure>

<p>接著去<a href="https://chromedriver.chromium.org/downloads" target="_blank" rel="noopener">此網站</a>，下載最適合的版本，並放入你寫程式的資料夾內，建議放入與上述 <code>selenium-server-standalone-X.XXX.XX.jar</code>相同位置</p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://blog.gtwang.org/r/rselenium-r-selenium-browser-web-scraping-tutorial/" target="_blank" rel="noopener">RSelenium：R 使用 Selenium 操控瀏覽器下載網頁資料</a><br><a href="https://www.selenium.dev/downloads/" target="_blank" rel="noopener">Selenium</a><br><a href="https://mran.microsoft.com/snapshot/2017-12-11/web/packages/RSelenium/vignettes/RSelenium-basics.html" target="_blank" rel="noopener">RSelenium: Basics</a><br><a href="https://stackoverflow.com/questions/56857745/chromedriver-vs-chrome-update-incompatibility" target="_blank" rel="noopener">Chromedriver vs. Chrome update incompatibility</a></p>
]]></content>
      <categories>
        <category>R語言</category>
      </categories>
      <tags>
        <tag>R語言</tag>
        <tag>學習筆記</tag>
        <tag>網路爬蟲</tag>
      </tags>
  </entry>
  <entry>
    <title>QUESTION! 在 R 語言中數字後面有 L 是甚麼意思呢？</title>
    <url>/2020/11/15/R/R-L_meaning/</url>
    <content><![CDATA[<h2 id="內容說明："><a href="#內容說明：" class="headerlink" title="內容說明："></a>內容說明：</h2><blockquote>
<p>在 R 語言中數字後面有 L 是甚麼意思呢？<br>例如： 1233L 是甚麼意思？</p>
</blockquote>
<a id="more"></a>

<h2 id="Answer-表示長整數"><a href="#Answer-表示長整數" class="headerlink" title="Answer: 表示長整數"></a>Answer: 表示長整數</h2><p>如果有再寫 C++ 的人可以知道，在 C++ 中有一個資料型態叫做 <code>int</code>，可以表達數字在 \(\pm 2^{31}-1\)，在 R 語言中數字後面加上 L 也是此意思。</p>
<p>主要是因為 R 語言中數值型態有分，數值(numeric) or 整數 (integer)，因此才需要再有一些些麻煩的設定。</p>
<h2 id="參考連結："><a href="#參考連結：" class="headerlink" title="參考連結："></a>參考連結：</h2><p><a href="https://bookdown.org/tonykuoyj/eloquentr/variable-types.html" target="_blank" rel="noopener">8 精簡的變數型別</a></p>
]]></content>
      <categories>
        <category>R語言</category>
      </categories>
      <tags>
        <tag>R語言</tag>
        <tag>學習筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>統計學(一) 筆記 - 第六章 均勻機率分配(Continuous Probability Distributions)</title>
    <url>/2020/11/23/NTUT_note/statistics-ch6/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊與財金管理系大二上統計學重點整理<br><font color="#dd0000">並非所有人都適用，部分對我而言稍加容易的內容並不會寫在此內。</font><br><strong>這是觀看影片心得後的筆記，老師上課可能不太適用會忘記抄到</strong></p>
</blockquote>
<a id="more"></a>
<h1 id="Continuous-Probability-Distributions"><a href="#Continuous-Probability-Distributions" class="headerlink" title="Continuous Probability Distributions"></a>Continuous Probability Distributions</h1><p>給定一個區間，在此發生的機率是多少，下圖則是透過圖片介紹：</p>
<blockquote>
<p><img src="/images/statistics-ch6/1.PNG" alt=""></p>
</blockquote>
<h3 id="Continuous-Random-Variable"><a href="#Continuous-Random-Variable" class="headerlink" title="Continuous Random Variable"></a>Continuous Random Variable</h3><p>公式如下：</p>
<blockquote>
<p><img src="/images/statistics-ch6/2.PNG" alt=""></p>
</blockquote>
<h2 id="Uniform-Probability-Distribution-均勻機率分配"><a href="#Uniform-Probability-Distribution-均勻機率分配" class="headerlink" title="Uniform Probability Distribution (均勻機率分配)"></a>Uniform Probability Distribution (均勻機率分配)</h2><p>公式如下：</p>
<blockquote>
<p><img src="/images/statistics-ch6/3.PNG" alt=""><br><img src="/images/statistics-ch6/4.PNG" alt=""></p>
</blockquote>
<h3 id="Area"><a href="#Area" class="headerlink" title="Area"></a>Area</h3><p>我們再算均勻機率分配時要注意，如果不是區間的時機率值都是 0，因為沒有面積 </p>
<h2 id="Normal-Probability-Distribution-常態機率分配"><a href="#Normal-Probability-Distribution-常態機率分配" class="headerlink" title="Normal Probability Distribution (常態機率分配)"></a>Normal Probability Distribution (常態機率分配)</h2><p>最重要的一種機率分配之一，舉例可以用在身高、考試成績。</p>
<h3 id="Normal-Probability-Density-Function"><a href="#Normal-Probability-Density-Function" class="headerlink" title="Normal Probability Density Function"></a>Normal Probability Density Function</h3><p>公式如下：</p>
<blockquote>
<p><img src="/images/statistics-ch6/5.PNG" alt=""></p>
</blockquote>
<h3 id="Characterustucs-特點"><a href="#Characterustucs-特點" class="headerlink" title="Characterustucs (特點)"></a>Characterustucs (特點)</h3><ul>
<li>從中間切開後，左右機率各 0.5</li>
<li>68.26% 會落在正負一個標準差</li>
<li>95.44% 會落在正負兩個標準差 </li>
<li>99.72% 或落在正負三個標準差<h3 id="Standard-Normal-Probability-Distribution-標準常態隨機變數"><a href="#Standard-Normal-Probability-Distribution-標準常態隨機變數" class="headerlink" title="Standard Normal Probability Distribution (標準常態隨機變數)"></a>Standard Normal Probability Distribution (標準常態隨機變數)</h3>當平均數等於 0、標準差等於 1 時才符合條件，此時 z 表示標準常態隨機分配。</li>
</ul>
<p>公式如下：</p>
<blockquote>
<p><img src="/images/statistics-ch6/6.PNG" alt=""></p>
</blockquote>
<h2 id="Normal-Approximation-of-Binomial-Probabilities-二項機率的常態分配近似值"><a href="#Normal-Approximation-of-Binomial-Probabilities-二項機率的常態分配近似值" class="headerlink" title="Normal Approximation of Binomial Probabilities (二項機率的常態分配近似值)"></a>Normal Approximation of Binomial Probabilities (二項機率的常態分配近似值)</h2><p>其實本身是<strong>離散時機率分配</strong>，但在實驗次數增加後，要計算相對不容易就可以使用二項機率的常態分配近似值，條件如下：</p>
<ul>
<li>\(成功機率(n) * 實驗次數(p) \geq 5  \) </li>
<li>\(實驗次數(n) * (1-成功機率(p)) \geq 5 \)</li>
<li>因為二項機率通常是找某一個特定值，但是 ormal Approximation of Binomial Probabilities 則是區間，於是就盡量用，與此 \( (特定值 + 特定值前一個元素) / 2 \) and \( (特定值 + 特定值後一個元素) / 2 \)，設定為區間即可。</li>
</ul>
<p>公式如下：</p>
<blockquote>
<p><img src="/images/statistics-ch6/7.PNG" alt=""></p>
</blockquote>
<h2 id="Expeonential-Probability-Distribution-指數機率分配"><a href="#Expeonential-Probability-Distribution-指數機率分配" class="headerlink" title="Expeonential Probability Distribution (指數機率分配)"></a>Expeonential Probability Distribution (指數機率分配)</h2><p>獨立隨機事件發生的時間間隔，舉例：完成一個實驗的時間之類等。</p>
<p>公式如下:</p>
<blockquote>
<p><img src="/images/statistics-ch6/8.PNG" alt=""></p>
</blockquote>
<h3 id="Relationship-between-the-Poisson-and-Exponential-Distributions-指數機率分配與卜瓦松的關係"><a href="#Relationship-between-the-Poisson-and-Exponential-Distributions-指數機率分配與卜瓦松的關係" class="headerlink" title="Relationship between the Poisson and Exponential Distributions (指數機率分配與卜瓦松的關係)"></a>Relationship between the Poisson and Exponential Distributions (指數機率分配與卜瓦松的關係)</h3><ul>
<li>兩個方法的 x 互為<strong>倒數關係</strong><blockquote>
<p><img src="/images/statistics-ch6/9.PNG" alt=""></p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>北科上課筆記</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>統計學筆記</tag>
        <tag>北科大二上統計學筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 比較時間先後</title>
    <url>/2020/11/24/Python/Python_compare_time/</url>
    <content><![CDATA[<h2 id="內容說明"><a href="#內容說明" class="headerlink" title="內容說明"></a>內容說明</h2><blockquote>
<p>有時候在寫程式的時候，需要比較兩個時間的先來後到，那我們應該要怎麼比較呢？</p>
</blockquote>
<a id="more"></a>

<h2 id="最簡單的比較方式"><a href="#最簡單的比較方式" class="headerlink" title="最簡單的比較方式"></a>最簡單的比較方式</h2><p>在擁有著大量套件的 Python 中，如果要比較時間大小不一定需要使用到數學XD，Python 可以用一個語法 <code>time.strftime</code> 透過<strong>日期格式</strong>轉換成數字，就變成了單純的比數字大小遊戲XD。</p>
<h3 id="比較沒有紀錄天數的時間點"><a href="#比較沒有紀錄天數的時間點" class="headerlink" title="比較沒有紀錄天數的時間點"></a>比較沒有紀錄天數的時間點</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">int(time.strftime(<span class="string">"%H%M%S"</span>))</span><br><span class="line"></span><br><span class="line">int(time.strftime(<span class="string">"%H%M%S"</span>,<span class="string">"09:12:22"</span>)) = <span class="number">091222</span></span><br></pre></td></tr></table></figure>

<h3 id="比較日期"><a href="#比較日期" class="headerlink" title="比較日期"></a>比較日期</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">int(time.strftime(<span class="string">"%Y-%m-%d"</span>))</span><br><span class="line"></span><br><span class="line">int(time.strftime(<span class="string">"%Y-%m-%d"</span>,<span class="string">"2020-11-24"</span>)) = <span class="number">20201124</span></span><br></pre></td></tr></table></figure>

<p>注意:不需要擔心數字會不會超過 int or long long 的長度，因為 Python 的數字內建支援大數運算XD。</p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://blog.csdn.net/junbujianwpl/article/details/60984757" target="_blank" rel="noopener">Python比较2个时间的大小</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>Python 好簡單，可以把一些比較麻煩的事情都解決掉，設計出 Python 的人是天才八，好感謝這個世界有這麼多人無私的奉獻才有辦法讓我自學努力到現在。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 有沒有 do...until 迴圈</title>
    <url>/2020/11/24/Python/Python_do_until/</url>
    <content><![CDATA[<h2 id="內容說明"><a href="#內容說明" class="headerlink" title="內容說明"></a>內容說明</h2><blockquote>
<p>Python 有沒有 do…until 迴圈來幫助我們寫呢？</p>
</blockquote>
<a id="more"></a>

<h2 id="答案是…沒有！"><a href="#答案是…沒有！" class="headerlink" title="答案是…沒有！"></a>答案是…沒有！</h2><p>很意外八！但還是有解決方案的，不然我就不會寫一篇了對吧！</p>
<p>寫法主要如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    do_something()</span><br><span class="line">    <span class="keyword">if</span> condition():</span><br><span class="line">       <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<p>透過在最後用一個 if 進行判斷，來模擬成 do..until 迴圈。</p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://stackoverflow.com/questions/1662161/is-there-a-do-until-in-python" target="_blank" rel="noopener">Is there a “do … until” in Python? [duplicate]</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>雖然是有點麻煩的事情，不過其實還算是可以接受啦，有沒有改進其實都還可以，沒有問題的XD。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 操控 Excel 利用 openpyxl 套件</title>
    <url>/2020/11/24/Python/Python_openpyxl/</url>
    <content><![CDATA[<h2 id="內容說明"><a href="#內容說明" class="headerlink" title="內容說明"></a>內容說明</h2><blockquote>
<p>說明大衛在 Python openpyxl 套件學習的路上，有用到的語法紀錄</p>
</blockquote>
<a id="more"></a>

<h2 id="安裝套件"><a href="#安裝套件" class="headerlink" title="安裝套件"></a>安裝套件</h2><p>如果你跟我用的一樣，都是用 Spyder 此軟體來寫程式的話，只需要去旁邊的 Console 打下方指令即可。</p>
<p>如果不是，那就在 terminal 中打此指令也是可以的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install openpyxl</span><br></pre></td></tr></table></figure>

<h2 id="在程式中匯入套件"><a href="#在程式中匯入套件" class="headerlink" title="在程式中匯入套件"></a>在程式中匯入套件</h2><p>沒有匯入的話，這份程式碼是沒辦法使用此套件的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> openpyxl</span><br></pre></td></tr></table></figure>

<h2 id="Python-Openpyxl-的一些用法"><a href="#Python-Openpyxl-的一些用法" class="headerlink" title="Python Openpyxl 的一些用法"></a>Python Openpyxl 的一些用法</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> openpyxl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立一個 Excel </span></span><br><span class="line">workbook = openpyxl.Workbook()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 焦點放在第一張工作表</span></span><br><span class="line">sheet = workbook.worksheets[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一張工作表 A1 儲存格設定值為 "Hello David and Openpyxl."</span></span><br><span class="line">sheet[<span class="string">"A1"</span>] = <span class="string">"Hello David and Openpyxl."</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 將 text 設定成第一張工作表 A1 儲存格</span></span><br><span class="line">text = sheet[<span class="string">"A1"</span>].value</span><br><span class="line"></span><br><span class="line"><span class="comment"># row 最大數量</span></span><br><span class="line">print(sheet.max_row)</span><br><span class="line"></span><br><span class="line"><span class="comment"># column 最大數量</span></span><br><span class="line">print(sheet.max_column)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 儲存檔案</span></span><br><span class="line">workbook.save(<span class="string">'test.xlsx'</span>)</span><br></pre></td></tr></table></figure>

<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://ithelp.ithome.com.tw/articles/10246377" target="_blank" rel="noopener">[2020鐵人賽Day16]糊裡糊塗Python就上手-Python Excel 操縱套餐(使用openpyxl)</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>Python 操作 Excel 比起 C++ 真的是優秀太多了，很不賴欸，怪不得會有那麼多人喜歡寫 Python，如果是要寫應用，我自己也會越來越喜歡寫 Python XD，不過可能要注意一下還是要懂那些內涵，不然就像是一個會用的麻瓜。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 一個 function 回傳兩個值</title>
    <url>/2020/11/24/Python/Python_return_two_value_from_a_function/</url>
    <content><![CDATA[<h2 id="內容說明"><a href="#內容說明" class="headerlink" title="內容說明"></a>內容說明</h2><blockquote>
<p>在寫程式的時候，偶爾會需要一個 function 回傳兩個值，但你卻很懶惰的不想用一個 list 裝，此時又想到 C++ 有 pair 可以用，那 Python 有沒有呢？</p>
</blockquote>
<h2 id="答案是…沒有！"><a href="#答案是…沒有！" class="headerlink" title="答案是…沒有！"></a>答案是…沒有！</h2><p>但有兩種解決方案，如果你非常需要用到 pair 這資料結構時，那就直接自己寫一個 class 來定義吧！或是將兩個變數丟給 function，之後再回傳兩個 value。</p>
<h3 id="解決方案-寫一個-Class"><a href="#解決方案-寫一個-Class" class="headerlink" title="解決方案 - 寫一個 Class"></a>解決方案 - 寫一個 Class</h3><p>就…手寫阿XD，之後宣告一個 pair 即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">pair</span><span class="params">()</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,key,value)</span>:</span></span><br><span class="line">    self.key = key </span><br><span class="line">    self.value = value</span><br></pre></td></tr></table></figure>

<h3 id="解決方案-function-return-two-value"><a href="#解決方案-function-return-two-value" class="headerlink" title="解決方案 - function return two value"></a>解決方案 - function return two value</h3><p>透過 function 回傳兩個值來解決此問題。</p>
<p>觀看下方 function 可以了解到，<code>thing function</code>回傳了兩個值 a,b，並將 a 給予 c、b 給予 d。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">thing</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> a , b </span><br><span class="line"></span><br><span class="line">c , d = thing()</span><br></pre></td></tr></table></figure>

<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://stackoverflow.com/questions/9752958/how-can-i-return-two-values-from-a-function-in-python" target="_blank" rel="noopener">How can I return two values from a function in Python?</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>Python 好簡單，可以把一些比較麻煩的事情都解決掉，設計出 Python 的人是天才八，好感謝這個世界有這麼多人無私的奉獻才有辦法讓我自學努力到現在。</p>
<p>我想應該是有人有寫出這種類似 C++ pair 的套件，不過我不確定就是了。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 切割字串</title>
    <url>/2020/11/24/Python/Python_split/</url>
    <content><![CDATA[<h2 id="內容說明"><a href="#內容說明" class="headerlink" title="內容說明"></a>內容說明</h2><blockquote>
<p>通常在寫程式時都會需要用到字串切割，那 Python 的字串切割要怎麼做呢？</p>
</blockquote>
<a id="more"></a>

<h2 id="Python-String-split-切割字串函數"><a href="#Python-String-split-切割字串函數" class="headerlink" title="Python String.split 切割字串函數"></a>Python String.split 切割字串函數</h2><p>只要在 <code>string.split()</code> 就可以切割函數</p>
<p>通常會用到的有這幾種，如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">str = <span class="string">"this is David and ...!!"</span></span><br><span class="line">print(str.split()) # 用空格來切割</span><br><span class="line">print(str.split(<span class="string">"i"</span>,<span class="number">1</span>)) # 以 i 來切割，但只切割第一次</span><br><span class="line">print(str.split(<span class="string">"a"</span>)) # 以 a 來切割，但不斷切割，直到字串結尾</span><br></pre></td></tr></table></figure>

<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://www.runoob.com/python3/python3-string-split.html" target="_blank" rel="noopener">Python3 split()方法</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>Python 好簡單，可以把一些比較麻煩的事情都解決掉，設計出 Python 的人是天才八，好感謝這個世界有這麼多人無私的奉獻才有辦法讓我自學努力到現在。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 使用 threading 套件來讓多執行緒來加速運算速度</title>
    <url>/2020/11/25/Python/Python_threading/</url>
    <content><![CDATA[<h2 id="內容說明"><a href="#內容說明" class="headerlink" title="內容說明"></a>內容說明</h2><blockquote>
<p>有的時候會需要用到多執行緒來讓整個程式加速運算，在現代電腦中擁有多核心 CPU 以是常態，但通常一份程式碼都是使用單核心來操控，如果我們讓他多核心操控就可以擁有更快速度啦！</p>
<p>一種自己程式碼寫不好就幫硬體升級的概念XD。</p>
</blockquote>
<a id="more"></a>

<h2 id="一些說明："><a href="#一些說明：" class="headerlink" title="一些說明："></a>一些說明：</h2><ul>
<li>在使用 threading 套件時，不可以將 list 傳給多個 threading<br>舉例： A threading 移除 list index 0 的值，B 則呼叫 list index 0 的值，此時會產生錯誤，原因是因為 B threading 還認為 list index 0 的 memory 還在那位置，但卻發現不再、被移除。</li>
<li><em>因此我們無法保證 List 在多執行緒時能被正常使用。*</em></li>
<li>在多執行緒需要同時用到一個陣列時，建議使用 deque(內建)，<code>import queue</code><br>Python 有保證 queue 在 threading 時絕對安全，因此個人建議盡量使用他。</li>
</ul>
<h2 id="安裝套件"><a href="#安裝套件" class="headerlink" title="安裝套件"></a>安裝套件</h2><p>沒有！他是內建的，完全不需要安裝喔，讚啦。</p>
<h2 id="在程式中匯入套件"><a href="#在程式中匯入套件" class="headerlink" title="在程式中匯入套件"></a>在程式中匯入套件</h2><p>還是要的，這是必備。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br></pre></td></tr></table></figure>

<h2 id="建立子執行緒的例子"><a href="#建立子執行緒的例子" class="headerlink" title="建立子執行緒的例子"></a>建立子執行緒的例子</h2><p>要稍微注意一下：<code>threading.Thread(target= function,args= (A,B))</code> ，這裡的 <code>function</code> <strong>不可以加括號</strong>，因為這裡是找他記憶體位置，但如果你想要執行的 function 有參數要傳進去則要在後面加入 <code>args= (A,B)</code>，並記住，<strong>他一定要是一個 list or tuple</strong>，不可以只是一個 int or string..，一定是要一個陣列。</p>
<p>如果要問我為甚麼？我只知道這是寫套建時的規則，我也沒辦法說出一個很好的大概。</p>
<p>如果需要不斷的讓這些執行緒工作，這裡有一個不錯的寫法，建議看看：<br><a href="https://theriseofdavid.github.io/2020/11/30/Python/Python_Open_multiple_threads_and_find_idle_threads/" target="_blank" rel="noopener">Python 開多執行緒並找出空閒執行緒的方法 (使用 threading 套件)</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading <span class="comment"># 匯入套件</span></span><br><span class="line"><span class="keyword">import</span> time <span class="comment"># 匯入套件</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">job</span><span class="params">(it,nu)</span>:</span>  <span class="comment"># thread 要執行的工作內容</span></span><br><span class="line">  print(<span class="string">"thread"</span> , it , <span class="string">" is ready to work."</span>)</span><br><span class="line">  time.sleep(<span class="number">2</span>)</span><br><span class="line">  print(<span class="string">"thread"</span> , it , <span class="string">"is finished."</span>)</span><br><span class="line"></span><br><span class="line">t = [] <span class="comment"># 這是 threading 的陣列，我們用這個陣列來表示裡面的某個執行緒。</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>): <span class="comment"># 這裡我們假設給 3 個執行緒</span></span><br><span class="line">    t.append(threading.Thread(target = job , args=(i,<span class="string">""</span> )))</span><br><span class="line">    <span class="comment"># t 陣列增加一個執行緒，執行 function 為 job ， 參數為 args</span></span><br><span class="line">    t[i].start() <span class="comment"># 執行此執行緒</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>): <span class="comment"># 檢查這些執行緒有沒有都做完，才特別寫的</span></span><br><span class="line">    <span class="keyword">if</span>(t[i].isAlive()): <span class="comment">#確認這個執行緒有沒有正在被使用，如果有則是 True</span></span><br><span class="line">      t[i].join() <span class="comment">#等待這個執行緒工作完畢</span></span><br></pre></td></tr></table></figure>

<h2 id="將執行緒寫成-OOP"><a href="#將執行緒寫成-OOP" class="headerlink" title="將執行緒寫成 OOP"></a>將執行緒寫成 OOP</h2><p>作者還沒讀到，未來會看看。</p>
<h2 id="QUEUE-搭配-執行續"><a href="#QUEUE-搭配-執行續" class="headerlink" title="QUEUE 搭配 執行續"></a>QUEUE 搭配 執行續</h2><p>作者還沒讀到，未來會看看。</p>
<h2 id="防止兩個多執行緒同時寫入一個檔案-LOCK"><a href="#防止兩個多執行緒同時寫入一個檔案-LOCK" class="headerlink" title="防止兩個多執行緒同時寫入一個檔案 (LOCK)"></a>防止兩個多執行緒同時寫入一個檔案 (LOCK)</h2><p>作者還沒讀到，未來會看看。</p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://blog.gtwang.org/programming/python-threading-multithreaded-programming-tutorial/" target="_blank" rel="noopener">Python 多執行緒 threading 模組平行化程式設計教學</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>Python 好簡單，可以把一些比較麻煩的事情都解決掉，設計出 Python 的人是天才八，好感謝這個世界有這麼多人無私的奉獻才有辦法讓我自學努力到現在。</p>
<p>多執行緒真的好方便，初學者如果想要略過一些複雜的理論或實作時，用 Python 可以省去很多麻煩呢。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 使用 Pymysql 套件來在 Python 中執行資料庫 (for windows)</title>
    <url>/2020/11/30/Python/Python_Mysql_pymysql/</url>
    <content><![CDATA[<h2 id="內容說明"><a href="#內容說明" class="headerlink" title="內容說明"></a>內容說明</h2><blockquote>
<p>寫程式如果需要讀取大量資料或抓取資料時，使用資料庫是在好不過的選擇了！這裡就來說說 MySQL 應用在 Python 的教學八！</p>
<p>此文章只針對 Windows OS，沒有對 Linux 進行解說，未來有機會會寫一篇</p>
<p><a href="http://note.drx.tw/2012/12/mysql-syntax.html" target="_blank" rel="noopener">MySQL 語法連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="安裝-MySQL"><a href="#安裝-MySQL" class="headerlink" title="安裝 MySQL"></a>安裝 MySQL</h2><p>沒有資料庫，你要怎麼應用資料庫XD。</p>
<h3 id="下載-MySQL-for-windows"><a href="#下載-MySQL-for-windows" class="headerlink" title="下載 MySQL (for windows)"></a>下載 MySQL (for windows)</h3><p>這裡的下載 MySQL 以 Windows 為主，如果想要知道 Linux 的使用方法話，就去看其他文章吧！作者目前還沒遇到此問題www，相信以後就會碰到QQ。</p>
<p>從這裡 <a href="https://dev.mysql.com/downloads/installer/" target="_blank" rel="noopener">下載 MySQL</a>後，點選此下載<br><img src="/images/Python_Mysql_pymysql/1.PNG" alt=""></p>
<p>下載後，在點擊下方的 <strong>No thanks, just start my download.</strong> 後則立即下載。<br><img src="/images/Python_Mysql_pymysql/2.PNG" alt=""></p>
<ul>
<li><p>開啟安裝檔後，點 Developer Default，之後點選 Next</p>
</li>
<li><p>接下來設定 MySQL 的資料庫帳號，必須設置，<strong>無法跳過</strong></p>
</li>
<li><p>設置完成後接下來則需要登入帳密檢查</p>
</li>
<li><p>之後點擊灰色方塊即可，並輸入帳號密碼即可<br><img src="/images/Python_Mysql_pymysql/3.PNG" alt=""></p>
</li>
</ul>
<h2 id="建立-MySQL-資料庫"><a href="#建立-MySQL-資料庫" class="headerlink" title="建立 MySQL 資料庫"></a>建立 MySQL 資料庫</h2><ul>
<li><p>登入成功並進去後，點擊資料庫圖示，建立資料庫，改成自己想要的名子、並將 Charset 改成 UTF-8，並點選右下角的 Apply 建立資料庫，並一直點擊 apply、Finish 就可以建立成功。<br><img src="/images/Python_Mysql_pymysql/4.PNG" alt=""></p>
</li>
<li><p>接下來找到 Schemas 點擊<br><img src="/images/Python_Mysql_pymysql/5.PNG" alt=""></p>
</li>
<li><p>點擊 table(1)，再來點 table 右鍵為新增<strong>資料表</strong>(英文為 create table)，新增資料庫欄位(2)，完成後點擊 Apply(3)<br>注意：新增資料庫欄位(2)，Primary key 一定要對 PK、NN 打勾。<br><img src="/images/Python_Mysql_pymysql/6.PNG" alt=""></p>
<h3 id="MySQL-pk、nn、qu、b、un、zf、ai、g-的意思"><a href="#MySQL-pk、nn、qu、b、un、zf、ai、g-的意思" class="headerlink" title="MySQL pk、nn、qu、b、un、zf、ai、g 的意思"></a>MySQL pk、nn、qu、b、un、zf、ai、g 的意思</h3></li>
<li><p>PK primary key 主键</p>
</li>
<li><p>NN not null 欄位不可為空</p>
</li>
<li><p>UQ unique 唯一索引</p>
</li>
<li><p>BIN binary 二進位資料，比 text 更大的二進位資料</p>
</li>
<li><p>UN unsigned 沒有正負符號</p>
</li>
<li><p>ZF zero fill 將剩餘的位數填 0，舉例： int(4) 內容顯現為 0001</p>
</li>
<li><p>AI auto increment 自增</p>
</li>
<li><p>G generated column 生成列</p>
</li>
<li><p>\g 等同於 MySQL 中的 “;” </p>
</li>
<li><p>\G 等同於將資料轉向，舉例：縱向資料表轉變成橫向資料表</p>
</li>
</ul>
<h2 id="在-Python-操作-MySQL"><a href="#在-Python-操作-MySQL" class="headerlink" title="在 Python 操作 MySQL"></a>在 Python 操作 MySQL</h2><p>MySQL 建置完成後，透過 Python 進行操作。</p>
<h3 id="安裝套件"><a href="#安裝套件" class="headerlink" title="安裝套件"></a>安裝套件</h3><ul>
<li>在 cmd 安裝 <code>pip install pymysql</code></li>
</ul>
<h3 id="測試資料庫"><a href="#測試資料庫" class="headerlink" title="測試資料庫"></a>測試資料庫</h3><p>如果下方程式碼成功印出連線成功，就表示資料庫連線成功了！</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"></span><br><span class="line">db_settings = &#123;</span><br><span class="line">  <span class="string">"host"</span> : <span class="string">"127.0.0.1"</span>,</span><br><span class="line">  <span class="string">"port"</span> : <span class="number">3306</span>,</span><br><span class="line">  <span class="string">"user"</span> : <span class="string">"資料庫管理員帳號"</span> ,</span><br><span class="line">  <span class="string">"password"</span> : <span class="string">"資料庫管理員密碼"</span> ,</span><br><span class="line">  <span class="string">"db"</span> : <span class="string">"demo"</span> ,　<span class="comment"># 根據你的資料庫名稱</span></span><br><span class="line">  <span class="string">"charset"</span> : <span class="string">"utf8"</span>　</span><br><span class="line">&#125;</span><br><span class="line">conn = pymysql.connect(**db_settings)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 建立Connection物件</span></span><br><span class="line">    conn = pymysql.connect(**db_settings)</span><br><span class="line">    print(<span class="string">"連線成功"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> conn.cursor() <span class="keyword">as</span> cursor: </span><br><span class="line">    <span class="comment">#稍微注意一下 with statement 完成後，會自動關閉資料庫的連線操作，詳請需要 with 指令</span></span><br><span class="line">      <span class="comment">#資料表相關操作</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> ex: <span class="comment"># 出現意外時印出</span></span><br><span class="line">    print(ex)</span><br></pre></td></tr></table></figure>

<h3 id="新增資料"><a href="#新增資料" class="headerlink" title="新增資料"></a>新增資料</h3><p>檢查 MySQL Workbench 如果成功有出現一筆資料則表示成功！</p>
<p>應該會出現如下：<br><img src="/images/Python_Mysql_pymysql/7.PNG" alt=""></p>
<p>P.S. 需要點擊 MySQL 指令的閃電，才會重新執行指令呦！位置如下：<br><img src="/images/Python_Mysql_pymysql/9.PNG" alt=""></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"></span><br><span class="line">db_settings = &#123;</span><br><span class="line">  <span class="string">"host"</span> : <span class="string">"127.0.0.1"</span>,</span><br><span class="line">  <span class="string">"port"</span> : <span class="number">3306</span>,</span><br><span class="line">  <span class="string">"user"</span> : <span class="string">"資料庫管理員帳號"</span> ,</span><br><span class="line">  <span class="string">"password"</span> : <span class="string">"資料庫管理員密碼"</span> ,</span><br><span class="line">  <span class="string">"db"</span> : <span class="string">"demo"</span> ,</span><br><span class="line">  <span class="string">"charset"</span> : <span class="string">"utf8"</span></span><br><span class="line">&#125;</span><br><span class="line">conn = pymysql.connect(**db_settings)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">  <span class="keyword">with</span> conn.cursor() <span class="keyword">as</span> cursor:</span><br><span class="line">    command = <span class="string">f"INSERT INTO class(id,name) VALUES (%s,%s)"</span> </span><br><span class="line">    <span class="comment"># 需要特別注意，我們要新增的值，並不是根據資料庫的類型，而是要能夠符合 Python String 要求</span></span><br><span class="line">    <span class="comment"># 於是全部的值都設定成 %s</span></span><br><span class="line">    cursor.execute(command,(<span class="string">"1"</span>,<span class="string">"science"</span>)) <span class="comment">#後面則是我們 %s 要傳給 MySQL 的值</span></span><br><span class="line">    <span class="comment"># 記住： 一定要用小括號包住，即使是只有傳回一個值也是如此，語法規定。</span></span><br><span class="line">    print(<span class="string">"新增資料完成"</span>)</span><br><span class="line">    conn.commit() <span class="comment">#這是最重要的，如果沒有儲存變更，則 Py 會一直操作 MySQL 不會退出</span></span><br><span class="line">    <span class="comment"># 而導致 MySQL 被占用，而無法被其他程式呼叫或使用</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> ex:</span><br><span class="line">    print(ex)</span><br></pre></td></tr></table></figure>

<h3 id="查詢資料"><a href="#查詢資料" class="headerlink" title="查詢資料"></a>查詢資料</h3><p>剛剛已經新增過資料，那現在我們來測試查詢資料，我們透過 Primary key 來查詢！</p>
<p>查詢的 id = ‘1’，應該要傳回的值如下：<br><img src="/images/Python_Mysql_pymysql/8.PNG" alt=""></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"></span><br><span class="line">db_settings = &#123;</span><br><span class="line">  <span class="string">"host"</span> : <span class="string">"127.0.0.1"</span>,</span><br><span class="line">  <span class="string">"port"</span> : <span class="number">3306</span>,</span><br><span class="line">  <span class="string">"user"</span> : <span class="string">"資料庫管理員帳號"</span> ,</span><br><span class="line">  <span class="string">"password"</span> : <span class="string">"資料庫管理員密碼"</span> ,</span><br><span class="line">  <span class="string">"db"</span> : <span class="string">"demo"</span> ,</span><br><span class="line">  <span class="string">"charset"</span> : <span class="string">"utf8"</span></span><br><span class="line">&#125;</span><br><span class="line">conn = pymysql.connect(**db_settings)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">  <span class="keyword">with</span> conn.cursor() <span class="keyword">as</span> cursor:</span><br><span class="line">    command = <span class="string">f"select * from class where id = %s"</span> </span><br><span class="line">    cursor.execute(command,(<span class="string">"1"</span>)) </span><br><span class="line">    print(<span class="string">"查詢資料完成"</span>)</span><br><span class="line">    results = cursor.fetchall() <span class="comment">#傳回資料，P.S. 這裡會傳回全部的資料，並使用 tuple 包裝</span></span><br><span class="line">    print(results[<span class="number">0</span>]) <span class="comment">#傳回的那行會用 tuple 包裝</span></span><br><span class="line">    conn.commit() <span class="comment">#這是最重要的，如果沒有儲存變更，則 Py 會一直操作 MySQL 不會退出</span></span><br><span class="line">    <span class="comment"># 而導致 MySQL 被占用，而無法被其他程式呼叫或使用</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> ex:</span><br><span class="line">    print(ex)</span><br></pre></td></tr></table></figure>

<h3 id="修改資料"><a href="#修改資料" class="headerlink" title="修改資料"></a>修改資料</h3><p>剛剛也成功查詢了，現在我們來修改吧！應該要能夠出來以下的值才表示成功：<br><img src="/images/Python_Mysql_pymysql/10.PNG" alt=""></p>
<p>P.S. 記住要重新執行一次查詢指令XD</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"></span><br><span class="line">db_settings = &#123;</span><br><span class="line">  <span class="string">"host"</span> : <span class="string">"127.0.0.1"</span>,</span><br><span class="line">  <span class="string">"port"</span> : <span class="number">3306</span>,</span><br><span class="line">  <span class="string">"user"</span> : <span class="string">"root"</span> ,</span><br><span class="line">  <span class="string">"password"</span> : <span class="string">"1234"</span> ,</span><br><span class="line">  <span class="string">"db"</span> : <span class="string">"demo"</span> ,</span><br><span class="line">  <span class="string">"charset"</span> : <span class="string">"utf8"</span></span><br><span class="line">&#125;</span><br><span class="line">conn = pymysql.connect(**db_settings)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">  <span class="keyword">with</span> conn.cursor() <span class="keyword">as</span> cursor:</span><br><span class="line">    command = <span class="string">f"update class set name= %s where id = %s"</span> </span><br><span class="line">    <span class="comment"># 需要特別注意，我們要新增的值，並不是根據資料庫的類型，而是要能夠符合 Python String 要求</span></span><br><span class="line">    <span class="comment"># 於是全部的值都設定成 %s</span></span><br><span class="line">    cursor.execute(command,(<span class="string">"math"</span>,<span class="string">"1"</span>)) <span class="comment">#後面則是我們 %s 要傳給 MySQL 的值</span></span><br><span class="line">    <span class="comment"># 記住： 一定要用小括號包住，即使是只有傳回一個值也是如此，語法規定。</span></span><br><span class="line">    print(<span class="string">"修改資料完成"</span>)</span><br><span class="line">    conn.commit() <span class="comment">#這是最重要的，如果沒有儲存變更，則 Py 會一直操作 MySQL 不會退出</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> ex:</span><br><span class="line">    print(ex)</span><br></pre></td></tr></table></figure>

<h3 id="刪除資料"><a href="#刪除資料" class="headerlink" title="刪除資料"></a>刪除資料</h3><p>修改完資料後，接下來就是刪除資料拉。刪除資料後資料庫應該要為空，如下：<br><img src="/images/Python_Mysql_pymysql/11.PNG" alt=""></p>
<p>記住也要重新執行查詢指令XD。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"></span><br><span class="line">db_settings = &#123;</span><br><span class="line">  <span class="string">"host"</span> : <span class="string">"127.0.0.1"</span>,</span><br><span class="line">  <span class="string">"port"</span> : <span class="number">3306</span>,</span><br><span class="line">  <span class="string">"user"</span> : <span class="string">"root"</span> ,</span><br><span class="line">  <span class="string">"password"</span> : <span class="string">"1234"</span> ,</span><br><span class="line">  <span class="string">"db"</span> : <span class="string">"demo"</span> ,</span><br><span class="line">  <span class="string">"charset"</span> : <span class="string">"utf8"</span></span><br><span class="line">&#125;</span><br><span class="line">conn = pymysql.connect(**db_settings)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">  <span class="keyword">with</span> conn.cursor() <span class="keyword">as</span> cursor:</span><br><span class="line">    command = <span class="string">f"delete from class where id =%s"</span> </span><br><span class="line">    <span class="comment"># 需要特別注意，我們要新增的值，並不是根據資料庫的類型，而是要能夠符合 Python String 要求</span></span><br><span class="line">    <span class="comment"># 於是全部的值都設定成 %s</span></span><br><span class="line">    cursor.execute(command,(<span class="string">"1"</span>)) <span class="comment">#後面則是我們 %s 要傳給 MySQL 的值</span></span><br><span class="line">    <span class="comment"># 記住： 一定要用小括號包住，即使是只有傳回一個值也是如此，語法規定。</span></span><br><span class="line">    print(<span class="string">"刪除資料完成"</span>)</span><br><span class="line">    conn.commit() <span class="comment">#這是最重要的，如果沒有儲存變更，則 Py 會一直操作 MySQL 不會退出</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> ex:</span><br><span class="line">    print(ex)</span><br></pre></td></tr></table></figure>

<h2 id="可能會遇到的問題"><a href="#可能會遇到的問題" class="headerlink" title="可能會遇到的問題"></a>可能會遇到的問題</h2><p>這裡收錄大衛在學習 Py MySQL 操作時一些遇到的小錯誤，如果讀者也剛好有此問題剛好能看我文章解決那就再好不過了。<br><a href="https://theriseofdavid.github.io/2020/11/30/Python/Python_Pymysql_fetchone_fetchall/" target="_blank" rel="noopener">Python 套件中 Pymysql 的 fetchone() 與 fetchall() 差別</a><br><a href="https://theriseofdavid.github.io/2020/11/30/MySQL/MySQL_stop_windows_server/" target="_blank" rel="noopener">MySQL 停止在 windows 上的服務</a></p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://www.learncodewithmike.com/2020/02/python-mysql.html" target="_blank" rel="noopener">[Python實戰應用]掌握Python連結MySQL資料庫的重要操作</a><br><a href="https://blog.csdn.net/ZeroBz/article/details/79136926" target="_blank" rel="noopener">mysql pk、nn、qu、b、un、zf、ai、g代表的意思</a><br><a href="http://note.drx.tw/2012/12/mysql-syntax.html" target="_blank" rel="noopener">MySQL 語法連結</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>寫教學文章真的好難…，其實我發現我寫應用的教學文章比較沒有甚麼心得感言XD，因為都是使用別人的套件，偶爾採坑上網查資料去換另外一種寫法，直到找出可以寫的方法，不得不說有了資料庫與 Python 後我的學習路上一帆風順，我不需要懂基礎知識就可以應用，但這也同時讓我感到害怕，我是不是就只學會如何找工具，並拿來放，有點像是工人，而散播套件的人則是工廠，大量產生工具給我們用。</p>
<p>工人永遠都不懂工具是怎麼被製造而成，但工人會不斷地應用，我覺得這似乎是一件很可怕的事情，應該要懂工具是怎麼被製作、應用，學習才有踏實感也有意義吧，不然感覺現在的我似乎還是沒有像學習演算法時那樣，了解整個套件的應用。</p>
]]></content>
      <categories>
        <category>Python</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>Python</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 開多執行緒並找出空閒執行緒的方法 (使用 threading 套件)</title>
    <url>/2020/11/30/Python/Python_Open_multiple_threads_and_find_idle_threads/</url>
    <content><![CDATA[<h2 id="內容說明"><a href="#內容說明" class="headerlink" title="內容說明"></a>內容說明</h2><blockquote>
<p>這裡留存大衛在寫 Python 開多執行緒並找出空閒執行緒的方法，大衛認為此寫法不錯，因此放在這裡供各位與未來的我參考</p>
</blockquote>
<a id="more"></a>

<h2 id="寫法"><a href="#寫法" class="headerlink" title="寫法"></a>寫法</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"><span class="keyword">import</span> threading </span><br><span class="line"></span><br><span class="line">workers = queue.deque()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    workers.append(threading.Thread(target=function,args=(<span class="number">1</span>,)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> workers[<span class="number">0</span>].isAlive(): <span class="comment">#找出沒有工作的執行緒</span></span><br><span class="line">    labor = workers[<span class="number">0</span>]  <span class="comment"># labor 就是 workers[0] 並且她正在工作</span></span><br><span class="line">    workers.popleft() <span class="comment"># 將wokrers 0 移除</span></span><br><span class="line">    workers.append(labor) <span class="comment"># 再將 labor 放入，即將 workers[0] 放到 queue 的最後</span></span><br><span class="line">    time.sleep(<span class="number">1</span>) <span class="comment"># 等待一秒，在查詢下一個執行緒有沒有工作</span></span><br></pre></td></tr></table></figure>

<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>有時候真的好佩服我自己可以寫得出這種想法，我發現我的想法都是在浴室洗澡的時候想出來，看來我有一個很棒的理由可以說自己為甚麼每天要洗兩次澡了XD，因為只有在那個時候我的腦袋思緒會特別清楚，會不會是因為我把身體洗乾淨，所以腦袋也乾淨了呢wwww。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>Python</tag>
        <tag>優秀寫法紀錄</tag>
      </tags>
  </entry>
  <entry>
    <title>Python ERROR !  argument after * must be an iterable, not int</title>
    <url>/2020/11/30/Python/Python_argument_after_must_be_an_iterable_not_int/</url>
    <content><![CDATA[<h2 id="內容說明"><a href="#內容說明" class="headerlink" title="內容說明"></a>內容說明</h2><blockquote>
<p>記錄我在學習 Python 路上遇到的坑，並將以補足。 </p>
</blockquote>
<a id="more"></a> 

<h2 id="Python-ERROR-argument-after-must-be-an-iterable-not-int"><a href="#Python-ERROR-argument-after-must-be-an-iterable-not-int" class="headerlink" title="Python ERROR !  argument after * must be an iterable, not int"></a>Python ERROR !  argument after * must be an iterable, not int</h2><p>這問題主要是在講例如使用 <code>threading</code> 套件時，可能會遇到的問題。</p>
<p>以 <code>threading</code> 套件而立，args 不可以是一個數字，就算 function 的值只需要一個參數，也必須要用 tuple(或可迭代的 object)，此指令才允許被執行。</p>
<p>通常是語法規定，原因可能要問當初設計這樣的用意XD。</p>
<h3 id="正確寫法"><a href="#正確寫法" class="headerlink" title="正確寫法"></a>正確寫法</h3><p>使用正確寫法後，相信就能執行成功了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">threading.Thread(target=function, args=(<span class="number">1</span>,))</span><br></pre></td></tr></table></figure>

<h3 id="錯誤寫法"><a href="#錯誤寫法" class="headerlink" title="錯誤寫法"></a>錯誤寫法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">threading.Thread(target=function, args=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://stackoverflow.com/questions/52575418/reverse-with-prefix-argument-after-must-be-an-iterable-not-int" target="_blank" rel="noopener">_reverse_with_prefix() argument after * must be an iterable, not int</a><br><a href="https://stackoverflow.com/questions/56545387/typeerror-start-argument-after-must-be-an-iterable-not-int" target="_blank" rel="noopener">TypeError: start() argument after * must be an iterable, not int [duplicate]</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>Python 真的很方便，但即使再方便的程式語言也必須合乎套件要求才有辦法正常執行，只有學會正確的使用方式才可以完整的操作 Python，一起加油吧！</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>Python</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>QUESTION! git push 需要不斷重複輸入帳號密碼，並且還是出現登入失敗</title>
    <url>/2020/11/27/git/git_login_repeat/</url>
    <content><![CDATA[<h2 id="文章大意："><a href="#文章大意：" class="headerlink" title="文章大意："></a>文章大意：</h2><blockquote>
<p>解決 <code>git push</code> 需要一直登入帳號密碼，但還是沒辦法推上去的問題。</p>
</blockquote>
<a id="more"></a>

<h2 id="QUESTION-git-push-需要不斷重複輸入帳號密碼，並且還是出現登入失敗"><a href="#QUESTION-git-push-需要不斷重複輸入帳號密碼，並且還是出現登入失敗" class="headerlink" title="QUESTION! git push 需要不斷重複輸入帳號密碼，並且還是出現登入失敗"></a>QUESTION! git push 需要不斷重複輸入帳號密碼，並且還是出現登入失敗</h2><p>在使用 <code>git push</code> 時，可能會遇到一種狀況時，系統不斷跳出要你輸出帳號 and 密碼，你重新輸入過後，又跳出一個新視窗，此視窗與先前的不同，輸入帳號密碼後，明明正確還是說你驗證失敗時要怎麼辦呢？</p>
<h2 id="situlation-Creating-a-personal-access-token-建立個人訪問令牌"><a href="#situlation-Creating-a-personal-access-token-建立個人訪問令牌" class="headerlink" title="situlation : Creating a personal access token (建立個人訪問令牌)"></a>situlation : Creating a personal access token (建立個人訪問令牌)</h2><p>透過此方式，就可以回復到像其他教學文章、或你之前的使用體驗一樣，只需要 <code>git push</code> 就可以成功放到 github 了！</p>
<h3 id="Step-1-先從-Github-拿到-access-token"><a href="#Step-1-先從-Github-拿到-access-token" class="headerlink" title="Step 1: 先從 Github 拿到 access token"></a>Step 1: 先從 Github 拿到 access token</h3><p>先去 github 找出設定後並點擊，先點右上角的頭像，之後點下方 Setting<br><img src="/images/git_login_repeat/1.PNG" alt=""></p>
<p>接下來點擊 Developer settings<br><img src="/images/git_login_repeat/2.PNG" alt=""></p>
<p>點擊 Personal access token<br><img src="/images/git_login_repeat/3.PNG" alt=""></p>
<p>點擊 Generate new token，之後輸入密碼<br><img src="/images/git_login_repeat/4.PNG" alt=""></p>
<p>有打藍色勾勾的，都要勾起來，之後點擊 Generate token<br><img src="/images/git_login_repeat/5.PNG" alt=""></p>
<p>之後會看到一組 token，複製此 token<br><img src="/images/git_login_repeat/6.PNG" alt=""></p>
<h2 id="Step-2-將此-token-套用在我們電腦中的-git"><a href="#Step-2-將此-token-套用在我們電腦中的-git" class="headerlink" title="Step 2: 將此 token 套用在我們電腦中的 git"></a>Step 2: 將此 token 套用在我們電腦中的 git</h2><p>這次我們就先使用 <code>git clone https://.../repo.git</code>，來呼叫出我們要不斷登入的畫面，之後只要是 Username 的部分我們就一樣打 Username，另外一個 Password 則是打 <strong>token</strong>，如果需要打兩次是屬於正常，但如果還是一直失敗就要注意可能是哪裡有問題了。</p>
<p>統整一下的話則像這樣子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git clone https:&#x2F;&#x2F;......&#x2F;repo.git</span><br><span class="line">Username: your_username</span><br><span class="line">Password: your_token</span><br></pre></td></tr></table></figure>

<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://docs.github.com/en/free-pro-team@latest/github/authenticating-to-github/creating-a-personal-access-token" target="_blank" rel="noopener">Creating a personal access token</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>此參考連結救了大衞長久以來的問題了QQ，原本是想說只是要登入兩次也不是甚麼太麻煩的事情，但到了最近卻發現登入兩次也沒辦法拯救此問題，實在是忍不了，就上網爬文求 solution，不過不要學我拉，我是不好示範，我等到我受不了才去找問題，通常只要有一些小毛病就要去解決，不要拖。</p>
<p><strong>拖只會讓問題越來越嚴重</strong>，所以要盡早解決，不要變成大病了才來重視他，有點為時已晚。</p>
<p>不過我又學了好多知識，好開心喔&gt;&lt;</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL Boolean 資料類別</title>
    <url>/2020/11/30/MySQL/MySQL_boolean/</url>
    <content><![CDATA[<h2 id="內容說明"><a href="#內容說明" class="headerlink" title="內容說明"></a>內容說明</h2><blockquote>
<p>簡單紀錄在 MySQL 新增 Boolean 型態的 column(欄位)，會突然變成 tinyint</p>
</blockquote>
<a id="more"></a>

<h2 id="MySQL-Boolean-資料類別簡單介紹："><a href="#MySQL-Boolean-資料類別簡單介紹：" class="headerlink" title="MySQL Boolean 資料類別簡單介紹："></a>MySQL Boolean 資料類別簡單介紹：</h2><p>因為 MySQL 並沒有內建 Boolean 類別，為了更方便的使用，於是他使用了 TINYINT(1) - 只能存放 0 與 1 數字的資料型態，通常 0 表示 FALSE、1 表示 TRUE。</p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://www.yiibai.com/mysql/boolean.html" target="_blank" rel="noopener">MySQL boolean类型</a><br><a href="https://stackoverflow.com/questions/7156147/inserting-boolean-value-into-mysql-with-python" target="_blank" rel="noopener">Inserting boolean value into MySQL with Python</a></p>
<h2 id="心得："><a href="#心得：" class="headerlink" title="心得："></a>心得：</h2><p>學了一課，我對於 MySQL 原本一點認識都沒有，透過這幾天的自學，慢慢學到了許多東西，MySQL 真的是太贊了，也要謝謝各位願意將技術文章放在網路上才能夠讓我學習。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 套件中 Pymysql 的 fetchone() 與 fetchall() 差別</title>
    <url>/2020/11/30/Python/Python_Pymysql_fetchone_fetchall/</url>
    <content><![CDATA[<h2 id="內容說明"><a href="#內容說明" class="headerlink" title="內容說明"></a>內容說明</h2><blockquote>
<p>簡單介紹 Python 套件中 Pymysql 的 fetchone() 與 fetchall() 差別</p>
</blockquote>
<a id="more"></a>

<h2 id="fetchone"><a href="#fetchone" class="headerlink" title="fetchone():"></a>fetchone():</h2><p>回傳 Python 呼叫 MySQL 指令的<strong>一條</strong>紀錄(row)，如果沒有回傳值則返回 <code>None</code></p>
<h2 id="fetchall"><a href="#fetchall" class="headerlink" title="fetchall()"></a>fetchall()</h2><p>回傳 Python 呼叫 MySQL 指令的<strong>多條</strong>紀錄(row)，如果沒有則回傳 <code>()</code></p>
<h2 id="兩者差異"><a href="#兩者差異" class="headerlink" title="兩者差異"></a>兩者差異</h2><p>稍微看得出來差異吧XD，<code>fetchone()</code> 回傳一條紀錄，於是如果回傳超過一條紀錄時，只會回傳<strong>第一條</strong>紀錄，且是<strong>一維 tuple</strong></p>
<p><code>fetchall()</code> 如果只有回傳一條紀錄時一樣是傳回 <strong>二維 tuple</strong>。</p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://blog.csdn.net/u014234260/article/details/79581041" target="_blank" rel="noopener">【Python】fetchone()和fetchall()</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>學起來了，學起來了，學習這些知識使我在未來想要實踐自己的程式能力時，可以更好發揮。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 停止在 windows 上的服務</title>
    <url>/2020/11/30/MySQL/MySQL_stop_windows_server/</url>
    <content><![CDATA[<h2 id="內容說明"><a href="#內容說明" class="headerlink" title="內容說明"></a>內容說明</h2><blockquote>
<p>有時候 MySQL 可能會出點 Bug，我們會需要 MySQL 先關閉再開啟，來解決遇到 Bug 或卡頓的問題，對不起，我就懶，想要暴力解。</p>
<p>這篇只適用 windows，其他作業系統不適合QQ。</p>
</blockquote>
<a id="more"></a>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="找到-services-msc-並關閉-MySQL"><a href="#找到-services-msc-並關閉-MySQL" class="headerlink" title="找到 services.msc 並關閉 MySQL"></a>找到 services.msc 並關閉 MySQL</h3><p>在搜尋框內輸入 services.msc，並且點擊那圖是有<strong>齒輪</strong>的唯一搜尋資料。</p>
<blockquote>
<p><img src="/images/MySQL_stop_windows_server/1.PNG" alt=""></p>
</blockquote>
<p>之後點開後畫面則像這樣</p>
<blockquote>
<p><img src="/images/MySQL_stop_windows_server/2.PNG" alt=""></p>
</blockquote>
<h3 id="開啟-services-ms"><a href="#開啟-services-ms" class="headerlink" title="開啟 services.ms"></a>開啟 services.ms</h3><p>找到 MySQL，通常是 MySQLXX，XX 為版本</p>
<blockquote>
<p><img src="/images/MySQL_stop_windows_server/3.PNG" alt=""></p>
</blockquote>
<p>並對她按右鍵後，點擊停止就立即停止 MySQL 服務。</p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://stackoverflow.com/questions/10885038/stop-mysql-service-windows" target="_blank" rel="noopener">Stop MySQL service windows</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>這篇參考連結救了我…，嗚嗚，要是沒了他我不知道還要找多久資料…</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 輸出資料至 EXCEL</title>
    <url>/2020/11/30/MySQL/MySQL_Export_Excel/</url>
    <content><![CDATA[<h2 id="內容說明"><a href="#內容說明" class="headerlink" title="內容說明"></a>內容說明</h2><blockquote>
<p>說明如何透過 SQL 語法輸出資料至 EXCEL</p>
</blockquote>
<a id="more"></a>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h2><p>在 MySQL 沒有辦法直接將資料輸出成 Excel 格式，但可以輸出成 csv 之後並透過 Excel 進行打開，範例如下：</p>
<h3 id="不含標題"><a href="#不含標題" class="headerlink" title="不含標題"></a>不含標題</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT ... FROM ... WHERE ... </span><br><span class="line">INTO OUTFILE &#39;file.csv&#39;</span><br><span class="line">FIELDS TERMINATED BY &#39;,&#39;</span><br></pre></td></tr></table></figure>

<h3 id="含標題"><a href="#含標題" class="headerlink" title="含標題"></a>含標題</h3><p>如果需要標題時要怎麼辦呢？自己打，對，我真的沒有開玩笑…，我也很難過，嗚嗚。不過這樣自由度也高拉，其實也不差，範例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT &#39;ColName1&#39;, &#39;ColName2&#39;, &#39;ColName3&#39;</span><br><span class="line">UNION ALL</span><br><span class="line">SELECT ... FROM ... WHERE ... </span><br><span class="line">INTO OUTFILE &#39;file.csv&#39;</span><br><span class="line">FIELDS TERMINATED BY &#39;,&#39;</span><br></pre></td></tr></table></figure>

<h2 id="可能會遇到的問題"><a href="#可能會遇到的問題" class="headerlink" title="可能會遇到的問題"></a>可能會遇到的問題</h2><p>這裡收錄大衛在輸出 MySQL csv 時一些遇到的小錯誤，如果讀者也剛好有此問題剛好能看我文章解決那就再好不過了。<br><a href="https://theriseofdavid.github.io/2020/11/30/MySQL/MySQL_ERROR_1290_(HY000)_secure_file_priv_option/" target="_blank" rel="noopener">MySQL ERROR 1290 (HY000) he MySQL server is running with the –secure-file-priv option so it cannot execute this statement (for windows)</a></p>
<h2 id="參考連結："><a href="#參考連結：" class="headerlink" title="參考連結："></a>參考連結：</h2><p><a href="https://stackoverflow.com/questions/10295228/exporting-results-of-a-mysql-query-to-excel" target="_blank" rel="noopener">Exporting results of a Mysql query to excel?</a><br><a href="https://stackoverflow.com/questions/5941809/include-headers-when-using-select-into-outfile" target="_blank" rel="noopener">Include headers when using SELECT INTO OUTFILE?</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>Stackoverflow 是甚麼網站阿，為甚麼我想要答案都會在哪裡，其他隔壁的農場文章都是負責抄襲此網站，而且水準以及翻譯水平即差，希望 Google 可以將一些垃圾資訊移除，才會方便需要學習的讀者可以查詢到需要的網頁，而不是一直搜尋到品質低劣的網站。</p>
<p>Stackoverflow 你好偉大…，嗚嗚嗚嗚，沒有你的我好爛。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL ERROR 1290 (HY000) he MySQL server is running with the --secure-file-priv option so it cannot execute this statement (for windows)</title>
    <url>/2020/11/30/MySQL/MySQL_ERROR_1290_(HY000)_secure_file_priv_option/</url>
    <content><![CDATA[<h2 id="內容說明"><a href="#內容說明" class="headerlink" title="內容說明"></a>內容說明</h2><blockquote>
<p>當你在寫 MySQL 並輸出檔案時可能會遇到一些問題，這裡提供一種解決方式。</p>
<p>目前只提供 Windows 方案，之後如果 Linux 我也有遇到此問題我則會補上。</p>
</blockquote>
<a id="more"></a>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h2><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>在 MySQL 中檔案輸出是有嚴格的要求，我不確定是甚麼因素導致 MySQL 對於輸出資料庫檔案如此要求，但他要求了，不符合我們的需求，那我們就要來調整至我們的需求瞜XD。</p>
<h3 id="查詢此位置-SECURE-FILE-PRIV"><a href="#查詢此位置-SECURE-FILE-PRIV" class="headerlink" title="查詢此位置 SECURE-FILE-PRIV"></a>查詢此位置 SECURE-FILE-PRIV</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SHOW GLOBAL VARIABLES LIKE &#39;%secure%&#39;;</span><br></pre></td></tr></table></figure>

<p>通常在進行此查詢後，會看到一段路徑，移動到此路徑，以我為範例，我輸出的路徑則是 <code>C:\ProgramData\MySQL\MySQL Server 8.0</code></p>
<p><img src="/images/MySQL_ERROR_1290_(HY000)_secure_file_priv_option/1.PNG" alt=""></p>
<h3 id="找到-MySQL-Server-X-X-的-my-ini-並修改"><a href="#找到-MySQL-Server-X-X-的-my-ini-並修改" class="headerlink" title="找到 MySQL Server X.X 的 my.ini 並修改"></a>找到 MySQL Server X.X 的 my.ini 並修改</h3><p>由於問題是 secure-file-priv 此參數設定我們輸出的檔案只能在他規定的路徑下，於是我們要修改他的路徑，要如何修改呢，首先就是要先找到 <code>my.ini</code>，通常位置如果沒有被改變，應該是預設在 <code>C:\ProgramData\MySQL\MySQL Server 8.0</code></p>
<p>找到  secure-file-priv 並修改值為 <code>&quot;&quot;</code>，當值被設定為<code>&quot;&quot;</code>時表示不監控檔案輸出路徑，即你想輸出在哪個位置都可以。<br><img src="/images/MySQL_ERROR_1290_(HY000)_secure_file_priv_option/2.PNG" alt=""></p>
<h3 id="重開-MySQL-server"><a href="#重開-MySQL-server" class="headerlink" title="重開 MySQL server"></a>重開 MySQL server</h3><p>注意，並不是只將 MySQL Workbench 關掉重開即可，要<strong>完整關掉</strong>。</p>
<p>詳細步驟可以看此連結 <a href="https://theriseofdavid.github.io/2020/11/30/MySQL/MySQL_stop_windows_server/" target="_blank" rel="noopener">MySQL 停止在 windows 上的服務</a></p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://stackoverflow.com/questions/34102562/mysql-error-1290-hy000-secure-file-priv-option" target="_blank" rel="noopener">MySQL ERROR 1290 (HY000) –secure-file-priv option</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>Stackoverflow 是甚麼網站阿，為甚麼我想要答案都會在哪裡，其他隔壁的農場文章都是負責抄襲此網站，而且水準以及翻譯水平即差，希望 Google 可以將一些垃圾資訊移除，才會方便需要學習的讀者可以查詢到需要的網頁，而不是一直搜尋到品質低劣的網站。</p>
<p>Stackoverflow 你好偉大…，嗚嗚嗚嗚，沒有你的我好爛。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>資料庫管理 筆記 - 大二上期中考</title>
    <url>/2020/12/01/NTUT_note/database_1/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊與財金管理系大二上統計學重點整理<br><font color="#dd0000">並非所有人都適用，部分對我而言稍加容易的內容並不會寫在此內。</font></p>
</blockquote>
<a id="more"></a>

<h1 id="資料庫管理期中考"><a href="#資料庫管理期中考" class="headerlink" title="資料庫管理期中考"></a>資料庫管理期中考</h1><h2 id="老師說得必考"><a href="#老師說得必考" class="headerlink" title="老師說得必考"></a>老師說得必考</h2><ul>
<li>非主鍵的外來鍵(Foreign key) 畫虛線</li>
<li>外來鍵用其他表的主鍵表示兩表格的關係</li>
<li>候選鍵一定要有值，非候選鍵不一定有值</li>
<li>主鍵是從候選鍵挑出來的<h3 id="determinant-行列式-and-Candidate-key-候選鍵"><a href="#determinant-行列式-and-Candidate-key-候選鍵" class="headerlink" title="determinant(行列式) and Candidate key(候選鍵)"></a>determinant(行列式) and Candidate key(候選鍵)</h3>可以識別一筆row的資料，但若為複合鍵的情況下，Candidate key的所有屬性都不能是多餘的(redundancy)，也就是不能有屬性是刪除後對於Candidate key識別一筆row資料沒有影響；Candidate key 一定是 Determinant，但Determinant不一定是Candidate key。<h3 id="問你主鍵-Primary-Keys-是什麼-參考限制條件"><a href="#問你主鍵-Primary-Keys-是什麼-參考限制條件" class="headerlink" title="問你主鍵(Primary Keys)是什麼 參考限制條件"></a>問你主鍵(Primary Keys)是什麼 參考限制條件</h3></li>
<li>一定要畫<strong>實線</strong></li>
<li>不可有空值(Not Null)</li>
<li>永遠不會改變(Never Change)</li>
<li>非識別值(Nonidentifying Value)<br>即「值」本身沒有意義。例如買電子產品都會有一個「序號」，假設第一碼代表供應商麼，第二碼代表所在地區(台北、台中…)，有一天供應商搬家了，從台北搬到台中，那第二碼就不會符合現況。</li>
<li>主鍵是關係的唯一標識符。 示例包括員工編號，社會保險號等。這可以確保所有行都是唯一的。</li>
<li>Primary keys are unique identifiers of the relation. Examples include employee numbers, social security numbers, etc. This guarantees that all rows are unique.</li>
</ul>
<h4 id="Domain-Constraints-域約束"><a href="#Domain-Constraints-域約束" class="headerlink" title="Domain Constraints 域約束"></a>Domain Constraints 域約束</h4><ul>
<li>Allowable values for an attribute (includes data types and restrictions on values)</li>
<li>屬性的允許值（包括數據類型和值限制）</li>
</ul>
<h4 id="Entity-Integrity-實體完整性"><a href="#Entity-Integrity-實體完整性" class="headerlink" title="Entity Integrity 實體完整性"></a>Entity Integrity 實體完整性</h4><ul>
<li>No primary key attribute may be null. All primary key fields MUST contain data values.</li>
<li>主鍵屬性不能為空。 所有主鍵字段必須包含數據值。</li>
</ul>
<h4 id="Referential-Integrity-參照完整性"><a href="#Referential-Integrity-參照完整性" class="headerlink" title="Referential Integrity 參照完整性"></a>Referential Integrity 參照完整性</h4><ul>
<li>Rules that maintain consistency between the rows of two related tables.</li>
<li>維護兩個相關表的行之間一致性的規則。</li>
</ul>
<h3 id="資料正規化-3個異常-4-38-4-39"><a href="#資料正規化-3個異常-4-38-4-39" class="headerlink" title="資料正規化 3個異常 4-38 4-39"></a>資料正規化 3個異常 4-38 4-39</h3><p><img src="https://i.imgur.com/pQz0S5h.png" alt=""></p>
<h4 id="Insertion"><a href="#Insertion" class="headerlink" title="Insertion"></a>Insertion</h4><ul>
<li>can’t enter a new employee without having the employee take a class (or at least empty fields of class information)</li>
<li>在沒有讓員工參加課程的情況下（或至少在課程信息的空白字段中）不能輸入新員工</li>
</ul>
<h4 id="Deletion"><a href="#Deletion" class="headerlink" title="Deletion"></a>Deletion</h4><ul>
<li>if we remove employee 140, we lose information about the existence of a Tax Acc class</li>
<li>如果我們刪除員工140，我們將丟失有關Tax Acc類的信息</li>
</ul>
<h4 id="Modification"><a href="#Modification" class="headerlink" title="Modification"></a>Modification</h4><ul>
<li>giving a salary increase to employee 100 forces us to update multiple records</li>
<li>給員工100加薪迫使我們更新多個記錄</li>
</ul>
<h2 id="資料正規化"><a href="#資料正規化" class="headerlink" title="資料正規化"></a>資料正規化</h2><h3 id="1NF"><a href="#1NF" class="headerlink" title="1NF"></a>1NF</h3><ul>
<li>是指在資料表中的所有記錄之屬性內含值都是基元值(Atomic Value)。<br>基元值(Atomic Value) = 亦即無重覆項目群</li>
<li>沒有任何兩筆以上的資料是完全重覆</li>
<li>資料表中有主鍵, 而其他所有的欄位都相依於「主鍵」。<h3 id="2NF"><a href="#2NF" class="headerlink" title="2NF"></a>2NF</h3><a href="https://hackmd.io/DafKP08ARwKBz-78gBSFYQ#%E8%B3%87%E6%96%99%E6%AD%A3%E8%A6%8F%E5%8C%96-3%E5%80%8B%E7%95%B0%E5%B8%B8-4-38-4-39" target="_blank" rel="noopener">看這裡就可以</a><h3 id="3NF"><a href="#3NF" class="headerlink" title="3NF"></a>3NF</h3>各欄位與「主鍵」之間沒有「遞移相依」的關係。</li>
<li>遞移相依<br>A 跟 B 有關係，B 跟 C 有關係，則 A 跟 C 就是<strong>遞移相依</strong><h3 id="實務範例"><a href="#實務範例" class="headerlink" title="實務範例"></a>實務範例</h3><img src="https://i.imgur.com/YLLLT5T.png" alt=""></li>
</ul>
<h2 id="資料來源"><a href="#資料來源" class="headerlink" title="資料來源"></a>資料來源</h2><p><a href="https://blog.kkbruce.net/2010/10/normalization-key.html#.X7qQVM0zaUl" target="_blank" rel="noopener">關聯資料表正規化(NORMALIZATION)–鍵,KEY</a><br><a href="https://answers.sap.com/questions/2689632/key-and-non-key-fields.html" target="_blank" rel="noopener">Key and Non-Key Fields</a><br><a href="http://abbydoubleb.blogspot.com/2014/10/1031-chapter-4-database-design.html" target="_blank" rel="noopener">1031 - 資料庫管理概論 Chapter 4 Database design</a><br><a href="http://cc.cust.edu.tw/~ccchen/doc/db_04.pdf" target="_blank" rel="noopener">資料庫正規化</a></p>
]]></content>
      <categories>
        <category>北科上課筆記</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>資料庫管理</tag>
      </tags>
  </entry>
  <entry>
    <title>投資學 筆記 - 股票交易制度</title>
    <url>/2020/12/01/NTUT_note/investment_stock_trading_system/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊與財金管理系大二上投資學重點整理<br><font color="#dd0000">並非所有人都適用，部分對我而言稍加容易的內容並不會寫在此內。</font><br>本章主要內容</p>
<ul>
<li>上市櫃股票交易流程</li>
<li>上市櫃股票交易成本</li>
<li>上市櫃股價漲跌幅與檔次</li>
<li>上市櫃股票信用交易</li>
<li>上市櫃股票鉅額交易與零股交易</li>
<li>興櫃股票交易制度</li>
</ul>
</blockquote>
<a id="more"></a>

<h2 id="基本觀念"><a href="#基本觀念" class="headerlink" title="基本觀念"></a>基本觀念</h2><p>台灣的股票交易採用兩層式架構，股票交易人將買或賣的委託單交由證券經紀商，輸入證交所或櫃買中心的交易系統中，進行撮合交易。</p>
<ul>
<li>2020 年 3 月 23 日 開始進行盤中逐筆交易</li>
<li>2020 年 10 月 26 日 盤中集合競價</li>
</ul>
<h3 id="股票交易程序"><a href="#股票交易程序" class="headerlink" title="股票交易程序"></a>股票交易程序</h3><ul>
<li>投資人需要開立三個帳戶 <ul>
<li>有價證券受託買賣帳戶 (交易帳戶)</li>
<li>證券集中保管帳戶 (證券存摺)</li>
<li>款券劃撥帳戶 (銀行活期存款存摺)</li>
</ul>
</li>
<li>開戶<br>個人需帶身分證、第二證件與印章至證券經紀商營業處，法人則須被授權人辦理，帶法人證件等、公司印鑑、被授權人身分證影本。</li>
<li>委託<ul>
<li>時間<br>委託時間在 8:30(開盤) ~ 13:30(收盤)，可進行交易，14:00 ~ 14:30(收盤)則可以根據收盤價進行交易，且盤後交易不可超過 499 單位</li>
<li>有效時間<br>可以在還沒成交前，取消委託，委託只限當日有效，到隔天則須重新委託。</li>
</ul>
</li>
<li>結算 (三種方式結算) <ul>
<li>公式<br>結算公式： \(結算 = 券的交割 + 結清款項\)</li>
<li>當日交割<br>必須當日完成，鉅額買賣為超過 500 交易單位</li>
<li>普通交易交割<br>成交日後的第二天(營業日)辦理交割，通常使用此方式。</li>
<li>違約交割<br>沒有在成交日後的第二天(營業日)辦理交割，違約，三年內不可再開戶與委託買賣。</li>
</ul>
</li>
<li>股票保管<ul>
<li>線上管理，都放在<strong>證券存摺</strong></li>
</ul>
</li>
</ul>
<h2 id="集合競價與逐筆競價制度"><a href="#集合競價與逐筆競價制度" class="headerlink" title="集合競價與逐筆競價制度"></a>集合競價與逐筆競價制度</h2><p>8:30-9:00(開盤前)、13:25-13:30(開盤即將結束)為集合競價，9:00-13:25 則採用逐筆競價</p>
<h3 id="集合競價"><a href="#集合競價" class="headerlink" title="集合競價"></a>集合競價</h3><p>買入累計與賣出累計為全部價位中的最大值，則此價位為成交價。<br>P.S. 買方必須都先 -100，圖片有問題</p>
<blockquote>
<p><img src="/images/investment_stock_trading_system/1.PNG" alt=""></p>
</blockquote>
<ul>
<li>只能下限價單，低於此價位就不賣出。(以賣出為例)</li>
</ul>
<h3 id="逐筆競價"><a href="#逐筆競價" class="headerlink" title="逐筆競價"></a>逐筆競價</h3><p>看圖說明即可，注意：如果有比你低的價位可買入，則優先買入</p>
<blockquote>
<p><img src="/images/investment_stock_trading_system/2.PNG" alt=""></p>
</blockquote>
<ul>
<li>可以下市價單、立即成交取消、全部成交或取消的委託單</li>
<li>限價委託<br>以買入為例，限價 50 表示在成交價 50 以下(含)才買入。</li>
<li>市價單<br>根據市場成交價買賣。</li>
</ul>
<h2 id="股票交易成本"><a href="#股票交易成本" class="headerlink" title="股票交易成本"></a>股票交易成本</h2><ul>
<li>手續費<br>股票、ETF、基金，證券商自訂，憑證上限為 0.1425%</li>
<li>證券交易稅<br>3%，完全不可變動。</li>
</ul>
<h2 id="股票信用交易"><a href="#股票信用交易" class="headerlink" title="股票信用交易"></a>股票信用交易</h2><p>期限通常為一年，最多可延兩次半年</p>
<h3 id="融資"><a href="#融資" class="headerlink" title="融資"></a>融資</h3><p>投資人以部分自備款擔保，向證券商購買股票</p>
<ul>
<li>融資對象<ul>
<li>20歲以上國民</li>
<li>開立買賣帳戶 3 個月以上</li>
<li>近一年委託買賣達 10 筆，融資額度只能到累積成交金額 50%。</li>
<li>融資額度為所得與全部財產的 30%。<h3 id="融券"><a href="#融券" class="headerlink" title="融券"></a>融券</h3>手上沒有股票但先賣股票，此時我們則欠證券商股票，必須在規定期限內買入股票歸還。</li>
</ul>
</li>
</ul>
<h3 id="融資融券的證券"><a href="#融資融券的證券" class="headerlink" title="融資融券的證券"></a>融資融券的證券</h3><ul>
<li>股票<br>上市櫃 6 個月且每股淨值都在票面之上的普通股股票。</li>
<li>台灣存託憑證<br>上市櫃滿六個月，且無累積虧損</li>
<li>受益憑證<br>上市須滿六個月，但 ETF 除外。</li>
<li><strong>股價波動劇烈、成交量異常、股權或受益權集中都不可融資融券</strong></li>
<li><strong>零股買賣、鉅額買賣不可融資融券</strong></li>
</ul>
<h4 id="規定事項"><a href="#規定事項" class="headerlink" title="規定事項"></a>規定事項</h4><blockquote>
<p><img src="/images/investment_stock_trading_system/3.PNG" alt=""></p>
</blockquote>
<h4 id="擔保維持率"><a href="#擔保維持率" class="headerlink" title="擔保維持率"></a>擔保維持率</h4><p>必須要維持<strong>擔保維持率</strong>，如果低於一定比率(2019 為 130%)，則委託人必須先補繳融資自備款達到比例，且期限為兩天，若沒達成條件則處分擔保品(俗稱斷頭)。<br>擔保維持率公式： \(\frac{融資擔保品市值+原融券擔保品及保証金}{原融資金額+融券標的証券市價}\)</p>
<h4 id="範例"><a href="#範例" class="headerlink" title="範例"></a>範例</h4><blockquote>
<p><img src="/images/investment_stock_trading_system/4.PNG" alt=""><br><img src="/images/investment_stock_trading_system/5.PNG" alt=""></p>
</blockquote>
<h4 id="暫停融資融券"><a href="#暫停融資融券" class="headerlink" title="暫停融資融券"></a>暫停融資融券</h4><ul>
<li>發行公司停止過戶日前五個營業日，停止融資買進三天</li>
<li>聽止過戶日前七個營業日，停止融券賣出五天</li>
</ul>
<blockquote>
<p><img src="/images/investment_stock_trading_system/6.PNG" alt=""></p>
</blockquote>
<h3 id="當日沖銷-當沖"><a href="#當日沖銷-當沖" class="headerlink" title="當日沖銷 (當沖)"></a>當日沖銷 (當沖)</h3><p>指投資人當天融資買入又融券賣出相同的股票，以兩者相抵後的餘額交割。</p>
<h4 id="範例-1"><a href="#範例-1" class="headerlink" title="範例"></a>範例</h4><blockquote>
<p><img src="/images/investment_stock_trading_system/7.PNG" alt=""></p>
</blockquote>
<h2 id="標借、議借與標購"><a href="#標借、議借與標購" class="headerlink" title="標借、議借與標購"></a>標借、議借與標購</h2><p>當某股票的融券數量超過證券金融公司的可融券數量時則會發生<strong>融券券源不足</strong>，可以向證交所貨櫃買中心申請，在網站上公告向投資人借股票，並由證券金融公司支付費用。</p>
<p>程序如下：</p>
<ol>
<li>先辦理<strong>標借</strong></li>
<li>券源不足，可<strong>議借</strong></li>
<li>還是不足，可<strong>標購</strong></li>
</ol>
<h3 id="標借"><a href="#標借" class="headerlink" title="標借"></a>標借</h3><ul>
<li>時間<br>8:30 開始公告<strong>標借</strong>證券，8:30-12:10 接受投標，12:30 電腦自動投標</li>
<li>價格<ul>
<li><strong>標借</strong>價格不超過融券差額發生日的收盤價或參考價的 7%。</li>
<li>開標按當日決標之借券費率，由低而高依序取借</li>
<li>當數量大過於需要的標借數量時按照輸入時間順序標借</li>
</ul>
</li>
</ul>
<h3 id="議借"><a href="#議借" class="headerlink" title="議借"></a>議借</h3><p>如果<strong>標借</strong>後仍有券源不足，可在 14:00 前<strong>議借</strong>，議借差額不可大於收盤價 10%</p>
<h3 id="標購"><a href="#標購" class="headerlink" title="標購"></a>標購</h3><p>如果<strong>議借</strong>後仍有券源不足，則在 14:30 委託證交所標購，差額不可大於 15%</p>
<h2 id="上市櫃股票鉅額交易與零股交易"><a href="#上市櫃股票鉅額交易與零股交易" class="headerlink" title="上市櫃股票鉅額交易與零股交易"></a>上市櫃股票鉅額交易與零股交易</h2><h3 id="鉅額交易"><a href="#鉅額交易" class="headerlink" title="鉅額交易"></a>鉅額交易</h3><ul>
<li>單一證券交易超過 500 個</li>
<li>單一證券交易超過 1500 萬</li>
<li>五種股票以上，總金額大於 1500 萬</li>
</ul>
<h4 id="交易方式"><a href="#交易方式" class="headerlink" title="交易方式"></a>交易方式</h4><ul>
<li>逐筆交易<br>採取撮合成交，採 T+2 日交割，申報時間為周一至周五 9:00-17:00</li>
<li>配對交易<br>採撮合成交，<strong>可以指定對象</strong>，採 T+2 日交割，申報時間為周一至周五 8:00-8:30 and 9:00-17:00</li>
</ul>
<h3 id="零股交易"><a href="#零股交易" class="headerlink" title="零股交易"></a>零股交易</h3><ul>
<li>不滿一個成交單位，即不滿 1000 股</li>
<li>盤中可以交易，且每三分鐘撮合一次</li>
<li>不可融資融券</li>
<li>圖表<blockquote>
<p><img src="/images/investment_stock_trading_system/8.PNG" alt=""></p>
</blockquote>
</li>
</ul>
<h3 id="定期定額買股票與自行買零股差異"><a href="#定期定額買股票與自行買零股差異" class="headerlink" title="定期定額買股票與自行買零股差異"></a>定期定額買股票與自行買零股差異</h3><ul>
<li>定期定額只需要設定一次之後就自動扣款，幫助投資人有紀律的投資</li>
<li>成交機率較高，券商可以匯總所有客戶款項再根據實際成交價、委託申購股數比例來進行分配</li>
</ul>
<h2 id="興櫃股票交易制"><a href="#興櫃股票交易制" class="headerlink" title="興櫃股票交易制"></a>興櫃股票交易制</h2><p><strong>未上市市櫃的股票也可以進行交易</strong>，台灣要上市上櫃的股票都必須要先在興櫃市場掛牌交易六個月以上，興櫃市場交易制度則是投資人透過交易系統與證券商進行議價交易。</p>
<h3 id="興櫃股票成交方式"><a href="#興櫃股票成交方式" class="headerlink" title="興櫃股票成交方式"></a>興櫃股票成交方式</h3><ul>
<li>到價委託單<br>\(投資人買價 \geq 證券商報賣價 \)，反之亦同，以價格優先，根據時間優先分配給推薦證券商成交</li>
<li>未到價委託單<br>\(投資人委託買價 &lt; 推薦證券商賣價 \)，證券商沒有成交義務，但可以點選成交 </li>
</ul>
]]></content>
      <categories>
        <category>北科上課筆記</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>北科大二上投資學筆記</tag>
        <tag>北科大大二上投資學期中考筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>統計學(一) 筆記 - 第七章 抽樣與抽樣分配(Sampling and Sampling Distributions)</title>
    <url>/2020/12/01/NTUT_note/statistics-ch7/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊與財金管理系大二上統計學重點整理<br><font color="#dd0000">並非所有人都適用，部分對我而言稍加容易的內容並不會寫在此內。</font><br><strong>這是觀看影片心得後的筆記，老師上課可能不太適用會忘記抄到</strong></p>
</blockquote>
<a id="more"></a>

<h2 id="名詞介紹"><a href="#名詞介紹" class="headerlink" title="名詞介紹"></a>名詞介紹</h2><ul>
<li>element<br>我們收集到的每一個資料</li>
<li>population 母體<br>我們資料整體，樣本(sample)則是資料裡面的其中一個集合</li>
<li>target population (目標母體)<br>我們想要選擇的母體</li>
<li>sampled population 抽樣母體<br>我們抽樣的整體資料</li>
<li>frame 抽樣清單<br>從 sampled population 抽取的清單</li>
</ul>
<h2 id="Selecting-Sample-選擇樣本"><a href="#Selecting-Sample-選擇樣本" class="headerlink" title="Selecting Sample 選擇樣本"></a>Selecting Sample 選擇樣本</h2><h3 id="Sampling-from-a-Finite-Population-有限母體"><a href="#Sampling-from-a-Finite-Population-有限母體" class="headerlink" title="Sampling from a Finite Population (有限母體)"></a>Sampling from a Finite Population (有限母體)</h3><p>舉例，信用卡名單、倉庫存貨、公司股東。</p>
<ul>
<li>簡單隨機樣本<br>每一個元素被抽出的機率相同</li>
<li>sampling with replacement 歸還抽樣<br>抽完放回去</li>
<li>sampling without replacement 不歸還抽樣<br>抽完不放回去</li>
</ul>
<h3 id="Sampling-from-a-Infinite-Population-無限母體"><a href="#Sampling-from-a-Infinite-Population-無限母體" class="headerlink" title="Sampling from a Infinite Population (無限母體)"></a>Sampling from a Infinite Population (無限母體)</h3><p>在無限母體中沒有 frame，因為 frame 會等於無限。<br>舉例：銀行產生的交易，因為會不斷產生因此不確定性很高。</p>
<ul>
<li>random sample <ul>
<li>每一個元素都是從相同母題抽出來</li>
<li>每一個元素都是獨立，即抽完不放回</li>
</ul>
</li>
</ul>
<h2 id="Point-Estimation-點估計量"><a href="#Point-Estimation-點估計量" class="headerlink" title="Point Estimation 點估計量"></a>Point Estimation 點估計量</h2><p>推測母體參數中某個數值</p>
<ul>
<li>\( \bar{x} \) 的點估計量就是平均值</li>
<li>s 點估計量為母體標準差</li>
<li>\( \bar{p} \) 為母體比例 p 的點估計量</li>
</ul>
<h3 id="舉例-St-Andrew’s-College"><a href="#舉例-St-Andrew’s-College" class="headerlink" title="舉例 - St. Andrew’s College"></a>舉例 - St. Andrew’s College</h3><p>Recall that St. Andrew’s College received 900 applications from prospective students. The application form contains a variety of information including the individual’s Scholastic Aptitude Test (SAT) score and whether or not the individual desires on-campus housing.</p>
<p>回想一下，聖安德魯學院收到了來自潛在學生的900份申請。 申請表包含各種信息，包括個人的學業能力測驗（SAT）分數以及個人是否希望在校內住宿。</p>
<p>P.S. 這裡的資料是在影片前面的抽樣資料為虛擬且抽樣數為 30，因此數字看看就好</p>
<ul>
<li>20 為申請住宿的量</li>
<li>50520 為分數總合</li>
<li>210512 則是透過公式與原始資料得出</li>
</ul>
<blockquote>
<p><img src="/images/statistics-ch7/2.PNG" alt=""></p>
</blockquote>
<p>下面這張圖片則是透過<strong>完整原始資料</strong>來進行計算</p>
<blockquote>
<p><img src="/images/statistics-ch7/3.PNG" alt=""></p>
</blockquote>
<h4 id="比較："><a href="#比較：" class="headerlink" title="比較："></a>比較：</h4><blockquote>
<p><img src="/images/statistics-ch7/4.PNG" alt=""></p>
</blockquote>
<h2 id="Introduction-to-Sampling-Distributions-抽樣分配"><a href="#Introduction-to-Sampling-Distributions-抽樣分配" class="headerlink" title="Introduction to Sampling Distributions 抽樣分配"></a>Introduction to Sampling Distributions 抽樣分配</h2><p><strong>每一次的抽樣計算出來的值都有可能不一樣</strong>，因為選擇的樣本不同。</p>
<p>但透過抽樣分配的次數越多，根據抽樣分配的次數會發現圖形長得像常態分配，即越偏差母體標準差的抽樣分配機率越小，越靠近的越大。</p>
<h3 id="舉例-關於公司管理職"><a href="#舉例-關於公司管理職" class="headerlink" title="舉例 - 關於公司管理職"></a>舉例 - 關於公司管理職</h3><p>公司總共有 2500 位管理職(母體)，我們想要知道下面以下問題：</p>
<ul>
<li>母體的平均年薪</li>
<li>母體的年薪標準差</li>
<li>母體中有完成教育訓練的值(母體參數)</li>
</ul>
<h4 id="答案-透過點估計量"><a href="#答案-透過點估計量" class="headerlink" title="答案 - 透過點估計量"></a>答案 - 透過點估計量</h4><ul>
<li><p>抽樣資料如下，有 30 筆</p>
<blockquote>
<p><img src="/images/statistics-ch7/5.PNG" alt=""></p>
</blockquote>
</li>
<li><p>Point estimation</p>
<ul>
<li>\(\bar{x} = \frac{\Sigma X_i}{n} = \frac{1,554,420}{30} = 51,814 \)</li>
<li>\(s = \sqrt{\frac{\Sigma (X_i - \bar{x})^2 }{n-1}} = \sqrt{\frac{325,009,260}{29}} = 3348 \)</li>
<li>\(\bar{p} = \frac{x}{n} = \frac{19}{30} = 0.63 \)</li>
</ul>
</li>
<li><p>為甚麼樣本標準差分母是？ n-1 觀念說明</p>
<ul>
<li><a href="https://www.researchmfg.com/2016/07/sigma-n-1/" target="_blank" rel="noopener">為什麼統計的樣本標準差計算要除(n-1)而母體標準差則除n？ - 電子製造，工作狂人 </a></li>
<li><a href="https://mathcenter.ck.tp.edu.tw/Resources/Ctrl/ePaper/eArticleDetail.aspx?id=c4181f30-955f-4063-87ea-576b0f318c73" target="_blank" rel="noopener">淺談自由度 (樣本標準差公式中的分母為什麼要採用 n-1 ) - 教育部高中數學學科電子報</a></li>
</ul>
</li>
</ul>
<h4 id="比對-原始資料"><a href="#比對-原始資料" class="headerlink" title="比對 - 原始資料"></a>比對 - 原始資料</h4><blockquote>
<p><img src="/images/statistics-ch7/6.PNG" alt=""></p>
</blockquote>
<h2 id="Sampling-Distribution-of-bar-x"><a href="#Sampling-Distribution-of-bar-x" class="headerlink" title="Sampling Distribution of \(\bar{x} \)"></a>Sampling Distribution of \(\bar{x} \)</h2><p>就是要找出母體平均數。</p>
<ul>
<li>Expected Value of \(\bar{x} \)<br>公式為 \(E(\bar{x})=\mu \)，其中 \(\mu \) 為母體平均值</li>
<li>Standard Deviation of \(\bar{x} \) <ul>
<li>\(\sigma_{\bar{x}} \) 為<strong>樣本</strong>標準差，也稱為<strong>標準誤(standard error)</strong></li>
<li>\(\sigma \) 為<strong>母體</strong>標準差</li>
<li>\(n \) 為樣本大小</li>
<li>\(N \) 為母體大小</li>
<li>Finite Population 有限母體公式<ul>
<li>\(\sigma_x = \sqrt{\frac{N-n}{N-1}}(\frac{\sigma}{\sqrt{n}})\)</li>
<li>其中前項為校正因子(\(\sqrt{\frac{N-n}{N-1}}\))用來修正數值，但當 N 的數量趨近無限大時，校正因子幾乎會被視為零。</li>
<li>當 \(n/N \leq 0.05 \) 時，就可以使用無限母體公式會更好計算，校正因子也幾乎變為零</li>
<li>當 \(\frac{n}{N} &gt; 0.05 \) 時，\(\bar{x} \) 為常態分配</li>
</ul>
</li>
<li>Infinite Population 無限母體公式<br>\(\sigma_x = \frac{\sigma}{\sqrt{n}}\) 且 \(\bar{x} \) 為常態分配</li>
</ul>
</li>
<li>\(\bar{x} \) 服從常態分配有以下情況<ul>
<li>樣本資料大於等於 30 筆資料時</li>
<li>如果有高度偏態(skew)或是 outliers(離群值)太多時，只要樣本資料大於 50 筆也會是常態分配</li>
</ul>
</li>
<li>透過機率來說明 \(\bar{x} \) 有多靠近母體平均值</li>
</ul>
<h2 id="Central-Limit-Theorem-中央極限定理"><a href="#Central-Limit-Theorem-中央極限定理" class="headerlink" title="Central Limit Theorem (中央極限定理)"></a>Central Limit Theorem (中央極限定理)</h2><p>中央極限定理提出越是大量的樣本抽取數量其圖形會逐漸變成常態分佈的形狀</p>
<h3 id="透過圖形來證明"><a href="#透過圖形來證明" class="headerlink" title="透過圖形來證明"></a>透過圖形來證明</h3><ul>
<li>Population 2 的圖形通常稱為兔耳型圖圖</li>
</ul>
<blockquote>
<p><img src="/images/statistics-ch7/7.PNG" alt=""><br><img src="/images/statistics-ch7/8.PNG" alt=""></p>
</blockquote>
<p>我們透過上面的圖可以推出無論是什麼樣的圖都可以推出常態分布的樣本分配，只要樣本資料夠多</p>
<h3 id="舉例-我們想找出離母體平均數加減-10-分有多少數量，也就是我們想要找-1687-1707-間的母體數量"><a href="#舉例-我們想找出離母體平均數加減-10-分有多少數量，也就是我們想要找-1687-1707-間的母體數量" class="headerlink" title="舉例 - 我們想找出離母體平均數加減 10 分有多少數量，也就是我們想要找 1687 ~ 1707 間的母體數量"></a>舉例 - 我們想找出離母體平均數加減 10 分有多少數量，也就是我們想要找 1687 ~ 1707 間的母體數量</h3><p>我們在先前的舉例中算出 \(\sigma_x = \frac{\sigma}{\sqrt{n}} = \frac{87.4}{\sqrt{30}} = 15.96 \)</p>
<blockquote>
<p><img src="/images/statistics-ch7/9.PNG" alt=""></p>
</blockquote>
<p>現在我們先計算 z 值來轉換成標準常態機率分配，\(z = (1707 - 1697) / 15.96 = 0.63 \)，查表可以看到 z = 0.63 時機率為 0.7357，再來 \(z = (1687 - 1697) / 15.96 = -0.63 \)，查表可以得出 0.2643，兩個相減就等於 0.4714</p>
<h3 id="舉例-根據上面的例子，我們現在抽樣-100-樣本，我們想要找-1687-1707-間的母體數量"><a href="#舉例-根據上面的例子，我們現在抽樣-100-樣本，我們想要找-1687-1707-間的母體數量" class="headerlink" title="舉例 - 根據上面的例子，我們現在抽樣 100 樣本，我們想要找 1687 ~ 1707 間的母體數量"></a>舉例 - 根據上面的例子，我們現在抽樣 100 樣本，我們想要找 1687 ~ 1707 間的母體數量</h3><p>這時候 \(E(x)\) 不變，母體平均值還是 1697。</p>
<p>但因為我們的抽取樣本數量改變，因此標準差改變，透過標準差公式也就變成，\(\sigma_x = \sqrt{\frac{N-n}{N-1}}(\frac{\sigma}{\sqrt{n}}) = \frac{900-100}{900-1}(\frac{87.4}{\sqrt{100}}) = 0.9433(8.74) = 8.2\)</p>
<p>跟上一個舉例進行比較，可以得證當樣本數量變大時，會符合中央極限定理</p>
<blockquote>
<p><img src="/images/statistics-ch7/10.PNG" alt=""></p>
</blockquote>
<p>因為圖形不同，因此區間面積也不同需要再重新計算，當 n = 100 時，\(P(1687 \leq \bar{x} \leq 1707 ) = 0.7776\)</p>
<h2 id="Sampling-Distribution-of-bar-p"><a href="#Sampling-Distribution-of-bar-p" class="headerlink" title="Sampling Distribution of \(\bar{p} \)"></a>Sampling Distribution of \(\bar{p} \)</h2><p>透過抽取 n 個元素的隨機樣本，計算\(\bar{p} \)之後再推論 \(p\)。</p>
<ul>
<li>Expected Value of \(\bar{p} \)<br>公式為 \(E(\bar{p}) = p \)</li>
<li>Standard Deviation of \(\bar{p} \) <ul>
<li>\(\sigma_{\bar{p}} \) 為<strong>樣本</strong>標準差，也稱為<strong>標準誤(standard error)</strong></li>
<li>\(\sigma \) 為<strong>母體</strong>標準差</li>
<li>\(n \) 為樣本大小</li>
<li>\(N \) 為母體大小</li>
<li>當 \(np &gt; 5 \) 時，\(n(1-p) \geq 5 \) 為常態分配</li>
<li>Finite Population 有限母體公式<ul>
<li>\(\sigma_p = \sqrt{\frac{N-n}{N-1}}(\sqrt{\frac{p(1-p)}{n}})\)</li>
<li>其中前項為校正因子(\(\sqrt{\frac{N-n}{N-1}}\))用來修正數值，但當 N 的數量趨近無限大時，校正因子幾乎會被視為零。</li>
<li>當 \(n/N \leq 0.05 \) 時，就可以使用無限母體公式會更好計算，校正因子也幾乎變為零</li>
</ul>
</li>
<li>Infinite Population 無限母體公式<br>公式為 \(\sigma_p =(\sqrt{\frac{p(1-p)}{n}})\)</li>
</ul>
</li>
</ul>
<h3 id="舉例-有-72-的學生申請宿舍，我們抽樣-30-學生，想請問在此樣本中學生申請宿舍的在-72-加減-0-05-的機率是多少"><a href="#舉例-有-72-的學生申請宿舍，我們抽樣-30-學生，想請問在此樣本中學生申請宿舍的在-72-加減-0-05-的機率是多少" class="headerlink" title="舉例 - 有 72 % 的學生申請宿舍，我們抽樣 30 學生，想請問在此樣本中學生申請宿舍的在 72% 加減 0.05 的機率是多少"></a>舉例 - 有 72 % 的學生申請宿舍，我們抽樣 30 學生，想請問在此樣本中學生申請宿舍的在 72% 加減 0.05 的機率是多少</h3><p>我們先檢查是否有常態分配，n=30, p=0.72，因此 \(np = 30(0.72) = 21.6 \geq 5 \) and \(n(1-p) = 30(0.28) = 8.4 \geq 5 \)，都有大於 5，因此符合使用常態分配條件。</p>
<p>由於這裡我們並不確定母體有多少學生，因此是 Infinite Population，計算就是 \(\sigma_{\bar{p}} = \sqrt{\frac{0.72(1-0.72)}{30}} = 0.082\)</p>
<p>一樣先轉換成 z 值成為標準常態機率分配，\(z = (0.77-0.72)/0.082 =0.61\)，查表發現 \(0.61z = 0.7291 \)，再來查另外一個值 \(z = (0.67-0.72)/0.082 =-0.61\)，查表發現 \(-0.61z = 0.2709 \)，兩個相減就得出常態分配面積區間，答案為 0.4582。</p>
<p>因此在這樣本中有 \((0.67 * 30) \) ~ \( (0.77 * 30)\) 機率的學生要申請宿舍的機率為 0.4582。</p>
<h3 id="舉例-主管的抽樣分配，題目如下，想詢問抽樣值為平均值-pm-500-的機率為多少"><a href="#舉例-主管的抽樣分配，題目如下，想詢問抽樣值為平均值-pm-500-的機率為多少" class="headerlink" title="舉例 - 主管的抽樣分配，題目如下，想詢問抽樣值為平均值 \(\pm 500\) 的機率為多少"></a>舉例 - 主管的抽樣分配，題目如下，想詢問抽樣值為平均值 \(\pm 500\) 的機率為多少</h3><blockquote>
<p><img src="/images/statistics-ch7/11.PNG" alt=""></p>
</blockquote>
<p>也就是我們要找出 \(P(51300 \leq \bar{x} \leq 52300) \)，的機率是多少，如果用手算的話則需要用到 Z，\(z = \frac{51300-51800}{730.30} = -0.68 \)、\(z = \frac{52300-51800}{730.30} = 0.68 \)</p>
<p>\(P(51300 \leq \bar{x} \leq 52300) \\<br>= P(-0.68 \leq z \leq 0.68 ) \\<br>= P(z \leq 0.68 ) - P(z \leq -0.68 )  \\<br>= 0.7517 - 0.2484 = 0.5034 \)</p>
<h4 id="compare-between-n-30-and-n-100"><a href="#compare-between-n-30-and-n-100" class="headerlink" title="compare between n = 30 and n = 100"></a>compare between n = 30 and n = 100</h4><blockquote>
<p><img src="/images/statistics-ch7/12.PNG" alt=""><br>作法與先前相同，就不贅述</p>
</blockquote>
<h3 id="舉例-承上題，當抽樣數為-100-n-100-，抽樣主管有成功完成教育訓練的標準誤"><a href="#舉例-承上題，當抽樣數為-100-n-100-，抽樣主管有成功完成教育訓練的標準誤" class="headerlink" title="舉例 - 承上題，當抽樣數為 100 (n = 100)，抽樣主管有成功完成教育訓練的標準誤"></a>舉例 - 承上題，當抽樣數為 100 (n = 100)，抽樣主管有成功完成教育訓練的<strong>標準誤</strong></h3><p>旁邊的公式為答案。</p>
<blockquote>
<p><img src="/images/statistics-ch7/13.PNG" alt=""></p>
</blockquote>
<p>60 % 的人會完成員工訓練，因此期望值為 0.6，再來透過公式計算。<br>\(\sigma_{p} = \sqrt{\frac{p(1-p)}{n}} = \sqrt{\frac{0.6(1-0.6)}{30}} = 0.894 \)</p>
<h3 id="舉例-承上題，抽樣主管有成功完成教育訓練的值在期望至-pm-0-05"><a href="#舉例-承上題，抽樣主管有成功完成教育訓練的值在期望至-pm-0-05" class="headerlink" title="舉例 - 承上題，抽樣主管有成功完成教育訓練的值在期望至 \(\pm 0.05 \)"></a>舉例 - 承上題，抽樣主管有成功完成教育訓練的值在期望至 \(\pm 0.05 \)</h3><p>先透過 Z 轉換，之後即可，題目大同小異，透過圖片附上答案。</p>
<blockquote>
<p><img src="/images/statistics-ch7/14.PNG" alt=""></p>
</blockquote>
<h2 id="Propertires-of-Point-Estimators-點估計量的特性"><a href="#Propertires-of-Point-Estimators-點估計量的特性" class="headerlink" title="Propertires of Point Estimators 點估計量的特性"></a>Propertires of Point Estimators 點估計量的特性</h2><ul>
<li>點估計量的符號為 \(\hat{\theta}\)</li>
<li>Unbiased 不偏性<ul>
<li>期望值等於要估計的母體參數  </li>
<li>圖舉例，右邊是 Biased 有偏誤<blockquote>
<p><img src="/images/statistics-ch7/15.PNG" alt=""></p>
</blockquote>
</li>
</ul>
</li>
<li>Efficiency 有效性<ul>
<li>在有兩個抽樣分配的 \(\hat{\theta}\)，且兩個的\(\hat{\theta}\) 位置一樣時，則先取標準差(x 軸)比較少的值</li>
<li>圖舉例 <blockquote>
<p><img src="/images/statistics-ch7/16.PNG" alt=""></p>
</blockquote>
</li>
</ul>
</li>
<li>Consistency 一致性<ul>
<li>當樣本數(n)變大時，標準差則會越來越小，當樣本數越大時則優先使用此點估計量</li>
</ul>
</li>
</ul>
<h2 id="Other-Sampling-Methods-其他抽樣方法"><a href="#Other-Sampling-Methods-其他抽樣方法" class="headerlink" title="Other Sampling Methods 其他抽樣方法"></a>Other Sampling Methods 其他抽樣方法</h2><ul>
<li>機率抽樣<br>每一個母體元素都有一個特定的機率被選為抽樣樣本</li>
<li>非機率抽樣<br>由於我們沒辦法預估每一個母體元素機率為多少，因此稱為<strong>非機率抽樣</strong>。</li>
<li>找出最適合的抽樣方法<strong>最重要</strong>。</li>
</ul>
<h3 id="機率抽樣-Stratified-Random-Sampling-分層隨機抽樣"><a href="#機率抽樣-Stratified-Random-Sampling-分層隨機抽樣" class="headerlink" title="機率抽樣 - Stratified Random Sampling 分層隨機抽樣"></a>機率抽樣 - Stratified Random Sampling 分層隨機抽樣</h3><ul>
<li>strata<br>將母體分成好幾組</li>
<li>母體的每一個元素都必須被使用分組，且只能使用一次</li>
<li>每一組的元素同質性越高越好<br>可以根據年齡、工作部門、產業來區分 </li>
<li>有符合上述條件時，精準度會集高且抽樣資料不須太多</li>
<li>圖表<blockquote>
<p><img src="/images/statistics-ch7/17.PNG" alt=""></p>
</blockquote>
</li>
</ul>
<h3 id="機率抽樣-Cluster-Sampling-叢式-集群抽樣"><a href="#機率抽樣-Cluster-Sampling-叢式-集群抽樣" class="headerlink" title="機率抽樣 - Cluster Sampling 叢式/集群抽樣"></a>機率抽樣 - Cluster Sampling 叢式/集群抽樣</h3><ul>
<li>clusters<br>將母體分組，每組<strong>同質性極低</strong>，小生態圈</li>
<li>接下來抽出幾群，那些就是我們的抽樣資料</li>
<li>Sampling<br>透過市區、學校來抽樣</li>
<li>Advantage<br>節省成本</li>
<li>Disadvantage<br>抽樣資料比分成抽樣的資料需要更大些，才符合真實性</li>
<li>圖表<blockquote>
<p><img src="/images/statistics-ch7/18.PNG" alt=""></p>
</blockquote>
</li>
</ul>
<h3 id="機率抽樣-Systematic-Sampling-系統抽樣"><a href="#機率抽樣-Systematic-Sampling-系統抽樣" class="headerlink" title="機率抽樣 - Systematic Sampling 系統抽樣"></a>機率抽樣 - Systematic Sampling 系統抽樣</h3><ul>
<li>先將母體資料打亂後再進行編號</li>
<li>從母體(N)抽出樣本(n)，那我們就是 \(y = N/n\) 為我們要抽出的元素量(y)</li>
<li>再透過母體資料編號，<code>for(i = 0 ; i&lt;= y ; i++)</code>，找出我們的抽樣元素</li>
<li>Advantage<br>簡單</li>
</ul>
<h3 id="非機率抽樣-Convenience-Sampling-便利抽樣"><a href="#非機率抽樣-Convenience-Sampling-便利抽樣" class="headerlink" title="非機率抽樣 - Convenience Sampling 便利抽樣"></a>非機率抽樣 - Convenience Sampling 便利抽樣</h3><ul>
<li>透過非機率抽樣</li>
<li>Sampling<br>如發傳單，因為沒辦法得知收到傳單與沒收到傳單的機率。</li>
<li>Advantage<br>抽樣很方便</li>
<li>Disadvantage<br>沒辦法很精準的代表母體</li>
</ul>
<h3 id="非機率抽樣-Judgment-Sampling-判斷抽樣"><a href="#非機率抽樣-Judgment-Sampling-判斷抽樣" class="headerlink" title="非機率抽樣 - Judgment Sampling 判斷抽樣"></a>非機率抽樣 - Judgment Sampling 判斷抽樣</h3><ul>
<li>透過個人的知識去推斷出母體那些值可以被參考</li>
<li>例如記者想詢問立委對環保的意見<br>記者可以找出對比較熟悉環保的立委進行尋問</li>
<li>Advantage<br><del>可以造謠，</del>比較簡單。</li>
<li>Disadvantage<br>很看記者素質</li>
</ul>
]]></content>
      <categories>
        <category>北科上課筆記</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>統計學筆記</tag>
        <tag>北科大二上統計學筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>投資學 筆記 - 股票資產組合管理基礎篇(報酬與風險)</title>
    <url>/2020/12/02/NTUT_note/investment-stock-Asset-Portfolio-Management-Basic/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊與財金管理系大二上投資學重點整理<br><font color="#dd0000">並非所有人都適用，部分對我而言稍加容易的內容並不會寫在此內。</font><br>本章主要內容</p>
<ul>
<li>量化金融資產用預期報酬與風險</li>
<li>了解預期報酬與風險</li>
<li>透過過去歷史資料計算每種資產預期報酬率</li>
</ul>
</blockquote>
<a id="more"></a>

<h2 id="名目利率與實質利率和報酬率"><a href="#名目利率與實質利率和報酬率" class="headerlink" title="名目利率與實質利率和報酬率"></a>名目利率與實質利率和報酬率</h2><h3 id="實質利率"><a href="#實質利率" class="headerlink" title="實質利率"></a>實質利率</h3><p>每借 1 元，一年所要付出的代價，反之亦同。</p>
<p>\(實際利率 \approx 名目利率 - 通貨膨脹率 \)</p>
<h3 id="名目利率"><a href="#名目利率" class="headerlink" title="名目利率"></a>名目利率</h3><p>名目利率會隨著預期通貨膨脹率同步增加，公式則是 \(rn = rr + E(i) \)。</p>
<ul>
<li>\(rn\) 名目年利率</li>
<li>\(rr\) 實際年利率</li>
<li>\(E(i)\) 下一期通貨膨脹率的預測</li>
</ul>
<h3 id="報酬率"><a href="#報酬率" class="headerlink" title="報酬率"></a>報酬率</h3><p>\(預期報酬率 = 無風險利率 + 承擔通貨膨脹風險\)，換句換說則表示 \(金融資產的預期報酬 = 無風險利率+各種可能風險之溢酬\)</p>
<h2 id="金融資產可能的風險溢酬"><a href="#金融資產可能的風險溢酬" class="headerlink" title="金融資產可能的風險溢酬"></a>金融資產可能的風險溢酬</h2><ul>
<li>物價膨脹風險溢酬</li>
<li>信用與違約風險溢酬</li>
<li>變現性風險溢酬</li>
<li>到期日風險溢酬</li>
</ul>
<h3 id="預期報酬與實際報酬"><a href="#預期報酬與實際報酬" class="headerlink" title="預期報酬與實際報酬"></a>預期報酬與實際報酬</h3><ul>
<li>無風險利率<br>將資金投資於短期政府國庫券、銀行存款能賺取的報酬率</li>
<li>風險溢酬<br>股票風險與無風險利率的差距，則稱為股票的風險溢酬</li>
<li>超額報酬<br>風險性資產的實際報酬高於國庫券利率水準的為超額報酬，超額報酬的標準差很合適做為<strong>風險衡量值</strong></li>
</ul>
<h3 id="金融資產的預期報酬率與風險"><a href="#金融資產的預期報酬率與風險" class="headerlink" title="金融資產的預期報酬率與風險"></a>金融資產的預期報酬率與風險</h3><p>持有期間報酬 (HPR) 為\(HPR = \frac{期末股價-期初股價+現金股利}{期初股價}\)</p>
<h4 id="報酬的機率分配"><a href="#報酬的機率分配" class="headerlink" title="報酬的機率分配"></a>報酬的機率分配</h4><p>設第 s 種情境的持有期間報酬 \(r(s)\)<br>第 s 種情境的發生機率 \(p(s)\)</p>
<ul>
<li>預期報酬為機率分配的期望值<br>\(E(r) =\Sigma p(s)r(s)  \)</li>
<li>風險為機率分配的標準差(變異數取平方根)<br>\(\sigma^2 = \Sigma p(x)[r(s)-E(r)]^2\)<h5 id="例題"><a href="#例題" class="headerlink" title="例題"></a>例題</h5><blockquote>
<p><img src="/images/investment-stock-Asset-Portfolio-Management-Basic/1.PNG" alt=""><br><img src="/images/investment-stock-Asset-Portfolio-Management-Basic/2.PNG" alt=""></p>
</blockquote>
</li>
</ul>
<h2 id="預期報酬與風險的估計"><a href="#預期報酬與風險的估計" class="headerlink" title="預期報酬與風險的估計"></a>預期報酬與風險的估計</h2><p>資產報酬的真實分配可視為母體，一般會用樣本資料推估，使用過去的歷史資料作為樣本來推估資產的預期報酬與波動是非常有用的方法之一</p>
<h3 id="樣本平均數"><a href="#樣本平均數" class="headerlink" title="樣本平均數"></a>樣本平均數</h3><p>樣本平均數則表示報酬率分配的期望值，樣本標準差則為報酬率分配的標準差。</p>
<p>先找出一段時間的每一期(如每天、每月或每年)的期間實際報酬率計算，再做為樣本計算樣本平均數與標準差</p>
<h4 id="樣本平均報酬-共有兩種辦法"><a href="#樣本平均報酬-共有兩種辦法" class="headerlink" title="樣本平均報酬 (共有兩種辦法)"></a>樣本平均報酬 (共有兩種辦法)</h4><ul>
<li>算術平均報酬<br>\(\bar{r_{A}} = \frac{r_1 + r_2 + … + r_n}{n} \)</li>
<li>幾何平均報酬<br>\(\bar{r_G} = \sqrt[n]{(1+r_1) * (1+r_2) * … * (1+r_n) } -1\)</li>
<li>算術與幾何平均報酬比較<ul>
<li>幾何平均報酬以<strong>每期末投資計算複利</strong>收益較精確</li>
<li>算數大於幾何報酬率時，稱為<strong>平均數不等式</strong></li>
<li>\(幾何平均 = 算數平均 - 1/2 \sigma^2\)<h4 id="例題-1"><a href="#例題-1" class="headerlink" title="例題"></a>例題</h4><blockquote>
<p><img src="/images/investment-stock-Asset-Portfolio-Management-Basic/3.PNG" alt=""></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="樣本標準差"><a href="#樣本標準差" class="headerlink" title="樣本標準差"></a>樣本標準差</h3><p>樣本標準差公式為 \(\sigma = \sqrt{\frac{1}{n-1} \sum_{t=1}^{n} (r_t - \bar{r_A})^2 } \)</p>
<h4 id="例題-2"><a href="#例題-2" class="headerlink" title="例題"></a>例題</h4><blockquote>
<p><img src="/images/investment-stock-Asset-Portfolio-Management-Basic/4.PNG" alt=""></p>
</blockquote>
<h2 id="國庫券風險與報酬"><a href="#國庫券風險與報酬" class="headerlink" title="國庫券風險與報酬"></a>國庫券風險與報酬</h2><p>國庫券通常視為最沒有風險的金融資產，但他還是用通貨膨脹的風險。</p>
<h2 id="風險性資產組合的歷史報酬與風險"><a href="#風險性資產組合的歷史報酬與風險" class="headerlink" title="風險性資產組合的歷史報酬與風險"></a>風險性資產組合的歷史報酬與風險</h2><p>只要有投資風險的資產都被稱為風險性資產</p>
<ul>
<li>高帳面市值比則稱為價值型股票組合</li>
<li>低帳面市值比則稱為成長型股票組合</li>
</ul>
<h3 id="名詞解釋"><a href="#名詞解釋" class="headerlink" title="名詞解釋"></a>名詞解釋</h3><ul>
<li>市值<br>\(流通在外股數 * 每股市價 \)</li>
<li>帳面市價比<br>\( 每股帳面價值 / 每股市價 \)</li>
<li>價值型股票<br>股價相對獲利能力被低估的股票</li>
<li>成長型股票<br>股價相對於目前的獲利能力被高估的股票</li>
</ul>
]]></content>
      <categories>
        <category>北科上課筆記</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>北科大二上投資學筆記</tag>
        <tag>北科大大二上投資學期中考筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>投資學 筆記 - 股票資產組合管理資產組合與資本資產定價模型篇</title>
    <url>/2020/12/03/NTUT_note/investment_stock_asset_profolio_and_capital_asset_pricing_model/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊與財金管理系大二上投資學重點整理<br><font color="#dd0000">並非所有人都適用，部分對我而言稍加容易的內容並不會寫在此內。</font><br>本章主要內容</p>
<ul>
<li>資產多元化配置以降低風險</li>
<li>判斷市場均衡時定出資本資產定價模型，並判定個別資產是否有被高估或低估</li>
</ul>
</blockquote>
<a id="more"></a>

<h2 id="資金配置於風險及無風險兩個組合"><a href="#資金配置於風險及無風險兩個組合" class="headerlink" title="資金配置於風險及無風險兩個組合"></a>資金配置於風險及無風險兩個組合</h2><p>資金配置是指將資金配置到數種不同的資產類別，</p>
<h3 id="無風險資產"><a href="#無風險資產" class="headerlink" title="無風險資產"></a>無風險資產</h3><p><strong>真正的無風險資產可以對抗違約風險、利率風險、通貨膨脹風險的金融資產</strong>，實務上通常將國庫券視為無風險資產，但實務上一般投資人將定存單(CD)、商業本票(CP)或貨幣市場基金視為無風險資產，但因為是短期工具，因此對利率與通貨膨脹反映比較有限。</p>
<p>相較於國庫券，CP 與 CD 的殖利率較高，但發生金融動盪時，實際上與國庫券的殖利率差也會突然暴增。</p>
<p>通常在大型事件發生時，大部份投資人會轉向無風險資產，如第一次石油危機、股市崩盤。</p>
<h3 id="單一風險資產與單一無風險資產組合"><a href="#單一風險資產與單一無風險資產組合" class="headerlink" title="單一風險資產與單一無風險資產組合"></a>單一風險資產與單一無風險資產組合</h3><h4 id="名詞定義"><a href="#名詞定義" class="headerlink" title="名詞定義"></a>名詞定義</h4><ul>
<li>\(C=P+F\)，C = 財富金額、P = 投資於風險資產、F = 投資無風險資產，<del>廢話</del>。</li>
<li>\(r = 報酬 \) </li>
<li>風險資產 P 的預期報酬與風險以 \(E(r_p)\)及 \(\sigma_p\)表示</li>
<li>\(y = 無風險資產 \)、 \( 1-y = 風險資產 \)</li>
</ul>
<h3 id="舉例找出資產組合的資本配置線-CAL-："><a href="#舉例找出資產組合的資本配置線-CAL-：" class="headerlink" title="舉例找出資產組合的資本配置線 (CAL)："></a>舉例找出資產組合的資本配置線 (CAL)：</h3><p><del>這次沒有圖片拉，大衛用手打的</del></p>
<p>有下列兩種風險資產 p and f :</p>
<p>如果  \(E(r_p) = 15\%\)、\(\sigma_p = 22\%\)，且 \(E(r_p)-r_f = 7 \% \) 則完整組合的報酬率與風險分別為：<br>\(E(r_c) = y * 15\% + (1-y) * 7\% \)<br>\(\sigma_c^2 = Var(r_c) = Var(y* r_p + (1-y) * r_F) = y^2 \sigma_{P}^2 = y * \sigma_P = y * 22 \%  \)</p>
<p>將資產組合預期報酬率作為縱軸、標準差做為橫軸並將 y=0 and y=1 的兩個座標連起來則可以得到資本配置線 (CAL)</p>
<blockquote>
<p><img src="/images/investment_stock_asset_profolio_and_capital_asset_pricing_model/24.PNG" alt=""></p>
</blockquote>
<h3 id="資本配置線"><a href="#資本配置線" class="headerlink" title="資本配置線"></a>資本配置線</h3><p>當資本配置線的 y(標準差)，介於 0 與 1 之間時表示投資人資金分配在兩種不同資產；但相對投資人如果<strong>不分配無風險資產且借入資金購買風險資產</strong>則表示 \(y &gt; 1\)，也就是投資人不止將全部的資金都投資在風險資產上，同時還用無風險利率借入資金投資風險資產</p>
<blockquote>
<p><img src="/images/investment_stock_asset_profolio_and_capital_asset_pricing_model/25.PNG" alt=""></p>
</blockquote>
<p>根據前面的例題配合上方圖片的 y = 140% 時，投資人完整組合的預期報酬率與風險如下：\(E(r_C)=7\% + y * (15\% - 7\%) = 7\% + 140\% * (15\% - 7\%) = 18.2\% \)<br>\(\sigma_C = y * 22\% = 140\% * 22\% = 30.8\% \)</p>
<h4 id="CAL-的方程式"><a href="#CAL-的方程式" class="headerlink" title="CAL 的方程式"></a>CAL 的方程式</h4><p>透過點斜式計算方程式，透過 F 或 P 其中一點找出該直線的斜率，斜率的計算方式則是 \(\frac{E(r_P)-r_F}{\sigma_P}\)，此斜率的意義為：平均每一一單位風險所要求的風險溢酬，也就是後面提到的<a href="#Sharpe_ratio_找出兩個風險資產最適配置">Sharpe_ratio</a>因此該直線的方程式為 \(E(r_C) = r_F+\frac{E(r_P)-r_F}{\sigma_P} * \sigma_C = r_F + \frac{\sigma_C}{\sigma_P} * [E(r_P)-r_F ]\)</p>
<ul>
<li>實務上通常借款利率會比無風險利率高，<del>不然就不會有人借你</del>，此時 CAL 會有所變化，不再是原本的一直線，因為會變成報酬利率減去借款利率，用圖來說明，假設 \(r_B = 9\% &gt; 7\% = r_F \)<blockquote>
<p><img src="/images/investment_stock_asset_profolio_and_capital_asset_pricing_model/26.PNG" alt=""></p>
</blockquote>
</li>
</ul>
<h4 id="例題"><a href="#例題" class="headerlink" title="例題"></a>例題</h4><blockquote>
<p><img src="/images/investment_stock_asset_profolio_and_capital_asset_pricing_model/27.PNG" alt=""><br><img src="/images/investment_stock_asset_profolio_and_capital_asset_pricing_model/28.PNG" alt=""></p>
</blockquote>
<h2 id="被動投資策略與資本市場線"><a href="#被動投資策略與資本市場線" class="headerlink" title="被動投資策略與資本市場線"></a>被動投資策略與資本市場線</h2><p>被動投資策略為認定所有金融資產都充分表達在價格，因此不直接或間接分析證券價值來建立資產組合，而改成直接投資與市場指數相同報酬的組合。</p>
<p>如果一個投資者採用被動投資策略，則風險組合只會選擇含系統風險的指數型基金或追蹤市場指數的 ETF，也就是<strong>資本配置線(CAL)</strong>，中的 P 點為指數基金或 ETF，這時候的 CAL 則變成資本市場線(CML)。</p>
<p>通常 CML 表示投資人以被動投資策略搭配國庫券的各種投資機會集合。</p>
<p>資本配置線(CAL) 為風險資產與任一風險組合的連線</p>
<h3 id="名詞解釋"><a href="#名詞解釋" class="headerlink" title="名詞解釋"></a>名詞解釋</h3><ul>
<li>CML 中的 P 點為市場組合</li>
<li>\(E(r_m)\) 為預期報酬率</li>
<li>\(\sigma_m\) 為風險</li>
<li>CML 的數學方程式則是 \(E(r_C)= r_F + \frac{E(r_M)-r_F}{\sigma_M} * \sigma_C\)</li>
</ul>
<h2 id="Reviews"><a href="#Reviews" class="headerlink" title="Reviews"></a>Reviews</h2><ul>
<li>期望值的定義<br>\(E(X) = \sum_{i=1}^N P(X_i)X_i \)</li>
<li>運算規則<ul>
<li>\(E(aX+b) = aE(X) + b\)</li>
<li>\(E(aX+bY) =  aE(X) + bE(Y) \)</li>
</ul>
</li>
<li>變異數與共變異數的定義<ul>
<li>\(V(X) = \sigma_X^2 = E(X^2)-[E(X)]^2 \)</li>
<li>\(Cov(X,Y) =\sigma_{X,Y} = E(XY)-E(X)E(Y) \)</li>
<li>\(Cov(X,X) = \sigma_{X,X} = V(X) = \sigma_X^2 \)</li>
</ul>
</li>
<li>變異數與共變異數的運算規則<ul>
<li>\(V(aX+b) = V(aX) = a^2V(X) = a^2 \sigma_X^2 \)</li>
<li>\(V(aX \pm bY)=V(aX) + V(bY) \pm 2ab Cov(X,Y) = a^2 \sigma_X^2 + b^2 \sigma_Y^2 \pm 2ab \sigma_{X,Y}  \)</li>
<li>\(Cov(aX+bY , Z) = Cov(aX,Z) + Cov(bY,Z) = aCov(X,Z) + bCov(Y,Z) = a \sigma_{X,Z} + b \sigma_{Y,Z} \)</li>
</ul>
</li>
</ul>
<h2 id="兩種風險性資產組合"><a href="#兩種風險性資產組合" class="headerlink" title="兩種風險性資產組合"></a>兩種風險性資產組合</h2><p>假設兩種資產分別為 D and S，投資 D 的資金比重為 \(w_D\)，投資於 S 的資金比重為 \(w_S\)，且 \(w_D + w_S = 1\)，則此風顯資產組合報酬率為 \(r_p = w_D * r_D + w_S * r_S\)</p>
<ul>
<li>資產組合的預期報酬率<br>\(E(r_p) = E(w_D * r_D + w_S * r_S) = w_D * E(r_D) + w_S * E(r_S) \)</li>
<li>變異數<br>\(\sigma_{P}^2 = V(r_P) \\ = w_D^2 * \sigma_D^2 + w_S^2 * \sigma_S^2 + 2 w_D w_S \sigma_{D,S} \\ = w_D^2 * \sigma_D^2 + w_S^2 * \sigma_S^2 + 2 w_D w_S \sigma_{D} \sigma_{S} \rho_{D,S}  \)</li>
<li>\(\rho_{D,S} \) 為 D 及 S 報酬率的相關係數，\( -1 \leq \rho_{D,S} \leq 1 \)</li>
</ul>
<h3 id="相關係數"><a href="#相關係數" class="headerlink" title="相關係數"></a>相關係數</h3><p>相關係數是一種統計工具，用來衡量兩個隨機變數的線性關係，其值介於 -1 ~ +1。<br>公式為  \( \rho_{a,b} = \frac{\sigma_{a,b}}{\sigma_a \sigma_b}\)</p>
<h4 id="係數說明"><a href="#係數說明" class="headerlink" title="係數說明"></a>係數說明</h4><ul>
<li>相關係數為正時表示兩變數為正相關</li>
<li>為負時表示兩變數成負相關</li>
<li>為零時表示兩者變動互不相關</li>
</ul>
<h4 id="說明"><a href="#說明" class="headerlink" title="說明"></a>說明</h4><ul>
<li>當 \(\rho_{D,S} = 1 \) 表示兩者完全正相關，因此當 D 及 S 報酬率爭相關時，資產組合的標準差為兩資產個別標準查的加權平均，其係數為投資比重</li>
<li>當 \(\rho_{D,S} = -1 \) 表示兩者完全負相關，因此表示為對沖性的資產組合，可以降低資產組合的粽風險，因此對於其他組合，喜歡規避風險的投資人會喜歡對沖姓資產組合</li>
<li>只要相關係數不是完全正相關，則風險會比個別資產的風險低，因此只要相關係數不等於 1 就有分散風險效果，-1 時降低風險效果最大</li>
</ul>
<h4 id="例題-1"><a href="#例題-1" class="headerlink" title="例題"></a>例題</h4><p>假設 \(E(r_D) = 0.08\)，\(E(r_S) = 0.13\)、\(\sigma_D = 0.12\)、\(\rho_{D,S} = 0.3\)，則風險最小的資產配置為？</p>
<p>由於 \(w_D + w_S = 1 \)，且 \(\sigma_{p}^{2} \geq 0\)，因此一定存在全域最小值，求解時只需要利用一階必要條件。<br>\(\frac{d \sigma_{P}^{2}}{d w_D} = 2(0.12)^2 w_D  + 2(0.2)^2(1-w_D)(-1) \\ + 2(0.12)(0.2)(0.3)-2 * 2(0.12)(0.2)(0.3) w_D = 0 \)<br>需要注意的是最後兩項 \(w_D w_S = (1-w_D)w_D = w_D - w_D^2\)，因此式子會變得非常複雜QQ。</p>
<p>答案： \(w_D = 0.82\), \(w_S = 1 - w_D = 0.18 \)；\(E(r_p) = 0.089\)，\(\sigma_{P}^{2} = (0.115)^2 \)</p>
<p>紅色圈圈為註解：</p>
<blockquote>
<p><img src="/images/investment_stock_asset_profolio_and_capital_asset_pricing_model/1.PNG" alt=""></p>
</blockquote>
<ol>
<li>\( E(r_P) = 0.08(w_D) + 0.13(1 - w_D) = 0.08(w_D) + 0.13 - 0.13(w_D)\)<br>放大 20 倍後並移項則變成 \(20 E(r_P) = (w_D) + 2.6(1 - w_D)\)</li>
<li>透過 1. 推出 \((1-w_D) = w_S \)，就變成 \(w_S = -1.6 + 20E(r_p)\)，再把 \(w_S \) 改回 \(1-w_D\) 即可</li>
<li>真的太複雜了，我真的不算</li>
</ol>
<h2 id="股票、債券及無風險資產所構成組合的最適選擇"><a href="#股票、債券及無風險資產所構成組合的最適選擇" class="headerlink" title="股票、債券及無風險資產所構成組合的最適選擇"></a>股票、債券及無風險資產所構成組合的最適選擇</h2><p>如果有兩個風險資產與一個無風險資產時，通常是先決定好兩個風險資產的最適當配置，再將其視為一個風險資產，將資金分配在一個無風險資產與<strong>合併的一個風險資產</strong></p>
<blockquote>
<p><img src="/images/investment_stock_asset_profolio_and_capital_asset_pricing_model/2.PNG" alt=""></p>
</blockquote>
<p>我們在<a href="#單一風險資產與單一無風險資產組合">前面章節</a>已經知道 CAL 為無風險資產與任一風險組合的連線</p>
<h3 id="Sharpe-ratio-找出兩個風險資產最適配置"><a href="#Sharpe-ratio-找出兩個風險資產最適配置" class="headerlink" title="Sharpe ratio 找出兩個風險資產最適配置"></a>Sharpe ratio 找出兩個風險資產最適配置</h3><p>Sharpe ratio 可以用來作為資產組合績效的指標，績效越好的資產組合會是投資人所偏愛的組合，因此我們要找出 Sharpe ratio 最大，也就是 CAL 斜率最大的組合，也就是最適當的風險資產組合。</p>
<p>公式為：</p>
<ul>
<li>\(E(r_P) = w_D E(r_D) + w_S E(r_S)\)</li>
<li>\( \sigma_{P}^{2} = w_D^2 * \sigma_D^2 + w_S^2 * \sigma_S^2 + 2 w_D w_S \sigma_{D} \sigma_{S} \rho_{D,S}  \)</li>
<li>找出 \(w_D\)，再找出 \(w_S\) 即可，\(w_S = 1 - w_D \)</li>
<li>\(\text{Sharpe_Ratio}  = (報酬率 - 無風險利率) /  標準差 \)<h4 id="舉例"><a href="#舉例" class="headerlink" title="舉例"></a>舉例</h4>\(E(r_D) = 0.08 \), \(E(r_S)=0.13\),\(\sigma_{D} =0.12\),\(\sigma_{S}=0.2\),\(\rho_{D,S}=0.03\)，試問 ratio 極大的資產配置組合、該組合的預期報酬率、標準差與 Sharpe ratio</li>
</ul>
<p>5 % 應該是無風險利率，但此題並沒有說無風險利率是幾 % </p>
<blockquote>
<p><img src="https://imgur.com/I9BTJpD.jpg" alt=""></p>
</blockquote>
<h3 id="將兩個風險資產合併成一個風險資產後，找出風險資產與無風險資產最適配置"><a href="#將兩個風險資產合併成一個風險資產後，找出風險資產與無風險資產最適配置" class="headerlink" title="將兩個風險資產合併成一個風險資產後，找出風險資產與無風險資產最適配置"></a>將兩個風險資產合併成一個風險資產後，找出風險資產與無風險資產最適配置</h3><p>透過 Sharpe ratio 合併兩個風險資產後，將其視為一個風險資產，並找出風險資產與無風險資產最適配置，透過受限制條件下的預期效用函數極大化求值即可。</p>
<p>公式如下： 基本上都是先前的知識結合應用就不贅述</p>
<blockquote>
<p><img src="/images/investment_stock_asset_profolio_and_capital_asset_pricing_model/4.PNG" alt=""></p>
</blockquote>
<h3 id="note-預期效用函數"><a href="#note-預期效用函數" class="headerlink" title="note 預期效用函數"></a>note 預期效用函數</h3><p>設定絕對風險規避衡量值為 A(課本沒有告訴我們怎麼算)，當投資人風險規避 \(A &gt; 0\)，且規避風險越高時 A 值越大，如果投資活動對投資人財富的變動率為常態分配時，則可以推出預期效用函數 \(U = U(E(r),\sigma ) = E(r) - \frac{1}{2}A \sigma^2\)</p>
<p>注意，這裡的 \(y = 風險資產\)，與前面的不同</p>
<blockquote>
<p><img src="/images/investment_stock_asset_profolio_and_capital_asset_pricing_model/5.PNG" alt=""><br><img src="/images/investment_stock_asset_profolio_and_capital_asset_pricing_model/6.PNG" alt=""></p>
</blockquote>
<h3 id="複習"><a href="#複習" class="headerlink" title="複習"></a>複習</h3><blockquote>
<p><img src="/images/investment_stock_asset_profolio_and_capital_asset_pricing_model/7.PNG" alt=""></p>
</blockquote>
<h2 id="馬可維茲組合-多種風險資產及一種無風險資產組合的最適選擇"><a href="#馬可維茲組合-多種風險資產及一種無風險資產組合的最適選擇" class="headerlink" title="馬可維茲組合 - 多種風險資產及一種無風險資產組合的最適選擇"></a>馬可維茲組合 - 多種風險資產及一種無風險資產組合的最適選擇</h2><p>此決策方式，與先前提到的方式相同，但他的方程式更為複雜，此方程式的正式名稱為最小變異數前緣 (minimun-variance frontier)</p>
<p>在寫出求解過程前，我們先了解多種風險資產組合的預期報酬率及風險，先來說明一下我們會用的公式，目前我還沒想出標準差是怎麼來的。</p>
<blockquote>
<p><img src="/images/investment_stock_asset_profolio_and_capital_asset_pricing_model/8.PNG" alt=""><br><img src="/images/investment_stock_asset_profolio_and_capital_asset_pricing_model/9.PNG" alt=""><br><img src="/images/investment_stock_asset_profolio_and_capital_asset_pricing_model/10.PNG" alt=""></p>
</blockquote>
<h3 id="效率組合與效率前緣"><a href="#效率組合與效率前緣" class="headerlink" title="效率組合與效率前緣"></a>效率組合與效率前緣</h3><ul>
<li>風險資產效率組合定義<ul>
<li>所有相同期望報酬率組合最低風險</li>
<li>所有相同風險組合中最高預期報酬率</li>
</ul>
</li>
<li>風險資產組合效率前緣<br>效率前緣就是最小變異數(最低風險)，也就是前緣中正斜率處</li>
</ul>
<h4 id="效率前緣"><a href="#效率前緣" class="headerlink" title="效率前緣"></a>效率前緣</h4><p>找出效率式非常麻煩的一件事情，假如有 30 種資產就必須先預測 30 種資產預期報酬率，接著要計算 30 個標準差，再來要計算相關係數，標準差與相關係數共有 435 個。</p>
<p>假如你負責配置資產組合，在有限制條件的情況下建立出的效率前緣條件則會與完全自由無限制時不同，如限制你投資高配息的股票或只能投資某產業等。</p>
<h4 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h4><ul>
<li>決定風險資產組合與無風險資產間配置為 \(y=\frac{E(r_P)-r_F}{A \sigma_{P}^2}\)</li>
<li>風險資產組合的數學模型為<blockquote>
<p><img src="/images/investment_stock_asset_profolio_and_capital_asset_pricing_model/11.PNG" alt=""></p>
</blockquote>
</li>
</ul>
<h3 id="階段性區隔特性-由多種風險資產與一種風險資產構成的資產組合決策"><a href="#階段性區隔特性-由多種風險資產與一種風險資產構成的資產組合決策" class="headerlink" title="階段性區隔特性 - 由多種風險資產與一種風險資產構成的資產組合決策"></a>階段性區隔特性 - 由多種風險資產與一種風險資產構成的資產組合決策</h3><p>風險資產組合建構過程中，最適當的風險資產一定是 \(\rho \) 點，不論他的風險規避程度，也就是風險資產組合的選擇與其風險偏好程度是完全無關，決定過程是<strong>客觀且技術性</strong>。</p>
<p>決定配置比例時，是根據投資人能接受的風險規避，此時決定過程是<strong>主觀且策略性的</strong>，此時投資人根據自身策略在風險資產組合 \(\rho\)點間抉擇，差異只會在風險規避程度不同與資產組合分配比率不同。</p>
<h2 id="風險資產組合之風險分散效果"><a href="#風險資產組合之風險分散效果" class="headerlink" title="風險資產組合之風險分散效果"></a>風險資產組合之風險分散效果</h2><p>透過投資資產多元化可以消除個別資產的獨立風險，主要是透過不同公司的好消息與壞消息，獲得的正報酬與負報酬抵銷，而讓風險分散。</p>
<p>但如果是共同風險，如：市場風險、系統風險，這些風險都沒辦法透過多元化投資不同股票消除，當往好消息成長時，會增加所有報酬，反之亦同。</p>
<h3 id="表達式"><a href="#表達式" class="headerlink" title="表達式"></a>表達式</h3><blockquote>
<p><img src="/images/investment_stock_asset_profolio_and_capital_asset_pricing_model/12.PNG" alt=""><br><img src="/images/investment_stock_asset_profolio_and_capital_asset_pricing_model/13.PNG" alt=""><br><img src="/images/investment_stock_asset_profolio_and_capital_asset_pricing_model/14.PNG" alt=""></p>
</blockquote>
<h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p>根據最後一張圖片的 \(\rho = 0\)，當 n 趨近於無限時，則 \(\sigma_{P}^2 = 0\)，表示完全沒有共同風險。</p>
<p>如果 \(\rho &gt; 0 \)，實務上的正常情況，儘管有些資產的相關係數為負，但整體平均為正，則當 n 趨近於無限時，\(\sigma_{P}^2 \) 趨近於某一正數，且 \(\rho \) 越大則代表資產組合風險越高。</p>
<p>最極端的情況下，\(\rho = 1\)，不論 n 是多少，資產組合的風險都會是\(\sigma_{P}^2 \) 表示資產多元化對於<strong>風險分散完全沒有任何效果</strong></p>
<h2 id="資本資產定價模型-CAPM"><a href="#資本資產定價模型-CAPM" class="headerlink" title="資本資產定價模型 CAPM"></a>資本資產定價模型 CAPM</h2><h3 id="基本觀念"><a href="#基本觀念" class="headerlink" title="基本觀念"></a>基本觀念</h3><ul>
<li>CPAM 是財務領域第一個資產定價模型，雖然假設多且簡化人類投資，但清楚地描述風險資產的預期報酬率與其風險關係。</li>
<li>CAPM 描述的預期報酬與風險關係在實務上的應用</li>
</ul>
<ul>
<li>描述的均衡關係用來判定任何一風險資產是否偏離此關係，從中發現被低估或高估的可能性</li>
<li>描述的預期報酬率可作為資本財的成本，並賴以評估投資案的選擇決策</li>
</ul>
<h3 id="假設條件"><a href="#假設條件" class="headerlink" title="假設條件"></a>假設條件</h3><ol>
<li>所有投資人都是資產價格的接受者，不會因為某些投資人的交易結果而發生重大改變，即風險資產的市場為完全競爭市場。</li>
<li>投資人的活動都是一期，不會有多期</li>
<li>只能投資在市場上交易的資產，如股票</li>
<li>投資人不需要負擔交易稅、佣金，沒有交易成本</li>
<li>投資人的目的都是為了找到效率前緣</li>
<li>所有投資人的未來資產報酬分配具有同質性預期，也就是他們面對的效率前緣完全相同，沒有個別差異</li>
</ol>
<h3 id="重要結論"><a href="#重要結論" class="headerlink" title="重要結論"></a>重要結論</h3><ul>
<li>投資人只能夠持有市場組合(股票、無風險)，投資人之間的差異只有在市場組合的比重不同</li>
<li>市場組合一定是效率前緣上的組合，更是所有投資人面對的最適風險組合，由無風險資產與市場風險組合間的連結為最佳的 CAL，我們稱之為 CML</li>
</ul>
<blockquote>
<p><img src="/images/investment_stock_asset_profolio_and_capital_asset_pricing_model/15.PNG" alt=""></p>
</blockquote>
<h3 id="QUESTION-為何投資人都會持有市場投資組合"><a href="#QUESTION-為何投資人都會持有市場投資組合" class="headerlink" title="QUESTION: 為何投資人都會持有市場投資組合"></a>QUESTION: 為何投資人都會持有市場投資組合</h3><ul>
<li>投資人採用相同平均值 - 變異數分析(假設條件 5 )</li>
<li>投資人將資金投資在相同投資機會 (假設條件 3)</li>
<li>投資人有相同的持有期間 (假設條件 2)</li>
<li>投資人有相同的效率前緣 (假設條件 6)</li>
<li>投資人有相同的交易成本 (假設條件 4)</li>
</ul>
<h3 id="全體投資人必然會選擇持有相同的最適風險投資組合"><a href="#全體投資人必然會選擇持有相同的最適風險投資組合" class="headerlink" title="全體投資人必然會選擇持有相同的最適風險投資組合"></a>全體投資人必然會選擇持有相同的最適風險投資組合</h3><p>根據前面的 QUESTION，投資人可導出相同的效率前緣線，進而得到相同的最適風險性投資組合，即潔具向無風險利率水準的資本配置線與效率前緣線的切點 M，如下圖。</p>
<blockquote>
<p><img src="/images/investment_stock_asset_profolio_and_capital_asset_pricing_model/16.PNG" alt=""></p>
</blockquote>
<h3 id="市場組合的風險溢酬"><a href="#市場組合的風險溢酬" class="headerlink" title="市場組合的風險溢酬"></a>市場組合的風險溢酬</h3><p>投資者每個人都會找到同樣的效率前緣，因此每個人不同只因為每個人有不同的 \(A_i\)，因此平均每個人擁有的無風險資產為 0%，也表示每一個人持有的風險部位為 100%，也就表示市場組合的風險溢酬與市場組合的風險和風險規避平均值呈比率關係。</p>
<blockquote>
<p><img src="/images/investment_stock_asset_profolio_and_capital_asset_pricing_model/17.PNG" alt=""></p>
</blockquote>
<h3 id="CAPM-特性"><a href="#CAPM-特性" class="headerlink" title="CAPM 特性"></a>CAPM 特性</h3><ul>
<li>個別資產的風險溢酬是對整個市場組合的風險大小而定，風險大小等於 beta。<blockquote>
<p><img src="/images/investment_stock_asset_profolio_and_capital_asset_pricing_model/18.PNG" alt=""></p>
</blockquote>
</li>
<li>風險溢酬也亦是如此<blockquote>
<p><img src="/images/investment_stock_asset_profolio_and_capital_asset_pricing_model/19.PNG" alt=""></p>
</blockquote>
</li>
</ul>
<p>市場組合的 beta 值為 1，將組合個別資產的 beta 市值比例加權總計必等於 1，因此推論任何一個資產組合 beta 值大於 1 表示主動性策略，組合中大部分所選的投資產品 beta 值多數大於 1；反之則稱為防禦型投資策略。</p>
<h2 id="證券市場線-SML"><a href="#證券市場線-SML" class="headerlink" title="證券市場線 SML"></a>證券市場線 SML</h2><p>將預期報酬視為 Y 軸，Beta 係數視為 X 軸，則預期報酬與 Beta 則有線性關係，斜率就是市場風險溢酬，如下圖</p>
<blockquote>
<p><img src="/images/investment_stock_asset_profolio_and_capital_asset_pricing_model/20.PNG" alt=""></p>
</blockquote>
<h3 id="SML-應用"><a href="#SML-應用" class="headerlink" title="SML 應用"></a>SML 應用</h3><p>如果某一種風險資產價格被低估則預期報酬率必然高於 SML 線對應的均衡預期報酬率；反之，如果風險資產價格被高估則預期報酬率則會低於 SML 所對應的均衡預期報酬率</p>
<p>通常風險資產組合的預期報酬率與 SML 線所對應的均衡報酬率之間差額為風險資產的 Alpha，部分投資分析則是在尋找 Alpho 的投資組合，在 CAPM 的前提下買入有正 Alpha，賣出負 Alpha 的資產。</p>
<p>如下圖： 下圖為 Alpha 的差額</p>
<blockquote>
<p><img src="/images/investment_stock_asset_profolio_and_capital_asset_pricing_model/21.PNG" alt=""></p>
</blockquote>
<h4 id="例題-2"><a href="#例題-2" class="headerlink" title="例題"></a>例題</h4><blockquote>
<p><img src="/images/investment_stock_asset_profolio_and_capital_asset_pricing_model/22.PNG" alt=""><br>看圖可以得知 0.12 時比 SML 線還高，但 0.13 則比 SML 線還低<br><img src="/images/investment_stock_asset_profolio_and_capital_asset_pricing_model/23.PNG" alt=""></p>
</blockquote>
<h2 id="Fama-and-French-的-3-因子模型"><a href="#Fama-and-French-的-3-因子模型" class="headerlink" title="Fama and French 的 3 因子模型"></a>Fama and French 的 3 因子模型</h2><p>CAPM 的研究發現，單獨市場組合風險溢酬(beta)沒辦法完全解釋資產的風險溢酬，於是考量了其他變數，在此模型中加入了公司規模、帳面市值比兩項因素，模型為 \(E(r_i) = r_F + [E(r_M) - r_F] * \beta_{i,1} + E(SMB) * \beta_{i,2} + E(HML) * \beta_{i,3} \)</p>
<p>上面模型為小公司預期報酬率減大公司預期報酬率，稱為公司規模溢酬；HML為高 B/M 股票預期報酬率減低 B/M 股票預期報酬率，稱為公司價值溢酬。</p>
<h2 id="Fama-and-French-的-4-因子模型"><a href="#Fama-and-French-的-4-因子模型" class="headerlink" title="Fama and French 的 4 因子模型"></a>Fama and French 的 4 因子模型</h2><p>接下來又建立了一個四因子模型，模型為<br>\(E(r_i)=r_F + [E(r_M)-r_F] * \beta_{i,1} + E(SMB) * \beta_{i,2} + E(HML) * \beta_{i,3} + E(PR1YR) * \beta_{i,4}\)</p>
<ul>
<li>PR1YR 前一年動能組合<br>前 12 個月報酬較高的股票，繼續投資能有獲得超額報酬機會，因此我們可以放空前 12 個月低報酬的公司股票組合去投資前 12 個月高報酬公司股票組合來獲得風險溢酬。</li>
</ul>
]]></content>
      <categories>
        <category>北科上課筆記</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>北科大二上投資學筆記</tag>
        <tag>北科大大二上投資學期中考筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>統計學(一) 筆記 - 大二上第二次段考 (L4-L6)</title>
    <url>/2020/12/04/NTUT_note/statistics-1081-mid/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊與財金管理系大二上統計學重點整理<br><font color="#dd0000">並非所有人都適用，部分對我而言稍加容易的內容並不會寫在此內。</font><br><strong>這是觀看影片心得後的筆記，老師上課可能不太適用會忘記抄到</strong></p>
</blockquote>
<a id="more"></a>

<h1 id="Chapter-4-Introduction-to-Probability-介紹機率"><a href="#Chapter-4-Introduction-to-Probability-介紹機率" class="headerlink" title="Chapter 4 Introduction to Probability (介紹機率)"></a>Chapter 4 Introduction to Probability (介紹機率)</h1><h2 id="名詞介紹"><a href="#名詞介紹" class="headerlink" title="名詞介紹"></a>名詞介紹</h2><ul>
<li>Random Experiments 隨機實驗</li>
<li>Counting Rules 計數規則</li>
<li>Assigning Probabilities 分配機率</li>
<li>Event 事件</li>
<li>Conditional Probability 條件機率</li>
<li>Bayes’ Theorem 貝式定理</li>
</ul>
<h2 id="Uncertainties-不確定性"><a href="#Uncertainties-不確定性" class="headerlink" title="Uncertainties 不確定性"></a>Uncertainties 不確定性</h2><p>管理人員對於不確定性的選擇進行分析，如</p>
<ul>
<li>提高物品售價時，銷售機會減少?</li>
<li>透過新的組裝方式會不會增加生產率</li>
<li>新投資獲利的機會會多少</li>
</ul>
<h2 id="Probability-機率"><a href="#Probability-機率" class="headerlink" title="Probability 機率"></a>Probability 機率</h2><ul>
<li>用數字表示事件發生的可能性</li>
<li>機率的值只會在 0 - 1 之間</li>
<li>機率值越靠近零表示越不容易發生</li>
<li>機率值越靠近一表示越容易發生</li>
</ul>
<h2 id="Statistical-Experiments-統計實驗"><a href="#Statistical-Experiments-統計實驗" class="headerlink" title="Statistical Experiments 統計實驗"></a>Statistical Experiments 統計實驗</h2><ul>
<li>統計學中的實驗概念與物理實驗不同</li>
<li>在統計實驗中，機率表示結果</li>
<li>即使實驗完全相同，出來的結果也有可能完全不同</li>
<li>統計實驗有時候又被稱為隨機實驗</li>
</ul>
<h2 id="Random-Experiment-and-Its-Sample-Space-隨機實驗與樣本空間"><a href="#Random-Experiment-and-Its-Sample-Space-隨機實驗與樣本空間" class="headerlink" title="Random Experiment and Its Sample Space 隨機實驗與樣本空間"></a>Random Experiment and Its Sample Space 隨機實驗與樣本空間</h2><ul>
<li>隨機實驗<br>產生一個明顯的實驗結果</li>
<li>樣本空間<br>所有實驗結果的集合(set)</li>
<li>樣本點<br>其中一個實驗結果的集合(set)的一個元素為 sample point(樣本點)</li>
</ul>
<h2 id="A-Counting-Rule-for-Multiple-Step-Experiments-多步驟的實驗技術"><a href="#A-Counting-Rule-for-Multiple-Step-Experiments-多步驟的實驗技術" class="headerlink" title="A Counting Rule for Multiple-Step Experiments 多步驟的實驗技術"></a>A Counting Rule for Multiple-Step Experiments 多步驟的實驗技術</h2><p>如果實驗中需要 k 個步驟，那假設第一步可能有 \(n_1\) 個結果，第二步有 \(n_2\) 個結果，依此類推，那實驗結果的總數為 \(n_1 * n_2 * … * n_k \)。</p>
<p>多步驟實驗的圖形表示大都是<strong>樹狀圖</strong></p>
<h3 id="舉例"><a href="#舉例" class="headerlink" title="舉例"></a>舉例</h3><blockquote>
<p><img src="/images/statistics-1081-mid/1.PNG" alt=""><br><img src="/images/statistics-1081-mid/2.PNG" alt=""></p>
</blockquote>
<h3 id="Counting-Rule-for-Combinations-計數規則的組合"><a href="#Counting-Rule-for-Combinations-計數規則的組合" class="headerlink" title="Counting Rule for Combinations 計數規則的組合"></a>Counting Rule for Combinations 計數規則的組合</h3><p>使用 Combinations 進行計數，在 \(N\) 個實驗中拿出 \( n \) 個結果，則使用 \(C_n^N = \frac{N!}{n!(N-n)!}\)</p>
<p><strong>組合是沒有注意順序的，即 1,2,3 與 1,3,2 視為相同</strong></p>
<h3 id="Counting-Rule-for-Permutations-計數規則的排列"><a href="#Counting-Rule-for-Permutations-計數規則的排列" class="headerlink" title="Counting Rule for Permutations 計數規則的排列"></a>Counting Rule for Permutations 計數規則的排列</h3><p>使用 Permutations 進行計數，在 \(N\) 個實驗中拿出 \(n\) 個結果，使用 \(P_n^N = \frac{N!}{(N-n)!}\)</p>
<p><strong>組合是有注意順序的，即 1,2,3 與 1,3,2 不相同</strong></p>
<h2 id="Assigning-Probabilities-指派機率"><a href="#Assigning-Probabilities-指派機率" class="headerlink" title="Assigning Probabilities 指派機率"></a>Assigning Probabilities 指派機率</h2><h3 id="Basic-Requirements-for-Assigning-Probabilities"><a href="#Basic-Requirements-for-Assigning-Probabilities" class="headerlink" title="Basic Requirements for Assigning Probabilities"></a>Basic Requirements for Assigning Probabilities</h3><ul>
<li>每一個實驗結果機率都必須介於 0-1 之間</li>
<li>所有的實驗結果相加起來必等於 1 </li>
</ul>
<h3 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h3><ul>
<li>Classical Method<br>將所有的實驗結果機率<strong>平均</strong>分配，分配為 \(1 \ n \)</li>
<li>Relative Frequency Method<br>根據<strong>實驗或歷史數據</strong>分配機率，通常是用百分比進行分配</li>
<li>Subjective Method 主觀方法<br>透過<strong>主觀方式</strong>分配機率，爽，想怎麼分配就怎麼分配</li>
<li>通常會結合上面三種方法，來找到最正確的實驗結果機率</li>
</ul>
<h2 id="Events-and-Their-Probabilities-事件與他們的機率"><a href="#Events-and-Their-Probabilities-事件與他們的機率" class="headerlink" title="Events and Their Probabilities 事件與他們的機率"></a>Events and Their Probabilities 事件與他們的機率</h2><ul>
<li>事件是樣本點的集合</li>
<li>每一個事件的機率等同於此事件總和的樣本點機率，如：事件 A 發生機率是 40%，那 A 事件中的每個樣本點發生機率總和一定等於 40%</li>
<li>如果我們可以識別實驗中的每個樣本點並幫她分配機率，就可以算出此事件的機率</li>
<li>事件 = 樣本空間每一個元素分配到的機率</li>
</ul>
<h2 id="Some-Basic-Relationships-of-Probability-機率的基本觀念"><a href="#Some-Basic-Relationships-of-Probability-機率的基本觀念" class="headerlink" title="Some Basic Relationships of Probability 機率的基本觀念"></a>Some Basic Relationships of Probability 機率的基本觀念</h2><ul>
<li>Complement (餘集)<blockquote>
<p><img src="/images/statistics-1081-mid/3.PNG" alt=""></p>
</blockquote>
</li>
<li>Union 聯集<ul>
<li>Addition Law(加法律)<br>\(P(A \cup B) = P(A) + P(B) - P(A \cap B) \)<blockquote>
<p><img src="/images/statistics-1081-mid/4.PNG" alt="">  </p>
</blockquote>
</li>
</ul>
</li>
<li>Intersection 交集<ul>
<li>Multiplication Law(乘法律)<br>\(P(A \cap B) = P(B)P(A|B) = P(A)P(B|A) \)，其中 \(P(A|B)\)為<a href="#Conditional-Probability-條件機率">條件機率</a><blockquote>
<p><img src="/images/statistics-1081-mid/6.PNG" alt=""></p>
</blockquote>
</li>
</ul>
</li>
<li>Mutually Exclusive 互斥<ul>
<li>如果一個事件發生，那另外一個事件就一定無法發聲</li>
<li>Addition Law(加法律)<br>\(P(A \cup B ) = P(A) + P(B) \)<blockquote>
<p><img src="/images/statistics-1081-mid/7.PNG" alt=""></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="Conditional-Probability-條件機率"><a href="#Conditional-Probability-條件機率" class="headerlink" title="Conditional Probability 條件機率"></a>Conditional Probability 條件機率</h2><p>一個事件(A)中又發生另外一個事件(B)的機率稱為條件機率，例如選出撲克牌為偶數(A)且大於 6 (B)的機率是多少</p>
<p>條件機率符號通常用 \(P(A|B) \)，計算方式為 \(P(A|B) = \frac{P(A \cap B)}{P(B)}\)</p>
<h3 id="Joint-Probability-Table-聯合機率表"><a href="#Joint-Probability-Table-聯合機率表" class="headerlink" title="Joint Probability Table 聯合機率表"></a>Joint Probability Table 聯合機率表</h3><ul>
<li>Joint Probabilities 出現在表格的主體，即 1 處</li>
<li>Marginal Probabilties(邊際機率，即單獨只看某事件的機率)通常在表格的邊界，即 2 處<blockquote>
<p><img src="/images/statistics-1081-mid/8.PNG" alt=""></p>
</blockquote>
</li>
</ul>
<h3 id="Independent-Events-獨立事件"><a href="#Independent-Events-獨立事件" class="headerlink" title="Independent Events 獨立事件"></a>Independent Events 獨立事件</h3><p>如果 A 事件不會影響到 B 事件，我們就說 A 跟 B 是獨立事件，因此可以這樣表達 \(P(A|B) = P(A) \) or \(P(B|A) = P(B) \)</p>
<ul>
<li>multiplication law 乘法律 <ul>
<li>此 Law 也可以用來驗證這兩個事件是不是獨立事件</li>
<li>如果是獨立事件則乘法律出來的答案應該是 \(P(A \cap B ) = P(A)P(B) \)<br><a href="#Some-Basic-Relationships-of-Probability-機率的基本觀念">multiplication law 乘法律</a>公式可以點擊此連結並移到下方的<strong>Intersection 交集</strong></li>
</ul>
</li>
</ul>
<h3 id="Mutual-Exclusiveness-and-Independence-互斥與獨立"><a href="#Mutual-Exclusiveness-and-Independence-互斥與獨立" class="headerlink" title="Mutual Exclusiveness and Independence 互斥與獨立"></a>Mutual Exclusiveness and Independence 互斥與獨立</h3><ul>
<li>互斥事件與獨立事件<strong>不同</strong></li>
<li>機率大於 0 的兩個事件不會<strong>同時</strong>有互斥與獨立，即兩個事件只要機率 \(&gt; 0\)，就表示一定有關係</li>
<li>如果知道事件 A , B 是互斥事件，當 A 發生時 B 不會發生，因此他們是有相關的，並不是<strong>獨立事件</strong>，因為會互相影響</li>
<li>如果事件 A , B 不是互斥事件，那他們<strong>有可能是</strong>獨立事件</li>
</ul>
<h2 id="Bayes’-Theorem-貝式定理"><a href="#Bayes’-Theorem-貝式定理" class="headerlink" title="Bayes’ Theorem 貝式定理"></a>Bayes’ Theorem 貝式定理</h2><h3 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h3><blockquote>
<p><img src="/images/statistics-1081-mid/11.PNG" alt=""></p>
</blockquote>
<h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><p>根據已知的 A 機率推出 B 機率</p>
<p>流程圖如下：</p>
<blockquote>
<p><img src="/images/statistics-1081-mid/9.PNG" alt=""></p>
</blockquote>
<h3 id="舉例-1"><a href="#舉例-1" class="headerlink" title="舉例"></a>舉例</h3><p>在鎮上興建購物中心是一個很好的主意，可以帶來不錯的收益，但必須通過鎮公所的允許，否則不能建照。規畫委員會要向鎮公所提出建議，來獲得支持或反對興建購物中心</p>
<p>\(A_1 \) = 支持興建 , 機率為 0.7<br>\(A_2 \) = 反對興建 , 機率為 0.3</p>
<h4 id="situlation-A"><a href="#situlation-A" class="headerlink" title="situlation A"></a>situlation A</h4><p>目前規畫委員會建議不要興建購物中心(B)，此事件的發生會不會影響到鎮公所支持或反對興建購物中心的機率?</p>
<p>根據過去歷史 \(P(B|A_1)=0.2\) and \(P(B|A_2)=0.9\)</p>
<p>我們可以透過歷史推出 \(P(B_C | A_1) = 0.8 \) and \(P(B_C | A_2) = 0.1 \)</p>
<p>樹狀圖則如下：</p>
<blockquote>
<p><img src="/images/statistics-1081-mid/10.PNG" alt=""></p>
</blockquote>
<p>根據我們規畫委員會的建議後，我們可以得出<br>\(P(A_1 |B) = \frac{P(A_1)P(B|A_1)}{P(A_1)P(B|A_1) + P(A_2)P(B|A_2)} \\ = \frac{(0.7)(0.2)}{(0.7)(0.2) + (0.3)(0.9)} = 0.34 \)</p>
<p>其中 \(P(B) = P(A_1 \cap B) + P(A_2 \cap B) \)</p>
<h4 id="conclusion-A-1"><a href="#conclusion-A-1" class="headerlink" title="conclusion A-1"></a>conclusion A-1</h4><p>這對不想要興建購物中心的人認為是一個好消息，因為從原本支持興建的機率 0.7 降至 0.34</p>
<p>透過表來解讀則是</p>
<ul>
<li>(4) 是表示在歷史資料中遇到的情況去乘這次的情況，來說明這次有可能成功的機率，但必須注意的是小數相乘會越來越小，因此不可以透過 14% 去算，分母已經不再是 1 了</li>
<li>P(B) 則表示這兩種可能總共的機率</li>
<li>(5) 再來則是透過 P(B) 來找出每一個 \(P(A_i)\) 的機率<blockquote>
<p><img src="/images/statistics-1081-mid/11.PNG" alt=""><br><img src="/images/statistics-1081-mid/12.PNG" alt=""></p>
</blockquote>
</li>
</ul>
<h1 id="Chapter-5-Discrete-Probability-Distributions-離散機率分配"><a href="#Chapter-5-Discrete-Probability-Distributions-離散機率分配" class="headerlink" title="Chapter 5 Discrete Probability Distributions 離散機率分配"></a>Chapter 5 Discrete Probability Distributions 離散機率分配</h1><p>Discrete random variable(離散隨機變數) 為有限數量或無限數量的序列值，且可以透過圖表、公式、表格來描述離散的機率分布</p>
<h2 id="甚麼時機用-Discrete-Probability-Distributions，進行舉例"><a href="#甚麼時機用-Discrete-Probability-Distributions，進行舉例" class="headerlink" title="甚麼時機用 Discrete Probability Distributions，進行舉例"></a>甚麼時機用 Discrete Probability Distributions，進行舉例</h2><ul>
<li>一個家庭有多少個小孩，Infinite Sequence</li>
<li>家裡有沒有狗或貓，有這四種結果，有狗、有貓、沒有狗貓、有狗貓， finite Sequences</li>
<li><strong>在此時則不可以使用 Discrete Probability Distributions</strong><br>詢問台北到高雄的距離，此時要使用 Continuous </li>
</ul>
<h2 id="Random-Variables"><a href="#Random-Variables" class="headerlink" title="Random Variables"></a>Random Variables</h2><p>隨機變數是透過數值描述實驗結果，類似樣本空間隨機抽樣本點 </p>
<h2 id="Type-Of-discrete-probability-distributions"><a href="#Type-Of-discrete-probability-distributions" class="headerlink" title="Type Of discrete probability distributions"></a>Type Of discrete probability distributions</h2><ul>
<li>First Type<br>透過規則將實驗結果的機率指定並確定給每一個隨機變數</li>
<li>Second Type<br>透過數學公式給予每一個隨機變數值的機率</li>
</ul>
<h2 id="probability-function-機率函數"><a href="#probability-function-機率函數" class="headerlink" title="probability function 機率函數"></a>probability function 機率函數</h2><p><strong>機率分布</strong>透過<strong>機率函數 \(f(x) \)</strong>定義，為該函數的隨機變數每一個值提供機率，並且 \(f(x) \geq 0 \) and \(\Sigma f(x) = 1\)</p>
<p>通常透過三種方式來指派機率給予隨機變數，<a href="#Method">古典法、主觀法、頻率關聯法</a>，透過頻率關聯法的稱為 empirical discrete distribution (實證離散分布)</p>
<h2 id="discrete-probability-distributions-specified-by-formulas-離散機率分布公式"><a href="#discrete-probability-distributions-specified-by-formulas-離散機率分布公式" class="headerlink" title="discrete probability distributions specified by formulas (離散機率分布公式)"></a>discrete probability distributions specified by formulas (離散機率分布公式)</h2><p>除了圖表與表格外，通常會有公式來給予機率函數的每一個值(x)指定機率，來描述離散分布</p>
<h3 id="下面是機率公式，適合的應用範圍"><a href="#下面是機率公式，適合的應用範圍" class="headerlink" title="下面是機率公式，適合的應用範圍"></a>下面是機率公式，適合的應用範圍</h3><table>
<thead>
<tr>
<th>機率公式</th>
<th>應用情況</th>
</tr>
</thead>
<tbody><tr>
<td><a href="#discrete-uniform-離散均勻">離散均勻</a></td>
<td>發生n次 則每一次的機率就是1/n</td>
</tr>
<tr>
<td><a href="#binomial-二項">二項</a></td>
<td>求在 n 是實驗中 x 次成功才能達到期望結果的機率</td>
</tr>
<tr>
<td><a href="#negative-binomial-負二項">負二項</a></td>
<td>需要x 次實驗才能夠達到期望結果的機率</td>
</tr>
<tr>
<td><a href="#geometric-幾何">幾何</a></td>
<td>在第一次成功的次數</td>
</tr>
<tr>
<td><a href="#Poisson-卜瓦松">卜瓦松</a></td>
<td>在特定的空間(或單點)內發生次數(離散)的機率</td>
</tr>
<tr>
<td><a href="#hypergeometric-超幾何">超幾何</a></td>
<td>N次試驗中成功的機率(但取後不放回)</td>
</tr>
<tr>
<td><a href="#Exponential-Probability-Distribution-指數機率分配">指數機率</a></td>
<td>詢問區間中的<strong>連續</strong>變數機率</td>
</tr>
<tr>
<td><a href="#Normal-Probability-Distribution-常態機率分布">常態機率分布</a></td>
<td>最常用的機率分布之一，通常題目會告訴要用此公式</td>
</tr>
</tbody></table>
<h3 id="期望值-E-x"><a href="#期望值-E-x" class="headerlink" title="期望值 \(E(x) \)"></a>期望值 \(E(x) \)</h3><ul>
<li>在離散機率分布中，期望值與平均值為一樣，公式為 \(E(x) = \mu = \Sigma x f(x) \)</li>
<li>期望值是隨機變數的加權平均，權重則是隨機變數的機率</li>
<li>期望值<strong>不是隨機變數可以設定的值</strong></li>
</ul>
<h3 id="Variance-and-Standard-Deviation-變異數與標準差"><a href="#Variance-and-Standard-Deviation-變異數與標準差" class="headerlink" title="Variance and Standard Deviation 變異數與標準差"></a>Variance and Standard Deviation 變異數與標準差</h3><ul>
<li>變異數公式為 \(Var(x) = \sigma^2 = \Sigma(x-\mu)^2 f(x) \)</li>
<li>變異數是隨機變數值減去平均值(期望值)次方在乘機率的加權平均，權重則是隨機變數的機率</li>
<li>標準差 \(\sigma \)，是變異數開平方的值</li>
</ul>
<h2 id="discrete-uniform-離散均勻"><a href="#discrete-uniform-離散均勻" class="headerlink" title="discrete-uniform 離散均勻"></a>discrete-uniform 離散均勻</h2><ul>
<li>The discrete uniform probability distributionis 是數學公式中最簡單的離散機率分布</li>
<li>公式為 \(f(x) = 1 / n \)，n = 隨機變數的總和 </li>
<li>基本上每一個隨機變數的值都很有可能相同</li>
<li><blockquote>
<p><img src="/images/statistics-1081-mid/13.PNG" alt=""></p>
</blockquote>
</li>
</ul>
<h2 id="Bivariate-二元"><a href="#Bivariate-二元" class="headerlink" title="Bivariate 二元"></a>Bivariate 二元</h2><ul>
<li>涉及兩個隨機變數的機率分配時可以使用 bivariate probability distribution</li>
<li>每一個實驗結果都有兩個值，一個隨機變數</li>
<li>通常我們在使用此機率分布時，我們會對於<strong>隨機變數與另一隨機變數的關聯性</strong>產生興趣</li>
</ul>
<h3 id="舉例-A-員工滿意度"><a href="#舉例-A-員工滿意度" class="headerlink" title="舉例 A - 員工滿意度"></a>舉例 A - 員工滿意度</h3><p>舉例有 200 位員工對他的工作滿意度與福利待遇進行調查，如下圖</p>
<blockquote>
<p><img src="/images/statistics-1081-mid/14.PNG" alt=""><br><img src="/images/statistics-1081-mid/15.PNG" alt=""><br><img src="/images/statistics-1081-mid/16.PNG" alt=""><br><img src="/images/statistics-1081-mid/18.PNG" alt=""><br><img src="/images/statistics-1081-mid/19.PNG" alt=""></p>
</blockquote>
<h3 id="Covariance-共變異數"><a href="#Covariance-共變異數" class="headerlink" title="Covariance 共變異數"></a>Covariance 共變異數</h3><p>公式：\(\sigma_{xy} = [ Var(x+y) - Var(x) - Var(y)] /2 \) or \(\sigma_{xy} =  \Sigma_{i,j} [ x_i - E(x_i) ] [y_i - E(y_i) ] f(x_i,y_i)\)</p>
<h3 id="Correlation-Coefficient-相關係數"><a href="#Correlation-Coefficient-相關係數" class="headerlink" title="Correlation Coefficient 相關係數"></a>Correlation Coefficient 相關係數</h3><p>公式 \(\rho_{xy} = \frac{\sigma_{xy}}{\sigma_x \sigma_y}\)</p>
<ul>
<li>延續剛剛的舉例，如圖：<blockquote>
<p><img src="/images/statistics-1081-mid/21.PNG" alt=""></p>
</blockquote>
</li>
</ul>
<h3 id="舉例-B-金融資產配置"><a href="#舉例-B-金融資產配置" class="headerlink" title="舉例 B - 金融資產配置"></a>舉例 B - 金融資產配置</h3><p>透過金融資產分配進行舉例</p>
<blockquote>
<p><img src="/images/statistics-1081-mid/22.PNG" alt=""></p>
</blockquote>
<ul>
<li><p>其中 a = 0.5 and b = 0.5 為我們資產配置各一半，其中共變異數將在下頁說明</p>
<blockquote>
<p><img src="/images/statistics-1081-mid/23.PNG" alt=""></p>
</blockquote>
</li>
<li><p>共變異數</p>
<blockquote>
<p><img src="/images/statistics-1081-mid/24.PNG" alt=""></p>
</blockquote>
</li>
<li><p>結果</p>
<blockquote>
<p><img src="/images/statistics-1081-mid/25.PNG" alt=""></p>
</blockquote>
</li>
<li><p>標準差為其投資組合風險，期望值為投資應能得到的報酬，實際獲利範圍應為\(期望值  * \pm 標準差 \)</p>
</li>
</ul>
<h2 id="binomial-二項"><a href="#binomial-二項" class="headerlink" title="binomial 二項"></a>binomial 二項</h2><ul>
<li>此公式可以找出在 y 次實驗中 x 次成功的機率分布</li>
<li>透過 n 個相同實驗組成</li>
<li>每一次的實驗都有兩個結果，成功或失敗</li>
<li>平穩性假設 (stationarity assumption)<br>成功的機率(p)，在每一項實驗都是獨立，亦即不會受到其他實驗影響</li>
<li>Probability Distributions APP - binomial<ul>
<li>n 實驗的次數</li>
<li>p 實驗的成功機率</li>
<li>x 我們想要知道的實驗成功次數<h3 id="舉例-員工離職"><a href="#舉例-員工離職" class="headerlink" title="舉例 - 員工離職"></a>舉例 - 員工離職</h3><blockquote>
<p><img src="/images/statistics-1081-mid/26.PNG" alt=""><br><img src="/images/statistics-1081-mid/27.PNG" alt=""></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p>需要注意的是員工<strong>只可以</strong>離職一次，因此我們找出員工的離職機率只可以是<strong>離職一次</strong>的機率</p>
<blockquote>
<p><img src="/images/statistics-1081-mid/28.PNG" alt=""><br><img src="/images/statistics-1081-mid/29.PNG" alt=""></p>
</blockquote>
<h3 id="Expected-Value-and-Variance-and-Standarad-Deviation"><a href="#Expected-Value-and-Variance-and-Standarad-Deviation" class="headerlink" title="Expected Value and Variance and Standarad Deviation"></a>Expected Value and Variance and Standarad Deviation</h3><ul>
<li>Excpected Value<br>\(E(x) = np = \mu \)</li>
<li>Variance<br>\(Var(x) = np(1-p) = \sigma^2 \)</li>
<li>Standard Deviation<br>\(\sigma = \sqrt{np(1-p)}\)</li>
<li>p 為我們想要得到的實驗結果機率</li>
</ul>
<h4 id="QUESTION-A-此-3-個員工明年會有一個人想要離職的機率是多少"><a href="#QUESTION-A-此-3-個員工明年會有一個人想要離職的機率是多少" class="headerlink" title="QUESTION A: 此 3 個員工明年會有一個人想要離職的機率是多少"></a>QUESTION A: 此 3 個員工明年會有一個人想要離職的機率是多少</h4><p>設 n = 3 , p = 0.1 , x = 1 再透過 Probability Distributions APP 可以得出 0.243 </p>
<blockquote>
<p><img src="/images/statistics-1081-mid/30.jpg" alt=""></p>
</blockquote>
<h2 id="negative-binomial-負二項"><a href="#negative-binomial-負二項" class="headerlink" title="negative binomial 負二項"></a>negative binomial 負二項</h2><ul>
<li>需要多少次的實驗才能達到我們的期望結果</li>
<li>每一次的實驗都有兩個結果，成功或失敗</li>
<li>透過 n 個相同實驗組成</li>
<li>平穩性假設 (stationarity assumption)<br>成功的機率(p)，在每一項實驗都是獨立，亦即不會受到其他實驗影響</li>
<li>實驗只會進行到<strong>第一次</strong>我們期望結果，就結束</li>
<li>Probability Distributions APP - <strong>binomial(2)</strong><ul>
<li>r 實驗成功的次數</li>
<li>p 實驗的成功機率</li>
<li>x 我們想要知道可以符合我們的實驗次數</li>
</ul>
</li>
</ul>
<h3 id="舉例-我們想要知道擲五次硬幣，有兩次正面的機率是多少，投擲正反面的機率都是-0-5"><a href="#舉例-我們想要知道擲五次硬幣，有兩次正面的機率是多少，投擲正反面的機率都是-0-5" class="headerlink" title="舉例 - 我們想要知道擲五次硬幣，有兩次正面的機率是多少，投擲正反面的機率都是 0.5"></a>舉例 - 我們想要知道擲五次硬幣，有兩次正面的機率是多少，投擲正反面的機率都是 0.5</h3><p>設 r = 2 , p = 0.5 , x = 5 再透過 Probability Distributions APP 可以得出 0.125</p>
<blockquote>
<p><img src="/images/statistics-1081-mid/31.jpg" alt=""></p>
</blockquote>
<h3 id="Expected-Value-and-Variance"><a href="#Expected-Value-and-Variance" class="headerlink" title="Expected Value and Variance"></a>Expected Value and Variance</h3><ul>
<li>Expected Value<br>\(E(x) = \mu = \frac{r}{p} \)</li>
<li>Variance<br>\(Var(x) = \sigma^2 = \frac{r(1-p)}{p^2}\)</li>
</ul>
<h2 id="geometric-幾何"><a href="#geometric-幾何" class="headerlink" title="geometric 幾何"></a>geometric 幾何</h2><ul>
<li>每一次的實驗都有兩個結果，成功或失敗</li>
<li>平穩性假設 (stationarity assumption)<br>成功的機率(p)，在每一項實驗都是獨立，亦即不會受到其他實驗影響</li>
<li>geometric 是 negative binomial 的特例</li>
<li>需要一次我們想要的期望結果的成功次數</li>
<li>如果將 negative binomial r = 1，即變成了 geometric</li>
<li>Probability Distributions APP - <strong>Geometric(2)</strong><ul>
<li>x 實驗 x 後第一次我們想要的結果出現</li>
<li>p 實驗的成功機率</li>
</ul>
</li>
</ul>
<h3 id="舉例-擲四次硬幣，前面三次都是反面，最後一次為正面的機率是多少，投擲正反面的機率都是-0-5"><a href="#舉例-擲四次硬幣，前面三次都是反面，最後一次為正面的機率是多少，投擲正反面的機率都是-0-5" class="headerlink" title="舉例 - 擲四次硬幣，前面三次都是反面，最後一次為正面的機率是多少，投擲正反面的機率都是 0.5"></a>舉例 - 擲四次硬幣，前面三次都是反面，最後一次為正面的機率是多少，投擲正反面的機率都是 0.5</h3><p>設 p = 0.5 , x = 4，再透過 Probability Distributions APP 可以得出 0.0625</p>
<blockquote>
<p><img src="/images/statistics-1081-mid/32.jpg" alt=""></p>
</blockquote>
<h3 id="Expected-Value-and-Variance-1"><a href="#Expected-Value-and-Variance-1" class="headerlink" title="Expected Value and Variance"></a>Expected Value and Variance</h3><ul>
<li>Expected Value<br>\(E(x) = \mu = \frac{1}{p} \)</li>
<li>Variance<br>\(Var(x) = \sigma^2 = \frac{(1-p)}{p^2}\)</li>
</ul>
<h2 id="Poisson-卜瓦松"><a href="#Poisson-卜瓦松" class="headerlink" title="Poisson 卜瓦松"></a>Poisson 卜瓦松</h2><ul>
<li>Poisson 通常用於一段區間或時間內發生的次數，為離散的隨機變數，可以是無限的序列，即 x 趨近於無限</li>
<li>Poisson 的二個性質<ul>
<li>在兩個相同長度但<strong>並不是同一個區間</strong>，發生的機率可能相同</li>
<li>發生與不發生為獨立事件，兩者沒有任何關係</li>
</ul>
</li>
<li>一個應用舉例關於 Poisson <ul>
<li>一小時內到達收費站的車輛數量</li>
</ul>
</li>
<li>Probability Distributions APP - <strong>Poisson</strong><ul>
<li>\(\lambda \) 平均值 or 期望值</li>
<li>x 一個區間發生的次數</li>
</ul>
</li>
</ul>
<h3 id="舉例-周末晚上通常每小時會有-6-個病人到急診室，想請問-30-分鐘內會有-4-個人到達的機率是多少"><a href="#舉例-周末晚上通常每小時會有-6-個病人到急診室，想請問-30-分鐘內會有-4-個人到達的機率是多少" class="headerlink" title="舉例 - 周末晚上通常每小時會有 6 個病人到急診室，想請問 30 分鐘內會有 4 個人到達的機率是多少"></a>舉例 - 周末晚上通常每小時會有 6 個病人到急診室，想請問 30 分鐘內會有 4 個人到達的機率是多少</h3><p>設 \(\lambda \) = 3 , x = 4 ，再透過 Probability Distributions APP 可以得出 0.16803</p>
<blockquote>
<p><img src="/images/statistics-1081-mid/33.jpg" alt=""></p>
</blockquote>
<h3 id="Expected-Value-and-Variance-2"><a href="#Expected-Value-and-Variance-2" class="headerlink" title="Expected Value and Variance"></a>Expected Value and Variance</h3><ul>
<li>Expected Value = Mean = \(\mu = \sigma^2 \)</li>
<li>Variance \(Var(x) = \sigma^2\)</li>
</ul>
<h2 id="hypergeometric-超幾何"><a href="#hypergeometric-超幾何" class="headerlink" title="hypergeometric 超幾何"></a>hypergeometric 超幾何</h2><ul>
<li>hypergeometric 可以找出 n 次實驗中成功的機率但實驗結果並不具有獨立性，且 x 趨近於無限</li>
<li>hypergeometric 的兩個性質<ul>
<li>與 binomial 相似</li>
<li><strong>但實驗不獨立</strong>，也就是前面做的實驗會影響到下一次的實驗</li>
</ul>
</li>
<li>Probability Distributions APP - <strong>hypergeometric</strong> <ul>
<li>x 為實驗成功次數</li>
<li>n 為我們希望發生的實驗次數</li>
<li>N 為實際上會有的實驗結果</li>
<li>M 為我們想知道的成功次數</li>
</ul>
</li>
<li>hypergeometric 限制<ul>
<li>我們想知道的成功次數不可以大於我們想知道的成功次數，即 \(x \leq M\)</li>
<li>\(n-x \leq N - M \)，即我們不想知道的失敗次數一定要<strong>大於或等於</strong>會失敗的次數</li>
<li>沒有滿足上面兩條件則機率必定是 0 </li>
</ul>
</li>
<li><strong>當母體極大時，可以使用 binomial 來近似</strong></li>
<li>hypergeometric 的其他變數，<strong>透過 binomial 來算出的變數</strong><ul>
<li>\(p = \frac{M}{N}\) 為第一次發生實驗成功的機率</li>
<li>如果母體值極大，也就表示 \((N-n) / (N-1) = 1 \)，極限的概念</li>
<li>Expect Value = \( E(x) = np\)</li>
<li>Variance = \(Var(x) = np(1-p) \)</li>
</ul>
</li>
</ul>
<h3 id="舉例-手中有兩顆沒電的電池與全新電池，現在隨機選擇兩顆電池，能拿到全新的電池機率是多少"><a href="#舉例-手中有兩顆沒電的電池與全新電池，現在隨機選擇兩顆電池，能拿到全新的電池機率是多少" class="headerlink" title="舉例 - 手中有兩顆沒電的電池與全新電池，現在隨機選擇兩顆電池，能拿到全新的電池機率是多少"></a>舉例 - 手中有兩顆沒電的電池與全新電池，現在隨機選擇兩顆電池，能拿到全新的電池機率是多少</h3><ul>
<li>x = 2 我們想知道選到兩顆好電池的機率</li>
<li>n = 2 我們隨機選擇兩顆電池</li>
<li>N = 4 這四顆電池我們都有機會拿到，因此我們的實驗結果會有 4 個</li>
<li>M = 2 其中成功的機率最高為 2 次，因為好電池只有兩顆</li>
<li>透過 Probability Distributions APP 可以得出 0.1667<blockquote>
<p><img src="/images/statistics-1081-mid/34.jpg" alt=""></p>
</blockquote>
</li>
</ul>
<h3 id="Expected-Value-and-Variance-3"><a href="#Expected-Value-and-Variance-3" class="headerlink" title="Expected Value and Variance"></a>Expected Value and Variance</h3><ul>
<li>Expected Value = Mean = \(\mu = n \frac{M}{N} \)</li>
<li>Variance \(Var(x) = \sigma^2 = n(\frac{M}{N})(1- \frac{M}{N})(\frac{N-n}{N-1})\)</li>
</ul>
<h1 id="Chapter-6-Continuous-Probability-Distributions-連續機率分布"><a href="#Chapter-6-Continuous-Probability-Distributions-連續機率分布" class="headerlink" title="Chapter 6 Continuous Probability Distributions 連續機率分布"></a>Chapter 6 Continuous Probability Distributions 連續機率分布</h1><p>Continuous random variable(連續隨機變數) 為一個區間的任何數值，特質為下</p>
<ul>
<li>沒辦法去討論特定的值，每一個點的機率都為零</li>
<li>連續機率分布討論隨機變量在區間中取值的機率</li>
<li>透過兩個點連線(\(x_1 , x_2 \))的區間為機率圖下的面積<ul>
<li>Uniform <blockquote>
<p><img src="/images/statistics-1081-mid/30.PNG" alt=""></p>
</blockquote>
</li>
<li>Normal <blockquote>
<p><img src="/images/statistics-1081-mid/31.PNG" alt=""></p>
</blockquote>
</li>
<li>Exponential <blockquote>
<p><img src="/images/statistics-1081-mid/32.PNG" alt=""></p>
</blockquote>
</li>
</ul>
</li>
<li>連續機率分布的變數，個人認為不太會用到，如果看之後的 ppt 會用到我在修正<ul>
<li>Probability density function</li>
</ul>
</li>
</ul>
<h2 id="Uniform-Probability-Distribution-均勻機率分配"><a href="#Uniform-Probability-Distribution-均勻機率分配" class="headerlink" title="Uniform Probability Distribution 均勻機率分配"></a>Uniform Probability Distribution 均勻機率分配</h2><ul>
<li>根據上方 Uniform 的圖 y 軸為 \(1/(b-a) \)，x 軸為單位刻度。</li>
<li>只要區間與機率成為正比，隨機變量就會均勻分布</li>
<li>公式<ul>
<li>\(f(x) = 1 / (b-a) , for \ a \leq x \leq b \\ = 0 , elsewhere \)</li>
<li>a 為最小的變數刻度</li>
<li>b 為最大的變數刻度</li>
</ul>
</li>
<li>Expected Value<ul>
<li>\(E(x) = (a+b) / 2\)</li>
<li>\(Var(x) = (b-a)^2 / 12 \)</li>
</ul>
</li>
</ul>
<h3 id="舉例-顧客通常測取沙拉的分量在-5-ounces-and-15-ounces-之間，在平均機率分布下客人拿取-12-ounces-15-ounces-機率多少"><a href="#舉例-顧客通常測取沙拉的分量在-5-ounces-and-15-ounces-之間，在平均機率分布下客人拿取-12-ounces-15-ounces-機率多少" class="headerlink" title="舉例 - 顧客通常測取沙拉的分量在 5 ounces and 15 ounces 之間，在平均機率分布下客人拿取 12 ounces ~ 15 ounces 機率多少"></a>舉例 - 顧客通常測取沙拉的分量在 5 ounces and 15 ounces 之間，在平均機率分布下客人拿取 12 ounces ~ 15 ounces 機率多少</h3><ul>
<li>畫圖如下<blockquote>
<p><img src="/images/statistics-1081-mid/33.PNG" alt=""></p>
</blockquote>
</li>
<li>現在要取 12 ounces ~ 15 ounces <blockquote>
<p><img src="/images/statistics-1081-mid/34.PNG" alt=""></p>
</blockquote>
</li>
<li>期望值就為 \((5+15)/2 = 10 \)</li>
<li>變異數就為 \((15-5)^2 / 12 = 8.33\)</li>
</ul>
<h2 id="Normal-Probability-Distribution-常態機率分布"><a href="#Normal-Probability-Distribution-常態機率分布" class="headerlink" title="Normal Probability Distribution 常態機率分布"></a>Normal Probability Distribution 常態機率分布</h2><ul>
<li>Normal Probability Distribution 是 Continuous Probability Distributions 的最重要理論</li>
<li>常被廣泛用於統計推論中，如：降雨量、成績</li>
<li>常態分配為對稱，沒有 skewness</li>
<li>圖形中的最高點為，mean、median、mode，圖形寬度隨著標準差拉大或拉小</li>
<li>經驗法則<ul>
<li>68.26% 的值會落在正負一個標準差</li>
<li>95.44% 的值會落在正負兩個標準差</li>
<li>99.72% 的值會落在正負三個標準差</li>
</ul>
</li>
<li>Probability Distributions APP - <strong>Normal</strong> <ul>
<li>\(\mu \) 平均值</li>
<li>\(\sigma \) 標準差</li>
<li>x 我們所要詢問的值</li>
</ul>
</li>
</ul>
<h3 id="Standard-Normal-Probability-Distribution-標準常態機率分布"><a href="#Standard-Normal-Probability-Distribution-標準常態機率分布" class="headerlink" title="Standard Normal Probability Distribution 標準常態機率分布"></a>Standard Normal Probability Distribution 標準常態機率分布</h3><p>當平均值等於零且標準差為一時，則是 Standard Normal Probability Distribution</p>
<ul>
<li>將常態機率分配轉換成標準常態機率分配，透過 z 來轉換<br>\(z = \frac{x-\mu }{\sigma}\)，</li>
<li>z 的值介於 1 ~ -1 之間，是標準常態分配的 x 軸</li>
</ul>
<h3 id="舉例-商店銷售機油，當機油庫存少於-20-gallons-時要補貨，經理不希望有缺貨的時機，目前確定標準差為-6、平均值為-15、使用常態分布，想詢問當需求訂單超過-20-gallons-時機率為多少"><a href="#舉例-商店銷售機油，當機油庫存少於-20-gallons-時要補貨，經理不希望有缺貨的時機，目前確定標準差為-6、平均值為-15、使用常態分布，想詢問當需求訂單超過-20-gallons-時機率為多少" class="headerlink" title="舉例 - 商店銷售機油，當機油庫存少於 20 gallons 時要補貨，經理不希望有缺貨的時機，目前確定標準差為 6、平均值為 15、使用常態分布，想詢問當需求訂單超過 20 gallons 時機率為多少"></a>舉例 - 商店銷售機油，當機油庫存少於 20 gallons 時要補貨，經理不希望有缺貨的時機，目前確定標準差為 6、平均值為 15、使用常態分布，想詢問當需求訂單超過 20 gallons 時機率為多少</h3><ul>
<li>畫圖<blockquote>
<p><img src="/images/statistics-1081-mid/35.PNG" alt=""></p>
</blockquote>
</li>
<li>透過 Probability Distributions APP 可以得出 0.2033<ul>
<li>\(\sigma = 6 \)</li>
<li>\(\mu = 15 \)</li>
<li>\(x &gt; 20 \)</li>
<li>圖片<blockquote>
<p><img src="/images/statistics-1081-mid/36.jpg" alt=""></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="舉例-承上一個舉例，經理希望缺貨的可能性不超過-0-05，那應該甚麼時候補貨"><a href="#舉例-承上一個舉例，經理希望缺貨的可能性不超過-0-05，那應該甚麼時候補貨" class="headerlink" title="舉例 - 承上一個舉例，經理希望缺貨的可能性不超過 0.05，那應該甚麼時候補貨"></a>舉例 - 承上一個舉例，經理希望缺貨的可能性不超過 0.05，那應該甚麼時候補貨</h3><p>我們可以透過標準常態機率分配，來找出適合的補貨點，需要使用到 <strong>z</strong>，來轉換成標準常態機率分配，因為經理已經說了希望缺貨的可能性不超過 0.05，透過查表的方式可以找出。<br>如果是透過手機，就用二分搜尋逼近 x 值即可</p>
<ul>
<li>查完表後，找到適合的 z 值，在帶回 z 函數，可以推出 \( x = \mu + z_0.05 * \sigma \)<blockquote>
<p><img src="/images/statistics-1081-mid/36.PNG" alt=""></p>
</blockquote>
</li>
</ul>
<h3 id="Normal-Approximation-of-Binomial-Probabilities-常態近似二項機率分配"><a href="#Normal-Approximation-of-Binomial-Probabilities-常態近似二項機率分配" class="headerlink" title="Normal Approximation of Binomial Probabilities 常態近似二項機率分配"></a>Normal Approximation of Binomial Probabilities 常態近似二項機率分配</h3><p>當實驗次數增加後，很難手動或使用計算機來計算二項式機率函數，常態近似二項機率分配可以幫助我們快速計算二項機率分布的值近似值，下面說說一些限制要求與條件。</p>
<ul>
<li>\(np \geq 5 \) </li>
<li>\(n(1-p) \geq 5 \)</li>
<li>\(\mu = np \)</li>
<li>\(\sigma = \sqrt{np(1-p)}\)</li>
<li>因為是使用連續分布來近似離散分布，所以要透過加減來校正因子<br>舉例，如果是要問 x = 12 時且單位量為 1 時，我們使用常態近似二項機率分配則要 \(P(11.5 &lt; x &lt; 12.5) \)，因為區間對於單位點的機率都是零</li>
</ul>
<h3 id="舉例-公司有-10-的發票記錄錯誤，隨機選了-100-張發票，試問裡面會有-12-張發票記錄錯誤的機率，使用常態近似二項機率分配"><a href="#舉例-公司有-10-的發票記錄錯誤，隨機選了-100-張發票，試問裡面會有-12-張發票記錄錯誤的機率，使用常態近似二項機率分配" class="headerlink" title="舉例 - 公司有 10% 的發票記錄錯誤，隨機選了 100 張發票，試問裡面會有 12 張發票記錄錯誤的機率，使用常態近似二項機率分配"></a>舉例 - 公司有 10% 的發票記錄錯誤，隨機選了 100 張發票，試問裡面會有 12 張發票記錄錯誤的機率，使用常態近似二項機率分配</h3><ul>
<li>先判斷是否有超過限制<ul>
<li>\( np = 100(0.1) = 10 \geq 5  \)，有符合</li>
<li>\(n(1-p) = 100(0.9) = 90 \geq 5 \)，有符合</li>
<li>\(\mu = np = 100(0.1) = 10 \))</li>
<li>\(\sigma = \sqrt{np(1-p)} = [100(0.1)(0.9)]^(\frac{1}{2}) = 3 \)</li>
</ul>
</li>
<li>透過 Probability Distributions APP 可以得出 0.1052<ul>
<li>\(mu = 10\)</li>
<li>\(\sigma = 3 \)</li>
<li>\(x &lt; 11.5 = 0.7967 \)</li>
<li>\(x &lt; 12.5 = 0.6915 \)</li>
<li>\(0.7967 - 0.6915 = 0.1052 \)</li>
</ul>
</li>
</ul>
<h2 id="Exponential-Probability-Distribution-指數機率分配"><a href="#Exponential-Probability-Distribution-指數機率分配" class="headerlink" title="Exponential Probability Distribution 指數機率分配"></a>Exponential Probability Distribution 指數機率分配</h2><ul>
<li>Exponential Probability Distribution 用來描述完成任務所需要的時間，應用如<ul>
<li>車輛到達收費站德時間</li>
<li>完成問卷需要的時間</li>
</ul>
</li>
<li>指數機率分佈的標準差與平均值皆相等</li>
<li>指數機率分佈向右偏(即圖形主要面積在左邊)，偏度為二</li>
<li>Probability Distributions APP - <strong>Exponential</strong> <ul>
<li>\(\lambda = \frac{1}{\mu}\)</li>
<li>x 為我們所期望得到的目標，如找出一段時間內 x 次紅綠燈為紅燈的次數</li>
</ul>
</li>
</ul>
<h3 id="舉例-從家裡到火車站平均開車時間為-3-分鐘，透過指數機率分布，想找出連續兩次到達時間不大於兩分鐘的機率是多少"><a href="#舉例-從家裡到火車站平均開車時間為-3-分鐘，透過指數機率分布，想找出連續兩次到達時間不大於兩分鐘的機率是多少" class="headerlink" title="舉例 - 從家裡到火車站平均開車時間為 3 分鐘，透過指數機率分布，想找出連續兩次到達時間不大於兩分鐘的機率是多少"></a>舉例 - 從家裡到火車站平均開車時間為 3 分鐘，透過指數機率分布，想找出連續兩次到達時間不大於兩分鐘的機率是多少</h3><ul>
<li>透過 Probability Distributions APP 可以得出 0.4862<ul>
<li>\(\lambda = 0.3333 = \frac{1}{\mu} \)</li>
<li>\(x &lt;= 2 \)</li>
<li>圖片<blockquote>
<p><img src="/images/statistics-1081-mid/37.jpg" alt=""></p>
</blockquote>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>北科上課筆記</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>統計學筆記</tag>
        <tag>北科大二上統計學筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>投資學 筆記 - 股票價值基本分析 (產業分析與個別公司績效分析)</title>
    <url>/2020/12/06/NTUT_note/investment_stock_value_analysis_company_performance/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊與財金管理系大二上投資學重點整理<br><font color="#dd0000">並非所有人都適用，部分對我而言稍加容易的內容並不會寫在此內。</font><br>本章主要內容</p>
<ul>
<li>公司在產業中的競爭力分析</li>
<li>台灣產業分類與特性</li>
<li>利用經營指標分析公司股價</li>
</ul>
</blockquote>
<a id="more"></a>

<h1 id="產業分析"><a href="#產業分析" class="headerlink" title="產業分析"></a>產業分析</h1><h2 id="景氣循環"><a href="#景氣循環" class="headerlink" title="景氣循環"></a>景氣循環</h2><h3 id="產業景氣循環"><a href="#產業景氣循環" class="headerlink" title="產業景氣循環"></a>產業景氣循環</h3><p>經濟活動會重複性的經歷擴張與收縮，稱為景氣循環，循環的轉折點稱為高峰、低谷，高峰為擴張期結束和收縮期結束的交接點，谷底則出現在衰退期的底部，準備開始復甦</p>
<ul>
<li>成長性產業<br>具有高成長性，不受景氣循環影響，如：網通業、太陽能產業等，新產品或新技術有重大突破的產業</li>
<li>循環性產業<br>受景氣循環影響，如：汽車、家電產業</li>
<li>防禦性產業<br>受景氣循環小，如：食品生產、加工業、製藥業</li>
</ul>
<blockquote>
<p><img src="/images/investment_stock_value_analysis_company_performance/1.PNG" alt=""></p>
</blockquote>
<h3 id="產業競爭力分析架構"><a href="#產業競爭力分析架構" class="headerlink" title="產業競爭力分析架構"></a>產業競爭力分析架構</h3><blockquote>
<p><img src="/images/investment_stock_value_analysis_company_performance/2.PNG" alt=""></p>
</blockquote>
<h3 id="產業生命週期"><a href="#產業生命週期" class="headerlink" title="產業生命週期"></a>產業生命週期</h3><ul>
<li>開創期<br>產業發展的早期階段，特徵是擁有新技術與新產品，新產品在市場上尚未飽和，銷貨和盈餘成長很快，但不確定性也高，因為機器設備投資而讓資金大量流出</li>
<li>成長期<br>產業領導者開始出現，市場占有率容易被預測，產業的領頭羊廠商績效帶領著整體產業績效，此時產品普遍被消費者使用，在成長後期開始有大量現金流入</li>
<li>成熟期<br>產品已經廣為消費者使用，各公司的產品逐漸標準化，產品創新不多，開始進入價格戰爭，導致邊際利潤減少，現金流入極大後開始慢慢減少</li>
<li>衰退期<br>開始有新的替代產品出現或有低價產品入侵，產業成長率開始低於整體經濟社會甚至為負，現金流入不斷減少</li>
</ul>
<blockquote>
<p><img src="/images/investment_stock_value_analysis_company_performance/3.PNG" alt=""></p>
</blockquote>
<h2 id="台灣股票分類"><a href="#台灣股票分類" class="headerlink" title="台灣股票分類"></a>台灣股票分類</h2><h3 id="台灣對特定類股專有名詞"><a href="#台灣對特定類股專有名詞" class="headerlink" title="台灣對特定類股專有名詞"></a>台灣對特定類股專有名詞</h3><ul>
<li>主流股 投資人在短期內看好某類股票</li>
<li>內需股 產品以內銷為主，如水泥、食品、營建</li>
<li>資產股 公司有大量的不動產，如飯店、營建</li>
<li>投機股 股價波動大的股票</li>
<li>中國概念股 在中國設廠投資的股票</li>
<li>摩根概念股 納入<strong>新興市場自由指數(EMF)</strong>的股票</li>
</ul>
<h3 id="傳產股"><a href="#傳產股" class="headerlink" title="傳產股"></a>傳產股</h3><p>台灣投資人除了<strong>電子業</strong>與<strong>金融業</strong>之外的產業稱為傳統產業</p>
<ul>
<li>傳統產業的特性<ul>
<li>大多為成熟型產業，毛利率較低，不容易有獲利大幅成長情況</li>
<li>產品生命週期比較長</li>
</ul>
</li>
<li>須注意事項<ul>
<li>營建業為<strong>火車頭工業</strong>，他帶動著其他傳產業的發展，如：水泥、玻璃、鋼鐵</li>
<li>傳產業也有高科技技術產品，如：紡織股</li>
</ul>
</li>
</ul>
<blockquote>
<p><img src="/images/investment_stock_value_analysis_company_performance/4.PNG" alt=""><br><img src="/images/investment_stock_value_analysis_company_performance/5.PNG" alt=""></p>
</blockquote>
<h3 id="資訊電子業"><a href="#資訊電子業" class="headerlink" title="資訊電子業"></a>資訊電子業</h3><ul>
<li>台灣電子產業特性<ul>
<li>電子產業生命週期短，如果沒有開發新產品或創造有營利的產品，股價容易一落千丈</li>
<li>國內電子產業主要以代工為主，因此當國外廠商抽單時，營運馬上就發生危機</li>
<li>大多以出口為主，因此很受國外景氣與匯率影響極大</li>
<li>台灣的電子類股通常會引領大盤走向</li>
</ul>
</li>
</ul>
<blockquote>
<p><img src="/images/investment_stock_value_analysis_company_performance/6.PNG" alt=""></p>
</blockquote>
<h3 id="金融-保險-股"><a href="#金融-保險-股" class="headerlink" title="金融(保險)股"></a>金融(保險)股</h3><p>台灣的金融類股共有</p>
<ul>
<li>金融股<br>允許業者提供各種金融產品與服務，金控公司開始成立</li>
<li>商業銀行股<ul>
<li>銀行傳統收入大多來源放款與存款的利息差額，與外匯買賣、消費金融，近年改以手續費收入為收入來源</li>
<li>銀行放款大多為不動產抵押貸款，因此當房地產行情不佳時，呆帳增加則會降低銀行利潤</li>
</ul>
</li>
<li>保險股<br>分為<strong>壽險</strong>與<strong>產險</strong>，國人重視保險時有助於此產業的發展，但保險資金的投資運用有<strong>嚴格限制</strong>，經營上多投資不動產或國內外債券</li>
</ul>
<h2 id="國家發展計畫-2021年-2014年"><a href="#國家發展計畫-2021年-2014年" class="headerlink" title="國家發展計畫 2021年 - 2014年"></a>國家發展計畫 2021年 - 2014年</h2><ul>
<li>2016 年的 5+2 產業政策<br>加速台灣產業轉型並升級，提出<strong>智慧機械、亞洲矽谷、綠能產業、生醫產業、國防產業、新農業、循環經濟</strong>，來驅動台灣產業成長的核心</li>
<li>2020 年的 5+2 產業政策</li>
<li><em>強化半導體，建構 5G 與 AI 應用*</em>，鼓勵領航企業進行前瞻技術布局，提供研發經費補助，希望台灣成為亞洲研發核心</li>
<li>2021 - 2024 國家發展策略圖表<blockquote>
<p><img src="/images/investment_stock_value_analysis_company_performance/7.PNG" alt=""></p>
</blockquote>
</li>
</ul>
<h2 id="公司績效"><a href="#公司績效" class="headerlink" title="公司績效"></a>公司績效</h2><p>利用財報資訊來理解公司績效是<strong>基本分析</strong>的重要關鍵，通常透過 3 項財務數據作為指標</p>
<ul>
<li>ROE 股東權益報酬率 <ul>
<li>股東權益報酬率為企業為股東資金創造獲利的效率，比率越高表示股東獲利越多</li>
<li>\(ROE = (稅後淨利 / 銷售收入) * (銷貨收入 / 平均總資產 ) * (平均總資產 / 股東權利 ) \\ = 稅後淨利率 * 總資產周轉率 * 權益乘數\)</li>
<li>權益乘數<br>資產總額除以股東權益，表示企業負債程度，比率越高表示負債越高</li>
<li>通常 ROE 的主要變因在於<strong>稅後淨利率</strong></li>
<li><blockquote>
<p><img src="/images/investment_stock_value_analysis_company_performance/8.PNG" alt=""></p>
</blockquote>
</li>
</ul>
</li>
<li>ROA 總資產報酬率<br>評價企業運用全部資產的總體獲利能力，比率越高表示企業資產利用效益越好，企業盈利越強</li>
<li>EPS 每股盈餘</li>
<li><em>三項指標最為重要*</em>，對於有將股票在公開交易市場的企業而言，每股盈餘對企業的股價有一定的連動性</li>
</ul>
]]></content>
      <categories>
        <category>北科上課筆記</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>北科大二上投資學筆記</tag>
        <tag>北科大大二上投資學期中考筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>投資學 筆記 - 股票價值基本分析 (國內外政經事件與國內總經因素)</title>
    <url>/2020/12/05/NTUT_note/investment_stock_value_analysis_economic/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊與財金管理系大二上投資學重點整理<br><font color="#dd0000">並非所有人都適用，部分對我而言稍加容易的內容並不會寫在此內。</font><br>本章主要內容</p>
<ul>
<li>討論股票每股真實價值</li>
<li>分析影響股票市價因素</li>
</ul>
</blockquote>
<a id="more"></a>

<h1 id="基本分析"><a href="#基本分析" class="headerlink" title="基本分析"></a>基本分析</h1><h2 id="基本分析架構圖"><a href="#基本分析架構圖" class="headerlink" title="基本分析架構圖"></a>基本分析架構圖</h2><blockquote>
<p><img src="/images/investment_stock_value_analysis_economic/1.PNG" alt=""></p>
</blockquote>
<h3 id="國際與國內政經事件"><a href="#國際與國內政經事件" class="headerlink" title="國際與國內政經事件"></a>國際與國內政經事件</h3><ul>
<li>重大政治、金融風暴、戰爭與天災都會讓股市產生劇烈波動</li>
<li>經濟體越小的國家，國內政經動盪影響股市越大，反之亦同</li>
<li>政治變動，特別是民主國家的政權替換，通常會造成<strong>短期股市震盪</strong>，當大部分會回到原本走勢</li>
<li>天災、金融風暴、戰爭對股市影響特別大，基本上都需要非常長的時間才能回復到原本走勢</li>
</ul>
<h2 id="全球經濟"><a href="#全球經濟" class="headerlink" title="全球經濟"></a>全球經濟</h2><p>經濟成長率通長以一國的生產毛額(GDP)的年增率表示。</p>
<h5 id="QUESTION-What-is-the-difference-between-GDP-and-GNP"><a href="#QUESTION-What-is-the-difference-between-GDP-and-GNP" class="headerlink" title="QUESTION: What is the difference between GDP and GNP"></a>QUESTION: What is the difference between GDP and GNP</h5><ul>
<li>GDP 國內生產毛額<br>計算<strong>國內</strong>全部的生產毛額</li>
<li>GNP 國民生產毛額<br>計算<strong>國民</strong>全部的生產毛額，此國民無論人在國內國外都應該要被計算</li>
</ul>
<h3 id="各國經濟成長率與股市報酬率"><a href="#各國經濟成長率與股市報酬率" class="headerlink" title="各國經濟成長率與股市報酬率"></a>各國經濟成長率與股市報酬率</h3><ul>
<li>各國經濟成長率表示各國整體購買力，成長率越高就表示對未來的經濟發展越有淺力，國民投資能力越強</li>
<li>台灣是<strong>小型經濟開放體</strong>，依賴貿易，因此會受國際經濟景氣影響，特別是其他大型經濟體，如美國、中國、日本</li>
<li>股市通常比景氣更快反應，也就是說景氣要好轉前股市就會先好轉。P.S. 因為股市帶動景氣</li>
</ul>
<h2 id="匯率"><a href="#匯率" class="headerlink" title="匯率"></a>匯率</h2><ul>
<li>表示本國貨幣轉換成外國貨幣的比率，當本國貨幣可以換得更多外國貨幣則為<strong>升值</strong>，反之貶值</li>
<li>匯率會影響一國產品在國際市場的競爭力，匯率會影響整個產業，尤其以進出口為主要經濟活動的產業</li>
<li>新台幣升值時對進口廠商有利，對出口商不利；反之亦同。<br>因為我們進口時是給予外國貨幣，因此當新台幣升值時可以換得更多外國貨幣；出口時是對方給予我們外國貨幣，但因為本國貨幣升值，導致我們換回的新台幣變少而貶值。</li>
</ul>
<p>台灣進口美國產品，台灣廠商先換成美國貨幣在交易；台灣出口美國產品，美國則給予我們美國貨幣交易。</p>
<p>為甚麼都是以美國貨幣為主？因為在大多數情況下，交易都是用國際貨幣(通常是美金)為主</p>
<h3 id="貨幣通常被三項因素控制"><a href="#貨幣通常被三項因素控制" class="headerlink" title="貨幣通常被三項因素控制"></a>貨幣通常被三項因素控制</h3><ul>
<li>物價膨脹</li>
<li>國民所得、經濟成長率</li>
<li>利率水準</li>
<li>除了上面此三項因素，通常資金控制越開放的國家，匯率變動頻率也會越高</li>
<li>當市場預期新台幣貶值時，會擔心以新臺幣為主的資產縮水，因此市場投資人(特別是外資)會傾向將資金移出，造成資金外流，股市缺乏資金隨之下跌。</li>
</ul>
<h3 id="央行對於外匯管理措施"><a href="#央行對於外匯管理措施" class="headerlink" title="央行對於外匯管理措施"></a>央行對於外匯管理措施</h3><p>為了防止外資炒作外匯，中央銀行有對外資做些限制：</p>
<ul>
<li>資金停泊<br>外資匯入後，要在一周之內將新台幣投入股市，以免被誤認為有炒匯嫌疑</li>
<li>投資限額<br>央行規定，外資匯入後，購買公債等固定收益商品，不可超過匯入資金的三成，以免之後台灣匯率被國外控制</li>
<li>匯入<br>外資將外國貨幣轉入新台幣</li>
</ul>
<h2 id="經濟循環"><a href="#經濟循環" class="headerlink" title="經濟循環"></a>經濟循環</h2><p>一國的經濟循環變動稱為景氣循環，通常是指經過衰退、蕭條、復甦、繁榮，不斷來回的現象，股市可以看出景氣變得的特性，當股價上升時通常表時景氣準備上升、反之亦同。</p>
<p>用來觀測總體經濟景氣變化的指標為：景氣對策訊號、景氣動向指標</p>
<p>主要的總體經濟變數則包括：物價與油價、貨幣供給量、利率、採購經理人指數</p>
<h3 id="景氣對策信號"><a href="#景氣對策信號" class="headerlink" title="景氣對策信號"></a>景氣對策信號</h3><p>通常由國發會發布，透過利用多項經濟指標量化產生分數後，再將分數分級成某種燈號，來判斷經濟景氣的情況</p>
<ul>
<li><p>燈號</p>
<ul>
<li>綠燈 = 穩定</li>
<li>紅燈 = 熱絡</li>
<li>藍燈 = 低迷</li>
<li>紅黃燈 = 紅燈準備轉向綠燈</li>
<li>黃藍燈 = 藍燈準備轉向綠燈</li>
</ul>
</li>
<li><p>台灣股市與景氣對策訊號</p>
<ul>
<li>當藍燈出現時股價比較低，紅燈時股價高</li>
<li><strong>但景氣對策訊號有一項為股價指數，因此用來預測股市繁榮效用不高</strong></li>
<li>但如果長期持有股票且經濟體發展穩健，那反應到股價則時遲早問題</li>
</ul>
</li>
</ul>
<h3 id="景氣動向指標"><a href="#景氣動向指標" class="headerlink" title="景氣動向指標"></a>景氣動向指標</h3><p>將季節調整、標準化因子調整、加權平均後建構出的綜合性指標，可以反應出景氣的變動與幅度，且<strong>領先指標可以被投資分析所使用</strong></p>
<p>領先指標能夠<strong>提前</strong>反應景氣變動，轉折點也領先於景氣循環的轉折點，如果連續三個月往上則表示景氣將好轉，股價也會有好的表現</p>
<h3 id="油價與物價"><a href="#油價與物價" class="headerlink" title="油價與物價"></a>油價與物價</h3><ul>
<li>物價<ul>
<li>物價膨脹率可以用物價指數(CPI or WPI)的變動率計算，上升時會提高生產成本，產商如果沒辦法將成本轉嫁給消費者，將會影響到公司獲利而降低股價</li>
<li>中央銀行會抑止股價上速上揚，會採取緊縮性貨幣政策，例如調高利率或減少市面貨幣供給量，導致股市失去資金動能而下跌</li>
</ul>
</li>
<li>油價<ul>
<li>原油屬於上游原料，當油價上漲大多數的產品成本也會上漲，而影響產品價格進而間接影響股價(造成公司獲利減少)</li>
<li>如果是原油供給面減少則會讓經濟與股價<strong>全面性衰退</strong>；如果是需求面增加則有可能造成經濟與股價<strong>全面性上揚</strong><br>因為有更多需求表示可以為公司增加更多財富，但供給減少表示沒辦法讓公司增加財富還會增加公司生產成本</li>
</ul>
</li>
</ul>
<h3 id="貨幣供給量"><a href="#貨幣供給量" class="headerlink" title="貨幣供給量"></a>貨幣供給量</h3><p>在某一個特定時間，銀行體系的企業與個人能保油的通貨與存款總額，當貨幣供給量增加，市場上的資金不缺乏，充滿資金動能，股價容易上漲；當貨幣供給量減少則缺乏資金動能，股價容易下跌。</p>
<h4 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h4><ul>
<li>\(M_{1a} = 通貨發行淨額 + 支票存款 + 活期存款\)</li>
<li>\(M_{1b} = M_{1a} + 活期儲蓄存款 \)</li>
<li>\(M_2 = M_{1b} + 定期存款 + 郵政儲金 + 外國人持有本國貨幣 + 外幣定存 + 附買回交易\)</li>
<li>活期存款是<strong>法人或公司</strong>所持有</li>
<li>活期儲蓄存款為<strong>個人</strong>所持有</li>
</ul>
<h4 id="觀念"><a href="#觀念" class="headerlink" title="觀念"></a>觀念</h4><p>當 \(M_{1b}\) 年增率上升時表示有多餘的資金動能帶動股市上漲，特別是當年的 \(M_{1b}\) 年增率高於 \(M_2\) 且交叉向上形成黃金交叉表示市場資金充沛，資金動能更多，股票會有一段時間上漲(因為可以支配的錢已經比被鎖住的錢還多)</p>
<p>當 \(M_{1b}\) 年增率上升時會帶動股市上漲，當 \(M_{1b}\) 下降時常會造成股價下跌，\(M_2\) 則不明顯，因為大部分都是被鎖住資金，操作自由度不高</p>
<h3 id="利率"><a href="#利率" class="headerlink" title="利率"></a>利率</h3><ul>
<li>利率上升時會使投資人的報酬要求率上升，評估企業價值時，其價值會降低，股價也會降低</li>
<li>當利率上升時，如果股票投資率不高於銀行存款利率時，投資人會將資金放入銀行而不是股市</li>
<li>利率上升表示公司資金成本上升，使其獲利下降、股價下挫</li>
<li>長期利率的差距<br>長期的負斜率狀態與經濟率退有很高的關聯性，且經濟衰退又會導致股價下跌</li>
</ul>
<h3 id="採購經理人指數-PMI"><a href="#採購經理人指數-PMI" class="headerlink" title="採購經理人指數 PMI"></a>採購經理人指數 PMI</h3><p>以 50 作為製造業景氣好壞的分水嶺，當該指數高於 50 時表示景氣熱絡、對股市有利；反之亦同。</p>
<p>在台灣，2011 年開始有台灣製造業採購經理人指數，可作為投資人掌握台灣景氣波動的參考指標</p>
<h3 id="台灣經濟指標公布時間"><a href="#台灣經濟指標公布時間" class="headerlink" title="台灣經濟指標公布時間"></a>台灣經濟指標公布時間</h3><blockquote>
<p><img src="/images/investment_stock_value_analysis_economic/2.PNG" alt=""></p>
</blockquote>
]]></content>
      <categories>
        <category>北科上課筆記</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>北科大二上投資學筆記</tag>
        <tag>北科大大二上投資學期中考筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>演算法知識 - Two way search 雙向搜尋</title>
    <url>/2020/12/14/Explain_Algorithm/Two-way-search/</url>
    <content><![CDATA[<h2 id="Two-way-search-介紹"><a href="#Two-way-search-介紹" class="headerlink" title="Two way search 介紹"></a>Two way search 介紹</h2><blockquote>
<p>雙向搜尋主要是透過起點與終點都進都進行搜尋來獲得答案，主要是為了加快搜尋效率而產生的一種新觀念</p>
<p>下面將介紹兩種雙向搜尋演算法</p>
<ul>
<li>雙向同時搜尋</li>
<li>Meet in the middle </li>
</ul>
</blockquote>
<a id="more"></a>

<h2 id="雙向同時搜尋"><a href="#雙向同時搜尋" class="headerlink" title="雙向同時搜尋"></a>雙向同時搜尋</h2><p>基本作法是先透過起點端或終點端進行一次搜尋(BFS or DFS)，其中當起點在進行的搜尋與終點在進行的搜尋遇到時則表示找到答案解，在其必要時透過<strong>兩次搜尋</strong>，將沒有連接終點與起點的節點進行刪除(枝剪)。</p>
<h3 id="例題"><a href="#例題" class="headerlink" title="例題"></a>例題</h3><ul>
<li><a href="https://theriseofdavid.github.io/2020/12/14/UVa/UVa208/" target="_blank" rel="noopener">UVa 208 – Firetruck</a> </li>
</ul>
<h2 id="Meet-in-the-middle-中間相遇法"><a href="#Meet-in-the-middle-中間相遇法" class="headerlink" title="Meet in the middle 中間相遇法"></a>Meet in the middle 中間相遇法</h2><p>Meet in the middle 沒有正式的中文名稱，常見名稱<strong>中間相遇法</strong>，此觀念適用在於輸入數據較小，但並沒有小到能夠直接 brute force 的情況時就適合用 Meet in the middle。</p>
<p>基本作法為將一張圖切成兩部分，分別進行搜尋，最後再將兩邊的結果合併，brute force 的時間複雜度通常為 \(O(N_n)\)，但透過 Meet in the middle 可以將時間複雜度降為 \(O(N^{n/2})\)，方便我們去嘗試 brute force。</p>
<h3 id="例題-1"><a href="#例題-1" class="headerlink" title="例題"></a>例題</h3><ul>
<li><a href="https://theriseofdavid.github.io/2020/12/15/UVa/UVa1326/" target="_blank" rel="noopener">UVa1326 - Jurassic Remains</a></li>
</ul>
]]></content>
      <categories>
        <category>演算法知識</category>
      </categories>
      <tags>
        <tag>程式解題</tag>
        <tag>演算法知識</tag>
        <tag>雙向搜尋</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa208 - Firetruck (雙向搜尋-逆向搜尋)</title>
    <url>/2020/12/14/UVa/UVa208/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>在一個區域中必定會有一個消防局，現在有一個點失火，我們想知道從消防局到失火點的所有路徑，並且輸出。<br>請注意：消防員不願意接受繞圓此動作(繞了一個圓圈再回到某個點，即形成一個循環)，因為會影響他們的行進速度。</p>
<p>題目測資的點不會超過 22 個點，也就是路徑最多不會超過 22 條路徑。</p>
</blockquote>
<a id="more"></a>

<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>這題是使用雙向搜尋是最適合的題目之一，由於此題目必須要輸出每一個路徑，因此用 brute force 是最好的應用，但如果想到這邊然後就直接進行 DFS or BFS 搜尋就會遇到一個大麻煩，時間 TLE。</p>
<p>為甚麼會遇到 TLE 呢？我們舉個例子：我們假設道路都是單行道，只能向北走，想請問有沒有辦法從台北走到高雄？</p>
<p>答案是不行的，因為道路都是<strong>單行道且只能往北走</strong>台北往到高雄勢必是不可能，但程式會不斷嘗試的從台北出發往北的道路不斷進行搜尋，因此在道路複雜許多後就會造成 TLE 的問題，這時候就要用到一個觀念，<strong>雙向搜尋</strong>。</p>
<h2 id="雙向搜尋-同時搜尋"><a href="#雙向搜尋-同時搜尋" class="headerlink" title="雙向搜尋-同時搜尋"></a><a href="https://theriseofdavid.github.io/2020/12/14/Explain_Algorithm/Two-way-search/" target="_blank" rel="noopener">雙向搜尋-同時搜尋</a></h2><p>我們先從終點進行搜尋(<strong>反向搜尋</strong>)，透過終點搜尋(BFS,DFS)可以接觸到的所有節點，並記錄下來；之後再透過起點進行搜尋(<strong>正向搜尋</strong>)，在正向搜尋時再附加一個條件為<strong>必須要是反向搜尋有經過的節點</strong>，才可以確保目前正向搜尋的路線中是正確的方向，而不是在往錯誤的方向前進。</p>
<p>這裡我們則使用 DFS 進行撰寫。</p>
<h3 id="QUESTION-為甚麼要這樣寫呢？這樣不是把兩張一樣的圖搜尋過一遍嗎"><a href="#QUESTION-為甚麼要這樣寫呢？這樣不是把兩張一樣的圖搜尋過一遍嗎" class="headerlink" title="QUESTION: 為甚麼要這樣寫呢？這樣不是把兩張一樣的圖搜尋過一遍嗎"></a>QUESTION: 為甚麼要這樣寫呢？這樣不是把兩張一樣的圖搜尋過一遍嗎</h3><p>這個問題問得很好，我與我的演算法隊友齊笎經過一番論戰過後，找出原因，測試資料中有一筆測資是起點並沒有與終點連在一起，也就是他們是兩張分開的圖，其他的點則交互連在一起。</p>
<p>如果沒有這個反向 dfs 就會導致起點不斷的進行搜尋卻怎麼樣都沒有搜尋到終點，當測資一大時就會超時，極端的測資是 終點自己一個點，然後起點與其他點都互相連接，即每個點都有 n-2 個邊。扣掉終點與自己</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse_dfs</span><span class="params">(<span class="keyword">int</span> u )</span></span>&#123; <span class="comment">//反向搜尋</span></span><br><span class="line">    join[u] = <span class="number">1</span> ; <span class="comment">//join 紀錄反向搜尋會經過的點，1表示會經過</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; MAXN ; i++)</span><br><span class="line">        <span class="keyword">if</span>( !join[i] &amp;&amp; road[u][i] ) reverse_dfs(i);</span><br><span class="line">        <span class="comment">//road 表示這條路徑目前已經被用過</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="焦點回到題目上，解開題目的小設計"><a href="#焦點回到題目上，解開題目的小設計" class="headerlink" title="焦點回到題目上，解開題目的小設計"></a>焦點回到題目上，解開題目的小設計</h2><p>之後只需要做好每一次在讀取測試資料時要清除上筆測試的資料且<strong>題目輸出格式正確，輸出的路徑那行最後不可以有空白</strong>，即<code>1 3 5</code>，以及不要將 DFS 寫爛即可。</p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="http://acm.zzkun.com/archives/92" target="_blank" rel="noopener">UVa 208 – Firetruck [双向DFS]</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>雙向搜尋是我這一周碰到的新觀念，觀念雖然是簡單但其實如果用在題目上，我還會傻住，這也驗證了演算法一向都是觀念好懂，實作很難的事物阿，希望我之後可以善用此演算法在未來或是大型的演算法比賽中。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>其實就是沒有附上說明的程式碼，看得懂跟說得出來真的是兩回事，也許還有人覺得我說的很差，不過我已經盡力解釋。希望可以幫助到各位。</p>
<p>也希望大家想要學習的知識都可以快速學習而成，不要因為自身的環境不足而學習不到。</p>
<p>於是這裡就補述一些題目給的資料範圍限制與標頭檔了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 22</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n , kase , cnt , vis[MAXN] , road[MAXN][MAXN] , join[MAXN];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse_dfs</span><span class="params">(<span class="keyword">int</span> u )</span></span>&#123;</span><br><span class="line">    join[u] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; MAXN ; i++)</span><br><span class="line">        <span class="keyword">if</span>( !join[i] &amp;&amp; road[u][i] ) reverse_dfs(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u )</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u == n )&#123; <span class="comment">//到達終點，輸出路徑</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; res.size()<span class="number">-1</span> ; i++) <span class="built_in">cout</span> &lt;&lt; res[i] &lt;&lt; <span class="string">' '</span> ;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; res[res.size()<span class="number">-1</span>] ;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">        cnt++ ;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; MAXN ; i++)&#123; </span><br><span class="line">        <span class="keyword">if</span>(!vis[i] &amp;&amp; road[u][i] &amp;&amp; join[i] )&#123; <span class="comment">//符合條件後記錄節點 </span></span><br><span class="line">            vis[i] = <span class="number">1</span> ;</span><br><span class="line">            res.push_back(i);</span><br><span class="line">            dfs(i);</span><br><span class="line">            res.pop_back();</span><br><span class="line">            vis[i] = <span class="number">0</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123; <span class="comment">//清除資料並重新整理</span></span><br><span class="line">    <span class="built_in">memset</span>(road,<span class="number">0</span>,<span class="keyword">sizeof</span>(road));</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="built_in">memset</span>(join,<span class="number">0</span>,<span class="keyword">sizeof</span>(join));</span><br><span class="line">    cnt = <span class="number">0</span> ;</span><br><span class="line">    res.clear();</span><br><span class="line">    vis[<span class="number">1</span>] = <span class="number">1</span> ;</span><br><span class="line">    res.push_back(<span class="number">1</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> );</span><br><span class="line">    freopen(<span class="string">"out.txt"</span> , <span class="string">"w"</span> , <span class="built_in">stdout</span>) ;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">int</span> a,b ;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n)&#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &amp;&amp; a &amp;&amp; b )&#123; </span><br><span class="line">            road[a][b] = <span class="number">1</span> ; road[b][a] = <span class="number">1</span> ; <span class="comment">//紀錄路徑</span></span><br><span class="line">        &#125;</span><br><span class="line">        reverse_dfs(n);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"CASE "</span> &lt;&lt; ++kase &lt;&lt; <span class="string">":\n"</span> ;</span><br><span class="line">        dfs(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"There are "</span> &lt;&lt; cnt &lt;&lt; <span class="string">" routes from the firestation to streetcorner "</span> &lt;&lt; n &lt;&lt; <span class="string">".\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="紙筆紀錄"><a href="#紙筆紀錄" class="headerlink" title="紙筆紀錄"></a>紙筆紀錄</h2><p>上方有一點提到我與齊笎進行探討，我將我們在那邊進行廝殺的紀錄放在此處，留念XD。</p>
<p><img src="https://i.imgur.com/DDeJi7M.jpg" alt=""></p>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>演算法知識</tag>
        <tag>雙向搜尋</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa1326 - Jurassic Remains (雙向搜尋-Meet in the middle、位元運算)</title>
    <url>/2020/12/15/UVa/UVa1326/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>考古學家們挖到恐龍化石，但恐龍化石太大沒有辦法被載送回來，於是考古學家就將化石切成零件，並做上標記，載回博物館；但遇到了一個麻煩，同時有另外一批化石也被送回博物館，同時也是將化石切稱 零件，運氣不好的是他們的零件標記與我們使用的符號相同，我們的目標就是找出我們的恐龍化石，並且透過我們的零件組回化石。</p>
<p>有五點需要特別注意：</p>
<ul>
<li>零件組合必須是兩個相同的標籤組成</li>
<li>每一個化石標籤，都必須都有相同的化石標籤且<strong>不一定是</strong>另外一個零件，也可以是自己的</li>
<li>我們找回的化石必須要是零件配對數量最大的，也就是零件配對數量必須要最高</li>
<li>一個零件中的所有標籤，每一個都必須被使用到</li>
<li>零件最多不會超過 25</li>
</ul>
</blockquote>
<a id="more"></a>


<h2 id="懶人包題目大意："><a href="#懶人包題目大意：" class="headerlink" title="懶人包題目大意："></a>懶人包題目大意：</h2><p>是不是覺得上面很煩不想看？因此我有特別寫一個簡單版的。</p>
<p>利用題目測試資料的 x 行選出 y 行能夠將每一個字母的數字總合為偶數，且 y 必須是最大。<del>好懂了八</del></p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>由於必須輸出最大的行數且必須要輸出有哪些行，因此這裡 brute force 會是最好的選擇。</p>
<p>這題 Udebug 沒有提供測資，好難過啊QwQ。</p>
<h3 id="時間複雜度"><a href="#時間複雜度" class="headerlink" title="時間複雜度"></a>時間複雜度</h3><p>我們先來分析一下時間複雜度，如果使用 brute force 時複雜度會是 \(O(2^24)\)，選或不選並且有至少有 24 個英文字母，時間複雜度會太高，因此我們這邊使用<a href="https://theriseofdavid.github.io/2020/12/14/Explain_Algorithm/Two-way-search/" target="_blank" rel="noopener">雙向搜尋-Meet in the middle</a>，將時間複雜度優化至\(O(2^{12} * 12) \)，選或不選有 12 個英文字母，且每一個都可以在與另外 12 個英文字母考慮選或不選，</p>
<ul>
<li>時間複雜度 \(O(2^{24})\)，運行時間為 1.110s<br>程式碼由<a href="https://blog.csdn.net/keshuai19940722/article/details/18995013" target="_blank" rel="noopener">JeraKrs 提供</a></li>
<li>時間複雜度 \(O(2^{12} * 12\)，運行時間為 0.3s</li>
</ul>
<h3 id="雙向搜尋-Meet-in-the-middle"><a href="#雙向搜尋-Meet-in-the-middle" class="headerlink" title="雙向搜尋-Meet in the middle"></a><a href="https://theriseofdavid.github.io/2020/12/14/Explain_Algorithm/Two-way-search/" target="_blank" rel="noopener">雙向搜尋-Meet in the middle</a></h3><p>透過雙向搜尋-Meet in the middle，我們將 12 個字母分成一組，再將兩組合併，只要這兩組的字母合起來為偶數並偶數數量為最大值時則代表我們搜尋成功。</p>
<h3 id="字母-Hash"><a href="#字母-Hash" class="headerlink" title="字母 Hash"></a>字母 Hash</h3><p>稍微複習一下，左移(<code>a &lt;&lt; b</code> )，為 \(a * 2 ^ b\)、右移(<code>a &gt;&gt; b</code>)，為 \(a / 2 ^ b\)</p>
<p>在這題，我們將運用到全新的黑科技(神奇的寫法)，透過<strong>二進位</strong>來 hash 每一個字母，A 為 1、B 為 2、C 為 4、D 為 8，想必大家都看的出來了，沒錯，那就是透過二進位的位數來進行 hash，因此程式碼會這樣寫</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> &lt;&lt; (<span class="built_in">string</span>[j] - <span class="string">'A'</span>) <span class="comment">//找出該字母的 hash</span></span><br></pre></td></tr></table></figure>

<p>再聰明一點的朋友肯定會更多想一步，那這樣我就可以透過加法來給出每一行字串的 hash 了，這時候要請大家再回去看<a href="https://theriseofdavid.github.io/2020/12/15/UVa/UVa1326/#題目大意：" target="_blank" rel="noopener">題目大意</a>需要注意的第二點，那些標籤也可以跟自己的字串組合，因此這裡我們不使用加法而是使用 <strong>xor</strong>，來解決此問題，透過 xor 在兩個字母的 hash 都一樣時會變回 0，就可以方便處理到加法會進位的問題。</p>
<p>舉例： <code>3 xor 3 = 0</code></p>
<p>因此我們的 hash 字母可以這樣寫：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">memset</span>(mark,<span class="number">0</span>,<span class="keyword">sizeof</span>(mark)); <span class="comment">//mark 為每一行存的 hash 值</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i++)&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; temp ;</span><br><span class="line">    x = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; temp.length() ; j++)</span><br><span class="line">        x ^= <span class="number">1</span> &lt;&lt; (temp[j] - <span class="string">'A'</span>); <span class="comment">//字母 hash 並檢查奇偶數</span></span><br><span class="line">    mark[i] = x ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="雙向搜尋-Meet-in-the-middle-實作"><a href="#雙向搜尋-Meet-in-the-middle-實作" class="headerlink" title="雙向搜尋-Meet in the middle 實作"></a>雙向搜尋-Meet in the middle 實作</h3><p>這裡也要用到 2 進位，2 進位真的好用。</p>
<p>透過二進位的關係，可以寫出一種組合為<strong>全部的資料運用</strong>，我們用舉例的應該大家會比較好懂：</p>
<h4 id="舉例：n-3，我們想要輸出-3-的全部組合"><a href="#舉例：n-3，我們想要輸出-3-的全部組合" class="headerlink" title="舉例：n = 3，我們想要輸出 3 的全部組合"></a>舉例：n = 3，我們想要輸出 3 的全部組合</h4><p>n = 3，於是我們找到二進位位數等於 3 的最大值 = 7，並透過 for(i &lt;= 8)，對 i 變數中位元為 1 的值紀錄可以發現以下有趣的事：</p>
<table>
<thead>
<tr>
<th>數字</th>
<th>位元為 1 的值紀錄</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>2</td>
<td>1</td>
</tr>
<tr>
<td>3</td>
<td>0,1</td>
</tr>
<tr>
<td>4</td>
<td>2</td>
</tr>
<tr>
<td>5</td>
<td>0,2</td>
</tr>
<tr>
<td>6</td>
<td>1,2</td>
</tr>
<tr>
<td>7</td>
<td>0,1,2</td>
</tr>
<tr>
<td>8</td>
<td>3</td>
</tr>
</tbody></table>
<p>透過紀錄每一個數字位元為 1 的值，竟然可以將每一行的組合都找到！太神了拉！</p>
<p>其實是利用二進位的數字增加，透過此方式來找出全部的組合。</p>
<h3 id="回歸焦點"><a href="#回歸焦點" class="headerlink" title="回歸焦點"></a>回歸焦點</h3><p>我們現在已經可以找出全部的組合了，再來就是要每個組合進行 xor，並且保存記錄下來，值得注意的地方則是假如有兩個的 hash 值為一樣時，題目要求的是組合行數最大，因此當兩個 hash 值相同時我們則要找出使用最多行的 hash 值作為標準(最多行的組合)，因此我們再透過<code>__builtin_popcount</code>函數可以幫助我們找出此數字內有多少個 1，來完成此判斷。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m1 , m2 ; <span class="comment">//紀錄 m1 為拆開的前半圖、m2為拆開的後半圖</span></span><br><span class="line"><span class="keyword">int</span> div1 = n/<span class="number">2</span> , div2 = n - n/<span class="number">2</span> ; <span class="comment">//div1 為前半圖的寬度,div2 為後半圖的寬度</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; ( <span class="number">1</span> &lt;&lt;div1) ; i++ )&#123; <span class="comment">// 1 &lt;&lt; div1 找到最大位數</span></span><br><span class="line">    x = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; div1 ; j++ )&#123; <span class="comment">//div1 檢查這三位數即可</span></span><br><span class="line">        <span class="keyword">if</span>((i &gt;&gt; j ) &amp; <span class="number">1</span>) x ^= mark[j] ; <span class="comment">//紀錄有 1 的位數，並且讓他與那行進行 hash</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!m1.count(x) || __builtin_popcount(m1[x]) &lt; __builtin_popcount(i) ) </span><br><span class="line">    <span class="comment">//比較是否有更多行的組合</span></span><br><span class="line">        m1[x] = i ; <span class="comment">//紀錄用到的行數，之後可以用位元為 1 的值回推</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; (<span class="number">1</span> &lt;&lt; div2) ; i++)&#123; <span class="comment">// 1 &lt;&lt; div2 的最大位數</span></span><br><span class="line">    x = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; div2 ; j++)&#123; <span class="comment">//div2 檢查這三位數即可</span></span><br><span class="line">        <span class="keyword">if</span>((i &gt;&gt; j ) &amp; <span class="number">1</span>) x ^= mark[j + div1]; </span><br><span class="line">        <span class="comment">//紀錄有 1 的位數，並且讓他與那行進行 hash，並且 mark[j + div1]，</span></span><br><span class="line">        <span class="comment">//需要加 div1 是因為這是後半張的圖，且我們 index 從 0 開始，因此只需要加 dvi1，不須 +1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!m2.count(x) || __builtin_popcount(m2[x]) &lt; __builtin_popcount(i) )</span><br><span class="line">    <span class="comment">//比較是否有更多行的組合</span></span><br><span class="line">        m2[x] = i ; <span class="comment">//紀錄用到的行數，之後可以用位元為 1 的值回推</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="結合兩張圖，找出答案"><a href="#結合兩張圖，找出答案" class="headerlink" title="結合兩張圖，找出答案"></a>結合兩張圖，找出答案</h3><p>現在我們將兩張圖都執行完畢也得到結果了，那是時候進行合併了！要怎麼合併呢？我們只需要查詢 m1 的資料有沒有在 m2 裡面就可以了！</p>
<p>為甚麼只需要這樣做呢？是因為我們 m1,m2 分別存了兩張圖的所有組合，我們只要找出這兩張圖組合起來最大的值即可，所以不需要檢查前半圖某一的組合裡面的某幾行是否有跟後半圖的某幾行形成偶數，因為這樣就會是前半圖的另外一個組合選項，故此不用。</p>
<p>並且記錄最大配對數量與最多配對行的 hash 即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> resMask = <span class="number">0</span> , resCnt = <span class="number">0</span> ; <span class="comment">//resCnt 最大的配對數量</span></span><br><span class="line"><span class="comment">//resMask 紀錄我們用到的值，hash 狀態，方便我們之後透過位元為1的位數來回推用到的行數 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it : m1)&#123; <span class="comment">//不斷進行配對</span></span><br><span class="line">    <span class="keyword">if</span>(m2.count(it.first))&#123; <span class="comment">//找到適合的配對</span></span><br><span class="line">        x = (m2[it.first] &lt;&lt; div1) | it.second ; </span><br><span class="line">        <span class="comment">//(m2[it.first] &lt;&lt; div1) 我們先前存的資料行數是假設為這是一張獨立分開的圖，</span></span><br><span class="line">        <span class="comment">//因此現在我們進行合併，就要將資料行數返回題目原本正確的行數，因此幫她 &lt;&lt; div1 </span></span><br><span class="line">        <span class="keyword">if</span>(resCnt &lt; __builtin_popcount(x)) resCnt = __builtin_popcount(x) , resMask = x ;</span><br><span class="line">        <span class="comment">//如果有比當前配對最大數量還高時，我們就將 resCnt , resMask 換成現在的值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="hash-resMask"><a href="#hash-resMask" class="headerlink" title="hash resMask"></a>hash resMask</h3><p>這時候我們將記錄好的 resMask，解密成我們原本要的值，透過之前的表格可以得知，假如我們的 <code>resMask = 7</code>，則我們用到的行數則是 1,2,3，因此我們只需要將紀錄的 resMask 找出所有位數為 1 的值就能將值解密成功。</p>
<p>需要注意的是，在輸出時，每行的最後一個都必須是數字，而不是空格。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> flag = <span class="number">1</span> ; <span class="comment">//紀錄第一個值是否已經被印出</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; resCnt &lt;&lt; <span class="string">'\n'</span> ; <span class="comment">//印出最大配對數量</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>((resMask &gt;&gt; i) &amp; <span class="number">1</span>)&#123; <span class="comment">//判斷 i 位數是否為 1</span></span><br><span class="line">        <span class="keyword">if</span>(flag) <span class="built_in">cout</span> &lt;&lt; i+<span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; i+<span class="number">1</span> ;</span><br><span class="line">        flag = <span class="number">0</span> ; <span class="comment">//被輸出因此設成 0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h3><p>記住如果是要判斷字典是否有此值時請使用，<code>if(map.count(i))</code>，而不是<code>if(map[i])</code>，在現在的 UVa Judge 中，只有第一種可以被允許使用，第二種目前不行，因此請不要隨意亂使用</p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>老實講，難的不是雙向搜尋，而是位元運算阿…，特別是那個透過二進位加法來找出全部的組合真的是跟神一樣，這是我從來沒有想過的解決方案，讓我在這邊學到了，算是非常開心呢！雖然自學演算法真的是一件非常痛苦的事情，但學習成功的成就感以及能讓腦袋智力快速上升的感覺真的事非常痛快呢！</p>
<p>也希望我可以在比賽中成功使用到我所學習到的演算法，或是在生活中用到，那是再好不過的了！</p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://blog.csdn.net/sinat_36215255/article/details/78266381?utm_medium=distribute.pc_relevant.none-task-blog-searchFromBaidu-1.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-searchFromBaidu-1.control" target="_blank" rel="noopener">[UVA-1326] （暴力+位运算+中间相遇法）</a><br><a href="http://morris821028.github.io/2015/04/27/uva-1326/" target="_blank" rel="noopener">UVa 1326 - Jurassic Remains</a><br><a href="https://blog.csdn.net/keshuai19940722/article/details/18995013" target="_blank" rel="noopener">uva 1326 - Jurassic Remains(暴力+位运算+中间相遇法）</a></p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>其實就是沒有附上說明的程式碼，看得懂跟說得出來真的是兩回事，也許還有人覺得我說的很差，不過我已經盡力解釋。希望可以幫助到各位。</p>
<p>也希望大家想要學習的知識都可以快速學習而成，不要因為自身的環境不足而學習不到。</p>
<p>於是這裡就補述一些題目給的資料範圍限制與標頭檔了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 30</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="keyword">int</span> n , mark[MAXN] , x ;</span><br><span class="line"><span class="built_in">string</span> temp ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(mark,<span class="number">0</span>,<span class="keyword">sizeof</span>(mark));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; temp ;</span><br><span class="line">            x = <span class="number">0</span> ;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; temp.length() ; j++)</span><br><span class="line">                x ^= <span class="number">1</span> &lt;&lt; (temp[j] - <span class="string">'A'</span>);</span><br><span class="line">            mark[i] = x ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m1 , m2 ;</span><br><span class="line">        <span class="keyword">int</span> div1 = n/<span class="number">2</span> , div2 = n - n/<span class="number">2</span> ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; ( <span class="number">1</span> &lt;&lt;div1) ; i++ )&#123;</span><br><span class="line">            x = <span class="number">0</span> ;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; div1 ; j++ )&#123;</span><br><span class="line">                <span class="keyword">if</span>((i &gt;&gt; j ) &amp; <span class="number">1</span>) x ^= mark[j] ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!m1.count(x) || __builtin_popcount(m1[x]) &lt; __builtin_popcount(i) )</span><br><span class="line">                m1[x] = i ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; (<span class="number">1</span> &lt;&lt; div2) ; i++)&#123;</span><br><span class="line">            x = <span class="number">0</span> ;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; div2 ; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>((i &gt;&gt; j ) &amp; <span class="number">1</span>) x ^= mark[j + div1];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!m2.count(x) || __builtin_popcount(m2[x]) &lt; __builtin_popcount(i) )</span><br><span class="line">                m2[x] = i ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> resMask = <span class="number">0</span> , resCnt = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it : m1)&#123;</span><br><span class="line">            <span class="keyword">if</span>(m2.count(it.first))&#123;</span><br><span class="line">                x = (m2[it.first] &lt;&lt; div1) | it.second ;</span><br><span class="line">                <span class="keyword">if</span>(resCnt &lt; __builtin_popcount(x)) resCnt = __builtin_popcount(x) , resMask = x ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">1</span> ;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; resCnt &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((resMask &gt;&gt; i) &amp; <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(flag) <span class="built_in">cout</span> &lt;&lt; i+<span class="number">1</span> ;</span><br><span class="line">                <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; i+<span class="number">1</span> ;</span><br><span class="line">                flag = <span class="number">0</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="在寫-UVa-1326-的紙筆紀錄"><a href="#在寫-UVa-1326-的紙筆紀錄" class="headerlink" title="在寫 UVa 1326 的紙筆紀錄"></a>在寫 UVa 1326 的紙筆紀錄</h2><p>因為只是自己在思考過程中隨手做的筆記，覺得不是對讀者這麼有幫助，因此放在文章最下面。</p>
<p>有時候用想或用看的可能不太能夠懂這演算法，那就用寫的吧！這是大衛我自己學習的手稿，紀錄者我的學習過程。</p>
<p><img src="/images/UVa11475/2.jpg" alt=""></p>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>演算法知識</tag>
        <tag>雙向搜尋</tag>
        <tag>位元運算</tag>
      </tags>
  </entry>
  <entry>
    <title>人生規劃書 - 20201218</title>
    <url>/2020/12/18/life_experence/Life_Plan_20201218/</url>
    <content><![CDATA[<h2 id="說明"><a href="#說明" class="headerlink" title="說明"></a>說明</h2><blockquote>
<p>由於最近的自己一直沒辦法安下心來，不斷的充滿迷茫感，於是特地寫下我對於我人生的要求，之後再不斷進行修正或更改八。</p>
<p>如果用公司來比喻的話，那麼這家公司的目標、產業發展都不明確(自己的規劃)，而股東們都有自己的想法，公司提出來的版本都還沒有辦法讓每位股東願意信服、投資，因此讓每位股東對這家公司感到擔憂、不信任。</p>
</blockquote>
<a id="more"></a>

<h2 id="前提概要："><a href="#前提概要：" class="headerlink" title="前提概要："></a>前提概要：</h2><p>我在高一入學時，暑假作業有一個是要寫給三年後的自己的作業，有點類似於時光膠囊，只是他保證一定會在高三畢業還給你XD，我很謝謝那位有提出此想法的老師，他讓我更有深度、更有眼界。</p>
<p>在高一時候的我寫下了對自己的期望，現在的我還記得的就只剩下，有沒有考上台中科大、有沒有跟初戀和好，有沒有開開心心的？</p>
<h3 id="稍微來回顧一下"><a href="#稍微來回顧一下" class="headerlink" title="稍微來回顧一下"></a>稍微來回顧一下</h3><ul>
<li>有沒有考上中科呢？<br>不只考上了中科，甚至考上了北科，還對北科不滿足(<del>另類的貪心</del>)。但自己在高中付出了極大的努力，甚至可以說是燃燒生命八，我捨棄了我所愛的一切，就只為了讓自己達到此目標，個人認為代價似乎有點太大了。但整體而言是好的，有完成到</li>
<li>跟初戀和好嘛<br>老實說，沒有。<br>真的沒有，基本上我的高一難過都是因為我的初戀而難過，我那時候真的很喜歡他，我覺得我這個人最大的錯誤、最大的罪惡就是讓喜歡我的女生傷心離開。</li>
<li>有沒有開開心心的？<br>老實講，沒有。<br>我在高二的時候曾經被我們班的人陷害，他們讓我很難過一陣子，也讓我了解到霸凌的滋味，這是我第一次被霸凌，因此我從此之後就具有強大的正義，不允許別人欺負別人。<br>但也是因為他們的霸凌使我優秀了起來，因為他們欺負我，激發出我要離開此環境的慾望，讓我與隔壁班的建名合作參加科展與專題，之後努力學習程式得到了金手獎，因此送上北科。<br>我發現人都是現實的，但你的成就、名聲都比別人高時，基本上別人就不會瞧不起你，還會尊重你，當我陸續拿到許多獎項後，沒有人再欺負我，因為我的價值比他人高，這很不好。但我想這就是現實。</li>
</ul>
<h2 id="大二的自己"><a href="#大二的自己" class="headerlink" title="大二的自己"></a>大二的自己</h2><p>由於現在對未來的自己充滿期待也還怕失敗，於是乎我希望自己能夠給予每一個階段的自己信任這個由每一個階段的自己所構出來的人物，現在我要寫出一份關於目前的我對於未來的計劃，並在 2021 年 12 月再寫一次進行核對與檢討、修正，讓大三的自己來改進大二寫的企劃，或是完全重寫一次。</p>
<h2 id="人生規劃："><a href="#人生規劃：" class="headerlink" title="人生規劃："></a>人生規劃：</h2><h3 id="短期目標-大學結束前"><a href="#短期目標-大學結束前" class="headerlink" title="短期目標 - 大學結束前"></a>短期目標 - 大學結束前</h3><p>此短期目標比較具有可視性，我也比較知道如何去規劃，不至於有太大的變動，目前的主要想法如下：</p>
<ul>
<li>寫好演算法，拿到 ICPC 2021 銀獎<br>這目標是我的最主要目標，演算法是我的核心也是我成長的關鍵。寫好演算法等於我鞏固了我的所有知識與深度，因此我認為我需要被某個檢定或考試認可，ICPC 是我目前所知最大型、最重要的比賽之一，因此我需要拿到銀獎</li>
<li>投資股票，希望投資報酬可以來到 50% 1 年，目前預計本金是 10 萬<br>投資是很重要的課題，我相信是這樣的事情。透過投資可以有效利用財富來讓我去獲得世上更好的資源，希望能夠透過我未來學習到的知識幫助我在投資的路上更順，畢竟在世界上錢可以解決一定的壓力與紛爭，特此我需要學會投資來減輕我的壓力。</li>
<li>認識統計，類似 UVa 的題目來讓我練習<br>統計是我很需要學會的一件事情，到目前為止的人生中，我有太多的事情是值得被統計量化而我卻只是用文字帶過，當我學會了統計，我相信能夠更認識我自己，明白我自己的性格、優點、弱點。</li>
<li>找到一份薪水有 500 元的工作<br>老實講，這可能有點難完成。但我認為我需要這樣要求自己，因為當公司願意開給我 500 元的價值時表示我在社會上是一定有 500 元的價值，這是客觀認定。我需要透過客觀的認定來讓我知道社會中我是屬予那一塊的人，社會或企業有沒有需要我，我能夠透過一份工作的薪水來知道我在這間社會、產業是多麼重要或是不需要的人。</li>
<li>減肥，目標是 70 KG<br>我知道體重是我現在蠻大的一個缺點，我不瘦，我自認我沒有很胖，但我知道肥胖確實對身體不好，也會對於我的體力造成影響，因此我需要減肥，他對於我的人生各方面都有好處，只是我常將時間分配給上面的重點，而不會給減肥，因為我個人對於吃很要求，如果有好吃的食物會讓我在各方面開心許多，期許我會給予自己一些機會去運動、健身。透過在家健身的方式來讓自己的體態稍微棒些。</li>
<li>學會基本穿搭<br>我認為穿搭會讓我在社交時增加自信，在增加自信的同時我想會對於我在與他人交流時增加我意見的權重，我知道蠻多人再開會或是討論意見時，其實都不是對於這意見進行發表，而是先看是誰發表意見才來思考這意見是不是好意見，因此我把穿搭先學好，可以讓一些比較膚淺的人對於我不會有偏見，讓我在社會立足時會更好些。</li>
<li>讀好英文，多益能上 700<br>這應該比較不好達成，我是這麼認為的。因為我會將時間花在上面，可能對於英文不會那麼的重視，但姑且先放在這，讓明天的我可以來罵過去的自己XD。</li>
<li>讀好日文，檢定能上 N5<br>我相信這也很難達成，但我認為學會日文還蠻重要的，我很喜歡日本的事物，我蠻想要去多了解一下，透過學習他人國家的環境來讓我自身有所成長，我覺得這會是一個很好的學習歷程與機會，當然我需要去學習其他國家的語言，但以我目前的所在環境中，除了中文、英文，日文應該會是我最有動力學習的語言。</li>
</ul>
<h3 id="中期目標-研究所"><a href="#中期目標-研究所" class="headerlink" title="中期目標 - 研究所"></a>中期目標 - 研究所</h3><p>目前只希望自己可以考上台清交成，且是自己所喜歡的科目。如果能考上國外的研究所且比台清交成更好那是再好不過的。</p>
<p>因為我沒有辦法對於自己的中期目標看到方向，現在只能夠大概的描述方向，細節可能需要交給未來的我來規劃。</p>
<h3 id="長期目標-研究所畢業到-30-歲"><a href="#長期目標-研究所畢業到-30-歲" class="headerlink" title="長期目標 - 研究所畢業到 30 歲"></a>長期目標 - 研究所畢業到 30 歲</h3><ul>
<li>步入婚姻<ul>
<li>原因<br>婚姻是人生中重要的一件事情，雖然現在的我認為我還是很對不起喜歡過我的女生，但我認為我需要愛情，沒有愛情的我沒有辦法讓我自己找到安全感與立足點，因此我認為我需要一個愛情來滋潤我的生活，在我難過時給予我打氣、加油，讓我有勇氣再站起來。</li>
</ul>
</li>
<li>老婆要有的特質<ul>
<li>愛我<br>這很重要，沒有愛我哪來美滿的家庭，或許連家庭都稱不上。</li>
<li>溫柔<br>家庭應該要是我的後盾，我不允許家庭對待我是沒有尊嚴或尊重的，我的努力一定必須要在家庭中受到肯定，畢竟我的成長一定會等比例的給予家庭正面影響。如果失去了溫柔，那我很高機率不會喜歡家裡的失誤，導致我對家的責任失格。</li>
<li>會撒嬌<br>我需要被補充一些男子氣概，不可否認的，我在難過或失意時是非常脆弱的，如果這時候沒有一位女孩來撒嬌或安慰我，我很有可能會放棄我在此領域的研究或是要花很大的時間才能走出來，就像情傷一樣，我到現在還是沒有走出來。</li>
<li>長相我喜歡<br>一定是需要一位長相是我喜歡的人，這樣我才會回家時有種驕傲且幸福的感覺！我是視覺動物，還是需要視覺被滋潤的，不然當我上班永遠都是看到男生，整個價值觀會偏差的。</li>
<li>沒有重大病痛，至少要在我能夠接受的範圍內<br>這點是一定要遵守的，再好的女生也不可以有重大病痛，有重大病痛的女生在他發生關於性命的事件時，我是會擔憂到吃不下飯、睡不著覺的，要是他提前離開此世界那就等於我失去了世上最好的女生了，再讓我找一個我也會覺得自己對他很不負責任，為了我的自私，因此我不會跟重大病痛的女生組成家庭，我會害怕我哪天失去它，自從失去她的那天我就失去了我面對世界的勇氣。</li>
</ul>
</li>
</ul>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>希望每一個階段的我在不安心的時候都能想起來，大二的我有打此篇文章，透過閱讀大二的我來堅強自己內心，對自己充滿信心。我知道世界上的任何一件負面情緒都會對自己帶來受傷的心情，但我們要知道一件事情，我們都是大衞的一份子，如果我們被打倒了，那麼大衛就被打倒了，如果我們團結了，那麼大衛就團結了，如果我們成功了，那麼大衛就成功了。</p>
<p>只要我們一起努力，即使大衛沒有成為優秀的人，我們也會笑著說<strong>我們很棒吧</strong>，一同完成了這麼偉大的一件事情。</p>
]]></content>
      <categories>
        <category>人生旅途</category>
      </categories>
      <tags>
        <tag>大學Life</tag>
        <tag>人生旅途</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa118 - Mutant Flatworld Explorers (實作題)</title>
    <url>/2020/12/24/UVa/UVa118/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>我們命令機器人依照我們的指令在陸地上移動，如果機器人根據我們的指令跳入海裡時，那接下來的機器人會知道那邊是海，而不會執行我們的指令。</p>
<p>舉例：假如向前走會掉入海裡，那則不會執行命令</p>
<p>指令有向左轉與向右轉、往前走，一開始會給你地圖的右上角，之後就是每一個機器人與其需要執行的指令。</p>
<p>題目要求 由於是根據向量座標，於是往北走的座標則為 x,y+1 , 南(x,y-1) , 西(x-1,y) , 東(x+1,y)</p>
</blockquote>
<a id="more"></a>


<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>簡單的實作題，根據地圖的大小，以及其方向執行命令，然後我們透過 map 記住現在的機器人掉入海的方向與其 x,y 座標，如果接下來有其他機器人也碰到此情況就不執行指令，然後需要記住題目給定的座標方向QQ。(我沒看懂這座標方向浪費了一堆時間)。</p>
<p>需要記住的是只有<strong>向前走</strong>才會掉入海哩，所以轉向的指令都會被執行。</p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>嗚嗚，英文好難。</p>
<p>圖論搜尋的題目再給予向量座標時跟用二維陣列的表格差太多了，我習慣的北方是(x-1,y)，但她的卻是 (x,y+1)， 還有想太少XD，我漏想只有往前走在會掉入海裡，原本的程式碼只要轉向朝海就會被我不執行XDDD，太貼心了www。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 110</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">map</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;,<span class="keyword">int</span>&gt; mp_lost ;</span><br><span class="line"><span class="keyword">int</span> direct[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;&#125; ;</span><br><span class="line"><span class="keyword">int</span> n , m ; <span class="comment">// n,m is border and d is now direct</span></span><br><span class="line"><span class="keyword">int</span> sx , sy , tx , ty , d ; <span class="comment">//start x , start y ,</span></span><br><span class="line"><span class="built_in">string</span> ins , str_d; <span class="comment">//instruction</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; map_sd ;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="built_in">string</span>&gt; back_sd ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">in_grid</span><span class="params">(<span class="keyword">int</span> x , <span class="keyword">int</span> y , <span class="keyword">int</span> d  )</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; <span class="number">0</span> || x &gt; n )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">if</span>(y &lt; <span class="number">0</span> || y &gt; m )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> );</span><br><span class="line">    freopen(<span class="string">"out.txt"</span> , <span class="string">"w"</span> , <span class="built_in">stdout</span> );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ;</span><br><span class="line">    map_sd[<span class="string">'N'</span>] = <span class="number">0</span> ;</span><br><span class="line">    map_sd[<span class="string">'W'</span>] = <span class="number">1</span> ;</span><br><span class="line">    map_sd[<span class="string">'S'</span>] = <span class="number">2</span> ;</span><br><span class="line">    map_sd[<span class="string">'E'</span>] = <span class="number">3</span> ;</span><br><span class="line">    back_sd[<span class="number">0</span>] = <span class="string">"N"</span>;</span><br><span class="line">    back_sd[<span class="number">1</span>] = <span class="string">"W"</span>;</span><br><span class="line">    back_sd[<span class="number">2</span>] = <span class="string">"S"</span>;</span><br><span class="line">    back_sd[<span class="number">3</span>] = <span class="string">"E"</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; sx &gt;&gt; sy &gt;&gt; str_d )&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; ins ;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; ins &lt;&lt; '\n' ;</span></span><br><span class="line">        d = map_sd[str_d[<span class="number">0</span>]] ;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; ins.length() ; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ins[i] == <span class="string">'F'</span>)&#123;</span><br><span class="line">                tx = sx ;</span><br><span class="line">                ty = sy ;</span><br><span class="line">                sx += direct[d][<span class="number">0</span>] ;</span><br><span class="line">                sy += direct[d][<span class="number">1</span>] ;</span><br><span class="line">                pair&lt;int,int&gt; pa(tx,ty) ;</span><br><span class="line">                <span class="keyword">if</span>(in_grid(sx,sy,d) == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(mp_lost.count(pa))&#123; <span class="comment">//indicate past robot fell</span></span><br><span class="line">                        sx = tx ;</span><br><span class="line">                        sy = ty ;</span><br><span class="line">                        <span class="keyword">continue</span> ;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; tx &lt;&lt; <span class="string">' '</span> &lt;&lt; ty &lt;&lt; <span class="string">' '</span> &lt;&lt; back_sd[d] &lt;&lt; <span class="string">' '</span> &lt;&lt; <span class="string">"LOST"</span> &lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">                    mp_lost[pa] = <span class="number">1</span> ;</span><br><span class="line">                    flag = <span class="number">0</span> ;</span><br><span class="line">                    <span class="keyword">break</span> ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(ins[i] == <span class="string">'L'</span>) <span class="comment">//change direction</span></span><br><span class="line">                d = (d+<span class="number">4</span>+<span class="number">1</span>) % <span class="number">4</span> ;</span><br><span class="line">            <span class="keyword">if</span>(ins[i] == <span class="string">'R'</span>) <span class="comment">//change direction</span></span><br><span class="line">                d = (d+<span class="number">4</span><span class="number">-1</span>) % <span class="number">4</span> ;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; "i is : " &lt;&lt; sx &lt;&lt; ' ' &lt;&lt; sy &lt;&lt; ' ' &lt;&lt; back_sd[d] &lt;&lt; '\n' ;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; sx &lt;&lt; <span class="string">' '</span> &lt;&lt; sy &lt;&lt; <span class="string">' '</span> &lt;&lt; back_sd[d] &lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>Competitive Programming3</tag>
        <tag>實作題</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa280 - Vertex(DFS)</title>
    <url>/2020/12/24/UVa/UVa280/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>給你一張單向圖，寫一個程式，我們想詢問從 x 點進行搜尋會有哪些點是不會被搜尋到。</p>
<p>題目測資有點小麻煩，需要處理。</p>
</blockquote>
<a id="more"></a>

<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>標準的 DFS，基本上沒有難度的，需要注意的是要輸出的節點是未經過，所以要記錄下來。</p>
<p>需要特別注意的是一開始的點<strong>並不會被當作有經過</strong>，所以一開始的點不能被視為 visit。</p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>這應該是我覺得最簡單的題目之一，寫得好開心。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 200</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> visit[MAXN] , graph[MAXN][MAXN] ;</span><br><span class="line"><span class="keyword">int</span> n , len , sz , temp_n , temp_i ;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; record ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x )</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; i++ )&#123;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; i &lt;&lt; ' ' &lt;&lt; graph[x][i] &lt;&lt; '\n' ;</span></span><br><span class="line">        <span class="keyword">if</span>(graph[x][i] &amp;&amp; !visit[i])&#123;</span><br><span class="line">            visit[i] = <span class="number">1</span> ;</span><br><span class="line">            dfs(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> );</span><br><span class="line">    freopen(<span class="string">"out.txt"</span> , <span class="string">"w"</span> , <span class="built_in">stdout</span> );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n &amp;&amp; n )&#123;</span><br><span class="line">        <span class="built_in">memset</span>(graph,<span class="number">0</span>,<span class="keyword">sizeof</span>(graph));</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; temp_i &amp;&amp; temp_i )</span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; temp_n &amp;&amp; temp_n) graph[temp_i][temp_n] = <span class="number">1</span> ;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; len ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; len ; i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; temp_n ;</span><br><span class="line">            sz = <span class="number">0</span> ;</span><br><span class="line">            record.clear();</span><br><span class="line">            <span class="built_in">memset</span>(visit,<span class="number">0</span>,<span class="keyword">sizeof</span>(visit));</span><br><span class="line">            dfs(temp_n);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!visit[j])</span><br><span class="line">                    record.push_back(j);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; record.size() ;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> it : record )</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; it ;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>Competitive Programming3</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa318 - Domino Effect(Dijkstra)</title>
    <url>/2020/12/24/UVa/UVa318/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>Domino Effect 指一件事的發生會產生一連串的連鎖反應，但這不是我們的重點XD。</p>
<p>我們的重點就如題目，給你一張骨牌的圖，並告訴你<strong>關鍵點</strong>以及從此關鍵點到下一個關鍵點的<strong>秒數</strong>。然後我們想要推動其中一個關鍵點，來讓圖上所有的骨牌倒塌，想請問是在第幾秒的時候全部倒塌，在那一個<strong>關鍵點</strong>開始倒榻。</p>
<p>關鍵點: 可以影響到兩個骨牌以上的骨牌。<br>秒數的一個小提示，假如最後倒塌是從兩個關鍵點一起倒榻時則計算秒數方式如下 \(0.5(起點到關鍵點一 +  起點到關鍵點二 + 關鍵點一至關鍵點二)\)</p>
<p>這題的測試資料有個問題，最後一筆是只有一個 0，因此在判斷時，只要判斷 N 是否為 0 即可，如果全部都判斷反而會有錯誤(cin 的情況，因為我是用 cin )。</p>
</blockquote>
<a id="more"></a>

<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>這題有點小難，一開始的時候我不太懂這題需要使用到 Dijkstra，我想說應該是用洪水法去解出，但後來發現洪水法的話雖然一樣可以得出單緣最短路徑，但並不好寫，至少需要開兩張一樣大的圖，查網路上後知道這題用 Dijkstra 更好，要是沒有查的話可能會浪費時間寫，還要再重改八QQ。</p>
<p>用 adjecency matrix 會更好寫，如果用 Piority 來寫的話會發現其實沒有那麼好寫，思考邏輯會比較混亂，於是 Dijkstra 就用 adjecency matrix 寫。</p>
<p>我們先算出最長的最短路徑(找出最後一個骨牌落下的時間，並定義 max_path )，同時並記錄每一個關鍵點的最短路徑(跌落秒數)，再來我們透過 burte force 的方式將每一個連接邊去揣測，如果可以揣測出比 max_path 更大的跌落秒數就表示此骨牌應該是兩個關鍵點同時跌落而不是當最後一個點跌落結束全部都結束。</p>
<h2 id="參考來源"><a href="#參考來源" class="headerlink" title="參考來源"></a>參考來源</h2><p><a href="https://blog.csdn.net/mobius_strip/article/details/64440081" target="_blank" rel="noopener">UVa 318 - Domino Effect（zoj 1298</a><br><a href="http://celinechiu0809.blogspot.com/2015/05/uva318-domino-effect-dijkstra-single.html" target="_blank" rel="noopener">【UVa】318-Domino effect (Dijkstra, Single source shortest path)</a></p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 520</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> oo 1e20</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> kase=<span class="number">0</span> , N , M ;</span><br><span class="line"><span class="keyword">int</span> a , b , v , x , st , ed , flag , now   ;</span><br><span class="line"><span class="keyword">double</span> graph[MAXN][MAXN] ;</span><br><span class="line"><span class="keyword">int</span> used[MAXN] ;</span><br><span class="line"><span class="keyword">double</span> max_path , speed[MAXN] ; <span class="comment">//speed = start to each node shortest path </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line">    speed[<span class="number">1</span>] = <span class="number">0</span> ;</span><br><span class="line">    used[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    now = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= N ; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(graph[now][j] &amp;&amp; speed[j] &gt; graph[now][j] + speed[now] )&#123;</span><br><span class="line">                speed[j] = graph[now][j] + speed[now];</span><br><span class="line">                <span class="comment">//cout &lt;&lt; speed[j] &lt;&lt; '\n' ;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        max_path = oo ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= N ; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>( !used[j] &amp;&amp; max_path &gt; speed[j])&#123;</span><br><span class="line">                max_path = speed[j] ;</span><br><span class="line">                now = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; "i is " &lt;&lt; i &lt;&lt; ' ' &lt;&lt; now &lt;&lt; ' ' &lt;&lt; max_path &lt;&lt; '\n' ;</span></span><br><span class="line">        used[now] = <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> );</span><br><span class="line">    freopen(<span class="string">"out.txt"</span> , <span class="string">"w"</span> , <span class="built_in">stdout</span> );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M &amp;&amp; N )&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= N ; j++) graph[i][j] = <span class="number">0</span> ;</span><br><span class="line">            speed[i] = oo ;</span><br><span class="line">            used[i] = <span class="number">0</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= M ; i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; v ;</span><br><span class="line">            graph[a][b] = v ;</span><br><span class="line">            graph[b][a] = v ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        flag = <span class="number">0</span> ;</span><br><span class="line">        dijkstra() ;</span><br><span class="line">        max_path = speed[now];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span> ; j &lt;= N ; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(graph[i][j]  &amp;&amp;max_path &lt; <span class="number">0.5</span> * (speed[i] + speed[j] + graph[i][j]))&#123;</span><br><span class="line">                    max_path = <span class="number">0.5</span> * (speed[i] + speed[j] + graph[i][j]) ;</span><br><span class="line">                    st = i ;</span><br><span class="line">                    ed = j ;</span><br><span class="line">                    flag = <span class="number">1</span> ;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"System #"</span> &lt;&lt; ++kase &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="number">1</span> )&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"The last domino falls after "</span> &lt;&lt; fixed &lt;&lt; setprecision(<span class="number">1</span>) &lt;&lt; max_path</span><br><span class="line">             &lt;&lt; <span class="string">" seconds, between key dominoes "</span> &lt;&lt; st &lt;&lt;<span class="string">" and "</span> &lt;&lt; ed &lt;&lt; <span class="string">"."</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"The last domino falls after "</span> &lt;&lt; fixed &lt;&lt; setprecision(<span class="number">1</span>) &lt;&lt; max_path &lt;&lt; <span class="string">" seconds, at key domino "</span> &lt;&lt; now &lt;&lt; <span class="string">"."</span> ;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"\n\n"</span> ;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>Dijkstra&#39;s</tag>
        <tag>程式解題</tag>
        <tag>Competitive Programming3</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa614 - Mapping the Route(DFS)</title>
    <url>/2020/12/24/UVa/UVa614/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>給予一張地圖，再給你起點與終點，我們想要你輸出透過<strong>題目規定的 DFS</strong>，畫出一張圖。<br>測試資料則會給予每一個節點來給定南邊或東邊的牆是否存在。</p>
<p>題目規定的 DFS:必須依序 西、北、東、南的方式遍地</p>
<p>輸出規定 </p>
<ul>
<li>如果是有經歷過的節點但卻不是從起點至終點的路徑時，輸出 “???”</li>
<li>沒有經歷過的節點，也不是起點到終點的路徑，輸出 “   “</li>
<li>如果是起點至終點的路徑就輸出從起點開始的第幾個節點</li>
<li>左邊的牆輸出 ‘|’，右邊的牆輸出 “—“</li>
</ul>
</blockquote>
<a id="more"></a>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>輸出好難，他是在考你輸出八 = =。</p>
<p>由於這題是使用<strong>邊</strong>來判定有沒有連結，而不是透過<strong>點至點</strong>，而讓整個程式難寫許多，透過兩個陣列 graph 地圖狀態、record 從起點到終點的路徑。</p>
<p>幾個地方需要注意：如下</p>
<ul>
<li>我們透過回推的方式判斷，假如 x,y 西邊有牆，也就代表 x,y-1 的東邊有牆，透過此方次來回推西邊或北邊是否有牆即可，以及要注意邊界問題。</li>
<li>我們都先假設我們的搜尋(record 陣列紀錄)是對的，所以當前的 record x,y = 上一個 record x,y+1，如果不對再改為 -1 </li>
<li>要判斷邊界</li>
<li>輸出也要注意，他是3位為一道牆，因此如果數值位數沒有大於 3，就需要在左邊補上空白，如果是用 cout 就需要補上 <code>set(3) &lt;&lt; right</code>。</li>
<li>再來需要透過 flag 來判斷是否有成功抵達終點，如果沒有成功抵達終點則起點也會是 “???”，因為他不是從起點到終點的路徑。<br>function <code>row_wall()</code></li>
<li>定義一個陣列 south_wall 來判斷 x,y 的南邊是否有牆，才可以在輸出時正確輸出。</li>
<li>走過，但並不是路徑的則將 <code>record[x][y] = -1</code>，在輸出時才可以正確知道此處為 “???”<br>dfs 處每一個遞迴的下一行處，但需要先判斷 flag，來得知這路徑是否為起點到終點的路徑，不是才符合此條件</li>
</ul>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>這題的輸出才是最難的問題吧…，UVA 是不是認為這種類型的題目都不難因此都特地出一些很難的輸出格式來考大家的反應能力壓QQ，而且我最近在挑戰寫程式的過程中不用紙筆，發現很難、而且下次看到程式碼的時候還需要很多時間去重新理解、思考。我原先以為如果不用紙筆輔助思考會讓腦袋的印相加深，但似乎是不對的QQ。</p>
<p>然後英文還是需要加強，英文還是有點太爛了….。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 15</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> graph[MAXN][MAXN] ;</span><br><span class="line"><span class="keyword">int</span> record[MAXN][MAXN] ;</span><br><span class="line"><span class="keyword">int</span> direct[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">int</span> south_wall[MAXN] ;</span><br><span class="line"><span class="keyword">int</span> sx , sy , N , M , ex , ey ;</span><br><span class="line"><span class="keyword">int</span> a , kase = <span class="number">0</span> , flag = <span class="number">0</span> ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isboard</span><span class="params">(<span class="keyword">int</span> x , <span class="keyword">int</span> y , <span class="keyword">int</span> i )</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(x + direct[i][<span class="number">0</span>] &gt; N || x + direct[i][<span class="number">0</span>] &lt; <span class="number">1</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">if</span>(y + direct[i][<span class="number">1</span>] &gt; M || y + direct[i][<span class="number">1</span>] &lt; <span class="number">1</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; x + direct[i][0] &lt;&lt; ' ' &lt;&lt; y + direct[i][1] &lt;&lt; ' ' &lt;&lt; N &lt;&lt; ' ' &lt;&lt; M  &lt;&lt; '\n' ;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x , <span class="keyword">int</span> y )</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ox , oy   ;</span><br><span class="line">    ox = x ;</span><br><span class="line">    oy = y ;</span><br><span class="line">    <span class="keyword">if</span> (x == ex &amp;&amp; y == ey) &#123;</span><br><span class="line">        flag = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(isboard(x,y,<span class="number">0</span>) )&#123; <span class="comment">//west</span></span><br><span class="line">        x = ox + direct[<span class="number">0</span>][<span class="number">0</span>] ;</span><br><span class="line">        y = oy + direct[<span class="number">0</span>][<span class="number">1</span>] ;</span><br><span class="line">        <span class="keyword">if</span>(record[x][y] == <span class="number">0</span> &amp;&amp; (graph[x][y] == <span class="number">2</span> || graph[x][y] == <span class="number">0</span>))&#123;</span><br><span class="line">            record[x][y] = record[ox][oy] + <span class="number">1</span> ;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; y &lt;&lt; " west" &lt;&lt; '\n' ;</span></span><br><span class="line">            dfs(x,y);</span><br><span class="line">            <span class="keyword">if</span>(flag) <span class="keyword">return</span> ;</span><br><span class="line">            record[x][y] = <span class="number">-1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(isboard(x,y,<span class="number">1</span>))&#123; <span class="comment">//north</span></span><br><span class="line">        x = ox + direct[<span class="number">1</span>][<span class="number">0</span>] ;</span><br><span class="line">        y = oy + direct[<span class="number">1</span>][<span class="number">1</span>] ;</span><br><span class="line">        <span class="keyword">if</span>(record[x][y] == <span class="number">0</span> &amp;&amp; (graph[x][y] == <span class="number">1</span> || graph[x][y] == <span class="number">0</span>))&#123;</span><br><span class="line">            record[x][y] = record[ox][oy] + <span class="number">1</span> ;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; y &lt;&lt; " north" &lt;&lt; '\n' ;</span></span><br><span class="line">            dfs(x,y);</span><br><span class="line">            <span class="keyword">if</span>(flag) <span class="keyword">return</span> ;</span><br><span class="line">            record[x][y] = <span class="number">-1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(isboard(ox,oy,<span class="number">2</span>) )&#123;<span class="comment">//east</span></span><br><span class="line">        x = ox + direct[<span class="number">2</span>][<span class="number">0</span>] ;</span><br><span class="line">        y = oy + direct[<span class="number">2</span>][<span class="number">1</span>] ;</span><br><span class="line">        <span class="keyword">if</span>(record[x][y] == <span class="number">0</span> &amp;&amp; (graph[ox][oy] == <span class="number">2</span> || graph[ox][oy] == <span class="number">0</span>))&#123;</span><br><span class="line">            record[x][y] = record[ox][oy] + <span class="number">1</span> ;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; y &lt;&lt; " east" &lt;&lt; '\n' ;</span></span><br><span class="line">            dfs(x,y);</span><br><span class="line">            <span class="keyword">if</span>(flag) <span class="keyword">return</span> ;</span><br><span class="line">            record[x][y] = <span class="number">-1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(isboard(ox,oy,<span class="number">3</span>))&#123;<span class="comment">//south</span></span><br><span class="line">        x = ox + direct[<span class="number">3</span>][<span class="number">0</span>] ;</span><br><span class="line">        y = oy + direct[<span class="number">3</span>][<span class="number">1</span>] ;</span><br><span class="line">        <span class="keyword">if</span>(record[x][y] == <span class="number">0</span> &amp;&amp; (graph[ox][oy] == <span class="number">1</span> || graph[ox][oy] == <span class="number">0</span> ))&#123;</span><br><span class="line">            record[x][y] = record[ox][oy] + <span class="number">1</span> ;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; y &lt;&lt; " south" &lt;&lt; '\n' ;</span></span><br><span class="line">            dfs(x,y);</span><br><span class="line">            <span class="keyword">if</span>(flag) <span class="keyword">return</span> ;</span><br><span class="line">            record[x][y] = <span class="number">-1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">row_wall</span><span class="params">( )</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= M ; i++)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"+"</span> ;</span><br><span class="line">        <span class="keyword">if</span>(south_wall[i])&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"---"</span> ;</span><br><span class="line">            south_wall[i] = <span class="number">0</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"   "</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"+\n"</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Maze "</span> &lt;&lt; ++kase &lt;&lt; <span class="string">"\n\n"</span> ;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; flag &lt;&lt; '\n' ;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= M ; i++) south_wall[i] = <span class="number">1</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(flag == <span class="number">0</span> ) record[sx][sy] = <span class="number">-1</span> ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; i++)&#123;</span><br><span class="line">        row_wall();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">'|'</span> ;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; M &lt;&lt; '\n' ;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= M ; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(record[i][j] == <span class="number">-1</span>)</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"???"</span> ;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(record[i][j] &gt; <span class="number">0</span>)</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; setw(<span class="number">3</span>) &lt;&lt; right &lt;&lt; record[i][j] ;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"   "</span> ;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(j == M || graph[i][j] == <span class="number">1</span> || graph[i][j] == <span class="number">3</span>)</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"|"</span> ;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> ;</span><br><span class="line">            <span class="keyword">if</span>(graph[i][j] == <span class="number">2</span> || graph[i][j] == <span class="number">3</span>)</span><br><span class="line">                south_wall[j] = <span class="number">1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= M ; i++) south_wall[i] = <span class="number">1</span> ;</span><br><span class="line">    row_wall();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\n\n"</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> );</span><br><span class="line">    freopen(<span class="string">"out.txt"</span> , <span class="string">"w"</span> , <span class="built_in">stdout</span> );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M &gt;&gt; sx &gt;&gt; sy &gt;&gt; ex &gt;&gt; ey &amp;&amp; N)&#123;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; N &lt;&lt; ' ' &lt;&lt; M &lt;&lt; ' ' &lt;&lt; sx &lt;&lt; ' ' &lt;&lt; sy &lt;&lt; '\n' ;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= M ; j++)&#123;</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; a ;</span><br><span class="line">                graph[i][j] = a ;</span><br><span class="line">                record[i][j] = <span class="number">0</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        flag = <span class="number">0</span> ;</span><br><span class="line">        record[sx][sy] = <span class="number">1</span> ;</span><br><span class="line">        dfs(sx,sy);</span><br><span class="line">        output();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>Competitive Programming3</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa824 - Coast Tracker(實作)</title>
    <url>/2020/12/24/UVa/UVa824/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>我們寫 GPS 的一小部分功能，給予一張圖，地圖上只有陸地與海，我們只能走陸地且要沿著海岸線走，我們透過逆時鐘方向進行搜尋，找出下一個節點是我們可以走的方向，輸出下一個節點可以走的方向位置</p>
<p>方向位置圖如下:<br><img src="https://i.imgur.com/i6ufysm.png" alt=""></p>
<p>需要注意的是，我們是根據上一個節點的方向開始逆時鐘，而不是每次都是從上一張圖的 1 開始。<br>　座標則是像我們畫方程式的座標相同，也就是北(x,y+1)，左上(-1,1)…以此類推，<strong>與平常不同</strong>。</p>
</blockquote>
<a id="more"></a>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>這題的邏輯跟我腦袋想的不太一樣啊…，讓我腦袋打結了QQ，我好笨。</p>
<p>這題有個地方比較酷，他是給你當前的方向，但你不可以直接使用當前方向直接進行逆時鐘搜尋，看下面的圖</p>
<blockquote>
<p><img src="https://i.imgur.com/wDlQiOi.png" alt=""></p>
</blockquote>
<p>你會發現，他的搜尋方向是 1，是因為他的上一個位置是 6，再來透過逆時鐘搜尋 7,0 都是海洋所以不可以往那方向走，但是 1 就是陸地所以可以往那方向走，所以搜尋位置就要從反向的位置 +1，來進行搜尋。</p>
<p>也就是上上面那張圖誤導了大家wwww，或是英文變不好QQ。</p>
<p>這裡我有用一個比較特別的寫法是我將陸地變成 1，海洋變成 2，這樣再透過 map 實作時會更加方便些，然後要記住上一個位置一定會是陸地，但這題是可以往回走的(不過是最後一個選擇)，需要特別注意。</p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>這題好吃 2D 邏輯與方向感，在我不願意透過紙筆來輔助時則發現我常常將一樣的邏輯重複思考，有點笨欸www，需要將英文再複習，我也透過了這題目將 2D 的邏輯與方向感變好，感覺好棒，學了好多東西呢，也要在將邏輯弄得夠清晰。<br>ε٩(๑&gt; ₃ &lt;)۶з。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pos 8</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> direct[pos][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">1</span>&#125;&#125; ;</span><br><span class="line"><span class="keyword">int</span> counter_direct[] = &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125; ;</span><br><span class="line"><span class="built_in">map</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;,<span class="keyword">int</span>&gt; record;</span><br><span class="line"><span class="keyword">int</span> x , y , d , a , b , c ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> );</span><br><span class="line">    <span class="comment">//freopen("out.txt" , "w" , stdout );</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y &gt;&gt; d &amp;&amp; x != <span class="number">-1</span>)&#123;</span><br><span class="line">        record.clear();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; pos ; i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c ;</span><br><span class="line">            record[make_pair(a,b)] = c ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ox , oy , r ;</span><br><span class="line">        ox = x ; oy = y ;</span><br><span class="line">        r = counter_direct[d];</span><br><span class="line">        <span class="comment">//record[make_pair(x+direct[r][0],y+direct[r][1])] = 0;</span></span><br><span class="line">        <span class="comment">//cout &lt;&lt; "r is " &lt;&lt; x+direct[r][0] &lt;&lt; ' ' &lt;&lt; y+direct[r][1] &lt;&lt; '\n' ;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= pos ; i++)&#123;</span><br><span class="line">            d = (r+i) % <span class="number">8</span> ;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; "r is " &lt;&lt; r &lt;&lt; '\n' ;</span></span><br><span class="line">            x = ox + direct[d][<span class="number">0</span>] ;</span><br><span class="line">            y = oy + direct[d][<span class="number">1</span>] ;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; y &lt;&lt; '\n' ;</span></span><br><span class="line">            <span class="keyword">if</span>(record[make_pair(x,y)] == <span class="number">1</span> )&#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; d &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">                <span class="keyword">break</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>Competitive Programming3</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa168 - Theseus and the Minotaur (DFS)</title>
    <url>/2020/12/24/UVa/Uva168/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>英雄要捕捉牛頭怪，牛頭怪怕光也怕英雄，給你一張圖(有節點與邊)，英雄可以在 K 步後的節點蠟燭，這樣牛頭人就不會在往那通道走，總有一天英雄會抓到牛頭人，我們想請問牛頭人最後走到哪裡就無路可走。</p>
<p>牛頭人走路有順序性，一定會先走<strong>字典序</strong>最小的值，但不會回頭走。<br>英雄一開始一定在牛頭人旁邊的節點，也就是英雄與牛頭人的距離只有 1 (只有一個邊)。</p>
<p>題目輸入極其難受，請仔細思考<br>P.S. 注意 K 沒有限制，想要多大都可以，但基本上可以不需要在意這個問題。</p>
</blockquote>
<a id="more"></a>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>這裡主要有兩點需要特別注意，由於 K 數字沒有極限，但是這題目的 K 基本上暴力是可以通過，不需要做 mod，但如果要 mod 就會變成 NP 問題，雖然 mod 出來的數字與 K 相同，但是<strong>英雄的位置則不一定相同</strong>，回推就會不同，輸出的路徑也就不一定相同。</p>
<p>基本上就是紀錄遇到 K 時就紀錄這個節點，直到沒辦法再繼續 DFS 時最後的那個節點就是牛頭人無處可逃的地方，但是需要記得一件事情因為 K 沒有限制，但遞迴最多只能向下深層 9998，再往下就會 stack overflow(不是你想的那個論壇，就實際上的名字)，因此要將遞迴 DFS 改成迴圈 DFS，也就是把繼續遞迴的地方改成 break 模擬遞迴。 </p>
<h3 id="輸入格式"><a href="#輸入格式" class="headerlink" title="輸入格式"></a>輸入格式</h3><p>由於題目的輸入格式與眾不同，是 A 節點配上 ‘:’(冒號) 在加上後面全部的所有字元，假設 <code>A:BCD</code>，那就是 A 連接 B ,A 連接 C,A 連接 D。</p>
<p>我的想法是先將前面那行輸入成 String，接下來則用 flag 當作標誌</p>
<ul>
<li>flag = 0<br>表示讀到 ‘:’(冒號)，因此我們找 ‘:’(冒號) 的前一字元即可，同時將 flag = 1，由於題目有說明一個節點只會有英文字母才能這樣做</li>
<li>flag = 1<br>為 ‘:’(冒號) 後面的所有的值，因此將 <code>vector[A].push_back(b)</code>，b 為 : 後的所有值</li>
<li>讀到  ‘.’(句號) 或 ‘;’(分號)<br>讀到 ‘.’(句號) 或 ‘;’(分號)  這裡時，就換成下一個 A 節點，因此 flag 設 0 換設定下一個節點與其他節點的連結</li>
</ul>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 300</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN_Alpha 27</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">string</span> strQ  ;</span><br><span class="line"><span class="keyword">char</span> strM , strT ;</span><br><span class="line"><span class="keyword">int</span> M , T , K , ans , cnt ; <span class="comment">//cnt is all of use letter</span></span><br><span class="line"><span class="keyword">int</span> flag , nx , ny; <span class="comment">//nx nodex ny nodey</span></span><br><span class="line"><span class="keyword">int</span> visit[MAXN];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; record ;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path[MAXN_Alpha] ;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> m , <span class="keyword">int</span> t , <span class="keyword">int</span> k )</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        flag = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span> )&#123; </span><br><span class="line">            visit[t] = <span class="number">1</span> ;</span><br><span class="line">            record.push_back(t) ;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; "candle is " &lt;&lt; (char)(t+'A') &lt;&lt; '\n' ;</span></span><br><span class="line">            k = K ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; "m is " &lt;&lt; (char)(m+'A') &lt;&lt; '\n' ;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it : path[m])&#123; <span class="comment">//DFS</span></span><br><span class="line">            <span class="keyword">if</span>((visit[it] == <span class="number">0</span> &amp;&amp; it != t) )&#123; <span class="comment">// recursive -&gt; break</span></span><br><span class="line">                <span class="comment">//cout &lt;&lt; i &lt;&lt; '\n' ;</span></span><br><span class="line">                flag = <span class="number">0</span> ;</span><br><span class="line">                t = m ;</span><br><span class="line">                m = it ;</span><br><span class="line">                k-- ;</span><br><span class="line">                <span class="keyword">break</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> );</span><br><span class="line">    freopen(<span class="string">"out.txt"</span> , <span class="string">"w"</span> , <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; strQ &amp;&amp; strQ != <span class="string">"#"</span>)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; strM &gt;&gt; strT &gt;&gt; K ;</span><br><span class="line">        T = strT - <span class="string">'A'</span> ;</span><br><span class="line">        M = strM - <span class="string">'A'</span> ;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; T &lt;&lt; ' ' &lt;&lt; M &lt;&lt; ' ' &lt;&lt; K &lt;&lt; '\n' ;</span></span><br><span class="line">        flag = <span class="number">0</span>;</span><br><span class="line">        cnt = <span class="number">0</span> ;</span><br><span class="line">        <span class="built_in">memset</span>(visit,<span class="number">0</span>,<span class="keyword">sizeof</span>(visit));</span><br><span class="line">        record.clear();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; MAXN_Alpha ; i++)</span><br><span class="line">            path[i].clear();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; strQ.length() ; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(flag == <span class="number">0</span> &amp;&amp; strQ[i] == <span class="string">':'</span>)&#123;</span><br><span class="line">                cnt ++;</span><br><span class="line">                nx = strQ[i<span class="number">-1</span>] - <span class="string">'A'</span> ;</span><br><span class="line">                flag = <span class="number">1</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(strQ[i] == <span class="string">'.'</span> || strQ[i] == <span class="string">';'</span>)&#123;</span><br><span class="line">                flag = <span class="number">0</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(flag == <span class="number">1</span> )&#123;</span><br><span class="line">                ny = strQ[i] - <span class="string">'A'</span> ;</span><br><span class="line">                path[nx].push_back(ny);</span><br><span class="line">                <span class="comment">//cout &lt;&lt; "edge is " &lt;&lt; nx &lt;&lt; ' ' &lt;&lt; ny &lt;&lt; '\n' ;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//K %= cnt ;</span></span><br><span class="line">        <span class="comment">//if(K == 0 ) K = cnt ;</span></span><br><span class="line">        ans = dfs(M,T,K);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it : record )</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; (<span class="keyword">char</span>)( <span class="string">'A'</span> + it) &lt;&lt; <span class="string">' '</span> ;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">'/'</span> &lt;&lt; (<span class="keyword">char</span>)( <span class="string">'A'</span> + ans) &lt;&lt; <span class="string">'\n'</span>  ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>Competitive Programming3</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa10055 - Hashmat the Brave Warrior (水題)</title>
    <url>/2020/12/27/UVa/UVa10055/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>勇敢的戰士要作戰，他們知道對方的士兵數量以及我方的士兵數量，他們想要知道對方與我方的差額是多少。</p>
<p>輸出不會大於 \(2^{32}\) </p>
</blockquote>
<a id="more"></a>

<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>水到不行，英文又簡單。真的香。</p>
<p>就兩個數字減法即可。</p>
<h2 id="重點觀念："><a href="#重點觀念：" class="headerlink" title="重點觀念："></a>重點觀念：</h2><ul>
<li>題目只有說輸出不會大於 \(2^{32}\) ，沒有說資料不會超過，所以記得要開 long long<br>有個小偷懶步驟，可以把 long long define 成 int，接著再將 main 前面的 int 換成 int32_t，就可以無痛轉移 long long XD。</li>
</ul>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>題目真水，英文又簡單。應該多出這點題目XD，這樣那些聰明人看起來就跟我一樣笨www。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> N , M ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> );</span><br><span class="line">    freopen(<span class="string">"out.txt"</span> , <span class="string">"w"</span> , <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">abs</span>(N-M) &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>水題</tag>
        <tag>UVa</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa10077 - The Stern-Brocot Number System (二分搜尋)</title>
    <url>/2020/12/27/UVa/UVa10077/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>The Stern-Brocot tree 能夠完美的建構出沒有任何一個負分數，且 n 與 m 絕對互質，也就表示產生的值絕對不會有重複。</p>
<p>現在給你 The Stern-Brocot tree 其中一個值，我們想詢問透過 The Stern-Brocot tree 的方式，那它的位置在哪裡？透過 R and F 描述</p>
<p>舉例： 找出 \(\frac{3}{1}\)，那就是 RR 。</p>
</blockquote>
<a id="more"></a>

<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>這題考的是腦筋急轉彎，問你會不會運用自身所學的知識。</p>
<p>其實這題就是二分搜尋，只是他將規則稍微改變。<br>但如果你可以從中得出結論你可以發現，數字的左邊值一定比中間的數字小，反之，右邊則會比中間數字大。</p>
<p>只要透過此規則進入左邊輸入 L、右邊輸入 R 就是答案了。</p>
<p>圖示：</p>
<blockquote>
<p><img src="https://i.imgur.com/AaPrjHo.png" alt=""></p>
</blockquote>
<h2 id="重點觀念："><a href="#重點觀念：" class="headerlink" title="重點觀念："></a>重點觀念：</h2><ul>
<li>在判斷的時候因為有分子與分母要判斷，必須兩個都同時等於才跳出迴圈，因此 <code>(b1 != d1 &amp;&amp; b1 != d2)</code> 這邏輯是錯誤的，錯誤舉例：b1 = 1 , b2 = 2 , d1 = 1 , d2 = 3。因此要改變下，變成 <code>!(b1 == d1 &amp;&amp; b2 == d2)</code> 即可。</li>
<li>int 在相除時出來的數字還是 int，因此需要將兩個數字都先轉成 float 再進行除法才會得出小數。<br>舉例：<code>double r = (float)b1 / (float)b2</code></li>
<li>不要強轉型態，會很花時間，向第二個重點的寫法，就會導致超時，因此要將這兩個額外拉出宣告兩個小數點變數。</li>
</ul>
<h2 id="變數命名"><a href="#變數命名" class="headerlink" title="變數命名"></a>變數命名</h2><ul>
<li>int <ul>
<li>a1 , a2<br>左邊的值</li>
<li>b1 , b2<br>中間的值</li>
<li>c1 , c2<br>右邊的值</li>
<li>d1 , d2<br>題目需要找到的值</li>
</ul>
</li>
<li>double<ul>
<li>compute_b , compute_d<br>計算大小用</li>
<li>d_b1 , d_b2 , d_d1 , d_d2<br>計算 b and d  的值，強轉型態會浪費時間因此拉出 double 宣告</li>
</ul>
</li>
</ul>
<h2 id="參考來源"><a href="#參考來源" class="headerlink" title="參考來源"></a>參考來源</h2><p><a href="http://programming-study-notes.blogspot.com/2014/01/uva-10077-stern-brocot-number-system.html" target="_blank" rel="noopener">Programming學習筆記 - UVa 10077 The Stern-Brocot Number System</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>這題目真的好棒啊，我被她考到我卻一點怨言都沒有，出這題目的人是天才八，把我玩弄得心服口服，可惡，我學起來了，下次不會再犯了。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a1=<span class="number">0</span> , a2=<span class="number">1</span> , b1=<span class="number">1</span> , b2=<span class="number">1</span> , c1=<span class="number">1</span> , c2=<span class="number">0</span> ;</span><br><span class="line"><span class="keyword">int</span> d1 , d2 , t1 , t2 ;</span><br><span class="line"><span class="keyword">double</span> compute_b , compute_d , d_b1 , d_b2 , d_d1 , d_d2 ;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bs</span><span class="params">()</span></span>&#123; <span class="comment">//binary search</span></span><br><span class="line">    a1 = <span class="number">0</span> ; a2 = <span class="number">1</span> ;</span><br><span class="line">    b1 = <span class="number">1</span> ; b2 = <span class="number">1</span> ;</span><br><span class="line">    c1 = <span class="number">1</span> ; c2 = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">while</span>(!(b1 == d1 &amp;&amp; b2 == d2))&#123;</span><br><span class="line">        d_b1 = b1 ; d_b2 = b2 ;</span><br><span class="line">        d_d1 = d1 ; d_d2 = d2 ;</span><br><span class="line">        compute_b = d_b1 / d_b2 ;</span><br><span class="line">        compute_d = d_d1 / d_d2 ;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; compute_b &lt;&lt; ' ' &lt;&lt; compute_d &lt;&lt; '\n' ;</span></span><br><span class="line">        <span class="keyword">if</span>(compute_d &gt; compute_b )&#123; <span class="comment">//great than</span></span><br><span class="line">            a1 = b1 ; a2 = b2 ;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"R"</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123; <span class="comment">//less than</span></span><br><span class="line">            c1 = b1 ; c2 = b2 ;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"L"</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        b1 = a1 + c1 ;</span><br><span class="line">        b2 = a2 + c2 ;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; "a is " &lt;&lt; a1 &lt;&lt; '/' &lt;&lt; a2 &lt;&lt; '\n' ;</span></span><br><span class="line">        <span class="comment">//cout &lt;&lt; "b is " &lt;&lt; b1 &lt;&lt; '/' &lt;&lt; b2 &lt;&lt; '\n' ;</span></span><br><span class="line">        <span class="comment">//cout &lt;&lt; "c is " &lt;&lt; c1 &lt;&lt; '/' &lt;&lt; c2 &lt;&lt; '\n' ;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> );</span><br><span class="line">    freopen(<span class="string">"out.txt"</span> , <span class="string">"w"</span> , <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; d1 &gt;&gt; d2 &amp;&amp; d1 + d2 != <span class="number">2</span> )&#123;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; d1 &lt;&lt; ' ' &lt;&lt; d2 &lt;&lt; '\n' ;</span></span><br><span class="line">        bs();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>Binary Search 二分搜尋</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa10071 - Back to High School Physics (水題)</title>
    <url>/2020/12/28/UVa/UVa10071/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>有一個飛天粒子有初始速度與加速度，我們給你 t 秒的速度，想請問 2t 秒後的位置是多少</p>
<p>P.S. 謝謝立委翻譯</p>
</blockquote>
<a id="more"></a>

<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>水到不行，靠公式即可www。</p>
<p>公式：\(距離 = 速度 * 時間 * 倍率\)，這裡的倍率是 2。</p>
<h2 id="參考來源"><a href="#參考來源" class="headerlink" title="參考來源"></a>參考來源</h2><ul>
<li>立委翻譯支援</li>
</ul>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>這題 cetain time(一定時間)，讓我納悶了很久，幸好有立委幫我翻譯我就解出來，這題不難，相信大家都會的！</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> u , v  ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> );</span><br><span class="line">    freopen(<span class="string">"out.txt"</span> , <span class="string">"w"</span> , <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; u * v * <span class="number">2</span> &lt;&lt; <span class="string">'\n'</span>  ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>水題</tag>
        <tag>UVa</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa10281 - Back to High School Physics (實作題)</title>
    <url>/2020/12/28/UVa/UVa10281/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>有台汽車的里程數壞掉了，於是我們手動拿上碼表 + 定速開車，想詢問每次我們標記的時間時已經行駛了多少公里。</p>
</blockquote>
<a id="more"></a>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>毒，到處都是毒。這題是大毒阿，快逃RRRR</p>
<p>很簡單的操作題，先將所有的時間換成秒數，之後再乘以速度，但這裡的速度是 km/hr，因此要在除以 3600 就是答案。</p>
<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li>這題如果要使用 cin，會非常難寫，建議使用 scanf<br>因為你沒辦法知道他到底這次有沒有要加速或是詢問你當前的距離</li>
<li>如果習慣 <code>#define int long long</code> 記住使用 scanf 要搭配 <code>%lld</code></li>
<li>windows 情況下，double 有機率無法被 scanf 用到，毒，這是毒阿。<br><a href="https://stackoverflow.com/questions/30950834/scanf-gcc-for-long-double" target="_blank" rel="noopener">scanf GCC for long double [duplicate]</a></li>
<li>有可能他連續加速兩次，因此計算里程數時不可以等到要查詢碼表時間是在算，必須每次都要算，<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;舉例</span><br><span class="line">00:00:01 12</span><br><span class="line">00:00:03 24</span><br></pre></td></tr></table></figure></li>
<li>任何一個計算公式都不可以有 int 與 float 運算出現，不然會高機率出錯。因此建議不用</li>
</ul>
<h2 id="參考來源"><a href="#參考來源" class="headerlink" title="參考來源"></a>參考來源</h2><p>齊笎編寫的 hackmd 詳解 </p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>這題滿滿的都是坑阿…，我最不擅長寫關於小數點的題目了，希望以後遇到小數點的題目都可以安然度過。這次的 scanf 不能輸入 double 我花了 2 小時去想真的是太難過了…，不過齊笎介紹使用的 sscanf 到蠻好用的，值的紀錄。</p>
<p>可以用 sscanf 加一個 string 格式化輸入資料，還可以知道有多少筆資料被成功輸入，真的好用、真的香，讚啦</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>  h , m , s , data  ;</span><br><span class="line"><span class="keyword">float</span> new_speed , speed=<span class="number">0</span>  , mile=<span class="number">0</span> ,s1=<span class="number">0</span> ,s2=<span class="number">0</span> ; <span class="comment">//s1 begin time , s2 end time</span></span><br><span class="line"><span class="keyword">char</span> strQ[<span class="number">128</span>] ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> );</span><br><span class="line">    freopen(<span class="string">"out.txt"</span> , <span class="string">"w"</span> , <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">while</span>(gets(strQ))&#123;</span><br><span class="line">        <span class="comment">//printf("%s\n" , strQ);</span></span><br><span class="line">        data = <span class="built_in">sscanf</span>(strQ , <span class="string">"%lld:%lld:%lld %f"</span> , &amp;h , &amp;m , &amp;s , &amp;new_speed);</span><br><span class="line">        <span class="comment">//printf("%lld:%lld:%lld %f\n",h , m , s , new_speed);</span></span><br><span class="line">        s2 = s1 ;</span><br><span class="line">        s1 = h * <span class="number">3600</span> + m * <span class="number">60</span> + s ;</span><br><span class="line">        mile += <span class="built_in">abs</span>(s1-s2) * speed / <span class="number">3600</span> ;</span><br><span class="line">        <span class="keyword">if</span>(data == <span class="number">4</span>)&#123;</span><br><span class="line">            speed =new_speed ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(data == <span class="number">3</span>)&#123;</span><br><span class="line">            <span class="comment">//printf("speed is %f\n" , speed);</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%.2lld:%.2lld:%.2lld %.2f km\n"</span> , h , m ,s ,mile);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>實作題</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa10469 - To Carry or not to Carry (水題)</title>
    <url>/2020/12/28/UVa/UVa10469/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>有一個人的加法器寫爛了，他的加法器不會進位，你可以模擬她這個笨蛋寫法嗎？</p>
</blockquote>
<a id="more"></a>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>很水，很簡單。</p>
<p>但這題其實可以再簡單一點，透過 xor 的特性，只有 0,1 or 1,0 才會輸出 1，0,0 or 1,1 都會輸出 0，所以只要用 xor 就好了，簡單吧！</p>
<p>如果不願意用 xor 也可以暴力解拉XD</p>
<h2 id="參考來源"><a href="#參考來源" class="headerlink" title="參考來源"></a>參考來源</h2><ul>
<li>齊笎詳解</li>
</ul>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>這題真的輕鬆，好開心。但不能每個題目都這樣啦，這樣會變笨www。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b ;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; (a^b) &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>水題</tag>
        <tag>UVa</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa10773 - Back to Intermediate Math (數論 Math theorm)</title>
    <url>/2020/12/28/UVa/UVa10773/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>給你河流寬度 d、河流速度 v、船速 u，想詢問一個小學生都可以回答的問題，船要渡河，我們想請問兩種方式相差的秒數為多少？</p>
<p>如果算不出來或這兩條路徑相同請輸出 can’t determine</p>
<ul>
<li>最短路徑<br>也就是直線經過</li>
<li>最快速度<br>順著河流速度經過</li>
</ul>
</blockquote>
<a id="more"></a>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>這題不是難題，但也不太像是水題，因為他需要用到三角函數與反三角函數。<del>我都沒學好於是去 wiki 查詢了一陣子QQQ</del>。</p>
<p>算出最短路徑所花費的秒數再算出最快速度所花費的秒數之後相減即可。</p>
<p>值得注意的是算最短路徑比較麻煩，且有一些例外案例。</p>
<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li>兩個路徑的長度必須是 double </li>
<li>秒數沒有正負，因此要加絕對值</li>
<li>判斷是否輸出 can’t determine<ul>
<li>船速等於 0，則永遠不會到終點</li>
<li>河流流速等於 0，則兩條路徑相同，題目 output 有說明一定要這兩條路徑不同才可以輸出答案</li>
<li>如果河流速度大於船的速度，則最短路徑則沒辦法抵達終點</li>
</ul>
</li>
<li>不可以判斷 d = 0 則不可以輸出 can’t determine<br>題目的坑…，他有可能 d 是 0，那這兩條路徑則視為不相同，但我覺得理應相同，不過是題目 bug 就算了www。</li>
<li>最短路徑與最快速度，先給出圖<blockquote>
<p><img src="https://i.imgur.com/almrnLB.png" alt=""></p>
</blockquote>
<ul>
<li>最快路徑公式(Shortest Time) \(d / u \)<ul>
<li>因為是最快路徑，因此我們順著河流，藉此讓船速跟河流速度的抵抗將至 0。所以只要距離除以船速即可。</li>
</ul>
</li>
<li>最短路徑公式(Shortest Path) \( cosθ = cos(arcsin(v / u))\)，前面是 v，後面是 u <ul>
<li>根據上面的圖我們可以知道河流會影響到我們的行進速度，於是我們需要更多時間來保證我們行徑的是最短路徑，因此船速要去抵抗河流速度，因此當河流往右時則我們船方向就往左來走出最短路徑。</li>
<li><blockquote>
<p><img src="https://i.imgur.com/GqsCe0L.png" alt=""><br>根據上圖可以看到類似於最短路徑的三角形產生， v 就是 x 然後 u 就是 1，因此 \(v / u \)就是我們需要的 \(cos(arcsin(v / u))\)，但要注意的是還需要乘以 u，因為我們剛剛是透過三角形公式先轉換成符合套件的度量衡，現在再乘回來才會得到正確答案</p>
</blockquote>
</li>
<li>之後與最快路徑公式相同，讓 \(d / (u * cos(arcsin(v / u))) \) 即可。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="參考來源"><a href="#參考來源" class="headerlink" title="參考來源"></a>參考來源</h2><ul>
<li>齊笎詳解</li>
<li><a href="https://zh.wikipedia.org/wiki/%E5%8F%8D%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0" target="_blank" rel="noopener">反三角函數 - wiki</a></li>
</ul>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>這個好難QQQ，竟然要用到三角函數，快把我給考倒了拉！！幸好有隊友的詳解來讓我快速學會，不然我在學習這題目的過程中一定會卡很久的關XD。</p>
<p>如果比賽要用到三角函數，我可能要先投降了..。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> kase ;</span><br><span class="line"><span class="keyword">double</span> n , u , d , v ;</span><br><span class="line"><span class="keyword">double</span> fast ,shortest ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> );</span><br><span class="line">    freopen(<span class="string">"out.txt"</span> , <span class="string">"w"</span> , <span class="built_in">stdout</span> );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; d &gt;&gt; v &gt;&gt; u;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Case "</span> &lt;&lt; ++kase &lt;&lt; <span class="string">": "</span> ;</span><br><span class="line">        <span class="keyword">if</span>(u == <span class="number">0</span> || v == <span class="number">0</span> || v &gt;= u )&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"can't determine"</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">            <span class="keyword">continue</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fast = <span class="number">0</span> ; shortest = <span class="number">0</span> ;</span><br><span class="line">        fast = d / u ;</span><br><span class="line">        shortest = d / (u *<span class="built_in">cos</span>(<span class="built_in">asin</span>(v/u)));</span><br><span class="line">        <span class="comment">//cout &lt;&lt; fast &lt;&lt; ' ' &lt;&lt; shortest &lt;&lt; '\n' ;</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; fixed &lt;&lt; setprecision(<span class="number">3</span>) &lt;&lt; <span class="built_in">abs</span>(fast - shortest ) &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>數論 Math theorm</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa11614 - Etruscan Warriors Never Play Chess (數論 Math theorm)</title>
    <url>/2020/12/28/UVa/UVa11614/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>有一組軍隊，他們的排隊方式向金字塔般，第一排一個、第二排兩個、第三排三個，以此類推，想請問你第 n 個人是第幾排？</p>
<p>測試資料最大不會超過 \(10^{18{\)</p>
</blockquote>
<a id="more"></a>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>不是難題，但也是有點腦筋急轉彎的感覺。</p>
<p>我們可以看出他像是金字塔一樣，因此透過梯形面積公式 \((上底 + 下底) * 高  / 2 \)的方式得出人數，上底必定是 1，因為第一排有一個人。</p>
<p>之後再透過配方法去解即可。</p>
<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li>公式解(配方法)，以下進行推導，題目要求的 row 必為正數，因此負不合<br>\(\frac{(1+row) * row}{2} \geq n \\ ⇒ row^2 + row -2n = 0 \\ ⇒ row = \frac{-1 \pm \sqrt{ 1^2 - (4 * 1 * (-2n))}{2}} \\ ⇒ row = \frac{-1+ sqrt{1+8n}}{2}   \)</li>
</ul>
<h2 id="參考來源"><a href="#參考來源" class="headerlink" title="參考來源"></a>參考來源</h2><ul>
<li>齊笎詳解</li>
<li><a href="http://ptvs24.blogspot.com/2017/05/uva-q11614-etruscan-warriors-never-play.html" target="_blank" rel="noopener">UVA Q11614 - Etruscan Warriors Never Play Chess</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E9%85%8D%E6%96%B9%E6%B3%95" target="_blank" rel="noopener">配方法</a></li>
</ul>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>這題不難，運用了國中知識解出。相信大家有一定概念都會的XD</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 10000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n , a ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compute</span><span class="params">(<span class="keyword">int</span> a )</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="number">-1</span> + <span class="built_in">sqrt</span>(<span class="number">1</span>+<span class="number">8</span>*a)) / <span class="number">2</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> );</span><br><span class="line">    freopen(<span class="string">"out.txt"</span> , <span class="string">"w"</span> , <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a ;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; compute(a) &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="手寫紀錄"><a href="#手寫紀錄" class="headerlink" title="手寫紀錄"></a>手寫紀錄</h2><p>記錄我在解這題的紀錄，透過紙筆來思考會讓我聰明很多<br><img src="https://i.imgur.com/yjQScQd.jpg" alt=""></p>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>數論 Math theorm</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa11723 - Numbering Roads! (水題)</title>
    <url>/2020/12/28/UVa/UVa11723/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>有一個國家的道路命名方式是這樣的，透過數字 0-9 與字母 A-Z，數字配上一個字母(也可以不配)來當作一個道路的命名，<del>類似舊高雄市</del>XD。<br>給你需要命名的道路數量，可用數字為 3，告訴我們可不可以全部命名成功，且輸出可以用到最少的字母，也就是只需要用到第幾個字母就命名完全道路，如果不行請輸出 impossible。</p>
<p>舉例，道路有 5 條，可用數字為 2<br>那道路就有 1,2,1a,2a,1b,2b ，因此就輸出 2，因為用到 b</p>
</blockquote>
<a id="more"></a>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>這題很簡單XD，我們只要把不一定要配上字母的命名也當作是一種字母，也就表示總共有 27 個字母可以使用，之後再讓道路數量除以可命名數字在減一就會是答案了XD。</p>
<h2 id="觀念重點"><a href="#觀念重點" class="headerlink" title="觀念重點"></a>觀念重點</h2><ul>
<li>由於 C++ 的除法是無條件輸入法，但在這裡我們需要的是無條件進位法，因為我們只要用到字母輸出就需要 +1，因此我們的做法是讓 <code>(道路數量 + 可用命名數量 -1 ) / 可用命名數量</code>，就可以達到無條件進位了！ -1 是防止 <code>(2+2) / 2 = 2</code> 的產生，因為道路數量只有 2，因此才需要將可用命名數量 -1 </li>
</ul>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>這題也是簡單 KO，這題的腦筋急轉彎比較少，我就順利通關，太開心了YA，小有成就感www。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 27</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> r , n , kase , cnt ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">compute</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cnt = (r + n<span class="number">-1</span>) / n ;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Case "</span> &lt;&lt; ++kase &lt;&lt; <span class="string">": "</span>;</span><br><span class="line">    <span class="keyword">if</span>(cnt &gt; <span class="number">27</span> )</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt;<span class="string">"impossible\n"</span> ;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; cnt<span class="number">-1</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> );</span><br><span class="line">    freopen(<span class="string">"out.txt"</span> , <span class="string">"w"</span> , <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; r &gt;&gt; n &amp;&amp; r+n != <span class="number">0</span> )&#123;</span><br><span class="line">        compute();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>水題</tag>
        <tag>UVa</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>統計學(一) 筆記 - 第八章 區間估計(Interval Estimation)</title>
    <url>/2020/12/29/NTUT_note/statistics-ch8/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊與財金管理系大二上統計學重點整理<br><font color="#dd0000">並非所有人都適用，部分對我而言稍加容易的內容並不會寫在此內。</font><br><strong>這是觀看影片心得後的筆記，老師上課可能不太適用會忘記抄到</strong></p>
</blockquote>
<a id="more"></a>

<h2 id="Margin-of-Error-and-the-Interval-Estimate-邊際誤差與區間估計"><a href="#Margin-of-Error-and-the-Interval-Estimate-邊際誤差與區間估計" class="headerlink" title="Margin of Error and the Interval Estimate 邊際誤差與區間估計"></a>Margin of Error and the Interval Estimate 邊際誤差與區間估計</h2><ul>
<li>點估計值基本上不會完全相等母體參數，也就是母體的正確答案</li>
<li>透過 Interval Estimate 區間估計可以幫助我們推出正確的點估計值<br>區間估計公式：\(\text{Point Estimate } \pm \text{Margin of Error }\)，其中點估計量通常會用 \(\bar{x}\) 代替</li>
<li>區間估計可以告訴我們 Point Estimate 多靠近母體參數。</li>
<li>母體參數<br>我們要詢問母體的某一件事，每一個人都必須適用，且通常都是判斷有或沒有，例如判斷所有的學生們有沒有統計都及格。</li>
</ul>
<h3 id="Margin-error-邊際誤差"><a href="#Margin-error-邊際誤差" class="headerlink" title="Margin error 邊際誤差"></a>Margin error 邊際誤差</h3><ul>
<li>通常設 \(E\) 來表示邊際誤差 </li>
<li>邊際誤差公式為 \(E = z_{a/2} \frac{\sigma}{\sqrt{n}}\)<ul>
<li>其中 n 為我們必要的樣本估計大小<br>將邊際誤差公式移項就可以得到 \(n = \frac{(z_{a/2}^2 \  \ \sigma^2)}{E^2}\)</li>
</ul>
</li>
<li>標準差未知的情況<ul>
<li>如果一開始不知道標準差就看<a href="https://theriseofdavid.github.io/2020/12/29/NTUT_note/statistics-ch8/#Interval-Estimate-of-a-Population-Mean-sigma-Unknown-%E6%AF%8D%E9%AB%94%E6%A8%99%E6%BA%96%E5%B7%AE%E6%9C%AA%E7%9F%A5%E7%9A%84%E9%BB%9E%E4%BC%B0%E8%A8%88%E9%87%8F" target="_blank" rel="noopener">母體標準差未知的點估計量</a></li>
<li>再抽測之前，先進行前側，這樣就知道標準差。</li>
<li><strong>預估</strong> <del>猜測</del></li>
</ul>
</li>
<li>如果知道標準差的估計量就看<a href="https://theriseofdavid.github.io/2020/12/29/NTUT_note/statistics-ch8/#Interval-Estimate-of-a-Population-Mean-sigma-Known-%E6%AF%8D%E9%AB%94%E6%A8%99%E6%BA%96%E5%B7%AE%E5%B7%B2%E7%9F%A5%E7%9A%84%E9%BB%9E%E4%BC%B0%E8%A8%88%E9%87%8F" target="_blank" rel="noopener">母體標準差已知的點估計量</a></li>
</ul>
<h4 id="舉例-公司想要知道各戶在-outlet-消費的平均花費是多少，在信心水準有-95-的情況下邊際誤差是-500-或是更小，請問我們應該要蒐集多少樣本，公司認為標準差為-4500。"><a href="#舉例-公司想要知道各戶在-outlet-消費的平均花費是多少，在信心水準有-95-的情況下邊際誤差是-500-或是更小，請問我們應該要蒐集多少樣本，公司認為標準差為-4500。" class="headerlink" title="舉例 - 公司想要知道各戶在 outlet 消費的平均花費是多少，在信心水準有 95% 的情況下邊際誤差是 500 或是更小，請問我們應該要蒐集多少樣本，公司認為標準差為 4500。"></a>舉例 - 公司想要知道各戶在 outlet 消費的平均花費是多少，在信心水準有 95% 的情況下邊際誤差是 500 或是更小，請問我們應該要蒐集多少樣本，公司認為標準差為 4500。</h4><p>先透過公式進行推導，\(z_{a/2}\frac{\sigma }{\sqrt{n}} = 500 \)<br>接著進行查表，當 \(z_{0.025} = 1.96 \)，因此標準差為 4500，就可以推出公式 \(n = \frac{(1.96)^2(4500)^2}{(500)^2} = 311.17 = 312 \)<br>因此我們就可以推出至少要有 312 個樣本才可以符合題目的要求。</p>
<h2 id="Interval-Estimate-of-a-Population-Mean-sigma-Known-母體標準差已知的點估計量"><a href="#Interval-Estimate-of-a-Population-Mean-sigma-Known-母體標準差已知的點估計量" class="headerlink" title="Interval Estimate of a Population Mean \(\sigma \) Known 母體標準差已知的點估計量"></a>Interval Estimate of a Population Mean \(\sigma \) Known 母體標準差<strong>已知</strong>的點估計量</h2><ul>
<li>要符合下面條件<ul>
<li>透過母體 \(\sigma \) 來計算</li>
<li>通常沒有辦法很精確的來找出母體 \(\sigma \)，但可以透過歷史資料來得出，這時我們就稱之為已知。</li>
<li>抽樣樣本 n 要大於 30</li>
<li>如果母體與常態分布相似則 n 大於 15 即可。</li>
<li>如果有高偏態或離群值很多時， n 至少要大於 50 </li>
</ul>
</li>
<li>樣本平均值分布為常態分布</li>
<li>點估計量 \(\mu \)<ul>
<li>公式 \(\bar{x} \pm Z_{a/2} \frac{\sigma}{\sqrt{n}}\)</li>
<li>\(\bar{x}\) 為樣本平均數</li>
<li>\(1-a \) 信賴係數</li>
<li>\(Z_{a/2} \) 為常態分布的信賴區間</li>
<li>\(\sigma\) 母體標準差</li>
<li>\(n\) 樣本大小</li>
</ul>
</li>
<li>常用的信賴區間、與信賴水準，信賴水準就是常態分配的 \(平均值 \pm 標準差 \)<ul>
<li>\( a / 2 \)，非信賴區間的面積</li>
<li>查表時，是先看 \(a / 2 \) 的值後進行查表，透過右邊的標準差來找出 Z 值是多少<blockquote>
<p><img src="/images/statistics-ch8/4.PNG" alt=""></p>
</blockquote>
</li>
</ul>
</li>
<li>舉例 - 透過上面那張圖可以知道在 \(\bar{x} \pm 1.645 \sigma_{\bar{x}}\) 有 90 % 的機率會包含母體平均數。<ul>
<li>因此 90 % 稱為信賴水準 (confidence level )</li>
<li>0.9 也被稱為信賴係數(confidence coefficient)，信賴水準的小數表示就稱為信賴係數。</li>
</ul>
</li>
</ul>
<h4 id="舉例-百貨公司想知道消費者消費金額，抽出-100-份，並透過此知道點估計量"><a href="#舉例-百貨公司想知道消費者消費金額，抽出-100-份，並透過此知道點估計量" class="headerlink" title="舉例 - 百貨公司想知道消費者消費金額，抽出 100 份，並透過此知道點估計量"></a>舉例 - 百貨公司想知道消費者消費金額，抽出 100 份，並透過此知道點估計量</h4><p>由於母體 \(\sigma \) 已經給出 20，且母體極大才能夠這樣算。</p>
<p><strong>這裡主要是要讓讀者知道點估計量也會是常態分配</strong> </p>
<blockquote>
<p><img src="/images/statistics-ch8/1.PNG" alt=""></p>
</blockquote>
<p>因此我們可以知道樣本標準差為 2。</p>
<h3 id="Normal-Probability-Distribution"><a href="#Normal-Probability-Distribution" class="headerlink" title="Normal Probability Distribution"></a>Normal Probability Distribution</h3><ul>
<li>複習一下常態分配中的經驗法則<ul>
<li>\(平均值 \pm 一個標準差 = 68.26 \% \)</li>
<li>\(平均值 \pm 兩個標準差 = 95.44 \% \)</li>
<li>\(平均值 \pm 三個標準差 = 99.72 \% \)</li>
</ul>
</li>
<li>在樣本平均值 \(\bar{x} \) 值中，我們推算出來的樣本標準差將會是信心區間，也就是每次的抽樣樣本平均值會落在樣本標準差裡面的機率會是多少。<ul>
<li>舉例，樣本標準差為 2，那下次抽樣樣本的平均值會落差標準差 2 的機率是多少<br>根據上面講的經驗法則，\(平均值 \pm 兩個標準差 = 95.44 \% \)，因此機率則會是 95.44%</li>
</ul>
</li>
<li>圖解<ul>
<li>\(\bar{x_1 }\) and \(\bar{x_3 }\)<br>這兩次的抽樣樣本中數值則有落在母體平均值當中</li>
<li>\(\bar{x_2 }\)<br>這次的抽樣樣本中數值則<strong>沒有</strong>落在母體平均值當中</li>
<li>z 則是在手算時會使用到，<a href="https://theriseofdavid.github.io/2020/12/01/NTUT_note/statistics-ch7/" target="_blank" rel="noopener">第七章</a>常用到</li>
<li>a (藍色區塊) 則是在抽樣樣本不會落在\(平均值 \pm 標準差 \) 的其他機率，除以 2 是因為左右一半都有面積</li>
<li><blockquote>
<p><img src="/images/statistics-ch8/3.PNG" alt=""></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="舉例-承上題，我們想知道-mu-pm-3-92-的值差幾個標準差並有多少機率母體平均數會落在此區間"><a href="#舉例-承上題，我們想知道-mu-pm-3-92-的值差幾個標準差並有多少機率母體平均數會落在此區間" class="headerlink" title="舉例 - 承上題，我們想知道 \(\mu \pm 3.92 \) 的值差幾個標準差並有多少機率母體平均數會落在此區間"></a>舉例 - 承上題，我們想知道 \(\mu \pm 3.92 \) 的值差幾個標準差並有多少機率母體平均數會落在此區間</h4><p>我們剛剛已經算是樣本標準差為 2，因此是 95.44% ，因此只需要 \(3.92 / 2 = 1.96 \)，因此落在 \(1.96 \sigma{\bar{x}}\)</p>
<blockquote>
<p><img src="/images/statistics-ch8/2.PNG" alt=""></p>
</blockquote>
<h4 id="舉例-Discounr-Sounds-在美國有-260-家的店，還想要開新的店，於是他先去調查新店-不是地名-地區的年收入，樣本-n-36，且年收入平均值為-41-100，母體沒有高偏態，標準差為-4-500-且信賴區間為-0-95，算出一個範圍在隨機抽樣中有-95-的機會有包含母體平均數"><a href="#舉例-Discounr-Sounds-在美國有-260-家的店，還想要開新的店，於是他先去調查新店-不是地名-地區的年收入，樣本-n-36，且年收入平均值為-41-100，母體沒有高偏態，標準差為-4-500-且信賴區間為-0-95，算出一個範圍在隨機抽樣中有-95-的機會有包含母體平均數" class="headerlink" title="舉例 - Discounr Sounds 在美國有 260 家的店，還想要開新的店，於是他先去調查新店(不是地名)地區的年收入，樣本 n = 36，且年收入平均值為 41,100，母體沒有高偏態，標準差為 4,500 且信賴區間為 0.95，算出一個範圍在隨機抽樣中有 95 % 的機會有包含母體平均數"></a>舉例 - Discounr Sounds 在美國有 260 家的店，還想要開新的店，於是他先去調查新店(不是地名)地區的年收入，樣本 n = 36，且年收入平均值為 41,100，母體沒有高偏態，標準差為 4,500 且信賴區間為 0.95，算出一個範圍在隨機抽樣中有 95 % 的機會有包含母體平均數</h4><p>因為抽樣會比起直接將整個母體查詢會更快一些，且母體沒有高偏態，因此可以進行常態分配。</p>
<p>往上數第四張圖已經說明 95% 的信心水準是 \(\bar{x} \pm 1.96 \sigma_{\bar{x}}\) 區間會包含母體平均數。</p>
<p>因此邊際誤差(margin of error) \(Z_{a/2} \frac{\sigma}{\sqrt{n}} = 1.96(\frac{4500}{\sqrt{36}}) = 1,470\)，因此在 95% 的信賴水準下邊際誤差會是 1,470。</p>
<p>再將母體平均值 \( 41,100 \pm 1,470 \) 也就是 \(39,630 \ to \ 42,570\)，就是我們的區間估計且有 95% 的信賴水準</p>
<p>在其他信賴區間時的邊際誤差與區間估計</p>
<blockquote>
<p><img src="/images/statistics-ch8/5.PNG" alt=""></p>
</blockquote>
<h2 id="Interval-Estimate-of-a-Population-Mean-sigma-Unknown-母體標準差未知的點估計量"><a href="#Interval-Estimate-of-a-Population-Mean-sigma-Unknown-母體標準差未知的點估計量" class="headerlink" title="Interval Estimate of a Population Mean \(\sigma \) Unknown 母體標準差未知的點估計量"></a>Interval Estimate of a Population Mean \(\sigma \) Unknown 母體標準差<strong>未知</strong>的點估計量</h2><ul>
<li>沒辦法透過過去歷史資料來推出 \(\sigma \) 時，透過隨機樣本來找出 \(\sigma \)，這個時候要使用 t 分配(Distribution)</li>
</ul>
<h3 id="t-Distribution"><a href="#t-Distribution" class="headerlink" title="t Distribution"></a>t Distribution</h3><ul>
<li>由一群相似的機率分配組合</li>
<li>依照參數來決定自由度 (degrees of freedom)</li>
<li>Degrees of freedom<br>再算樣本標準差有多少獨立的個數，在減掉 \(\bar{x}\)，就是自由度</li>
<li>自由度越大圖形越瘦長且會接近常態分配，如下圖<blockquote>
<p><img src="/images/statistics-ch8/6.PNG" alt=""></p>
</blockquote>
</li>
<li>t 值概念類似於標準常態機率分布的 z</li>
<li>當自由度大於 100 時，t 與 z 值接近相同</li>
<li>當 t 變成無限大時則與 z 相同 </li>
<li>Adequate Sample Size 足夠樣本數量 <ul>
<li>樣本數必須要大於 30 才可以使用</li>
<li>在母體高度偏態或有很多離群值時，樣本數量要高於 50 才可以使用</li>
<li>母體並不是常態分配，但有對稱性時則樣本數只需要 15 筆即可</li>
<li>母體分配與常態分配相同，那樣本數低於 15 也可以</li>
</ul>
</li>
<li>區間估計公式<ul>
<li>基本上類似於常態分配，但在一些非常態分布時也可以使用</li>
<li>\(\bar{x} \pm t_{a/2} \frac{s}{\sqrt{n}}\)</li>
<li>\(1-a\) 信賴係數</li>
<li>\(t_{a/2}\) 為 t 值的區域，為 \(n-1\) 的自由度， t 要查表</li>
<li>\(s\) 樣本標準差</li>
</ul>
</li>
</ul>
<h4 id="舉例-記者想要知道學生花多少錢在校外住宿，在離學校半英里裡面隨機抽樣出-16-筆雅房租金資料，平均租金-750-元、標準差-55，想要建立百分之-95-的信賴區間，來求出母體的平均租金與標準差"><a href="#舉例-記者想要知道學生花多少錢在校外住宿，在離學校半英里裡面隨機抽樣出-16-筆雅房租金資料，平均租金-750-元、標準差-55，想要建立百分之-95-的信賴區間，來求出母體的平均租金與標準差" class="headerlink" title="舉例 - 記者想要知道學生花多少錢在校外住宿，在離學校半英里裡面隨機抽樣出 16 筆雅房租金資料，平均租金 750 元、標準差 55，想要建立百分之 95% 的信賴區間，來求出母體的平均租金與標準差"></a>舉例 - 記者想要知道學生花多少錢在校外住宿，在離學校半英里裡面隨機抽樣出 16 筆雅房租金資料，平均租金 750 元、標準差 55，想要建立百分之 95% 的信賴區間，來求出母體的平均租金與標準差</h4><p>在 95 % 的信心區間中， \(\alpha = 0.05 \) and \(\alpha / 2 = 0.025 \)，因此可以找出\(t_{0.025}\)與在自由度為 \(n-1 = 16 - 1 = 15\)的 t 值，因此我們可以說明 \(t_{0.025} =2.131 \)</p>
<p>下方為查表</p>
<blockquote>
<p><img src="/images/statistics-ch8/7.PNG" alt=""></p>
</blockquote>
<p>根據區間估計公式 \(\bar{x} \pm t_{a/2} \frac{s}{\sqrt{n}} = 750 \pm 2.131 \frac{55}{\sqrt{16}} = 750 \pm 29.30 \)，透過此公式我們可以肯定在 95% 的信賴區間，母體的平均值會介於 720.70 to 779.30 。</p>
<h2 id="Summary-of-Interval-Estimate-Procedures-for-a-Population-Mean-區間估計的計算統整"><a href="#Summary-of-Interval-Estimate-Procedures-for-a-Population-Mean-區間估計的計算統整" class="headerlink" title="Summary of Interval Estimate Procedures for a Population Mean 區間估計的計算統整"></a>Summary of Interval Estimate Procedures for a Population Mean 區間估計的計算統整</h2><blockquote>
<p><img src="/images/statistics-ch8/8.PNG" alt=""></p>
</blockquote>
<h2 id="Interval-Estimate-of-a-Population-Proportion-母體比例的區間估計"><a href="#Interval-Estimate-of-a-Population-Proportion-母體比例的區間估計" class="headerlink" title="Interval Estimate of a Population Proportion 母體比例的區間估計"></a>Interval Estimate of a Population Proportion 母體比例的區間估計</h2><ul>
<li>公式為 \(\bar{p} \pm \text{Margin of Error}\)，將邊際誤差拆開就是<ul>
<li>等同於 \(\bar{p} \pm z_{a/2} \sqrt{\frac{\bar{p} (1-\bar{p}) }{n}}\)</li>
<li>\(1-a\) 為信心係數</li>
<li>\(z_{a/2}\) 為常態分配中，非信心水準的區塊</li>
<li>\(bar{p}\) 樣本母體</li>
</ul>
</li>
<li>在計算區間估計時，\(\bar{p}\) 會決定區間估計的距離</li>
<li>\(\bar{p} \) 要能夠使用常態分配時，必須要符合兩個條件<ul>
<li>\(n(1-p) \geq 5 \)</li>
<li>\(np \geq 5 \)</li>
</ul>
</li>
<li>用圖表來看<blockquote>
<p><img src="/images/statistics-ch8/9.PNG" alt=""></p>
</blockquote>
</li>
</ul>
<h4 id="舉例-民意公司想要調查投票者的薪資，因此進行調查，他調查-500-位選民有-220-位會投給-A，PSI-有-95-的信心水準，想要知道會支持-A-候選人的比例有多少。"><a href="#舉例-民意公司想要調查投票者的薪資，因此進行調查，他調查-500-位選民有-220-位會投給-A，PSI-有-95-的信心水準，想要知道會支持-A-候選人的比例有多少。" class="headerlink" title="舉例 - 民意公司想要調查投票者的薪資，因此進行調查，他調查 500 位選民有 220 位會投給 A，PSI 有 95% 的信心水準，想要知道會支持 A 候選人的比例有多少。"></a>舉例 - 民意公司想要調查投票者的薪資，因此進行調查，他調查 500 位選民有 220 位會投給 A，PSI 有 95% 的信心水準，想要知道會支持 A 候選人的比例有多少。</h4><p>因此透過公式 \(\bar{p} \pm z_{a/2} \sqrt{\frac{\bar{p} (1-\bar{p}) }{n}}\)，並將其值帶入</p>
<ul>
<li>\(n = 500 \)</li>
<li>\(\bar{p} = 220 / 500 = 0.44 \)</li>
<li>\(z_{a/2} = 1.96 \)</li>
</ul>
<p>帶入後則會得到 \(0.44 \pm 1.96 \sqrt{\frac{0.44-(1-0.44)}{500}} = 0.44 \pm 0.0435 \)</p>
<p>因此民意公司在 95% 的信心水準之下，會投給 A 候選人的比例在於 0.3965 to 0.4835。</p>
<h3 id="Sample-Size-for-an-Interval-Estimate-of-a-Population-Proportion-決定母體比例的區間估計的樣本大小"><a href="#Sample-Size-for-an-Interval-Estimate-of-a-Population-Proportion-決定母體比例的區間估計的樣本大小" class="headerlink" title="Sample Size for an Interval Estimate of a Population Proportion 決定母體比例的區間估計的樣本大小"></a>Sample Size for an Interval Estimate of a Population Proportion 決定母體比例的區間估計的樣本大小</h3><p>找出邊際誤差的公式為 \(E = z_{a/2} \sqrt{\frac{\bar{p} (1-\bar{p}) }{n}}\) ，<strong>其中，\(\bar{p}\)</strong>因為我們還沒抽樣還不知道，因此我們這邊用\(\star{p}\) 表示還不知道樣本大小的 p</p>
<p>因此公式就是 \(n = \frac{(z_{a/2} \ )^2 \ \star{p} (1-\star{p})}{E^2}\)</p>
<ul>
<li>\(\star{p}\) 怎麼得出<ul>
<li>透過過去歷史資料得出</li>
<li>前側，先簡單抽樣一次</li>
<li>判斷，<del>猜測</del></li>
<li>使用 0.5 當參考，但這是最後手段。 </li>
</ul>
</li>
</ul>
<h4 id="舉例-民意公司希望有-99-的機率樣本比例離平均數為正負-0-03-邊際誤差-，需要多少的樣本才能達到這個目標？根據過去資料通常樣本比例必須要是-0-44"><a href="#舉例-民意公司希望有-99-的機率樣本比例離平均數為正負-0-03-邊際誤差-，需要多少的樣本才能達到這個目標？根據過去資料通常樣本比例必須要是-0-44" class="headerlink" title="舉例 - 民意公司希望有 99% 的機率樣本比例離平均數為正負 0.03(邊際誤差)，需要多少的樣本才能達到這個目標？根據過去資料通常樣本比例必須要是 0.44"></a>舉例 - 民意公司希望有 99% 的機率樣本比例離平均數為正負 0.03(邊際誤差)，需要多少的樣本才能達到這個目標？根據過去資料通常樣本比例必須要是 0.44</h4><p>因此根據邊際誤差公式 \(z_{a/2} \sqrt{\frac{p(1-p)}{n}} = 0.03 \)<br>在 99% 的信心水準中，\(z_{0.005} = 2.576\)，\(\bar{p} = 0.44 \)<br>因此將公式寫出就是 \(n = \frac{(z_{a/2} \ )^2 \ p* (1-p*)}{E^2} = \frac{(2.576)^2(0.44)(0.56)}{(0.03)^2} \approx 1817  \)</p>
<p>也就是樣本大小至少要大於 1817，才可以符合離平均數誤差為 0.03 之間且信心水準為 0.99。</p>
<p>如果題目沒有給出樣本比例時，則就用 0.5 來計算。</p>
]]></content>
      <categories>
        <category>北科上課筆記</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>統計學筆記</tag>
        <tag>北科大二上統計學筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa11805 - Bafana Bafana (水題)</title>
    <url>/2020/12/30/UVa/UVa11805/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>一個足球隊要訓練傳球，球員圍成一個圓圈且球員的傳球方式是傳給左手邊的隊友，也就是 1 傳給 2 傳給 3 已此類推，教練一開始會把球傳給 k 球員，想詢問傳了 p 次後球會在那個隊員腳上？</p>
</blockquote>
<a id="more"></a>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>英文很難…XD，這很痛苦wwww。這句英文特難啊，就讓我放在這邊來讓未來的我緬懷現在英文不好的我www。</p>
<h3 id="英文翻譯"><a href="#英文翻譯" class="headerlink" title="英文翻譯"></a>英文翻譯</h3><p>In each pass, a player will give the ball to his partner who is in his immediate right side.</p>
<p>在每一次的傳球，一個球員將傳給他的夥伴並且他的夥伴是在<strong>右手邊</strong>收到球。</p>
<p>看到了嘛！！！！！ 他的語句是被動型態，且是以收球者觀點為主，在華人社會很少會這樣講，直接習慣性以踢球者為主的角度去看，讓我以為她踢球是讓球員遞減，隊友 3 傳給隊友 2 傳給隊友 1，這種感覺..。</p>
<p>基本上這題不難，只需要將 \((現在的球員號碼 + 傳 x 次) % 隊員數量\) 即可，注意是當餘數為 0 時要特別改成 n 即可。因為模數的特姓，在球員號碼等同於隊員數量時上面公式會輸出 0，因此特別拉出來寫案例即可。</p>
<h2 id="觀念重點"><a href="#觀念重點" class="headerlink" title="觀念重點"></a>觀念重點</h2><ul>
<li>\((現在的球員號碼 + 傳 x 次) % 隊員數量\)</li>
<li>當上面的公式值為 0 時將改成輸出隊員數量</li>
</ul>
<h2 id="參考來源"><a href="#參考來源" class="headerlink" title="參考來源"></a>參考來源</h2><ul>
<li>齊笎詳解</li>
</ul>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>這題不難拉，只需要解決英文問題就好了，最近都在訓練數學題目順便增強英文閱讀能力，最近覺得英文閱讀能力有變好，算是一大感動嘛XD</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> t , n , k , p ;</span><br><span class="line"><span class="keyword">int</span> kase ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compute</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = (k + p) % n ;</span><br><span class="line">    <span class="keyword">if</span>(temp == <span class="number">0</span> )</span><br><span class="line">        <span class="keyword">return</span> n ;</span><br><span class="line">    <span class="keyword">return</span>  temp ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t ;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k &gt;&gt; p ;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Case "</span> &lt;&lt; ++kase &lt;&lt; <span class="string">": "</span> &lt;&lt; compute() &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>水題</tag>
        <tag>UVa</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa11875 - Brick Game (水題)</title>
    <url>/2020/12/30/UVa/UVa11875/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>孟加拉國對於 Brick Game 非常熱衷，最近出現了電競的賽事，隊伍的隊員數量必定是奇數，且透過年齡進行排序，可能會給遞增或遞減。需要一個隊長且隊長年齡必須是隊伍的中間值，否則會出現代溝，請輸出隊長的最適合年齡。</p>
<p>P.S. 隊友年齡都是獨一無二，不會有另外一個隊友與其他隊友年齡相同。</p>
</blockquote>
<a id="more"></a>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>水到不行www，前題是你英文夠好的話…。<del>我就理解錯了方向，還我寫了一個錯誤的版本</del></p>
<p>由於題目的隊員數量必定是奇數因此不需要擔心偶數 / 2 的問題，再加上年齡一定是遞增或是遞減，在奇數情況時連排序都不需要www。</p>
<h3 id="偶數的情況-題目沒有用到"><a href="#偶數的情況-題目沒有用到" class="headerlink" title="偶數的情況 - 題目沒有用到"></a>偶數的情況 - 題目沒有用到</h3><p>偶數比較麻煩，假如 1,2,3,4 我們要找出隊長就有可能是 2,3，但因為題目是奇數所以就不用擔心了XD。</p>
<p>假如隊長改成偶數且年齡必須是<strong>等於或等於 + 1</strong> 的年齡這時候排序就會很重要，不然直接輸入至陣列時就會因為沒有排序，如果同筆測試資料只是順序遞增與遞減時輸出答案就會不一至。</p>
<h4 id="舉例：-1-2-3-4-and-4-3-2-1-如果隊員是偶數時則選中位數-1-的隊友"><a href="#舉例：-1-2-3-4-and-4-3-2-1-如果隊員是偶數時則選中位數-1-的隊友" class="headerlink" title="舉例： 1,2,3,4 and 4,3,2,1 如果隊員是偶數時則選中位數 + 1 的隊友"></a>舉例： 1,2,3,4 and 4,3,2,1 如果隊員是偶數時則選中位數 + 1 的隊友</h4><p>同樣放在題目的這份程式碼，公式是 \(n/2+1\)，那在這兩種順序就會輸出 2 或者 3，答案不一致。</p>
<h3 id="錯誤方向"><a href="#錯誤方向" class="headerlink" title="錯誤方向"></a>錯誤方向</h3><p>擷取題目的關鍵字，這是誤導我的方向</p>
<p>Hence they select the captain of a team in such a way so that the number of player in the team who are younger than that captain is equal to the number of players who are older than that captain</p>
<p>因此選擇一個隊長的方法是選擇一位隊員且此<strong>隊員年齡會是隊伍的中間值</strong>。<br>P.S. 中間值 = 中位數。</p>
<p>我把它理解成了平均值…，於是我就用了加權平均數去計算，再找出最靠近加權平均數的年齡，後來才發現她要的是中位數..。</p>
<h3 id="觀念重點"><a href="#觀念重點" class="headerlink" title="觀念重點"></a>觀念重點</h3><ul>
<li>先將隊員年齡放入陣列中(index 0)，在 \(n/2\) 即可。</li>
</ul>
<h2 id="參考來源"><a href="#參考來源" class="headerlink" title="參考來源"></a>參考來源</h2><ul>
<li>齊笎詳解</li>
</ul>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>這題不難拉，只需要解決英文問題就好了，最近都在訓練數學題目順便增強英文閱讀能力，最近覺得英文閱讀能力有變好，算是一大感動嘛XD</p>
<p>可是我已經連續兩題英文閱讀方向錯了…，可以給我翻譯蒟蒻嘛。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 15</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> oo 1e9</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> num[MAXN] ;</span><br><span class="line"><span class="keyword">int</span> t , n ;</span><br><span class="line"><span class="keyword">int</span>  kase  ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compute</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; num[i] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//sort(num,num+n);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> num[n/<span class="number">2</span>] ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> );</span><br><span class="line">    freopen(<span class="string">"out.txt"</span> , <span class="string">"w"</span> , <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t ;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Case "</span> &lt;&lt; ++kase &lt;&lt; <span class="string">": "</span> &lt;&lt; compute() &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>水題</tag>
        <tag>UVa</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa12149 - Feynman( 數論 Math theorm )</title>
    <url>/2021/01/02/UVa/UVa12149/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>費曼在筆記中夾著餐巾紙，上面寫到在一個 n * n 的正方形中，裡面可以有多少種不同的正方形。<br>舉例：在 2 * 2 的正方形中，總共會有 5 種不同的正方形<br><img src="https://i.imgur.com/qpMeoD0.png" alt=""></p>
</blockquote>
<a id="more"></a>

<h2 id="觀念重點"><a href="#觀念重點" class="headerlink" title="觀念重點"></a>觀念重點</h2><ul>
<li><strong>推算</strong>出 n 的正方形有多少種正方形</li>
<li>再將這<strong>推算</strong>變成一數學公式</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>大難題XD，對於數學底子不好的我來說完全沒有辦法克服這題阿，我就像笨蛋一樣，嗚嗚。看了詳解並且詳細推了公式之後才了解一些。</p>
<h3 id="想出其他測試資料"><a href="#想出其他測試資料" class="headerlink" title="想出其他測試資料"></a>想出其他測試資料</h3><p>一開始要先稍微去推導其他例子，也就是除了範例以外我們再去想想在 n = 多少時會有多少正方形。</p>
<ul>
<li>n = 2 ，此時總共有  5 個正方形</li>
<li>n = 3 ，此時總共有 14 個正方形</li>
<li>n = 4 ，此時總共有 30 個正方形</li>
<li><del>不要問我怎麼算的，手畫真的很累..</del></li>
</ul>
<h3 id="歸納"><a href="#歸納" class="headerlink" title="歸納"></a>歸納</h3><p>如果真的有努力畫到 n = 4，那應該可以歸納出一個邏輯</p>
<ul>
<li>正方形邊長為 1<br>假如有一個 n 邊長的正方形，那他一定會有 n * n 個邊長為 1 的正方形</li>
<li>正方形邊長為 2<br>假如有一個 n 邊常的正方形，且 \(n \geq 2 \) 那他一定會有 \((n-1) * (n-1)\) 個邊長為 2 的正方形。至於為甚麼呢則在下方進行說明<ul>
<li>不同的正方形<br>因為不同的正方形定義只要裡面其中有一格是與其他正方形不同就可以獨立算是另一個新的正方形，但因為是正方形所以沒有辦法一格不同，只能夠 1 * n。</li>
<li>只需要 1 * n 個不同，我們要極大化正方形數量，因此我們從正方形左上角開始，不斷往下堆疊出邊長為 2 的正方形，會發現只能夠堆疊出 n - 1 個正方形<ul>
<li>舉例 n = 3，只能夠堆疊出兩個<br>如果想堆疊到第三個會發現會超出邊界，因此不可以</li>
<li>舉例 n = 4，只能夠堆疊出三個</li>
</ul>
</li>
<li>由於正方形長寬都一樣，因此 \( (n-1) * (n-1)\) 就會等於此正方形中邊長為 2 的所有正方形數量</li>
</ul>
</li>
<li>正方形邊長為 3<br>假如有一個 n 邊常的正方形，且 \(n \geq 3 \) 那他一定會有 \((n-2) * (n-2)\) 個邊長為 3 的正方形。至於為甚麼呢則在下方進行說明<ul>
<li>不同的正方形<br>因為不同的正方形定義只要裡面其中有一格是與其他正方形不同就可以獨立算是另一個新的正方形，但因為是正方形所以沒有辦法一格不同，只能夠 1 * n。</li>
<li>只需要 1 * n 個不同，我們要極大化正方形數量，因此我們從正方形左上角開始，不斷往下堆疊出邊長為 3 的正方形，會發現只能夠堆疊出 n - 1 個正方形<ul>
<li>舉例 n = 3，只能夠堆疊出一個<br>如果想堆疊到第二個會發現會超出邊界，因此不可以</li>
<li>舉例 n = 4，只能夠堆疊出兩個</li>
</ul>
</li>
<li>由於正方形長寬都一樣，因此 \( (n-2) * (n-2)\) 就會等於此正方形中邊長為 3 的所有正方形數量</li>
</ul>
</li>
<li>下方為圖示，為上方兩個正方形變長的範例 <blockquote>
<p><img src="https://i.imgur.com/WACl1u2.jpg" alt=""></p>
</blockquote>
</li>
<li>透過此方式可以推出在正方形邊長為 x 時，那會等於此正方形中邊長為 x 的所有正方形數量公式為 \((n-x) * (n-x) \)，也就是 \(\sum_{i=0}^{n-1} (n-i) * (n-i) \)。</li>
</ul>
<h3 id="將公式轉換"><a href="#將公式轉換" class="headerlink" title="將公式轉換"></a>將公式轉換</h3><p>再來我們將公式進行轉換，\(\sum_{i=0}^{n-1} (n-i) * (n-i) \) 雖然看起來可以用了，但我們還可以把它更優化。</p>
<p>\(\sum_{i=0}^{n-1} (n-i) * (n-i) \) 可以透過平方化簡等於 \(\sum_{i=0}^{n-1} (n-i)^2 \)。</p>
<p>再來，我們舉例假設 n = 3 的時候，應該會是 \((3-0)^2 + (3-1)^2 + (3-2)^2 = 3^2 + 2^2 + 1^2\)，透過這個舉例我們可以再將它化簡為 \(\sum_{i=1}^{n} i^2 \)，而此公式就是大家熟知的<strong>連續正整數平方和公式</strong>。</p>
<h3 id="連續正整數平方和公式"><a href="#連續正整數平方和公式" class="headerlink" title="連續正整數平方和公式"></a>連續正整數平方和公式</h3><p>再來就套用連續平方何公式即可。</p>
<p>關於此公式證明請看<a href="http://www.mathland.idv.tw/fun/Sum_of_squares.htm" target="_blank" rel="noopener">圖解連續正整數平方和公式</a></p>
<p>我會在講解一遍，但我認為我講解的不一定好於是附上網址，讓不懂我講解的人去看此，也謝謝此網站作者將學習資源公布在網路上</p>
<h4 id="證明"><a href="#證明" class="headerlink" title="證明"></a>證明</h4><p><img src="https://i.imgur.com/Jmuro5W.png" alt=""></p>
<ul>
<li><p>歸納<br>由此圖可知，有 5 個正方形與 5 個長方形組成此圖，且這 5 個正方形邊長分別為 1,2,3,4,5、5 個長方形邊長則為 1 * 1 , 1 * (1+2) , 1 * (1+2+3) , 1 * (1+2+3+4) , 1 * (1+2+3+4+5)。</p>
</li>
<li><p>我們想找的面積<br>而其實我們想要計算的連續正整數平方和就是紫色面積的正方形總和，如果我們透過數學算式去計算就是總面積減去黃色面積就是我們要查詢的面積。<br>於是我們就可以將公式稍微推出來，\([1 + 2 + 3 + … + (n-1) + n ] * (n+1) - [1 + (1+2) + (1+2+3) + … + (1+2+3+4+ … + n )] \)，翻譯成中文就是總面積的長度乘以總面積的高減去黃色部分就是紫色面積。 </p>
</li>
<li><p>將想找出的面積透過數學方式描述<br>\( [1 + (1+2) + (1+2+3) + … + (1+2+3+4+ … + n )] \) 是黃色面積中每一條長方型的面積，總和起來就是總黃色面積。</p>
</li>
<li><p>將其公式化<br>現在我們可以推出公式 \(\sum_{i=1}^{n} = i^2  =  \frac{n(n+1)}{2}(n+1) - \sum_{i = 1}^{n} \frac{i(i+1)}{2}   \)，這裡的 \(\frac{i(i+1)}{2} \) 為連續和公式。(梯形公式，上底為 1，下底為 n，高為 n )</p>
</li>
<li><p>推導與化簡步驟 1<br>再來進行化簡<br>\( \frac{n(n+1)}{2}(n+1) - \sum_{i = 1}^{n} \frac{i(i+1)}{2} = \frac{n(n+1)}{2}(n+1) - \frac{1}{2} \sum_{i=1}^{n} i(i+1) \)</p>
</li>
<li><p>推導與化簡步驟 2<br>\( \frac{n(n+1)}{2}(n+1) - \frac{1}{2} \sum_{i=1}^{n} i(i+1) =\frac{n(n+1)}{2}(n+1) - \frac{1}{2} \sum_{i=1}^{n} i^2 - \frac{1}{2} \sum_{i=1}^{n} i  \)，把 \( \sum_{i=1}^{n} i(i+1) \) 拉出來寫</p>
</li>
<li><p>推導與化簡步驟 3<br>這裡我們要進行移項，還記得一開始是  \(\sum_{i=1}^{n} = i^2 \) 嗎? 是我們不斷進行推導剛剛的步驟。<br>\(\sum_{i=1}^{n} = i^2 = \frac{n(n+1)}{2}(n+1) - \frac{1}{2} \sum_{i=1}^{n} i^2 - \frac{1}{2} \sum_{i=1}^{n} i \) 就變成了<br>\(  \frac{3}{2} \sum_{i=1}^{n} i^2 =  \frac{n(n+1)}{2}(n+1) - \frac{1}{2}\sum_{i = 1}^{n} i  \)，我們將 \( \frac{1}{2} \sum_{i=1}^{n} i^2 \) 移項至 \(\sum_{i=1}^{n} = i^2\) </p>
</li>
<li><p>推導與化簡步驟 4<br>\( \frac{n(n+1)}{2}(n+1) - \frac{1}{2}\sum_{i = 1}^{n} i = \frac{n(n+1)}{2}(n+1)  - \frac{1}{2} \frac{n(n+1)}{2} \)，將 \(\sum_{i = 1}^{n} i \) 轉換成連續和公式。</p>
</li>
<li><p>推導與化簡步驟 5<br>\( \frac{n(n+1)}{2}(n+1)  - \frac{1}{2} \frac{n(n+1)}{2} = \frac{n(n+1)}{2}(n+1) - (n + 1 - ) \frac{1}{2} \)，\(\frac{1}{2} \frac{n(n+1)}{2}\) 這項進行運算並化簡。</p>
</li>
<li><p>推導與化簡步驟 6<br>\( \frac{n(n+1)}{2}(n+1) - (n + 1 - ) \frac{1}{2} = \frac{n(n+1)(2n+1)}{4}\)，前面那項進行運算並化簡</p>
</li>
<li><p>推導與化簡步驟 7<br>還記得剛剛的值是 \(  \frac{3}{2} \sum_{i=1}^{n} i^2 \) 嗎？現在我們要在變回 \(  \sum_{i=1}^{n} i^2 \)於是<br>\(  \frac{3}{2} \sum_{i=1}^{n} i^2 = \frac{n(n+1)(2n+1)}{4}\) 將 \(  \frac{3}{2} \) 變成移項至另一邊，移項是分數數值會顛倒於是就變成了 \(\sum_{i=1}^{n} i^2 =  \frac{n(n+1)(2n+1)}{6}\)</p>
</li>
</ul>
<p><strong>現在我們有公式了，就來解決吧！</strong>，其實寫程式很簡單，如果有推出公式的話XD。</p>
<h2 id="參考來源"><a href="#參考來源" class="headerlink" title="參考來源"></a>參考來源</h2><ul>
<li><a href="https://knightzone.studio/2012/07/15/1759/uva%EF%BC%9A12149%EF%BC%8Dfeynman/" target="_blank" rel="noopener">uva：12149－feynman</a></li>
<li><a href="http://www.mathland.idv.tw/fun/Sum_of_squares.htm" target="_blank" rel="noopener">昌爸工作坊</a></li>
<li>微積分老師洪揮霖</li>
</ul>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>老實講，這題我寫的好痛苦XDDD，我自己的數學觀念太差了，雖然看了大神的 blog 得知這題是算出連續正整數平方和公式，但也是花了很多時間才想通QQQQ，再來連續正整數平方和公式我想要推出其證明還卡關…，問了微積分老師洪揮霖(他人很好，幫助我很多數學問題)發現我竟然是卡在移項問題沒看懂..(冏。</p>
<p>因為這題我花的時間比較久且大部分都是在公式推導上於是我就將我的公式推導流程放上來，如果有數學底子跟我一樣差的或許就能看懂了！希望不要有人跟我一樣差拉，很痛苦的，真的。都怪我國中太愛玩都沒有好好上數學課。</p>
<p>總之，學會了，我也變強了，希望之後可以發揮我現在學習的一課！<del>學習 1 小時，寫心得 4 小時是正常的嘛…</del></p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n &amp;&amp; n )&#123;</span><br><span class="line">        n = (n * (n+<span class="number">1</span>) * (<span class="number">2</span>*n+<span class="number">1</span>)) / <span class="number">6</span> ;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="思考流程"><a href="#思考流程" class="headerlink" title="思考流程"></a>思考流程</h2><p>透過紙筆與黑板而思考而成的片段，放在網路上供我紀念XD</p>
<blockquote>
<p><img src="https://i.imgur.com/EhqZ4y7.jpg" alt=""></p>
</blockquote>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>數論 Math theorm</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa12502 - Three Families(數論 Math theorm )</title>
    <url>/2020/12/31/UVa/UVa12502/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>A,B,C 這 3 個家庭共同管理一個花園，其中有一周 C 家庭出去玩，讓 A 與 B 共同去整理花園，當 C 回來時給予一筆錢來感謝 A 與 B 一起整理花園，題目詢問 A 應該要拿到多少錢比較好？ </p>
<p>x 為 A 家庭整理花園的時數<br>y 為 B 家庭整理花園的時數<br>z 為 C 家庭給予的錢</p>
<p>貼心提示</p>
<ul>
<li>假如 x 為 5、y 為 4、z 為 90，那公式並不是 \(90/(5+4)*5 = 50 \)，需要仔細想想，題目不會告訴你 </li>
<li>如果用到小數點時請小心使用，建議盡量避免</li>
</ul>
</blockquote>
<a id="more"></a>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>這題是大坑…，題目寫得很委婉希望你不要用小數..，但其實就是在暗示你說基本上你用有 95% 的機率不會過，另外 5% 是運氣www，然後我就是那 95 % 的人，真難過，嗚嗚嗚。</p>
<p>如果用題目推薦的方法，也就是不使用小數來計算時那我們就需要透過公式，公式推導如下：</p>
<ul>
<li>\(\frac{x+y}{3} = one\)，one 為三個家庭都應該要花的時數</li>
<li>\(x^{\prime} = x - one\)， \(x^{\prime} \) A 家庭多做的時數，如果是負數表示為少做</li>
<li>\(y^{\prime} = y - one \)，\(x ^ {\prime}\) B 家庭多做的時數，如果是負數表示為少做</li>
<li>\(z_a = z * \frac{x^{\prime} }{^{\prime}+y^{\prime}  } \)，\(z_a\) 為 A 家庭應該獲得的錢</li>
<li>將 \(z_a \) 開始進行推導<br>\(z_a = z * \frac{x^{\prime} }{x^{\prime}+y^{\prime}} \\ = z * \frac{x - one }{(x -one ) + (y - one)} \\ = z * \frac{(x - \frac{x+y}{3})} {  (x - \frac{x+y}{3}) + (y - \frac{x+y}{3}) } \\ = z * \frac{ \frac{2x-y}{3}}{\frac{2x-y}{3} + \frac{2y-x}{3}} \\ = z * \frac{2x-y}{2x-y+2y-x} \\ = z * \frac{(2x-y)}{x+y} \)</li>
<li>根據我們得出的結論就可以得到此公式 \(z * \frac{(2x-y)}{x+y}\)，再透過此公式進行計算即可且此計算還可以避免掉小數問題，符合題目需求，讚。(只使用一次除法會產生小數點，是最簡避免方法)</li>
</ul>
<h2 id="觀念重點"><a href="#觀念重點" class="headerlink" title="觀念重點"></a>觀念重點</h2><ul>
<li>思考出這題要帶給你的邏輯觀念</li>
<li>公式推導</li>
<li>讓你知道在程式中多使用小數點是非常不好的事，盡量避免小數除法</li>
<li>如果 A 沒有幫忙工作，反而還少工作此時 A 則不應該拿到薪水，如果計算出來為負也要改為 0<br><del>壞家庭 A</del></li>
<li>享受題目的惡意</li>
</ul>
<h2 id="參考來源"><a href="#參考來源" class="headerlink" title="參考來源"></a>參考來源</h2><ul>
<li><a href="https://knightzone.studio/2020/01/22/4687/uva%EF%BC%9A12502%EF%BC%8Dthree-families/" target="_blank" rel="noopener">UVa：12502－Three Families</a></li>
</ul>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>這題好機車..，主要任務是將小數點誤差降至最低但是卻又不跟你說明白，有點暗示暗示的概念小討厭阿，查看了 google 上其他大神的詳解後發現他們的解法才是真的強阿，透過不斷推導、不斷優化來找出答案，讓我不禁覺得自己是個笨蛋了…。</p>
<p>不過透過他們的推導也讓我自己對這種類型的題目有了更深的體悟，也讓我思考的觀點有多了一個，學習到了新事物的感覺真的不錯呀，整個腦袋感覺都被提升了一個檔次。</p>
<p>只是題目沒有明示我真的猜不出來…，我不夠熟還需要懂淺規則RRRRR。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">float</span> t , hr , x , y , z ;</span><br><span class="line"><span class="keyword">int</span> cost ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>,<span class="string">"r"</span> , <span class="built_in">stdin</span>) ;</span><br><span class="line">    freopen(<span class="string">"out.txt"</span>, <span class="string">"w"</span> , <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t ;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y &gt;&gt; z ;</span><br><span class="line">        cost = z * (<span class="number">2</span> * x - y) / (x + y ) ;</span><br><span class="line">        <span class="keyword">if</span>(cost &lt; <span class="number">0</span> ) cost = <span class="number">0</span> ;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; cost &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>##　思考流程<br>透過紙筆與黑板而思考而成的片段，放在網路上供我紀念XD</p>
<blockquote>
<p><img src="https://i.imgur.com/NN4I3DT.jpg" alt=""><br><img src="https://i.imgur.com/yTbnkno.jpg" alt=""><br><img src="https://i.imgur.com/7d1P97E.jpg" alt=""><br><img src="https://i.imgur.com/MPX4z1C.jpg" alt=""></p>
</blockquote>
<h2 id="錯誤的思考方向"><a href="#錯誤的思考方向" class="headerlink" title="錯誤的思考方向"></a>錯誤的思考方向</h2><p>我在寫程式的時後我一開始有透過我的思考方式來寫出這份題目，但發現有個很重要的問題XD，那就是誤差太大了…。</p>
<p>在透過題目的樣本測資時並沒有錯誤，但在 udebyg 上的測資發現有兩筆答案都少一個數字，我很納悶於是用手重新算了一遍則發現是小數點誤差導致發生其問題。</p>
<p>我一開始寫的程式邏輯如下</p>
<ul>
<li>先算出每個家庭應該要工作的時數，公式是 \((x+y) / 3\)，因為題目有說明所有家庭的打掃速度都是相同</li>
<li>由於 C 家庭付出薪水而沒有工作(資本主義的荼毒)，因此我們可以假設成 C 付出的錢等於一個家庭的工作量</li>
<li>C 付出的薪水除以一個家庭應該要工作的時數，等於 1 小時的薪資</li>
<li>A 家庭減去一個家庭應該要工作的時數，剩下的時數就是幫 C 工作的時數，再將我們計算好 1 hr 的薪水去乘 A 多工作的時數</li>
<li>輸出 A 應該要拿到的薪水</li>
</ul>
<h3 id="會錯誤的原因-誤差"><a href="#會錯誤的原因-誤差" class="headerlink" title="會錯誤的原因 - 誤差"></a>會錯誤的原因 - 誤差</h3><ul>
<li>第一個誤差<br>其實這個邏輯沒有錯，錯就錯在小數點誤差…，一開始必須要算出一個人的工作時數，此時需要除以 3，如果這時候會有小數時就會有誤差</li>
<li>第二個誤差<br>再來是 C 付出的錢要除以一個家庭應該要工作的時數，如果這時候也除不盡也會有誤差</li>
<li>第三個誤差<br>再來是 A 家庭要拿到多工作的薪水，如果前面是小數點且有誤差的狀態則會讓誤差被放大，但如果前面兩個誤差都不會發生那就沒有問題XD。</li>
</ul>
<p>有上面三個誤差，就導致在某些測資上會產生 &gt;= 1 的誤差，因此錯誤，才要透過大神們的推導來寫，只會有一個機會誤差。</p>
<h3 id="舉例-x-3-y-2-z-90"><a href="#舉例-x-3-y-2-z-90" class="headerlink" title="舉例 x = 3 , y = 2 , z = 90"></a>舉例 x = 3 , y = 2 , z = 90</h3><h4 id="錯誤思考"><a href="#錯誤思考" class="headerlink" title="錯誤思考"></a>錯誤思考</h4><p>那每個家庭平均的工作量應該要是 (3+2) / 3 = 1.66<br>由於 C 付出 90 元，因此 90 / 1.66 = 54.21，也就是 1hr 為 54.21 元<br>3 - 1.66 = 1.34 ，1.34 為 x 多做的部分，因此給他時薪也就是 54.21 * 1.34 = 72.614</p>
<h4 id="正確方向"><a href="#正確方向" class="headerlink" title="正確方向"></a>正確方向</h4><p>透過推導公式可以得出 \(90 * \frac{2 * 3 - 2 }{3 + 2 } = 90 * \frac{4}{5} = 72 \)，與錯誤思考相差 0.614 元，因此正確方向比較好，遇到小數點誤差機率降低</p>
<h3 id="錯誤程式碼"><a href="#錯誤程式碼" class="headerlink" title="錯誤程式碼"></a>錯誤程式碼</h3><p>放在這裡來紀念寫錯程式碼的我來讓我進步吧XD</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">float</span> t , hr , x , y , z ;</span><br><span class="line"><span class="keyword">int</span> cost ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>,<span class="string">"r"</span> , <span class="built_in">stdin</span>) ;</span><br><span class="line">    freopen(<span class="string">"out.txt"</span>, <span class="string">"w"</span> , <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t ;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y &gt;&gt; z ;</span><br><span class="line">        cost = z * (<span class="number">2</span> * x - y) / (x + y ) ;</span><br><span class="line">        <span class="keyword">if</span>(cost &lt; <span class="number">0</span> ) cost = <span class="number">0</span> ;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; cost &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>數論 Math theorm</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa10181 - 15-Puzzle Problem(A*搜尋 )</title>
    <url>/2021/01/09/UVa/UVa10181/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>大家有玩過數字拼圖嗎？這題是數字拼圖，給你一個隨機生成的數字拼圖，透過上下左右的方式讓空白附近的方塊跟空白交換，操作方式如下：<br><img src="https://i.imgur.com/mAx9XXC.png" alt=""></p>
<p>如果可以在 50 步以內玩到拼圖的所有數字從左到右、從上到下都按照數字順序，那稱之為完成。並輸出從初始拼圖至最終拼圖的操作，輸出字元只能是 U,D,L,R。<br>P.S. 完成必須要是此圖<br><img src="https://i.imgur.com/t8TEweY.png" alt=""></p>
<p>如果不行，輸出 “This puzzle is not solvable.”</p>
</blockquote>
<a id="more"></a>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>這題好噁心…，好想回去寫數學…，數學好懂很多，這個讓我痛苦了 3 天左右、近 70 次左右的 TLE，嗚嗚。</p>
<p>這題可以用 IDA* or A* 去解決，比較推薦前者 IDA* 來解決，A* 有很多細節要進行處理，如果你是一位熱愛被題目折磨的好友就使用 A* 吧！</p>
<p>注意：此題目為 NP 問題，還沒有被科學家所研究出相關公式，只有研究出是否可解。</p>
<h3 id="分析棋面"><a href="#分析棋面" class="headerlink" title="分析棋面"></a>分析棋面</h3><p>首先，我們先來定義<strong>棋面</strong>的意思，此名詞為每一個拼圖狀態的樣子，只要有進行移動，即是兩個不同的棋面，相信大家看的出來這題是必須要輸出路徑至變成最終拼圖狀態，那這時最好的演算法就是 Dijkstra，但棋面的複雜度應該是 \(O(16! / 2) = 1.04e13\)，其中除 2 是左邊方塊與右邊方塊交換、右邊方塊與左邊方塊交換相同，則其道理上下也是</p>
<p>時間複雜度為 \(O(E \log \ V ) = 1.25e13\)、\(E = 1.04e13 , V = 16 \)，有 16 個點要找出最短路徑最短路徑，有 \(1.04e13\) 個狀態(邊)，但問題是最優秀的最短路徑演算法也需要對於這題做一些小技巧，不可以透過單純的 piority_queue 去解決，必須再透過一些小技巧來優化。</p>
<h4 id="儲存棋面"><a href="#儲存棋面" class="headerlink" title="儲存棋面"></a>儲存棋面</h4><p>我們粗略的判斷一下，每一個拼圖號碼都可以放在 16 個位置，總共有 16 個拼圖，並且拼圖順序不同也算是不同的棋面那總共會有 \(2e9\) 個棋面，\(E = 24 * 24 = 576 \)、\(V = 16 \)，如果透過簡單的 piority_queue，要對哪個棋面優先 top queue 環節。但由於每一次的狀態都會產生出 4 個狀態，因此有一個好的函示來判斷要先取出那個狀態做 dijkstra 是非常重要的，而這函式我們稱為<a href="https://theriseofdavid.github.io/2021/01/07/Explain_Algorithm/Astar/" target="_blank" rel="noopener">啟發式搜尋 heuristic search</a></p>
<h3 id="啟發式搜尋-heuristic-search"><a href="#啟發式搜尋-heuristic-search" class="headerlink" title="啟發式搜尋 heuristic search"></a><a href="https://theriseofdavid.github.io/2021/01/07/Explain_Algorithm/Astar/" target="_blank" rel="noopener">啟發式搜尋 heuristic search</a></h3><h4 id="判斷每一個拼圖是否在每個正確的位置上，沒有就加-1"><a href="#判斷每一個拼圖是否在每個正確的位置上，沒有就加-1" class="headerlink" title="判斷每一個拼圖是否在每個正確的位置上，沒有就加 1"></a>判斷每一個拼圖是否在每個正確的位置上，沒有就加 1</h4><p>這樣勢必是不行的，那麼在每次判斷的時候都必須跑一次迴圈進行測試，效率太差。且如果再正確位置空白下放 1 拼圖、正確位置 1 放空白拼圖，那麼此方法沒有辦法去解決此拼圖；因為只要換了就會讓錯的數字更多。</p>
<h4 id="曼哈頓距離"><a href="#曼哈頓距離" class="headerlink" title="曼哈頓距離"></a>曼哈頓距離</h4><p>曼哈頓距離，是幾何學中的用語，<del>幾何學的用語都很不淺顯易懂</del>，簡單來說的話就是，某一個拼圖要用最短步驟才可以到達正確拼圖的位置。</p>
<p>例如下圖中的 3，移到正確位置是多少曼哈頓距離。</p>
<blockquote>
<p><img src="https://i.imgur.com/CsjmuLp.png" alt=""></p>
</blockquote>
<p>正確答案是 4，最短只需要透過 4 步就可以到達正確拼圖的位置。而這樣可以透過國中就學習過的公式來進行推導 \(|x_1 - x_2 | + |y_1 - y_2 |\)。</p>
<h3 id="剛剛我們已經決定好要用曼哈頓距離，那-piority-queue-的判斷就是曼哈頓距離最小嗎？"><a href="#剛剛我們已經決定好要用曼哈頓距離，那-piority-queue-的判斷就是曼哈頓距離最小嗎？" class="headerlink" title="剛剛我們已經決定好要用曼哈頓距離，那 piority_queue 的判斷就是曼哈頓距離最小嗎？"></a>剛剛我們已經決定好要用曼哈頓距離，那 piority_queue 的判斷就是曼哈頓距離最小嗎？</h3><p>當然不是，嗚嗚。我在這裡也犯過錯QQQ。</p>
<p>正確來說的公式應該是 \(已經行走的步驟 + 曼哈頓距離 * x = 優先權重\)，其中 x 為係數並且要大於等於 1，程式這裡為 10，且優先權重最<strong>小</strong>的先進行此次的 dijkstra。</p>
<p>稍微解釋一下公式，為甚麼曼哈頓距離需要乘以 x，是因為曼哈頓距離是我們預估的權重數量，並不是我們真正已經走的步驟，曼哈頓距離是我們<strong>尚未走</strong>的步驟。</p>
<p>如果沒有放大倍率那會造成已經走的步驟跟曼哈頓距離其實是一樣的概念，但其實並不是，已經走的步驟必定是<strong>當前</strong>最佳解且已經走過路徑，但曼哈頓路徑還不確定路徑需要去嘗試，因此最好的方法就是讓<br>必曼哈頓距離乘以 x 來讓他在權重中的影響力降低，在我們先將優先權重最小的點拿出的情況下。</p>
<h4 id="struct-使用-priority-queue-重點提醒"><a href="#struct-使用-priority-queue-重點提醒" class="headerlink" title="struct 使用 priority_queue 重點提醒"></a>struct 使用 priority_queue 重點提醒</h4><p>由於本人我在寫 pioirity_queue 犯過一個錯誤，其實是作者自己記憶力不好一直忘記QQ，因此寫在這邊稍微複習一下。</p>
<p>pioirity_queue 是 queue 的強化版，透過 heap sort 來強化<strong>權重</strong>的價值，預設情況下是遞減，因此如果我們特別自定一個 struct 時，C++ 並不清楚大小排序是如何？因此我們要自己寫一個 operator 來告知判斷大小的依據。</p>
<p>當要自己寫一個 operator 時，由於 pioirity_queue 是遞減，因此我們可以用一種偷懶的寫法，只要右邊的 struct 變數 A 小於左邊的 sturct 變數 st 依據是 A 的 h + step 要大於 st.h + st.step，透過此模式就可以在 priority_queue 遞減的情況下 struct 輸出的資料則是遞增。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">state</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> graph[<span class="number">4</span>][<span class="number">4</span>] ;</span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="keyword">int</span> h=<span class="number">-1</span> , step=<span class="number">0</span> ;</span><br><span class="line">    <span class="built_in">string</span> path =<span class="string">""</span> ;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(state st) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> h + step &gt; st.h + st.step ; </span><br><span class="line">        <span class="comment">//因此在這邊 st 要大於 state 的依據就是， state 的 h + step 要大於 st，</span></span><br><span class="line">        <span class="comment">//如果有符合此條件，那 heap sort 就會往上一層去比較，以達到 heap 遞減。</span></span><br><span class="line">        <span class="comment">//如果 st 沒有大於 state，那 st 的 h + step 就比 state 大</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可閱讀此篇來進行更好的理解<a href="https://blog.csdn.net/luomingjun12315/article/details/47376359" target="_blank" rel="noopener">STL 之 优先队列(priority_queue) Enstein_Jun </a></p>
<h3 id="這裡我們就不使用-map-or-set-紀錄棋面，而是用-priority-queue-去找優先權重最小，如果找到重複也沒關係"><a href="#這裡我們就不使用-map-or-set-紀錄棋面，而是用-priority-queue-去找優先權重最小，如果找到重複也沒關係" class="headerlink" title="這裡我們就不使用 map or set 紀錄棋面，而是用 priority_queue 去找優先權重最小，如果找到重複也沒關係"></a>這裡我們就不使用 map or set 紀錄棋面，而是用 priority_queue 去找優先權重最小，如果找到重複也沒關係</h3><p>為甚麼我們會這樣寫呢，根據上面的分析，棋面真的太多了，如果用 set or unorder_map 每次不斷去查詢是否有重複的棋面，那複雜度則會大幅上升。map 時間複雜度是 \(o(log \ n )\)，每次進行查詢與插入(新增棋面) 兩次的 \(o(log \ n )\)，會讓程式笨重許多。因此建議就是不進行記錄，我們透過 priority_queue 最小的取出的方式，直接取出最小值，只要我們能夠不斷取出最小值，小到 0 就會是答案。</p>
<p>可能會有人想問 priority_queue 複雜度也是 \(o(log \ n )\)，為甚麼就可以用它呢？那是因為我們一定要用到他，不然 dijkstra 就寫不出來了XD。</p>
<h3 id="但注意的是，我們還是要禁止他不斷的左右交換、上下交換"><a href="#但注意的是，我們還是要禁止他不斷的左右交換、上下交換" class="headerlink" title="但注意的是，我們還是要禁止他不斷的左右交換、上下交換"></a>但注意的是，我們還是要禁止他不斷的左右交換、上下交換</h3><p>由於我們缺少了紀錄棋面，因此在 Dijkstra 當下的棋面會不斷的嘗試進行上下左右交換，但假如剛剛我們才讓空白拼圖與某一數字交換，現在又在交換回來不就徒勞無功了嗎？因此我們要拒絕這種可能性，而解決此問題就是紀錄剛剛的 Path，如果剛剛從左來，那我們就禁止往右、剛剛從上來，就禁止往下.、剛剛從下來，就禁止往上、剛剛從右來，就禁止往左。</p>
<h3 id="判斷拼圖有沒有解"><a href="#判斷拼圖有沒有解" class="headerlink" title="判斷拼圖有沒有解"></a>判斷拼圖有沒有解</h3><p>在數字拼圖中是有無解的情況發生，舉個例子， n = 2，透過 (1,1) = 1, (1,2) = 3 , (2,1) = 2，讀者嘗試看看是否能夠解出XD。</p>
<p>一定沒有辦法解出。能解出還請私密我XD，你太強了www。在數字拼圖的論文中則有講到先將數字拼圖展開成一維陣列，之後透過下述規則判斷是否可解。</p>
<ul>
<li>N 為奇數，那<strong>遞減數對</strong>為偶數時可以被解出</li>
<li>N 為偶數<ul>
<li>如果空白拼圖是出現在由底部開始數的<strong>奇數</strong>時，則遞減數對在<strong>偶數</strong>時可解</li>
<li>如果空白拼圖是出現在由底部開始數的<strong>偶數</strong>時，則遞減數對在<strong>奇數</strong>時可解</li>
</ul>
</li>
<li>遞減數對是甚麼？<br>如上面的 n = 2 例子，展開成一維陣列即是 1,3,2，那 3,2 就是遞減數對，數對定義為只要兩個數字且前面數字大於後面數字就代表一組數對，但必須維持原本一維陣列的順序。</li>
<li>更好的解釋請查看 <a href="https://www.geeksforgeeks.org/check-instance-15-puzzle-solvable/" target="_blank" rel="noopener">How to check if an instance of 15 puzzle is solvable? GeeksforGeeks</a></li>
</ul>
<h4 id="證明"><a href="#證明" class="headerlink" title="證明"></a>證明</h4><p>我們先將拼圖變成一維陣列後，可以知道在水平移動時一維陣列並不會被更動，空白拼圖不可以被當作數字，因此不會用 (數字,空白) 的遞減數對發生；但在垂直移動時一維陣列的值就會被改動，且影響的方式是將某一數字與另一數字位置交換，我們稱之為對調。</p>
<p>由於數字拼圖的每一步可以想像成每一組數字的排列，我們只是將她重新排列成某一狀態，這時我們可以將題目理解成將 <code>1,2,3,4,5</code> 轉換成 <code>4,2,1,3,5</code>，只需要將 4 移動到 1 前面再來讓 1 移動到 3 前面即可得到答案。</p>
<p>再來讓 4 移動到 1 前面總共移動了 3 步，讓 1 移動到 3 前面總共移動了 2 步，因此每次的移動就會是 \(n-1 \)，n 為中間有多少數字。</p>
<h4 id="再來我們要怎麼用奇偶數來解決是否可以解出來呢？"><a href="#再來我們要怎麼用奇偶數來解決是否可以解出來呢？" class="headerlink" title="再來我們要怎麼用奇偶數來解決是否可以解出來呢？"></a>再來我們要怎麼用奇偶數來解決是否可以解出來呢？</h4><blockquote>
<p><img src="https://i.imgur.com/1XXxwtr.png" alt=""></p>
</blockquote>
<p>如果我們假設綠色格子是奇數，紅色格子是偶數，那我們要能夠將空白拼圖從紅色格子移到綠色格子時，奇偶數一定會產生變化，根據上方遞減數對的交換的說明。</p>
<p>因此我們就可以得知一個結論，透過舉例說明：</p>
<ul>
<li>一開始的狀態，紅色的格子(3,3)為空白區塊，且目前為奇數。</li>
<li>最終狀態，綠色的格子(4,4)為空白區塊，且為偶數。<br>這樣一定可以達到，對八，因為只要進行一次交換那奇偶數就會交換。</li>
<li>那我們把最終型態改變一下，綠色的格子(4,4)為空白區塊，且為奇數。<br>這樣就勢必沒有辦法達到，因為紅色格子在跟綠色格子交換時奇偶數就會被改變，因此我們永遠不可能達到此情況。</li>
</ul>
<p>題目要求我們的最終棋面的遞減數對為 0，因此空白最下方並且遞減數對為偶數。</p>
<p>更好的解釋請看 <a href="https://www.youtube.com/watch?v=Jidu5yA99u0&ab_channel=%E6%96%B9%E5%A1%8A%E8%BD%89%E4%B8%8D%E5%BF%AB" target="_blank" rel="noopener">你解不開！數字華容道 (15 puzzle) 與奇偶性 - 方塊轉不快</a>，但要注意這裡有將空白拼圖當作 16 但此證明沒有，但他的動畫很棒，因此建議大家觀看。</p>
<p>再來我們可以得知，如果是水平互換時，遞減數對不變，垂直互換時則遞減數對則增加或減少 \(N-1\)，在沒有 16 的情況下。</p>
<ul>
<li>如果 n 是偶數，那麼在此公式下  \(N-1\) 出來必定會是奇數，因此每次的遞減數對都會少了奇數<ul>
<li>因此如果空白為底部開始數的第一行時，那麼遞減數對在偶數時可解</li>
<li>因此如果空白為底部開始數的第二行時，那麼遞減數對在奇數時可解<br>因為每次的遞減數對都會增加或減少 \(N-1\)，N 為 puzzle 寬度</li>
</ul>
</li>
<li>根據上面兩個重點就可以得知 N 為偶數且空白拼圖是出現在由底部開始數的<strong>奇數</strong>時，則遞減數對在<strong>偶數</strong>時可解</li>
<li>如果空白拼圖是出現在由底部開始數的<strong>偶數</strong>時，則遞減數對在<strong>奇數</strong>時可解</li>
<li>如果 n 是奇數，那麼垂直移動時遞減數對會減少 \(N-1\)，但由於 N 為奇數因此公式下來必定是偶數，但偶數減偶數還是偶數XD，好饒舌www，因此我們只需要判斷遞減數對為偶數即可。</li>
</ul>
<p>透過此結論就可以知道</p>
<ul>
<li>如果 N 為奇數，則能夠被解出的狀態只有遞減數對為偶數</li>
<li>如果 N 為偶數<ul>
<li>如果空白拼圖是出現在由底部開始數的<strong>奇數</strong>時，則遞減數對在<strong>偶數</strong>時可解</li>
<li>如果空白拼圖是出現在由底部開始數的<strong>偶數</strong>時，則遞減數對在<strong>奇數</strong>時可解</li>
</ul>
</li>
</ul>
<h3 id="判斷-puzzle-是否可被解的小優化"><a href="#判斷-puzzle-是否可被解的小優化" class="headerlink" title="判斷 puzzle 是否可被解的小優化"></a>判斷 puzzle 是否可被解的小優化</h3><p>cnt = 遞減數對、x 為一般我們在計算時的方向位置，舉例：(3,2) = 空白，那 x 就等於 3。<br>如果 x 等於奇數時，就表示由底部開始算就會是偶數，因為 N = 4，當 n = 4 那從底部算就會是 1，因此剛好符合條件底部為偶數時，遞減數對在奇數是可解，所以我們就直接 \(+x\)，因為奇數加偶數還是等於奇數。</p>
<p>反之，那 x 等於偶數時，底部就會是奇數，相加時狀態不會改變，如果 cnt = 奇數，那加上偶數還是奇數，如果 cnt = 偶數，那加上偶數還是偶數，因此只要 mod 2 == 0 就表示不可解。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>((cnt+x)%<span class="number">2</span> ==<span class="number">0</span>) <span class="comment">//判斷是否可解，這裡用了小優化，可看上面文章理解</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span> ;</span><br></pre></td></tr></table></figure>

<h3 id="小優化-string"><a href="#小優化-string" class="headerlink" title="小優化 string"></a>小優化 string</h3><p>string 用平常的 +=，時間複雜度比較高，因此這裡我們使用 <code>string.push_back(char)</code>，會更好些，因為我們要不斷的做在字串尾巴中加入方向，如果一直不段使用 += 會拖累我們的效能，因此用<code>string.push_back(char)</code>會更為優秀些。</p>
<h2 id="觀念重點"><a href="#觀念重點" class="headerlink" title="觀念重點"></a>觀念重點</h2><ul>
<li>A* 用法使用得宜</li>
<li>piority_queue struct 寫 operator</li>
<li>puzzle 是否可以被解出<ul>
<li>核心推理證明</li>
<li>遞減數對與空白在哪個位置要判斷奇偶數的小優化</li>
</ul>
</li>
<li>不可以使用 map or set 紀錄</li>
<li>跑 dijkstra 拒絕回到上一步</li>
<li>紀錄正確位置的寫法</li>
<li>string 小優化</li>
</ul>
<h2 id="參考來源"><a href="#參考來源" class="headerlink" title="參考來源"></a>參考來源</h2><ul>
<li><a href="https://oi-wiki.org/search/astar/" target="_blank" rel="noopener">A* oiwiki</a></li>
<li><a href="https://blog.csdn.net/helloworld10086/article/details/41908903" target="_blank" rel="noopener">UVA - 10181 15-Puzzle Problem（15数码 A*） HelloWorld10086 </a></li>
<li><a href="https://www.geeksforgeeks.org/check-instance-15-puzzle-solvable/" target="_blank" rel="noopener">How to check if an instance of 15 puzzle is solvable? GeeksforGeeks</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E6%88%B4%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">戴克斯特拉演算法 - wiki </a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E7%BD%AE%E6%8F%9B#cite_note-combination-1" target="_blank" rel="noopener">排列 - wiki </a></li>
<li><a href="https://blog.csdn.net/luomingjun12315/article/details/47376359" target="_blank" rel="noopener">STL 之 优先队列(priority_queue) Enstein_Jun </a></li>
<li><a href="https://sites.google.com/site/zsgititit/home/jin-jiec-cheng-shi-she-ji/stl/priority" target="_blank" rel="noopener">priority queue 高中資訊科技概論教師黃建庭的教學網站 </a></li>
<li><a href="https://www.youtube.com/watch?v=Jidu5yA99u0&ab_channel=%E6%96%B9%E5%A1%8A%E8%BD%89%E4%B8%8D%E5%BF%AB" target="_blank" rel="noopener">你解不開！數字華容道 (15 puzzle) 與奇偶性 - 方塊轉不快</a></li>
</ul>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>這題好難…，可能是我第一次學 A* 在寫這份題目中我獲得了許多痛苦的感覺XD，畢竟在還沒有辦法把題目解開之前人都不會是開心的八，歷經了 4 次程式版本，看了許多網路上大佬的程式碼仔細研究分析，終於找到適合我學習的程式碼好開心&gt;&lt;。題外話：我寫了 4 個版本，結果都 TLE 卡住</p>
<p>就算通關後還是為了要能夠讓我完整了解此題的運作，我又花了很多時間不斷去理解、嘗試，最終理解至現在，不得不說學習到了很多觀念與事物，但在了解的過程中也獲得了很多絕望感XD，因為想不出來嘛，就很容懷疑自己到底為甚麼要走演算法，讓自己過的那麼不開心。但其實通關後的成就感以及讓我學習到的思維，我認為是不會愧對於前面的痛苦地。</p>
<p>但每次想到要寫演算法，心還是會揪一下XD。</p>
<p>不過這裡還是要謝謝齊芫，他在我學習這題的過程中不斷指出我的邏輯問題，也退回我的邏輯概念讓我有機會可以去重新學習此題，減少了我在未來中可能會因為這次的學習瑕疵而犯的漏洞，很謝謝他。</p>
<p>要是沒有他每次給我一個邏輯壓制，我可能現在還覺得我很會寫演算法呢XD。</p>
<p>也謝謝在網路上提供資料的大神們，沒有你們我連學習的機會都沒有…，然後農場文章真的不要那麼氾濫，Google 管一下拉。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n ;</span><br><span class="line"><span class="comment">//unordered_map&lt;string,int&gt; visit ;</span></span><br><span class="line"><span class="comment">//set&lt;string&gt; visit ; // no set will be AC</span></span><br><span class="line"><span class="keyword">int</span> direct[<span class="number">4</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;&#125;; <span class="comment">//方向</span></span><br><span class="line"><span class="keyword">int</span> place[<span class="number">18</span>][<span class="number">2</span>] ; <span class="comment">//紀錄最終棋面每一個數字的 x,y 座標</span></span><br><span class="line"><span class="keyword">char</span> dname[<span class="number">4</span>] = &#123;<span class="string">'R'</span> , <span class="string">'L'</span> , <span class="string">'D'</span> , <span class="string">'U'</span>&#125;; <span class="comment">// 方向</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">state</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> graph[<span class="number">4</span>][<span class="number">4</span>] ;</span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="keyword">int</span> h=<span class="number">-1</span> , step=<span class="number">0</span> ;</span><br><span class="line">    <span class="built_in">string</span> path =<span class="string">""</span> ;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(state st) <span class="keyword">const</span>&#123; <span class="comment">//priority_queue 使用</span></span><br><span class="line">        <span class="keyword">return</span> h + step &gt; st.h + st.step ; <span class="comment">//輸出最小</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123; <span class="comment">//debug 測試用</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">4</span> ; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; <span class="number">4</span> ; j++)</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; graph[i][j] &lt;&lt; <span class="string">' '</span> ;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">h</span><span class="params">(<span class="keyword">int</span> graph[][<span class="number">4</span>])</span></span>&#123; <span class="comment">//曼哈頓距離</span></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">4</span> ; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; <span class="number">4</span> ; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(graph[i][j] == <span class="number">0</span> || (i == place[graph[i][j]][<span class="number">0</span>] &amp;&amp; \</span><br><span class="line">                                      j == place[graph[i][j]][<span class="number">1</span>]  ))</span><br><span class="line">                <span class="keyword">continue</span> ;</span><br><span class="line">            cnt += <span class="built_in">abs</span>(place[graph[i][j]][<span class="number">0</span>] - i) + <span class="built_in">abs</span>(place[graph[i][j]][<span class="number">1</span>] - j ) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt * <span class="number">10</span>  ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isboard</span><span class="params">(<span class="keyword">int</span> x , <span class="keyword">int</span> y )</span></span>&#123; <span class="comment">//判斷邊界</span></span><br><span class="line">    <span class="keyword">if</span>(x &gt;= <span class="number">0</span> &amp;&amp; x &lt; <span class="number">4</span> &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; <span class="number">4</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span> ;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isback</span><span class="params">(<span class="built_in">string</span> path , <span class="keyword">char</span> nxtD )</span></span>&#123; <span class="comment">//拒絕回到上一步的棋面</span></span><br><span class="line">    <span class="keyword">if</span>(path.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span> ; </span><br><span class="line">    <span class="keyword">char</span> D = path[path.size()<span class="number">-1</span>] ;</span><br><span class="line">    <span class="keyword">if</span>(D == <span class="string">'L'</span> &amp;&amp; nxtD == <span class="string">'R'</span> ) <span class="keyword">return</span> <span class="literal">true</span> ;</span><br><span class="line">    <span class="keyword">if</span>(D == <span class="string">'R'</span> &amp;&amp; nxtD == <span class="string">'L'</span> ) <span class="keyword">return</span> <span class="literal">true</span> ;</span><br><span class="line">    <span class="keyword">if</span>(D == <span class="string">'U'</span> &amp;&amp; nxtD == <span class="string">'D'</span> ) <span class="keyword">return</span> <span class="literal">true</span> ;</span><br><span class="line">    <span class="keyword">if</span>(D == <span class="string">'D'</span> &amp;&amp; nxtD == <span class="string">'U'</span> ) <span class="keyword">return</span> <span class="literal">true</span> ;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Astar</span><span class="params">(state input )</span></span>&#123; <span class="comment">// Astar 核心</span></span><br><span class="line">    priority_queue&lt;state&gt; q ;</span><br><span class="line">    <span class="comment">//visit.clear() ;</span></span><br><span class="line">    <span class="keyword">int</span> x , y;</span><br><span class="line">    state now , next ;</span><br><span class="line">    q.push(input);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        now = q.top() ; q.pop() ;</span><br><span class="line">        <span class="comment">//now.print();</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">4</span> ; i++)&#123; <span class="comment">//方向選擇</span></span><br><span class="line">            x = now.x + direct[i][<span class="number">0</span>] ;</span><br><span class="line">            y = now.y + direct[i][<span class="number">1</span>] ;</span><br><span class="line">            <span class="keyword">if</span>(!isboard(x,y)) <span class="keyword">continue</span> ; <span class="comment">//判斷邊界</span></span><br><span class="line">            <span class="keyword">if</span>(isback(now.path,dname[i])) <span class="keyword">continue</span> ; <span class="comment">//判斷是否回到上一步</span></span><br><span class="line">            next = now ; <span class="comment">//TLE key because this line go to 85 before.</span></span><br><span class="line">            next.step = now.step + <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">if</span>(next.step &gt; <span class="number">50</span> ) <span class="keyword">continue</span> ; <span class="comment">//判斷是否超過 50 步</span></span><br><span class="line">            swap(next.graph[x][y] , next.graph[now.x][now.y]);</span><br><span class="line">            <span class="comment">//now.print() ;</span></span><br><span class="line">            <span class="comment">//cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; y &lt;&lt; '\n' ;</span></span><br><span class="line">            <span class="comment">//next.print();</span></span><br><span class="line">            next.x = x ; next.y = y ;</span><br><span class="line">            next.h = h(next.graph) ;</span><br><span class="line">            next.path.push_back(dname[i]) ;</span><br><span class="line">            q.push(next);</span><br><span class="line">            <span class="keyword">if</span>(next.h == <span class="number">0</span> )&#123; <span class="comment">// 判斷是否已走到正確答案</span></span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; next.path &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; next.path &lt;&lt; '\n' ;</span></span><br><span class="line">            <span class="comment">//next.print();</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">issolve</span><span class="params">(<span class="keyword">int</span> graph[][<span class="number">4</span>])</span></span>&#123; <span class="comment">//此拼圖是否可以被解出</span></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span> , x , y  ;</span><br><span class="line">    <span class="keyword">int</span> num[<span class="number">16</span>] = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">4</span> ; i++)&#123; <span class="comment">//一維陣列化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; <span class="number">4</span> ; j++)&#123;</span><br><span class="line">            num[cnt++] = graph[i][j] ;</span><br><span class="line">            <span class="keyword">if</span>(graph[i][j]==<span class="number">0</span>) x = i , y = j ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cnt = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">16</span> ; i++)&#123; <span class="comment">//有多少遞減數對</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span> ; j &lt; <span class="number">16</span> ; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num[j] &amp;&amp; num[j] &lt; num[i]) cnt++ ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((cnt+x)%<span class="number">2</span> ==<span class="number">0</span>) <span class="comment">//判斷是否可解，這裡用了小優化，可看上面文章理解</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="comment">//ios::sync_with_stdio(0);</span></span><br><span class="line">    <span class="comment">//cin.tie(0);</span></span><br><span class="line">    <span class="comment">//cout.tie(0);</span></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">4</span> ; i++)&#123; <span class="comment">//紀錄正確答案位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; <span class="number">4</span> ; j++)&#123;</span><br><span class="line">            place[cnt][<span class="number">0</span>] = i ;</span><br><span class="line">            place[cnt++][<span class="number">1</span>] = j ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123; <span class="comment">//測資開始</span></span><br><span class="line">        state input ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">4</span> ; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; <span class="number">4</span> ; j++)&#123;</span><br><span class="line">                 <span class="built_in">cin</span> &gt;&gt; input.graph[i][j] ;</span><br><span class="line"></span><br><span class="line">                 <span class="keyword">if</span>(input.graph[i][j] == <span class="number">0</span>)</span><br><span class="line">                    input.x = i , input.y = j ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!issolve(input.graph) || !Astar(input))</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"This puzzle is not solvable.\n"</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="思考流程"><a href="#思考流程" class="headerlink" title="思考流程"></a>思考流程</h2><p>透過紙筆與黑板而思考而成的片段，放在網路上供我紀念XD</p>
<p>錯誤的程式碼就不放上來讓大家見笑了QQQQ。</p>
<blockquote>
<p><img src="https://i.imgur.com/UMMzOGr.jpg" alt=""><br><img src="https://i.imgur.com/6X3AmHY.jpg" alt=""><br><img src="https://i.imgur.com/Cnilh1u.jpg" alt=""><br><img src="https://i.imgur.com/raKaHeL.jpg" alt=""></p>
</blockquote>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>A*搜尋</tag>
      </tags>
  </entry>
  <entry>
    <title>演算法知識 - A* 搜尋</title>
    <url>/2021/01/07/Explain_Algorithm/Astar/</url>
    <content><![CDATA[<h2 id="A-介紹"><a href="#A-介紹" class="headerlink" title="A* 介紹"></a>A* 介紹</h2><p>A* 搜尋演算法，(A* 讀做 Astar)，在圖形平面上對對多個節點路徑求出最低成本的演算法，是將 BDS 與遍地圖(Graph Travel )的改進演算法。</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>主體還是以 BFS 為主，但多增加一個函式，啟發式搜尋(heuristic)找出最高的權重在使其進行 BFS，找出最高的權重為 \(f(x) = g(x) + h(x) \)，其中 \(g(x)\) 則是從起點走到當前節點的距離，\(h(x)\) 則是啟發式搜尋，用於猜測當前節點至終點的距離。</p>
<h3 id="啟發式搜尋-heuristic"><a href="#啟發式搜尋-heuristic" class="headerlink" title="啟發式搜尋(heuristic)"></a>啟發式搜尋(heuristic)</h3><p>在搜尋演算法中作為效率提升的一個手段，對於當前已知的資訊或結點進行評判，並對資訊進行評分，透過評分方式來使搜尋演算法找到最優的搜尋方向。</p>
<h2 id="資料來源"><a href="#資料來源" class="headerlink" title="資料來源"></a>資料來源</h2><p><a href="https://oi-wiki.org/search/astar/" target="_blank" rel="noopener">A* OIwiki</a><br><a href="https://oi-wiki.org/search/heuristic/" target="_blank" rel="noopener">启发式搜索 OIwiki</a></p>
]]></content>
      <categories>
        <category>演算法知識</category>
      </categories>
      <tags>
        <tag>程式解題</tag>
        <tag>演算法知識</tag>
        <tag>A*</tag>
      </tags>
  </entry>
  <entry>
    <title>資料庫管理 筆記 - 第七章 Databases in Applications</title>
    <url>/2021/01/13/NTUT_note/database7/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊與財金管理系大二上資料庫管理重點整理<br><font color="#dd0000">並非所有人都適用，部分對我而言稍加容易的內容並不會寫在此內。</font></p>
</blockquote>
<a id="more"></a>

<h2 id="Client-Server-Architecture-客戶端與伺服器架構"><a href="#Client-Server-Architecture-客戶端與伺服器架構" class="headerlink" title="Client/Server Architecture 客戶端與伺服器架構"></a>Client/Server Architecture 客戶端與伺服器架構</h2><ul>
<li>網路計算模型 Networked computing model</li>
<li>處理客戶端與伺服器行程(執行的程式) Processes distributed between clients and servers</li>
<li>客戶端<br>使用服務的計算機</li>
<li>伺服器<br>接受要求的計算機</li>
<li>DBMS 只有資料庫的伺服器</li>
<li>Internet 網路伺服器</li>
<li>圖解架構 <ul>
<li>上層 GUI 介面</li>
<li>中層 program , function </li>
<li>下層 DBMS activities(運作)</li>
<li>圖解<blockquote>
<p><img src="https://imgur.com/WcwVgZN.jpg" alt=""></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="應用分區-APPLICATION-PARTITIONING"><a href="#應用分區-APPLICATION-PARTITIONING" class="headerlink" title="應用分區 APPLICATION PARTITIONING"></a>應用分區 APPLICATION PARTITIONING</h3><ul>
<li>將每一分 code 放到適合的地方去運作，適合的地方有客戶端 / 伺服器</li>
<li>優點<ul>
<li>性能提升 Improved performance</li>
<li><a href="https://zh.wikipedia.org/zh-tw/%E4%BA%92%E6%93%8D%E4%BD%9C%E6%80%A7" target="_blank" rel="noopener">互操作性改善</a> Improved interoperability</li>
<li>平衡工作量 Balanced workloads</li>
</ul>
</li>
</ul>
<h3 id="Fat-and-Thin-Client"><a href="#Fat-and-Thin-Client" class="headerlink" title="Fat and Thin Client"></a>Fat and Thin Client</h3><ul>
<li>Fat<br>對於客戶端的電腦計算需求較大，DBMS 在客戶端</li>
<li>Thin<br>讓客戶端電腦只接受客戶需求，不在本地存取資料</li>
<li>圖解<blockquote>
<p><img src="https://i.imgur.com/A75n2jI.jpg" alt=""></p>
</blockquote>
</li>
</ul>
<h2 id="網路應用程式要素-WEB-APPLICATION-COMPONENTS"><a href="#網路應用程式要素-WEB-APPLICATION-COMPONENTS" class="headerlink" title="網路應用程式要素 WEB APPLICATION COMPONENTS"></a>網路應用程式要素 WEB APPLICATION COMPONENTS</h2><ul>
<li>Database server<br>需要一個 database Server，例如：Oracle, SQL Server, Informix, MS Access, MySql</li>
<li>Web server<br>接收與回應 http 要求，例如：apache</li>
<li>Application server，例如：PHP<br>透過程式碼編寫的<strong>動態網頁</strong></li>
<li>Web browser<br>客戶可以透過網頁來瀏覽，例如：chrome、IE</li>
</ul>
<h2 id="MIDDLEWARE-中介軟體-AND-APIS"><a href="#MIDDLEWARE-中介軟體-AND-APIS" class="headerlink" title="MIDDLEWARE(中介軟體) AND APIS"></a>MIDDLEWARE(中介軟體) AND APIS</h2><ul>
<li>MIDDLEWARE<br>允許應用程式去操作，而不需要用戶取理解程式碼或編寫。</li>
<li>Application Program Interface (API)<br>是一種應用程式，用來請求計算機執行程式或運算。</li>
<li>Common database APIs –ODBC, ADO .NET, JDBC</li>
</ul>
<h2 id="透過中介軟體使用-API-的-6-部曲-STEPS-FOR-USING-DATABASES-VIA-MIDDLEWARE-APIS"><a href="#透過中介軟體使用-API-的-6-部曲-STEPS-FOR-USING-DATABASES-VIA-MIDDLEWARE-APIS" class="headerlink" title="透過中介軟體使用 API 的 6 部曲  STEPS FOR USING DATABASES VIA MIDDLEWARE APIS"></a>透過中介軟體使用 API 的 6 部曲  STEPS FOR USING DATABASES VIA MIDDLEWARE APIS</h2><ul>
<li>建立或識別資料庫驅動程式</li>
<li>打開並連接資料庫</li>
<li>對資料庫執行查詢</li>
<li>處理查詢結果</li>
<li><strong>必要</strong>，反覆執行前兩點</li>
<li>關閉資料庫連接</li>
</ul>
<h2 id="Python-應用資料庫管理"><a href="#Python-應用資料庫管理" class="headerlink" title="Python 應用資料庫管理"></a>Python 應用資料庫管理</h2><ul>
<li>Model Class<br>創建數據、查詢數據</li>
<li>Serialize Class<br>轉換資料格式，如：data</li>
<li>View Class<br>讓使用者方便閱讀，如：browser</li>
</ul>
<h2 id="應用資料庫時的-3-個需要考慮因素"><a href="#應用資料庫時的-3-個需要考慮因素" class="headerlink" title="應用資料庫時的 3 個需要考慮因素"></a>應用資料庫時的 3 個需要考慮因素</h2><ul>
<li>儲存<ul>
<li>放在 DBMS 的程式碼</li>
<li>改善效能</li>
</ul>
</li>
<li>請求與呼叫資料庫 Transactions<ul>
<li>涉及許多資料庫的更新</li>
<li>有成功，才會執行成功，反之不執行</li>
</ul>
</li>
<li>資料庫連接<ul>
<li>開放連接並長期使用時會占用 database 大量資源</li>
<li>使用<a href="https://zh.wikipedia.org/wiki/%E8%BF%9E%E6%8E%A5%E6%B1%A0" target="_blank" rel="noopener">連接池</a></li>
</ul>
</li>
<li>考慮這些因素時的優點<ul>
<li>編譯 SQL code 效能提升</li>
<li>減少網路流量，而導致塞車的情況</li>
<li>提高安全性</li>
<li>加強資料完整性</li>
<li>Thinner clients</li>
<li>Scalability 可延伸性</li>
<li>Long-term cost reduction 降低長期成本</li>
<li>要求方與回應方更好進行配對 Better match of systems to business needs</li>
<li>改善客戶伺服器</li>
<li>擁有競爭優勢 Competitive advantage</li>
</ul>
</li>
<li>缺點<ul>
<li>寫程式要更多時間</li>
<li>有些演算法不可移植，需要重寫</li>
</ul>
</li>
</ul>
<h3 id="請求與呼叫完整性：ACID-TRANSACTION-INTEGRITY-ACID-RULES"><a href="#請求與呼叫完整性：ACID-TRANSACTION-INTEGRITY-ACID-RULES" class="headerlink" title="請求與呼叫完整性：ACID  TRANSACTION INTEGRITY: ACID RULES"></a>請求與呼叫完整性：ACID  TRANSACTION INTEGRITY: ACID RULES</h3><ul>
<li>Atomic<ul>
<li>請求與呼叫不可分割</li>
<li>Transaction cannot be subdivided</li>
</ul>
</li>
<li>Consistent <ul>
<li>請求前到請求後都沒有被改變</li>
<li>Constraints don’t change from before transaction to after transaction</li>
</ul>
</li>
<li>Isolated<ul>
<li>請求完成後用戶才會接收到資料</li>
<li>Database changes not revealed to users until after transaction has completed</li>
</ul>
</li>
<li>Durable<ul>
<li>資料庫的改動具有永久性</li>
<li>Database changes are permanent</li>
</ul>
</li>
</ul>
<h3 id="要求合法訪問-CONTROLLING-CONCURRENT-ACCESS"><a href="#要求合法訪問-CONTROLLING-CONCURRENT-ACCESS" class="headerlink" title="要求合法訪問 CONTROLLING CONCURRENT ACCESS"></a>要求合法訪問 CONTROLLING CONCURRENT ACCESS</h3><ul>
<li>問題<br>在多用戶不斷發送要求給伺服器時，同時訪問會造成資料庫資料不一致。(lost update problem)</li>
<li>解決方法<ul>
<li>保持資料完整性、並確保不會因為交互操作而導致資料庫資料不一致</li>
<li>Serializability 可序列化<br>變成 queue，一次一筆操作。請排隊</li>
<li>Locking Mechanisms 鎖定處理<ul>
<li>可序列化常用方法<br>The most common way of achieving serialization</li>
<li>在執行要求中，伺服器被鎖定<br>Data that is retrieved for the purpose of updating is locked for the updater</li>
<li>解鎖之前，其他用戶不可使用<br>No other user can perform update until unlocked</li>
<li>操作如下<blockquote>
<p><img src="https://i.imgur.com/q5KaIxk.jpg" alt=""></p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li>問題範例，同時操作資料庫但資料庫資料不一致<blockquote>
<p><img src="https://i.imgur.com/haCtPzf.jpg" alt=""></p>
</blockquote>
</li>
</ul>
<h4 id="LOCK-LEVEL"><a href="#LOCK-LEVEL" class="headerlink" title="LOCK LEVEL"></a>LOCK LEVEL</h4><ul>
<li>Database - used during database updates</li>
<li>Table - used for bulk updates 區塊更新</li>
<li>Block or page – very commonly used 非常常用</li>
<li>Record - only requested row; fairly commonly used 經常會用</li>
<li>Field –requires significant overhead; impractical<br>字段，需要大量效能，不切實際。</li>
</ul>
<h4 id="Types-of-locks"><a href="#Types-of-locks" class="headerlink" title="Types of locks"></a>Types of locks</h4><ul>
<li>Shared lock<ul>
<li>唯讀，只能在讀取資料時使用</li>
<li>Read but no update permitted. Used when just reading to prevent another user from placing an exclusive lock on the record</li>
</ul>
</li>
<li>Exclusive lock<ul>
<li>不可以用來閱讀，只能在更新時使用</li>
<li>No access permitted. Used when preparing to update</li>
</ul>
</li>
<li>Dead Lock<ul>
<li>兩個以上的請求佔住公用資源，並都在等待對方解鎖資源時就會發生</li>
<li>An impasse that results when two or more transactions have locked common resources, and each waits for the other to unlock their resources</li>
<li>圖解<blockquote>
<p><img src="https://imgur.com/84roCgl.jpg" alt=""></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h5 id="MANAGING-DEADLOCK"><a href="#MANAGING-DEADLOCK" class="headerlink" title="MANAGING DEADLOCK"></a>MANAGING DEADLOCK</h5><ul>
<li>Deadlock prevention 預防死鎖<ul>
<li>開始請求前，先將所有請求紀錄</li>
<li>試圖更新（上傳）的資料的會被鎖住</li>
<li>死鎖有成長期與收縮期</li>
<li>可能沒辦法去判斷需要多少資源來解決死鎖</li>
</ul>
</li>
<li>Deadlock Resolution 死鎖原因<ul>
<li>一定是因為允許死鎖的發生，<del>廢話，幹。但 PPT 真的這樣說..</del></li>
<li>打破了防止死鎖的機制</li>
<li>資源使用矩陣</li>
</ul>
</li>
</ul>
<h2 id="VERSIONING-版本化"><a href="#VERSIONING-版本化" class="headerlink" title="VERSIONING 版本化"></a>VERSIONING 版本化</h2><ul>
<li>替代鎖定</li>
<li>假設不同版本不會同時更新<br>Assumption is that simultaneous updates will be infrequent</li>
<li>每一筆請求都可以嘗試更新<br>Each transaction can attempt an update as it wishes</li>
<li>系統會建立新版本，而不是不斷替換舊版本<br>The system will create a new version of a record instead of replacing the old one</li>
<li>當請求衝突發生時，接收一個用戶的更新並通知另一用戶需要再次發送請求<br>When a conflict occurs, accept one user’s update and inform the other user that its update needs to be tried again</li>
<li>發生請求衝突時，將造成請求衝突的請求回朔到發生請求之前<br>Use of rollback and commit for this</li>
<li>圖解<br><a href="https://i.imgur.com/Wx9o930.jpg" target="_blank" rel="noopener">https://i.imgur.com/Wx9o930.jpg</a></li>
</ul>
<h2 id="DATA-SECURITY"><a href="#DATA-SECURITY" class="headerlink" title="DATA SECURITY"></a>DATA SECURITY</h2><ul>
<li>保護資料不被破壞或丟失<br>Protection of the data against accidental or intentional loss, destruction, or misuse</li>
<li>由於可以透過網路訪問而讓 DATA SECURITY 增加難度<br>Increased difficulty due to Internet access and client/server technologies</li>
</ul>
<h3 id="THREATS-TO-DATA-SECURITY-威脅資料安全"><a href="#THREATS-TO-DATA-SECURITY-威脅資料安全" class="headerlink" title="THREATS TO DATA SECURITY 威脅資料安全"></a>THREATS TO DATA SECURITY 威脅資料安全</h3><p>威脅來自許多來源，資訊系統中的多個位置都存在漏洞<br>Threats come from many sources and vulnerabilities exist in multiple places within an information system</p>
<ul>
<li>意外損失原因 Accidental losses attributable<ul>
<li>人為錯誤</li>
<li>軟體故障 Software failure</li>
<li>硬體故障 Hardware failure</li>
</ul>
</li>
<li>盜竊和詐欺 Theft and fraud</li>
<li>失去隱密或機密性 Loss of privacy or confidentiality<ul>
<li>Loss of privacy (personal data)</li>
<li>Loss of confidentiality (corporate data)公司資料</li>
</ul>
</li>
<li>失去資料完整性 Loss of data integrity </li>
<li>無法使用資料 Loss of availability (e.g., through sabotage) 例如：破壞</li>
</ul>
<blockquote>
<p><img src="https://imgur.com/CHuIq6N.jpg" alt=""></p>
</blockquote>
<h2 id="CLIENT–SERVER-APPLICATION-SECURITY"><a href="#CLIENT–SERVER-APPLICATION-SECURITY" class="headerlink" title="CLIENT–SERVER APPLICATION SECURITY"></a>CLIENT–SERVER APPLICATION SECURITY</h2><ul>
<li>Static HTML files are easy to secure(安全)<ul>
<li>Standard database access(訪問) controls</li>
<li>Place(放置) Web files in protected directories(目錄) on server</li>
</ul>
</li>
<li>Dynamic pages are harder<ul>
<li>User authentication</li>
<li>Session security</li>
<li>SSL for encryption</li>
<li>Restrict(限制) number of users and open ports</li>
<li>Remove unnecessary programs</li>
</ul>
</li>
</ul>
<h2 id="DATA-PRIVACY-隱私"><a href="#DATA-PRIVACY-隱私" class="headerlink" title="DATA PRIVACY(隱私)"></a>DATA PRIVACY(隱私)</h2><ul>
<li>W3C Web Privacy Standard<br>Platform for Privacy Protection (P3P)</li>
<li>Addresses the following 需要解決的問題<ul>
<li>Who collects data</li>
<li>What data is collected and for what purpose</li>
<li>Who is data shared with</li>
<li>Can users control access to their data 使用者可以去訪問資料</li>
<li>How are disputes resolved 如何解決紛爭</li>
<li>Policies(政策) for retaining(保留) data</li>
<li>Where are policies kept and how can they be accessed 哪裡可以查詢政策</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>北科上課筆記</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>資料庫管理</tag>
      </tags>
  </entry>
  <entry>
    <title>資料庫管理 筆記 - 第六章 Advanced SQL</title>
    <url>/2021/01/13/NTUT_note/database6/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊與財金管理系大二上資料庫管理重點整理<br><font color="#dd0000">並非所有人都適用，部分對我而言稍加容易的內容並不會寫在此內。</font></p>
</blockquote>
<a id="more"></a>

<h2 id="PROCESSING-MULTIPLE-TABLES-處理兩者以上的表"><a href="#PROCESSING-MULTIPLE-TABLES-處理兩者以上的表" class="headerlink" title="PROCESSING MULTIPLE TABLES 處理兩者以上的表"></a>PROCESSING MULTIPLE TABLES 處理兩者以上的表</h2><ul>
<li>Join<br>a relational operation that causes(原因) two or more tables with a common domain to be combined into a single table or view</li>
<li>Equi-join 類似於交集 - 有重複值<br>A join in which the joining condition(情況) is based on equality between values in the common columns; common columns appear redundantly(多餘) in the result table，也就是只要兩個表的某個值相同就會輸出，但那兩個同樣的值會被輸出兩次</li>
<li>Natural (inner) join 類似於交集<br>An equi-join(上面那點) in which one of the duplicate columns is eliminated(消除) in the result table</li>
<li>Outer join 類似於餘集<br>輸出表為值不相同的，A join in which rows that do not have matching values in common columns are nonetheless(儘管如此) included in the result table (as opposed(反對) to innerjoin, in which rows must have matching values in order to appear in the result table)</li>
<li>Union join 類似於聯集<br>Includes all data from each table that was joined</li>
<li>圖表<blockquote>
<p><img src="https://i.imgur.com/1U7KjW0.jpg" alt=""></p>
</blockquote>
</li>
<li>圖示 join 查詢<blockquote>
<p><img src="https://imgur.com/XzERFKl.jpg" alt=""></p>
</blockquote>
</li>
</ul>
<h3 id="上述-join-的-example"><a href="#上述-join-的-example" class="headerlink" title="上述 join 的 example"></a>上述 join 的 example</h3><ul>
<li>Equi-join<blockquote>
<p><img src="https://imgur.com/x1dEZK9.jpg" alt=""></p>
</blockquote>
</li>
<li>Inner Join <ul>
<li>INNER JOIN clause(子句) is an alternative(可替代) to WHERE clause, and is used to match primary(主) and foreign(外來) keys.</li>
<li>An INNER join will only return rows from each table that have matching rows in the other.</li>
<li>This query produces the same results as the previous(先前) equi-join example</li>
<li>程式碼 (圖)<blockquote>
<p><img src="https://imgur.com/H3MlEGa.jpg" alt=""></p>
</blockquote>
</li>
</ul>
</li>
<li>Nature Join <blockquote>
<p><img src="https://imgur.com/3j0Z2Iq.jpg" alt=""></p>
</blockquote>
</li>
<li>Outer Join <ul>
<li>LEFT OUTER JOIN clause causes(原因) rows from the first mentioned(提起) table (customer) to appear even if there is no corresponding order data.</li>
<li>Unlike(不像) an INNER join, this will include customer rows with no matching order rows.</li>
<li>程式碼 (圖)<blockquote>
<p><img src="https://imgur.com/BFq96ka.jpg" alt=""></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="透過命名變數讓輸出的名子改變"><a href="#透過命名變數讓輸出的名子改變" class="headerlink" title="透過命名變數讓輸出的名子改變"></a>透過命名變數讓輸出的名子改變</h2><p>What are the employee ID and name of each employee and the name of his or her supervisor(主管) (label the supervisor’s name Manager)?</p>
<blockquote>
<p><img src="https://imgur.com/C3p7gm8.jpg" alt=""></p>
</blockquote>
<h2 id="SUBQUERIES-子查詢"><a href="#SUBQUERIES-子查詢" class="headerlink" title="SUBQUERIES 子查詢"></a>SUBQUERIES 子查詢</h2><p>placing an inner query(內部查詢) (SELECT statement) inside an outer query(外部查詢)</p>
<ul>
<li>Options <ul>
<li>In a condition of the WHERE clause</li>
<li>As a “table” of the FROM clause</li>
<li>Returning a field(區塊) for the SELECT clause</li>
<li>Within the HAVING clause 在 having 子句內</li>
</ul>
</li>
<li>能夠做到的事<ul>
<li>Noncorrelated(非相關性) <ul>
<li>executed once for the entire outer query 執行一次整個外部查詢</li>
<li>Do not depend on data from the outer query 指不需要再外面寫一個 select，內部就可以寫外部查詢了 </li>
</ul>
</li>
<li>Correlated <ul>
<li>executed once for each row returned by the outer query 對每一欄執行一次外部查詢</li>
<li>Make use of data from the outer query 利用外部查詢的資料</li>
<li>Can use the EXISTS and ALL operators 可以使用EXISTS和ALL運算 </li>
<li>Example<blockquote>
<p><img src="https://imgur.com/JKUC8EC.jpg" alt=""></p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li>Example<ul>
<li><blockquote>
<p><img src="https://imgur.com/CwUaZFZ.jpg" alt=""></p>
</blockquote>
</li>
<li>另外一個方法可以解決上述問題<blockquote>
<p><img src="https://imgur.com/XsbGxFo.jpg" alt=""></p>
</blockquote>
</li>
</ul>
</li>
<li>查詢方法圖示<blockquote>
<p><img src="https://imgur.com/phHXpiU.jpg" alt=""></p>
</blockquote>
</li>
</ul>
<h3 id="ANOTHER-SUBQUERY-EXAMPLE-DERIVED-TABLE-另一種子查詢"><a href="#ANOTHER-SUBQUERY-EXAMPLE-DERIVED-TABLE-另一種子查詢" class="headerlink" title="ANOTHER SUBQUERY EXAMPLE /(DERIVED TABLE) 另一種子查詢"></a>ANOTHER SUBQUERY EXAMPLE /(DERIVED TABLE) 另一種子查詢</h3><p>將我們子查詢的值設成變數，在使他可以跟上面的查詢進行比較</p>
<blockquote>
<p><img src="https://imgur.com/ItsxXAo.jpg" alt=""></p>
</blockquote>
<h2 id="COMBINING-QUERIES"><a href="#COMBINING-QUERIES" class="headerlink" title="COMBINING QUERIES"></a>COMBINING QUERIES</h2><h3 id="UNION"><a href="#UNION" class="headerlink" title="UNION"></a>UNION</h3><p>將多個查詢 union 在一起，但所有的資料欄位與屬性都必須相同</p>
<p>Combine the output (union of multiple queries) together into a single result table<br>With UNION queries, the quantity and data types of the attributes in the SELECT clauses of both queries must be identical.</p>
<blockquote>
<p><img src="https://imgur.com/EYpaZ6w.jpg" alt=""></p>
</blockquote>
<h3 id="If-寫法，CONDITIONAL-EXPRESSIONS-USING-CASE-KEYWORD-使用大小寫關鍵字的條件表達"><a href="#If-寫法，CONDITIONAL-EXPRESSIONS-USING-CASE-KEYWORD-使用大小寫關鍵字的條件表達" class="headerlink" title="If 寫法，CONDITIONAL EXPRESSIONS USING CASE KEYWORD 使用大小寫關鍵字的條件表達"></a>If 寫法，CONDITIONAL EXPRESSIONS USING CASE KEYWORD 使用大小寫關鍵字的條件表達</h3><p>Select Case 可以做到程式中的 if-then，只需要透過此方式即可。 </p>
<p>CASE expression acts like an if-then statement. It allows you to choose what will appear in a column of the result set, depending on a condition.</p>
<p>範例如下</p>
<blockquote>
<p><img src="https://imgur.com/m6EKI08.jpg" alt=""></p>
</blockquote>
<h3 id="操作-View-關聯表-，MORE-COMPLICATED-SQL-QUERIES-更多複雜的-SQL-操作"><a href="#操作-View-關聯表-，MORE-COMPLICATED-SQL-QUERIES-更多複雜的-SQL-操作" class="headerlink" title="操作 View(關聯表)，MORE COMPLICATED SQL QUERIES 更多複雜的 SQL 操作"></a>操作 View(關聯表)，MORE COMPLICATED SQL QUERIES 更多複雜的 SQL 操作</h3><ul>
<li>資料庫可能會有好幾千個 table，而且 table 有很多 column<br>Production databases contain hundreds or even thousands of tables, and tables could include hundreds of columns.</li>
<li>因此查詢可能會變得非常複雜<br>So, sometimes query requirements can be very complex.</li>
<li>有時可以透過 View 來合併查詢<br>sometimes it’s useful to combine queries, through the use of Views.</li>
<li>如果使用 View(其中一個查詢)，也可以讓另外一個查詢使用 View，類似操作 table<br>If you use a view (which is a query), you could have another query that uses the view as if it were a table.</li>
<li>簡單來說 View 就是虛擬的 table，結合現在的 table or View 產生</li>
</ul>
<p>View 的操作範例</p>
<blockquote>
<p><img src="https://imgur.com/VB38lat.jpg" alt=""></p>
</blockquote>
<h3 id="TIPS-FOR-DEVELOPING-QUERIES"><a href="#TIPS-FOR-DEVELOPING-QUERIES" class="headerlink" title="TIPS FOR DEVELOPING QUERIES"></a>TIPS FOR DEVELOPING QUERIES</h3><ul>
<li>熟悉資料模型，實體與關聯性<br>Be familiar with the data model (entities and relationships)</li>
<li>了解想要的結果<br>Understand the desired(了解) results</li>
<li>知道結果中鎖需要的屬性<br>Know the attributes desired in results</li>
<li>辨識實體所包含的屬性<br>Identify the entities that contain desired attributes</li>
<li>Review ERD</li>
<li>對每一個 link 建構一個 where 相等性<br>Construct a WHERE equality for each link</li>
<li>如果需要，使用 GROUP BY 和 HAVING 子句<br>Fine tune with GROUP BY and HAVING clauses if needed</li>
<li>考慮異常資料對資料庫的影響<br>Consider the effect on unusual data</li>
</ul>
<h2 id="查詢效率的注意事項-QUERY-EFFICIENCY-CONSIDERATIONS"><a href="#查詢效率的注意事項-QUERY-EFFICIENCY-CONSIDERATIONS" class="headerlink" title="查詢效率的注意事項 QUERY EFFICIENCY CONSIDERATIONS"></a>查詢效率的注意事項 QUERY EFFICIENCY CONSIDERATIONS</h2><ul>
<li>在 select 中標註屬性而不用 *<br>Instead of SELECT *, identify the specific attributes in the SELECT clause; this helps reduce network traffic of result set</li>
<li>限制子查詢的數量，盡量在單查詢中查尋完畢<br>Limit the number of subqueries; try to make everything done in a single query if possible</li>
<li>如果要多次使用同樣查詢，就建立成關聯表(View)<br>If data is to be used many times, make a separate query and store it as a view</li>
</ul>
<h2 id="查詢設計方法-GUIDELINES-FOR-BETTER-QUERY-DESIGN"><a href="#查詢設計方法-GUIDELINES-FOR-BETTER-QUERY-DESIGN" class="headerlink" title="查詢設計方法 GUIDELINES FOR BETTER QUERY DESIGN"></a>查詢設計方法 GUIDELINES FOR BETTER QUERY DESIGN</h2><ul>
<li>了解再查詢資料中使用 index<br>Understand how indexes are used in query processing</li>
<li>保持優化且為最新<br>Keep optimizer statistics up to date</li>
<li>對於文字或字段兩種資料型態兼容<br>Use compatible data types for fields and literals(文字)</li>
<li>Write simple queries</li>
<li>把複雜查詢拆成簡單查詢<br>Break complex queries into multiple simple parts</li>
<li>盡量不要把查詢內嵌在另一個查詢<br>Don’t nest one query inside another query</li>
<li>自身查詢不跟自身連接<br>Don’t combine a query with itself (if possible avoid self-joins)</li>
<li>創建暫存表在擁有非常多查詢時<br>Create temporary tables for groups of queries</li>
<li>Combine update operations 合併更新操作</li>
<li>僅檢索需要的數據<br>Retrieve only the data you need</li>
<li>沒有 index 就沒辦法對 DBMS 排序<br>Don’t have the DBMS sort without an index</li>
<li>Learn! (…)</li>
<li>考慮某些特殊查詢在總查詢處理時間會不會過多<br>Consider the total query processing time for ad hoc queries</li>
</ul>
<h2 id="使用與定義關聯表-USING-AND-DEFINING-VIEWS"><a href="#使用與定義關聯表-USING-AND-DEFINING-VIEWS" class="headerlink" title="使用與定義關聯表 USING AND DEFINING VIEWS"></a>使用與定義關聯表 USING AND DEFINING VIEWS</h2><ul>
<li>Dynamic View<ul>
<li>對於用戶新增動態<strong>虛擬表</strong><br>A “virtual table” created dynamically upon request by a user</li>
<li>沒有資料儲存在 View，而是將原始資料提供給用戶<br>No data actually stored; instead data from base table made available to user</li>
<li>為 table or View 中的 SQL select 語法<br>Based on SQL SELECT statement on base tables or other views</li>
<li>Advantage 優點<ul>
<li>Simplify query commands</li>
<li>Assist(協助) with data security</li>
<li>Enhance(提高) programming productivity(生產率)</li>
<li>Contain most current base table data</li>
<li>Use little storage space</li>
<li>Provide customized(專屬打造) view for user</li>
<li>Establish(建立) physical(物理) data independence</li>
<li>每次使用 View 都需要時間<br>Use processing time each time view is referenced(被引用)</li>
<li>可能沒有辦法直接更新<br>May or may not be directly updateable</li>
<li>謹慎使用 View<br>As with all SQL constructs, you should use views with discretion</li>
</ul>
</li>
</ul>
</li>
<li>實質關聯表 Materialized View<ul>
<li>複製資料，實際儲存在 View<br>Copy or replication of data, data actually stored</li>
<li>需要不斷更新才可以與原本查詢的 table 資料相符<br>Must be refreshed periodically to match corresponding base tables</li>
</ul>
</li>
<li>Sample <ul>
<li>View has a name</li>
<li>View is based on a SELECT statement</li>
<li>CHECK_OPTIO 只能用來可以被更新的關聯表，並禁止更新不包含在 View 裡的資料<br>CHECK_OPTION works only for updateable views and prevents updates that would create rows not included in the view</li>
</ul>
</li>
</ul>
<h2 id="例行程序-ROUTINES-AND-TRIGGERS"><a href="#例行程序-ROUTINES-AND-TRIGGERS" class="headerlink" title="例行程序 ROUTINES AND TRIGGERS"></a>例行程序 ROUTINES AND TRIGGERS</h2><ul>
<li>Routines 需要執行的程式區塊</li>
<li>Functions 給 Routines 參數並回傳值</li>
<li>Procedures 給 Routines 參數並<strong>不傳</strong>值</li>
<li>Triggers 當 Routines 啟動到特殊事件時觸發</li>
<li>Procedures and functions are called explicitly(明確調用). Triggers are event-driven(事件觸發).</li>
<li>圖示<blockquote>
<p><img src="https://imgur.com/qtZevFX.jpg" alt=""></p>
</blockquote>
</li>
<li>Triggers Sample 有兩張<blockquote>
<p><img src="https://imgur.com/dnxZMF3.jpg" alt=""><br><img src="https://imgur.com/6p5occl.jpg" alt=""></p>
</blockquote>
</li>
</ul>
<h2 id="SQL-ENHANCEMENTS-增強"><a href="#SQL-ENHANCEMENTS-增強" class="headerlink" title="SQL ENHANCEMENTS(增強)"></a>SQL ENHANCEMENTS(增強)</h2><ul>
<li>User-defined data types (UDT) 自定義資料型態</li>
<li>可設定子類別為標準型態 or object<br>Subclasses of standard types or an object type</li>
<li>Analytical functions (for OLAP)<ul>
<li>CEILING, FLOOR, SQRT, RANK, DENSE_RANK, ROLLUP, CUBE, SAMPLE,</li>
<li>WINDOW –improved numerical analysis capabilities</li>
</ul>
</li>
<li>New Data Types<br>BIGINT, MULTISET (collection), XML</li>
<li>CREATE TABLE LIKE<br>create a new table similar to an existing one</li>
<li>MERGE</li>
</ul>
<h2 id="SQL-EXTENSIONS-擴展"><a href="#SQL-EXTENSIONS-擴展" class="headerlink" title="SQL EXTENSIONS(擴展)"></a>SQL EXTENSIONS(擴展)</h2><ul>
<li>Persistent(永久的) Stored Modules (SQL/PSM)</li>
<li>Capability(能力) to create and drop(刪除) code modules</li>
<li>New statements: CASE, IF, LOOP, FOR, WHILE, etc.</li>
<li>Makes SQL into a <a href="https://zh.wikipedia.org/wiki/%E8%BF%87%E7%A8%8B%E5%BC%8F%E7%BC%96%E7%A8%8B" target="_blank" rel="noopener">procedural language(可以變成函式相互呼叫)</a></li>
<li>Oracle has propriety version(專有版本) called PL/SQL, and Microsoft SQL Server has Transact/SQL</li>
</ul>
]]></content>
      <categories>
        <category>北科上課筆記</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>資料庫管理</tag>
      </tags>
  </entry>
  <entry>
    <title>b944- 好想上廁所(男廁篇)</title>
    <url>/2021/01/21/zerojudge/b944/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>男生要上廁所，通常會相隔一個小便斗，如果沒有，就從數字最小的廁所開始找第一間空間上廁所，沒有辦法上廁所就輸出 “  Not enough” </p>
<p>輸出<br><a href="https://zerojudge.tw/ShowProblem?problemid=b944" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="觀念重點"><a href="#觀念重點" class="headerlink" title="觀念重點"></a>觀念重點</h2><ul>
<li>兩種規則<ul>
<li>先嘗試能否在相隔的情況下上廁所</li>
<li>從最小的廁所開始上，找到空格</li>
</ul>
</li>
<li>有可能進去上廁所，但是時間是零秒，但在這次還是要照常輸出</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>簡單的操作題，根據題目進行分析輸出，在每一個程式碼中放入簡單註解，希望大家可以看懂XD。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">b944</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		<span class="keyword">int</span> n , a , b ;</span><br><span class="line">		n = input.nextInt() ;</span><br><span class="line">		<span class="keyword">int</span> num[] = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">2</span>]; <span class="comment">//使用的編號 </span></span><br><span class="line">		<span class="keyword">int</span> time[] = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">2</span>]; <span class="comment">//剩下使用的時間</span></span><br><span class="line">		<span class="keyword">while</span>(input.hasNext()) &#123;</span><br><span class="line">			a = input.nextInt(); </span><br><span class="line">			b = input.nextInt();</span><br><span class="line">			<span class="keyword">int</span> flag = <span class="number">1</span> ; <span class="comment">//判斷這次有沒有成功找到廁所</span></span><br><span class="line">            <span class="comment">// 1 是還沒找到廁所， 0 是找到了</span></span><br><span class="line">			</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; i++) &#123; <span class="comment">//將上次的狀態進行更新</span></span><br><span class="line">				<span class="keyword">if</span>(num[i] != <span class="number">0</span>) &#123; <span class="comment">//表示有人正在使用</span></span><br><span class="line">					time[i] -=<span class="number">1</span> ; <span class="comment">//時間減一 </span></span><br><span class="line">					<span class="keyword">if</span>(time[i] &lt; <span class="number">0</span> ) time[i] = <span class="number">0</span> ; </span><br><span class="line">                    <span class="comment">//如果剛剛上廁所的人是零秒，在剛剛會被 -1 秒，因此現在歸零</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span>(time[i] &lt;= <span class="number">0</span> ) num[i] = <span class="number">0</span> ; <span class="comment">// 0 秒表示上完廁所，使用號碼歸零</span></span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; i++) &#123; <span class="comment">//第一個規則</span></span><br><span class="line">				<span class="keyword">if</span>(num[i]==<span class="number">0</span> &amp;&amp; num[i-<span class="number">1</span>]==<span class="number">0</span> &amp;&amp; num[i+<span class="number">1</span>]==<span class="number">0</span>) &#123; </span><br><span class="line">                    <span class="comment">//看當前間、左邊、右邊使否為空間</span></span><br><span class="line">					num[i] = a ; <span class="comment">//這間廁所被 a  使用  </span></span><br><span class="line">					time[i] = b ; <span class="comment">// 使用 b 秒</span></span><br><span class="line">					flag = <span class="number">0</span> ; <span class="comment">//成功找到廁所</span></span><br><span class="line">					<span class="keyword">break</span> ;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(flag==<span class="number">1</span>) &#123; <span class="comment">//還沒找到廁所，就用第二種規則</span></span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; i++) &#123;</span><br><span class="line">					<span class="keyword">if</span>(num[i] == <span class="number">0</span>) &#123; <span class="comment">//這間廁所沒有被使用，那就讓她使用</span></span><br><span class="line">						num[i] = a ; </span><br><span class="line">						time[i] = b ;</span><br><span class="line">						flag = <span class="number">0</span> ; <span class="comment">//成功找到廁所</span></span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span>(flag == <span class="number">1</span> ) <span class="comment">//表示還沒找到廁所，所以輸出 not enough </span></span><br><span class="line">				System.out.print(<span class="string">"  Not enough\n"</span>);</span><br><span class="line">			</span><br><span class="line">			System.out.print(<span class="string">"Number:"</span>); <span class="comment">//輸出廁所使用的編號</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; i++) &#123;</span><br><span class="line">				System.out.printf(<span class="string">" %d"</span> , num[i]);</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.printf(<span class="string">"\n"</span>);</span><br><span class="line">			</span><br><span class="line">			System.out.print(<span class="string">"Time:"</span>); <span class="comment">//輸出每個廁所的使用時間</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; i++) &#123;</span><br><span class="line">				System.out.printf(<span class="string">" %d"</span> , time[i]);</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.printf(<span class="string">"\n"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>久違的寫 zerojudge 程式題目，zerojudge 是刷簡單題的好區，可以快速累積新手經驗值，可以讓自己程式變優秀的好地方(◍•ᴗ•◍)❤️。</p>
<p>題外話：UVa 好難喔..，一個啟發式搜尋要讓我使用 range tree，我真的會哭喔 ಥ⌣ಥ。</p>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>程式解題</tag>
        <tag>實作題</tag>
        <tag>zerojudge</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa12863 - Journey through the kingdom(A*搜尋 、2D BIT)</title>
    <url>/2021/01/24/UVa/UVa12863/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>ICPC 是一家保全公司，負責將重要的資料從 A 地搬運到 B 地，此地圖是個表格，我們會告訴你每一個點 (i,j)，能夠到的最大的距離與成本，接下來請寫一個程式告訴我們從 A 地到 B 地的最小成本。</p>
<p>提供 3 個 n*m 的陣列，第一個是成本陣列、第二個是每一個節點最大可以走幾個 Row、第三個則是每一個節點最多可以走 Column。</p>
<p>此題為嚴格輸出比對，需要完全的嚴謹。<br><a href="">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li>最短路徑用法 (dijkstra)</li>
<li>RangeTree<ul>
<li>選擇要用哪個比較好，BIT or Segment Tree? 這裡要使用 BIT</li>
</ul>
</li>
<li>判斷時間複雜度與了解 Range Tree 每一種資料結構的時間複雜度</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>好題，好題，這題好題，讓我學到了很多知識，也謝謝 morris 大大讓我在學習知識的路上成長了許多。</p>
<p>首先根據題目要求我們可以明顯知道這題一定是使用 Dijkstra，那現在我們接下來就會遇到一些問題</p>
<h3 id="QUESTION-A-如何判斷-dijkstra-的權重呢"><a href="#QUESTION-A-如何判斷-dijkstra-的權重呢" class="headerlink" title="QUESTION A: 如何判斷 dijkstra 的權重呢"></a>QUESTION A: 如何判斷 dijkstra 的權重呢</h3><p>由於題目要求成本必須最小，因此我們一定要設定一個 struct，並且寫一個 operator 讓成本最小的優先讓 queue top，假如成本都一樣時，我們就比較<a href="https://theriseofdavid.github.io/2021/01/09/UVa/UVa10181/#曼哈頓距離" target="_blank" rel="noopener">曼哈頓距離</a>誰比較接近終點的優先 top。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Node &amp;a) <span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(v != a.v) <span class="comment">//成本</span></span><br><span class="line">        <span class="keyword">return</span> a.v &lt; v ;</span><br><span class="line">    <span class="keyword">return</span> a.h &lt; h ; <span class="comment">//曼哈頓距離</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="QUESTION-B-要如何知道當前節點能走到那些節點呢？"><a href="#QUESTION-B-要如何知道當前節點能走到那些節點呢？" class="headerlink" title="QUESTION B: 要如何知道當前節點能走到那些節點呢？"></a>QUESTION B: 要如何知道當前節點能走到那些節點呢？</h3><p>由於每個節點都有可以走訪的最大長度 C(column) or R(row)，因此我們只要判斷\(當前節點 \pm 最大長度 \)，並不讓它超出邊界即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">lr = max(<span class="number">1</span>, u.r-R[u.r][u.c]); rr = min(n, u.r+R[u.r][u.c]);</span><br><span class="line"><span class="comment">//lr = 左邊界 rr = 右邊界</span></span><br><span class="line">lc = max(<span class="number">1</span>, u.c-C[u.r][u.c]); rc = min(m, u.c+C[u.r][u.c]);</span><br><span class="line"><span class="comment">// lc = 上邊界 rc = 下邊界</span></span><br></pre></td></tr></table></figure>

<h3 id="QUESTION-C-要如何知道節點有沒有被走訪過呢？"><a href="#QUESTION-C-要如何知道節點有沒有被走訪過呢？" class="headerlink" title="QUESTION C: 要如何知道節點有沒有被走訪過呢？"></a>QUESTION C: 要如何知道節點有沒有被走訪過呢？</h3><p>由於這題的邊都是單向邊，然而我們的目標則是要找出所有未走訪的點加入 queue，我們每次要查找有哪些點沒有被走訪時，可以有這幾種方法</p>
<ul>
<li>for 雙重迴圈查找<br>由於每次的時間複雜度都是 \(n^2\)，不理想，因此我們不使用</li>
<li>2D Binary Index Tree<br>由於 Binary Index Tree 查詢時間複雜度是 \(O(\log{N})\)，單點修改也是\(O(\log{N})\)，在對於會有大量節點進入 queue 中的 dijkstra 中是一個好選擇</li>
<li>2D Segment Tree<br>Segment Tree 與 Binary Index Tree 大致相同，Segment Tree 比 Binary Index Tree 用途更廣泛一些，但 Binary Index Tree 實現過程中較為好寫 ，但因為這裡的矩陣長度一致性極高，不會有區間不相同的問題且區間相同都是 1，因此這裡我們使用 Binary Index Tree。</li>
</ul>
<p><a href="https://stackoverflow.com/questions/17466218/what-are-the-differences-between-segment-trees-interval-trees-binary-indexed-t" target="_blank" rel="noopener">What are the differences between segment trees, interval trees, binary indexed trees and range trees? - stackoverflow</a></p>
<p>對於 Binary Index Tree or Segment Tree 我還沒寫出詳解，以後如果有寫會補上。</p>
<h3 id="2D-Binary-Index-Tree-建立、修改、查詢方法"><a href="#2D-Binary-Index-Tree-建立、修改、查詢方法" class="headerlink" title="2D Binary Index Tree 建立、修改、查詢方法"></a>2D Binary Index Tree 建立、修改、查詢方法</h3><h4 id="建立-init"><a href="#建立-init" class="headerlink" title="建立 init"></a>建立 init</h4><p>在 2D Binary Index Tree 中不會像 1D Binary Index Tree 建立方式完全相同，大致上相同，且每個點都需要新增(modify)初始值。</p>
<p>值得注意的是 2D Binary Index Tree，的最大長度在這題我們會設定不可以大於 Row or Column 的最大數量，因為我們可以透過 2D Binary Index Tree 相減的方式來找出當前節點應該要有的值為何</p>
<p>舉例：我們想要查找 4 的值，那就只需要讓 4 這個節點減掉 2 與 3 這兩個節點就可以知道 4 原本的值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> A[MAXN][MAXN] ;</span><br><span class="line"><span class="keyword">int</span> R , C ;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> _R, <span class="keyword">int</span> _C)</span></span>&#123;</span><br><span class="line">    R = _R ;</span><br><span class="line">    C = _C ;</span><br><span class="line">    <span class="built_in">memset</span>(A,<span class="number">0</span>,<span class="keyword">sizeof</span>(A));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= R ; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= C ; j++)</span><br><span class="line">            modify(i, j, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="modify-修改"><a href="#modify-修改" class="headerlink" title="modify 修改"></a>modify 修改</h4><p>2D Binary Index Tree，使用雙重迴圈，由於是二維的因此 x,y 座標都必須使用 lowbit 且 y 軸必須因為 x 軸的變化而變回 1。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(; x &lt;= R ; x += lowbit(x))&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = y ; i &lt;= C ; i += lowbit(i))</span><br><span class="line">            A[x][i] += val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="query-查詢"><a href="#query-查詢" class="headerlink" title="query 查詢"></a>query 查詢</h4><p>這是與 1D Binary Index Tree，最不同的地方，因為 2D Binary Index Tree 如果只對一個區間查詢如 \((x_1,y_1)\) ~ \((x_2,y_2)\)，如果只對 \((x_2,y_2)\) 進行像 1D Binary Index Tree 查詢就會使查找範圍變為 \((1,1)\) ~ \((x_2,y_2)\)，這裡的 index 從 1 開始，透過圖片來示意即是：</p>
<p><a href="https://iq.opengenus.org/2d-fenwick-tree/" target="_blank" rel="noopener">2D Fenwick Tree / 2D Binary Indexed Tree</a></p>
<blockquote>
<p><img src="https://i.imgur.com/nHz5TUm.png" alt=""></p>
</blockquote>
<p>相信讀者已經大概了解我在說甚麼，為了讓我們的查找範圍可以順利查找成功，因此我們要減去\((x_2,y_1)\) ~ \((0,0)\) 與 \((x_1,y_2)\) ~ \((0,0)\) 再加上 \((x_1,y_1)\) 的範圍來補回我們之前多減的區塊。</p>
<p>可能會有些讀者想問，那我能不能夠一口氣查詢 \((x_1,y_1)\) ~ \((x_2,y_2)\) 的範圍呢？答案是不行的，因為我們在修改值的時候會讓 1 的節點值加給 2 號節點，再讓 2 號節點加給 3 號節點(lowbit) 的效果，因此我們沒有辦法一口氣就查詢完畢。</p>
<p>必須先寫一個 sub query 來讓對每塊長方形進行查詢，在進行加減法來達到我們想查詢的範圍</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123; <span class="comment">//子查詢 sub query</span></span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span>(; x &gt; <span class="number">0</span> ; x -= lowbit(x))&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = y ; i&gt;<span class="number">0</span> ; i -= lowbit(i))</span><br><span class="line">            cnt += A[x][i] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rectCnt</span><span class="params">(<span class="keyword">int</span> lx, <span class="keyword">int</span> ly, <span class="keyword">int</span> rx, <span class="keyword">int</span> ry)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> query(rx,ry) - query(lx<span class="number">-1</span>,ry) - query(rx, ly<span class="number">-1</span>) + query(lx<span class="number">-1</span>, ly<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="QUESTION-D-嚴格比對怎麼寫比較好呢？"><a href="#QUESTION-D-嚴格比對怎麼寫比較好呢？" class="headerlink" title="QUESTION D: 嚴格比對怎麼寫比較好呢？"></a>QUESTION D: 嚴格比對怎麼寫比較好呢？</h3><p>由於是嚴格比對，因此我們輸出要特別小心，要<strong>完全一樣</strong>，但比較能夠放心的是我們可以用簡單的寫法去實現即可，也就是當我們讀到最後一筆時再輸出 <code>\n</code>，其他都輸出 space 即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++)&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; findPath(r, c, P[i<span class="number">-1</span>][<span class="number">0</span>], P[i<span class="number">-1</span>][<span class="number">1</span>], P[i][<span class="number">0</span>], P[i][<span class="number">1</span>]) ;</span><br><span class="line">    <span class="keyword">if</span>(i==n<span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="QUESTION-E-priority-queue-有沒有清空函式呢"><a href="#QUESTION-E-priority-queue-有沒有清空函式呢" class="headerlink" title="QUESTION E: priority_queue 有沒有清空函式呢"></a>QUESTION E: priority_queue 有沒有清空函式呢</h3><p>答案是沒有，因此手寫一個迴圈不斷 pop 到 queue 被清空即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(!q.empty()) q.pop(); <span class="comment">//由於 queue 沒有清空，因此寫個清空</span></span><br></pre></td></tr></table></figure>

<h2 id="參考來源"><a href="#參考來源" class="headerlink" title="參考來源"></a>參考來源</h2><ul>
<li><a href="http://morris821028.github.io/2014/11/22/uva-12863/" target="_blank" rel="noopener">UVa 12863 - Journey through the kingdom - Morris’ Blog </a></li>
<li><a href="https://iq.opengenus.org/2d-fenwick-tree/" target="_blank" rel="noopener">OpenGenus IQ: Learn Computer Science - 2D Fenwick Tree / 2D Binary Indexed Tree</a></li>
<li><a href="https://stackoverflow.com/questions/17466218/what-are-the-differences-between-segment-trees-interval-trees-binary-indexed-t" target="_blank" rel="noopener">What are the differences between segment trees, interval trees, binary indexed trees and range trees? - stackoverflow</a></li>
</ul>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>這題學到蠻多東西的，也讓我把整個程式碼的排版稍微再重新整理一些，最近學到要讓自己的程式碼風格與大家相同才會讓他人在看我的程式碼時不會感到厭煩，會開心一些。</p>
<p>也謝謝我在學習演算法時網路上提供資源的大神們，讓我在學習的路上可以更輕鬆，有資源讓我進行成長，沒有他們我不知道這題我還要學習多久。</p>
<p>題外話：最近發現寫網頁前端不需要訓練太久，薪水也蠻不錯的就讓我覺得學演算法似乎沒什麼太大幫忙QQ，希望未來可以打翻這個認知，不然會讓我很難過啊，嗚嗚。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 512</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) x&amp;(-x)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> V[MAXN][MAXN], R[MAXN][MAXN], C[MAXN][MAXN], P[MAXN][<span class="number">2</span>] ;</span><br><span class="line"><span class="comment">//V 是成本 R 是可擴長的 row , C 是可擴展的 column , P 是要查詢從某地到某地的紀錄</span></span><br><span class="line"><span class="keyword">int</span> TX , TY ; <span class="comment">// 終點 x 終點 y</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span> <span class="comment">//dijkstra 用到的節點</span></span><br><span class="line">    <span class="keyword">int</span> r, c, v, h; <span class="comment">// r=x , c=y , h 等於漢明距離 , v 是成本</span></span><br><span class="line">    Node(<span class="keyword">int</span> _r=<span class="number">0</span>,<span class="keyword">int</span> _c=<span class="number">0</span>, <span class="keyword">int</span> _v=<span class="number">0</span>, <span class="keyword">int</span> _h=<span class="number">0</span>):  <span class="comment">//輸入值可以有這種寫法</span></span><br><span class="line">        r(_r), c(_c), h(_h), v(_v) &#123;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Node &amp;a) <span class="keyword">const</span>&#123; <span class="comment">//看大衛的筆記 , UVa 10181 </span></span><br><span class="line">        <span class="keyword">if</span>(v != a.v)</span><br><span class="line">            <span class="keyword">return</span> a.v &lt; v ; <span class="comment">//最小</span></span><br><span class="line">        <span class="keyword">return</span> a.h &lt; h ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;Node&gt; q ; <span class="comment">// dijkstra</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BIT</span>&#123;</span> <span class="comment">// 2D binary indexed tree，狀態樹 注意，這裡是二維</span></span><br><span class="line">    <span class="keyword">int</span> A[MAXN][MAXN] ; <span class="comment">// 走過的點 1 為還沒走過</span></span><br><span class="line">    <span class="keyword">int</span> R , C ;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> _R, <span class="keyword">int</span> _C)</span></span>&#123;</span><br><span class="line">        R = _R ;</span><br><span class="line">        C = _C ;</span><br><span class="line">        <span class="built_in">memset</span>(A,<span class="number">0</span>,<span class="keyword">sizeof</span>(A));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= R ; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= C ; j++)</span><br><span class="line">                modify(i, j, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> val)</span></span>&#123; <span class="comment">//修改值</span></span><br><span class="line">        <span class="keyword">for</span>(; x &lt;= R ; x += lowbit(x))&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = y ; i &lt;= C ; i += lowbit(i))</span><br><span class="line">                A[x][i] += val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123; <span class="comment">//sub query</span></span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span>(; x &gt; <span class="number">0</span> ; x -= lowbit(x))&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = y ; i&gt;<span class="number">0</span> ; i -= lowbit(i))</span><br><span class="line">                cnt += A[x][i] ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rectCnt</span><span class="params">(<span class="keyword">int</span> lx, <span class="keyword">int</span> ly, <span class="keyword">int</span> rx, <span class="keyword">int</span> ry)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> query(rx,ry) - query(lx<span class="number">-1</span>,ry) - query(rx, ly<span class="number">-1</span>) + query(lx<span class="number">-1</span>, ly<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> lx, <span class="keyword">int</span> ly, <span class="keyword">int</span> rx, <span class="keyword">int</span> ry, <span class="keyword">int</span> val, <span class="keyword">int</span> tot)</span></span>&#123;</span><br><span class="line">        <span class="comment">//lr = 左邊界 rr = 右邊界</span></span><br><span class="line">        <span class="comment">//lc = 上邊界 rc = 下邊界</span></span><br><span class="line">        <span class="comment">// val 成本 tot 當前還有多少節點</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(tot == <span class="number">-1</span>) <span class="comment">//表示還未查詢過，現在進行查詢</span></span><br><span class="line">            tot = rectCnt(lx,ly,rx,ry); </span><br><span class="line">        <span class="keyword">if</span>(tot == <span class="number">0</span>) <span class="keyword">return</span> ; <span class="comment">//已經沒有節點，表示都有走訪過</span></span><br><span class="line">        <span class="keyword">if</span>(lx == rx)&#123; <span class="comment">//先透過 x 進行二分查詢，如果一樣在對 y 進行二分查詢</span></span><br><span class="line">            <span class="keyword">if</span>(ly == ry)&#123; <span class="comment">//已經抵達未走訪的節點</span></span><br><span class="line">                q.push(Node(lx, ly, val+V[lx][ly], <span class="built_in">abs</span>(lx-TX)+<span class="built_in">abs</span>(ly-TY))); <span class="comment">//增加節點</span></span><br><span class="line">                modify(lx, ly, <span class="number">-1</span>);</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> cnt = rectCnt(lx, ly, rx, (ly+ry)/<span class="number">2</span>); <span class="comment">//查找二分後的節點，cnt 表示左邊</span></span><br><span class="line">            <span class="keyword">if</span>(cnt) <span class="comment">//如果左邊還有節點表示還沒有走訪</span></span><br><span class="line">                update(lx, ly, rx, (ly+ry)/<span class="number">2</span>, val, cnt);</span><br><span class="line">            <span class="keyword">if</span>(cnt &lt; tot)  <span class="comment">//表示右半部還有節點還沒有走訪</span></span><br><span class="line">                update(lx, (ly+ry)/<span class="number">2</span> + <span class="number">1</span>, rx, ry, val, tot - cnt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> cnt = rectCnt(lx, ly, (lx+rx)/<span class="number">2</span>, ry);  <span class="comment">//查找二分後的節點，cnt 表示左邊</span></span><br><span class="line">            <span class="keyword">if</span>(cnt) <span class="comment">//如果左邊還有節點表示還沒有走訪</span></span><br><span class="line">                update(lx, ly, (lx+rx)/<span class="number">2</span>, ry, val, cnt);</span><br><span class="line">            <span class="keyword">if</span>(cnt &lt; tot) <span class="comment">//表示右半部還有節點還沒有走訪</span></span><br><span class="line">                update((lx+rx)/<span class="number">2</span> + <span class="number">1</span>, ly, rx, ry, val, tot - cnt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;bit;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findPath</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="keyword">int</span> sx, <span class="keyword">int</span> sy, <span class="keyword">int</span> ex, <span class="keyword">int</span> ey)</span></span>&#123; <span class="comment">//dijkstra 主題核心</span></span><br><span class="line">    <span class="keyword">if</span>(sx == ex &amp;&amp; sy == ey ) <span class="keyword">return</span> <span class="number">0</span> ; <span class="comment">//當前位置就是終點位置</span></span><br><span class="line">    TX = ex ; TY = ey ; <span class="comment">//設定值</span></span><br><span class="line">    bit.init(n, m); <span class="comment">//建立圖</span></span><br><span class="line">    bit.modify(sx, sy, <span class="number">-1</span>); <span class="comment">//將起點可以走訪到的點都設為 -1</span></span><br><span class="line">    <span class="comment">//clear</span></span><br><span class="line">    <span class="keyword">while</span>(!q.empty()) q.pop(); <span class="comment">//由於 queue 沒有清空，因此寫個清空</span></span><br><span class="line">    q.push(Node(sx, sy, V[sx][sy], <span class="built_in">abs</span>(sx-TX)+<span class="built_in">abs</span>(sy-TY))); <span class="comment">//放入初始節點</span></span><br><span class="line"></span><br><span class="line">    Node u;</span><br><span class="line">    <span class="keyword">int</span> lr, rr, lc, rc;</span><br><span class="line">    <span class="comment">//lr = 左邊界 rr = 右邊界</span></span><br><span class="line">    <span class="comment">//lc = 上邊界 rc = 下邊界</span></span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123; <span class="comment">//如果節點還沒有被走訪完就繼續 dijkstra</span></span><br><span class="line">        u = q.top(); q.pop(); </span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(u.r - ex) &lt;= R[u.r][u.c] &amp;&amp; <span class="built_in">abs</span>(u.c - ey) &lt;= C[u.r][u.c])</span><br><span class="line">        <span class="comment">//當前節點已經可以碰到終點節點了，因此就輸出成本即可。</span></span><br><span class="line">            <span class="keyword">return</span> u.v;</span><br><span class="line"></span><br><span class="line">        lr = max(<span class="number">1</span>, u.r-R[u.r][u.c]); rr = min(n, u.r+R[u.r][u.c]);</span><br><span class="line">        lc = max(<span class="number">1</span>, u.c-C[u.r][u.c]); rc = min(m, u.c+C[u.r][u.c]);</span><br><span class="line">        <span class="comment">//確認當前節點可以到的最大範圍</span></span><br><span class="line">        bit.update(lr, lc, rr, rc, u.v, <span class="number">-1</span>); <span class="comment">//進行更新，將這些裡面的節點都標示為走訪過</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//如果無法抵達，那就輸出 -1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span> , <span class="string">"r"</span> , <span class="built_in">stdin</span> );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">int</span> r, c, n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; r &gt;&gt; c &gt;&gt; n)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=r; i++)&#123; <span class="comment">//輸入成本陣列</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=c ;j++)</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; V[i][j] ; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=r; i++)&#123; <span class="comment">//輸入最大 Row陣列</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=c ;j++)</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; R[i][j] ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=r; i++)&#123; <span class="comment">//輸入最大 Column 陣列</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=c ;j++)</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; C[i][j] ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) <span class="comment">//紀錄所有的目的地</span></span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; P[i][<span class="number">0</span>] &gt;&gt; P[i][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++)&#123; </span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; findPath(r, c, P[i<span class="number">-1</span>][<span class="number">0</span>], P[i<span class="number">-1</span>][<span class="number">1</span>], P[i][<span class="number">0</span>], P[i][<span class="number">1</span>]) ;</span><br><span class="line">            <span class="keyword">if</span>(i==n<span class="number">-1</span>) <span class="comment">//嚴格比對，因此這樣寫</span></span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="思考流程"><a href="#思考流程" class="headerlink" title="思考流程"></a>思考流程</h2><p>透過紙筆與黑板而思考而成的片段，放在網路上供我紀念XD</p>
<blockquote>
<p><img src="https://i.imgur.com/SW9JQzx.jpg" alt=""></p>
</blockquote>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>A*搜尋</tag>
        <tag>2D Fenwick Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces 1474C - Array Destruction (設計解題、數學推理)</title>
    <url>/2021/01/28/Codeforces/Codeforces%201474C/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>有一個陣列，裡面只有正整數，要進行以下操作：</p>
<ul>
<li>一開始先選出某一數字為 \(x\)</li>
<li>移除陣列中的兩個元素，定義 \(a,b\)，移除時必須符合此公式 \(a+b=x\)</li>
<li>之後必須將 \(max(a,b) = x \)，讓 a or b 中的最大值成為 x</li>
</ul>
<p>如果可以透過規則讓陣列元素全部被清空就輸出 “Yes”，否則就輸出 “NO”</p>
<p>舉例： \(a = [3,5,1,2] \)，那清空的操作如下</p>
<ul>
<li>\(x=6=5+1\)</li>
<li>\(x=5=2+3\)</li>
</ul>
<p><a href="https://codeforces.com/contest/1474/problem/C" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li>對於數字的邏輯推理</li>
<li>快速找出題目的重點與其作答方向</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>好題，這種給你一種遊戲方式來讓你去解出來的，我稱之為「設計解題」，這種題目由於沒辦法先前準備，因此很吃反應能力跟思考速度，一個不小心可能就亂掉了QQ。</p>
<h3 id="QUESTION-A-如果找出-x-？"><a href="#QUESTION-A-如果找出-x-？" class="headerlink" title="QUESTION A: 如果找出 \(x\)？"></a>QUESTION A: 如果找出 \(x\)？</h3><p>首先，\(x\) 值一定要是比陣列中所有元素更大，且要讓陣列元素中的某兩個值相加 \(a,b\)。<br>再來，\(x\) 值會變成\(a,b\)中取最大的值做為下一次的 \(x\)。</p>
<p>因此我們可以知道，<strong>\(x\) 一定會遞減</strong>。</p>
<h3 id="QUESTION-B-那-x-值一開始會是多少呢？有辦法推出來嘛？"><a href="#QUESTION-B-那-x-值一開始會是多少呢？有辦法推出來嘛？" class="headerlink" title="QUESTION B: 那 \(x\) 值一開始會是多少呢？有辦法推出來嘛？"></a>QUESTION B: 那 \(x\) 值一開始會是多少呢？有辦法推出來嘛？</h3><p>沒有辦法。<br>因為我們不確定哪兩個元素為 \(x\) 之後，就可以讓後面不斷運行的操作都可以成立，每次都可以順利讓 \(a+b=x\)。</p>
<p>因此，在這種情況下只剩下暴力嘗試去找出其一開始的 \(x\) 值，讓元素中最大的數字去加上元素中其中另一元素當作 x，不斷反覆去嘗試配對，直到可以將所有數字用完就是正解。</p>
<p>至於為甚麼是先讓元素中最大的數字去配陣列中其他元素？<br>我們可以舉個例子：   \(a = [3,5,1,2] \)</p>
<ul>
<li>一開始我們使用 \(a+b=x\) 等同於 \(3+1=4\)，這樣就<strong>不是</strong>讓元素中最大的數字去配陣列中其他元素</li>
<li>再來我們必須使用 3 來讓成為下次的 \(x\)，此時我們可以發現 5 這個元素再也沒有辦法被移除，因為 x 已經小於 5 了，因此這種配對方式一定會失敗。</li>
<li>這點我們有在 QUESTION A 討論過，這裡透過舉例讓讀者更加清晰。</li>
</ul>
<h2 id="參考來源"><a href="#參考來源" class="headerlink" title="參考來源"></a>參考來源</h2><p><a href="https://codeforces.com/blog/entry/86933" target="_blank" rel="noopener">Codeforces Round #696 Editorial</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>原本我在寫這題時一直卡關，想不出來怎麼解…，數字推理與反應速度慢的不可思議啊QQQQ，之後透過不斷的寫演算法題目來讓我的思考能力變快、更迅速，一定可以幫忙到生活上的所有事物，可能我會不清楚在哪裡用到，但現在的我認為這一定是會讓自己變更聰明的學習！</p>
<p>雖然學的過程中真的蠻痛苦的…，希望我可以多努力加油。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1000020</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> t, n, x, num[MAXN], a[MAXN];  </span><br><span class="line"><span class="comment">// a 為題目給的元素陣列 </span></span><br><span class="line"><span class="comment">//num 為那個數字有幾個，舉例： num[2]=1 a陣列中有 2 這個數值並且有一個</span></span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt; record; <span class="comment">//紀錄要輸出的 pair</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    sort(a,a+<span class="number">2</span>*n); <span class="comment">//先進行排序，方便找出陣列中最大的數值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>*n<span class="number">-1</span>; i++)&#123; <span class="comment">//陣列中最大的數值與某一數值合併</span></span><br><span class="line">        record.clear(); <span class="comment">//清空紀錄</span></span><br><span class="line">        <span class="built_in">memset</span>(num, <span class="number">0</span>, <span class="keyword">sizeof</span>(num)); <span class="comment">//先將 num 清空</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">2</span>*n<span class="number">-1</span>; j++) <span class="comment">//讓 num 的資料與 a 同步</span></span><br><span class="line">            num[a[j]]++;</span><br><span class="line">        x = a[i] + a[<span class="number">2</span>*n<span class="number">-1</span>]; <span class="comment">//最一開始的 x</span></span><br><span class="line">        <span class="comment">//cout &lt;&lt; "x is " &lt;&lt; x &lt;&lt; '\n';</span></span><br><span class="line">        <span class="keyword">int</span> cnt = n; <span class="comment">//需要組成幾個 pair，如果都可以成功組出表示沒問題</span></span><br><span class="line">        <span class="keyword">while</span>(cnt)&#123; <span class="comment">//這裡的判斷是剩下幾個 pair</span></span><br><span class="line">            <span class="keyword">int</span> pos = <span class="number">2</span>*n<span class="number">-1</span>; <span class="comment">//從最大開始找， 2*n-1 為初始陣列中最長的位置</span></span><br><span class="line">            <span class="keyword">while</span>(pos &gt; <span class="number">0</span> &amp;&amp; num[a[pos]] == <span class="number">0</span>) </span><br><span class="line">            <span class="comment">//從後面開始算，如果後面那些值被用過就往前算，用來找出當前最大的 x</span></span><br><span class="line">                pos--;</span><br><span class="line">            num[a[pos]]--; num[x-a[pos]]--; <span class="comment">//更新 num 值狀態，那兩個值透過規則被提出</span></span><br><span class="line">            <span class="comment">//x=a+b，當 a,x 值固定 則 b(x-a[pos]) 值一定是固定</span></span><br><span class="line">            <span class="comment">// 注意，這裡的 a 不是陣列 a，是我們定義的數值 a</span></span><br><span class="line">            <span class="keyword">if</span>(num[a[pos]] &lt; <span class="number">0</span> || num[x-a[pos]] &lt; <span class="number">0</span>) </span><br><span class="line">            <span class="comment">//如果 num 值裡面是 -1 就表示陣列中沒有這個數字，不能拿來當成一個 pair</span></span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">//再換新組合</span></span><br><span class="line">            record.push_back(&#123;a[pos], x-a[pos]&#125;); </span><br><span class="line">            <span class="comment">//記錄這個 pair，因為通過上面的 if 表示通過考驗</span></span><br><span class="line">            <span class="comment">//cout &lt;&lt; a[pos] &lt;&lt; ' ' &lt;&lt; x-a[pos] &lt;&lt; '\n';</span></span><br><span class="line">            x = max(a[pos], x-a[pos]); <span class="comment">//選擇下一個 x</span></span><br><span class="line">            cnt--; <span class="comment">//還需要的 pair 數量 -1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt == <span class="number">0</span> )&#123; <span class="comment">//等於 0 表示，已經可以完全匹配到了</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"YES\n"</span>;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; record[<span class="number">0</span>].first + record[<span class="number">0</span>].second &lt;&lt; <span class="string">'\n'</span>; </span><br><span class="line">            <span class="comment">//題目要求輸出最一開始的 x</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> it: record) <span class="comment">//輸出所有配對</span></span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; it.first &lt;&lt; <span class="string">' '</span> &lt;&lt; it.second &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">//由於配對成功，所以 return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"NO\n"</span>; <span class="comment">//配對失敗</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>*n; i++) <span class="comment">//輸入資料</span></span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>設計解題</tag>
        <tag>程式解題</tag>
        <tag>Codeforces</tag>
        <tag>數學推理</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces 1474D - Array Destruction (設計解題、數學推理)</title>
    <url>/2021/01/31/Codeforces/Codeforces%201474D/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>有一個遊戲規則，遊戲規則如下：<br>有 x 堆的石頭，每堆石頭都可以跟鄰近的石頭進行移除，移除方式為雙方各移除 y 顆石頭，移除數量必須小於石頭數量，最終要求為要讓所有堆的石頭全部數量歸零。</p>
<p>特殊規則：可以有一次將兩堆石頭進行交換。</p>
<p><a href="https://codeforces.com/contest/1474/problem/D" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li>對於數字的邏輯推理</li>
<li>快速找出題目的重點與其作答方向</li>
</ul>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>我們可以先根據題目找出一些邏輯觀念：</p>
<ul>
<li>定義石頭堆為 \(a_i\)</li>
<li>沒有移動石頭堆的情況下<ul>
<li>如果 \( a_1 &gt; a_2 \)，那麼 \(a_1 \) 這堆石頭永遠不會歸零，因此就永遠無法完成題目的 “Yes”</li>
<li>即使 \( a_1 &gt; a_2 \)，那也要移除到最後一堆石頭時剛好全部移除完畢，因此需要開一個陣列紀錄 \(a_{i-1} - a_{i-2} \) 的剩下數量，再跟我們的 \(a_i\) 進行移除比較；這裡我們透過一個陣列來維護他，陣列就稱為 <code>pre</code>。</li>
<li>因此可以得出一個規則， 石頭堆中的每一個 \(pre[i-1] &lt; pre[i] \)，否則無法完成題目的 “Yes”，定義為<strong>向後消除規則</strong>；因為此規則紀錄的陣列就與前綴和近乎相同，只有在前綴和為 -1 時，後面全部都設為 -1，表示無法被成功移除，只要到最後一堆石頭完成時前綴和為 0 就會是 “Yes”</li>
<li>可以再延伸出一個規則，題目沒有說移除的方向，因此可以從左邊移除也可以從右邊移除石頭</li>
<li>即使 \( a_1 &lt; a_2 \)，那也要移除到最後一堆石頭時剛好全部移除完畢，因此需要開一個陣列紀錄 \(a_{i+1} - a_{i+2} \) 的剩下數量，再跟我們的 \(a_i\) 進行移除比較；這裡我們透過一個陣列來維護他，陣列就稱為 <code>suf</code>。</li>
<li>因此可以得出一個規則， 石頭堆中的每一個 \(suf[i] &gt; suf[i+1] \)，否則無法完成題目的 “Yes”，定義為<strong>向前消除規則</strong>，陣列就稱為 <code>suf</code>；因為此規則紀錄的陣列就與後綴和近乎相同，只有在後綴和為 -1 時，前面全部都設為 -1，表示無法被成功移除，只要到第一堆石頭完成時後綴和為 0 就會是 “Yes”</li>
<li><strong>向後消除規則</strong>或<strong>向前消除規則</strong>滿足其中一個條件即可，</li>
</ul>
</li>
<li>有交換石頭堆的情況下<ul>
<li>由於可以進行交換石頭，因此前面兩個規則就不適用，但可以透過他們擴展出一套新的規則，如果只是將某兩堆的石頭進行交換，可以發現一定會影響到 \(pre[i]\) and \(suf[i+1]\)</li>
<li>再來我們可以發現在一個可以被全解的石頭堆測試範例中可以發現 \(pre[i] = suf[i+1]\)，那是因為<strong>移除</strong>本身沒有方向性，因此如果以 i 為分水嶺，i 前面的都用<strong>向後消除規則</strong>，i 後面的都用<strong>向前消除規則</strong>，會發現則最後一個移除無論是向後消除規則或向前消除規則都是相同的。</li>
<li>因此 \(pre[i] = suf[i+1]\) 表示這裡是最後一次的移除，並且可以完全移除成功，如果不等於就表示把這裡當作最後一次的移除時，並沒有辦法完全移除成功。</li>
<li>根據上面的規則，因為只有 \(pre[i]\) and \(suf[i+1]\) 會被更動到，因此我們先假設讓 \(a[i] \) 與 \(a[i+1]\) 交換，算出交換後的 \(pre[i]\) and \(suf[i+1]\)，再判斷他們是否相等即可。</li>
<li>只要 \(pre[i-1]\) 為 -1 表示已經打破了<strong>向後消除規則</strong>，在 \(a_i\) 前面就已經有石頭堆不可以被消除 or \(suf[i+2]\) 為 -1 表示已經打破了<strong>向前消除規則</strong> 在 \(a_i\) 後面就已經有石頭堆不可以被消除；因此 \(pre[i] = -1\) or \(suf[i+1] = -1 \) 就表示在這邊交換也沒辦法完成題目規定的 “Yes”。</li>
</ul>
</li>
</ul>
<h2 id="參考來源"><a href="#參考來源" class="headerlink" title="參考來源"></a>參考來源</h2><p><a href="https://codeforces.com/blog/entry/86933" target="_blank" rel="noopener">Codeforces Round #696 Editorial - IgorI’s blog</a><br><a href="https://tomjobs.blog.csdn.net/article/details/112889868?utm_medium=distribute.pc_relevant.none-task-blog-OPENSEARCH-2.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-OPENSEARCH-2.control" target="_blank" rel="noopener">Codeforces-1474 D. Cleaning（前缀和） - tomjobs  </a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>這題好難QQQ，我花了將近 3 天的時間才能理解懂，很懊惱自己的腦袋為甚麼不夠聰明沒辦法把這些思緒都想懂阿，希望我每周這樣不斷地對自己進行訓練能夠讓自己在生活日常中不斷地運用到，讓我在寫程式的過程中不斷地運用到，那我就沒有白費我現在每天這麼努力的練習自己的腦袋了。</p>
<p>希望自己未來的腦袋能變好，這種設計解題都能夠順利解開</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 200020</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f * 10 <span class="comment">//為解說中說明的 -1</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> t, n, num[MAXN];</span><br><span class="line"><span class="keyword">int</span> pre[MAXN], suf[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span></span>&#123; <span class="comment">//判斷是否可以解出</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(suf[i+<span class="number">1</span>] == pre[i]) <span class="comment">//表示不須交換就可以消除，把這裡的 i 讓他做後一次消除可以輸出 yes</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">//成功輸出 yes</span></span><br><span class="line">        <span class="keyword">int</span> x = num[i+<span class="number">1</span>] - pre[i<span class="number">-1</span>], y = num[i] - suf[i+<span class="number">2</span>] ; </span><br><span class="line">        <span class="comment">// x = pre[i] y = suf[i+1]，讓 x,y 視為交換後的調整</span></span><br><span class="line">        <span class="keyword">if</span>(x &gt;= <span class="number">0</span> &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; x == y) </span><br><span class="line">        <span class="comment">// x,y 都要大於 0，表示假設這裡進行最後一次移除，可以嘗試判斷能否全部移除成功</span></span><br><span class="line">        <span class="comment">//如果 x,y 其中一個為負數表示被 INF 減去，</span></span><br><span class="line">        <span class="comment">//也表示這裡就算進行最後一次移除也沒辦法全部移除成功，</span></span><br><span class="line">        <span class="comment">//如果 pre 或 suf 為 INF 表示前面或後面已經有石頭沒辦法被消除，分析有對此進行詳細說明</span></span><br><span class="line">        <span class="comment">// x==y 表示答案相同，代表這裡為最後一次移除可以完全移除成功，因此可以輸出 "YES"</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//表示沒有辦法被完全移除成功，符合題目要求，因此輸出 "NO"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; num[i];</span><br><span class="line">        suf[n+<span class="number">1</span>] = <span class="number">0</span>; <span class="comment">//先將 suf[n+1] 為 0，才可以讓找後綴和不會抓到前筆資料</span></span><br><span class="line">        pre[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">//pre[0] 為 0，才不會讓前綴和抓到前筆資料</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123; <span class="comment">//向前消除規則</span></span><br><span class="line">            <span class="keyword">if</span>(num[i] - pre[i<span class="number">-1</span>] &lt; <span class="number">0</span>) </span><br><span class="line">            <span class="comment">//為了防止 pre[i-1] = -1 時，num[i] - (-1) 會等於正數時的冏境，因此將 pre[i] 設為 INF</span></span><br><span class="line">                pre[i] = INF; <span class="comment">//為分析中所說的 -1，由於在等等程式撰寫方便，因此使用 INT</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                pre[i] = num[i] - pre[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &gt; <span class="number">0</span>; i--)&#123; <span class="comment">//向後消除規則</span></span><br><span class="line">            <span class="keyword">if</span>(num[i] - suf[i+<span class="number">1</span>] &lt; <span class="number">0</span>)</span><br><span class="line">                suf[i] = INF + MAXN; <span class="comment">//為分析中所說的 -1，由於在等等程式撰寫方便，因此使用 INT + MAXN</span></span><br><span class="line">                <span class="comment">//為了要讓 suf[i+1] == pre[i] 成立，且不讓 suf[i+1] == pre[i] == INF 時也成立，</span></span><br><span class="line">                <span class="comment">//因此讓 suf 在 INF 的時候再加 MAXN 來使在 INF 時 suf[i+1] != pre[i] </span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                suf[i] = num[i] - suf[i+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(solve())</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"YES\n"</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"NO\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="思考流程"><a href="#思考流程" class="headerlink" title="思考流程"></a>思考流程</h2><p>透過紙筆與黑板而思考而成的片段，放在網路上供我紀念XD</p>
<p>錯誤的程式碼就不放上來讓大家見笑了QQQQ。</p>
<blockquote>
<p><img src="https://i.imgur.com/eUgR0A4.jpg" alt=""><br><img src="https://i.imgur.com/IGVGdSI.jpg" alt=""><br><img src="https://i.imgur.com/lKYs80H.jpg" alt=""><br><img src="https://i.imgur.com/WVQw5IJ.jpg" alt=""></p>
</blockquote>
]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>設計解題</tag>
        <tag>程式解題</tag>
        <tag>Codeforces</tag>
        <tag>數學推理</tag>
      </tags>
  </entry>
  <entry>
    <title>演算法知識 - Disjoint Set 並查集</title>
    <url>/2021/02/02/Explain_Algorithm/disjoint-set/</url>
    <content><![CDATA[<h2 id="Disjoint-Set-介紹與應用"><a href="#Disjoint-Set-介紹與應用" class="headerlink" title="Disjoint Set 介紹與應用"></a>Disjoint Set 介紹與應用</h2><blockquote>
<p>Disjoint Set 並查集是資料結構的其中一種，主要用來處理元素間的合併與查詢，並查集有 2 種操作</p>
<ul>
<li>查詢 查詢某個元素是在哪個集合中，通常是返回集合內的<strong>代表元素</strong>，也就是在查詢此集合中的任一元素時，都會傳回此元素</li>
<li>合併 將兩個集合合併成一個</li>
</ul>
<p>由於此兩操作時間複雜度都是 \(O(\log_n\)，且編寫容易，因此受到大量地使用，是個很棒的資料結構</p>
</blockquote>
<a id="more"></a>

<h2 id="Disjoint-Set-原理"><a href="#Disjoint-Set-原理" class="headerlink" title="Disjoint Set 原理"></a>Disjoint Set 原理</h2><h3 id="建立初始-Disjoint-Set"><a href="#建立初始-Disjoint-Set" class="headerlink" title="建立初始 Disjoint Set"></a>建立初始 Disjoint Set</h3><p>由於一開始每個元素都是獨立的集合且也是自己集合中的<strong>代表元素</strong>，因此先寫一個迴圈讓每個元素都是集合中的<strong>代表元素</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 2000</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXN; i++)&#123;</span><br><span class="line">        tree[i] = i;</span><br><span class="line">        cnt[i] = <span class="number">1</span>; <span class="comment">//cnt 為數量，也就是每一個集合的數量，一開始都是 1，因為只有自己。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="查詢"><a href="#查詢" class="headerlink" title="查詢"></a>查詢</h3><p>查詢是要查詢某個元素是在哪個集合中，因此我們只需要寫這樣即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_root</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[i] != i) <span class="comment">//如果 tree[i] 本身並不是集合中的代表元素，</span></span><br><span class="line">    <span class="comment">//表示這個集合中有其他元素，並且其他元素才是代表元素</span></span><br><span class="line">        <span class="keyword">return</span> tree[i] = find_root(tree[i]); <span class="comment">//遞迴，將 tree[i] 的元素在進行查詢，</span></span><br><span class="line">        <span class="comment">//並將代表元素設為現在的 tree[i]</span></span><br><span class="line">    <span class="keyword">return</span> tree[i]; <span class="comment">//回傳代表元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="合併"><a href="#合併" class="headerlink" title="合併"></a>合併</h3><p>合併較為簡單，只需要先<strong>查詢</strong> <code>tree[a],tree[b]</code> 這兩個的代表元素是否為一樣，如果不一樣就表示兩個為不同集合，讓 <code>tree[b]</code>代表元素與<code>tree[a]</code>相同即可，這樣之後在查詢中代表元素就會相同。</p>
<p>計算數量的陣列也要進行改變，因為這兩個集合被合併了，因此數量要進行更新，讓 <code>cnt[b]</code> 的值加給 <code>cnt[a]</code>， <code>cnt[b]</code> 之後再將他歸 0。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    rx = find_root(tree[a]); <span class="comment">//找出 find_root(tree[a]) 的代表元素</span></span><br><span class="line">    ry = find_root(tree[b]); <span class="comment">//找出 find_root(tree[b]) 的代表元素</span></span><br><span class="line">    <span class="keyword">if</span>(rx != ry) <span class="comment">//如果不一樣就合併</span></span><br><span class="line">        tree[ry] = rx; <span class="comment">//要合併的是代表元素，不是 tree[b]</span></span><br><span class="line">        cnt[rx] += cnt[ry]; <span class="comment">//將原本另一集合的數量加到這集合，因為他們合併了</span></span><br><span class="line">        cnt[ry] = <span class="number">0</span>;  <span class="comment">//由於合併，因此將原本獨立的集合數量歸 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="QUESTION-可能有些人會想問這樣真的就可以合併成功嗎？"><a href="#QUESTION-可能有些人會想問這樣真的就可以合併成功嗎？" class="headerlink" title="QUESTION: 可能有些人會想問這樣真的就可以合併成功嗎？"></a>QUESTION: 可能有些人會想問這樣真的就可以合併成功嗎？</h4><p>我知道大家好奇的原因，因為我也好奇過XD。</p>
<p>可是我們稍微思考一下，由於我們是將 <code>tree[ry]</code> 的代表元素更換為 <code>tree[rx]</code> 的代表元素，因此在<strong>查詢到</strong> <code>tree[ry]</code>，就會發現 <code>tree[ry]</code>已經不是代表元素了，因此會再進行一次遞迴，就會查詢到 <code>tree[rx]</code>，發現他是代表元素，就開始不斷的進行 return。</p>
<h4 id="QUESTION-可能還會有些人好奇那原本-tree-ry-的集合中其他元素不還是指向-tree-ry-嗎-沒關係嗎"><a href="#QUESTION-可能還會有些人好奇那原本-tree-ry-的集合中其他元素不還是指向-tree-ry-嗎-沒關係嗎" class="headerlink" title="QUESTION: 可能還會有些人好奇那原本 tree[ry] 的集合中其他元素不還是指向 tree[ry] 嗎?沒關係嗎?"></a>QUESTION: 可能還會有些人好奇那原本 <code>tree[ry]</code> 的集合中其他元素不還是指向 <code>tree[ry]</code> 嗎?沒關係嗎?</h4><p>沒關係的，在查詢中一樣會先查詢到 <code>tree[ry]</code> 但它並不是代表元素，因此會在遞迴查詢，就會查到 <code>tree[rx]</code>，之後再遞迴回傳時在讓當前的 <code>tree[i]</code>直接指向代表元素即可，加快效率。</p>
<h3 id="count-計算數量"><a href="#count-計算數量" class="headerlink" title="count 計算數量"></a>count 計算數量</h3><p>disjoint set 常常會需要計算數量，這時我們前面使用的 cnt 陣列就派上用場了，用法很簡單，因為前面在合併的過程中都幫助我們處理好了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; cnt[find_root(x)] ; <span class="comment">// x 為要查詢的集合</span></span><br></pre></td></tr></table></figure>

<h4 id="QUESTION-這樣真的就會計算數量成功嗎-我們只有將兩個集合加入，但還會有點沒有被算到吧？"><a href="#QUESTION-這樣真的就會計算數量成功嗎-我們只有將兩個集合加入，但還會有點沒有被算到吧？" class="headerlink" title="QUESTION: 這樣真的就會計算數量成功嗎? 我們只有將兩個集合加入，但還會有點沒有被算到吧？"></a>QUESTION: 這樣真的就會計算數量成功嗎? 我們只有將兩個集合加入，但還會有點沒有被算到吧？</h4><p>會的，因為每一次的合併都會將別人的元素加入，最一開始的合併一定是 1+1，也就是兩個點的合併，只要一開始是正確的，後面就都會正確。</p>
<p>不然就不叫程式了XD。</p>
<h2 id="Disjoint-Set-應用"><a href="#Disjoint-Set-應用" class="headerlink" title="Disjoint Set 應用"></a>Disjoint Set 應用</h2><ul>
<li><a href="https://theriseofdavid.github.io/2020/03/23/UVa/Uva11987/" target="_blank" rel="noopener">Uva11987 - Almost Union-Find (Disjoint Set)</a></li>
<li><a href="https://theriseofdavid.github.io/2021/02/02/UVa/UVa599/" target="_blank" rel="noopener">UVa599 - The Forrest for the Trees(Disjoint Set)</a></li>
<li><a href="https://theriseofdavid.github.io/2021/02/06/UVa/UVa11503/" target="_blank" rel="noopener">UVa11503 - Virtual Friends(Disjoint Set)</a></li>
</ul>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://zh.wikipedia.org/wiki/%E5%B9%B6%E6%9F%A5%E9%9B%86" target="_blank" rel="noopener">併查集</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>這是我在高中時期就學會的演算法之一，在高職的時候我是自己學的，在新北市政府的幫助之下讓我去版中上課，接觸到了許多優秀的人才以及優秀的老師(蝸牛老師)，老師在教演算法這塊特別優秀，教導的十分好懂，是我的演算法啟蒙老師之一，很謝謝老師的講解！讓我在快要忘記之餘強制複習，才讓他完全記錄在我的腦海之中。</p>
]]></content>
      <categories>
        <category>演算法知識</category>
      </categories>
      <tags>
        <tag>Disjoint Set 並查集</tag>
        <tag>程式解題</tag>
        <tag>演算法知識</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa599 - The Forrest for the Trees(Disjoint Set)</title>
    <url>/2021/02/02/UVa/UVa599/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>給你很多個邊，這些邊透過節點的連接組成，接下來給你一些節點，要詢問這些節點有哪些節點有跟其他的節點做連結，哪些沒有。</p>
<p>有跟其他點做連結的點稱之為 tree，沒有的稱之為 acorns，請輸出他們的數量。</p>
<p><a href="https://onlinejudge.org/external/5/599.pdf" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="觀念重點"><a href="#觀念重點" class="headerlink" title="觀念重點"></a>觀念重點</h2><ul>
<li>並查集的應用</li>
<li>計算數量 acrons 與 tree 時的程式編寫</li>
<li>輸入的格式判斷</li>
</ul>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>明顯可以看得出來這是一個 disjoint set 題目，哪裡可以看的出來呢？</p>
<p>在他說輸出 tree 與 acorns 時，不難發現 tree 就是有跟其他節點連結過的集合，acorns 就是沒有跟其他節點連結過的集合，透過 disjoint set 可以很快完美解決此問題。</p>
<p>如果還不懂 disjoint set 的可以看<a href="https://theriseofdavid.github.io/\2021/02/02/Explain_Algorithm/disjoint-set/" target="_blank" rel="noopener">演算法知識 - Disjoint Set 並查集</a>或<a href="https://www.youtube.com/watch?v=wU6udHRIkcc" target="_blank" rel="noopener">Abdul Bari</a></p>
<h3 id="tree-and-acrons-的程式碼編寫"><a href="#tree-and-acrons-的程式碼編寫" class="headerlink" title="tree and acrons 的程式碼編寫"></a>tree and acrons 的程式碼編寫</h3><p>一開始先開兩個陣列 cT and cA，cT 用來數 tree 的數量，cA 用來數 acorns。<br>並且在 disjoint set 建立時，先讓每個 <code>cA[i]</code>都設為 1，表示當前每個都是 acorns。</p>
<p>我們可以在每次的合併查詢中多寫一句話</p>
<ul>
<li>如果代表元素不等於自己，那就讓 <code>cA[i]</code> 等於 0 且 <code>cT[i]</code> 為 1</li>
</ul>
<p>接下來在到測資結束前，對題目想查詢的節點進行計數，如果 <code>cA[i] = 1</code>，等等輸出的 acorns 就加一，如果 <code>cT[i] = 1</code>，等等輸出的 tree 就加一</p>
<p>這樣可以方便又快速的解決此問題，這是我個人想到的，並不一定要用此方式解。</p>
<h3 id="由於他詢問的節點不一定按照字母順序，記得要先用-vector-存起來。"><a href="#由於他詢問的節點不一定按照字母順序，記得要先用-vector-存起來。" class="headerlink" title="由於他詢問的節點不一定按照字母順序，記得要先用 vector 存起來。"></a>由於他詢問的節點不一定按照字母順序，記得要先用 vector 存起來。</h3><p>記得對每一個要查詢的值進行判斷是 acorn or tree，再用 vector 紀錄，等等再進行計數。</p>
<p>我知道可能沒有寫得很乾淨，可以改進XD。</p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>這題讓我複習了很多 disjoint set，把我的小腦袋給弄醒了一些呀，好希望自己可以在學習的過程中更優秀、更努力，就可以讓自己變得更強，也透過寫演算法來增加我的思維。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 30 <span class="comment">//題目最大數量</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> tree[MAXN], cT[MAXN], cA[MAXN]; <span class="comment">//cntTree cntAcorn 判斷 i 是 tree or acorn</span></span><br><span class="line"><span class="comment">//tree 為 disjoint set </span></span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"><span class="built_in">string</span> temp;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; record; <span class="comment">//紀錄查詢的字元</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123; <span class="comment">//初始</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXN; i++)&#123; </span><br><span class="line">        tree[i] = i; <span class="comment">//重設 disjoint set</span></span><br><span class="line">        cA[i] = <span class="number">1</span>; <span class="comment">//一開始每個節點都是 acorns</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(cT, <span class="number">0</span>, <span class="keyword">sizeof</span>(cT)); <span class="comment">//一開始沒有節點是 tree</span></span><br><span class="line">    record.clear(); <span class="comment">//查詢字元紀錄刪除</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_root</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123; <span class="comment">//disjoint set 查詢</span></span><br><span class="line">    <span class="keyword">if</span>(tree[i] != i)</span><br><span class="line">        <span class="keyword">return</span> tree[i] = find_root(tree[i]);</span><br><span class="line">    <span class="keyword">return</span> tree[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">()</span></span>&#123; <span class="comment">//debug 用，無意義</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; MAXN; i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; MAXN; i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; tree[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; MAXN; i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; cA[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"out.txt"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; temp)&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp[<span class="number">0</span>] == <span class="string">'('</span>)&#123; <span class="comment">//合併節點</span></span><br><span class="line">                <span class="keyword">int</span> x, y, rx, ry; <span class="comment">//rootx rooty</span></span><br><span class="line">                x = temp[<span class="number">1</span>] - <span class="string">'A'</span> + <span class="number">1</span>; <span class="comment">//hash 用，透過 ascii</span></span><br><span class="line">                y = temp[<span class="number">3</span>] - <span class="string">'A'</span> + <span class="number">1</span>;</span><br><span class="line">                rx = find_root(tree[x]); <span class="comment">//找集合內代表元素</span></span><br><span class="line">                ry = find_root(tree[y]); <span class="comment">//找集合內代表元素</span></span><br><span class="line">                <span class="keyword">if</span>(rx != ry) <span class="comment">//兩個不再同集和內就合併</span></span><br><span class="line">                    tree[ry] = rx;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(temp[<span class="number">0</span>] == <span class="string">'*'</span>)&#123; <span class="comment">//查詢節點</span></span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; temp;</span><br><span class="line">                <span class="keyword">int</span> root, x;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; temp.length(); i+=<span class="number">2</span>)&#123;</span><br><span class="line">                    x = temp[i] - <span class="string">'A'</span> + <span class="number">1</span>; <span class="comment">//hash 用，透過 ascii</span></span><br><span class="line">                    record.push_back(x); <span class="comment">//紀錄查詢字元</span></span><br><span class="line">                    root = find_root(tree[x]); <span class="comment">//找集合內代表元素</span></span><br><span class="line">                    <span class="comment">//cout &lt;&lt; root &lt;&lt; ' ' &lt;&lt; x &lt;&lt; "\n";</span></span><br><span class="line">                    <span class="keyword">if</span>(root != x)&#123; <span class="comment">//如果集合內代表元素並不是 x 就表示他一定是 tree</span></span><br><span class="line">                        cA[x] = <span class="number">0</span>; <span class="comment">// 證明 x 不是 acorn</span></span><br><span class="line">                        cA[root] = <span class="number">0</span>; <span class="comment">//root 也不會是 acorn 因此設為 0</span></span><br><span class="line">                        cT[root] = <span class="number">1</span>; <span class="comment">//但 root 會 +1，因為有跟其他值連結</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//debug();</span></span><br><span class="line">        <span class="keyword">int</span> sum_cT = <span class="number">0</span>, sum_cA = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; record.size(); i++)&#123; <span class="comment">//計算 acorn and root 數量，透過記錄的查詢字元</span></span><br><span class="line">            <span class="keyword">if</span>(cT[record[i]]) sum_cT++; <span class="comment">//表示 i 是 tree</span></span><br><span class="line">            <span class="keyword">if</span>(cA[record[i]]) sum_cA++; <span class="comment">//表示 i 是 acorn</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"There are "</span> &lt;&lt; sum_cT &lt;&lt; <span class="string">" tree(s) and "</span> &lt;&lt; sum_cA &lt;&lt; <span class="string">" acorn(s).\n"</span>; <span class="comment">//輸出</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>Disjoint Set 並查集</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa10895 - Matrix Transpose(水題)</title>
    <url>/2021/02/02/UVa/UVa10895/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>給你一個矩陣，請你將原本的矩陣進行對調，原本是 \(num_ij\) 的值改放到 \(num_ji\)。</p>
<p>注意：題目的輸入輸出格式較為特別，需要注意</p>
<p><a href="https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1836" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="觀念重點"><a href="#觀念重點" class="headerlink" title="觀念重點"></a>觀念重點</h2><ul>
<li>對題目的格式清楚了解</li>
<li>英文閱讀</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>這題基本上沒有難度，直接讓陣列顛倒即可，怎麼顛倒呢？</p>
<p>題目對每一 row 都會給兩行，第一行的第一個數字是 row 中有幾個 index 要被輸入，這 row 中非 0 元素的 index，第二行則是這些非 0 元素 index 的數值，依此類推，注意，如果 row 沒有值要被輸入，那下一行則會空行。</p>
<p>這是題目的輸入說明，他的輸入格式翻譯成中文再經由我轉述，希望可以讓大家看懂，因為他的輸入於其他 uva 格式較為不同。</p>
<p>只需要將測資輸入到程式時是顛倒就可以了，記得是<strong>嚴格比對</strong>，然後 row 如果沒有非 0 元素，下行要是空行。</p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>除了練好我的英文能力以外，也要增加我對英文的自信心阿，加強英文閱讀速度，一定會讓我對未來更有力的。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 10020</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> num[MAXN][MAXN], row[MAXN]; </span><br><span class="line"><span class="comment">//num 題目中的 matrix, row 為非零元素的 index</span></span><br><span class="line"><span class="keyword">int</span> n, m, r;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">input_row</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123; <span class="comment">//對每一列的非零元素進行輸入</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; r; <span class="comment">//表示有 r 個非零元素</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= r; j++) <span class="comment">//輸入 index </span></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; row[j];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= r; j++) <span class="comment">//再將這些值直接進行轉換傳給 num</span></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; num[row[j]][i]; <span class="comment">//row[j] 要在前面，因為直接進行轉換</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; m &lt;&lt; <span class="string">' '</span> &lt;&lt; n &lt;&lt; <span class="string">'\n'</span>; <span class="comment">//顛倒輸出，因為矩陣轉換</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; record; <span class="comment">//紀錄這行的非零元素 index</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        record.clear(); <span class="comment">//換新行，清空</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num[i][j]) record.push_back(j); <span class="comment">//如果 num 數值不是 0，那 record 紀錄 index</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; record.size(); <span class="comment">//有多少非零元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it: record) <span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; it; <span class="comment">//輸出這些 index </span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(record.size() &gt; <span class="number">0</span>)&#123; <span class="comment">//如果有元素可以被輸出，才須要輸出數值</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; record.size()<span class="number">-1</span>; j++) <span class="built_in">cout</span> &lt;&lt; num[i][record[j]] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">            <span class="comment">//依序輸出每個非零元素，最後一個獨立輸出，因為她的後面不能加上空白</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; num[i][record[record.size()<span class="number">-1</span>]] ; <span class="comment">//獨立輸出</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>; <span class="comment">//換行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"out.txt"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(num, <span class="number">0</span>, <span class="keyword">sizeof</span>(num)); <span class="comment">//初始題目陣列</span></span><br><span class="line">        <span class="built_in">memset</span>(row, <span class="number">0</span>, <span class="keyword">sizeof</span>(row)); <span class="comment">//初始紀錄非零元素的 index 陣列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) input_row(i); <span class="comment">//對每 row 進行輸入值</span></span><br><span class="line">        output(); <span class="comment">//輸出轉換</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>水題</tag>
        <tag>UVa</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa10507 - Waking up brain(BFS)</title>
    <url>/2021/02/02/UVa/UVa10507/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>近代的研究指出如果要喚醒腦袋的區域時，必須要附近三塊的腦袋都是清醒的狀況才有辦法喚醒此區域，我們會給你已經清醒的區域，還有哪些區域是有連結的，想請問多久後才可以將腦袋中所有區域喚醒成功？</p>
<p>P.S. 喚醒需要一年的時間，請輸出多久可以喚醒，如果沒辦法喚醒輸出 “THIS BRAIN NEVER WAKES UP”，可以就輸出 “WAKE UP IN, n, YEARS”, where n is the number of the years all the brain has taken to wake up</p>
<p><a href="https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1448" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li>必須要看懂英文，這題對我來說英文有點難QQQ</li>
<li>觀察出此題類似於 BFS，但都只跑一層</li>
<li>哪些節點可以被喚醒再跑一次<strong>第二點</strong>。</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>這題與 BFS 比較不同的地方就是加入節點的要求是需要有鄰近 3 個區域被喚醒才可以被加入節點，為了要解決這個問題，我們開一個陣列叫做 area，每次讓喚醒的區域連結到還在睡著的區域，就讓被睡著的區域加一，如果加到 3 就加入節點，做下一次的 BFS。</p>
<h3 id="QUESTION-那要怎麼找出是需要幾年可以把全部區域喚醒呢"><a href="#QUESTION-那要怎麼找出是需要幾年可以把全部區域喚醒呢" class="headerlink" title="QUESTION: 那要怎麼找出是需要幾年可以把全部區域喚醒呢"></a>QUESTION: 那要怎麼找出是需要幾年可以把全部區域喚醒呢</h3><p>這時候就需要遞迴來幫助我們了，我們 BFS 的 vector (定義 vA)是當前有被喚醒的區域，裡面的節點都成功去 link 每個未喚醒的節點後就 pop，那如果有節點在此時被喚醒我們則把她加入到新的 vector 中(定義 vB)，當 vA 全部完成後，如果 vB 有節點我們就進行下一次的 BFS，使用遞迴則是可以方便知道我們總共喚醒幾次。</p>
<p>只需要將每一次的遞迴視為明年會被激活的區域即可。特別注意的是，一開始的區域不可以被 +1，因為那是已經醒來的區域，因此在進入遞迴時先將值設為 -1，這樣進入第一層遞迴時就會歸零。</p>
<h3 id="QUESTION-但上面那個問題沒有解決怎麼知道全部的區域都被喚醒呢？"><a href="#QUESTION-但上面那個問題沒有解決怎麼知道全部的區域都被喚醒呢？" class="headerlink" title="QUESTION: 但上面那個問題沒有解決怎麼知道全部的區域都被喚醒呢？"></a>QUESTION: 但上面那個問題沒有解決怎麼知道全部的區域都被喚醒呢？</h3><p>我們一開始不是有一個陣列(area) 可以知道此區域有幾個喚醒的區域連結嗎？我們只需要寫一個迴圈查詢所有的節點是不是都有 3 個或 3 個以上的區域連結就可以檢查了！</p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>這題其實不難，但蠻酷的，有一些很簡單的腦筋急轉彎需要去思考，遞迴裡面塞入一個 BFS，似乎有點類似於 IDDFS，但年代久遠我有點忘記了QQ，還需要在去複習一下，寫演算法很容易會忘記QQ，希望我的腦袋可以把這些思維都記錄下來並應用在生活上，這樣我就會是一個很不賴的人了！</p>
<p>希望自己的大腦要能夠一直都醒來拉，不醒來會對周遭的人很麻煩，會麻煩到他們的。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。</p>
<p>裡面為了讓程式碼更好寫，有做一些小手腳，在這邊會加上一些定義，供大家在閱讀時更好閱讀</p>
<ul>
<li><code>-INF</code> 已經有被掃描過的區域</li>
<li><code>flag</code> 判斷有多少節點是喚醒的</li>
<li><code>ca, cb</code> 輸入題目中的邊時要用到的字元</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 30</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f <span class="comment">//-INF 表示此節點已經被掃描過</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, cnt, flag;</span><br><span class="line"><span class="keyword">int</span> area[MAXN];</span><br><span class="line"><span class="built_in">string</span> temp;</span><br><span class="line"><span class="keyword">char</span> ca, cb;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; edge[MAXN]; <span class="comment">//每一個邊，第一個維度是分類為 edge[i] 可以連接到哪些邊</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123; <span class="comment">//將所有的陣列清空，不被上次的測資干擾</span></span><br><span class="line">    <span class="built_in">memset</span>(area,<span class="number">0</span>,<span class="keyword">sizeof</span>(area)); <span class="comment">//清空所有的 area</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXN; i++) edge[i].clear(); <span class="comment">//清空所有的邊</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wake</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; record)</span></span>&#123; <span class="comment">// BFS遞迴，查詢喚醒次數跟讓上次被喚醒的區域再跟其他區域連結 </span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp2; <span class="comment">//這次經過連結後會被喚醒的區域先暫存的 vector</span></span><br><span class="line">    cnt++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it: record)&#123; <span class="comment">//將上次被喚醒的區域去跟其他節點連結</span></span><br><span class="line">        <span class="comment">//cout &lt;&lt; (char)(it+'A') &lt;&lt; ' ';</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edge[it].size(); i++)&#123; <span class="comment">//每一個邊連結的其他邊</span></span><br><span class="line">            area[edge[it][i]]++; <span class="comment">//被連結的其他區域 +1，表示鄰近被喚醒的區域 +1</span></span><br><span class="line">            <span class="keyword">if</span>(area[edge[it][i]] &gt;= <span class="number">3</span>)&#123; <span class="comment">//如果大於 3，表示下次這個區域可以被喚醒</span></span><br><span class="line">                temp2.push_back(edge[it][i]); <span class="comment">//先放入暫存 vector</span></span><br><span class="line">                area[edge[it][i]] = -INF; <span class="comment">//此節點被放入 vector 了，因此設為 -INF</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; '\n';</span></span><br><span class="line">    <span class="keyword">if</span>(temp2.empty()) <span class="keyword">return</span> ; <span class="comment">//如果是空的就表示已經沒有區域被喚醒，沒辦法在跟其他區域連結</span></span><br><span class="line">    <span class="keyword">return</span> wake(temp2); <span class="comment">//還有區域被喚醒，因此進入下次的遞迴在跟其他區域連結</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"out.txt"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m)&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; record; <span class="comment">//紀錄有被喚醒的區域</span></span><br><span class="line">        init(); <span class="comment">//初始化，清空</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; temp; <span class="comment">//輸入字串，為一開始有被喚醒的區域</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; temp.length(); i++)&#123; </span><br><span class="line">            record.push_back(temp[i] - <span class="string">'A'</span>); <span class="comment">//將被喚醒的區域加入 vector，等等 BFS</span></span><br><span class="line">            area[temp[i] - <span class="string">'A'</span>] = -INF; <span class="comment">//點被加入 vector，因此值設為 -INF</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m ; i++)&#123; <span class="comment">//輸入連結的邊</span></span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; ca &gt;&gt; cb;</span><br><span class="line">            edge[ca - <span class="string">'A'</span>].push_back(cb - <span class="string">'A'</span>); <span class="comment">//hash 透過 ascii，A = 0, B = 1,...</span></span><br><span class="line">            edge[cb - <span class="string">'A'</span>].push_back(ca - <span class="string">'A'</span>); <span class="comment">//雙向連結，題目有說明是雙向邊</span></span><br><span class="line">        &#125;</span><br><span class="line">        cnt = <span class="number">-1</span>; flag = <span class="number">0</span>; <span class="comment">//cnt = -1，第一次的區域是已經醒來，所以不需要等待</span></span><br><span class="line">        <span class="comment">//flag 是要查詢哪些區域有被喚醒且已經被掃描過，如果有被喚醒就一定會被掃瞄，BFS 會做好這件事</span></span><br><span class="line">        wake(record);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXN; i++)&#123; <span class="comment">//查詢所有區域是否有被喚醒且已經被掃描過</span></span><br><span class="line">            <span class="keyword">if</span>(area[i] &lt; <span class="number">0</span>) flag++; <span class="comment">//有就 flag++</span></span><br><span class="line">            <span class="comment">//cout &lt;&lt; area[i] &lt;&lt; '\n';</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(flag == n) <span class="built_in">cout</span> &lt;&lt; <span class="string">"WAKE UP IN, "</span> &lt;&lt; cnt &lt;&lt; <span class="string">", YEARS\n"</span>;</span><br><span class="line">        <span class="comment">//表示有被喚醒且已經被掃描過區域等同題目給的所有區域也就是所有區域都被喚醒，因此可以輸出 cnt，代表只需要 cnt 年就可以將腦袋全部區域喚醒</span></span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"THIS BRAIN NEVER WAKES UP\n"</span>; </span><br><span class="line">        <span class="comment">//表示所有區域並沒有都被喚醒且已經被掃描過，有些區域沒有被喚醒，因此輸入永遠沒辦法讓大腦醒來 QQ。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>Disjoint Set 並查集</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa11503 - Virtual Friends(Disjoint Set)</title>
    <url>/2021/02/06/UVa/UVa11503/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>大家都喜歡線上交友，線上交友成為了一種大家的習慣或嗜好，我們每行會給你兩個名子，那兩個人是朋友關係，因為線上交友的關係，因此那兩人的朋友們也都會互相成為朋友。</p>
<p>每次新增朋友關係後，請試者輸出那群朋友的數量</p>
<p><a href="https://onlinejudge.org/index.php?option=onlinejudge&Itemid=8&page=show_problem&problem=2498" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li>了解 Disjoint Set</li>
<li><a href="https://theriseofdavid.github.io/2021/02/02/Explain_Algorithm/disjoint-set/" target="_blank" rel="noopener">演算法知識 - Disjoint Set 並查集</a></li>
</ul>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>很明顯的並查集，我們只需要寫好並查集的模板，接著將字串進行 hash，就可以得到答案。</p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>最近這幾天心情很煩燥，很多事情都安不下心，我還是一個小孩，還不願成長為一個大人，好多事情我都想逃避，但是世界不會讓我逃避、都市不會讓我逃避。</p>
<p>希望最近能讓我好點。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。</p>
<p>裡面為了讓程式碼更好寫，有做一些小手腳，在這邊會加上一些定義，供大家在閱讀時更好閱讀</p>
<ul>
<li><code>num</code> 為 disjoint set 判斷 <code>num[index]</code> 在哪個集合內</li>
<li><code>cnt</code> 為 disjoint set 判斷 <code>cnt[index]</code> 此代表元素的集合內有多少元素有多少元素</li>
<li><code>hs</code> 用來 hash 值，來讓字串進行加密壓縮</li>
<li><code>record</code> 字典，用來紀錄字串 hash 成 int 的值</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100020</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> t, f, hs;</span><br><span class="line"><span class="keyword">int</span> num[MAXN], cnt[MAXN]; </span><br><span class="line"><span class="built_in">string</span> n1, n2;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; record;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_root</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123; <span class="comment">//disjoint set 查詢</span></span><br><span class="line">    <span class="keyword">if</span>(num[i] != i) <span class="keyword">return</span> num[i] = find_root(num[i]);</span><br><span class="line">    <span class="keyword">return</span> num[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"out.txt"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXN; i++)&#123; <span class="comment">//最一開始先幫所有陣列初始化</span></span><br><span class="line">        num[i] = i; <span class="comment">//重設 disjoint set</span></span><br><span class="line">        cnt[i] = <span class="number">1</span>; <span class="comment">//重設 disjoint set</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; f;</span><br><span class="line">        hs = <span class="number">0</span>; record.clear();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; f; i++)&#123; <span class="comment">//讓上次測資不干擾這次測資</span></span><br><span class="line">            num[i] = i;  <span class="comment">//重設 disjoint set</span></span><br><span class="line">            cnt[i] = <span class="number">1</span>;  <span class="comment">//重設 disjoint set</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; f; i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; n1 &gt;&gt; n2;</span><br><span class="line">            <span class="comment">//壓縮字串為 int，如果字典沒有這個字串那就給他從未用過的 hash 值</span></span><br><span class="line">            <span class="keyword">if</span>(!record.count(n1)) record[n1] = hs++; </span><br><span class="line">            <span class="keyword">if</span>(!record.count(n2)) record[n2] = hs++;</span><br><span class="line">            <span class="keyword">int</span> rx, ry;</span><br><span class="line">            <span class="comment">//為 disjoint set 的合併，開始</span></span><br><span class="line">            rx = find_root(num[record[n1]]); </span><br><span class="line">            ry = find_root(num[record[n2]]); </span><br><span class="line">            <span class="keyword">if</span>(rx != ry)&#123; </span><br><span class="line">                num[ry] = num[rx];</span><br><span class="line">                cnt[rx] += cnt[ry];</span><br><span class="line">                cnt[ry] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//為 disjoint set 的合併，結束</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; cnt[rx] &lt;&lt; <span class="string">'\n'</span>; <span class="comment">//輸出集合內的元素數量</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>Disjoint Set 並查集</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa11991 - Easy Problem from Rujia Liu?(水題)</title>
    <url>/2021/02/02/UVa/UVa11991/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>Rujia Liu(華人大神出了許多演算法競賽的書，被稱之為聖經) 出了一份題目希望讓大家可以一起來為了演算法競賽而努力，題目內容如下：</p>
<p>給你一組陣列，進行查詢，查詢的模式是在 v 此數字出現第 k 次的位置是在陣列中的哪個 index</p>
<p><a href="https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=3142" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="觀念重點"><a href="#觀念重點" class="headerlink" title="觀念重點"></a>觀念重點</h2><ul>
<li>能夠快速把此題寫完</li>
<li>清空陣列，讓每筆測資不受干擾</li>
</ul>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>明顯可以看出此題是水體，鼓勵各位新手來進入這個演算法競賽中(<del>地獄</del>)www，這題主要可以用 vector 去解，可以將 vector 開到題目測試資料極限最大值，再將每個數字的 index 不斷存入屬於那個數字的 vector，如果要查詢的 size 比當前的 vector size 大就表示一定沒辦法查詢，輸出 “0”，不然就輸出 <code>num[v][k-1]</code>，vector 的 index 是從 0 開始。</p>
<p>上面講的是基本作法，但有一個地方需要注意</p>
<p>需要特別注意的是我們的數字最大可以來到 \(10^9\)，因此不可以直接用 <code>vector[(10^9)]</code>，如果使用的話會導致 TLE，需要在一個 unordered_map 來進行 hash，由於數字陣列最大只會來到 \(10^5\)，因此讓先讀到的數字先放入 unordered_map，假如沒有被記錄在 unordered_map 表示這個數字還沒有被 hash，現在給他 hash，之後如果查詢此值就給他 hash 過的數值，以此為標準來找出 <code>num[v][k-1]</code> 的值，注意這裡的 <code>num[v][k-1]</code> 是 <code>num[unordered_map[v]][k-1]</code></p>
<p>map 在數量大於 300 時，速度會開始變慢，如果已知需要紀錄的數量大於 300 時使用 unordered_map。</p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>原本我一開始這題還想要開一個二維陣列去寫，第一個維度是這個數字(定義 x)，第二個維度是出現地次數(定義為 y)，值為題目陣列的 index，但發現這樣很難寫，而且很麻煩XDD，所以後來就改使用 vector 去寫，非常方便又好用阿XD。</p>
<p>題外話：現在在寫 UVA 時 judge 壞掉了，好難過QQQQ。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100020</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, k, v, temp; </span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; num[MAXN]; <span class="comment">//我們用來分類的陣列，第一個維度是每一個數字的分類</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; record; <span class="comment">//用來記錄 hash，陣列的 int 值會 hash 變成低於 MAXN 的值，才可以讓 num vector 成功存入</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"out.txt"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m)&#123; <span class="comment">//輸入資料</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= MAXN; i++) num[i].clear();</span><br><span class="line">        <span class="comment">//一定要把之前的全部查詢都清除，不然會讓上筆測資跟這次的干擾；</span></span><br><span class="line">        <span class="comment">//一定要是 MAXN，題目的數字是 0 &lt; x &lt; MAX</span></span><br><span class="line">        cnt = <span class="number">0</span>; record.clear(); <span class="comment">//cnt 是 hash 的值，如果 record 沒有紀錄此數字就讓 cnt 表示這值，</span></span><br><span class="line">        <span class="comment">//進行 hash 後就不會有浪費 num vector 的問題。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123; <span class="comment">//輸入資料</span></span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; temp;</span><br><span class="line">            <span class="keyword">if</span>(!record.count(temp)) record[temp] = cnt++; <span class="comment">//如果 record 沒有 hash 過現在這個數值，現在進行 hash，然後讓 cnt 的值再加一。</span></span><br><span class="line">            num[record[temp]].push_back(i); <span class="comment">//將要查詢的數字先轉成 hash 過的值，在用其 hash 值的 num 找出 index。</span></span><br><span class="line">            <span class="comment">//並且透過第二個維度來表示第幾個出現，一開始第一個出現的會是零</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123; <span class="comment">//查詢 query</span></span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; k &gt;&gt; v;</span><br><span class="line">            <span class="keyword">if</span>(num[record[v]].size() &lt; k ) <span class="built_in">cout</span> &lt;&lt; <span class="string">"0\n"</span>; <span class="comment">//如果 k 比 num[record[v]](hash 值) size 小，表示查詢不到輸出 0</span></span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; num[record[v]][k<span class="number">-1</span>] &lt;&lt; <span class="string">'\n'</span>; <span class="comment">//輸出 index</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>Disjoint Set 並查集</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>人生心得 2021年02月06日</title>
    <url>/2021/02/06/life_experence/experence20210206/</url>
    <content><![CDATA[<h2 id="說明"><a href="#說明" class="headerlink" title="說明"></a>說明</h2><blockquote>
<p>覺得最近得自己又開始不安穩了，不安感又開始隱隱作亂，我好怕失敗，我都在努力，能不能。</p>
<p>能不能讓我一定會成功，讓我安心。<br>我不是壞人，我沒有錯，我不應該受到這種折磨。</p>
</blockquote>
<a id="more"></a>

<h2 id="演算法的挫敗"><a href="#演算法的挫敗" class="headerlink" title="演算法的挫敗"></a>演算法的挫敗</h2><p>因為我高中是寫演算法的，但是我演算法沒有寫得比台大頂尖好，但演算法路很小，通常非頂尖就不會有工作。</p>
<p>但是我喜歡演算法，所以我現在還繼續努力，只是遇到太多的挫折就會很受傷，有時候是覺得自己的腦袋不聰明、有時候是別人常會看不起你，認為自己高中沒能力就不要再繼續往這條路走；我很頑固，我不願意承認，到現在都還是不認輸，導致我現在沒人看好，自己也看不好我自己，但我卻還是往這方向走。</p>
<p>希望自己組隊的演算法可以在今年九月打到銀獎，讓現在的我與高中的我可以不愧對自己，能夠告訴自己，自己是做得到的，我才沒有那麼沒用。<br>即使那時候的我嚎啕大哭，我也不覺得丟臉。</p>
<h2 id="自動投資"><a href="#自動投資" class="headerlink" title="自動投資"></a>自動投資</h2><p>雞蛋不應該都放在同個籃子哩，所以我不讓自己的人生輸在演算法上，接了兩個案子，一個是自動投資，但現在也沒有到很棒的起步，由於現在還在摸索中，還沒有辦法穩上腳步。</p>
<p>很怕自己沒有辦法寫成功，怕賠了教授的錢，更怕的是毫無起步，浪費了時間。</p>
<p>嘴巴說我是大學生，我不怕失敗，那是騙人的，我很害怕失敗，我超怕我自己做錯了一切，我沒有人帶，一切都憑著自信與厚臉皮來讓自己表現出我的能力，但其實每一次的我都在緊張，我都在畏懼。</p>
<p>希望自己這次能夠做好這件事，但目前看起來也還有很多要學習，希望學習不會使我茫然。</p>
<h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><p>有一個加州大學柏克萊分校的教授很欣賞我，台灣人。</p>
<p>他找我進入他的公司，我加入了，但問題又來了，雖然我有滿腔的熱血，但是公司認為我是菜鳥，因此我負責的東西比較不是公司主要的，每次我報告都沒有認真聽，久而久之開始累了，對工作也趕到疲憊。</p>
<p>由於我也不太確定自己的薪水，不清楚自己在公司的價值是如何，我常認為自己就像免洗筷一樣，用不到就丟了吧！</p>
<p>希望自己可以找到滿意的薪水，找到工作的安全感，接著努力工作，等待獎賞。</p>
<h2 id="大學"><a href="#大學" class="headerlink" title="大學"></a>大學</h2><p>由於上述的各種原因，大二就有種庸庸碌碌、汲汲營營的感覺，沒有明確的目標再行動，沒有系統化的成<br>長，成績也沒有變高，甚至還掉落，讓人的信心越來越低。</p>
<p>加上自己沒有一個女朋友可以聽自己得內心，我也不擅長將自己的內心打開，只能打在網路上，無論有誰看到我都不在意，因為他們不認識我，不會在背後嘲笑我。</p>
<p>我可能需要一個女朋友來讓我安心，讓她告訴我，我永遠是對的，你的失敗我都會包容，你不會失敗，因為你有我這個女朋友。<br>太夢想了對吧，不過我就是個理想主義者，每次都帶著期待又害怕的心情去面對每件事情，然後開心或者失望的歸來。</p>
<h2 id="內心"><a href="#內心" class="headerlink" title="內心"></a>內心</h2><p>我覺得自己最近成長了很多，可能是青少年(還沒有滿 20 歲)或小大人的轉折點吧，原本的我很悲觀，因為高中時期的我面對的問題都是可以憑者<strong>我的努力</strong>去完成，去改變它；但現在的我發現，我想要解決的問題都不是只要我<strong>努力</strong>，就可以解決的。</p>
<p>於是我拚了命的想要讓自己不斷成功，但換來的是痛苦和難過，在這麼多的情況下，漸漸的我也調適了自己，強制了自己演化。</p>
<p>在跟揮霖老師講到自動投資的專案時，老師有說樂觀是很重要的一件事在；ICPC 2020 比賽時，陳風平學長也說樂觀很重要，這是有研究證明的，當時的我不懂此道理，一心的想要反駁，認為悲觀會使我努力，我努力就能解決問題。</p>
<p>現在的我知道這是錯的，很多問題都不是靠著努力就能解決，有時候能夠成功的點並不是努力，而是機運，經歷過多次失敗後，我終於知道自己需要的是堅強與樂觀，樂於接受事實，並在對問題進行改進，讓下次更好或是認賠殺出，我從來沒有認賠殺出過，我也很討厭這個選項，希望我這輩子都不需要使用這個選項。<br>我想要最完美的過程，最完美的結局，我知道不可能達成，早就失敗了，就像急診室醫生一般，明知道這位患者一定不能被救活，但還是會想要拚了命的救活。醫生想要的不是奇蹟，而是不願意在眼前目送著生命的逝去。</p>
<p>現在的我，是樂觀的，我要不害怕每個挑戰，我不需要面子，我需要的是貨真價值的能力。<br>希望我能夠做得到。</p>
]]></content>
      <categories>
        <category>人生旅途</category>
      </categories>
      <tags>
        <tag>大學Life</tag>
        <tag>人生旅途</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces 1477A - Nezzar and Board (設計解題、暴力搜尋 Brute force)</title>
    <url>/2021/02/10/Codeforces/Codeforces%201477A/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>有一個黑板上有許多數字，你可以透過 \(z = 2x-y\)，其中 x,y 為黑板上的數字且可以相同，你可以將 z 在寫到黑板上，並且 x,y 不移除，試問能否用黑板的數字求出 k？</p>
<p><a href="https://codeforces.com/contest/1477/problem/A" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li>能夠將 \(2x-y\) 進行推導與聯想</li>
<li>了解貝祖定理</li>
</ul>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>好題，太好了，能寫出來的都是天才八。</p>
<p>我們將推導進行分解，方便理解。</p>
<h3 id="Step-A-2x-y-k-推導"><a href="#Step-A-2x-y-k-推導" class="headerlink" title="Step A: \(2x-y = k\) 推導"></a>Step A: \(2x-y = k\) 推導</h3><ul>
<li>我們可以將 \(2x-y = k\)，理解成 \(x-y=k-x\)。</li>
<li>再來我們進行分析，公式推導<ul>
<li>\(x_i = x_j + (x_j - x_k) \)</li>
<li>\(x_a = x_i + (x_i - x_b) \)</li>
<li>\(x_c = x_a + (x_a - x_d) \)</li>
<li>我們就可以將 \(x_c\) 表示為 \(x_c = x_j + (x_j - x_k) + (x_i - x_b) + (x_a - x_d) \)</li>
<li>因此我們公式就成了 \(\sigma (x_i - y_i) = k - x_i\)，sigma 不用白板數字全部累加，只要我們需要的就好，我們也可以針對需要的不斷進行操作，也就是可以 \(y(x_i - y_i) = k - x_i\)。</li>
</ul>
</li>
<li>再來我們可以透過 \(2x-y = k\) 反覆求得 x or y。<ul>
<li>\(2x-y = k = x + (x-y)\)，這裡我們把 \(x + (x-y) \) 視為新的數字(k)</li>
<li>將 k 視為 \(x + (x-y) \) 跟原先的 x 在嘗試一次 \(2x-y\)<br>就可以理解成為 \(2x - [x + (x-y)] = 2x - 2x + y = y\)，可以透過此推導再次求回 y，反之，也可以求出 x，將係數相反放即可。</li>
</ul>
</li>
<li>因為可以透過 \(2x-y\) 不斷求出 x 與 y，因此我們可以理解此數學式 \(\sigma (x_i - y_i) = k - x_i\) 為 \(\sigma (x_i - x_1) = k - x_1\)，其實 \(x_1\) 為隨便一個 x 數值即可，因為每個 x 都可以被 \(2x-y\) 反覆求出。</li>
<li>再來我們將這個公式寫成方程式，\(y_1(x_1-x_1) + y_2(x_2-x_1) + y_3(x_3-x_1) + … + y_n(x_n-x_1) = k - x_1 \)，其中 y 值可以為 0 or 1，不斷產生的 \(x_i\)，如果我們求出的 k 不會用到就可以讓 y 為零。</li>
</ul>
<h3 id="Step-B-貝祖定理"><a href="#Step-B-貝祖定理" class="headerlink" title="Step B: 貝祖定理"></a>Step B: 貝祖定理</h3><p>貝祖定理是關於最大公因數的其中一個定理之一，此定理說明 \(ax+by = dm\)，其中 a,b 為已知數值，m 為 a,b 最大公因數，d 為倍率。</p>
<p>詳細證明請參考<a href="https://zh.wikipedia.org/wiki/%E8%B2%9D%E7%A5%96%E7%AD%89%E5%BC%8F" target="_blank" rel="noopener">貝祖定理 - wiki </a></p>
<p>因此就可以讓貝祖定理套用在 \(y_1(x_1-x_1) + y_2(x_2-x_1) + y_3(x_3-x_1) + … + y_n(x_n-x_1) = k - x_1 \) 此公式，只要證明 \(k - x_1 = gcd( \sigma(x_i- x_1))\) 即可。</p>
<h3 id="Step-C-可是-y-1-x-1-x-1-y-2-x-2-x-1-y-3-x-3-x-1-…-y-n-x-n-x-1-k-x-1-此公式只有用到已知的-x，那我們根據-2x-y-所推出來的數值不就都沒有用到嗎"><a href="#Step-C-可是-y-1-x-1-x-1-y-2-x-2-x-1-y-3-x-3-x-1-…-y-n-x-n-x-1-k-x-1-此公式只有用到已知的-x，那我們根據-2x-y-所推出來的數值不就都沒有用到嗎" class="headerlink" title="Step C: 可是 \(y_1(x_1-x_1) + y_2(x_2-x_1) + y_3(x_3-x_1) + … + y_n(x_n-x_1) = k - x_1 \) 此公式只有用到已知的 x，那我們根據 \(2x-y\) 所推出來的數值不就都沒有用到嗎?"></a>Step C: 可是 \(y_1(x_1-x_1) + y_2(x_2-x_1) + y_3(x_3-x_1) + … + y_n(x_n-x_1) = k - x_1 \) 此公式只有用到已知的 x，那我們根據 \(2x-y\) 所推出來的數值不就都沒有用到嗎?</h3><p>這裡就又一個新推導了，我們假設白板上只有兩個數字 a,b，我們可以給他進行反覆操作</p>
<ul>
<li>\(2a-b\) 是新的數值</li>
<li>\(2b - 2a-b = b - 2a\) 又是新的數值</li>
<li>\(2(2a-b) - b = 4a - b \)，這裡我們假設 \(4a -b = k\)</li>
<li>因此 \(k = 4a - 1b\)，這裡會符合貝祖定理，因此 \( k = gcd(a,b) \)</li>
</ul>
<p>因此我們可以推論出只要是透過原先白板的數值推出的值都一定會符合 \(gcd(a,b)\)。</p>
<h2 id="Step-D-求出公式"><a href="#Step-D-求出公式" class="headerlink" title="Step D: 求出公式"></a>Step D: 求出公式</h2><p>只要 \(\gcd(x_i - x_1) = d(k - x_i) \) 就可以被解出，也就是只要 \(\gcd(x_i - x_1) \ mod \ (k - x_i) = 0 \)，就是有解。</p>
<p>d 則是貝祖定理的數值，並不再本題討論中，詳請須看貝祖定理的證明</p>
<h2 id="參考來源"><a href="#參考來源" class="headerlink" title="參考來源"></a>參考來源</h2><ul>
<li><a href="https://blog.csdn.net/weixin_45697774/article/details/113655626" target="_blank" rel="noopener">Codeforces Round #698 (Div. 2) D. Nezzar and Board（一步步推出来，超级清晰，不猜结论，看不懂来打我 ~ 好题 ） - 繁凡さん</a></li>
<li><a href="https://codeforces.com/blog/entry/87294" target="_blank" rel="noopener">Editorial of Codeforces Round #698 (Div.1, Div.2) - Nezzar’s blog</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E8%B2%9D%E7%A5%96%E7%AD%89%E5%BC%8F" target="_blank" rel="noopener">貝祖定理 - wiki </a></li>
</ul>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>這題真的是一個好題，複雜的推導，又需要用到數學定理，現在回頭想想或許 \(2x-y=k\)，題目這裡其實就在暗示這題可以使用貝祖定理來解，但因為寫題目的經驗不夠多沒有反應到，錯失了寫出這題的能力，好可惜呀！</p>
<p>也要謝謝繁凡さん的 blog，他寫得很詳細，如果沒有他的 blog，我可能還沒有辦法意識到自己到底怎麼錯的，錯在哪，正確的思維要怎麼走。</p>
<p>題外話，我看懂這題花了 3hr，是不是有點太笨了QQ。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1000200</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> t, n, k;</span><br><span class="line"><span class="keyword">int</span> num[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">cin</span> &gt;&gt; num[i]; <span class="comment">//輸入數列</span></span><br><span class="line">        sort(num, num+n); <span class="comment">//排序，以免會有相減，減出負值的冏境發生，讓 gcd 失靈。</span></span><br><span class="line">        <span class="keyword">int</span> x1 = num[<span class="number">0</span>], gcd = <span class="number">0</span>; <span class="comment">//c++ 的 gcd 在其中有一值為 0 時，gcd 為另一數</span></span><br><span class="line">        <span class="comment">//這裡不可以用 1，這樣最大的公因數永遠會是 1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) gcd = __gcd(gcd,num[i] - x1); </span><br><span class="line">        <span class="comment">//開始找所有數列的最大公因數</span></span><br><span class="line">        <span class="keyword">if</span>((k - x1) % gcd == <span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">"YES\n"</span>;</span><br><span class="line">        <span class="comment">//如果可以整除表示符合貝祖定理，證明可解。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"NO\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="思考流程"><a href="#思考流程" class="headerlink" title="思考流程"></a>思考流程</h2><p>透過紙筆與黑板而思考而成的片段，放在網路上供我紀念XD</p>
<p>錯誤的程式碼就不放上來讓大家見笑了QQQQ。</p>
<blockquote>
<p><img src="https://i.imgur.com/0bD4xXC.jpg" alt=""></p>
</blockquote>
]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>設計解題</tag>
        <tag>程式解題</tag>
        <tag>Codeforces</tag>
        <tag>暴力搜尋 Brute force</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa1237 - Expert Enough?(水題)</title>
    <url>/2021/02/10/UVa/UVa1237/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>有一家公司要建立汽車資料庫，會給你很多筆的汽車品牌與他的最低價與最高價，之後在給你一個價格請你幫忙查詢此價格有哪一個汽車品牌落在區間？</p>
<p>如果這個價格有兩個汽車品牌以上的話或都沒有汽車品牌在此價格就輸出 UNDETERMINED，其他都輸出牌子。<br><a href="https://onlinejudge.org/index.php?option=onlinejudge&Itemid=8&page=show_problem&problem=3678" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="觀念重點"><a href="#觀念重點" class="headerlink" title="觀念重點"></a>觀念重點</h2><ul>
<li>選擇適合的演算法</li>
<li>評估程式好寫以及題目最大容許的時間複雜度</li>
</ul>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>這題其實用程式碼寫可以非常簡單，<del>不然怎麼可以叫水題嘛XD</del>，但這題可以直接用線性查詢的方式查出，由於題目的資料庫資料最大只會來到 10000，且查詢只會有 1000，因此這題的時間複雜度可以到 \(O(10^7)\)，基本上所有的程式題目都會容許此時間複雜度，因此我們就直接用最暴力的方式解即可。</p>
<p>建議 UVA 的題目都已嚴格輸出為導向，我有時候常常會因為這個卡很久QQ。</p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>其實這題我原本是想要用線段樹來解的，但寫到一半發現，要離散化的線段樹我沒有寫過呀QQQ，如果要寫要花很多時間呀，而且中途有遇到很多障礙QQ。</p>
<p>後來在翻網路資料時，意外看到有篇說這題可以暴力輾過，我才想起這題的時間複雜度不高呀，我為甚麼要讓自己走 hard 路線了，應該走 easy 路線呀！</p>
<p>對於每份題目，應該要能夠寫出最符合題目要求且讓自己編寫速度最快的演算法，畢竟比賽分秒必爭，AC 卻不看程式碼的品質。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 10020</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> t, h, m, l, p, d, q; <span class="comment">//題目的輸入資訊</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Com</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r; <span class="comment">//l 最低價格 r 最高價格</span></span><br><span class="line">    <span class="built_in">string</span> v; <span class="comment">//v 公司名子</span></span><br><span class="line">&#125;;</span><br><span class="line">Com com[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> name = <span class="string">""</span>; <span class="comment">//輸出汽車品牌</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; d; i++)&#123; <span class="comment">//開始暴力查詢</span></span><br><span class="line">        <span class="keyword">if</span>(p &gt;= com[i].l &amp;&amp; p &lt;= com[i].r)&#123; <span class="comment">//如果在此區間就進入 if</span></span><br><span class="line">            <span class="keyword">if</span>(name == <span class="string">""</span> ) name = com[i].v; <span class="comment">//如果還沒有被輸入汽車品牌，那就輸入</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="string">"UNDETERMINED"</span>;</span><br><span class="line">            <span class="comment">//表示前面有被輸入，這個價格有兩個以上的汽車品牌，因此輸入  "UNDETERMINED"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(name == <span class="string">""</span> ) name = <span class="string">"UNDETERMINED"</span>; <span class="comment">//沒有品牌，輸輸=入  "UNDETERMINED"</span></span><br><span class="line">    <span class="keyword">return</span> name; <span class="comment">// 輸出 name</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"out.txt"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; d;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; d; i++) <span class="built_in">cin</span> &gt;&gt; com[i].v &gt;&gt; com[i].l &gt;&gt; com[i].r;</span><br><span class="line">        <span class="comment">//資料庫輸入</span></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; q;</span><br><span class="line">        <span class="built_in">string</span> name;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; q; i++)&#123; <span class="comment">//查詢</span></span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; p;</span><br><span class="line">            name = solve(p);</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; name &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>水題</tag>
        <tag>UVa</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa927 - Integer Sequences from Addition of Terms(數論 Math theorm)</title>
    <url>/2021/02/10/UVa/UVa927/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>有一個數列，有三種模式，分成 a,b,c，index 從 0 開始，且有一個數字 d，a 為主要的數列，b 數列的方式是重複 \(a_i\) 的數列 \(i * d\) 次，而 c 則是一個 hash 的數列，公式如下<br>\(a_n = c_0 + c_1 n + c_2 n^2 + … + c_i n*i\)，注意，這裡的 n 是第 n 項，而非 sigma 的意思。</p>
<p>給你 c 數列與 d，還有一個數字 k，詢問 \(b_k\) 的位置？</p>
<p><a href="https://onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=868" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li>了解題目意思，懂得基本數學觀念 </li>
<li>善用數學的等差公式概念</li>
</ul>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>我們主要的目的是要找出 \(b_k\) 的位置，由於 b 數列會隨著 d 遞增，但 b 會重複 \(a_i\) 的數列，因次我們要先找出 \(a_i \)，但題目只給我們 c，因此我們要用 c 去推 a，這時候題目的公式就派上用場了。</p>
<p>那現在我們要找出的就是 \(b_k\) 是用到 a 的那個數值了。</p>
<p>怎麼找？</p>
<p>透過等差公式。</p>
<p>由於b 數列的方式是重複 \(a_i\) 的數列 \(i * d\) 次，與等差數列的概念吻合，因此我們進行疊代，找到一個數值(定義 p)可以 \(\geq k\)，再將 p 去套入公式即可，這裡的 p 是公式的 n。</p>
<p>需要特別注意的是那條最長的數列，第一個為數列長度，然後 index 從 0 開始。</p>
<h2 id="參考來源"><a href="#參考來源" class="headerlink" title="參考來源"></a>參考來源</h2><p><a href="https://blog.csdn.net/mobius_strip/article/details/73590707" target="_blank" rel="noopener">UVa 927 - Integer Sequences from Addition of Terms - 小白菜又菜</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>肯定是我的英文太弱才讓我看英文的數學題讓我這麼痛苦QQ，一開始的我把 n 理解為最後一項，害我整個程式都寫錯，看別人的 uva 詳解我才知道這題要怎麼解，題目意思是如何，表示我對英文的數學理解力還不夠。</p>
<p>再多刷些 uva 題目增強八。</p>
<p>我還將那條最長的數列以為全部都是數列的值，都用 stringstream 去解..，後來才發現第一項是 n，index 從 0 開始，嗚嗚。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 10020</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> C, d, k, temp1, clen; <span class="comment">//clen = c 數列 length</span></span><br><span class="line"><span class="keyword">int</span> c[MAXN], a[MAXN]; <span class="comment">//數列 c 與數列 a</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = d, y = <span class="number">0</span>, p = <span class="number">0</span> ; <span class="comment">//y 為 a_i，p 判斷當前等差數列的最大長度</span></span><br><span class="line">    <span class="comment">// x 則是下底</span></span><br><span class="line">    <span class="keyword">while</span>(p &lt; k)&#123; <span class="comment">//如果當前等差數列的最大長度還沒有大於 k 就繼續</span></span><br><span class="line">        y++; <span class="comment">//累加，進行疊代。</span></span><br><span class="line">        p = y * (d + x) / <span class="number">2</span>; <span class="comment">//等差數列公式</span></span><br><span class="line">        <span class="comment">//cout &lt;&lt; "p is" &lt;&lt; p &lt;&lt; '\n';</span></span><br><span class="line">        x += d; <span class="comment">//下底加大</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; "y is " &lt;&lt; y &lt;&lt; '\n';</span></span><br><span class="line">    <span class="keyword">int</span> ans = c[<span class="number">0</span>], cnt = y;  <span class="comment">//cnt 計算 n * i 的倍數</span></span><br><span class="line">    <span class="comment">//ans 是答案，由於第一項不乘以 n，且題目 k 最小為 1，因此我設定第一項是最小答案</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= clen; i++ )&#123;</span><br><span class="line">        ans += c[i] * cnt; <span class="comment">//題目公式</span></span><br><span class="line">        <span class="comment">//cout &lt;&lt; c[i] &lt;&lt; ' ' &lt;&lt; cnt &lt;&lt; '\n';</span></span><br><span class="line">        cnt *= y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"out.txt"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; C;</span><br><span class="line">    <span class="keyword">while</span>(C--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; clen; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= clen; i++) <span class="built_in">cin</span> &gt;&gt; c[i]; </span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; d &gt;&gt; k;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; solve() &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>數論 Math theorm</tag>
      </tags>
  </entry>
  <entry>
    <title>跟風鈴在一起的日子</title>
    <url>/2021/02/11/life_experence/love_windchimes/</url>
    <content><![CDATA[<h2 id="說明"><a href="#說明" class="headerlink" title="說明"></a>說明</h2><blockquote>
<p>這是高三那年寒假和風鈴在一起，那段美好的日子的心得，以及我不好好珍惜的懺悔。</p>
<p>原本是沒有想要打成一篇 blog，但是真的太喜歡她了，每次想到他都會心痛，所以還是打成一篇文章，看能不能讓自己的心情變好。</p>
</blockquote>
<a id="more"></a>

<h2 id="認識風鈴"><a href="#認識風鈴" class="headerlink" title="認識風鈴"></a>認識風鈴</h2><p>我認識風鈴是在 soul(交友軟體) 認識的，我的好朋友岳昇告訴我這個軟體，讓我進去聊聊天散散心，由於這是我第一次玩交友軟體，很新鮮，因此我認真、用心對待每一個人，他會跳出周遭附近有沒有人，就可以選擇一起聊天。</p>
<p>有次我在家時跳出通知，並且此人只離我不到 500m，由於離我非常近，特別讓我有一股親切感，我就主動密他、聊天，而他也因為難得有人離他這麼近，所以也很熱切跟我聊天。</p>
<p>我印象最深刻的是，我向他炫耀說我是高職金手第六時，他用崇拜的字句告訴我，我是個很厲害的人。那句話我想忘都忘不掉。</p>
<p>雖然越長大越認為自己的成就不算成就，不斷地在自我成長、自我認知吧。</p>
<p>後來越聊越有感情，我們也交換了照片，他給我的照片沒有正臉，是一個在塑膠球池中婷婷而立的小女孩。</p>
<h2 id="在一起"><a href="#在一起" class="headerlink" title="在一起"></a>在一起</h2><p>聊了三四個月後，我們互有好感，我主動向他告白，他也接受了！對那時的我感到非常開心，我感覺到了我的人生，之後回去大陸娘家時，我都在跟他聊天，有點無心注意大陸的新事物。</p>
<p>慢慢地開始想要約會，但因為她家管得嚴，沒有那麼容易出來，每次出來我都很珍惜，我都緊緊的抱著她、欺負她、玩弄他，非常喜歡跟他在一起的時光，通常都在河濱公園散步，在蝴蝶公園天台談心或橋下抑或著是些 XA 的地方，做些只有情侶才可以做的事情。</p>
<p>而隨著約會的次數變多，我變得食髓知味，不斷的要求她每周六日其中一天都要來陪我，他只要不陪我我就很生氣，因為我會覺得我得不到她的愛，而把氣出在他身上，常常對他冷言冷語、或是情緒勒索，但那時候的我不懂這些事情，充分地把<strong>大衞</strong>給表達出來。</p>
<p>我也給了她我最愛的蜘蛛人吊飾，希望他可以隨時掛在身邊就能想到我。</p>
<blockquote>
<p><a href="https://drive.google.com/file/d/1Klz5eyKh1mI7IiEFB0qMM9ybPgq9r2Yy/view?usp=sharing" target="_blank" rel="noopener">屬於我的秘密 1 -被加密只有我能看到</a><br><a href="https://drive.google.com/file/d/1iCr236WaG4bAcPDpCLUEmc2S-eN0xc1p/view?usp=sharing" target="_blank" rel="noopener">屬於我的秘密 2 -被加密只有我能看到</a></p>
</blockquote>
<h3 id="甜蜜"><a href="#甜蜜" class="headerlink" title="甜蜜"></a>甜蜜</h3><p>記錄些我之前跟她甜蜜的部分。</p>
<p>我還記得我之前常常會要求他做些當下不可能做到的事，然後再給他些小懲罰(情趣)XD，他的腰很怕癢所以我常常會欺負他www，那時候真的好開心，好幸福呀！</p>
<p>有次則次在蝴蝶公園的天台我假裝生氣，我跟他說要讓他做一件事來讓我消氣，他踮起腳尖壓著我肩膀像我臉頰親下去，輕輕的一聲 chu 的聲音，讓我心花怒放，當下認為全世界只有他最可愛，只有我能夠享受到他這份可愛，那我一定是全世界最幸福幸福的人，我也要讓她幸福！</p>
<p>在天橋下從背後抱住她，每次只要一聽到腳步聲就會被嚇到，就像那時候的我小心翼翼地想要保護這份愛情般，明明只是簡單的抱抱，但卻能讓我永不忘記。</p>
<h2 id="分手"><a href="#分手" class="headerlink" title="分手"></a>分手</h2><p>沒有一個女生是喜歡自己的男朋友冷言冷語、情緒勒索，他漸漸的對我感到灰心、感到難過、感到失望，加上交往的事情曝光，由於 XB 的關係，他爸媽有給她一次機會，只要不跟我見面，網路上的話就可以，那時候的我也說好，但那時候的我根本忍不住，就像飢餓的獅子一般，渴望著。即使不可以見面，也希望他可以馬上回我、XC，說些愛我的話。</p>
<p>有天，他爸看到了，被強制分手了，他爸把她的對外聯絡方式都沒收了，我內心大受傷、我當時用極我一切的知識量想要成功，但想當然而知的，一個高三生鬥得過一個事業有成的大人嗎？也許建中生可以，但我真的沒辦法。</p>
<p>我拚了命的想要連絡他，但我越是拼命，越達到反效果，但那時候的我已經喪失判斷能力了，明明是一個會寫程式的人，卻完全沒有辦法理解這些；漸漸地，隨著他被爸媽不斷地碎念、我不斷給他壓力，他放棄了，他不想再那麼累了。</p>
<p>寫了一封信給他，他也哭了很久，他也回寫給我，我嚎啕大哭，我超級捨不得，我超級不想要這個結局，為甚麼要這樣對我。</p>
<p>同時，這時候的我因為金手獎的關係去了日本參訪，在日本的某處(東京，有很大的天台，很多 cosplay與藝文產品)，好不容易可以讓她跟我打電話，那時候的我其實在流淚，但我忍住，用很開心的語氣跟他聊天，但她旁邊太多朋友了，只能草草聊天，就掛掉。</p>
<p>隔天，他爸又發現跟我聊天，他爸更生氣了，強制分手，但風鈴還是喜歡我。</p>
<p>而有天她說，她心情爆炸了，這個時候的我就像純情少年一樣一心只想找他，就算風鈴果斷地跟我說不要也是一樣，我還是拚了命的去她家樓下想要找他；此時此刻的我就像偶像劇的主角一樣浪漫，一樣的執著，只可惜的這場戲的男主角換來的是被封鎖的下場，而不是換來美好大結局。</p>
<p>從那天起，我深刻地知道了一件事，努力才沒有辦法解決所有事，真的會有無能為力的時刻，我的價值觀完全崩壞了，原本的我深信著，只要我努力，一定可以完成每件事情。</p>
<p>下次他密我，就是他將我給他的蜘蛛人吊飾還給我，他要跟我斷乾淨了。</p>
<p>從那次之後她對我的態度只有敷衍，我對他的態度只有溫暖，但他這時候怎麼會需要我的溫暖呢？需要的只有我的離開，他越敷衍，我越想要對他溫暖，那時的我相信只要這樣，我就一定可以追回他，一定可以打動她的心。</p>
<p>理所當然的，這不是在演偶像劇，這是人生，當然失敗了。</p>
<h2 id="重新相遇"><a href="#重新相遇" class="headerlink" title="重新相遇"></a>重新相遇</h2><p>在我考上北科，大一前的暑假，我在大安森林公園玩團康，那時候我們相遇了，我沒有看到他，但她看到我了，他在那時重新密了我，我那時候很開心，以為他不生氣了，但換來的還是他的敷衍、厭惡和冷漠。</p>
<h2 id="第三次相遇"><a href="#第三次相遇" class="headerlink" title="第三次相遇"></a>第三次相遇</h2><p>第三次是我在服務學習時遇到，那時候是在大一下的聖誕節，我在捷運府中站募款，是盲人基金會的志工讓我們體驗弱勢，此時風鈴就看到了我，也主動密我今天有沒有遇到我，這次他的態度就友善很多，像是朋友的感覺，從那次開始我們就陸陸續續地聊天，說是陸陸續續，但其實也只是一天聊一次，離原本的開心我認為還是少了很多，但只少有好轉了。</p>
<p>其實原本我的內心是很害怕跟他聊天的，我怕我想起被傷害的樣子，想起盡力但還是失敗的樣子，但他已經密我了，那我肯定會回他。</p>
<p>至於為甚麼？因為我愛他。</p>
<p>愛到卡慘死。</p>
<h2 id="重新聊天"><a href="#重新聊天" class="headerlink" title="重新聊天"></a>重新聊天</h2><p>再重新聊天時，我自己有想要找他復合，但都被他拒絕，他在這段過程中也說過，我之前有在一起的時候跟他說過，<strong>我想要找另外一個女朋友，深深的傷害他的心</strong>，從那天起，我覺得我對他的只剩下抱歉，我想要再次給他溫暖，來對我的過去負責。</p>
<p>我好希望我能夠給她快樂，我希望她每天都是快樂，如果是現在的我絕對可以讓我跟他的互動是快樂的，他不會受傷。</p>
<p>其實我每天都想著要跟他復合，我好想重新再跟他在一起，我求了多少次的籤，就是希望我可以在一次跟她在一起，消除我的不安，透過信仰來解除我的安全感，因為這次我明顯的知道，我的努力不夠，但我沒辦法再做甚麼了，所以我只好求籤，希望真的可以實現這個願望。</p>
<p>我想要跟他在一起，可以幸福的過每個日子。</p>
<p>但我們疏遠太久了，可能要能回到再一次憶起開開心心的日子，可能不只需要我的努力，也需要他的努力。也許我現在正為了喚起他的努力而努力著吧。</p>
<p>我曾經有問她未來有可能在一起嗎？她跟我說<strong>她真的不知道</strong>，但現在的我已經知道了，會在一起是我的奢望，就像我期望爸媽能否永遠陪在我身邊，永不老去般，明明知道不可能，但還是會發自內心的期望。</p>
<h2 id="害怕"><a href="#害怕" class="headerlink" title="害怕"></a>害怕</h2><p>老實講，跟他在一起我會害怕，他家很有錢，從她告訴她家的房子是那棟豪宅開始，跟我家差太多了；他吃的伙食跟我家吃的伙食差太多了，當她買上海茶樓，我吃的是外面的便當，他讀的是雙語學校、我讀的是公立高職，他的爸媽職業是上流、而我的爸媽只是普通的員工，在這種情況下，我真的好怕我被他的爸媽嫌棄，我好怕我沒辦法給他很好的生活，即使他都會說他會養我，但我真的好害怕。</p>
<p>這些不安感直到現在還是無法消除掉，我真的好怕…。</p>
<p>他讀的學校將近一學期 18 萬而我的只要 4000…，所以我真的好害怕，害怕她不喜歡我，害怕我沒有給他面子，怕她被其他人閒言閒語。</p>
<p>在這種情況下，我慢慢了解了門當戶對的重要性，就算優勢方不嫌棄弱勢方，但弱勢方還是會因為自己的內心壓力而抬不起頭，整天存活在壓力與恐懼的環境下。</p>
<p>我想要讓我自己賺多點錢，有能力可以去當一個門當戶對的人，不要活在壓力與恐懼的環境下，更不要因為自己沒有門當戶對而失去了我所想要的愛情。</p>
<h2 id="似乎約成了每年送禮物的習慣"><a href="#似乎約成了每年送禮物的習慣" class="headerlink" title="似乎約成了每年送禮物的習慣"></a>似乎約成了每年送禮物的習慣</h2><h3 id="2020-的禮物"><a href="#2020-的禮物" class="headerlink" title="2020 的禮物"></a>2020 的禮物</h3><p>由於我想要見到他，所以我提出了一個小理由，希望他可以出來，理由就是送他生日禮物XD，雖然很爛…。但她還是同意了，我很開心，那時候剛上大一的我想說希望能給他最好的，但是因為那個時候的我沒有經濟能力，我只能送給他 500 元的兔耳帽，(旁邊有兩條線垂吊下來，如果壓最末端那麼兔耳就會翹起來)，但我明顯的知道我能給他的最好，卻可能連他的平常都沒有。</p>
<p>但她還是願意接受我的禮物，也還願意稱讚我的眼光，那是讓我很感動的一件事，至少可以讓我的自尊心或責任心好過一些，他是個溫柔的人，我不知道她說的是真的還是假的，但他還願意對我說場面話就讓我很開心了，我真的覺得很對不起他…。</p>
<p>我原本還想要摸她的臉頰，但是被他躲掉了，她害怕地看著我。我感到了罪惡，我好害怕我會再次傷到他。</p>
<h4 id="2021-的禮物"><a href="#2021-的禮物" class="headerlink" title="2021 的禮物"></a>2021 的禮物</h4><p>這次送給他一個小企鵝，禮物沒有比上次貴，但是是我精挑細選的，曾經在他的 ig 上看到他喜歡企鵝，於是我就買了一個小企鵝，我認為很可愛、我想他應該也會認為很可愛吧XD，因為她的包裝紙破掉了，於是我就去文具店買了禮盒與卡片。早上在麥當勞寫著卡片，希望自己的情意可以傳達到，我害怕等到他的回應，因此我不敢直接密他，透過卡片寫吧，反正他一定不會回答我在卡片上問他的事。</p>
<p>這次見面比 2020 好些，我們這次的互動變好了一點，至少聊了 10 句話，而且有感覺到他有比較開心些，他身高也變高了，而且他身上的香味還是沒變，我依舊聞到我跟他在一起的香味，我好想要再多聞一些，讓我回憶起和他約會快樂的時光，而不是那些透過網路被他敷衍的時光。</p>
<p>我一如往常地想要肢體碰觸，但他一如往常的躲開、避免我，希望未來可以好點。</p>
<p>回家的路上他告訴我說 youbike 在哪裡，似乎有變好、但又沒有變好的感覺，我真的好想要他跟我好啊..。</p>
<p>能不能在一次跟我好，在一次在一起就好，這次讓我用心無愧的對待他。就算是信仰也好，能幫我這次嗎</p>
<h2 id="我的成長"><a href="#我的成長" class="headerlink" title="我的成長"></a>我的成長</h2><p>這次的愛情事件後，他成為了我內心中的一個精神支柱，我知道過了兩年，那個她已經有所成長，我喜歡的那個風鈴可能已經變成了豊翎，有更好的人適合他。</p>
<p>上了大學後，我的內心加速長大，有些事情是我大學才能豊會到的，對情人的態度、不該對自己好的人惡劣、自私的心、負面的態度…等，很多事情是他教會我的，這時候就會覺得自己很不好，自己很虧欠她，從她身上學會這麼多，但是我卻讓她哭了那麼多，如果有機會真的想要在讓她一次快樂。</p>
<p>不是贖罪的心，而是發自內心的喜歡。</p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>今天是 2021/02/12，他今天還沒有回我訊息，也沒有跟我說新年快樂，好難過…。</p>
<p>其實我今天一直在想他，我真的好喜歡他喔…。我原本很早就想好要寫我跟他愛情故事然後紀錄，但遲遲沒有動力，但是今天我真的太想它了，受不了了，甚至到了一想到她心就會痛的地步了，於是我就寫下了和他在一起的全部故事，希望未來的我可以記得。</p>
<p>也希望未來的我可以再一次跟她在一起。</p>
<p>我也希望在我現在有點能力的時候可以照顧他，補足我之前對他的不好、讓過去有缺失的我可以改進、讓現在比較有能力的我可以陪伴她，但我知道，現在的她不需要我、過去的他也不需要我。</p>
<p>但我就是想做一些甚麼阿…，我真的很難接受透過我的努力卻沒辦法達到我期望的結果，這種感覺、這種事實。</p>
<p>豊翎，可以的話，我們可以在一次在一起嗎？如果不行，也可以告訴我嗎？至少讓我死心，不要讓我的心情在起伏不定可以嗎QQ。</p>
<p>最後，祝你永遠都快樂，不會有不開心，不要因為我而造成內心傷害。</p>
<h2 id="附註"><a href="#附註" class="headerlink" title="附註"></a>附註</h2><p>XA XB 那些，是我個人美好的回憶，我不想讓其他人知道，因此我把這些寫在其他地方，只讓我自己看到。</p>
<h3 id="寄給風鈴的信"><a href="#寄給風鈴的信" class="headerlink" title="寄給風鈴的信"></a>寄給風鈴的信</h3><ul>
<li><a href="https://drive.google.com/file/d/1h-aZqjpJqaX_K5WRY76qJr9pb8Qd1QLT/view?usp=sharing" target="_blank" rel="noopener">txt 只有我才打得開</a></li>
<li><a href="https://drive.google.com/file/d/1R6B0GOip5UM2JXeZCM5yNQuLBtc0pXuV/view?usp=sharing" target="_blank" rel="noopener">2019/06/28 給風鈴 (online-audio-converter.com)</a></li>
<li><a href="https://drive.google.com/file/d/1U8gFzfcFfv2yRXNjaoIhxAKdPkxRyhBQ/view?usp=sharing" target="_blank" rel="noopener">2019/04/23 給風鈴的一封信 </a></li>
<li><a href="https://drive.google.com/file/d/1fLuSqoJW1vkf4hssAMDAZMUVbLpG7h17/view?usp=sharing" target="_blank" rel="noopener">2020/01/29 給許豊翎的一封信 2次，2020 生日禮物的時候想給的</a></li>
</ul>
<h3 id="訊息對話截圖"><a href="#訊息對話截圖" class="headerlink" title="訊息對話截圖"></a>訊息對話截圖</h3><ul>
<li><a href="https://drive.google.com/file/d/1JxKGOkouUrqWXoeQ3GXwNP0D5fsfwemz/view?usp=sharing" target="_blank" rel="noopener">對話 1</a></li>
<li><a href="https://drive.google.com/file/d/1dRfTq1oso7gKzt-oy50iVBlfR4QRA6OO/view?usp=sharing" target="_blank" rel="noopener">對話 2</a></li>
<li><a href="https://drive.google.com/file/d/1vMLLOe8eymCvVh984rx2uegMe4hmryev/view?usp=sharing" target="_blank" rel="noopener">對話 3</a></li>
<li><a href="https://drive.google.com/file/d/1PpGIe5R3aYDwOItSLl2AQRqPcWV-gNG3/view?usp=sharing" target="_blank" rel="noopener">對話 4</a></li>
<li><a href="https://drive.google.com/file/d/11yNa2Ssj6Y0QQgozR3fK9WZCOFEYrKoB/view?usp=sharing" target="_blank" rel="noopener">私密 - 對話 5</a></li>
<li><a href="https://drive.google.com/file/d/1SxK8KVtnbN89y3DIFp8FuxN--ahmYNUt/view?usp=sharing" target="_blank" rel="noopener">私密 - 對話 6</a></li>
</ul>
]]></content>
      <categories>
        <category>人生旅途</category>
      </categories>
      <tags>
        <tag>大學Life</tag>
        <tag>人生旅途</tag>
        <tag>高中 life</tag>
      </tags>
  </entry>
  <entry>
    <title>電影觀後感 - 靈魂急轉彎 (5/5)</title>
    <url>/2021/02/12/movie/soul/</url>
    <content><![CDATA[<h2 id="前情概要"><a href="#前情概要" class="headerlink" title="前情概要"></a>前情概要</h2><blockquote>
<p>喬（Joe Gardner）人過中年仍抱有在爵士樂團擔任鋼琴手的夢想，卻懷才不遇只能在紐約一所國中擔任兼職音樂教師。一日，透過以往學生阿寇（Curley）的引薦，喬得到與知名爵士樂手桃樂絲（Dorothea Williams）面試的機會，桃樂絲對於喬渾然忘我的即興演出印象深刻，同意他晚上來二分音符酒吧參加樂團表演。喬深感自己夢想即將成真，在狂喜之下衝出街道，然而大意掉進人孔重傷昏迷。當喬恢復意識時，發現自己瀕臨死亡邊緣，成為一個靈魂，身在名為作古畢業班（Great Beyond）的空間，三位靈魂告知喬此處是靈魂的終點，隨後消失於空間盡頭的白光，見到此景的喬陷入恐懼，朝邊界奮力掙扎，意外落入名為投胎先修班（Great Before）的空間，亦稱作人生研討會（The You Semina）。</p>
 <div class="video-container"><iframe src="https://www.youtube.com/embed/zXTVxkd9KUY" frameborder="0" loading="lazy" allowfullscreen></iframe></div>

<p><a href="https://zh.wikipedia.org/wiki/%E9%9D%88%E9%AD%82%E5%A5%87%E9%81%87%E8%A8%98" target="_blank" rel="noopener">資料來源</a></p>
</blockquote>
<a id="more"></a>

<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>整體我非常喜歡這部片，以下是我的靈魂急轉彎心得。</p>
<p>但由於我寫電影心得的時間拖太長，可能有些地方寫得不好，還請大家見諒。</p>
<h3 id="主角在中學當代課老師"><a href="#主角在中學當代課老師" class="headerlink" title="主角在中學當代課老師"></a>主角在中學當代課老師</h3><p>我認為這部片很吃情感與人生經驗，沒有這種不斷失敗、渴望成功的人會感受不到主角為何拼命，主角熱愛爵士樂，夢想是想要加入知名的爵士樂團，但因為現在的環境只能讓他在中學老師當代課老師，這種離自己夢想越來越遠，離妥協越來越近的無力感，會讓人想愈現實妥協。</p>
<p>人的適應力很強，只要溫水煮青蛙，可以讓每位抱有理想的英雄都成了現實中的螺絲釘。</p>
<p>男主角收到了學生的邀請，可以去當知名爵士樂團的臨時演員，男主角的專注演奏感化了樂團，樂團願意讓他一起加入，但男主角卻沒有得到喜悅，但這明明是他迫切想要得到的呀，但卻為甚麼會這樣呢？</p>
<p>我能理解，有的時候我們所渴望的是追逐目標的感覺，但我們卻深不自知，只覺得我一定要達成目標我就會很快樂，我原本以為我拿到金手這就是我的人生快樂之一，但我卻發現當我拿到金手後，我還是我，完全沒有改變，明天還是要去上學，過著一樣的生活。</p>
<p>那我是為了甚麼才這麼努力？為了目標，這樣說對嗎？對。<br>那我努力後為甚麼沒有成就感？我目標不是達成了嗎？</p>
<p>因為我們達成了，在完成目標的同時，也象徵著我們失去了目標，也就表示自己失去了追逐目標的權利，當我們下次再燃起幹勁一定就是我們要追逐新的目標。</p>
<h3 id="小女孩的轉變"><a href="#小女孩的轉變" class="headerlink" title="小女孩的轉變"></a>小女孩的轉變</h3><p>老實講，我很喜歡小女孩。<del>犯罪預告</del></p>
<p>小女孩對音樂的熱愛在班級中無人能比，但也就因為無人能比才無人理解，但小女孩演奏樂器到忘我的境界時卻被班上的人嘲笑，小女孩因此感到丟臉，因為感到丟臉，不想要與他人不同，因此希望自己在班上吹奏音樂時可以不要出現忘我的境界。</p>
<p>ummm…這在現實中很常發現，對八。很多時候大家都會做一件事做到忘我，但其他人卻沒有時，視覺的反差感會讓人感到害羞，進而封閉自己忘我的境界，特別在中學、人格發展的階段如果經常遭到此對待會很容易讓自己再也不敢達到忘我的境界，失去了每個人最獨有、最能表達自己的時候。</p>
<p>而男主角在此時也做出了正確的舉動，制止了他人，但在中學時期，朋友帶給自己的觀念總比老師講述給自己的觀念有用多了，小女孩最後還是決定想要跟老師說放棄練習樂隊。</p>
<p>但當 22 號支持他放棄音樂時，他則反悔了，突然自願的吹奏起音樂，又重新想要繼續在樂隊練習，我認為小女孩只是想向往常一般從男主角這邊獲得勇氣與支持，但因為現在男主角的身體正被 22 號駕駛，才會對小女孩說放棄也不錯，但小女孩壓根從沒有這樣想，他只是想要找到能夠理解他的人，他以為老師也認為他不喜歡樂器了！趕緊吹奏一首樂器來表示自己其實很想要繼續留在樂隊，也很害怕自己又被老師勸退樂隊，趕緊跟老師說我下禮拜練習而趕快下樓。</p>
<p>這種感覺很棒啊，中學時期就有屬於自己的人生動力去學習、去成長，而沒有被人生的一些娛樂所迷惑。不像我常常被愛情、成績、人際關係所迷惑….QQ，能夠找到自己想要的事情去成長且能夠不斷達到忘我的境界，當從忘我的境界回來時，最有成就感、人生中滿足的一刻嗎？</p>
<h3 id="靈魂先修班-死後的世界"><a href="#靈魂先修班-死後的世界" class="headerlink" title="靈魂先修班(死後的世界)"></a>靈魂先修班(死後的世界)</h3><p>在男主角進入靈魂先修班後，導師們帶領男主角去看著靈魂們去領取不同的個性，在萬物堂體驗各個事物，領悟自己的火花，用這樣的方式去描述其實很有趣，現在的我們無從推得我們的個性到底是怎麼來的，所以電影透過其實有萬物隨便的指定的你的個性這種方式來告訴大家每個人的個性其實都不是自己決定的，都是傑瑞們<strong>隨便</strong>給的。</p>
<p>而靈魂們就透過導師們的隨意，再加上自己跟著導師找到屬於自己的火化後，一同再次加入地球，成為下一個新生命。</p>
<blockquote>
<p><img src="https://i.imgur.com/EBHZ6Q0.jpg" alt="靈魂先修班"></p>
</blockquote>
<h3 id="22-號的個性"><a href="#22-號的個性" class="headerlink" title="22 號的個性"></a>22 號的個性</h3><p>22 號是一個與眾不同的靈魂，他跟其他的靈魂不同，他與其他人的價值觀不同，在靈魂急轉彎中死後的世界有著，他不成熟，我們不確定他在生前遇到了甚麼，但我們知道他生前肯定沒有很快樂、沒有受到很正面的影響，他看甚麼事情都是負面的，從來沒有想要體驗生活，也並不認為體驗生活、找到自己的火花是一件快樂的事情。</p>
<blockquote>
<p><img src="https://i.imgur.com/gE5dtB9.jpg" alt="體驗萬物"></p>
</blockquote>
<p>由於他有著不可撼動的價值觀，因此他在對待導師時總是可以找到導師們的弱點進行反擊，讓導師們生氣，但男主角意外的成為導師，且她的生活是不像其他導師們般光鮮亮麗，有著成功的事蹟、幸福的人生，這讓 22 號卸下心防，也很好奇，這個人是甚麼怪咖，生活這麼爛還想要回去，就只是為了演奏 sax？</p>
<p>22 號帶她去找船長進入迷失的靈魂中，如果是一位專注的人則會在泡泡中專心，如果是一位執著的人則會成為迷失的靈魂，被黑霧壟罩，我超喜歡這種世界觀的，社會不就是如此嗎？但我們對一件事情執著到近乎瘋狂時常常會做出一些傷害他人或自身的事情，而不自知或是置之不理，這些人不就是迷失的靈魂嗎？</p>
<h3 id="男主角回去地球參加演出"><a href="#男主角回去地球參加演出" class="headerlink" title="男主角回去地球參加演出"></a>男主角回去地球參加演出</h3><p>男主角太想要回去地球，於是船長幫助他回去世界，但卻發現 22 號進去到男主角的身體，而貓的身體裡面有男主角？其實這裡我有一個地方很好奇，那貓原本的靈魂呢？</p>
<p>22 號與男主角體驗了人生的事物，對於男主角是平常在不過的事情，但對於 22 號卻是非常有趣的、新鮮的，22 號在導師那邊所體驗不到的事情，他在地球上都體驗到了！我認為導師沒辦法撼動他是合理的，你跟一個不會寫字的人說，現在的人可以透過寫符號就可以與他人溝通，對不會寫字的人是很難理解的。</p>
<p>用俗語來比喻最相似的應該就是，貧窮限制了我的想像。</p>
<p>於是 22 號透過在地球中的體驗，活過來了，打破了他以前的價值觀，他找到了有趣的事物、值得他專注的事物。</p>
<h3 id="22-號不願意將身體還給男主角"><a href="#22-號不願意將身體還給男主角" class="headerlink" title="22 號不願意將身體還給男主角"></a>22 號不願意將身體還給男主角</h3><p>22 號由於害怕自己找不到火花沒有辦法在享受到在地球上的人生，必須要回去會面無聊的導師們，他跑走了，他害怕自己現在所接觸到的事物只是體驗，回去導師區後只能夠<strong>模擬</strong>人生，她害怕地跑走了。</p>
<p>此時的我在想 22 號應該有被加入<strong>自私</strong>此個性，他從來沒有去考慮過其他人，永遠都只有考慮自己，明明這是別人的身體、別人現在有著最重要的事物，但 22 號卻從沒有考慮他人，而直接向前衝果斷地離開男主角。</p>
<p>而後來會計師(專門清點靈魂的導師)發現這個錯誤，要把這個問題給解決掉，順利找到了 22 號與男主角。</p>
<p>其中還跟男配角說洋芋片很不健康、不要吃，我那時候想到很幽默的話XD，只要多吃點就可以提早見到導師摟XD。</p>
<h3 id="理髮師與-22-號的對話"><a href="#理髮師與-22-號的對話" class="headerlink" title="理髮師與 22 號的對話"></a>理髮師與 22 號的對話</h3><p>這裡是電影中我覺得非常精采的片段，由於 22 號的幽默風趣與以往的男主角不同，讓理髮師有了更廣的對話內容，不再只有 jazz，聊到了理髮師的過去，其實原本理髮師也不是真的想要當理髮師，他也有他的人生目標，22 號認為那理髮師的火花應該不是理髮師，應該要去努力追求她所愛的理想，但理髮師卻對他自己現在的工作感到滿足，雖然不是最好，但也是份不錯、有價值的工作。</p>
<p>此時讓我意識到了理髮師並沒有說出自己當時選擇的痛苦與逃避的過程，而是講出了最美好的一段，我想這是動畫必須的場景，動畫必須傳達給人們正面的感覺，而不是負面感，我也認為這才是動畫一定要做的事情，當人們具有正能量才有辦法繼續向前，不然就很容易像 22 號一樣，這也是我的微積分教授所教導我的，我非常感謝他。</p>
<p>理髮師開心的與 22 號聊天，其中也說到了，男主角基本上只會跟理髮師聊 jazz 的事情，其他都不提起，也就意味著男主角只完全在意著自己所愛的事物，並沒有關注他人的個性，也許它的個性沒有被加入<strong>觀察</strong>，而這些個性我們卻不能夠自己去追求，而是被傑瑞們隨便給予，這不是很不公平的一件事嗎？</p>
<blockquote>
<p><img src="https://i.imgur.com/50ho4rZ.jpg" alt="與理髮師的對話"></p>
</blockquote>
<h3 id="重回靈魂先修班"><a href="#重回靈魂先修班" class="headerlink" title="重回靈魂先修班"></a>重回靈魂先修班</h3><p>重回靈魂先修班後，22 號獲得了火花，男主角也受到傑瑞們的稱讚，男主角感到憤怒，22 號憑著自私就可以獲得了重生的機會，而他卻不行？明明有錯的是他阿，他向 22 號發怒，22 號感到他的怒氣，這時 22 號因為被他人羞辱，而放棄掉她的重生機會，甩給了男主角。</p>
<p>這裡也有個疑惑，為甚麼男主角重生是回到他原本的身體，而不是新生命呢？</p>
<p>男主角成功的表演，享受完了樂團表演，此時他認為他完成了自身的人生目標，也就意味著他失去了人生目標，在此，我的認知是他<strong>暫時</strong>失去了火花，因此他想把他的生命權給予 22 號，透過找到船長來讓自己可以將生命權傳給 22 號。</p>
<p>發現 22 號成為了迷失的靈魂，他由於害怕自己被眾人給看扁、給予負面評價而感到畏懼，感到害怕，成為了一位的靈魂，就像那些畏首畏尾的人們，那些人般令人討厭，連我也開始討厭起 22 號，但或許這就是傑瑞給他的個性使然，又讓我認為我真的應該要討厭 22 號嗎？</p>
<p>總之，熱血的對手戲結束後，22 號回復正常。</p>
<h3 id="傑瑞的獎賞"><a href="#傑瑞的獎賞" class="headerlink" title="傑瑞的獎賞"></a>傑瑞的獎賞</h3><p>由於 22 號與男主角的過程都被傑瑞看在眼底，換句話說，其實傑瑞跟著我們一起看電影XD，傑瑞認為自己也受到了一場教育，因此願意給男主角在一次一個機會讓他可以重回自己的生命。</p>
<p>這讓我知道了，傑瑞可能不是神，傑瑞也類似於人，需要透過學習，需要看著別人的賣命而讓自己獲得收穫，就好比傑瑞看著每場電影，再把每個人分成某些電影類，再讓某些人成為濫電影、某些成為好電影。</p>
<p>但即使傑瑞獲得了收穫，但傑瑞還是隨意的將人給予不同的個性，這是有必要的嗎？還是其實連傑瑞也不懂、不理解呢？</p>
<h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>我認為靈魂急轉彎是非常棒的作品，但他的客群我認為應該在 25 - 55 之間，想要讓大家明白自己為甚麼而活，而動力是為何，希望可以讓每個人都再次找到自己的火花，繼續讓自己燃燒自己，努力的讓自己的火花發亮。</p>
<p>但有些支線劇情交代不清，我認為可以將這些劇情進行刪減，將主線劇情交代完整，例如男主角媽媽與男主角的對手戲我認為就相當不好，令我感受不到感情、感覺不到愛，就像是因為我想要，所以我就要的概念一樣，打不太動我的心。</p>
<p>但就只有這裡不好，其他我覺得都不賴，整體的世界觀我超極喜歡，所有的劇情鋪設都超級讚，畫面也細膩，我非常建議大家來看。</p>
<p>不然我的心得也沒有辦法打那麼多，那肯定是因為好看我才能夠打那麼多。</p>
]]></content>
      <categories>
        <category>電影心得</category>
      </categories>
      <tags>
        <tag>人生旅途</tag>
        <tag>電影心得</tag>
        <tag>動畫類電影心得</tag>
      </tags>
  </entry>
  <entry>
    <title>2020/02/02 大屯國小遊記</title>
    <url>/2021/02/13/life_experence/datun_elementary20210202/</url>
    <content><![CDATA[<h2 id="說明"><a href="#說明" class="headerlink" title="說明"></a>說明</h2><blockquote>
<p>之前與嘉偉還有柏翰(以下稱 boso)，一起騎車去大屯山看夜景，出去玩樂的趣事。</p>
</blockquote>
<a id="more"></a>

<h2 id="前情概要"><a href="#前情概要" class="headerlink" title="前情概要"></a>前情概要</h2><p>我們在寒假要開始前我們就已經說好要去洗車，然後再去騎車，結果我們遲遲都沒有約，我忘記，他們也在忙跳舞社的事情就一路這樣拖拖到了 2 月 2 日。</p>
<p>中午的我跟隊伍在向指導老師討論演算法，討論時間不久，一下就好了，然後我就打電話跟嘉偉說我們來洗車八！但是我原本跟嘉偉約 5 點，但 3 點就好了，所以她趕緊打電話給 boso，讓他來北科。</p>
<h2 id="北科到大屯山"><a href="#北科到大屯山" class="headerlink" title="北科到大屯山"></a>北科到大屯山</h2><p>再從北科騎車到大屯山的時候有說有笑，騎到百齡橋的時候 boso 提醒我，我繞遠路了XD，下次我再把它改進啦，騎到大屯山的時候，那兩台 125cc 的機車都追不上我，我每個過彎的補油都比他們快些，畢竟是 150 嘛XD，但這也是我第一次感受到 150 明顯大於 125 的時候，而且還是 boso 跟我說的，不然我原本還不知道原來 150 這麼強，畢竟我沒有騎過 125 的機車上來大屯山www。</p>
<p>但如果平常都騎在平地上還是建議牽 125 拉，小台好停車又省油，我那台 150 大胖子每次在都市停車都是一場災難QQ。</p>
<p>然後在我們騎車的時候還不小心騎到了別人丟在道路上的廚餘，廚餘汁直接噴在我的車上RRRRR，超受傷的，嗚嗚，最慘的是沒想到連我的衣服都有一點…，在道路上丟廚餘的太過分了拉。</p>
<h2 id="大屯國小"><a href="#大屯國小" class="headerlink" title="大屯國小"></a>大屯國小</h2><p>我們到了四季觀景台(約大屯國小附近)，由於那時候大概是 4 點左右，還沒有日落，那時的我們先在四季觀景台看看風景，發現四季觀景台早上真的不好看QQ，太多鐵皮屋妨礙景觀了拉…，不過這也沒辦法，畢竟台灣並沒有對市容做強制整理，雖然我也不認為一定要做拉，不過就是早上的 View 會不好看些。</p>
<p>看膩了風景後，boso 提意要去大屯國小，我原本持反對意見，因為我怕國小警衛可能會把我們趕出去，但 boso 覺得到時再說XD，所以我們就上去啦，結果很意外的他們的大門是開放式大門連門的實體都沒有，只有一塊石頭和階梯，石頭上則寫著<strong>大屯國小</strong></p>
<h3 id="幼兒園區"><a href="#幼兒園區" class="headerlink" title="幼兒園區"></a>幼兒園區</h3><p>進到大屯國小後，首先映入眼簾的是幼兒園區，他們的幼兒園區很棒呀！有沙灘、溜滑梯，還有兩個我在都市從未見過的，知道是甚麼嗎？是<strong>木屋、手動發電的鋼琴</strong>，超酷的，有一個小木屋！可以在裡面逗留，當個小哨兵看守，又有手動發電的鋼琴，只要肯願意一直讓手去轉動發電器就可以開始去彈鋼琴，超酷的啦！<del>但是鋼琴要用兩隻手，要有一個人幫你轉才能發電XD</del></p>
<blockquote>
<p>樹屋<br><img src="https://i.imgur.com/t1NAHY6.jpg" alt=""></p>
</blockquote>
<blockquote>
<p>樹屋前的小吊橋<br><img src="https://i.imgur.com/w6O3V1z.jpg" alt=""></p>
</blockquote>
<blockquote>
<p>樹屋內部構造<br><img src="https://i.imgur.com/kDG0S8M.jpg" alt=""></p>
</blockquote>
<p>他們的幼兒園看起來有三班，但看起來都蠻不錯的，不過他們也是向我小學一樣吃著桶餐，我以為可能會是帶便當之類的呢，但是他們有專業的廚工在做菜，而不是像我們一樣是有著中央廚房在準備，我想有專業的廚工一定會很好吃吧！</p>
<p>而且他們的幼稚園老師也都有放出證明，這點讓我覺得不錯？可能是我社會化了，沒想到現在看到有放出證造的幼稚園我就會放心許多。</p>
<blockquote>
<p>某位老師的幼稚園老師證書<br><img src="https://i.imgur.com/7dENF67.jpg" alt=""></p>
</blockquote>
<h3 id="國小區"><a href="#國小區" class="headerlink" title="國小區"></a>國小區</h3><p>後來 boso 再往裡面探險些，發現了小學區，我們就上去他們的小學區探險拉，大屯國小蓋在山丘上所以他們是具有階梯式的，他們的操場不大，連籃球場都有點簡陋，中間有個簡易操場與司令台，供小孩們跑跳。但我認為他們確實不需要籃球場，他們有著許多有趣的遊樂設施，並不需要這種運動來強健身體，而是需要與大自然親近。</p>
<p>他們的 1,2,3 年級就在操場旁邊，操場旁邊有著攀岩，可能是要訓練小學生的肌耐力八，這感覺就超棒的呀，我的小學因為人數眾多，也沒有這種攀岩設備，於是老師們都是帶領著我們去跳花台，來訓練我們的平衡感、空間感、耐力，但這裏有著攀岩，就可以訓練到身體整個的流暢度，我認為我小時候如果有訓練過一定會更好！我個人因為小學跳花台的原因，下半身的反應特好，但上半身的反應明顯有落差，因為小學的成長都沒有去訓練到上半身。</p>
<blockquote>
<p>嘉偉的殘影 1<br><img src="https://i.imgur.com/WrPQeVx.jpg" alt=""></p>
</blockquote>
<blockquote>
<p>嘉偉的殘影 2<br><img src="https://i.imgur.com/QJQRSv7.jpg" alt=""></p>
</blockquote>
<p>我跟嘉偉在那邊拍攝我們攀岩的過程，很酷，超級酷的啦！boso 則在旁邊放著愜意的音樂，讓我的這倘旅程更加輕鬆</p>
<blockquote>
<p>嘉偉的慢動作攀岩</p>
<div class="video-container"><iframe src="https://www.youtube.com/embed/l95aNZITv8E" frameborder="0" loading="lazy" allowfullscreen></iframe></div>
</blockquote>
<blockquote>
<p>大衛的慢動作攀岩<br> <div class="video-container"><iframe src="https://www.youtube.com/embed/nHGEIx8w6kI" frameborder="0" loading="lazy" allowfullscreen></iframe></div></p>
</blockquote>
<p>他們的國小有種菜區來讓學生們學會種菜，我覺得這超酷的！在我的小學，那是一定沒有辦法的事情，因為我生活在都市中（萬華），這裡雖然沒有向大安區的高房價，但也不便宜，沒有辦法讓所有學生都在學校內有一個小植物來種菜，老實講，我認為小學能夠學會種菜這種技能相當不錯！</p>
<p>他們還有燒窯區，超酷的！我們國中的童軍課是簡單的烤肉，他們卻可以在小學就有這種體驗，感覺就超棒的！體驗到許多非都市生活，能夠在台北市體驗到大自然的學校真的不多，能夠在這種地方體驗燒窯，雖然機會可能就只在小學間，但那也是個不錯的回憶吧！</p>
<p>但比較可惜的是我認為他們可能會因為是鄉村小學的關係，人數不多，再舉辦運動會或園遊會就是一大難關，目測沒有跑道，可能沒有大隊接力這種運動方式八QQ，不過也沒辦法啦，山上的小學校資源本來就沒有辦法比都市多，要能夠有像都市一樣的高科技建築，可能還是比較難的。</p>
<blockquote>
<p>真人尺寸的圍棋棋盤<br><img src="https://i.imgur.com/H05NM5J.jpg" alt=""></p>
</blockquote>
<p>但他們有打鼓隊跟舞龍舞獅隊，應該有八，我們有看到器具XD，還是很不賴的啦。</p>
<p>但他們吃午餐看起來是十分愜意的一件事呢，他們的教室前面有著許多桌子，我想可以供他們坐在室外吃飯，看著大自然的風景，眺望者大台北吃飯，這可真是一個美好的事情呀，不需要待在教室像都市的學生一樣被制式管理，能夠多些互動空間。</p>
<blockquote>
<p>午餐區風景 1，傍晚時刻拍攝<br><img src="https://i.imgur.com/KZefjNW.jpg" alt=""></p>
</blockquote>
<blockquote>
<p>午餐區風景 2，傍晚時刻拍攝<br><img src="https://i.imgur.com/KKAL2b0.jpg" alt=""></p>
</blockquote>
<p>他們還有一個可以訓練小孩子爬行的能力的一個遊樂設施，看起來超級好玩的！可惜我們大了不能玩…。</p>
<p>此時夜晚已經悄悄降臨，大屯國小這時沒有照明設備了，我們到了警衛室，警衛室的側門貼著模範生，其中有一個讓我印象最深刻的就是他的夢想是想要去去外太空看地球，好啊！這就是有志向的年輕人！我祈求著他不會因為現實的壓力或者社會的歷練而將她的夢想只能收藏在妄想之中。</p>
<p>我曾經也是一個有著夢想的小孩，但社會把我打到了，現在的我只能看著現實給我的選項去選擇。</p>
<p>另外一位夢想則是想要有著歡樂的家庭，真的，有一個歡樂的家庭才有著面對世界挑戰的勇氣，不然就像是在生存一樣，令人感到疲憊。</p>
<p>如果不願意讓我公開，請私密我，我會將照片刪除。</p>
<blockquote>
<p>模範生 1 - 夢想是希望上月球<br><img src="https://drive.google.com/file/d/1ZVFTJE3w_7bic9S1oGiOFhtQp3OlJPOT/view?usp=sharing" alt=""></p>
</blockquote>
<blockquote>
<p>模範生 2 - 夢想是有著歡樂家庭<br><img src="https://drive.google.com/file/d/1J4wAjRZfzGVubQSaEaBqip4fZntzwXBH/view?usp=sharing" alt=""></p>
</blockquote>
<p>他們還針對每個月份都有著要求的事情，每個看起來都好棒，我相信女生應該都做得到，但是男生做得到嗎XD</p>
<blockquote>
<p>大屯國小 109 學期 12 月份四大天王檢核項目<br><img src="https://i.imgur.com/WgKblFq.jpg" alt=""></p>
</blockquote>
<h2 id="重返四季的夜景"><a href="#重返四季的夜景" class="headerlink" title="重返四季的夜景"></a>重返四季的夜景</h2><p>由於到了夜晚，我們再次重回四季觀景台看看，這時候的 VIEW 就好看很多了，畢竟夜晚了，那些醜化美觀的招牌與鐵皮屋都被夜色遮住，取而代之的是路燈、車燈、或是些許的招牌燈，點綴了整個黑夜，車燈就像動畫般緩慢的移動，美麗的瞬間不是我這種不會用相機的麻瓜可以拍攝到的。</p>
<blockquote>
<p>四季觀景台夜景 1<br><img src="https://i.imgur.com/pzAmQ3w.jpg" alt=""></p>
</blockquote>
<blockquote>
<p>四季觀景台夜景 2<br><img src="https://i.imgur.com/XT3hPda.jpg" alt=""></p>
</blockquote>
<h2 id="下山"><a href="#下山" class="headerlink" title="下山"></a>下山</h2><p>時候差不多，氣溫也開始轉冷了，我們就準備下山吃晚餐，我跟 boso 說我們不要發動引擎就可以開下山了XD，這裡的坡都很陡完全只依靠著坡的動力就能夠滑下去，可惜 boso 的車子只要一開燈就會發動引擎，沒有辦法跟我的車車一樣不發動引擎也能騎車XD。</p>
<p>下山之後我們到處晃晃，到了捷運唭哩岸去吃東西，為甚麼會到那麼遠呢？因為我想要吃飯飯XD，但是 8 點大部分的晚餐店都關掉了QQ，就跑去了捷運站附近來吃啦，原本想要吃咖哩飯，結果沒想到輪到我們的時候飯就沒了！太可惜了八…。</p>
<p>之後我們在騎車的過程中有聞到一間加熱滷味看起來就像是小巷中的名店，我們就買了，料不錯吃，但滷汁有點淡稍加可惜，豬肉片是精華一定要點，缺點是沒有內用，於是我們到了捷運的鐵橋下吃飯，結果 boso 還打翻碗噴到嘉偉XD，小鬧事，但很有趣。</p>
<h2 id="洗車"><a href="#洗車" class="headerlink" title="洗車"></a>洗車</h2><p>我們在騎車去吃飯的同時有找到一間自助洗車，於是我們就去那間自助洗車，那間自助洗車很乾淨，而且似乎主打高級的清潔劑，他的清潔劑 10 元只有 30s，有夠貴QQ，但我還是花了 20 元來洗，不得不說，把車洗乾淨的感覺真的超棒，但就是我當天背的書包必須一直背著好重RRRR，好想要放下來阿，但是我怕碰到洗車場髒髒的地方，所以一直死背著XD。</p>
<p>boso 幫我洗我的車(高壓清水)，他人超棒的，要是這裏我是女生我一定大加分，可惜我不是拉XD。下次也要帶海綿，不然會沒辦法洗車拉XD。</p>
<p>老樣子我每次洗車都會檢查自己的車車有沒有受傷，這次運氣不錯，都沒有受傷刮痕，於是這次就不用補漆拉。</p>
<h2 id="回程"><a href="#回程" class="headerlink" title="回程"></a>回程</h2><p>由於 boso 要回到內湖而我跟嘉偉要回到萬華與大安，路途不同，boso 騎到一半就往另一方向離開，而我則跟嘉偉到市民大道才分離，這是個美好的夜晚、美好的過程，讓我用文字記錄，那時候的美與快樂。</p>
<h2 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h2><p>總覺得人們的生活步調太快了，都不記錄自己的人生，就隨著時間將自己的回憶丟掉，這樣真的好可惜。</p>
]]></content>
      <categories>
        <category>人生旅途</category>
      </categories>
      <tags>
        <tag>大學Life</tag>
        <tag>人生旅途</tag>
      </tags>
  </entry>
  <entry>
    <title>電影觀後感 - 角頭：浪流連 (2/5)</title>
    <url>/2021/02/14/movie/Gatao-The-last-stray/</url>
    <content><![CDATA[<h2 id="前情概要"><a href="#前情概要" class="headerlink" title="前情概要"></a>前情概要</h2><blockquote>
<p>故事時間發生在《角頭2：王者再起》6年前，阿慶在北館角頭大哥仁哥的女兒滿月宴上，偶遇攝影師小淇進而衍生出一段相愛卻不能相守的愛情故事。身為角頭的阿慶遇到了小淇，原本水火不容的兩人，再一次次的爭吵中發現其實自己最在乎對方。阿慶與小淇相愛、相知、相惜、互相扶持，阿慶為小淇解決困難、小淇在阿慶事業遇到瓶頸時給予鼓勵。但就在此時湳沆的世界在背地裡陷害北館販毒，不僅讓北館深陷危機，仁哥與五虎們相繼誤解阿慶，小淇也因為阿慶受重傷。阿慶分身乏術，痛定思痛決定奮力一搏。</p>
<div class="video-container"><iframe src="https://www.youtube.com/embed/vpczVM8ddwk" frameborder="0" loading="lazy" allowfullscreen></iframe></div>

<p><a href="https://zh.wikipedia.org/wiki/%E8%A7%92%E9%A0%AD%EF%BC%8D%E6%B5%AA%E6%B5%81%E9%80%A3" target="_blank" rel="noopener">資料來源</a></p>
</blockquote>
<a id="more"></a>

<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>整體對於這部片並不喜歡，劇情支離破碎沒有一個完整的架構來建立，整體而言我們看的是演員的演技而不是劇情。</p>
<h3 id="滿月禮"><a href="#滿月禮" class="headerlink" title="滿月禮"></a>滿月禮</h3><p>滿月禮因為女主角的同事沒辦法感到因此換女主角代班，男主角被女主角的氣勢所逼，不甘情願地幫他做事，最後弄壞了相機鏡頭，想要賠錢了事但女主角不願意。</p>
<p>男主角回到店裡用錢對女主角賠罪但卻沒有成功，過程中看到拍攝到自己的相片，覺得拍攝的好而開始欣賞女主角。</p>
<p>整體到這邊演出了台灣道地的傳統，整體而言非常喜歡。</p>
<h3 id="女主角慢慢喜歡男主角"><a href="#女主角慢慢喜歡男主角" class="headerlink" title="女主角慢慢喜歡男主角"></a>女主角慢慢喜歡男主角</h3><p>女主角因為要拍攝北館但被當地小混混搶錢，富有正義感的女主角打抱不平，男主角看到後遏止了手下的小弟，男主角陪同女主角來拍北館，後來在一家餐廳用餐聊天聊到了雙方的身家背景，後來有次男主角要去看女主角而到女主角的工作地方時發現他不再，詢問工作同事後知道女主角的社區但不知道位置，男主角靠著厚臉皮找到女主角，之後男主角送女主角下山看醫院。</p>
<p>男主角的演技超好，那個有趣的對話腳本不得不說，超級漂亮，我都想要筆記怎麼會有好笑的對話內容XD，導演跟演員擅長這種曖昧對話的過程，但將鏡頭拉遠就會覺得這是個非常不合邏輯的地方，這種大型社區通常都會有警衛怎麼不直接詢問警衛就好了呢？還有怎麼會有人看到別人發燒還背女主角，那不是讓女主角更不舒服嗎QQ，通常應該是叫救護車吧，以及整體時間點過怪，男女主角離開女主角家是尚未傍晚，但男女主角在車上(應該是去醫院，因為沒有演到醫院那段不能確定)時間點卻是晚上，整體完全沒有交代女主角的病因，時間點也落差很大，放遠鏡頭後就覺得整體劇情奇怪，令人百思不得其解。</p>
<p>之後女主角就慢慢喜歡男主角開始有了曖昧情節，給予了男主角回饋，心的距離越來越近。</p>
<p>這裡的劇情十分不錯，非常優良，就是女主角喜歡男生這段內心戲沒有交代清楚，我覺得不好。</p>
<h3 id="橋下打鬥"><a href="#橋下打鬥" class="headerlink" title="橋下打鬥"></a>橋下打鬥</h3><p>一句話，看得過癮。整片最高潮、最吸睛的地方。</p>
<p>讓我在看的過程手腳都冒汗，怵目驚心。</p>
<h3 id="男女主角的約會"><a href="#男女主角的約會" class="headerlink" title="男女主角的約會"></a>男女主角的約會</h3><p>過程也是一樣棒，充滿了有趣的反差，讓人在看完戰鬥後感到開心與幸福，但想要充滿預言的鯊魚我這邊卻認為有點太硬要。</p>
<p>在書局，男主角特地拍獅子頭要做給女主角，聯合兄弟一起做菜這種感覺真的不錯，有著友情的快樂感覺。</p>
<p>鯊魚是女主角向男主角暗示的話，暗示他就像鯊魚般，沒有一刻可以休息下來。</p>
<p>用最新的鯊魚當梗本身是很棒的事，但導演可能忘記 IKEA 的鯊魚是表示可愛不是用在小流氓或兄弟身上呀！</p>
<h3 id="湳坑接班人賣毒"><a href="#湳坑接班人賣毒" class="headerlink" title="湳坑接班人賣毒"></a>湳坑接班人賣毒</h3><p>由於湳坑接班人(世界 - 人名)想要將北館打壞，認為北館佔了太多利益，因此想要將北館打下來，透過賣毒的方始來讓北館戰力降低，透過手下們建立起一間製毒室來拖垮對手戰力，找了大學生小陶來製毒。</p>
<p>這裡的劇情普通，在為了以後鋪陳，但也塑造了世界兇猛的形象。</p>
<h3 id="湳坑接班人去北館賭場鬧事"><a href="#湳坑接班人去北館賭場鬧事" class="headerlink" title="湳坑接班人去北館賭場鬧事"></a>湳坑接班人去北館賭場鬧事</h3><p>世界去北館玩天九牌，最終獲得勝利，但她帶著槍械違反北館規定，北館趕緊找人支援，最終世界放棄自己所勝利的籌碼瀟灑地走出出口。</p>
<p>中間仁哥跟世界的對話也是經典中的經典，雖然是經典，但我認為缺乏了些記憶點，我除了記得<strong>我認你一次、兩次，但不會有第三次！</strong>這種不太像是名言的名言樣就沒有甚麼感覺了。</p>
<p>倒是世界這邊帥氣地將錢撒出，講出一句<strong>吃紅</strong>真的帥，也讓我默默地在心中想著其實他並不是壞人，而是需要別人跟他大量的溝通來讓他理解情勢與情況，只可惜沒有人願意跟他進行大量溝通，只想讓<strong>現在的他</strong>當好一條狗。</p>
<blockquote>
<p>湳坑接班人去北館賭場鬧事<br><img src="https://i.imgur.com/2i76i4l.png" alt=""></p>
</blockquote>
<h3 id="市刑大警官-紅猴-去北館泡茶"><a href="#市刑大警官-紅猴-去北館泡茶" class="headerlink" title="市刑大警官(紅猴)去北館泡茶"></a>市刑大警官(紅猴)去北館泡茶</h3><p>紅猴聽到風聲說北館有賣毒，北館老大(貴董)直接否認，並且讓仁哥多注意。</p>
<p>這裡的紅猴姓氏為<strong>侯</strong>，讓人不禁就會聯想到新北市長侯友宜XD，令人有種微妙的感覺，紅猴這裡是個有趣的角色，透過自己的社交手法去處理任何事情，不動用任何<strong>物理</strong>上的權力，只靠著威脅、提醒的方式來讓所有人都明白情況、狀況，扮演著劇情的推動者，非常棒的角色，只可惜沒有多描述他的劇情。</p>
<p>紅猴在警局對男主角說，女主角跟我很熟，他還要叫我一聲 uncle，這裡我覺得超級好笑、超有梗，對話超棒。</p>
<h3 id="湳坑接班人與湳坑老大泡溫泉"><a href="#湳坑接班人與湳坑老大泡溫泉" class="headerlink" title="湳坑接班人與湳坑老大泡溫泉"></a>湳坑接班人與湳坑老大泡溫泉</h3><p>世界在跟湳坑老大(石霸)聊天，石霸問他是否有在北館賣毒，世界當然否認，世界被石壩潑了一杯酒後，用大吼發洩情緒。</p>
<p>這裡演出世界其實是有情有義的，他知道這是他老婆的爸爸，他對她有著其必要的尊重也並不打破，他完全能夠理解事情的重要性，而不是一言不合就拔刀的人。</p>
<h3 id="湳坑接班人與妻子的甜蜜故事"><a href="#湳坑接班人與妻子的甜蜜故事" class="headerlink" title="湳坑接班人與妻子的甜蜜故事"></a>湳坑接班人與妻子的甜蜜故事</h3><p>世界只有國中畢業但她非常愛她的老婆，特地燒了一手好菜給老婆，老婆也很開心，但老婆的擔心終究是忍耐不住，向世界提醒，並且刺激到世界，讓世界最後不願意與家人吃飯。</p>
<p>完全將世界的個性描寫的相當優秀，但一樣的大問題，鏡頭拉遠就讓人覺得不合邏輯，國中畢業的男生跟高材女生結婚，而石壩卻能接受？通常不會發生吧。</p>
<p>石議員不斷地刺激世界說，他爸不要讓世界這樣做，先聽他爸的，希望世界有著穩重的性格，但世界卻不願意一直接受刺激而生氣，這裡完美的揮發了世界的個性，甚至讓我覺得這裡有兩條劇情線的展開，讓我覺得這部戲好看了許多。</p>
<p>看的出來世界很愛老婆也對老婆很忠心，能為老婆能屈能伸，也不願意將老婆帶入他的賣毒計畫中，一心只想要守護著他的老婆，幫助他老婆，剷除他的所有敵人，也演出了沒有耐心的性格，這裡就跟他的設定一樣，國中畢業，沒有耐心可以讀下書，為了趕快接受到結果而用盡一切手段。</p>
<blockquote>
<p>議員提醒世界<br><img src="https://i.imgur.com/ap3za9J.png" alt=""></p>
</blockquote>
<h3 id="女生享受毒品的過程"><a href="#女生享受毒品的過程" class="headerlink" title="女生享受毒品的過程"></a>女生享受毒品的過程</h3><p>這裡真的莫名其妙，奇怪的音樂，就像想要告訴聽眾不要吸毒，在隱射著 W 飯店的女模一樣，雖然本身是好效果，但在這部電影宣導就向電視突然進廣告一樣令人厭煩，放個字幕轉下就好了，不要這麼硬要啦。</p>
<blockquote>
<p>男生給女生毒品後<br><img src="https://i.imgur.com/XpeHzH9.jpg" alt=""></p>
</blockquote>
<h3 id="世界想要殺掉男主角"><a href="#世界想要殺掉男主角" class="headerlink" title="世界想要殺掉男主角"></a>世界想要殺掉男主角</h3><p>由於男主角在監視器抓到了世界賣毒，因此抓住世界來工地福利社想來個人贓俱獲，但卻一無所有，加上新聞報導毒品的流串，讓世界必須在這裡下令殺害阿慶。</p>
<p>如果有看角頭二就知道，如果是那種目的式通常會讓殺手備感壓力，特別是第一次的人。</p>
<p>世界威脅其手下來進行殺害，此時男女主角正在暗巷中約會，這時男主角被圍毆，女主角也被爆打一頓，慘阿。</p>
<p>但這裡的賣點超棒，角頭浪流連最強的就是打鬥，怵目驚心，這不向劇情一樣可以用文字表述，只能夠用畫面、身體去記住，但是男女主角都沒有死，讓我好生氣！那些配角死的好冤阿QQ。</p>
<p>主角的光環太大往往會讓人出戲，建議改進。</p>
<blockquote>
<p>世界手下砍男主角<br><img src="https://i.imgur.com/NNSnDMF.jpg" alt=""></p>
</blockquote>
<h3 id="世界的手下被仁哥拷問"><a href="#世界的手下被仁哥拷問" class="headerlink" title="世界的手下被仁哥拷問"></a>世界的手下被仁哥拷問</h3><p>老樣子，怵目驚心。</p>
<p>坳手指的過程，拳打腳踢，男主角那個想要復仇的心，刻苦銘心，完全充滿了遏止了我想當 8+9 的心XD。</p>
<h3 id="男女主角的對手戲"><a href="#男女主角的對手戲" class="headerlink" title="男女主角的對手戲"></a>男女主角的對手戲</h3><p>本片我最不喜歡的地方。</p>
<p>鏡頭晃來晃去把我暈死了，想要理解劇情還必須看著鏡頭晃來晃去，完全不會想要理解劇情，不確定這裡導演為何要用此手法去演，希望我能夠去理解，因為我還沒有想到任何原因。</p>
<p>最後片尾演員進場，我上前發問也沒有給我一個答案，只說我們沒有討論到這個問題。</p>
<p>總之男生表現得還不錯，只帶一句<strong>你懂甚麼</strong>，充分顯現了一個沒讀過甚麼書，不容易溝通的表現，女主角則表演了女主角對於愛情的執著，拋棄掉理性的樣子，對白感人，就是鏡頭飄移讓我感到不適。</p>
<h3 id="世界中槍"><a href="#世界中槍" class="headerlink" title="世界中槍"></a>世界中槍</h3><p>世界，辛苦你了，你好可憐QQ。</p>
<p>從世界被開槍一樣也是打鬥的精華了，打鬥一直都是角頭最優秀的地方，男主角三方混戰這邊演得不錯，但我認為有理解力的觀眾可能會感到困惑，當下看可能反應不過來(包括我XD)，因為我們是上帝視角觀看，建議能夠用些簡單的手法輔述。</p>
<p>男主角一路追擊，小陶最後注射毒品，鼓起勇氣不斷向世界開槍，最終讓世界倒地，石議員最後去醫院看她(這裡是演員補述，電影沒有演到)，男主角過海去大陸。</p>
<p>莫名奇妙，明明是小陶打的為甚麼是男主角去大陸躲風聲，演的完整些會更好，這應該是一個武俠打鬥片不是一個劇情推理片，不應該放一堆模糊的片段讓觀眾去猜測阿。</p>
<h3 id="男女主角分手"><a href="#男女主角分手" class="headerlink" title="男女主角分手"></a>男女主角分手</h3><p>女主角躺在醫院，男主角去往大陸，紅猴來探望女主角，宗保告訴她分手並且請他理解，最後女主角痛哭，之後女主角在攝影展大展身手。</p>
<p>我認為其實沒有必要演到女主角在攝影展那段，可以補足其劇情而不是要刻意在這裡迎向劇情的高潮，前面的鋪陳都沒有弄得很完善阿！沒辦法帶入劇情…，這裡再放男主角(應該是虛擬)來看攝影展，看到自己的照片，讓這裡的劇情變得更加不明所以，讓人不得不對這片產生一個很明顯的問號，我開始完全不懂我到底看了甚麼。</p>
<h2 id="石壩與貴董的交談"><a href="#石壩與貴董的交談" class="headerlink" title="石壩與貴董的交談"></a>石壩與貴董的交談</h2><p>好啦，我猜這裡又有新外傳可以演吧，好煩，一堆破碎劇情。</p>
<p>石壩與貴董在這裡相談舊事，並且同意制裁世界，就像是很久沒見面的老朋友般，一樣熟悉的感覺。</p>
<p>特地演這齣，更加強大了我對破碎劇情，對這部戲的歡喜度又降低了。</p>
<h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>這裡中間的配樂我認為都不優，不好聽，沒有把台語的味道發揚光大，詞曲都沒有辦法擊中我心；並且劇情支離破碎，男主角的不死能力、男主角去往大陸時不明所以的劇情，特別是宗保那句<strong>你會來跟我搶角頭嗎？</strong>根本沒有演到，這裡放著回憶不會太怪嗎、女主角的病情、毒品事件只有演到中間就沒有再繼續。</p>
<p>一堆未完再續得劇情令我感到斐以所思，這是外傳，真的不考慮把劇情交代清楚嗎，導演擅長對於點進行發揮，那就讓劇情推演的慢且詳細，就像日劇一樣，這次的劇情雜而沒有條理，除非下次還有要演下集，但演下集也不應該放那麼多片段劇情！</p>
<p>演員打架、對白，都是設計漂亮的，且演員都有演到位，真的讚。</p>
<p>世界與石議員的劇情線比男女主角好太多，更 touch my heart。</p>
<p>最終，片尾是最好聽的。</p>
<p>電影結束後，演員親自感謝我們在第一周就觀看影片，我特地拍了演員們留念，最可惜的就是我詢問演員，男女吵架的對手戲那邊鏡頭為何特別晃則沒有一個好的回覆。</p>
<blockquote>
<p>片偉結束後，親眼看到演員<br><img src="https://i.imgur.com/PuCTPT8.jpg" alt=""></p>
</blockquote>
<p>如果要我硬說，我會認為這是一部爽片，看過就可以忘了，並沒有相當大的價值可以給後輩看。</p>
]]></content>
      <categories>
        <category>電影心得</category>
      </categories>
      <tags>
        <tag>人生旅途</tag>
        <tag>電影心得</tag>
        <tag>戰鬥類電影心得</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces 1480D2 - Painting the Array II (設計解題、數學推理)</title>
    <url>/2021/02/16/Codeforces/Codeforces%201480D2/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>給出一個陣列，我們可以把它放到另外兩個陣列 (A,B)，A,B 這兩個陣列計算元素是這樣計算的：</p>
<ul>
<li>陣列中如果周遭都是相同的數值就可以表示為一個元素，如 \((3,3,3) \) 就算一個、\((1,2,3)\) 就算是三個。</li>
<li>順序不可以交換，必須是一開始陣列的順序，透過給予 A or B 來讓 A and B 這兩個陣列元素最小，求這兩個 A,B 全部元素的數量</li>
</ul>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li>跳脫思考，不將重心思考放在如何把數字給這兩個陣列</li>
<li>思考放在如何讓重複的數字做到最大合併</li>
</ul>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>CF 的設計解題都是好題阿，往往都能啟發出我的好想法，或是透過他人的好想法來進行學習，真的有趣，需要多練習。</p>
<p>首先我們先將題目一開始的陣列進行壓縮，相同的重複數值合併成一個，定義此陣列 \(num\)</p>
<p>這題最好的方式就是將重心放在如何將所有相同的數字都放在一起，為了方便說明，我們一樣假設我們有兩個陣列 (A,B)，而他們陣列中最後的元素為 \(x,y\)，我們可以進行假設</p>
<ul>
<li>如果 \(num = x \ or \ num = y\)，這種情況當下不會多產生一個新元素</li>
<li>如果 \(num != x \ or \ num != y\)，那勢必會增加一個陣列新元素嗎？ <ul>
<li>如果這個數字在上次合併前沒有出現過，那一定會增加新元素</li>
<li>如果有出現過，則不會</li>
</ul>
</li>
</ul>
<p>合併是甚麼意思，看下面舉例。</p>
<h3 id="舉例"><a href="#舉例" class="headerlink" title="舉例"></a>舉例</h3><p>我們假設題目陣列為 \(1,2,3,1,2,2\)，壓縮後的 num 陣列為 \(1,2,3,1,2\)</p>
<p>我們一開始定義 A,B 兩個陣列，會依照順序給值，因此在 num 陣列給 \(1,2,3\) 應該要是這樣</p>
<ul>
<li>\(A = 1,3\)</li>
<li>\(B = 2\)</li>
</ul>
<p>接下來下一個 num 值是 1，這個時候問題來了。<br>我們其實可以做點操作，假如我們把 A 陣列的 3，給到 B 是不是就可以讓 num 的 1 放入 A 達到不產生元素的效果？對，沒問題，因此 A,B 陣列變了</p>
<ul>
<li>\(A = 1\)</li>
<li>\(B = 2,3\)</li>
</ul>
<p>此時 num 陣列中的素質為 2，我們還可以合併嗎？不行<br>為甚麼不能合併呢，因為我們前面已經進行了一次合併，num \(1,2,3,1\) 這邊我們已經進行了合併，我們不可以破壞上次的合併，否則會破壞題目陣列的順序姓，因此這邊勢必要加一元素。</p>
<p>但我們可以保留 A 的 1 與 B 的 3，這兩個可以被合併，因為他們是陣列最尾端，與他們合併並不會破壞其陣列順序姓。</p>
<ul>
<li>一個是因為進行合併而使得 A 陣列中的元素還是 1</li>
<li>另一個則是題目陣列中當前倒數第一個的數值</li>
</ul>
<p>透過此方式就能解出此題，用 map 紀錄哪些數字未合併但已被加入 A,B 陣列，如果下個數字是有在未合併中的數字時那就進行合併，如果還是一個未合併數字就讓答案加一。</p>
<h2 id="參考來源"><a href="#參考來源" class="headerlink" title="參考來源"></a>參考來源</h2><p><a href="https://blog.csdn.net/qq_46047971/article/details/113756394" target="_blank" rel="noopener">D2. Painting the Array II -  准准准准准菜鸡</a><br><a href="https://codeforces.com/blog/liouzhou_101" target="_blank" rel="noopener">Editorial of Codeforces Round #700 - liouzhou_101’s blog </a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>這題要是沒有<strong>准准准准准菜鸡</strong>的大力解說，我一定沒有辦法那麼快就想出這題，透過他在網路上的詳細解說讓我快速地學會此題，我要非常謝謝他！</p>
<p>希望我自己在解設計解題時都可以想到這些想法，那我在現實生活中一定會比這些不會寫 cf 的人更聰明、更加優秀。</p>
<p>希望大家都能夠快速理解，那是我的榮幸。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1000020</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, temp;</span><br><span class="line"><span class="keyword">int</span> a[MAXN]; <span class="comment">//原本題目陣列</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; num; <span class="comment">//壓縮的題目陣列</span></span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; mp; <span class="comment">//紀錄這些還沒合併的數字</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">cin</span> &gt;&gt; a[i]; <span class="comment">//輸入資料</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123; <span class="comment">//壓縮陣列</span></span><br><span class="line">        <span class="keyword">if</span>(a[i] == a[i<span class="number">-1</span>]) temp = a[i]; <span class="comment">//如果等於上次的，那就表示這邊可以再進行壓縮</span></span><br><span class="line">        <span class="keyword">else</span> num.push_back(a[i<span class="number">-1</span>]); <span class="comment">//不同了，所以放值</span></span><br><span class="line">    &#125;</span><br><span class="line">    num.push_back(a[n<span class="number">-1</span>]); <span class="comment">//最後的值一定要被加入，因為 for 沒有提到</span></span><br><span class="line">    <span class="comment">//for(int i = 0; i &lt; num.size(); i++) cout &lt;&lt; num[i] &lt;&lt; ' ';</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; '\n';</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num.size() ; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(mp[num[i]] == <span class="number">0</span>)&#123; <span class="comment">//又一個數字加入未合併數字中</span></span><br><span class="line">            mp[num[i]] = <span class="number">1</span>; <span class="comment">//標示被加入</span></span><br><span class="line">            ans++; <span class="comment">//答案 +1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            mp.clear(); <span class="comment">//合併了，因此要記錄新的合併</span></span><br><span class="line">            mp[num[i]] = <span class="number">1</span>; <span class="comment">//合併的數字</span></span><br><span class="line">            mp[num[i<span class="number">-1</span>]] = <span class="number">1</span>; <span class="comment">//原本當前題目壓縮陣列中最後一個元素</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>; <span class="comment">//輸出答案</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>設計解題</tag>
        <tag>程式解題</tag>
        <tag>Codeforces</tag>
        <tag>數學推理</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa11242 - Tour de France(水題)</title>
    <url>/2021/02/16/UVa/UVa11242/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>一個競速腳踏車由兩個齒輪與一條鏈子組成，鏈子則透過許多鏈輪組成，給你一些齒輪，並告訴妳這些齒輪的輪齒有多少，請幫忙選出兩個齒輪 (n/m)，n 是後輪、m 是前輪，定義為速率 \(d\)，要你找出兩個最大速率相除最大的數字。</p>
<p>最大速率有一些特別規定，如果有三種速度分別為 \(d_1, d_2 , d_3\)，排序為 \(d_1 &lt; d_2 &lt; d_3\)，那我們就不能拿 \(d_1 , d_2\) 來算最大速率，只能拿 \(d_1 \ and \ d_2 \) or \(d_2 \ and \ d_3 \) 進行相除。</p>
<p><a href="https://onlinejudge.org/index.php?option=onlinejudge&Itemid=8&page=show_problem&problem=2183" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li>學會理解英文會話題目</li>
<li>能看出此題如何運作</li>
</ul>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>其實這題不難，我們只要將全部的組合都嘗試一遍進行排序，找出相鄰的速率相除後的數字最大輸出即可。</p>
<p>需要注意的是 c++ <code>sort</code> 是由小到大，這點要特別注意。</p>
<h2 id="參考來源"><a href="#參考來源" class="headerlink" title="參考來源"></a>參考來源</h2><p><a href="https://gsourcecode.wordpress.com/2012/01/31/uva-11242/" target="_blank" rel="noopener">11242 – Tour de France - GSOURCECODE </a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>…，這題我寫了兩小時，完全思考錯 debug 方向，還以為是 cin 小數點的問題，一直在往這邊嘗試，直到找到了參考來源，互相比較後發現原來是我的 sort 排序完後，我自己會漏掉<strong>最後的一個數字</strong>去比較速率，現在改回來後，就好了很多，一次就 AC 啦！</p>
<p>題外話，往正確的 debug 方向走真的好難…，錯了都不知道。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;algorithm&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 20000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> F,R;</span><br><span class="line"><span class="keyword">double</span> f[MAXN], r[MAXN], num[MAXN]; <span class="comment">// f 前輪 r 後輪 num 速率</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"out.txt"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; F &gt;&gt; R &amp;&amp; F)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; F; i++) <span class="built_in">cin</span> &gt;&gt; f[i]; <span class="comment">//輸入資料</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; R; i++) <span class="built_in">cin</span> &gt;&gt; r[i]; <span class="comment">//輸入資料</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>; <span class="comment">//速率的最大長度</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; R; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; F; j++)&#123;</span><br><span class="line">                num[cnt++] = r[i] / f[j]; <span class="comment">//不斷交疊產生速率</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(num, num + cnt); <span class="comment">//排序</span></span><br><span class="line">        <span class="comment">//for(int i = 0; i &lt; cnt; i++ ) cout &lt;&lt; num[i] &lt;&lt; ' ';</span></span><br><span class="line">        <span class="comment">//cout &lt;&lt; '\n';</span></span><br><span class="line">        <span class="keyword">double</span> d, dmax = <span class="number">1</span>; <span class="comment">//dmax 是 1 是因為兩個數字一樣相比較最小會是 1，不會低於 1。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; cnt; i++)&#123; <span class="comment">//開始進行比較，找出兩個速率相差最大</span></span><br><span class="line">            <span class="keyword">if</span>(num[i] / num[i<span class="number">-1</span>] &gt;= dmax)&#123; <span class="comment">//如果 dmax 比較小</span></span><br><span class="line">                dmax = num[i] / num[i<span class="number">-1</span>]; <span class="comment">//替換成這兩個速率相差</span></span><br><span class="line">                <span class="comment">//cout &lt;&lt; "num is " &lt;&lt; num[i] &lt;&lt; ' ' &lt;&lt; num[i+1] &lt;&lt; '\n';</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; fixed &lt;&lt; setprecision(<span class="number">2</span>) &lt;&lt; dmax &lt;&lt; <span class="string">'\n'</span>; </span><br><span class="line">        <span class="comment">//輸出，題目要求小數點兩位，因此c++要這樣寫</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>水題</tag>
        <tag>UVa</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa1260 - Sales(LIS)</title>
    <url>/2021/02/16/UVa/UVa1260/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>有一家公司希望可以看今天的銷售金額比哪幾天高、等於，輸出哪幾天高的總和，如果前幾天是 \(20,30,40\)，那 30 那天的銷售金額就比前一天高，輸出 1；如果是 40 那天的銷售金額就輸出 2，大於前兩天的銷售金額，請輸出總和所有的銷售金額比哪些天高的天數並減一。</p>
<p><a href="https://onlinejudge.org/external/12/1260.pdf" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li>了解並學會 LIS</li>
<li>實踐 LIS</li>
<li><a href="https://theriseofdavid.github.io/2020/11/13/Explain_Algorithm/LIS/" target="_blank" rel="noopener">演算法知識 - Longest Increasing Subsequence 最長遞增子序列(時間複雜度 O(nlogn))</a></li>
</ul>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>這題就是簡單的 LIS，相信大家在看 uva 的題目時就能馬上知道這是 LIS，只需要學會 LIS 就能解出此題，但需要注意的是這題在相等時也要算入總和內，因此不可以使用 <code>lower_bound</code> 改使用 <code>upper_bound</code> 會更好！</p>
<h2 id="參考來源"><a href="#參考來源" class="headerlink" title="參考來源"></a>參考來源</h2><p><a href="https://theriseofdavid.github.io/2020/11/13/Explain_Algorithm/LIS/" target="_blank" rel="noopener">演算法知識 - Longest Increasing Subsequence 最長遞增子序列(時間複雜度 O(nlogn))</a><br><a href="http://web.ntnu.edu.tw/~algo/Subsequence.html" target="_blank" rel="noopener">演算法筆記 - Longest Increasing Subsequence</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>原本都是用比較麻煩的方式來寫，在師大的演算法筆記中發現了更棒的寫法，因此現在改用這種寫法認為會比之前更好寫!</p>
<p>也謝謝師大演算法可以讓我寫得更輕鬆如意，透過網路上教會我，是我網路上的老師！</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 5020</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[MAXN];</span><br><span class="line"><span class="keyword">int</span> T, n, len = <span class="number">0</span>, cur;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lis</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; b; <span class="comment">//用來產生 LIS 長度</span></span><br><span class="line">    b.push_back(a[<span class="number">0</span>]); <span class="comment">///先放入一個數值，以避免 b.back() 找不到值</span></span><br><span class="line">    <span class="keyword">int</span> sz = <span class="number">0</span>, temp; <span class="comment">//sz 為每個營收高於其它天的總和</span></span><br><span class="line">    <span class="comment">//temp 紀錄二分搜尋後找到的位置</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] &gt; b.back())&#123; <span class="comment">//如果現在這個數字大於此數列中最大的數字</span></span><br><span class="line">            sz += b.size(); <span class="comment">//表示今天大於其他天全部營收，直接加入 sz</span></span><br><span class="line">            b.push_back(a[i]); <span class="comment">//LIS push back</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            temp = upper_bound(b.begin(), b.end(), a[i]) - b.begin(); </span><br><span class="line">            <span class="comment">//二分搜尋，找到他適合的位置，前面數字比她小或相等，後面數字大</span></span><br><span class="line">            b.insert(b.begin()+temp , a[i]); <span class="comment">//插入她</span></span><br><span class="line">            sz += temp; <span class="comment">//sz 加上前面比她小的那些天數，注意，不需要 -1，因為 queue index 從 0 開始</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//debug</span></span><br><span class="line">            <span class="comment">//for(auto it: b) cout &lt;&lt; it &lt;&lt; ' ';</span></span><br><span class="line">            <span class="comment">//cout &lt;&lt; '\n';</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; "sz i is " &lt;&lt; sz &lt;&lt; '\n';</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sz;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"out.txt"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">cin</span> &gt;&gt; a[i]; <span class="comment">//輸入資料</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; lis() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>最長遞增子序列 Longest Increasing Subsequence</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa1103 - Ancient Messages(DFS)</title>
    <url>/2021/02/20/UVa/UVa1103/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>考古學家們給你一些古老文字，請你根據題目給你的資料進行判斷，這圖片有哪些文字，按照字母順序輸出，但你必須想辦法自己在古老文字中辨識古老文字。</p>
<p>題目給你的值是 16 位元的。<br>古老文字不會重疊、至少會有一個文字。</p>
<p><a href="https://onlinejudge.org/index.php?option=onlinejudge&Itemid=8&page=show_problem&problem=3544" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li>能夠理解題目英文</li>
<li>能找出題目文字輸出的規律性</li>
<li>了解 DFS</li>
</ul>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>難題，但不是難在該難的地方www，例如他要如何在題目資料中辨識文字呢，是按照文字中有幾個空白區段來辨識的…，沒有看別人的 blog 真的不會懂…，甚麼爛題目..。</p>
<p>特別還給他 16 位元來混淆大家的想法，這題真夠狠的，我都被他騙了 2 hr 的時間。</p>
<p>基本只有一個空格的是 W、兩個空格的是 A、三個空格是 K，以此類推 “WAKJSD”，而判斷空格的方式就是先將 16 位元先拆開來看</p>
<p>區塊定義：被 1 包圍的所有的 0。</p>
<h3 id="範例-A"><a href="#範例-A" class="headerlink" title="範例 A"></a>範例 A</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00010</span><br><span class="line">01101</span><br><span class="line">00010</span><br><span class="line">00000</span><br></pre></td></tr></table></figure>

<p>這樣的話就是 A，因為在 (4,2) 的 0，被 1 給包圍，因此答案是 A。</p>
<h3 id="範例-A-2"><a href="#範例-A-2" class="headerlink" title="範例 A-2"></a>範例 A-2</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00110</span><br><span class="line">01001</span><br><span class="line">00110</span><br><span class="line">00000</span><br></pre></td></tr></table></figure>

<p>這樣的話就是 A，因為 (3,2) 跟 (4,2)  都是 0， 1 給包圍，因此答案還是 A。</p>
<h3 id="範例-K"><a href="#範例-K" class="headerlink" title="範例 K"></a>範例 K</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">01111</span><br><span class="line">01010</span><br><span class="line">01111</span><br><span class="line">00000</span><br></pre></td></tr></table></figure>

<p>這樣的話就是 A，因為 (3,2) 跟 (5,2)  都是 0，但這兩個不是同個區塊，是被 1 分隔兩地，因此答案是，因此答案還是 K。</p>
<h3 id="重新整理"><a href="#重新整理" class="headerlink" title="重新整理"></a>重新整理</h3><p>因此我們可以知道，1 包圍很多 0 並且那些 0 都是不同的區塊時，越多區塊就是古老文字越多區塊的文字，像 D 就是有 6 個區塊，透過這樣推出。</p>
<p>沒有，這超難的…，在考大家聯想力..。</p>
<p>但現在我們可以知道了一件事，我們是要透過 1 包圍的區塊中判斷古老文字，因此我們先將 1 外圍的 0 全部都先表示成 2(有就是這些空格都是無意義，陪襯用)，接下來再判斷當我們走到 1 的使用開始搜尋外圍的 1 且當其中找到 0 時，就將那區塊全部都設為 2，表示已用過，並且記錄區塊，就可以判斷文字了！　</p>
<p>因此判斷的方式如下:</p>
<ul>
<li>先寫一個 DFS 將外圍的 0 都消除</li>
<li>再來遍地搜尋 1，但找到 1 就開始進行 DFS</li>
<li>如果從第二點的 DFS 搜尋到 0，表示這裡有區塊</li>
<li>將那些區塊全部都設為 2，因為都是同個區塊，實作用 DFS</li>
<li>根據幾個區塊而輸出文字，這樣即可。</li>
</ul>
<h2 id="參考來源"><a href="#參考來源" class="headerlink" title="參考來源"></a>參考來源</h2><p>我的朋友 - 陳立瑋</p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>這題真的很機車…，我想這題原本應該是給比賽用的才讓大家去猜測，但是我認為那個時候的大家應該也不知道吧…，這都快比 CF 的設計解題難 10 倍且還是難在非重要的地方，我認為很難過QQ，因為我就這樣被耍了兩個小時。</p>
<p>總之，訓練自己的英文能力很重要，雖然這題很機車，但是他也讓我大概理解影片解碼的方式了，謝謝他!</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> boardY 52 * 4 <span class="comment">// y 邊界，因為題目是 16 進位，但是我們要把它拆成 2 進位，才能分隔區塊</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> W, H, kase=<span class="number">0</span>, space;</span><br><span class="line"><span class="keyword">int</span> graph[<span class="number">202</span>][boardY + <span class="number">20</span>]; <span class="comment">//地圖</span></span><br><span class="line"><span class="built_in">string</span> word = <span class="string">"WAKJSD"</span>, ans, temp; <span class="comment">// word[i] 有 i 個區塊的象形文字, ans 答案</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs_white</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> w)</span></span>&#123; <span class="comment">//把當前空白區塊都掃描，用於一開始的去除外圍白色與去除 1 裡面的白色區塊</span></span><br><span class="line">    <span class="keyword">if</span>(h &gt; H + <span class="number">2</span>|| w &gt; boardY || h &lt; <span class="number">0</span> || w &lt; <span class="number">0</span>) <span class="keyword">return</span>; <span class="comment">//到邊界就不在繼續</span></span><br><span class="line">    <span class="keyword">if</span>(graph[h][w] != <span class="number">0</span>) <span class="keyword">return</span>; <span class="comment">//此座標不是白色就不繼續</span></span><br><span class="line">    graph[h][w] = <span class="number">2</span>; <span class="comment">//視為已用過</span></span><br><span class="line">    dfs_white(h + <span class="number">1</span>, w); <span class="comment">//搜尋 4 個方向</span></span><br><span class="line">    dfs_white(h - <span class="number">1</span>, w);</span><br><span class="line">    dfs_white(h, w + <span class="number">1</span>);</span><br><span class="line">    dfs_white(h, w - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs_black</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> w)</span></span>&#123; <span class="comment">//沿著 1 搜尋，只要碰到 0 就表示裡面有區塊，跳至 dfs_white 將那區塊全部掃描</span></span><br><span class="line">    <span class="keyword">if</span>(h &gt; H + <span class="number">2</span> || w &gt; boardY || h &lt; <span class="number">0</span> || w &lt; <span class="number">0</span>) <span class="keyword">return</span>; <span class="comment">//到邊界就不在繼續</span></span><br><span class="line">    <span class="keyword">if</span>(graph[h][w] == <span class="number">1</span>)&#123; <span class="comment">//表示此座標是 1</span></span><br><span class="line">        graph[h][w] = <span class="number">2</span>; <span class="comment">//視為已用過</span></span><br><span class="line">        dfs_black(h + <span class="number">1</span>, w); <span class="comment">//搜尋 4 個方向繼續沿著 1 搜尋</span></span><br><span class="line">        dfs_black(h - <span class="number">1</span>, w);</span><br><span class="line">        dfs_black(h, w + <span class="number">1</span>);</span><br><span class="line">        dfs_black(h, w - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(graph[h][w] == <span class="number">0</span>)&#123; <span class="comment">//表示這邊有區塊</span></span><br><span class="line">        space++; <span class="comment">//區塊++</span></span><br><span class="line">        <span class="comment">//cout &lt;&lt; "space is " &lt;&lt; space &lt;&lt; '\n';</span></span><br><span class="line">        dfs_white(h, w); <span class="comment">//將那區塊全部掃描一次</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; "dfs_black " &lt;&lt; h &lt;&lt; ' ' &lt;&lt; w &lt;&lt; '\n';</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">()</span></span>&#123; <span class="comment">//debug 用</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; H + <span class="number">2</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">5</span>; j &lt;= (W + <span class="number">1</span>) * <span class="number">4</span>; j++) <span class="built_in">cout</span> &lt;&lt; graph[i][j] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="comment">//freopen("out.txt", "w", stdout);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; H &gt;&gt; W &amp;&amp; H &amp;&amp; W)&#123; <span class="comment">//輸入 H,W</span></span><br><span class="line">        <span class="built_in">memset</span>(graph, <span class="number">0</span>, <span class="keyword">sizeof</span>(graph)); <span class="comment">//重置，避免影響這次測資</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= H; i++)&#123; <span class="comment">//輸入資料</span></span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; temp;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; W; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">isdigit</span>(temp[j])) space = temp[j] - <span class="string">'0'</span>; </span><br><span class="line">                <span class="comment">//16 進位判斷，前 9 個數字都跟 10 進位相同</span></span><br><span class="line">                <span class="keyword">else</span> space = temp[j] - <span class="string">'a'</span> + <span class="number">10</span>; <span class="comment">//將 16 進位轉成 10 進位</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) graph[i][(j + <span class="number">1</span>) * <span class="number">4</span> + <span class="number">4</span> - k] = (<span class="keyword">int</span>) <span class="number">1</span> &amp; (space &gt;&gt; k);</span><br><span class="line">                <span class="comment">//將 10 進位轉 2 進位，由於原本是 16 進位，因此最大只會有 4 個數字(位元)，</span></span><br><span class="line">                <span class="comment">// 1 &amp; (space &gt;&gt; k) 則是判斷那個數字(位元)原本是 1 還是 0，由於只要判斷 1 位元，並不要把其他位元牽扯，因此 &amp; 1。</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs_white(<span class="number">0</span>, <span class="number">0</span>); <span class="comment">//先將外圍的 0 先消除</span></span><br><span class="line">        <span class="comment">//debug();</span></span><br><span class="line">        ans = <span class="string">""</span>; <span class="comment">//答案清除</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">202</span>; i++)&#123; <span class="comment">//掃描，找出 1</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; boardY; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(graph[i][j] == <span class="number">1</span>)&#123; <span class="comment">//找到 1</span></span><br><span class="line">                    space = <span class="number">0</span>; <span class="comment">//將區塊設為 0</span></span><br><span class="line">                    dfs_black(i, j); <span class="comment">//沿著 1 搜尋</span></span><br><span class="line">                    ans += word[space]; <span class="comment">//幾個區塊就輸出相對應的象形文字</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(ans.begin(), ans.end()); <span class="comment">//字典排序</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Case "</span> &lt;&lt; ++kase &lt;&lt; <span class="string">": "</span>; <span class="comment">//說明這是第幾個 case</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>UVa</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa11094 - Continents(DFS)</title>
    <url>/2021/02/21/UVa/UVa11094/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>有一個國王喜歡佔領領土，給你一張地圖，這張地圖左右邊是有相同連結的！請你找出除了國王所在的地方外，最大的一片土地，國王要去征戰他</p>
<p>提醒，由於國家的地圖沒有統一標準，因此陸地或是海洋的標示都不相同，但會給你國王所在地。</p>
<p><a href="https://onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=2035" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="觀念重點"><a href="#觀念重點" class="headerlink" title="觀念重點"></a>觀念重點</h2><ul>
<li>理解題目英文</li>
<li>要讓 dfs 搜尋可以左邊邊界能與右邊邊界相通</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>這題不難，只需要在 dfs 時特別判斷，碰到左右邊界時會連接到另一邊的邊界即可。</p>
<p>然後有一個小技巧，雖然你不知道陸地或海洋的字元，但是因為國王永遠都在陸地，所以可以假設國王所在地是陸地，那個字元就是陸地字元，那麼另外一個字元就是海洋，然後 DFS 即可。</p>
<h2 id="參考來源"><a href="#參考來源" class="headerlink" title="參考來源"></a>參考來源</h2><p><a href="https://hackmd.io/@txya900619/Uva11094" target="_blank" rel="noopener">Uva11094 - Continents - txya900619</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>這題沒有很難，但我原本想說我簡單快速看題目，結果出來的是 WA，在我百思不得其解時問了力瑋，他跟我說明這題題目大意，我才又認真地回去看發現自己一堆東西都漏看…，真不該相信自己的閱讀能力..。</p>
<p>可以用國王的位置當作陸地的字元這點是力瑋告訴我的，不然我一開始還真沒有想到，力瑋好聰明</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 25 <span class="comment">//最大值</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BX 20 <span class="comment">// 題目 X 最大邊界</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BY 20 <span class="comment">// 題目 Y 最大邊界</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> N, M, X, Y; <span class="comment">//題目的輸入</span></span><br><span class="line"><span class="keyword">char</span> graph[MAXN][MAXN]; <span class="comment">//題目的地圖 </span></span><br><span class="line"><span class="keyword">char</span> land, water; <span class="comment">//陸地 與 水 的字元</span></span><br><span class="line"><span class="built_in">string</span> s; <span class="comment">//輸入題目陣列元素用</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123; <span class="comment">//用來搜尋陸地區塊</span></span><br><span class="line">    <span class="keyword">if</span>(x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span> || x &gt;= N || y &gt;= M) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//超出邊界</span></span><br><span class="line">    <span class="keyword">if</span>(graph[x][y] != land) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//如果這塊不是未被記錄的陸地就 return </span></span><br><span class="line">    graph[x][y] = <span class="string">'`'</span>; <span class="comment">//修改為已用過，由於題目的字元並不會用到此字元，因此改為她</span></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">1</span>; <span class="comment">//表示這塊是陸地，所以必定會有 1</span></span><br><span class="line">    cnt += dfs(x<span class="number">-1</span>, y); <span class="comment">//四個方向搜尋</span></span><br><span class="line">    cnt += dfs(x+<span class="number">1</span>, y);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(y == M<span class="number">-1</span>) cnt += dfs(x, <span class="number">0</span>); <span class="comment">//搜尋到右邊界，下次搜尋左邊界</span></span><br><span class="line">    <span class="keyword">else</span> cnt += dfs(x, y+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(y == <span class="number">0</span>) cnt += dfs(x,M<span class="number">-1</span>); <span class="comment">//搜尋到左邊界，下次搜尋右邊界</span></span><br><span class="line">    <span class="keyword">else</span> cnt += dfs(x, y<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> cnt; <span class="comment">//回傳陸地區塊</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">()</span></span>&#123; <span class="comment">//debug 用</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; M; j++)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; graph[i][j] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"out.txt"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M)&#123; <span class="comment">//輸入資料</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; M; j++) graph[i][j] = s[j];</span><br><span class="line">            <span class="comment">//注意這裡的 s[j]，不是 s[i]</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>; <span class="comment">//最大陸地</span></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; X &gt;&gt; Y;</span><br><span class="line">        land = graph[X][Y]; <span class="comment">//判斷是 land 的字元</span></span><br><span class="line">        dfs(X, Y);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123; <span class="comment">//遍地走訪</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; M; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(graph[i][j] == land) ans = max(ans, dfs(i, j));</span><br><span class="line">                <span class="comment">//如果此點有陸地，就全部搜尋看最大區塊是否有比 ans 大，有就更換答案</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//debug();</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>; <span class="comment">//輸出答案</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>UVa</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa11953 - Battleships(DFS)</title>
    <url>/2021/02/21/UVa/UVa11953/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>大家有玩過 Battleships game 嗎? 用兩張紙畫，目標是要擊沉對手的所有船艦，每一艘船艦都是 1 * N 大小的，要全部都被擊中就算輸了</p>
<p>題目是給你一張圖，請你判斷還有哪些戰艦還沒有被擊沉，被擊中並不包含擊沉</p>
<p><a href="https://onlinejudge.org/index.php?option=onlinejudge&Itemid=8&page=show_problem&problem=3104" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li>理解英文題目</li>
<li>DFS 應用</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>這題不難，學會 DFS 後，只要碰到非 ‘.’ 的格子，就進行 DFS 只要 DFS 中有遇到 ‘x’ 就表示這艘船還沒有被完全擊沉就加一</p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>簡單，開始慢慢學會，也慢慢改變自己的程式碼風格，使其更好閱讀</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 120</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> T, N, kase = <span class="number">0</span>; <span class="comment">//kase 輸出第幾個測資</span></span><br><span class="line"><span class="keyword">char</span> graph[MAXN][MAXN]; <span class="comment">//題目的地圖</span></span><br><span class="line"><span class="built_in">string</span> s; <span class="comment">//輸入題目資料用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123; <span class="comment">//搜尋 DFS，判斷這區塊有沒有還存活的戰艦</span></span><br><span class="line">    <span class="keyword">if</span>(x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span> || x &gt;= N || y &gt;= N) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//超出邊界</span></span><br><span class="line">    <span class="keyword">if</span>(graph[x][y] == <span class="string">'.'</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//碰到海洋</span></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>; <span class="comment">//表示還有幾個地方沒有被擊中</span></span><br><span class="line">    <span class="keyword">if</span>(graph[x][y] == <span class="string">'x'</span>) cnt += <span class="number">1</span>; <span class="comment">//表示這地方沒有被擊中</span></span><br><span class="line">    graph[x][y] = <span class="string">'.'</span>; <span class="comment">//算過因此，表示為海洋</span></span><br><span class="line">    cnt += dfs(x<span class="number">-1</span>, y); <span class="comment">//四個方向</span></span><br><span class="line">    cnt += dfs(x+<span class="number">1</span>, y);</span><br><span class="line">    cnt += dfs(x, y<span class="number">-1</span>);</span><br><span class="line">    cnt += dfs(x, y+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> cnt; <span class="comment">//回傳有幾個地方還沒被擊中</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">()</span></span>&#123; <span class="comment">//debug 用</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++) <span class="built_in">cout</span> &lt;&lt; graph[i][j] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"out.txt"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; N;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123; <span class="comment">//輸入資輛</span></span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++) graph[i][j] = s[j];</span><br><span class="line">            <span class="comment">//注意這裡的 s[j]，不是 s[i]</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>; <span class="comment">//幾艘還在</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123; <span class="comment">//遍地搜尋</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(graph[i][j] != <span class="string">'.'</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(dfs(i, j) != <span class="number">0</span>) ans++; <span class="comment">//如果 != 0 就表示還有地方沒有被擊中，因此戰艦+1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Case "</span> &lt;&lt; ++kase &lt;&lt; <span class="string">": "</span>; <span class="comment">//輸出答案</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>UVa</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa722 - Lakes(DFS)</title>
    <url>/2021/02/20/UVa/UVa722/</url>
    <content><![CDATA[<h2 id="題目大意："><a href="#題目大意：" class="headerlink" title="題目大意："></a>題目大意：</h2><blockquote>
<p>有一張地圖，我們會給你一個 x,y 座標，請你幫我們找出以此座標為基準、陸地為邊界擴大搜尋的水有幾格？</p>
<p><a href="https://onlinejudge.org/index.php?option=onlinejudge&Itemid=8&page=show_problem&problem=663" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li>學會理解英文會話題目</li>
<li>DFS 的應用</li>
<li>如何配合題目輸入資料輸入</li>
</ul>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>這題是簡單的 DFS 分析，其實應該是要使用 BFS 會更好些，避免遞迴崩潰的問題，但因為題目的地圖部會不會超過 \(99 * 99\)。</p>
<h2 id="參考來源"><a href="#參考來源" class="headerlink" title="參考來源"></a>參考來源</h2><p><a href="https://hackmd.io/@txya900619/Uva772" target="_blank" rel="noopener">Uva722 - Lakes txya900619 </a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>這題簡單複習 DFS，加強自己的敏感度。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。 </p>
<p>注意，為了題目好寫，我將 0 設為陸地，1 設為水</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 120</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> graph[MAXN][MAXN]; <span class="comment">//地圖</span></span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>, M, a, b, flag = <span class="number">1</span>; <span class="comment">//cnt 計算水的數量、flag 判斷 output 輸出 '\n'</span></span><br><span class="line"><span class="built_in">string</span> temp; <span class="comment">//用來輸入題目的地圖位置</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span> || x &gt; <span class="number">100</span> || y &gt; <span class="number">100</span>) <span class="keyword">return</span>; <span class="comment">//判斷邊界</span></span><br><span class="line">    <span class="keyword">if</span>(graph[x][y] == <span class="number">0</span>) <span class="keyword">return</span>; <span class="comment">//碰到陸地返回</span></span><br><span class="line">    graph[x][y] = <span class="number">0</span>; <span class="comment">//這邊的水被設為陸地，因為被記錄過</span></span><br><span class="line">    cnt++; <span class="comment">//增加計算水的樹木</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; "cnt x y " &lt;&lt; cnt &lt;&lt; ' ' &lt;&lt; x &lt;&lt; ' ' &lt;&lt; y &lt;&lt; '\n';</span></span><br><span class="line">    dfs(x<span class="number">-1</span>, y); <span class="comment">//四個方向進行搜尋</span></span><br><span class="line">    dfs(x+<span class="number">1</span>, y);</span><br><span class="line">    dfs(x, y<span class="number">-1</span>);</span><br><span class="line">    dfs(x, y+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123; <span class="comment">//debug 輸出用</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">100</span>; j++) <span class="built_in">cout</span> &lt;&lt; graph[i][j] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"out.txt"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; M;</span><br><span class="line">    <span class="keyword">while</span>(M--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b; <span class="comment">//輸入要查詢的座標</span></span><br><span class="line">        <span class="built_in">cin</span>.ignore(); <span class="comment">//這時候 cin 在 b 的尾端因此要 cin.ignore 來讓他直接指針指到下一個字元的前面。</span></span><br><span class="line">        <span class="built_in">memset</span>(graph, <span class="number">0</span>, <span class="keyword">sizeof</span>(graph)); <span class="comment">//重新整理，以免讓過去資料影響現在</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>; <span class="comment">//表示輸入地圖到底幾行</span></span><br><span class="line">        <span class="keyword">while</span>(getline(<span class="built_in">cin</span>,temp) &amp;&amp; temp != <span class="string">""</span>)&#123; <span class="comment">//判斷是否有資料，沒有就是 temp == ""</span></span><br><span class="line">            <span class="comment">//cout &lt;&lt; temp &lt;&lt; '\n';</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; temp.length(); j++) graph[i][j] = (temp[j] - <span class="string">'0'</span>) ^ <span class="number">1</span>; </span><br><span class="line">            <span class="comment">//輸入資料，後面 ^ 1，這是方便運算， 0 ^ 1 = 1 就可以表示水</span></span><br><span class="line">            <span class="comment">//in my code 1 is water, 0 is land</span></span><br><span class="line">            i++; <span class="comment">//換下行輸入</span></span><br><span class="line">        &#125;</span><br><span class="line">        cnt = <span class="number">0</span>; <span class="comment">//重置計算水的數目</span></span><br><span class="line">        <span class="comment">//print();</span></span><br><span class="line">        dfs(a<span class="number">-1</span>, b<span class="number">-1</span>); <span class="comment">//由於我們題目 index 從 0 計算，因此 a, b 都減一</span></span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="number">1</span> )&#123; <span class="comment">//這時候不需要中間空一行，因為是答案第一筆</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; cnt &lt;&lt; <span class="string">'\n'</span>; <span class="comment">//輸出計算的水量</span></span><br><span class="line">            flag = <span class="number">0</span>; <span class="comment">//表示已經不是答案第一筆</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span> &lt;&lt; cnt &lt;&lt; <span class="string">'\n'</span>; <span class="comment">//現在開始需要</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>UVa</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa758 - The Same Game(DFS)</title>
    <url>/2021/02/21/UVa/UVa758/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>一個小遊戲(類似於 candy crush)，目標是拿到最大分，規則與分數如下：</p>
<ul>
<li>有三種顏色的石頭，只要有三顆相同顏色的石頭在一起就可以被消除掉</li>
<li>如果石頭有被消除掉，當前的格子為空，那上面的石頭會替補上來(column)</li>
<li>如果有一整排(column)為空，那將右邊的那些石頭全部都往左移一排(column)</li>
<li>分數計算是消掉的石頭(m) \((m-2) ^ 2\)</li>
<li>如果全部的石頭都被消去就多獲得 1000 分</li>
</ul>
<p>一個好的策略是從左下底端開始尋找，找出有最大堆顏色的石頭將它們消去，不斷重複至不能消除<br>必須要輸出如何消除、總共分數、剩下幾顆。</p>
<p><a href="https://onlinejudge.org/index.php?option=onlinejudge&Itemid=8&page=show_problem&problem=699" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="觀念重點"><a href="#觀念重點" class="headerlink" title="觀念重點"></a>觀念重點</h2><ul>
<li>理解題目英文</li>
<li>這題屬於複雜操作題，腦袋清晰地寫</li>
<li>需要不斷反覆除錯</li>
</ul>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>麻煩的題目…，寫這題需要高度的專心力與注意力才可以把這題寫好…。</p>
<p>這題不難，就是依照題目的要求直接暴力解即可，不太需要想甚麼優化的問題，測資並不大。</p>
<p>題外話：我倒是花了一堆時間在想要怎麼把程式碼精簡，最終還是放棄QQ。</p>
<h2 id="參考來源"><a href="#參考來源" class="headerlink" title="參考來源"></a>參考來源</h2><p><a href="https://hackmd.io/@txya900619/Uva758" target="_blank" rel="noopener">Uva758 - The Same Game - txya900619</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>這題真的夠了..，一年寫一次這種題目就好了，我都想稱他為麻煩大題了QQ，我寫完後硬是讓自己逃避了 3,4 hr 再來 debug 這題，很怕有大錯讓自己要重改之類的RRRR。</p>
<p>總之，希望自己的程式能力速度可以變快。</p>
<p>透過學習立委的程式碼，讓我覺得自己變聰明了些。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。 </p>
<p>程式碼很長，希望大家都能專心QQ。</p>
<p>hash 模式<br>R = 1<br>G = 2<br>B = 3<br>消除的石頭(0) = 0;</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BX 10 <span class="comment">// 題目 X 最大邊界</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BY 15 <span class="comment">// 題目 Y 最大邊界</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> extra 5 <span class="comment">//擴增陣列，以防超出</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> graph[BX+extra][BY+extra], visit[BX+extra][BY+extra]; </span><br><span class="line"><span class="comment">//graph 遊戲的圖 visit 判斷有沒有走過，用於一開始的搜尋</span></span><br><span class="line"><span class="keyword">int</span> n, kase = <span class="number">0</span>; <span class="comment">//kase 輸出當前第幾測資</span></span><br><span class="line"><span class="built_in">string</span> s; <span class="comment">//輸入題目陣列元素用</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; mp; <span class="comment">// char hash 成 int</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">char</span>&gt; mp2; <span class="comment">// int hash 成 char</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs_search</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> value)</span></span>&#123; <span class="comment">//用來搜尋同樣顏色的石頭最大面積</span></span><br><span class="line">    <span class="keyword">if</span>(x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span> || x &gt; BX || y &gt; BY) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//超出邊界</span></span><br><span class="line">    <span class="keyword">if</span>(visit[x][y] == <span class="number">1</span> || graph[x][y] != value) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//已被走訪過 或 不同顏色石頭</span></span><br><span class="line"></span><br><span class="line">    visit[x][y] = <span class="number">1</span>; <span class="comment">//走訪過</span></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">1</span>; <span class="comment">//最大面積，還沒往其他地方探索，因此只有自己所以 1</span></span><br><span class="line">    cnt += dfs_search(x<span class="number">-1</span>, y, value); <span class="comment">//往四個地方進行走訪，value 是一開始搜尋的石頭顏色</span></span><br><span class="line">    cnt += dfs_search(x+<span class="number">1</span>, y, value);</span><br><span class="line">    cnt += dfs_search(x, y<span class="number">-1</span>, value);</span><br><span class="line">    cnt += dfs_search(x, y+<span class="number">1</span>, value);</span><br><span class="line">    <span class="keyword">return</span> cnt; <span class="comment">//回傳最大面積</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs_remove</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> value)</span></span>&#123; <span class="comment">//用來移除石頭，在找到最大面積石頭時使用</span></span><br><span class="line">    <span class="keyword">if</span>(x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span> || x &gt; BX || y &gt; BY) <span class="keyword">return</span>; <span class="comment">//超出邊界</span></span><br><span class="line">    <span class="keyword">if</span>(graph[x][y] != value) <span class="keyword">return</span>; <span class="comment">//顏色不同石頭</span></span><br><span class="line">    graph[x][y] = <span class="number">0</span>; <span class="comment">//移除，因此變零</span></span><br><span class="line">    dfs_remove(x<span class="number">-1</span>, y, value); <span class="comment">//四個方向移除</span></span><br><span class="line">    dfs_remove(x+<span class="number">1</span>, y, value);</span><br><span class="line">    dfs_remove(x, y<span class="number">-1</span>, value);</span><br><span class="line">    dfs_remove(x, y+<span class="number">1</span>, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span></span>&#123; <span class="comment">//將消除的石頭位置放上新石頭</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>; <span class="comment">//k 用來判斷位置</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; BX; i++)&#123; <span class="comment">//rule 1 題目大意的規則 2</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; BY; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(graph[i][j] == <span class="number">0</span>)&#123; <span class="comment">//表示這裡有被移除的石頭</span></span><br><span class="line">                k = i+<span class="number">1</span>; <span class="comment">//要跟上面沒有被移除的石頭的 x index </span></span><br><span class="line">                <span class="keyword">while</span>(k &lt; BX)&#123; <span class="comment">//如果沒有超出邊界，就繼續</span></span><br><span class="line">                    <span class="keyword">if</span>(graph[k][j] != <span class="number">0</span>)&#123; <span class="comment">//index k 的石頭沒有被消除</span></span><br><span class="line">                        swap(graph[i][j], graph[k][j]); <span class="comment">//那就交換</span></span><br><span class="line">                        <span class="keyword">break</span>; <span class="comment">// 消除成功，所以退出</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    k++; <span class="comment">//沒有找到，所以 k++</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//至於為甚麼要這樣找，不是直接跟上一個交換?</span></span><br><span class="line">                <span class="comment">//因為有可能上面三個都被移除，那移除石頭交換本身沒意義</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//注意，這裡是將 y index 放在外迴圈</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; BY; j++)&#123; <span class="comment">//rule2 題目大意的規則 3</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>; <span class="comment">//sum 用來判斷那行 column 是否都是空的</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; BX; i++) sum += graph[i][j]; </span><br><span class="line">        <span class="comment">//因為 hash 後的數值都大於 1，因此如果等於 0 一定都沒有</span></span><br><span class="line">        <span class="keyword">if</span>(sum == <span class="number">0</span>)&#123;</span><br><span class="line">            k = j+<span class="number">1</span>; <span class="comment">//用來交換的 index </span></span><br><span class="line">            <span class="keyword">while</span>(k &lt; BY)&#123;  <span class="comment">//如果沒有超出邊界，就繼續</span></span><br><span class="line">                <span class="keyword">if</span>(graph[<span class="number">0</span>][k] != <span class="number">0</span>)&#123; <span class="comment">//index k 的石頭沒有被消除</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; BX; i++) swap(graph[i][j], graph[i][k]);</span><br><span class="line">                    <span class="comment">//整行交換</span></span><br><span class="line">                    <span class="keyword">break</span>;  <span class="comment">// 消除成功，所以退出</span></span><br><span class="line">                &#125;</span><br><span class="line">                k++; <span class="comment">//沒有找到，所以 k++</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visit_debug</span><span class="params">()</span></span>&#123; <span class="comment">//debug 用</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = BX<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= BY<span class="number">-1</span>; j++) <span class="built_in">cout</span> &lt;&lt; visit[i][j] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">graph_debug</span><span class="params">()</span></span>&#123; <span class="comment">//debug 用</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = BX<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= BY<span class="number">-1</span>; j++) <span class="built_in">cout</span> &lt;&lt; mp2[graph[i][j]] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"out.txt"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCLA</span></span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    mp[<span class="string">'R'</span>] = <span class="number">1</span>; mp[<span class="string">'G'</span>] = <span class="number">2</span>; mp[<span class="string">'B'</span>] = <span class="number">3</span>; <span class="comment">//hash </span></span><br><span class="line">    mp2[<span class="number">1</span>] = <span class="string">'R'</span>; mp2[<span class="number">2</span>] = <span class="string">'G'</span>; mp2[<span class="number">3</span>] = <span class="string">'B'</span>; mp2[<span class="number">0</span>] = <span class="string">'0'</span>; <span class="comment">//hash </span></span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Game "</span> &lt;&lt; ++kase &lt;&lt; <span class="string">":\n\n"</span>; <span class="comment">//輸出當前 case </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = BX<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--)&#123; <span class="comment">//輸入資料</span></span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; BY; j++) graph[i][j] = mp[s[j]]; </span><br><span class="line">            <span class="comment">//注意這裡的 s[j]，不是 s[i]</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, score, step = <span class="number">1</span>, remain = BX*BY; </span><br><span class="line">        <span class="comment">//ans 答案 score 當前分數 step 移動第幾次 remain 還有幾個石頭沒有被消除</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123; <span class="comment">//不斷輪迴，嘗試消除石頭</span></span><br><span class="line">            <span class="keyword">int</span> block = <span class="number">0</span>, max_block = <span class="number">0</span>, mx, my; </span><br><span class="line">            <span class="comment">//block 當前區塊 max_block 最大區塊 mx my 最大區塊的 x,y</span></span><br><span class="line">            <span class="built_in">memset</span>(visit, <span class="number">0</span>, <span class="keyword">sizeof</span>(visit)); <span class="comment">//重設為 0</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; BY; j++)&#123; <span class="comment">//對每一個石頭進行搜尋</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; BX; i++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(visit[i][j] == <span class="number">0</span> &amp;&amp; graph[i][j] != <span class="number">0</span>) block = dfs_search(i, j, graph[i][j]);</span><br><span class="line">                    <span class="comment">//如果這個石頭沒有被搜尋，就 dfs 這邊的石頭</span></span><br><span class="line">                    <span class="keyword">if</span>(max_block &lt; block)&#123; <span class="comment">//搜尋的區塊比之前搜尋的還大</span></span><br><span class="line">                        max_block = block;</span><br><span class="line">                        mx = i; my = j;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//visit_debug();</span></span><br><span class="line">            <span class="comment">//cout &lt;&lt; "max_block " &lt;&lt; max_block &lt;&lt; '\n';</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(max_block &lt; <span class="number">2</span>) <span class="keyword">break</span>; <span class="comment">//如果搜尋到的最大區塊 &lt; 2 表示沒有辦法在消除，就離開迴圈</span></span><br><span class="line">            remain -= max_block; <span class="comment">//減掉最大的區塊</span></span><br><span class="line">            score = (max_block - <span class="number">2</span>) * (max_block - <span class="number">2</span>); <span class="comment">//計算這次分數</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Move "</span>&lt;&lt; step++ &lt;&lt; <span class="string">" at ("</span> &lt;&lt; mx+<span class="number">1</span> &lt;&lt; <span class="string">","</span> &lt;&lt; my+<span class="number">1</span> &lt;&lt; \</span><br><span class="line">             <span class="string">"): removed "</span> &lt;&lt; max_block &lt;&lt; <span class="string">" balls of color "</span>&lt;&lt; mp2[graph[mx][my]] &lt;&lt; <span class="string">", got "</span> &lt;&lt; score &lt;&lt; <span class="string">" points.\n"</span>;</span><br><span class="line">            <span class="comment">//輸出這次步驟，這裡輸出顏色用 mp2</span></span><br><span class="line">            ans += score; <span class="comment">//加上這次分數</span></span><br><span class="line">            dfs_remove(mx, my, graph[mx][my]); <span class="comment">//移除最大區塊的石頭</span></span><br><span class="line">            refresh(); <span class="comment">//將題目大意的規則 2 and 3 重整一次</span></span><br><span class="line">            <span class="comment">//graph_debug(); //debug</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(remain == <span class="number">0</span>) ans += <span class="number">1000</span>; <span class="comment">//沒有剩下的石頭可以拿到 1000 分</span></span><br><span class="line">        <span class="comment">//輸出最後資訊</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Final score: "</span> &lt;&lt; ans &lt;&lt; <span class="string">", with "</span> &lt;&lt; remain &lt;&lt; <span class="string">" balls remaining.\n"</span>;</span><br><span class="line">        <span class="keyword">if</span>(n != <span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>; <span class="comment">//最後一個不斷行兩次，因為題目要求間隔斷行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>








]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>UVa</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>2021/01/29 北科大學生夜衝北海岸</title>
    <url>/2021/02/22/life_experence/north_coast_trip_with_college_friends/</url>
    <content><![CDATA[<h2 id="說明"><a href="#說明" class="headerlink" title="說明"></a>說明</h2><blockquote>
<p>跟大學程式設計社團的朋友們一起去北海岸看日出、夜衝。<br>有紹宇、力瑋、天佑、洸明</p>
</blockquote>
<a id="more"></a>

<h2 id="前情概要"><a href="#前情概要" class="headerlink" title="前情概要"></a>前情概要</h2><p>在 1 月 29 日之前我一直很想要去白沙灣看日出，但是一直都沒有找到機會可以去北海岸玩，在練習完演算法後，想說臨時約大學程式社團能不能約動，經過一番波折後終於約成了，讚啦！</p>
<h2 id="把大家拉出來玩"><a href="#把大家拉出來玩" class="headerlink" title="把大家拉出來玩"></a>把大家拉出來玩</h2><p>一開始我想要出去玩，我先問了紹宇要不要去北海岸玩，紹宇說可以啊，要不要一起問社團，我就想說那一定好啊，然後我就去問了力瑋，力瑋也說沒有問題，我想說已經綁架兩個人了，剩下兩個人一定都很好綁架拉！</p>
<p>我將力瑋形容成立法院長、紹宇是社長、機長是洸明、總統是天佑，我是副總統，直接綁架機長跟總統說要不要給我通過行政命令XD，跟某豬議題可能類似XDDD。</p>
<p>後來機長跟總統受不了我的盧，終究還是跟我出去玩了！</p>
<h2 id="改期、租車是大問題啊"><a href="#改期、租車是大問題啊" class="headerlink" title="改期、租車是大問題啊"></a>改期、租車是大問題啊</h2><p>原本我們是約好的隔天馬上就要出發，但結果因為沒有辦法租車QQQ，租車要滿 20y，我們這邊的大哥哥洸明沒有駕照，天佑有，但才剛滿 20 申請和運還沒有辦法成功，沒辦法租車就只好借家裡的車拉，結果我爸的車有問題沒有去修理，力瑋爸的車要上班不能借QQ。</p>
<p>在百般無奈之下，就取消了這次的行程。</p>
<h2 id="我怎麼可能會死心"><a href="#我怎麼可能會死心" class="headerlink" title="我怎麼可能會死心"></a>我怎麼可能會死心</h2><p>但是我還是好想要出去玩RRRRR，我就在網路上找了一堆方法來能讓這次旅行可以出去玩，我就找了幾個方法來跟天佑不斷搓合，看有沒有機會出去玩，結果找到 29 號是大家有空可以出去玩，那就趕快出門拉</p>
<blockquote>
<p>跟天佑的對話，原先還要讓他帶小夜燈，結果他只有超大手電筒www<br><img src="https://drive.google.com/u/2/uc?id=1_N1Zn28I7XKIvj8oM-SYxF6XRH2b6dEc&export=download" alt=""></p>
</blockquote>
<h2 id="DC-大討論"><a href="#DC-大討論" class="headerlink" title="DC 大討論"></a>DC 大討論</h2><p>出去玩嘛，總是要討論一下的。</p>
<p>租車細節，怎麼樣玩拉，都需要討論，其實我原本是想說車子隨便開有玩到就賺、沒玩到地方下次來，來回慢跑我都覺得沒關係，結果大家直接把我噴得滿地都是XDDD，洸明還說我演算法怎麼學得，最短路徑都沒學好QQQQ。</p>
<p>總之，在大家的激烈討論下，看來要舉辦一個活動真的不容易呢，幸好大家都有包容我，不然說不定可能會玩得很差吧XD。</p>
<p>白沙灣在北邊，我們為甚麼在北邊看日出，這是我學到的最大經驗XD。</p>
<blockquote>
<p>出去玩的規劃<br><img src="https://drive.google.com/u/2/uc?id=1GlRCwwAxNIU-6vMpXjOhMZgOHeCzM1Ym&export=download" alt=""></p>
</blockquote>
<p>也要謝謝天佑拉，租車事宜都交給他，辛苦他了QQ。</p>
<h2 id="從北科出發"><a href="#從北科出發" class="headerlink" title="從北科出發"></a>從北科出發</h2><p>我們那天在進行演算法練習，而天佑跟紹宇先去取車，我們先在 109 集合，力瑋跟洸明在聊天跟肢體語言，剛好被我記錄下來XD。</p>
<blockquote>
<p>力瑋跟洸明的肢體語言<br><img src="https://drive.google.com/u/2/uc?id=1eAWRE-8Q0JDcULj0RYfA5rDQlOpa-7zO&export=download" alt=""></p>
</blockquote>
<p>天佑跟紹宇到了，我們趕快出發去找他們，結果剛好天佑去上廁所，我們都不能進去都在外面等他XDD，我們手中拿著一堆行李重得要死，結果我們嘗試要打開後車廂放行李都打不開，然後我們就乾等天佑，結果天佑來了後說為甚麼你們都不放行李，我說沒辦法開後車箱門被鎖住了，天佑就輕輕地就打開了，完全沒有做甚麼動作，只留下充滿驚訝的我。</p>
<p>紹宇坐上了副駕，留下了尷尬的我，我心裡想，我 1.5 喔確定要讓我擠後座嘛?????，在充滿懷疑的情況下車車把我們載走出發啦。</p>
<h2 id="高速公路上"><a href="#高速公路上" class="headerlink" title="高速公路上"></a>高速公路上</h2><p>在高速公路，我們聽著周杰倫的音樂，這是洸明限定，只有他在我們才有機會聽得道音樂，然後，恩，後座真的好擠，我跟洸明一直撞到RRRR，這個時候就覺得自己瘦了真好QQ。</p>
<p>在高速公路的路上，大家車速都好快，我真的會怕QQQ，那種高速公路上車禍的影片，第一次大家一起出去玩開車，讓我心驚膽跳，大家車速都 90 幾不是一個機車騎士能夠體會到的事QQQ。</p>
<h2 id="基隆廟口"><a href="#基隆廟口" class="headerlink" title="基隆廟口"></a>基隆廟口</h2><p>到了基隆後，我們停到了一個停車場，不得不說，基隆的人行道真的對人很不友善、基隆的車子交通也不好QQQ，一堆單行道，還有兩個不同方向的單行道同時面對面，突然覺得萬華的交通也沒有很爛阿，看看基隆，萬華好多了！</p>
<p>基隆的房子似乎都更得不多，還都是比較老舊的階段，</p>
<p>走到廟口後，我們先去吃最好吃的三明治，在買天婦羅(不過洸明不推)，覺得不好吃，我們一路吃著雞排、豆花，豆花蠻好吃的，但是太多澱粉要胖拉XDDD。</p>
<blockquote>
<p>好吃的三明治<br><img src="https://drive.google.com/u/2/uc?id=1tR0zfVeEkwIkr1xMTPjf5DZ58EehY0U5&export=download" alt=""></p>
</blockquote>
<p>吃完飯後，我們漫步在基隆，不得不說，在基隆晚上走路很舒服有著海風，基隆最精華的地方就屬基隆港了吧！在那邊可以讓人心曠神怡，但一往回來走就覺得有種進入 70 年代的台灣感覺。</p>
<p>吃飽後，我們先去 24hr 的頂好，基隆只有頂好 24 hr QQ，好難過，我對頂好的印象沒有很好的說，邊走邊喝，順便大家一起走路聊天，走到港口後發現有個漂亮的船，就跟他拍照拉！</p>
<blockquote>
<p>跟船的合照<br><img src="https://drive.google.com/u/2/uc?id=1DLpyZCCIhI7nSJepBEs4ECnMIorRLJ82&export=download" alt=""></p>
</blockquote>
<blockquote>
<p>天佑再幫我拍照時，旁邊那些人都進來鏡頭惡搞，太過分嘞！那就只好讓他們上我的 blog 拉<br><img src="https://drive.google.com/u/2/uc?id=1Mo9C0aJ2ny2racxmtLoag1deM2PJvHWz&export=download" alt=""></p>
</blockquote>
<blockquote>
<p>不過基隆的夜晚很美，天佑拍了兩張照作為紀念<br><img src="https://drive.google.com/u/2/uc?id=1t-g5Buc5w0zYE1T16KER9yAeIhViIsWD&export=download" alt=""><br><img src="https://drive.google.com/u/2/uc?id=1LNIQbsieH6dRvWdKisS7Cme4PZ4LHuhb&export=download" alt=""></p>
</blockquote>
<p>走累了後，我們要去北海岸的白沙灣看看日出，於是天佑跟紹宇先去停車場開車，我跟剩下的人則是一起去頂好買東西，其中頂好前面很漂亮，特別拍了照片。</p>
<blockquote>
<p>頂好前面拍照留念<br><img src="https://drive.google.com/u/2/uc?id=19jonnkbYpWRSY3PzVrC3UBUnBoe4MP-i&export=download" alt=""><br><img src="https://drive.google.com/u/2/uc?id=13EBIm9PTL_Ky3KKk62OeecCyrDX4Lfk-&export=download" alt=""></p>
</blockquote>
<blockquote>
<p>買了一堆的收據<br><img src="https://drive.google.com/u/2/uc?id=1f7G35fUzflfZOjg9n1MgnLqe5lWh5vhj&export=download" alt=""></p>
</blockquote>
<p>我們準備要去白沙灣拉，但是大家都很想尿尿XD，我們想要去麥當勞尿尿，結果路上一堆違停，我們原本是不想違停的，但是因為破窗效應嘛，所以我們就趕快違停去上廁所XD。</p>
<h2 id="白沙灣"><a href="#白沙灣" class="headerlink" title="白沙灣"></a>白沙灣</h2><p>我們到了白沙灣拉，馬上就想上廁所XD，我們跑去了警察局要來上廁所，結果警察局跟我們說廁所在旁邊，然後我們就摸黑上廁所，半夜是停電的RRR，然後晚上還在施工，我們原本一開始以為可能不能進去了！結果沒想到還是可以XD，好險，不然這趟就白來了QQ，我們就準備下去，結果紹宇沒有帶拖鞋，天佑趕緊回去陪他拿。</p>
<p>那其他人呢？<br>我們就換好拖鞋準備踩沙拉，那天的風有夠大，快吹到死掉了，我們還拚了命的想要去鋪好紹宇帶的沙灘巾，結果風太大根本沒有辦法啊RRRR，我們犧牲洸明壓著沙灘巾，而我跟立委趕緊去把裝備搬下來，然後突然想到我帶的仙女棒沒有帶打火機呢XD，趕快叫紹宇幫我買打火機XD。</p>
<p>紹宇他們回來後，發現，怎麼這麼冷！每個人都在念我這甚麼爛活動XD，不是吼，應該會蠻好玩的吼，是風向差了點拉，不是我的錯啦QQ。</p>
<blockquote>
<p>天佑拍大家終於可以休息的畫面<br><img src="https://drive.google.com/u/2/uc?id=16bTgzZZcPleVmZb6vu01B5pSRgjEWupL&export=download" alt=""></p>
</blockquote>
<blockquote>
<p>意義不明的沙灘照XD<br><img src="https://drive.google.com/u/2/uc?id=1kbZ3OFJg1hkwCKGDBIGR7nTdRCin9acq&export=download" alt=""></p>
</blockquote>
<blockquote>
<p>畫質有點差的凌晨沙灘<br><img src="https://drive.google.com/u/2/uc?id=1Ib2Y6dyBFRly4XpXFfnIfuoppQPTcCFb&export=download" alt=""></p>
</blockquote>
<p>我們在那邊喝點小酒，踩踩沙，玩玩仙女棒，結果仙女棒我們還點不起來火，我們特地為了點火大家互相包圍住仙女棒就是祈求將火點燃，結果還是沒有辦法XDDD，後來洸明想到好方法，跑到了屋子旁邊點火，終於成功了！我興奮地大叫讚啦，將軍，讚啦，點起了仙女棒來玩。</p>
<blockquote>
<p>大家一起玩仙女棒的影片，風超大，所以超級吵得XD</p>
<div class="video-container"><iframe src="https://www.youtube.com/embed/AMVpWwPhfNo" frameborder="0" loading="lazy" allowfullscreen></iframe></div>
</blockquote>
<p>聽到紹宇的怒吼，我覺得超好笑，來了都值了XD</p>
<p>寒假應該 100 分，怎麼會是 0 分。 大衛 2021/02/22</p>
<p>結果在喝的路上開始有點慢慢醉掉了，跟力瑋、洸明一起喝酒，結果我好像喝太多直接醉了QQ，一倒車上不小心一瞇起眼睛來就開始慢慢有了嘔吐的慾望。</p>
<h2 id="三芝買早餐"><a href="#三芝買早餐" class="headerlink" title="三芝買早餐"></a>三芝買早餐</h2><p>此時早餐店已經開了，紹宇跟某人，但我有點醉就忘記是誰了，就去買了早餐，我一吃完早餐就直接吐，大家看到都被嚇到QQ，這個時候我的腦袋開始已經有醉意了，只想要睡覺其他都不想要QQ。</p>
<p>吃完早餐後，就去富貴角燈塔啦。</p>
<h2 id="富貴角燈塔"><a href="#富貴角燈塔" class="headerlink" title="富貴角燈塔"></a>富貴角燈塔</h2><p>停好車後，我又在吐了一次。<br>我很對不起大家，還有地板。</p>
<p>後來我們一起去看日出，途中遇到很多野狗很怕阿QQQQ，不得不說，為甚麼富貴角燈塔比鵝鑾鼻燈塔的裝潢都還差拉QQ，都沒有經過好的整理嘛，嗚嗚。</p>
<p>路途上風超大的，這次我難得把帽子戴了起來。</p>
<blockquote>
<p>看到日出後的合照<br><img src="https://drive.google.com/u/2/uc?id=13brD52QNYm9CUW_litN2yX1vD1kFGpfm&export=download" alt=""></p>
</blockquote>
<blockquote>
<p>紹宇跟富貴角燈塔的合照<br><img src="https://drive.google.com/u/2/uc?id=1ajJOcn2InhUteghA5aae5o4u5jDU4a1u&export=download" alt=""></p>
</blockquote>
<blockquote>
<p>業配零食，這真的好好吃<br><img src="https://drive.google.com/u/2/uc?id=19xfiFa4yruM0JM4ujKLgQ2V3kHUs_o4K&export=download" alt=""></p>
</blockquote>
<blockquote>
<p>會影分身的力瑋<br><img src="https://drive.google.com/u/2/uc?id=1DcWNdHZ6N23CScN58HTehrqcyRwAj5l9&export=download" alt=""></p>
</blockquote>
<p>看完後，我們就去老梅放風箏。</p>
<h2 id="老梅"><a href="#老梅" class="headerlink" title="老梅"></a>老梅</h2><p>我又吐了一次，三次了，事不過三。<br>途中我完全沒有印象，是大家叫我起床的，然後我就來放風箏，結果不到 10s 風箏直接被風吹走…，他叫風箏欸QQQQQ，怎麼可以被風吹走，可能真的風太大了吧QQ。</p>
<p>總之，這趟旅程獲得了快樂與暈眩，失去了風箏QQQ。</p>
<blockquote>
<p>失去風箏的我<br><img src="https://drive.google.com/u/2/uc?id=1YUhM3-04EE8TJA-ybgcraCYP2R0vyqe4&export=download" alt=""></p>
</blockquote>
<p>後來我跟天佑好像在車上睡覺，其他人在外面聊天，我有點累掛了，直接在裡面睡掛。</p>
<p>大家集合到車上後，問我這個指揮官還要不要去淡水，對不起我沒有體力了QQ，我們回家吧，下次我會少碰酒QQQQ，我會好好改進的。</p>
<h2 id="到北科"><a href="#到北科" class="headerlink" title="到北科"></a>到北科</h2><p>我們一路到北科，但我完全沒記得。</p>
<p>後來天佑跟紹宇把我們放在北科卸下行李，他們先去還車，然後我們就先去社辦放東西，大家都有點疲勞了，我們就在社辦休息一陣子後就回家。</p>
<p>真的是拚了老命回家，我到現在完全沒有印象我怎麼回家的，我那時候應該拚著意識再衝吧XD。</p>
<p>辛苦天佑了，這麼累的情況還要載我們回家，他人最好了QQ。<br>辛苦紹宇了，陪著天佑到處跑。<br>辛苦力瑋了，陪著喝醉的我。<br>辛苦洸明了，忍受我的白目。<br>辛苦大衛了，你吐了三次。</p>
<h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>還是有很多地方可以改進拉，感覺並不是每個地方都做到最好，例如去白沙灣吹那麼強的海風就是一個大問題，沒有買到煙火也是大問題，主要是這次行程太趕變得沒有規劃好很多，我以後要再好好改進。</p>
<p>然後不可以喝太多酒，不然自己會死得很難看，我們也買太多，剩下一堆酒XD。</p>
<p>總之，還是謝謝大家在我的大學生活，我很快樂XD。</p>
]]></content>
      <categories>
        <category>人生旅途</category>
      </categories>
      <tags>
        <tag>大學Life</tag>
        <tag>人生旅途</tag>
      </tags>
  </entry>
  <entry>
    <title>演算法知識 - Topological Ordering 拓樸排序(時間複雜度 O(V+E))</title>
    <url>/2021/02/26/Explain_Algorithm/Topological_Ordering/</url>
    <content><![CDATA[<h2 id="Topological-Ordering-拓樸排序-介紹"><a href="#Topological-Ordering-拓樸排序-介紹" class="headerlink" title="Topological Ordering 拓樸排序 介紹"></a>Topological Ordering 拓樸排序 介紹</h2><blockquote>
<p>在有些程式問題，可能會有以下這些需求</p>
<ul>
<li>我們需要做完 n 個任務，但有些任務有依賴需求，需要某個任務完成才可以做這個任務，請給出一份符合要求的任務清單</li>
<li>要幫學員排隊，但有些人必須排在某些人的後面，請給出一份符合要求的排隊順序</li>
</ul>
<p>也就是對於一個序列，其中的某兩點具有先後關係，即是拓樸排序</p>
</blockquote>
<a id="more"></a>

<h2 id="Topological-Ordering-限制"><a href="#Topological-Ordering-限制" class="headerlink" title="Topological Ordering 限制"></a>Topological Ordering 限制</h2><p>Topological Ordering 有些要求，如下</p>
<ul>
<li>必須是有向圖<br>如果是無向圖，不會有順序的概念。</li>
<li>不可以有環(cycle)<br>如果有環，無法確定先後的關係，例如順時鐘或逆時鐘，則 1 這個數字的位置就不同。</li>
</ul>
<h2 id="Topological-Ordering-實作與說明"><a href="#Topological-Ordering-實作與說明" class="headerlink" title="Topological Ordering 實作與說明"></a>Topological Ordering 實作與說明</h2><p>在程式碼進行說明，相信會比較好理解些。</p>
<p>基本上此演算法類似於 BFS，如果有學過 BFS 一定會相當好懂。</p>
<h3 id="定義名詞"><a href="#定義名詞" class="headerlink" title="定義名詞"></a>定義名詞</h3><ul>
<li>紀錄關係<br>a,b ，則 a 必須在 b 前面、c,d，則 c 必須在 d 前面，此時我們會稱 a,c 為前面節點、b,d 是後面節點。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 120</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, a, b;</span><br><span class="line"><span class="keyword">int</span> cnt[MAXN]; <span class="comment">//記錄關係，以此節點為後面，而有多少節點在其前面</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; root[MAXN], ans; </span><br><span class="line"><span class="comment">//root 記錄關係，以此節點為前面，而另一節點就在後面 (vector.push_back)</span></span><br><span class="line"><span class="comment">//ans 答案序列，拓樸排序的序列</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">topo</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123; <span class="comment">//不斷輸入 </span></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b; <span class="comment">//輸入記錄關係，a 是前者 b 是後者</span></span><br><span class="line">        root[a].push_back(b);  <span class="comment">//記錄關係，記錄 a 有多少後面節點，並且記錄。</span></span><br><span class="line">        cnt[b]++; <span class="comment">//記錄有幾個前面節點，如果 b 是後面關係時。</span></span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; q; <span class="comment">//用來判斷有哪些節點現在已經可以直接被放到答案序列</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt[i] == <span class="number">0</span>) q.push_back(i); </span><br><span class="line">        <span class="comment">//在記錄關係中，如果以此節點為後面，沒有節點在前面就加入 q</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> now; <span class="comment">//暫存 bfs(q) 當前的節點</span></span><br><span class="line">    ans.clear(); <span class="comment">//答案序列清空</span></span><br><span class="line">    <span class="keyword">while</span>(ans.size() != n)&#123; <span class="comment">//如果答案序列的長度跟題目給的長度一樣就跳出</span></span><br><span class="line">        <span class="keyword">if</span>(q.empty()) <span class="keyword">break</span>; <span class="comment">//如果沒有節點可以直接被放入答案序列就跳出</span></span><br><span class="line">        now = q.front(); q.pop_front(); <span class="comment">//把當前節點給 now</span></span><br><span class="line">        ans.push_back(now); <span class="comment">//將 now 放入答案序列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it: root[now])&#123; <span class="comment">//由於 now 節點被放入答案陣列，</span></span><br><span class="line">        <span class="comment">//之前的記錄關係就不須記錄，因為放到答案陣列就剩下的後面節點就必定在後面</span></span><br><span class="line"></span><br><span class="line">            cnt[it]--; <span class="comment">//將所有原本在記錄關係中後面的節點 -1，減少了一個記錄關係</span></span><br><span class="line">            <span class="keyword">if</span>(cnt[it] == <span class="number">0</span>) q.push_back(it); <span class="comment">//如果都沒有記錄關係就可以放到 q</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ans.size() == n)&#123; <span class="comment">//如果答案序列跟 n 一樣，表示可以成功排出拓樸排序，就輸出答案</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ans.size(); i++) <span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; ans[i];</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Topological-Ordering-應用"><a href="#Topological-Ordering-應用" class="headerlink" title="Topological Ordering 應用"></a>Topological Ordering 應用</h2><p>點擊 tag Topological Ordering 就可以看到所有我寫過的應用題目</p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="http://web.ntnu.edu.tw/~algo/DirectedAcyclicGraph.html#2" target="_blank" rel="noopener">師大演算法 - Topological Ordering </a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>想註解真的是一件很難的事情！我腦袋滿滿的想法就是講不出來…，是我的高職國文沒有學好嗎，感覺自己的詞彙量沒有很大，還需要再好好進步，讓自己對於國文的表達能力在更好些。</p>
<h2 id="Topological-Ordering-無註解程式碼"><a href="#Topological-Ordering-無註解程式碼" class="headerlink" title="Topological Ordering 無註解程式碼"></a>Topological Ordering 無註解程式碼</h2><p>這裡則放置沒有註解的程式碼，如果讀者想要複製就從這裡進行複製吧！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n, m, a, b;</span><br><span class="line"><span class="keyword">int</span> cnt[MAXN];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; root[MAXN], ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">topo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt[i] == <span class="number">0</span>) q.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> now;</span><br><span class="line">    ans.clear();</span><br><span class="line">    <span class="keyword">while</span>(ans.size() != n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(q.empty()) <span class="keyword">break</span>;</span><br><span class="line">        now = q.front(); q.pop_front();</span><br><span class="line">        ans.push_back(now);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it: root[now])&#123;</span><br><span class="line">            cnt[it]--;</span><br><span class="line">            <span class="keyword">if</span>(cnt[it] == <span class="number">0</span>) q.push_back(it);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ans.size() == n)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; ans.size(); i++) <span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; ans[i];</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>演算法知識</category>
      </categories>
      <tags>
        <tag>程式解題</tag>
        <tag>演算法知識</tag>
        <tag>Topological Ordering 拓樸排序</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa10305 - Ordering Tasks(拓樸排序)</title>
    <url>/2021/02/27/UVa/UVa10305/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>John 有很多任務要做，但有些任務息息相關，希望你可以幫他寫出一份任務清單讓他來做任務</p>
<p><a href="https://onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1246" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li><a href="https://theriseofdavid.github.io/2021/02/26/Explain_Algorithm/Topological_Ordering/" target="_blank" rel="noopener">拓樸排序</a>的應用</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>簡單的拓樸排序，如果不太懂拓樸排序就看 <a href="https://theriseofdavid.github.io/2021/02/26/Explain_Algorithm/Topological_Ordering/" target="_blank" rel="noopener">演算法知識 - Topological Ordering 拓樸排序(時間複雜度 O(V+E))</a>，有對於一些拓樸排序有些基礎的教學，希望大家都可以看懂。</p>
<p>標準模板題，但要注意必需 n and m 都要是 <strong>0</strong> 才可以把程式終止喔，這題會有 n or m 一個零的情況。</p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="http://web.ntnu.edu.tw/~algo/DirectedAcyclicGraph.html#2" target="_blank" rel="noopener">師大演算法 - Topological Ordering </a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>這題真的是師大演算法給我大助攻阿！發現開學後我的腦袋變得沒有原本寒假時候清晰了，太多雜事要忙要做了，都沒有辦法用心做這件事，以前還記得的演算法現在都忘記了，現在趕快補這些知識回來。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。 </p>
<p>下面 <code>topo function</code> 的程式碼 <a href="https://theriseofdavid.github.io/2021/02/26/Explain_Algorithm/Topological_Ordering/" target="_blank" rel="noopener">演算法知識 - Topological Ordering 拓樸排序(時間複雜度 O(V+E))</a> 相同，就不寫講解，如果不太懂直接看此網頁就好。</p>
<ul>
<li>紀錄關係<br>a,b ，則 a 必須在 b 前面、c,d，則 c 必須在 d 前面，此時我們會稱 a,c 為前面節點、b,d 是後面節點。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 120</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, a, b;</span><br><span class="line"><span class="keyword">int</span> cnt[MAXN]; </span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; root[MAXN], ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">topo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt[i] == <span class="number">0</span>) q.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> now;</span><br><span class="line">    ans.clear();</span><br><span class="line">    <span class="keyword">while</span>(ans.size() != n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(q.empty()) <span class="keyword">break</span>;</span><br><span class="line">        now = q.front(); q.pop_front();</span><br><span class="line">        ans.push_back(now);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it: root[now])&#123;</span><br><span class="line">            cnt[it]--;</span><br><span class="line">            <span class="keyword">if</span>(cnt[it] == <span class="number">0</span>) q.push_back(it);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ans.size() == n)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; ans.size(); i++) <span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; ans[i];</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="comment">//freopen("out.txt", "w", stdout);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &amp;&amp; n + m != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) root[i].clear(); <span class="comment">//將資料清空，以免這次測資被上次測資干擾</span></span><br><span class="line">        <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span>(cnt)); </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123; <span class="comment">//輸入資料</span></span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">            root[a].push_back(b); <span class="comment">//記錄關係，記錄 a 有多少後面節點，並且記錄。</span></span><br><span class="line">            <span class="comment">//這裡的後面節點須看 [大衛的筆記 拓樸排序] 意思。</span></span><br><span class="line">            cnt[b]++; <span class="comment">//記錄有幾個前面節點</span></span><br><span class="line">        &#125;</span><br><span class="line">        topo(); <span class="comment">//拓樸排序開始</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>Topological Ordering 拓樸排序</tag>
      </tags>
  </entry>
  <entry>
    <title>統計學(二) 筆記 - 第九章 假說檢定(hypothesis testing)</title>
    <url>/2021/02/27/NTUT_note/statistics-ch9/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊與財金管理系大二下統計學重點整理<br><font color="#dd0000">並非所有人都適用，部分對我而言稍加容易的內容並不會寫在此內。</font><br><strong>這是觀看影片心得後的筆記，老師上課可能不太適用會忘記抄到</strong></p>
</blockquote>
<a id="more"></a>

<h2 id="假說檢定-hypothesis-testing-介紹"><a href="#假說檢定-hypothesis-testing-介紹" class="headerlink" title="假說檢定(hypothesis testing) 介紹"></a>假說檢定(hypothesis testing) 介紹</h2><p>決定一個數值透過母體參數產生的是否可以信任。</p>
<p>信任就是對立假設，反之虛無假設。</p>
<ul>
<li>虛無假設 null hypothesis<br>表示這個人是亂猜的，就是虛無假設，透過 \(H_0\) 表示。</li>
<li><strong>拒絕</strong>虛無假設 reject null hypothesis<br>通常拒絕虛無假設以機率來進行計算，常見的有 \(1 \%\)、\(5 \%\)、\(10 \%\)，也就是當虛無假設機率低於一定值時就是對立假設。</li>
<li>對立假設 alternative hypothesis<br>透過 boolean 來想虛無假設是 false，對立假設就是 true，透過 \(H_1 \) or \(H_A \) 表示。</li>
</ul>
<h2 id="在-Probability-Distribution-APP-上計算-z-值的方法"><a href="#在-Probability-Distribution-APP-上計算-z-值的方法" class="headerlink" title="在 Probability Distribution APP 上計算 z 值的方法"></a>在 Probability Distribution APP 上計算 z 值的方法</h2><ul>
<li>在母體平均值已知的情況下打開 APP，點 <code>normal</code><ul>
<li>算出 z 後，將 z 的值放入 x</li>
<li>決定左尾、右尾、雙尾，在紅色格子的 \(P(X&gt;x)\) 這邊可以選擇，第一個是右尾、第二左尾、第三雙尾</li>
<li>圖片說明<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1mfPzfLCmLPsrfex4bcFUsSf-8g0tQpnj&export=download" alt=""></p>
</blockquote>
</li>
</ul>
</li>
<li>在母體平均值已知的情況下打開 APP，點 <code>t</code><ul>
<li>算出 z 後，將 z 的值放入 x</li>
<li>t 為樣本數量 -1</li>
<li>決定左尾、右尾、雙尾，在紅色格子的 \(P(X&gt;x)\) 這邊可以選擇，第一個是右尾、第二左尾、第三雙尾</li>
<li>圖片說明<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1VkQccUO68-RR_LnC2FDKlUZVEbMnUKTu&export=download" alt=""></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="如何決定虛無假設與對立假設"><a href="#如何決定虛無假設與對立假設" class="headerlink" title="如何決定虛無假設與對立假設"></a>如何決定虛無假設與對立假設</h3><ul>
<li>對立假設就是我們研究論點<br>也就是決定好甚麼是 TRUE 甚麼是 FALSE，通常對立假設就是我們研究論點，透過對立假設來證明我們的論點是對的，先設定 \(H_1\) 在設定 \(H_0 \)。<ul>
<li>舉例：九點上課會不會讓學生有精神？<ul>
<li>\(H_1 \) 九點上課比較好</li>
<li>\(H_0\)  九點上課並不會讓學生比較好。</li>
</ul>
</li>
</ul>
</li>
<li>用假設檢定挑戰別人的論點<br>此時我們的目標是讓別人的論點 false，以否定別人論點為目標，因此先設定 \(H_0\) 在設定 \(H_1 \)<ul>
<li>舉例：當前政策內車道禁行機車會比較好嗎?<ul>
<li>\(H_0 \) 不會比較好</li>
<li>\(H_1\)  是好的沒錯</li>
</ul>
</li>
</ul>
</li>
<li>統整，使用方法<ul>
<li>利用樣本統計量驗證的假設 \(H_1\)</li>
<li>他人主張 \(H_0\)</li>
<li>會造成負面結果的 \(H_0\)，正面放 \(H_1\)</li>
<li>反面主張 \(H_0\)，</li>
<li>通常正面放 \(H_1\)，反面 \(H_0\)</li>
</ul>
</li>
</ul>
<h1 id="母體平均數假設檢定-Summary-of-Forms-for-Null-and-Alternative-Hypotheses-about-a-Population-Mean"><a href="#母體平均數假設檢定-Summary-of-Forms-for-Null-and-Alternative-Hypotheses-about-a-Population-Mean" class="headerlink" title="母體平均數假設檢定 Summary of Forms for Null and Alternative Hypotheses about a Population Mean"></a>母體平均數假設檢定 Summary of Forms for Null and Alternative Hypotheses about a Population Mean</h1><p>使用此檢定時，有一定義<strong>如果母體平均數相等時，則永遠都表示虛無假設</strong>，因為如果驗證一樣時，那就並不是我們研究的論點所支持，還是他人的論點相同，無法推翻。</p>
<p>在此檢定中用來判斷假設的標準通常是者幾種</p>
<ul>
<li>Lower-tail 左尾<ul>
<li>\(H_0 = \mu \geq u_0 \) </li>
<li>\(H_1 = \mu &lt; u_0 \) </li>
</ul>
</li>
<li>Upper-tail 右尾<ul>
<li>\(H_0 = \mu \leq u_0 \) </li>
<li>\(H_1 = \mu &lt; u_0 \) </li>
</ul>
</li>
<li>Two-tailed 兩尾<ul>
<li>\(H_0 = \mu = u_0 \) </li>
<li>\(H_1 = \mu != u_0 \) </li>
</ul>
</li>
</ul>
<h3 id="舉例：某一城市有-20-個醫療人員，平均只需要-12-分鐘就可以服務，決定虛無假設與對立假設，如果沒有達到-12-分鐘就要進行改善。"><a href="#舉例：某一城市有-20-個醫療人員，平均只需要-12-分鐘就可以服務，決定虛無假設與對立假設，如果沒有達到-12-分鐘就要進行改善。" class="headerlink" title="舉例：某一城市有 20 個醫療人員，平均只需要 12 分鐘就可以服務，決定虛無假設與對立假設，如果沒有達到 12 分鐘就要進行改善。"></a>舉例：某一城市有 20 個醫療人員，平均只需要 12 分鐘就可以服務，決定虛無假設與對立假設，如果沒有達到 12 分鐘就要進行改善。</h3><p>這邊我們要判斷是否達到目標，沒有則要進行改善，因此這邊我們認為是需要改善所以對立假設就會是 \(H_1 = \mu &gt; 12 \)<br>虛無假設就是 \(H_0 = \mu \leq 12 \)<br>對立假設就是 \(H_1 = \mu &gt; 12 \)</p>
<p><strong>要特別注意我們的檢定資料是使用母體還是抽測樣本</strong></p>
<h2 id="型一錯誤-Type1-Error-or-顯著性檢定-significance-tests"><a href="#型一錯誤-Type1-Error-or-顯著性檢定-significance-tests" class="headerlink" title="型一錯誤 Type1 Error or 顯著性檢定 significance tests"></a>型一錯誤 Type1 Error or 顯著性檢定 significance tests</h2><p>我們認為 \(H_0\) 是錯誤的，但其實是對的。</p>
<p>透過樣本資料推出的假設檢定是對的，但是樣本資料明顯與母體資料偏差。</p>
<p>型一錯誤 Type1 Error 也稱為 顯著性檢定 significance tests </p>
<h2 id="型二錯誤-Type2-Error"><a href="#型二錯誤-Type2-Error" class="headerlink" title="型二錯誤 Type2 Error"></a>型二錯誤 Type2 Error</h2><p>我們認為 \(H_0\) 是對的，但其實並不是正確的。</p>
<p>由於這種錯誤通常沒有辦法發現，需要等到再次驗證時才有機率發現(類似於 bug)，因此為了避免一開始說錯的風險，所以會用比較保守的說法，我們<strong>不反對 \(H_0\)</strong>，而不是我們<strong>相信 \(H_0\)</strong>。</p>
<p>通常在沒有足夠信心時使用。</p>
<blockquote>
<p>統整<br><img src="https://drive.google.com/u/2/uc?id=1c6CvvbRpAqi86sUR5N9NyXmAWnK761bQ&export=download" alt=""></p>
</blockquote>
<h2 id="p-Value-Approach-to-One-Tailed-Hypothesis-Testing-p-值法單尾假設檢定"><a href="#p-Value-Approach-to-One-Tailed-Hypothesis-Testing-p-值法單尾假設檢定" class="headerlink" title="p-Value Approach to One-Tailed Hypothesis Testing p 值法單尾假設檢定"></a>p-Value Approach to One-Tailed Hypothesis Testing p 值法單尾假設檢定</h2><p>p 本身的意思是 probability 也就是要找機率(可能性)，根據樣本結果可以支持虛無假設的機率是多少？</p>
<p>如果 p-value 越小且小於顯著姓測試 \(\alpha \)，我們就可以拒絕虛無假設。</p>
<p>因此公式就是：拒絕 \(H_0 \) if the \(p-value \leq \alpha \)</p>
<p>透過標準差 z，我們去設定顯著性測試的 \(z_a\)，與結果的 z 來判斷是否支持虛無假設</p>
<h3 id="Lower-Tailed-Test-About-a-Population-Mean-左尾-p-value-檢定法"><a href="#Lower-Tailed-Test-About-a-Population-Mean-左尾-p-value-檢定法" class="headerlink" title="Lower-Tailed Test About a Population Mean 左尾 p-value 檢定法"></a>Lower-Tailed Test About a Population Mean 左尾 p-value 檢定法</h3><p>透過常態分配的方法，只要我們的 z 值小於顯著性測試的 \(z_a\) 值時我們就可以拒絕此虛無假設</p>
<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1LvvtPA1gAe1rcFKeKQHMAFEvBaur1zqb&export=download" alt=""></p>
</blockquote>
<h3 id="Upper-Tailed-Test-About-a-Population-Mean-右尾-p-value-檢定法"><a href="#Upper-Tailed-Test-About-a-Population-Mean-右尾-p-value-檢定法" class="headerlink" title="Upper-Tailed Test About a Population Mean 右尾 p-value 檢定法"></a>Upper-Tailed Test About a Population Mean 右尾 p-value 檢定法</h3><p>與上方類似，只要我們的 z 值<strong>大於</strong>顯著性測試的 \(z_a\) 值時我們就可以拒絕此虛無假設</p>
<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1DAOfWZqgz2C3kZv2M8p9vCVSDCB111RM&export=download" alt=""></p>
</blockquote>
<h2 id="Critical-Value-Approach-to-One-Tailed-Hypothesis-Testing-臨界值檢定法"><a href="#Critical-Value-Approach-to-One-Tailed-Hypothesis-Testing-臨界值檢定法" class="headerlink" title="Critical Value Approach to One-Tailed Hypothesis Testing 臨界值檢定法"></a>Critical Value Approach to One-Tailed Hypothesis Testing 臨界值檢定法</h2><p>一樣透過標準常態機率分配的 \(z_a\) 值來判斷，設定一個面積，只要我們的檢測值落在 \(z_a\) 面積上就可以拒絕此假設</p>
<ul>
<li>Lower tail: Reject \(H_0\) if \(z \leq - z_a\)</li>
<li>Upper tail: Reject \(H_0\) if \(z \geq - z_a\)</li>
</ul>
<h3 id="Lower-Tailed-Test-About-a-Population-Mean-左尾臨界值檢定法"><a href="#Lower-Tailed-Test-About-a-Population-Mean-左尾臨界值檢定法" class="headerlink" title="Lower-Tailed Test About a Population Mean 左尾臨界值檢定法"></a>Lower-Tailed Test About a Population Mean 左尾臨界值檢定法</h3><p>設定 \(z_a\) 的值，以下圖來看如果檢測結果 z 值落在<strong>藍色面積</strong>，就拒絕，沒有就不拒絕</p>
<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1RJeKWXMcuanfhh9cb42JgEiYNJZXVcyP&export=download" alt=""></p>
</blockquote>
<h3 id="Upper-Tailed-Test-About-a-Population-Mean-右尾臨界值檢定法"><a href="#Upper-Tailed-Test-About-a-Population-Mean-右尾臨界值檢定法" class="headerlink" title="Upper-Tailed Test About a Population Mean 右尾臨界值檢定法"></a>Upper-Tailed Test About a Population Mean 右尾臨界值檢定法</h3><p>設定 \(z_a\) 的值，以下圖來看如果檢測結果 z 值落在<strong>藍色面積</strong>，就拒絕，沒有就不拒絕</p>
<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1cUqgMdoQJl0sQCdCqx711Fm1auBfc5ND&export=download" alt=""></p>
</blockquote>
<h2 id="Steps-of-Hypoththesis-Testing-假設檢定的步驟，母體平均數已知的情況"><a href="#Steps-of-Hypoththesis-Testing-假設檢定的步驟，母體平均數已知的情況" class="headerlink" title="Steps of Hypoththesis Testing 假設檢定的步驟，母體平均數已知的情況"></a>Steps of Hypoththesis Testing 假設檢定的步驟，母體平均數已知的情況</h2><ul>
<li>建立虛無假設與對立假設</li>
<li>設定顯著性測試</li>
<li>收集樣本資料，計算 z</li>
<li>使用方法<ul>
<li>p-Value Approach<ul>
<li>計算 p-value</li>
<li>根據 p-value 判斷是否拒絕虛無假設</li>
</ul>
</li>
<li>Critical Value Approach<ul>
<li>設定顯著型測試的區間</li>
<li>根據樣本的 z 值判斷是否落在拒絕區間</li>
</ul>
</li>
</ul>
</li>
<li>透過這兩種方法檢測答案都必須相同</li>
</ul>
<h3 id="舉例-抽取-40-筆樣本資料，平均回應緊急時間為-13-25-min，母體標準差為-3-2，做一假設檢定，0-05-的顯著性測試，能不能在-12-分鐘以內回應緊急事件，不行則進行改善"><a href="#舉例-抽取-40-筆樣本資料，平均回應緊急時間為-13-25-min，母體標準差為-3-2，做一假設檢定，0-05-的顯著性測試，能不能在-12-分鐘以內回應緊急事件，不行則進行改善" class="headerlink" title="舉例 - 抽取 40 筆樣本資料，平均回應緊急時間為 13.25 min，母體標準差為 3.2，做一假設檢定，0.05 的顯著性測試，能不能在 12 分鐘以內回應緊急事件，不行則進行改善"></a>舉例 - 抽取 40 筆樣本資料，平均回應緊急時間為 13.25 min，母體標準差為 3.2，做一假設檢定，0.05 的顯著性測試，能不能在 12 分鐘以內回應緊急事件，不行則進行改善</h3><ul>
<li>建立虛無假設與對立假設<ul>
<li>\(H_0: \mu \leq 12 \)</li>
<li>\(H_1: \mu &gt; 12\)，由於我們的觀點是想要進行改善，因此設定 \(H_1: \mu &gt; 12\)</li>
</ul>
</li>
<li>設定顯著性測試 0.5</li>
<li>收集樣本，計算 z<br>\(z = \frac{\bar{x} - \mu_0}{\sigma / \sqrt{n}} = \frac{13.25 - 12}{3.2 / \sqrt{40}} = 2.47\)</li>
<li>使用方法<ul>
<li>p-Value Approach<ul>
<li>計算 p-value<br>\(z = 2.47\)，算出 0.9932，\(p-value = 1 - 0.9932 = 0.0068\)</li>
<li>根據 p-value 判斷是否拒絕虛無假設<br>\(\alpha = 0.05 \geq 0.0068 = p-value\)，因此拒絕 \(H_0\)。因此我們沒有辦法在 12 分鐘內緊急回應</li>
</ul>
</li>
<li>Critical Value Approach<ul>
<li>設定顯著型測試的區間<br>\(\alpha = 0.05, z_{0.05} = 1.645\)，因此拒絕 \(H_0 \geq 1.645\)</li>
<li>根據樣本的 z 值判斷是否落在拒絕區間<br>\(z = 2.47 &gt; 1.645 \)落在拒絕區間，因此拒絕 \(H_0\)。因此我們沒有辦法在 12 分鐘內緊急回應</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Two-Tailed-Hypothesis-雙尾假設檢定"><a href="#Two-Tailed-Hypothesis-雙尾假設檢定" class="headerlink" title="Two-Tailed Hypothesis 雙尾假設檢定"></a>Two-Tailed Hypothesis 雙尾假設檢定</h2><h3 id="p-Value-Approach-to-Two-Tailed-Hypothesis-Testing-p-值法雙尾假設檢定"><a href="#p-Value-Approach-to-Two-Tailed-Hypothesis-Testing-p-值法雙尾假設檢定" class="headerlink" title="p-Value Approach to Two-Tailed Hypothesis Testing p 值法雙尾假設檢定"></a>p-Value Approach to Two-Tailed Hypothesis Testing p 值法雙尾假設檢定</h3><ul>
<li>計算標準常態分配的 z 值</li>
<li>計算 z 的機率</li>
<li>將機率<strong>乘二</strong></li>
<li>Reject \(H_0\) if the \(p-value \leq \alpha\)</li>
</ul>
<h3 id="Critival-Value-Approach-to-Two-Tailed-Hypothesis-Testing-臨界值法雙尾假設檢定"><a href="#Critival-Value-Approach-to-Two-Tailed-Hypothesis-Testing-臨界值法雙尾假設檢定" class="headerlink" title="Critival Value Approach to Two-Tailed Hypothesis Testing 臨界值法雙尾假設檢定"></a>Critival Value Approach to Two-Tailed Hypothesis Testing 臨界值法雙尾假設檢定</h3><p>透過標準常態機率分配找出 \(z_{a/2}\) 的面積</p>
<p>因此 Reject \(H_0\) if the \(z \leq -z_{a/2}\) or \(z \geq z_{a/2}\)</p>
<h3 id="舉例-牙膏平均重量是-6oz，進行假設檢定，如果大於或小於-6oz-就改善，抽-30-隻牙膏為樣本資料，樣本平均值是-6-1oz，標準差是-0-2oz，顯著性測試為-0-03"><a href="#舉例-牙膏平均重量是-6oz，進行假設檢定，如果大於或小於-6oz-就改善，抽-30-隻牙膏為樣本資料，樣本平均值是-6-1oz，標準差是-0-2oz，顯著性測試為-0-03" class="headerlink" title="舉例: 牙膏平均重量是 6oz，進行假設檢定，如果大於或小於 6oz 就改善，抽 30 隻牙膏為樣本資料，樣本平均值是 6.1oz，標準差是 0.2oz，顯著性測試為 0.03"></a>舉例: 牙膏平均重量是 6oz，進行假設檢定，如果大於或小於 6oz 就改善，抽 30 隻牙膏為樣本資料，樣本平均值是 6.1oz，標準差是 0.2oz，顯著性測試為 0.03</h3><ul>
<li>建立虛無假設與對立假設<ul>
<li>\(H_0: \mu = 6\)</li>
<li>\(H_1: \mu &lt;&gt; 6 \)</li>
</ul>
</li>
<li>設定顯著性測試 0.03</li>
<li>收集樣本，計算 z<br>\(z = \frac{\bar{x} - \mu_0}{\sigma / \sqrt{n}} = \frac{6.1 - 6}{0.2 / \sqrt{30}} = 2.74\)</li>
<li>使用方法<ul>
<li>p-Value Approach<ul>
<li>計算 p-value<br>\(z = 2.74\)，算出 0.9969，\(p-value = 2(1 - 0.9932) = 0.0062\)</li>
<li>根據 p-value 判斷是否拒絕虛無假設<br>\(\alpha = 0.03 \geq 0.0062 = p-value\)，因此拒絕 \(H_0\)。因此需要進行改善</li>
<li>用圖進行解釋<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1T22SDb3Q8g6nCS9H1-_3hUb1b1uRQ7lJ&export=download" alt=""></p>
</blockquote>
</li>
</ul>
</li>
<li>Critical Value Approach<ul>
<li>設定顯著型測試的區間<br>\(\alpha / 2 = 0.03 / 2 = 0.015 , z_{0.015} = 2.17\)，因此拒絕 \(H_0 \geq 2.17\)</li>
<li>根據樣本的 z 值判斷是否落在拒絕區間<br>\(z = 2.47 &gt; 2.17 \)落在拒絕區間，因此拒絕 \(H_0\)。因此我們沒有辦法在 12 分鐘內緊急回應</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Confidence-Interval-Approach-to-Two-Tailed-Hypothesis-Testing-信賴區間法雙尾假設檢定"><a href="#Confidence-Interval-Approach-to-Two-Tailed-Hypothesis-Testing-信賴區間法雙尾假設檢定" class="headerlink" title="Confidence Interval Approach to Two-Tailed Hypothesis Testing 信賴區間法雙尾假設檢定"></a>Confidence Interval Approach to Two-Tailed Hypothesis Testing 信賴區間法雙尾假設檢定</h3><p>計算信賴區間的公式為 \(\bar{x} \pm z_{a/2} \frac{\sigma}{\sqrt{n}}\)，如果假設檢定的值在信賴區間內時我們就<strong>不拒絕零 (to reject)</strong>，但如果在<strong>等於的情況時必須拒絕</strong>。</p>
<h4 id="透過剛剛舉例算信賴區間法雙尾假設檢定法"><a href="#透過剛剛舉例算信賴區間法雙尾假設檢定法" class="headerlink" title="透過剛剛舉例算信賴區間法雙尾假設檢定法"></a>透過剛剛舉例算信賴區間法雙尾假設檢定法</h4><p>顯著性測試為 0.03，因此有百分之 97 的信賴區間，因此 \(\mu \) 要是 \(\bar{x} \pm z_{a/2} \frac{\sigma}{\sqrt{n}} = 6.1 \pm 2.17(0.2 / \sqrt{30}) = 6.1 \pm 0.07924\)，也就是 6.02076 to 6.17924，因此 \( \mu_0 = 6 \) 不再此區間，因此拒絕 \(H_0\)。</p>
<h2 id="Steps-of-Hypoththesis-Testing-假設檢定的步驟，母體平均數未知的情況"><a href="#Steps-of-Hypoththesis-Testing-假設檢定的步驟，母體平均數未知的情況" class="headerlink" title="Steps of Hypoththesis Testing 假設檢定的步驟，母體平均數未知的情況"></a>Steps of Hypoththesis Testing 假設檢定的步驟，母體平均數未知的情況</h2><p>這時候就需要用到 t 了XD，公式為 \(t = \frac{\bar{x} - \mu_0}{s / \sqrt{n}}\)，其中 \(n - 1\) 就是自由度</p>
<ul>
<li>p-Value Approach<br>Reject \(H_0\) if \(\alpha \geq p-value\)</li>
<li>Critical Value Approach<ul>
<li>\(H_0: \mu \geq \mu_0 \) Reject \(H_0\) if \(t \leq -t_{a}\)</li>
<li>\(H_0: \mu \leq \mu_0 \) Reject \(H_0\) if \(t \geq t_{a}\)</li>
<li>\(H_0: \mu = \mu_0\) Reject \(H_0\) if \(t \leq -t_{a/2} \ or t \geq t_{a/2} \ \)</li>
</ul>
</li>
<li>p-Value and the t Distribution<br>如果用統計書的附錄算 t 值，大多不太精準，因此盡量使用軟體上的來計算。</li>
</ul>
<h3 id="舉例：高速公路常常會超速，因此我們要設測速照相機，測速的速度我們想假設為-65，進行假設檢定，在-64-筆的樣本資料，平均速度是-66-2，標準差-4-2，顯著性測試為-0-05"><a href="#舉例：高速公路常常會超速，因此我們要設測速照相機，測速的速度我們想假設為-65，進行假設檢定，在-64-筆的樣本資料，平均速度是-66-2，標準差-4-2，顯著性測試為-0-05" class="headerlink" title="舉例：高速公路常常會超速，因此我們要設測速照相機，測速的速度我們想假設為 65，進行假設檢定，在 64 筆的樣本資料，平均速度是 66.2，標準差 4.2，顯著性測試為 0.05"></a>舉例：高速公路常常會超速，因此我們要設測速照相機，測速的速度我們想假設為 65，進行假設檢定，在 64 筆的樣本資料，平均速度是 66.2，標準差 4.2，顯著性測試為 0.05</h3><ul>
<li>建立虛無假設與對立假設<ul>
<li>\(H_0: \mu \leq 65 \)</li>
<li>\(H_1: \mu &gt; 65 \)</li>
</ul>
</li>
<li>設定顯著性測試 0.05</li>
<li>收集樣本，計算 z<br>\(z = \frac{\bar{x} - \mu_0}{\sigma / \sqrt{n}} = \frac{66.2 - 65}{4.2 / \sqrt{64}} = 2.286\)<ul>
<li>p-Value Approach<ul>
<li>計算 p-value<br>\(t = 2.286\)，算出 0.01281</li>
<li>根據 p-value 判斷是否拒絕虛無假設<br>\(\alpha = 0.05 \geq 0.01281 = p-value\)，因此拒絕 \(H_0\)。因此大部分這邊人都會超速，可以設測速照相</li>
</ul>
</li>
<li>Critical Value Approach<ul>
<li>設定顯著型測試的區間<br>\(\alpha  = 0.05 , d.f. = 64 - 1 = 63, t_{0.005} = 1.669\)，因此 reject \(h_0\) if \(t \geq 1.669\)</li>
<li>根據樣本的 z 值判斷是否落在拒絕區間<br>\(t = 2.286 &gt; 1.669 \)落在拒絕區間，因此拒絕 \(H_0\)。因此大部分這邊人都會超速，可以設測速照相</li>
</ul>
</li>
</ul>
</li>
<li>圖片解釋<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1lbc1gj5E5u0ZGL90IrvbfTe7TELQkAc0&export=download" alt=""></p>
</blockquote>
</li>
</ul>
<h1 id="A-Summary-of-Forms-for-Null-and-Alternaitve-Hypotheses-About-a-Population-Proportion-母體參數假設檢定"><a href="#A-Summary-of-Forms-for-Null-and-Alternaitve-Hypotheses-About-a-Population-Proportion-母體參數假設檢定" class="headerlink" title="A Summary of Forms for Null and Alternaitve Hypotheses About a Population Proportion 母體參數假設檢定"></a>A Summary of Forms for Null and Alternaitve Hypotheses About a Population Proportion 母體參數假設檢定</h1><ul>
<li>等號永遠都在 \(H_0\)</li>
<li>以 p 表示母體比例</li>
<li>\(p_0\) 就是虛無假設</li>
<li>Lower-tail 左尾<ul>
<li>\(H_0 = p \geq p_0 \) </li>
<li>\(H_1 = p &lt; p_0 \) </li>
</ul>
</li>
<li>Upper-tail 右尾<ul>
<li>\(H_0 = p \leq p_0 \) </li>
<li>\(H_1 = p &lt; p_0 \) </li>
</ul>
</li>
<li>Two-tailed 兩尾<ul>
<li>\(H_0 = p = p_0 \) </li>
<li>\(H_1 = p != p_0 \) </li>
</ul>
</li>
</ul>
<h2 id="計算會用到的數值"><a href="#計算會用到的數值" class="headerlink" title="計算會用到的數值"></a>計算會用到的數值</h2><ul>
<li>z 的公式為 \(z = \frac{\bar{p} - p_0}{\sigma_\bar{p}}\)，用到的 p 為假設檢定所設定 \(H_0\)的 p 值</li>
<li>\(\sigma_\bar{p}\) 為 \(\sigma_\bar{p} = \frac{\sqrt{p_0(1-p_0)}}{n}\)</li>
<li>其中在使用 z 公式時，\(np \geq 5\) and \(n(1-p) \geq 5\)</li>
</ul>
<h2 id="P-Value-Approach-and-Critical-Value-Approach-Rejection-Rule-p-值法與臨界值法拒絕法則"><a href="#P-Value-Approach-and-Critical-Value-Approach-Rejection-Rule-p-值法與臨界值法拒絕法則" class="headerlink" title="P-Value Approach and Critical Value Approach Rejection Rule p 值法與臨界值法拒絕法則"></a>P-Value Approach and Critical Value Approach Rejection Rule p 值法與臨界值法拒絕法則</h2><ul>
<li>p-value<br>Reject \( H_0\) if \(p-value \leq \alpha\)</li>
<li>Critical Value<ul>
<li>\(H_0: p \leq p_0\) Reject \(H_0 \) if \(z \leq z_a\)</li>
<li>\(H_0: p \geq p_0\) Reject \(H_0 \) if \(z \geq z_a\)</li>
<li>\(H_0: p = p_0\) Reject \(H_0 \) if \(z \leq -z_{a/2} \ or \ z \geq z_{a/2}\)</li>
</ul>
</li>
</ul>
<h3 id="舉例-在新年期間中，國道車禍有-500-人死亡，其中有-50-是酒駕造成，樣本資料中-120-筆有-67-筆是酒駕，使用假設檢定，並且顯著性測試為-0-05，我們想要推翻其推論"><a href="#舉例-在新年期間中，國道車禍有-500-人死亡，其中有-50-是酒駕造成，樣本資料中-120-筆有-67-筆是酒駕，使用假設檢定，並且顯著性測試為-0-05，我們想要推翻其推論" class="headerlink" title="舉例: 在新年期間中，國道車禍有 500 人死亡，其中有 50 % 是酒駕造成，樣本資料中 120 筆有 67 筆是酒駕，使用假設檢定，並且顯著性測試為 0.05，我們想要推翻其推論"></a>舉例: 在新年期間中，國道車禍有 500 人死亡，其中有 50 % 是酒駕造成，樣本資料中 120 筆有 67 筆是酒駕，使用假設檢定，並且顯著性測試為 0.05，我們想要推翻其推論</h3><ul>
<li>設定假設<ul>
<li>\(H_0: p = 0.5 \)</li>
<li>\(H_1: p != 0.5 \)</li>
</ul>
</li>
<li>設定顯著性測試 0.05</li>
<li>收集樣本，計算 z and \(\sigma_\bar{p}\)，<strong>其中下面的 \(p_0\) 就是 \(H_0: p\)，也就是 0.5</strong><ul>
<li>\(\sigma_{\bar{p}} = \sqrt{\frac{p_0 (1-p_0)}{n}} = \frac{0.5(1-0.5)}{120} = 0.045644\)，注意是要用 \(H_0\) 的值</li>
<li>\(z = \frac{\bar{p} - p_0 }{\sigma_\bar{p}} = \frac{(67/120)-0.5}{0.045644} = 1.28\)</li>
</ul>
</li>
<li>兩方法計算<ul>
<li>p-Value Approach<ul>
<li>\(z = 1.28, p = 0.8997\)，\(1-p-value = 2(1 - 0.8997) = 0.2006\)</li>
<li>因為 \(p-value = 0.2006 &gt; \alpha = 0.05\)，因此我們不能拒絕 \(H_0\)</li>
</ul>
</li>
<li>Critical Value Approach<ul>
<li>\(a / 2 = 0.05/2 = 0.025， z_{0.025} = 1.96\)，因此 Reject \(H_0\) if \(z \leq -1.96 \ or \ z \geq 1.96 \)</li>
<li>1.278 介於 -1.96 與 1.96 之間，因此我們不能拒絕 \(H_0\)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="Hypothesis-Testing-and-Decision-Making-假設檢定的決策"><a href="#Hypothesis-Testing-and-Decision-Making-假設檢定的決策" class="headerlink" title="Hypothesis Testing and Decision Making 假設檢定的決策"></a>Hypothesis Testing and Decision Making 假設檢定的決策</h1><ul>
<li>如果答案是拒絕 \(H_0\)，就必須修改決策</li>
<li>如果答案是不拒絕 \(H_0\)，就不用修改決策</li>
</ul>
<h1 id="Calculating-the-Probability-of-a-Type-2-Error-in-Hypothesis-Tests-About-a-Population-Mean-母體平均值計算-Type-2-Error"><a href="#Calculating-the-Probability-of-a-Type-2-Error-in-Hypothesis-Tests-About-a-Population-Mean-母體平均值計算-Type-2-Error" class="headerlink" title="Calculating the Probability of a Type 2 Error in Hypothesis Tests About a Population Mean 母體平均值計算 Type 2 Error"></a>Calculating the Probability of a Type 2 Error in Hypothesis Tests About a Population Mean 母體平均值計算 Type 2 Error</h1><ul>
<li>列出 \(H_0\) and \(H_1\)</li>
<li>使用 Critical Value Approach 與顯著型測試，確認是否符合拒絕法則(Reject \(H_0\))</li>
<li>找出 z 在甚麼情況會接受 \(H_0\)，我們將此定義為 \(\bar{x}\)</li>
<li>給定 \(\mu \) 是大於顯著型測試的範圍，</li>
</ul>
<h2 id="舉例-EMS-隨機抽取-40-筆資料，平均數-13-25-分鐘，母體標準差是-3-2-分鐘，顯著性測試為-0-05，我們想知道緊急服務抵達會不會小於-12-分鐘，不會就改善。"><a href="#舉例-EMS-隨機抽取-40-筆資料，平均數-13-25-分鐘，母體標準差是-3-2-分鐘，顯著性測試為-0-05，我們想知道緊急服務抵達會不會小於-12-分鐘，不會就改善。" class="headerlink" title="舉例: EMS 隨機抽取 40 筆資料，平均數 13.25 分鐘，母體標準差是 3.2 分鐘，顯著性測試為 0.05，我們想知道緊急服務抵達會不會小於 12 分鐘，不會就改善。"></a>舉例: EMS 隨機抽取 40 筆資料，平均數 13.25 分鐘，母體標準差是 3.2 分鐘，顯著性測試為 0.05，我們想知道緊急服務抵達會不會小於 12 分鐘，不會就改善。</h2><ul>
<li>設定假設<ul>
<li>\(H_0: mu \leq  12 \)</li>
<li>\(H_1: \mu &gt; 12 \)</li>
</ul>
</li>
<li>Reject rule is: Reject \(H_0\) if \(z \geq 1.645\)</li>
<li>計算樣本平均值拒絕的區域<ul>
<li>\(z = \frac{\bar{x}-12}{3.2 / \sqrt{40}} \geq 1.645\)</li>
<li>\(\bar{x} \geq 12 + 1.645 (\frac{3.2}{\sqrt{40}}) = 12.8323\)</li>
</ul>
</li>
<li>因此我們接受 \(H_0\) 必須在 \(\bar{x} &lt; 12.8323\)</li>
<li>計算 Type2 Error  <ul>
<li>我們先假設一個值，此值要是符合 \(H_1\)，這裡假設為 14，因此 \(\mu = 14\)</li>
<li>計算樣本標準差 \(\sigma_\bar{x} = \frac{3.2}{\sqrt{40}} = 0.5060 \)</li>
<li>計算 z 值為 \(z = \frac{\bar{x} - \mu}{\sigma / sqrt{n}} = \frac{12.8323 - 14}{3.2 / \sqrt{40}} = -2.31 \) </li>
<li>再來我們找出 \(z = -2.31 \) 的機率為 0.0104，就是 \(\beta \)</li>
<li>圖片解釋<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1qhP93dQujI_jGQcsgiCWLs32KJ7-VZZS&export=download" alt=""></p>
</blockquote>
</li>
<li>算出每個 value of mu 的 beta 係數，其中的 \(1-\beta\) 的值就是正確率，如果離 \(H_0\) 越近有很高機率會做出錯誤判斷<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1TUD1SA4j3AjLAsmtuM2GnlHBQytttqp3&export=download" alt=""></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="Power-of-the-Test-假設檢定正確率"><a href="#Power-of-the-Test-假設檢定正確率" class="headerlink" title="Power of the Test 假設檢定正確率"></a>Power of the Test 假設檢定正確率</h2><p>就是剛剛舉例中的 \(1-\beta\)，越大表示我們的正確率越高。</p>
<p>透過剛剛的例子畫成圖表表示 </p>
<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1-keA5OCOB_h-O_IAWFYsVuXbIWlw-k2i&export=download" alt=""></p>
</blockquote>
<h2 id="在一個單尾-左尾-舉例"><a href="#在一個單尾-左尾-舉例" class="headerlink" title="在一個單尾(左尾)舉例"></a>在一個單尾(左尾)舉例</h2><ul>
<li>題目一些資訊，\( \sigma = 12, n = 36, \mu = 120\)</li>
<li>設定假設<ul>
<li>\(H_0: \mu \geq  120 \)</li>
<li>\(H_1: \mu &lt; 120 \)</li>
</ul>
</li>
<li>Reject rule is: Reject \(H_0\) if \(z \leq -1.645\)</li>
<li>計算樣本平均值拒絕的區域<ul>
<li>\(z = \frac{\bar{x}-120}{12 / \sqrt{36}} \leq -1.645\)</li>
<li>\(\bar{x} \leq  - 1.645 (\frac{12}{\sqrt{36}} ) = 116.71\)</li>
</ul>
</li>
<li>因此我們接受 \(H_0\) 必須在 \(\bar{x} &gt; 116.71\)</li>
<li>計算 Type2 Error  <ul>
<li>我們先假設一個值，此值要是符合 \(H_1\)，這裡假設為 112，因此 \(\mu = 112\)</li>
<li>計算樣本標準差 \(\sigma_\bar{x} = \frac{12}{\sqrt{36}} = 2 \)</li>
<li>計算 z 值為 \(z = \frac{\bar{x} - \mu}{\sigma / \sqrt{n}} = \frac{116.71 - 112}{12 / \sqrt{36}} = 2.36 \) </li>
<li>再來我們找出 \(z = 2.36 \) 的機率為 0.0091，就是 \(\beta \)</li>
<li>圖片解釋<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=19fmdAfQql-zh8nnhPE6A5gk7xoMO6x9h&export=download" alt=""></p>
</blockquote>
</li>
<li>算出每個 value of mu 的 beta 係數，其中的 \(1-\beta\) 的值就是正確率，如果離 \(H_0\) 越近有很高機率會做出錯誤判斷<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1Jb0c1osleRhpEvtxNWV7MnzOIhKFdTdY&export=download" alt=""></p>
</blockquote>
</li>
<li>畫成圖表則是<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1cWn1hDljGIflcVOT1gyuB9YZZ1P06TV0&export=download" alt=""></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h1 id="Determining-the-Sample-Suze-for-a-Hypothesis-Test-About-a-Population-Mean-確認樣本大小來進行母體平均值假設測試"><a href="#Determining-the-Sample-Suze-for-a-Hypothesis-Test-About-a-Population-Mean-確認樣本大小來進行母體平均值假設測試" class="headerlink" title="Determining the Sample Suze for a Hypothesis Test About a Population Mean 確認樣本大小來進行母體平均值假設測試"></a>Determining the Sample Suze for a Hypothesis Test About a Population Mean 確認樣本大小來進行母體平均值假設測試</h1><p>我們先設定好型一誤差與型二誤差後，找出適合的樣本大小數量來進行假設測試 </p>
<p>用圖來進行說明，我們說些重點</p>
<ul>
<li>在這張圖中，是右尾檢定，因為 \(\mu &gt; \mu_0\)</li>
<li>左邊是 Type1 Error，右邊是 Type2 Error，c 是臨界值，兩張圖藍色的部分就是誤差區</li>
<li>因此我們可以知道兩張圖的 C 是相同</li>
<li><blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1bYpgRmwnGNVaCt01WjQ5v0ezdXn9XzL8&export=download" alt=""></p>
</blockquote>
</li>
</ul>
<p>再來我們將公式進行合併，公式計算如下</p>
<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1diujZTQvgqNnDdYUBB1yAE3IsRfkAATv&export=download" alt=""></p>
</blockquote>
<p>因此我們可以知道當我們要設定 n 的大小時的公式為 \(n = \frac{(z_a + z_b )^2 \sigma^2}{(\mu_0 - \mu_a)^2}\)</p>
<ul>
<li>\(z_a\) 是 z value 提供 \(\alpha\) 的面積</li>
<li>\(z_b\) 是 z value 提供 \(\beta\) 的面積</li>
<li>\(\sigma\) 是母體標準差</li>
<li>\(\mu_0\) 是\(H_0\)母體平均值</li>
<li>\(\mu_a\) 是母體平均值，再用於檢測 Type2 Error 的值</li>
<li>在雙尾時，\(z_a/2 \) 而不是使用 \(z_a \)</li>
</ul>
<h2 id="舉例-平均回應緊急時間為-13-25-min，母體標準差為-3-2，期望能在-12-分鐘內回應，那-Type1-Error-0-05，如果超過-0-75-分鐘的機率不可以大於-0-1，也就是-Type2-Error-0-1，求樣本大小"><a href="#舉例-平均回應緊急時間為-13-25-min，母體標準差為-3-2，期望能在-12-分鐘內回應，那-Type1-Error-0-05，如果超過-0-75-分鐘的機率不可以大於-0-1，也就是-Type2-Error-0-1，求樣本大小" class="headerlink" title="舉例: 平均回應緊急時間為 13.25 min，母體標準差為 3.2，期望能在 12 分鐘內回應，那 Type1 Error = 0.05，如果超過 0.75 分鐘的機率不可以大於 0.1，也就是 Type2 Error = 0.1，求樣本大小"></a>舉例: 平均回應緊急時間為 13.25 min，母體標準差為 3.2，期望能在 12 分鐘內回應，那 Type1 Error = 0.05，如果超過 0.75 分鐘的機率不可以大於 0.1，也就是 Type2 Error = 0.1，求樣本大小</h2><p>因此我們這邊可以先統整資訊</p>
<ul>
<li>\(\alpha = 0.05 \)</li>
<li>\(\beta = 0.1\)</li>
<li>\(z_a = 1.645\)，\(a = 0.05\)</li>
<li>\(z_b = 1.28\)，\(b = 0.1\)</li>
<li>\(\mu_0 = 12, \mu_1 = 12.75\)</li>
<li>\(\sigma = 3.2\)</li>
</ul>
<p>計算 \(n = \frac{(z_a + z_b )^2 \sigma^2}{(\mu_0 - \mu_a)^2} = \frac{(1.645+1.28)^2 (3.2)^2}{(12-12.75)^2} = 155.75 \)，約等於 156。<strong>如果數字有小數點時必須 +1，樣本沒辦法分割所以就直接加一</strong></p>
<p>一旦我們有了 \(\alpha, \beta, n\)，其中兩項，我們就可以算出另一項，透過公式我們可以提出一些重點。</p>
<ul>
<li>當 n 固定時，\(\alpha\) 變小，則 \(\beta\)變大，反之亦同。</li>
</ul>
<p><strong>謝謝大家的努力拉</strong></p>
]]></content>
      <categories>
        <category>北科上課筆記</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>統計學筆記</tag>
        <tag>北科大二下統計學筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa11060 - Beverages(拓樸排序)</title>
    <url>/2021/02/27/UVa/UVa11060/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>Dilbert 是一位學生，他喜歡喝酒的時候先喝低濃度酒精飲料，之後慢慢變濃，不會再回去喝比較低的酒精飲料，給你他要喝的飲料，在給你一些酒精的先後關係，請給他一種飲料排序是可以符合他的喝酒規則。</p>
<p><a href="https://onlinejudge.org/index.php?option=onlinejudge&Itemid=8&page=show_problem&problem=2001" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li><a href="https://theriseofdavid.github.io/2021/02/26/Explain_Algorithm/Topological_Ordering/" target="_blank" rel="noopener">拓樸排序</a>的應用</li>
<li>將酒精飲料 hash 成數值</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>簡單的拓樸排序，如果不太懂拓樸排序就看 <a href="https://theriseofdavid.github.io/2021/02/26/Explain_Algorithm/Topological_Ordering/" target="_blank" rel="noopener">演算法知識 - Topological Ordering 拓樸排序(時間複雜度 O(V+E))</a>，有對於一些拓樸排序有些基礎的教學，希望大家都可以看懂。</p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>最近不斷在複習演算法，但是內心卻因為感情的事情不斷在擔憂，真的好煩。</p>
<p>好希望自己能夠安靜下心來，順利做完每個任務，好想讓自己可以變成一個溫暖、開心的人。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。 </p>
<p>關於 function <code>topo</code> 的程式碼說明請大家點<a href="https://theriseofdavid.github.io/2021/02/26/Explain_Algorithm/Topological_Ordering/" target="_blank" rel="noopener">拓樸排序</a>，有更完整的解釋，會讓讀者更好吸收。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 220</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> cnt[MAXN];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; root[MAXN];</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; mp; <span class="comment">//飲料 hash 成數字</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; mp2; <span class="comment">//還原 hash</span></span><br><span class="line"><span class="keyword">int</span> n, m, kase; <span class="comment">//題目資訊</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">topo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt[i] == <span class="number">0</span>) q.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    <span class="keyword">int</span> now;</span><br><span class="line">    <span class="keyword">while</span>(ans.size() != n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(q.empty()) <span class="keyword">break</span>;</span><br><span class="line">        sort(q.begin(), q.end());</span><br><span class="line">        now = q.front(); q.pop_front();</span><br><span class="line">        ans.push_back(now);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it: root[now])&#123;</span><br><span class="line">            <span class="keyword">if</span>(--cnt[it] == <span class="number">0</span>) q.push_back(it);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n == ans.size())&#123; <span class="comment">//輸出資料</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Case #"</span> &lt;&lt; ++kase &lt;&lt; <span class="string">": Dilbert should drink beverages in this order:"</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it: ans) <span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; mp2[it];</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">".\n\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"out.txt"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="built_in">string</span> temp, temp2; <span class="comment">//輸入題目資料</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123; <span class="comment">//輸入資料</span></span><br><span class="line">            root[i].clear(); <span class="comment">//先清空之前資料 </span></span><br><span class="line">            cnt[i] = <span class="number">0</span>; <span class="comment">//清除之前的記錄關係</span></span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; temp;</span><br><span class="line">            mp[temp] = i; <span class="comment">//hash，由於 i 值相對應每一個資料，不會碰撞所以就用 i hash</span></span><br><span class="line">            mp2[i] = temp; <span class="comment">//記錄還原</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; m; <span class="comment">//輸入記錄關係</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123; <span class="comment">//不斷輸入 </span></span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; temp &gt;&gt; temp2;</span><br><span class="line">            root[mp[temp]].push_back(mp[temp2]); </span><br><span class="line">            <span class="comment">//記錄關係，記錄 a 有多少後面節點，並且記錄。</span></span><br><span class="line">            cnt[mp[temp2]]++; <span class="comment">//記錄有幾個前面節點，如果 b 是後面關係時。</span></span><br><span class="line">        &#125;</span><br><span class="line">        topo();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>Topological Ordering 拓樸排序</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa872 - Ordering(拓樸排序)</title>
    <url>/2021/02/27/UVa/UVa872/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>有一種排序是，給你一些英文字母，再告訴你某個英文字母必須要在另個英文字母前面(定義為記錄關係)。</p>
<p>請輸出一種排序可以符合題目的所有記錄關係。</p>
<p><a href="https://onlinejudge.org/index.php?option=onlinejudge&Itemid=8&page=show_problem&problem=813" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li><a href="https://theriseofdavid.github.io/2021/02/26/Explain_Algorithm/Topological_Ordering/" target="_blank" rel="noopener">拓樸排序</a>的應用</li>
<li>如何輸入</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>這邊我用另種方式來寫拓樸排序，想說透過 DFS 的方式看能否寫出拓樸排序，但我認為我寫得不太好，這是我的自創方式，建議還是不要多看這個。</p>
<p>但如果想要了解我的思考，還是建議看看。</p>
<p>這題比較不好輸入，要用上 <code>stringstream</code> 這是類似於 <code>cin</code>，透過這個可以方便輸入題目資料，再來記錄所有的<strong>記錄關係</strong>，每次進行 DFS 時，確認之前的 DFS 的資料都有符合記錄關係才繼續，如果沒有就退回上層 DFS。</p>
<p>缺點是每層 DFS 都要做一次確認，時間複雜度會爆炸多，建議在比賽中還是不要使用。</p>
<p>DFS 只要能夠成功就一定會是拓樸排序，因為每層都會確認關係，因此只要走到 DFS 深度與原本序列一樣長就可以。</p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://github.com/morris821028/UVa/blob/master/volume008/872%20-%20Ordering.cpp" target="_blank" rel="noopener">UVa872 - morris821028</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>其實我一開始已經忘記<strong>拓樸排序</strong>了，那是高中學的，上了大學後都忘記了…，然後在根據 Competitive Programming3，複習的過程中在寫這題 UVA，翻著有沒有其他人寫詳解，結果發現 morris821028 沒有寫詳解QQ，但是有 github，就看著他的程式碼來解，但後來發現師大演算法的 BFS 版本更好，後面就改用師大演算法的了。</p>
<p>很感謝師大演算法與 morris821028 大大，願意讓學習資源在網路上才有辦法讓我學習到，很感謝他們。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。 </p>
<ul>
<li>紀錄關係<br>a,b ，則 a 必須在 b 前面、c,d，則 c 必須在 d 前面，此時我們會稱 a,c 為前面節點、b,d 是後面節點。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 40</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">stringstream</span> ss;</span><br><span class="line"><span class="keyword">int</span> graph[MAXN], visit[MAXN]; <span class="comment">//graph 由於題目給的是字串，所以我們把它 hash 成 int</span></span><br><span class="line"><span class="comment">//visit 判斷這個點有沒有被 DFS 經歷過</span></span><br><span class="line"><span class="keyword">int</span> order[MAXN][MAXN]; <span class="comment">//order 記錄關係</span></span><br><span class="line"><span class="keyword">int</span> n, lg, flag2, flag3; <span class="comment">//n 測資長度, lg 每一個陣列長度</span></span><br><span class="line"><span class="comment">//flag2 判斷有沒有辦法拓樸排序, flag3 控制每個測資的斷行</span></span><br><span class="line"><span class="keyword">char</span> ch; <span class="comment">//用來讀字元</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans; <span class="comment">//記錄拓樸排序的陣列</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    visit[x] = <span class="number">1</span>; <span class="comment">//這個點被經歷過</span></span><br><span class="line">    ans.push_back(x); <span class="comment">//放入 ans</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//for(auto it: ans) cout &lt;&lt; (char) (it + 'A') &lt;&lt; ' ';</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; '\n';</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ans.size() == lg)&#123; <span class="comment">//如果答案陣列跟原本陣列長度一樣</span></span><br><span class="line">        flag2 = <span class="number">0</span>; <span class="comment">//有找到拓圖排序</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; (<span class="keyword">char</span>) (ans[<span class="number">0</span>] + <span class="string">'A'</span>); <span class="comment">//輸出第一個字元，這裡是嚴格輸出</span></span><br><span class="line">        <span class="comment">//輸出資料</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; ans.size(); i++) <span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; (<span class="keyword">char</span>) (ans[i] + <span class="string">'A'</span>);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">//退回</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> flag; <span class="comment">//判斷當前答案陣列能不能在擴展</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXN; i++)&#123; <span class="comment">//遍地搜尋</span></span><br><span class="line">        flag = <span class="number">1</span>; </span><br><span class="line">        <span class="keyword">if</span>(graph[i] != <span class="number">1</span> || visit[i] == <span class="number">1</span>) <span class="keyword">continue</span>; </span><br><span class="line">        <span class="comment">//有被經歷過了或沒有這個節點(graph[i] != 1)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it: ans)&#123; <span class="comment">//遍地搜尋 ans 有沒有都符合記錄關係</span></span><br><span class="line">            <span class="keyword">if</span>(order[it][i])&#123; <span class="comment">//等於 1 表示沒有符合</span></span><br><span class="line">                flag = <span class="number">0</span>; <span class="comment">//退出 for，不能擴展繼續嘗試其他的節點</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="number">1</span>)&#123; <span class="comment">//表示此節點可以被擴展</span></span><br><span class="line">            dfs(i);　<span class="comment">//進入 DFS</span></span><br><span class="line">            visit[i] = <span class="number">0</span>; <span class="comment">//由於退回了，此節點要還原成原本狀態</span></span><br><span class="line">            ans.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"out.txt"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n; <span class="comment">//輸入資料</span></span><br><span class="line">    <span class="built_in">cin</span>.ignore(); <span class="comment">//為了後面的 getline，現在要讓指標先到下一行</span></span><br><span class="line">    flag3 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="built_in">string</span> temp;</span><br><span class="line">        getline(<span class="built_in">cin</span>, temp); <span class="comment">//replace blank line 把空白行消除掉</span></span><br><span class="line">        getline(<span class="built_in">cin</span>, temp); <span class="comment">//輸入題目陣列</span></span><br><span class="line">        <span class="comment">//cout &lt;&lt; "temp is " &lt;&lt; temp &lt;&lt; '\n';</span></span><br><span class="line">        ss.clear(); ss.str(<span class="string">""</span>); ss &lt;&lt; temp; <span class="comment">//給 stringstream 方便等等輸入資料</span></span><br><span class="line">        <span class="built_in">memset</span>(graph, <span class="number">0</span>, <span class="keyword">sizeof</span>(graph)); <span class="comment">//重新整理資料，避免干擾</span></span><br><span class="line">        <span class="built_in">memset</span>(order, <span class="number">0</span>, <span class="keyword">sizeof</span>(order));</span><br><span class="line">        lg = <span class="number">0</span>; <span class="comment">//用來記錄題目陣列長度</span></span><br><span class="line">        <span class="keyword">while</span>(ss &gt;&gt; ch)&#123; </span><br><span class="line">            graph[ch - <span class="string">'A'</span>] = <span class="number">1</span>; <span class="comment">//把每個值 hash 成 字元 - 'A'，1 就是有這節點</span></span><br><span class="line">            lg++; <span class="comment">//長度增加</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        getline(<span class="built_in">cin</span>, temp); <span class="comment">//輸入記錄關係</span></span><br><span class="line">        ss.clear(); ss.str(<span class="string">""</span>); ss &lt;&lt; temp; <span class="comment">//給 stringstream 方便等等輸入資料</span></span><br><span class="line">        <span class="keyword">while</span>(ss &gt;&gt; temp) order[temp[<span class="number">2</span>] - <span class="string">'A'</span>][temp[<span class="number">0</span>] - <span class="string">'A'</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//由於記錄關係是用字串表達，且只會有一個字母，所以就用這樣記錄</span></span><br><span class="line">        <span class="comment">//需要提醒的是，我是記錄違法記錄關係的，也就是會把後面關係放在前面 index，前面關係放在後面</span></span><br><span class="line">        <span class="comment">//這樣只要 DFS 有掃到就可以表示不符合關係。</span></span><br><span class="line">        <span class="comment">//也有其他種寫法，可以自己嘗試</span></span><br><span class="line"></span><br><span class="line">        flag2 = <span class="number">1</span>; <span class="comment">//判斷有沒有拓樸排序</span></span><br><span class="line">        <span class="keyword">if</span>(flag3 == <span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>; <span class="comment">//嚴格比較，每筆測資的斷航</span></span><br><span class="line">        <span class="keyword">if</span>(flag3) flag3 = <span class="number">0</span>; <span class="comment">//第一筆沒有斷行，因此第二筆開始都是 0。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXN; i++)&#123; <span class="comment">//遍地搜尋 </span></span><br><span class="line">            <span class="keyword">if</span>(graph[i] == <span class="number">1</span>)&#123; <span class="comment">//有此節點就繼續</span></span><br><span class="line">                dfs(i); <span class="comment">//擴展 DFS</span></span><br><span class="line">                ans.pop_back(); <span class="comment">//還原狀態</span></span><br><span class="line">                visit[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag2) <span class="built_in">cout</span> &lt;&lt; <span class="string">"NO\n"</span>; <span class="comment">//如果沒有找到，就輸出 no</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>Topological Ordering 拓樸排序</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown 放入 google drive 圖片</title>
    <url>/2021/02/28/blog/hackmd_view_googledricePIC/</url>
    <content><![CDATA[<h2 id="主要內容"><a href="#主要內容" class="headerlink" title="主要內容"></a>主要內容</h2><blockquote>
<p>主要介紹如何將 google drive 的圖片放到 markdown 上，並且會自動顯示。</p>
</blockquote>
<a id="more"></a>

<h2 id="如何在-Markdown-放入-google-drive-圖片呢？"><a href="#如何在-Markdown-放入-google-drive-圖片呢？" class="headerlink" title="如何在 Markdown 放入 google drive 圖片呢？"></a>如何在 Markdown 放入 google drive 圖片呢？</h2><p>就快速講結果，不講過程了。如果對過程有興趣就看參考連結，參考連結講的超棒我就不贅述了。</p>
<h3 id="Step1-先共享自己要放入-markdown-的圖片，然後找出網址"><a href="#Step1-先共享自己要放入-markdown-的圖片，然後找出網址" class="headerlink" title="Step1 先共享自己要放入 markdown 的圖片，然後找出網址"></a>Step1 先共享自己要放入 markdown 的圖片，然後找出網址</h3><p>通常網址會是如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;drive.google.com&#x2F;file&#x2F;d&#x2F;XXXXXX&#x2F;view?usp&#x3D;sharing</span><br></pre></td></tr></table></figure>

<p>其中 XXXX 就是這張圖片的 ID。</p>
<h3 id="Stpe2-將網址替換，並且將-ID-換上"><a href="#Stpe2-將網址替換，並且將-ID-換上" class="headerlink" title="Stpe2 將網址替換，並且將 ID 換上"></a>Stpe2 將網址替換，並且將 ID 換上</h3><p>換成如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;drive.google.com&#x2F;u&#x2F;2&#x2F;uc?id&#x3D;XXXXX&amp;export&#x3D;download</span><br></pre></td></tr></table></figure>

<p>然後嘗試</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![](https://drive.google.com/u/2/uc?id=XXXXX&amp;export=download)</span><br></pre></td></tr></table></figure>

<p>這樣就可以了！</p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://hackmd.io/@cnsrl/H1gHwCyGw" target="_blank" rel="noopener">於 HackMD 使用 Google 雲端硬碟中的圖片 - cnsrl</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>很感謝 cnsrl 大大願意教學，原本看 google drive 是提供 iframe 的方法，但是我對這方法不滿意，在網路上翻查後發現有這更好的方式。實在是太棒了！</p>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>QUESTION! C++11 upperbound and lowerbound 用法</title>
    <url>/2021/02/28/C++/C++_binarysearch/</url>
    <content><![CDATA[<h2 id="內容說明"><a href="#內容說明" class="headerlink" title="內容說明"></a>內容說明</h2><blockquote>
<p>語法常常讓人忘記，尤其是相似的語法更為容易，這裡告訴讀者這兩個用法差別，讓讀者在忘記時可以用到。</p>
</blockquote>
<a id="more"></a>

<h2 id="QUESTION-C-11-upperbound-and-lowerbound-用法"><a href="#QUESTION-C-11-upperbound-and-lowerbound-用法" class="headerlink" title="QUESTION! C++11 upperbound and lowerbound 用法"></a>QUESTION! C++11 upperbound and lowerbound 用法</h2><p>這兩個用法使用的是 <a href="https://theriseofdavid.github.io/2020/11/15/Explain_Algorithm/binary_search/" target="_blank" rel="noopener">binary serach 演算法</a>，這裡有詳細的解釋可以看看。</p>
<h3 id="upperbound-上限，傳回-index"><a href="#upperbound-上限，傳回-index" class="headerlink" title="upperbound 上限，傳回 index"></a>upperbound 上限，傳回 index</h3><p>傳回一個 index 為，選定的 \(value &lt; element\) 並傳回第一個元素，其中 value 是我們想找的數值，element 則是陣列中的元素數值。</p>
<p>另一種講法則是，uppderbound 表示對於有序的陣列能夠最<strong>後</strong>大於的數值。</p>
<h4 id="舉例-1-2-3-3-3-4-5，如果我們要找-3-那-uppderbound-會傳回甚麼"><a href="#舉例-1-2-3-3-3-4-5，如果我們要找-3-那-uppderbound-會傳回甚麼" class="headerlink" title="舉例 1,2,3,3,3,4,5，如果我們要找 3 那 uppderbound 會傳回甚麼"></a>舉例 1,2,3,3,3,4,5，如果我們要找 3 那 uppderbound 會傳回甚麼</h4><p>此時會傳回 5，表示 index，那元素數值則是 4。</p>
<p>寫法如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::upper_bound (struct.begin(), struct.end(), value) - <span class="class"><span class="keyword">struct</span>.<span class="title">begin</span>();</span></span><br></pre></td></tr></table></figure>

<h3 id="lowerbound-下限，傳回-index"><a href="#lowerbound-下限，傳回-index" class="headerlink" title="lowerbound 下限，傳回 index"></a>lowerbound 下限，傳回 index</h3><p>傳回一個 index 為，選定的 \(value \leq element\) 並傳回第一個元素，其中 value 是我們想找的數值，element 則是陣列中的元素數值。</p>
<p>另一種講法則是，lowerbound 表示對於有序的陣列能夠最<strong>先</strong>大於的數值。</p>
<h4 id="舉例-1-2-3-3-3-4-5，如果我們要找-3-那-lowerbound-會傳回甚麼"><a href="#舉例-1-2-3-3-3-4-5，如果我們要找-3-那-lowerbound-會傳回甚麼" class="headerlink" title="舉例 1,2,3,3,3,4,5，如果我們要找 3 那 lowerbound 會傳回甚麼"></a>舉例 1,2,3,3,3,4,5，如果我們要找 3 那 lowerbound 會傳回甚麼</h4><p>此時會傳回 2(表示 index)，那元素數值則是 3，因為 3(要找的數值) 等於 3(陣列元素數值)。</p>
<p>寫法如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::lower_bound (struct.begin(), struct.end(), value) - <span class="class"><span class="keyword">struct</span>.<span class="title">begin</span>();</span></span><br></pre></td></tr></table></figure>

<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="http://www.cplusplus.com/reference/algorithm/lower_bound/" target="_blank" rel="noopener">lower_bound - cplusplus</a><br><a href="https://blog.csdn.net/tjpuacm/article/details/26389441" target="_blank" rel="noopener">C++ STL lower_bound upper_bound的用法以及cmp函数 - AcmMissile</a><br><a href="https://blog.csdn.net/hpu_zyh/article/details/11497527" target="_blank" rel="noopener">C++ STL中的 lower_bound() 和 upper_bound() - Hanks-zyh</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>有時候語言寫多常常會讓自己搞混很多語法，透過自己的 blog 紀錄才不會忘記的時候查到不是自己需要的資料，自己寫的比較能夠知道自己不會甚麼！</p>
]]></content>
      <categories>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>Cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>正規表達式表達 windows 檔案命名規則</title>
    <url>/2021/03/01/Regular%20Expression/Regular-Expression-win-file-manager/</url>
    <content><![CDATA[<h2 id="內容說明"><a href="#內容說明" class="headerlink" title="內容說明"></a>內容說明</h2><blockquote>
<p>如果在寫程式的過程中需要輸出檔案到 windows OS 上時，<code>/  \   *  ?   :    &quot;   &lt;   &gt;  |</code> 都不可以用是檔名，此時正規表達式來幫助我們解決這問題是最好的了！</p>
<p>　如何寫出正規表達式表達 windows 檔案命名規則呢，就是我們的主題。</p>
</blockquote>
<a id="more"></a>

<h2 id="何寫出正規表達式表達-windows-檔案命名規則？"><a href="#何寫出正規表達式表達-windows-檔案命名規則？" class="headerlink" title="何寫出正規表達式表達 windows 檔案命名規則？"></a>何寫出正規表達式表達 windows 檔案命名規則？</h2><p>廢話不多說，這是我自己的版本提供大家使用 <code>/|\\*|\\?|:|\&quot;|&gt;|&lt;|\\|</code>，希望大家都能使用成功，有問題也能跟我說。</p>
<h2 id="參考來源"><a href="#參考來源" class="headerlink" title="參考來源"></a>參考來源</h2><p><a href="https://sites.google.com/site/zigongdaolun/zuo-ye-xi-tong-jie-shao/fen-lei/windows-dang-an-ming-cheng" target="_blank" rel="noopener">windows檔案命名規則 - 資工導論</a></p>
]]></content>
      <categories>
        <category>正規表示式 Regular Expression</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>正規表示式 Regular Expression</tag>
      </tags>
  </entry>
  <entry>
    <title>正規表達式 Regular Expression 基本方法</title>
    <url>/2021/03/01/Regular%20Expression/Regular-Expression/</url>
    <content><![CDATA[<h2 id="正規表達式-Regular-Expression-介紹"><a href="#正規表達式-Regular-Expression-介紹" class="headerlink" title="正規表達式 Regular Expression 介紹"></a>正規表達式 Regular Expression 介紹</h2><blockquote>
<p>在電腦科學中用來判斷一個字串是否符合我們所規定的特定模式，在文字編輯器中用來檢索、替換那些符合某個規則的文字。。</p>
</blockquote>
<a id="more"></a>

<h2 id="基本語法"><a href="#基本語法" class="headerlink" title="基本語法"></a>基本語法</h2><p>以下提供一些基本語法介紹</p>
<ul>
<li>or <code>|</code><br><code>a|b</code></li>
<li><code>+</code> 代表前面的字元必須至少出現一次<br><code>da+vid</code>，<code>da</code> 一定要出現一次</li>
<li><code>?</code> 代表前面的字元最多只可以出現一次，零次也可以<br><code>da?vid</code>，只要 <code>d or a</code> 出現或沒出現都可以。</li>
<li><code>*</code> 代表前面的字元出現或不出現都可以，也可以出現很多次。<br><code>d*avid</code>，<code>d</code> 想出現、重複、不出現都可以。</li>
<li><code>()</code> 優先順序，表示最優先<br>跟程式一樣</li>
<li><code>^</code> 必須在字首</li>
<li><code>$</code> 必須在字尾</li>
<li><code>[string]</code>，表示裡面其中一個字元有符合到都可以。</li>
<li><code>[a-z]</code>，只要 a 到 z 任意一個字元有就算符合。</li>
</ul>
<h2 id="一些題目或範例"><a href="#一些題目或範例" class="headerlink" title="一些題目或範例"></a>一些題目或範例</h2><p>都在 categories 分類中，<a href="https://theriseofdavid.github.io/categories/%E6%AD%A3%E8%A6%8F%E8%A1%A8%E7%A4%BA%E5%BC%8F-Regular-Expression/" target="_blank" rel="noopener">點這裡就可以看到很多範例</a></p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://zh.wikipedia.org/wiki/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F" target="_blank" rel="noopener">正規表示式 - wiki</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>雖然很早以前就知道正規表達式 Regular Expression，但是一直都沒有把他打成 blog，現在剛好用到就來打打，方便搜尋知識。</p>
<p>希望自己未來可以成為一個有用，成功的人！</p>
]]></content>
      <categories>
        <category>正規表示式 Regular Expression</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>正規表示式 Regular Expression</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces 1485C - Floor and Mod (設計解題、數學推理)</title>
    <url>/2021/02/22/Codeforces/Codeforces%201485C/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>有一種特殊的 pair(A,B)，定義這種 pair 必須符合 \([ \frac{a}{b} ] = a \ mod \ b\)</p>
<p>給你一個數字 x,y，其中特殊的 pair 數值必須是 \(1 \leq x \leq a \)、\(1 \leq y \leq  b\)，告訴我在這個範圍內有多少這種 pair 的數量。</p>
<p><a href="https://codeforces.com/contest/1485/problem/C" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li>數學邏輯推理</li>
<li>時間複雜度推測</li>
</ul>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>這題有難度XD，我被考倒了QQ。稍微看了下題目發現這是移項問題，只要移項移好腦袋清楚就可以把它成功解出了！</p>
<p>這題的 x,y 都是 \(10^9\)，有點刺激阿，由於 \(O(N) = 10^8\)，因此似乎這題時間複雜度要比 \(O(n)\) 還小。</p>
<p>codeforec 有很多人教學，在看了多遍後，能將這些話給講出來。</p>
<h3 id="StepA-推出-K-的範圍"><a href="#StepA-推出-K-的範圍" class="headerlink" title="StepA 推出 K 的範圍:"></a>StepA 推出 K 的範圍:</h3><p>我們可以定義 \( a \ mod \ b \) 出來的值為 k，因此 \([ \frac{a}{b} ] = a \ mod \ b = k\)</p>
<p>稍微進行移項，\( a = bk + k\)，其中 \(b &gt; k\)，否則不符合 \( [ \frac{a}{b} ]  = k \)</p>
<p>再來我們稍微進行粗略分析，\(bk+k &gt; k^2\)，我們前面有提到 \(b &gt; k\)，我們把所有的數學推導都拉出來寫寫看。</p>
<p>\(x \geq a = bk + k \geq k^2 \)，再來我們進行約分，收斂下後就可以得到 \(k \leq \sqrt{x}\)</p>
<h3 id="StepB-找出-b-的範圍"><a href="#StepB-找出-b-的範圍" class="headerlink" title="StepB 找出 b 的範圍:"></a>StepB 找出 b 的範圍:</h3><p>現在我們可以知道有特殊的 pair，範圍只在 \(1 \leq k \leq \sqrt{x}\) 、\(b &gt; k\)、 \(1 \leq kb+k \leq x\)，\(kb+k\) 是 \([\frac{a}{b}] = k\) 的移項。</p>
<p>再來我們進行推導，就可以將 \(1 \leq kb+k \leq x\) 推成 \(1 \leq b \leq x\k-1\)，同除 k，但 1 不變動，因為題目要求最小值是 1。</p>
<h3 id="StepC-找出公式"><a href="#StepC-找出公式" class="headerlink" title="StepC 找出公式"></a>StepC 找出公式</h3><p>再來我們可以推出一個算式，\(min(y,x/k-1) - k\)，我們這邊是在找有哪些 b 可以用，而不是再找有哪些方式 k 會符合，透過找有幾個 b 可以用來算出答案。</p>
<p>StepB 有說到 \(1 \leq b \leq x\k-1\)，但 y 不一定會小於 \(x\k-1\) 也不一定大於，因此特別用個 min 來找出最小值，找出最小的值。這裡是公式最重要最需要注意的地方。</p>
<p>減 k 則是 Step1 有說到，b 必須要大於 k，否則不滿足。</p>
<h3 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h3><p><a href="https://codeforces.com/blog/entry/87470" target="_blank" rel="noopener">Editorial of Codeforces Round #701 (Div. 2) - Codeforces By TheScrasse </a><br><a href="https://blog.csdn.net/qq_44791484/article/details/113832913?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-2&spm=1001.2101.3001.4242" target="_blank" rel="noopener">codeforces 1485 C Floor and Mod (枚举+推导) - CSDB by (xsj) </a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>這題真的很讚。</p>
<p>有好多的邏輯推導是我沒有被訓練過的，一時都沒有辦法學起來。老實講我沒有把握我現在就把這些都吸收完成，但我相信只要我多練習幾次，一定可以把這些問題都解開。</p>
<p>我希望我能夠成為一位優秀的解題大師，可以解出所有的問題。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1e10 <span class="comment">//題目最大值</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long <span class="comment">//用 long long 才不會 i*i 無法被 int 記下</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> x, y, n, ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y; <span class="comment">//輸入資料</span></span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i*i &lt; x; i++) ans += max(<span class="number">0l</span>l, min(x/i<span class="number">-1</span>, y) - i);</span><br><span class="line">        <span class="comment">//k 要小於 sqrt x，這裡的 k 是 i，再配合公式就可以得出答案</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>設計解題</tag>
        <tag>程式解題</tag>
        <tag>Codeforces</tag>
        <tag>數學推理</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces 1492C - Maximum width (二元搜尋)</title>
    <url>/2021/03/02/Codeforces/Codeforces%201492C/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>有兩個字串 s and t，題目定義一個 beautiful 的概念，beautiful 概念如下<br>必須 \(s_p_i = t_i\)，且 \(1 \leq p_1 &lt; p_2 &lt; … \leq n\)，一個 beautiful 概念應該是 \(max_{1 \leq i \leq m } (p_{i+1} - p_i\)</p>
<p>請你輸出最大的 beautiful width </p>
<p><a href="https://codeforces.com/contest/1492/problem/C" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li>二分搜尋</li>
<li>理解英文題目</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>其實就是按照題目的規則，將 t 字串的字元依照 t 的順序，分布在 s 的字串中，並且讓分布的其中一個距離最大，並且輸出他。</p>
<p>這樣要怎麼思考呢，很簡單，我們可以用二分搜尋來解決此問題。</p>
<p>我們先用一個陣列 \(p\) 表示如果我們都將 t 的字串放在 s 相同字元的最前面，再來我們只要能夠將 \(t_{i+1}\) 字元拉最遠，就可以達到我們的要求。</p>
<p>用 <code>upperbound</code> 讓 \(t_i\) 字串放在 s 相同字元的最前面並記錄在  \(p\)<br>用 <code>lowerbound</code> 找出 \(t_{i+1}\) 字元拉最遠的位置，在跟 \(t_i\) 相減就能記錄這次的最大長度。</p>
<h3 id="QUESTION-為甚麼找最前面用-upperbound，找最後面用-lowerbound-呢"><a href="#QUESTION-為甚麼找最前面用-upperbound，找最後面用-lowerbound-呢" class="headerlink" title="QUESTION: 為甚麼找最前面用 upperbound，找最後面用 lowerbound 呢"></a>QUESTION: 為甚麼找最前面用 <code>upperbound</code>，找最後面用 <code>lowerbound</code> 呢</h3><ul>
<li>第一點 <code>upperbound</code><br>那是因為 c++ 的特性，<code>lowerbound</code> 會找到 \(element \geq value\) 的值，如果 value 是剛剛的最左邊，那下個字元如果跟上個字元相同那下次的 <code>lowerbound</code> 也會找到同樣的左邊邊界，但實際必須加一，因此這裡用 upperbound 就沒有等於的情況。</li>
<li>第二點 <code>lowerbound</code><br>第二個點為甚麼要用 <code>lowerbound</code>，因為 <code>upperbound</code> 會找到 \(element &gt; value\) 的值，如果值是剛剛的最右邊 那下個字元如果跟上個字元相同那下次的 <code>upperbound</code>，也會找到同樣的右邊邊界，因此這邊改用 <code>lowerbound</code> 並且減一來減少此情況。<code>lowerbound</code> 有等於的情況就不會找到相同邊界，再透過減一表示跟剛剛的邊界不同。</li>
</ul>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://codeforces.com/blog/entry/87792?locale=en" target="_blank" rel="noopener">Codeforces Round #704 Editorial - ch_egor’s blog</a><br><a href="https://blog.csdn.net/tomjobs/article/details/114005919" target="_blank" rel="noopener">Codeforces-1492 C. Maximum width（构造）- tomjob </a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>這題我原本是想要我的方式來寫，透過字串壓縮來解決此題，但因為比賽時間只有 2hr，我寫前面的題目就來不及了後來就沒有將此題實現，後來看了其他人的寫法後覺得其他人的寫法更讚，因此學習然後寫一遍高手的寫法，讓我學習學習。</p>
<p>確實網路上永遠都會有人寫得比我更好，這種寫法讓我學起來，這樣會讓我學得更快！以後用得更好。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 0x3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">string</span> s, t; <span class="comment">//放題目的兩個字串</span></span><br><span class="line"><span class="keyword">int</span> n, m, pre = <span class="number">-1</span>, nxt = MAXN, num, ans;  </span><br><span class="line"><span class="comment">//pre 當前的最左邊邊界，nxt 當前的最右邊邊界</span></span><br><span class="line"><span class="keyword">int</span> p[MAXN]; <span class="comment">//每一個字元的最右邊邊界</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec[<span class="number">30</span>]; <span class="comment">//紀錄每個相同字元的 index，方便二分搜尋</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m; <span class="comment">//輸入資料</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s &gt;&gt; t;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123; <span class="comment">//將相同字元放入同樣 vector</span></span><br><span class="line">        num = s[i] - <span class="string">'a'</span>;</span><br><span class="line">        vec[num].push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123; <span class="comment">//對每個字元找出最左邊邊界</span></span><br><span class="line">        num = t[i] - <span class="string">'a'</span>; </span><br><span class="line">        p[i] = *upper_bound(vec[num].begin(), vec[num].end(), pre); </span><br><span class="line">        <span class="comment">//找最左邊邊界</span></span><br><span class="line">        <span class="comment">//cout &lt;&lt; "pre p[i] " &lt;&lt; i &lt;&lt; ' ' &lt;&lt; p[i] &lt;&lt; '\n';</span></span><br><span class="line">        pre = p[i];</span><br><span class="line">    &#125;</span><br><span class="line">    nxt = n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = m<span class="number">-1</span>; i &gt; <span class="number">0</span>; i--)&#123;</span><br><span class="line">        num = t[i] - <span class="string">'a'</span>;</span><br><span class="line">        p[i] = *--lower_bound(vec[num].begin(), vec[num].end(), nxt); <span class="comment">//找最右邊邊界</span></span><br><span class="line">        nxt = p[i]; <span class="comment">//將 p[i] 改為最右邊邊界，方便等等計算</span></span><br><span class="line">        <span class="comment">//cout &lt;&lt; "nxt p[i] " &lt;&lt; i &lt;&lt; ' ' &lt;&lt; p[i] &lt;&lt; '\n';</span></span><br><span class="line">        ans = max(ans, p[i] - p[i<span class="number">-1</span>]); <span class="comment">//比較哪個比較大</span></span><br><span class="line">        <span class="comment">//i 與 i-1，和 i+1 與 i 相同概念。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>; <span class="comment">//輸出答案</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>程式解題</tag>
        <tag>Binary Search 二分搜尋</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>演算法知識 - Segment Tree 線段樹</title>
    <url>/2021/03/06/Explain_Algorithm/segment-tree/</url>
    <content><![CDATA[<h2 id="Segment-Tree-線段樹-介紹"><a href="#Segment-Tree-線段樹-介紹" class="headerlink" title="Segment Tree 線段樹 介紹"></a>Segment Tree 線段樹 介紹</h2><blockquote>
<p>線段樹是一種二元樹型態的資料結構，通常用於需要大量查詢區間的問題，空間複雜度是 \(O(n)\)，查詢的時間複雜度則是 \(O(log \ n + k\)，k 為符合條件的區間數量</p>
<p>這種資料結構也能夠擴展到高維度</p>
<p><a href="https://zh.wikipedia.org/wiki/%E7%B7%9A%E6%AE%B5%E6%A8%B9" target="_blank" rel="noopener">線段樹 - wiki</a></p>
</blockquote>
<a id="more"></a>

<h2 id="Segment-Tree-線段樹-原理"><a href="#Segment-Tree-線段樹-原理" class="headerlink" title="Segment Tree 線段樹 原理"></a>Segment Tree 線段樹 原理</h2><blockquote>
<p>先透過一張圖進行解釋，這就是線段樹的原貌<br><img src="https://i.imgur.com/sC6SBjn.png" alt=""><br><a href="https://hackmd.io/@wiwiho/CPN-segment-tree" target="_blank" rel="noopener">師大附中校隊 hackmd 提供，如不願讓我使用請通知我</a></p>
</blockquote>
<p>為了方便好寫，通常我會將線段樹的區間設定為 \([1, n]\)，而非從零開始，但其實從零開始也可以實作成功。</p>
<p>線段樹一開始都會先到 root，之後根據我們所要查詢的區間往那方向進行查詢。</p>
<h4 id="舉例，查詢-3-5"><a href="#舉例，查詢-3-5" class="headerlink" title="舉例，查詢 \([3, 5]\)"></a>舉例，查詢 \([3, 5]\)</h4><ul>
<li>先查詢 \([0, 8]\)，向下找 \([0, 4]\)、\([5, 8]\)<ul>
<li>\([0, 4]\)，找  \([3, 4]\)，另外一邊則不再我們的查詢區間<ul>
<li>\([3, 4]\) 是在我們查詢的區間，不再往下查詢，直接回傳此答案</li>
</ul>
</li>
<li>\([5, 8]\)，查找 \([5, 6]\)，另外一邊則不再我們的查詢區間<ul>
<li>\([5, 6]\) 查詢 \([5, 5]\)，另外一邊則不再我們的查詢區間<ul>
<li>\([5, 5]\) 是在我們查詢的區間，不再往下查詢，直接回傳此答案</li>
</ul>
</li>
</ul>
</li>
<li>將前面兩個回傳的查詢，進行比較，取出最大 or 最小值，然後輸出。</li>
</ul>
</li>
</ul>
<p>主要就是線段樹的查詢過程</p>
<h3 id="結構型態"><a href="#結構型態" class="headerlink" title="結構型態"></a>結構型態</h3><p>線段樹的每個節點必須要有三個值，左邊邊界、右邊邊界、儲存的值。</p>
<p>需要值得注意的是，由於線段樹的底層是一顆二元樹，因此大小<strong>絕對不能只開一樣大</strong>，必須要開到 \(4 * n\)，至於為甚麼要開 \(4 * n\)，以下進行證明。</p>
<ul>
<li>一顆二元樹的葉節點假如是 \(2_i\)，\(i\) 為負整數</li>
<li>因此這棵樹所有節點不會大於 \(2^{i+1}\)，此證明如下<ul>
<li>第一層的節點是 1</li>
<li>第二層節點是第二層的兩倍，之後以此類推</li>
<li>得出公式 \(\sum_{i = 0}^{h-1} 2^i = 2^h-1\)，其中 h 為最大的深度，h-1 就表示非葉節點的最大深度</li>
<li>一個最簡單的證明就是 2 進位的 \(111_{(2)}\) 不會大於 \(1000_{(2)}\)，且\(1000_{(2)} - 1 = 111_{(2)}\) </li>
</ul>
</li>
<li>因此二元樹總節點會是 \(2^{h}-1 + 2^h\)，化簡後就是 \(2^{h+1} -1\)</li>
</ul>
<h4 id="證明參考"><a href="#證明參考" class="headerlink" title="證明參考"></a>證明參考</h4><blockquote>
<p><a href="http://wayne.cif.takming.edu.tw/datastru/tree.pdf" target="_blank" rel="noopener">資料結構的樹與二元樹（Trees and Binary Trees） -     林偉川老師 </a><br><a href="https://hackmd.io/@wiwiho/CPN-segment-tree" target="_blank" rel="noopener">師大附中校隊 hackmd </a></p>
</blockquote>
<blockquote>
<p>紹宇的證明提供，我在證明這裡時突然卡關，我好笨RRRR<br><img src="https://drive.google.com/u/2/uc?id=1DqmC6gLOn-nJJ7S8OOeiNNzaW2fzAUN3&export=download" alt=""></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> left; <span class="comment">// 左邊邊界</span></span><br><span class="line">    <span class="keyword">int</span> right; <span class="comment">//右邊邊界</span></span><br><span class="line">    <span class="keyword">int</span> value; <span class="comment">//儲存的值</span></span><br><span class="line">    <span class="keyword">int</span> z; <span class="comment">//區間修改用，如果沒有區間修改就不需要</span></span><br><span class="line">&#125;node[<span class="number">4</span> * N ];</span><br></pre></td></tr></table></figure>
<h2 id="透過實作來說明-Segment-Tree-線段樹"><a href="#透過實作來說明-Segment-Tree-線段樹" class="headerlink" title="透過實作來說明 Segment Tree 線段樹"></a>透過實作來說明 Segment Tree 線段樹</h2><p>這邊的問題則是給你一段數列，想請你告訴我們查詢的區間中最小值為何，下面的 <code>question()</code> 則是產生題目的數列。</p>
<h3 id="建立線段樹"><a href="#建立線段樹" class="headerlink" title="建立線段樹"></a>建立線段樹</h3><p>剛剛我們已經知道了節點數量的最大的大小，現在來進行建立的步驟。</p>
<p>我們要建立跟此網頁上第一張圖一樣的概念，直接透過程式碼說明，這邊我們要查詢的以最小值(min)為例。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Lson(x) (x &lt;&lt; 1) <span class="comment">//左子樹</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Rson(x) ((x &lt;&lt; 1) +1) <span class="comment">//右子樹</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">question</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) num[i] = i * <span class="number">123</span> % <span class="number">5</span>; </span><br><span class="line">    <span class="comment">// num 為題目產生的一段數列</span></span><br><span class="line">    <span class="comment">// hash 函數，讓 num 的 i 被隨機打亂</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> left , <span class="keyword">int</span> right , <span class="keyword">int</span> x = <span class="number">1</span> )</span></span>&#123; </span><br><span class="line">    <span class="comment">// left 為題目最大左邊界，right 為題目最大右邊界，圖片最上面的 root 為第一個節點</span></span><br><span class="line">    node[x].left = left ; <span class="comment">//給 x 節點左右邊界</span></span><br><span class="line">    node[x].right = right ;</span><br><span class="line">    <span class="keyword">if</span>(left == right)&#123; <span class="comment">//如果左右邊界節點相同，表示這裡是葉節點</span></span><br><span class="line">        node[x].value = num[left] ;  <span class="comment">//把 num 值給 node[x]</span></span><br><span class="line">        <span class="comment">//這裡的 num 值表示，我們要在 value 要放的值</span></span><br><span class="line">        <span class="keyword">return</span> ; <span class="comment">//向前返回</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (left + right ) / <span class="number">2</span> ; <span class="comment">//切半，產生二元樹</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//debug</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; mid &lt;&lt; '\n' ;</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; node[x].left &lt;&lt; ' ' &lt;&lt; node[x].right &lt;&lt; ' ' &lt;&lt; '\n' ;</span></span><br><span class="line"></span><br><span class="line">    build(left , mid , Lson(x)) ; <span class="comment">//將區間改為 [left, mid] 然後帶給左子樹</span></span><br><span class="line">    build(mid + <span class="number">1</span> , right , Rson(x)) ; <span class="comment">//將區間改為 [mid+1, right] 然後帶給右子樹</span></span><br><span class="line">    node[x].value = min(node[Lson(x)].value  , node[Rson(x)].value ) ;</span><br><span class="line">    <span class="comment">//查詢左右子樹哪個數值最小，並讓左右子樹最小值表示此區間最小數值。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="單點修改"><a href="#單點修改" class="headerlink" title="單點修改"></a>單點修改</h3><p>畢竟是線段樹，題目不可能數值都一成不變，有時候會進行變動，這裡我們將說明程式碼如何幫助線段樹進行單點修改。</p>
<p>基本上與建立相似，只是我們是先找到葉節點後，在向上比較，如果我們的值比較小就修改，沒有就保持原狀</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> position , <span class="keyword">int</span> value , <span class="keyword">int</span> x = <span class="number">1</span> )</span></span>&#123; <span class="comment">//修改數字</span></span><br><span class="line">    <span class="keyword">if</span>(node[x].left == position &amp;&amp; node[x].right == position )&#123; <span class="comment">//找到葉節點</span></span><br><span class="line">       node[x].value = value ; <span class="comment">//修改</span></span><br><span class="line">       <span class="keyword">return</span> ; <span class="comment">//傳回</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (node[x].left + node[x].right ) / <span class="number">2</span> ; <span class="comment">//切半，向下修改</span></span><br><span class="line">    <span class="keyword">if</span>(position &lt;= mid ) <span class="comment">//如果要修改的點在左邊，就往左下角追蹤</span></span><br><span class="line">        modify(position , value , Lson(x) );</span><br><span class="line">    <span class="keyword">if</span>(mid &lt; position ) <span class="comment">//如果要修改的點在右邊，就往右下角追蹤</span></span><br><span class="line">        modify(position , value , Rson(x)) ;</span><br><span class="line">    node[x].value = min(node[Lson(x)].value , node[Rson(x)].value );</span><br><span class="line">    <span class="comment">//比較左右子樹哪個值比較小，較小值為此節點的 value</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="區間修改"><a href="#區間修改" class="headerlink" title="區間修改"></a>區間修改</h3><p>線段樹中比較不好懂得部分，我們假設有一種題目是會把某個區間的值全加一個數字來進行舉例。</p>
<p>主要需要兩個 function 來寫</p>
<ul>
<li><code>push_down</code>，用來將先前的懶人標記往下推</li>
<li><code>update</code>，用來將一開始的區間推至線段樹<strong>適合的位置</strong></li>
</ul>
<p>假如我們要在區間 \([1, 10]\)，都進行加二，線段數的目標是找區間最小值，這時我們需要呼叫 <code>update</code>，幫助我們找到線段樹節點 \([1, 10]\)，把這邊的數值加二，並且給予一個懶人標記表示下面的所有子樹都沒有被進行加二，因此懶人標記就會是加二；如果之後會<strong>查詢、區間修改</strong>到其他值時，我們就會利用 <code>push_down</code> 讓<strong>下一層的子樹</strong>執行區間加二的指令。</p>
<p>那如果都不需要再向下查詢，那就讓懶人標記一直維持在此不需要對下面子樹進行更動，降低時間複雜度。</p>
<ul>
<li>如果不太懂可以看台大演算法線段樹區間修改教學，或是看我的程式碼來進行理解。<br><a href="https://www.csie.ntu.edu.tw/~sprout/algo2018/ppt_pdf/segment_tree_2.pdf" target="_blank" rel="noopener">Segment/Interval Tree - 2 by 林品諺</a></li>
</ul>
<p>但我很喜歡林品諺大佬的一句話，<strong>只在你需要的時候做事，有時候你不需要那麼勤勞</strong>。</p>
<p>我認為透過程式碼說明，勝過於簡單的文字說明。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> add)</span></span>&#123; <span class="comment">//將懶人標記往下推，讓下一層子樹進行區間修改</span></span><br><span class="line">    <span class="keyword">int</span> lson = Lson(x), rson = Rson(x);</span><br><span class="line">    node[lson].z += add;  <span class="comment">//給予懶人標記，表示子樹如果要給子樹的子樹區間修改時，</span></span><br><span class="line">    node[rson].z += add;  <span class="comment">//數值要是多少，左右子樹都需要做</span></span><br><span class="line"></span><br><span class="line">    node[lson].v += add; <span class="comment">//更新左右子樹的值</span></span><br><span class="line">    node[rson].v += add;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> cmd, <span class="keyword">int</span> x = <span class="number">1</span>)</span></span>&#123; </span><br><span class="line"><span class="comment">//a, b 為區間修改的 left and right, cmd 為要增加的數值 </span></span><br><span class="line">    <span class="keyword">if</span>(a &lt;= node[x].l &amp;&amp; b &gt;= node[x].r)&#123; </span><br><span class="line">        <span class="comment">//如果節點的 left and right，跟 a, b 區間是相等，或更小就，只要在這邊修改 cmd，</span></span><br><span class="line">        <span class="comment">//就可以讓 node[x].v 的值直接變為區間修改後的數值，</span></span><br><span class="line">        <span class="comment">//之後如果要讓這查詢向子樹進行區間修改，就用 push_down，</span></span><br><span class="line">        <span class="comment">//我們這邊的懶人標記就會告訴左右子樹要修改的值為多少</span></span><br><span class="line"></span><br><span class="line">        node[x].v += cmd; <span class="comment">//區間修改後的 v</span></span><br><span class="line">        node[x].z = cmd; <span class="comment">//區間修改是要增加多少數值</span></span><br><span class="line">        <span class="keyword">return</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    push_down(x);<span class="comment">//先將之前的區間查詢修改值，往下給子樹以避免上次的查詢值被忽略</span></span><br><span class="line">    <span class="comment">//假如當前的 node[x].z 原本是 3，如果沒有 push_down(x)，那下面的子樹都沒有被 +3，</span></span><br><span class="line">    <span class="comment">//導致答案不正確。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = (node[x].l+node[x].r) / <span class="number">2</span>;  <span class="comment">//切半，向下修改</span></span><br><span class="line">    <span class="keyword">if</span>(a &lt;= mid) update(a, b, cmd, Lson(x)); <span class="comment">//如果要修改的點在左邊，就往左下角追蹤</span></span><br><span class="line">    <span class="keyword">if</span>(b &gt; mid) update(a, b, cmd, Rson(x)); <span class="comment">//如果要修改的點在右邊，就往右下角追蹤</span></span><br><span class="line">    node[x].v = node[Lson(x)].v + node[Rson(x)].v;</span><br><span class="line">    <span class="comment">//比較左右子樹哪個值比較小，較小值為此節點的 value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="區間查詢"><a href="#區間查詢" class="headerlink" title="區間查詢"></a>區間查詢</h3><p>線段樹重要的部分，所有的線段樹一定會進行這個動作，但查詢的方式其實與二元樹相同，畢竟是透過二元樹建立的嘛XD。</p>
<p>我們將說明程式碼如何幫助線段樹進行區間查詢。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> left , <span class="keyword">int</span> right , <span class="keyword">int</span> x = <span class="number">1</span> )</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node[x].left &gt;= left &amp;&amp; node[x].right &lt;= right) </span><br><span class="line">        <span class="keyword">return</span> node[x].Min_Value ;</span><br><span class="line">    <span class="comment">//如果我們要查詢的區間比當前節點的區間大，那我們不需再向下查詢直接輸出此答案就好。</span></span><br><span class="line">    <span class="comment">// 例如我們要查詢 [2, 8]，我們只需要查詢 [3, 4]，不須查詢 [3, 3]、[4, 4]，</span></span><br><span class="line">    <span class="comment">// [3, 4] 已經做到最小值查詢</span></span><br><span class="line"></span><br><span class="line">    push_down(x);<span class="comment">//有區間修改時才需要寫    </span></span><br><span class="line">    <span class="keyword">int</span> mid = (node[x].left + node[x].right ) / <span class="number">2</span> ; <span class="comment">//切半，向下修改</span></span><br><span class="line">    <span class="keyword">int</span> ans = INF ; <span class="comment">//一開始先假設答案為最大值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( left &lt;= mid ) <span class="comment">//如果切半後，我們要查詢的區間有在左子樹就向下查詢</span></span><br><span class="line">        ans = min(ans , query(left , right , Lson(x))) ; <span class="comment">//更新答案，比較誰比較小</span></span><br><span class="line">    <span class="keyword">if</span>(mid &lt; right ) <span class="comment">//如果切半後，我們要查詢的區間有在右子樹就向下查詢</span></span><br><span class="line">        ans = min(ans , query(left , right , Rson(x))) ; <span class="comment">//更新答案，比較誰比較小</span></span><br><span class="line">    <span class="keyword">return</span> ans ; <span class="comment">//回傳答案</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="不可離散化的-Segment-Tree-線段樹"><a href="#不可離散化的-Segment-Tree-線段樹" class="headerlink" title="不可離散化的 Segment Tree 線段樹"></a>不可離散化的 Segment Tree 線段樹</h3><p>有時候會遇到一些題目的 n 可能大於 \(10^9\)，在 C++ 沒有辦法承擔那麼大的陣列大小時，我們可以用指標來解決這個問題，或是改使用 linklist 的方式，減少因為離散化而大量設定陣列值的問題。</p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><blockquote>
<p><a href="http://wayne.cif.takming.edu.tw/datastru/tree.pdf" target="_blank" rel="noopener">資料結構的樹與二元樹（Trees and Binary Trees） -     林偉川老師 </a><br><a href="https://hackmd.io/@wiwiho/CPN-segment-tree" target="_blank" rel="noopener">師大附中校隊 hackmd </a><br><a href="https://www.csie.ntu.edu.tw/~sprout/algo2018/ppt_pdf/segment_tree_2.pdf" target="_blank" rel="noopener">Segment/Interval Tree - 2 by 林品諺</a></p>
</blockquote>
<blockquote>
<p>紹宇的證明提供，我在證明這裡時突然卡關，我好笨RRRR<br><img src="https://drive.google.com/u/2/uc?id=1DqmC6gLOn-nJJ7S8OOeiNNzaW2fzAUN3&export=download" alt=""></p>
</blockquote>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>好久沒有複習線段樹了，透過這此的編寫讓我把線段樹也重新複習了一遍，老實講我常常會覺得自己寫這些東西似乎沒用，畢竟我走資財，寫這些東西可能只能夠在純資的環境上使用，但我是資財的學生，我不知道自己到底用不用的到。</p>
<p>老實講，自己在高中學到的東西，非常快樂，非常充實。但在大學時感覺不到有一群跟我一樣愛好的人一起努力奮鬥，大家都有自己的目標要奮鬥，大家的目標不再只有那麼單一，都很多樣，有時候會讓我迷失方向，會讓我覺得我做這些事情有意義嗎。</p>
<h2 id="Segment-Tree-線段樹-無註解程式碼"><a href="#Segment-Tree-線段樹-無註解程式碼" class="headerlink" title="Segment Tree 線段樹 無註解程式碼"></a>Segment Tree 線段樹 無註解程式碼</h2><p>這裡則放置沒有註解的程式碼，如果讀者想要複製就從這裡進行複製吧！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Lson(x) (x &lt;&lt; 1) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Rson(x) ((x &lt;&lt; 1) +1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 題目陣列最大長度</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> left;</span><br><span class="line">    <span class="keyword">int</span> right; </span><br><span class="line">    <span class="keyword">int</span> value; </span><br><span class="line">    <span class="keyword">int</span> z; <span class="comment">//不須區間修改就不用寫</span></span><br><span class="line">&#125;node[<span class="number">4</span> * N ]; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">question</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) num[i] = i * <span class="number">123</span> % <span class="number">5</span>; </span><br><span class="line">    <span class="comment">// num 為題目產生的一段數列</span></span><br><span class="line">    <span class="comment">// hash 函數，讓 num 的 i 被隨機打亂</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> left , <span class="keyword">int</span> right , <span class="keyword">int</span> x = <span class="number">1</span> )</span></span>&#123; </span><br><span class="line">    node[x].left = left ;</span><br><span class="line">    node[x].right = right ;</span><br><span class="line">    <span class="keyword">if</span>(left == right)&#123; </span><br><span class="line">        node[x].value = num[left] ; </span><br><span class="line">        <span class="keyword">return</span> ; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (left + right ) / <span class="number">2</span> ; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//debug</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; mid &lt;&lt; '\n' ;</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; node[x].left &lt;&lt; ' ' &lt;&lt; node[x].right &lt;&lt; ' ' &lt;&lt; '\n' ;</span></span><br><span class="line"></span><br><span class="line">    build(left , mid , Lson(x)) ; </span><br><span class="line">    build(mid + <span class="number">1</span> , right , Rson(x)) ;</span><br><span class="line">    node[x].value = min(node[Lson(x)].value  , node[Rson(x)].value ) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> position , <span class="keyword">int</span> value , <span class="keyword">int</span> x = <span class="number">1</span> )</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node[x].left == position &amp;&amp; node[x].right == position )&#123;</span><br><span class="line">       node[x].value = value ;</span><br><span class="line">       <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (node[x].left + node[x].right ) / <span class="number">2</span> ; </span><br><span class="line">    <span class="keyword">if</span>(position &lt;= mid ) </span><br><span class="line">        modify(position , value , Lson(x) );</span><br><span class="line">    <span class="keyword">if</span>(mid &lt; position )</span><br><span class="line">        modify(position , value , Rson(x)) ;</span><br><span class="line">    node[x].value = min(node[Lson(x)].value , node[Rson(x)].value );</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> add)</span></span>&#123; <span class="comment">//將懶人標記往下推</span></span><br><span class="line">    <span class="keyword">int</span> lson = Lson(x), rson = Rson(x);</span><br><span class="line">    node[lson].z = add;</span><br><span class="line">    node[rson].z = add;</span><br><span class="line"></span><br><span class="line">    node[lson].v += add;</span><br><span class="line">    node[rson].v += add;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> cmd, <span class="keyword">int</span> x = <span class="number">1</span>)</span></span>&#123; </span><br><span class="line">    <span class="keyword">if</span>(a &lt;= node[x].l &amp;&amp; b &gt;= node[x].r)&#123; </span><br><span class="line">        node[x].v += cmd;</span><br><span class="line">        node[x].z = cmd;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    push_down(x); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = (node[x].l+node[x].r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(a &lt;= mid) update(a, b, cmd, Lson(x));</span><br><span class="line">    <span class="keyword">if</span>(b &gt; mid) update(a, b, cmd, Rson(x));</span><br><span class="line">    node[x].v = min(node[Lson(x)].v , node[Rson(x)].v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> left , <span class="keyword">int</span> right , <span class="keyword">int</span> x = <span class="number">1</span> )</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node[x].left &gt;= left &amp;&amp; node[x].right &lt;= right) </span><br><span class="line">        <span class="keyword">return</span> node[x].value ;</span><br><span class="line">    push_down(x);<span class="comment">//有區間修改時才需要寫</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> mid = (node[x].left + node[x].right ) / <span class="number">2</span> ; </span><br><span class="line">    <span class="keyword">int</span> ans = INF ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( left &lt;= mid ) </span><br><span class="line">        ans = min(ans , query(left , right , Lson(x))) ; </span><br><span class="line">    <span class="keyword">if</span>(mid &lt; right ) </span><br><span class="line">        ans = min(ans , query(left , right , Rson(x))) ; </span><br><span class="line">    <span class="keyword">return</span> ans ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>演算法知識</category>
      </categories>
      <tags>
        <tag>程式解題</tag>
        <tag>演算法知識</tag>
        <tag>線段樹 Segment Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa11235 - Frequent values(線段樹)</title>
    <url>/2021/03/04/UVa/UVa11235/</url>
    <content><![CDATA[<h1 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h1><blockquote>
<p>有一個非遞增的數列，雖然非遞增，但前一個數值必會小於等於這個數值，我們要查詢一個區間，想詢問這個區間中最常出現的數字次數是多少？</p>
<p><a href="https://onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=2176" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li>線段樹的學習與應用<br>如果需要學習演算法，請參考 <a href="https://theriseofdavid.github.io/2021/03/06/Explain_Algorithm/segment-tree/" target="_blank" rel="noopener">大衞的筆記 - Segment Tree 線段樹</a></li>
<li>對於題目的仔細閱讀</li>
<li>我們線段樹應該要保存甚麼數值，才能解決此題</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>只要遇到需要查詢區間的問題一律就要想到線段樹，線段樹的時間複雜度可以來到 \(O(n \ log \ n\)，能夠打遍百分之 90 的題目，但這邊有些小技巧要解決。</p>
<p>這題要在線段樹裡面存的就是題目所需要的出現次數，但可能會有一種疑問<br>Q: 1,2,3,3,3,3,4，如果我要找區間 \([4,5]\) 要怎麼辦呢，這裡 index 從 1 開始。</p>
<p>這個時候題目給了我們一個很大的提示，題目有說<strong>前一個數值必會小於等於這個數值</strong>，因此我們可以視為相同的數字只會出現在同個區段且不會再有其他區段重複。</p>
<p>區段： 1,1,1,1，這種連續數字在一塊地，定義為區塊</p>
<h3 id="解決方法"><a href="#解決方法" class="headerlink" title="解決方法"></a>解決方法</h3><p>我們透過舉例來說明這種解決方式，用題目測資來說明</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">index:  1   2  3  4  5  6  7   8   9  10</span><br><span class="line">value: -1  -1  1  1  1  1  3  10  10  10</span><br><span class="line">fre:    2   2  4  4  4  4  1   3   3   3</span><br><span class="line"></span><br><span class="line">left:   1   1  2  2  2  2  7   8   8   8    </span><br><span class="line">right:  2   2  6  6  6  6  6  10  10  10</span><br></pre></td></tr></table></figure>

<p>如果我們要查詢的區間是 \([4,9]\)，此時如果按照存區塊最大值時答案會是 4，但這裡的區間不應該有 4，答案要是 3，遇到這種問題就很棘手XD。</p>
<p>但還是有辦法的，我們紀錄每個區塊的右邊界與左邊界，如果我們查詢的<strong>區間</strong>比起<strong>區塊</strong>還要小的時候就可以讓<strong>區塊的右邊界</strong>減去<strong>區間的左邊界</strong>，或<strong>區間的右邊界</strong>減去<strong>區塊的左邊界</strong>，這樣就可以避免掉區間查詢查到 4 的情況。</p>
<p>而且我們只要在一開始的去判斷這種區間切到區塊的問題，之後就不需要，我們可以將要查詢的範圍減掉左右兩區間所切到的區塊，依照範例就是變為 \([7,7]\)，\([4,6]) 則是被切掉的左區間、\([8,9]]\) 則是被切掉的右區間，那麼縮小範圍後的<strong>區間</strong>裡面必包含完整區塊。畢竟裡面的區塊我們都沒有動到，所以都是完整的，也不存在不完整的情況發生。<br>不完整的區間只有在一開始的查詢區間有可能出現。</p>
<p>這時我們再進行線段樹查詢找出最大出現數字次數，就能夠成功找到答案！</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。 </p>
<p>至於 <a href="https://theriseofdavid.github.io/2021/03/06/Explain_Algorithm/segment-tree/" target="_blank" rel="noopener">大衞的筆記 - Segment Tree 線段樹</a> 有做說明的部分，這邊就不在進行說明。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Lson(x) x &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Rson(x) (x &lt;&lt; 1) + 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100020</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, q, ta, tb;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tree</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, v; <span class="comment">//將 left right value 進行簡化為 l r v</span></span><br><span class="line">    tree()&#123;&#125;</span><br><span class="line">    tree(<span class="keyword">int</span> _l, <span class="keyword">int</span> _r, <span class="keyword">int</span> _v): l(_l), r(_r), v(_v) &#123;&#125;</span><br><span class="line">&#125;node[<span class="number">4</span> * MAXN];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NUM</span>&#123;</span> <span class="comment">//用來儲存區塊</span></span><br><span class="line">    <span class="keyword">int</span> l, r, f, v; </span><br><span class="line">    <span class="comment">// l 區塊的左邊界</span></span><br><span class="line">    <span class="comment">// r 區塊的右邊界</span></span><br><span class="line">    <span class="comment">// f 區塊有多長</span></span><br><span class="line">    <span class="comment">// v 區塊的數值</span></span><br><span class="line">&#125;num[MAXN];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> x = <span class="number">1</span>)</span></span>&#123;</span><br><span class="line">    node[x].l = left;</span><br><span class="line">    node[x].r = right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(left == right)&#123;</span><br><span class="line">        node[x].v = num[left].f; <span class="comment">//區塊有多長，題目詢問的重點</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">    build(left, mid, Lson(x));</span><br><span class="line">    build(mid + <span class="number">1</span>, right, Rson(x));</span><br><span class="line">    node[x].v = max(node[Lson(x)].v, node[Rson(x)].v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> x = <span class="number">1</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num[left].v == num[right].v) <span class="keyword">return</span> right - left + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//題目所查詢的區間，剛好在同個區塊上，num[left].v == num[right].v 表示數值相同也就代表區塊相同</span></span><br><span class="line">    <span class="comment">// 因此只需要拿左區間邊界減去右區間邊界加一就可以得到答案</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(left &gt; num[left].l)&#123; <span class="comment">//查詢的左區間邊界切到區塊，且此區間有數個區塊</span></span><br><span class="line">        ans = num[left].r - left + <span class="number">1</span>; <span class="comment">//計算切到的區間大小</span></span><br><span class="line">        <span class="comment">//方法是查詢被切到的區塊右邊界減去左區間邊界加一</span></span><br><span class="line">        left = num[left].r + <span class="number">1</span>; <span class="comment">//將左區間邊界移至被切區塊的右邊界加一，就不會切到區塊</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(right &lt; num[right].r)&#123; <span class="comment">//查詢的右區間邊界切到區塊，且此區間有數個區塊</span></span><br><span class="line">        ans = max(right - num[right].l + <span class="number">1</span>, ans); <span class="comment">//計算切到的區間大小，並找出最大</span></span><br><span class="line">        <span class="comment">//方法是查詢的右邊界減掉區塊左邊界加一</span></span><br><span class="line">        right = num[right].l - <span class="number">1</span>; <span class="comment">//將右區間邊界移至被切區塊的左邊界減一，就不會切到區塊</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; "left right ans " &lt;&lt; left &lt;&lt; ' ' &lt;&lt; right &lt;&lt; ' ' &lt;&lt; ans &lt;&lt; '\n';</span></span><br><span class="line">    <span class="keyword">if</span>(left &gt; right ) <span class="keyword">return</span> ans; <span class="comment">//如果左邊界大於右邊界，表示不需要再進行查詢直接回傳答案</span></span><br><span class="line">    <span class="comment">//由於上面的 +1、-1，因此有機會出現左邊界大於右邊界的情形。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(node[x].l &gt;= left &amp;&amp; node[x].r &lt;= right ) <span class="keyword">return</span> node[x].v; </span><br><span class="line">    <span class="keyword">int</span> mid = (node[x].l + node[x].r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(left &lt;= mid) ans = max(ans, query(left, right, Lson(x)));</span><br><span class="line">    <span class="keyword">if</span>(mid &lt; right) ans = max(ans, query(left, right, Rson(x)));</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug_num</span><span class="params">()</span></span>&#123; <span class="comment">//debug 用 無意義</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">' '</span> &lt;&lt; num[i].l &lt;&lt; <span class="string">' '</span> &lt;&lt; num[i].r &lt;&lt; <span class="string">' '</span> &lt;&lt; num[i].v &lt;&lt; <span class="string">' '</span> &lt;&lt; num[i].f &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug_build</span><span class="params">()</span></span>&#123; <span class="comment">//debug 用 無意義</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">' '</span> &lt;&lt; node[i].l &lt;&lt; <span class="string">' '</span> &lt;&lt; node[i].r &lt;&lt; <span class="string">' '</span> &lt;&lt; node[i].v &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"out.txt"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">1</span>, e; <span class="comment">//長度的 start ，長度的 end</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; q &amp;&amp; n + q != <span class="number">0</span>)&#123; <span class="comment">//輸入資料，並且注意查詢可以為 0，因此 n + q 必須 != 0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123; <span class="comment">//書資料</span></span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; ta;</span><br><span class="line">            num[i].v = ta; <span class="comment">//值設定 ta</span></span><br><span class="line">            <span class="keyword">if</span>(num[i].v != num[i<span class="number">-1</span>].v)&#123; <span class="comment">//如果現在的值與前面的值不同，表示不同區塊</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = s; j &lt; i; j++)&#123; <span class="comment">//將前面的區塊的左邊界、右邊界、長度進行設定。</span></span><br><span class="line">                    num[j].l = s; <span class="comment">//設定左邊界</span></span><br><span class="line">                    num[j].r = i<span class="number">-1</span>; <span class="comment">//設定右邊界，i-1 是因為 i 已經是不同區塊 </span></span><br><span class="line">                    num[j].f = i - s; <span class="comment">//設定長度</span></span><br><span class="line">                &#125;</span><br><span class="line">                s = i; <span class="comment">//更新下個區塊的左邊界</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = s; j &lt;= n; j++)&#123; <span class="comment">//最後一個區塊必須拉出來寫，因為後面沒有數值來進行分裂</span></span><br><span class="line">            num[j].l = s;</span><br><span class="line">            num[j].r = n;</span><br><span class="line">            num[j].f = n - s + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//debug_num();</span></span><br><span class="line">        build(<span class="number">1</span>, n);</span><br><span class="line">        <span class="comment">//debug_build();</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; q; i++)&#123; <span class="comment">//輸出結果</span></span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; ta &gt;&gt; tb;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; query(ta, tb) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="http://naivered.github.io/2018/05/20/Problem_Solving/UVa/UVa-11235-Frequent-values/" target="_blank" rel="noopener">UVa 11235 - Frequent values - naivered</a><br><a href="https://algorithmist.com/wiki/Main_Page" target="_blank" rel="noopener">algorithmist wiki</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>這題複習了我很久沒有練習的線段樹，演算法太久沒有碰真的會忘記，今天在複習線段樹的時後一直卡卡的，腦袋還沒有喚醒記憶，透過今天的複習把記憶在喚醒！</p>
<p>這題的小巧思好棒，雖然我沒有在很短的時間想到怎麼解，但我透過學習 naivered 大大的想法，得知還有這種解法，希望我學習了這種解法能夠讓我在未來的路上用上！</p>
<p>題外話：人生一定要學習有意義的事情嗎？ 怎樣的事情算有意義。</p>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>線段樹 Segment Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa11402 - Ahoy, Pirates!(線段樹)</title>
    <url>/2021/03/10/UVa/UVa11402/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>在一個海盜島上有許多的海盜，它們都有被編號(從 0 至 n)，且它們都有一個陣營，此海盜島上只有兩個陣營 Buccaneer、Barbary。</p>
<p>現在來了一個大魔法師，他可以將從 0 ~ n 的人變成 Buccaneer or Barbary 陣營的人或是把某區間的人陣營對調，原本是 Buccaneer 變為 Barbary，Barbary 變為 Buccaneer</p>
<p>神知道有這件事情後，非常生氣，他會問大魔法師一個區間內有幾個 Buccaneer 海盜，沒有就殺了他，所以請幫忙解決此問題吧！</p>
<p><a href="https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2397" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li>線段樹的學習與應用<br>如果需要學習演算法，請參考 <a href="https://theriseofdavid.github.io/2021/03/06/Explain_Algorithm/segment-tree/" target="_blank" rel="noopener">大衞的筆記 - Segment Tree 線段樹</a></li>
<li>對於題目的仔細閱讀</li>
<li>這題需要用到線段樹的高深操作，<strong>區間修改</strong>、<strong>懶人標記</strong></li>
<li>題目的指令在線段樹的懶人標記時，要如何判斷誰先誰後 (<strong>非常重要</strong>，它讓我花了 12hr 思考)</li>
<li>題目的指令優化 (<strong>非常重要</strong>，它讓我花了 12hr 思考)</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>好題，好題…，它讓我學到了一堆知識，雖然也讓我一堆時間飛走了QQQ。</p>
<p>這題比較麻煩的是要判斷 segment tree 懶人標記時，要如何判斷其先後順序，如果先將 0<del>n 的人全部變成 Buccaneer 在對調，與先對調在將 0</del>n 的人全部變成 Buccaneer，是不一樣的結果，因此我們在 <code>push_down</code> 跟 <code>mod2</code> 都需要比較多的處理，來判斷假如現在懶人標記是怎樣的情況時，我們現在又有這個指令時會對下面的子樹造成的影響是甚麼。</p>
<ul>
<li>定義 <code>1</code> 為把區間的人變成 Buccaneer</li>
<li>定義 <code>0</code> 為把區間的人變成 Barbary</li>
<li>定義 <code>2</code> 為區間的人對調</li>
</ul>
<h3 id="可以找出順序"><a href="#可以找出順序" class="headerlink" title="可以找出順序"></a>可以找出順序</h3><ul>
<li>如果先進行 <code>2</code> 再進行 <code>0</code>，那就不需要進行 <code>2</code>，只需要進行 <code>0</code></li>
<li>如果先進行 <code>2</code> 再進行 <code>1</code>，那就不需要進行 <code>2</code>，只需要進行 <code>1</code></li>
<li>如果先進行 <code>2</code> 再進行 <code>2</code>，那完全不需要改動下面子樹</li>
<li>如果先進行 <code>1</code> 再進行 <code>2</code>，那就只需要進行 <code>0</code></li>
<li>如果先進行 <code>0</code> 再進行 <code>2</code>，那就只需要進行 <code>1</code></li>
<li>如果先進行 <code>1</code> 再進行 <code>0</code>，那就只需要進行 <code>0</code></li>
<li>如果先進行 <code>0</code> 再進行 <code>1</code>，那就只需要進行 <code>1</code></li>
</ul>
<p>OK，現在知道進行區間修改時如果有兩個指令卡在同個節點時，我們就可以用這些規則來告訴下面子樹要進行甚麼規則。</p>
<p>那這樣就能夠透過 <code>query</code> 找到正確答案了！動手寫程式碼八</p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://www.csie.ntu.edu.tw/~sprout/algo2018/ppt_pdf/segment_tree_2.pdf" target="_blank" rel="noopener">Segment/Interval Tree - 2 by 林品諺</a><br><a href="https://yuihuang.com/uva-11402/" target="_blank" rel="noopener">【題解】UVA 11402 Ahoy, Pirates! by YUI HUANG</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>這題真的是很棒的好題，像這樣的順序，我直接大卡關….，我花了將近 4hr 在想這些順序問題，後來真的受不了了看 YUI HUANG 的題解，發現是我自作多情，我把她想太難了！不一定要每個步驟都做，可以把它們合併再讓子樹進行一個動作就好…，原先還想要對此線段樹紀錄 queue，來記錄順序然後進行區間查詢，結果記憶體爆了…。</p>
<p>後面把 queue 改成 string 則是超時，非常建議大家不要亂魔改資料結構阿QQQ，設計出來不是做此用途就不要亂用QQQ，就算用成功了也不一定可以成功，可能會有超時的問題…。</p>
<p>不過你是大發明家就不要記住我的話拉，我是笨蛋，只能靠努力的那種。</p>
<p>總之希望自己的未來可以一片光明，每天在不安感度過的感覺真的好可怕，希望自己學習的演算法與資料結構未來可以幫助我在人生的路上！</p>
<p>不然學習了這麼多的演算法，結果都沒用上，會不會有可能太不值了呢？</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。 </p>
<p>至於 <a href="https://theriseofdavid.github.io/2021/03/06/Explain_Algorithm/segment-tree/" target="_blank" rel="noopener">大衞的筆記 - Segment Tree 線段樹</a> 有做說明的部分，這邊就不在進行說明。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1024200</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Lson(x) x&lt;&lt;1 /</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Rson(x) (x&lt;&lt;1)+1</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> t, n, m, a, b, Qcnt, q, kase, len;</span><br><span class="line"><span class="comment">//題目資料， qcnt 是每次測試資料的 q 的查詢次數</span></span><br><span class="line"><span class="comment">//len //題目的海盜數值長度，也是計算當前 num 最大的長度</span></span><br><span class="line"><span class="keyword">int</span> num[MAXN]; <span class="comment">//用來記錄海盜的陣營</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tree</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, v, z; <span class="comment">//其中 z 為懶人標記，z 的 0,1,2 為操作的意思，-1 表示沒有需要操作</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123; <span class="comment">//無意義，debug 用</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"l = "</span> &lt;&lt; l &lt;&lt; <span class="string">" r = "</span> &lt;&lt; r &lt;&lt; <span class="string">" v = "</span> &lt;&lt; v &lt;&lt; <span class="string">" z = "</span> &lt;&lt; z &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;node[MAXN*<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x = <span class="number">1</span>)</span></span>&#123; <span class="comment">//線段樹的 function build</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//cout &lt;&lt; "x = " &lt;&lt; x &lt;&lt; " l = " &lt;&lt; l &lt;&lt; " r = " &lt;&lt; r &lt;&lt; '\n';</span></span><br><span class="line">    node[x].l = l;</span><br><span class="line">    node[x].r = r;</span><br><span class="line">    node[x].z = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">        node[x].v = num[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">    build(l, mid, Lson(x));</span><br><span class="line">    build(mid+<span class="number">1</span>, r, Rson(x));</span><br><span class="line">    node[x].v = node[Lson(x)].v + node[Rson(x)].v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mod1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> cmd)</span></span>&#123; <span class="comment">//方法 1，也就是定義操作的 0 and 1，線段樹的 function update</span></span><br><span class="line">    <span class="keyword">int</span> lson = Lson(x), rson = Rson(x); <span class="comment">//定義左子樹與右子樹位置</span></span><br><span class="line">    node[lson].z = cmd; <span class="comment">//更改懶人標記，規則上面有提到，直接更改不需要判斷先後順序</span></span><br><span class="line">    node[rson].z = cmd;</span><br><span class="line"></span><br><span class="line">    node[lson].v = (node[lson].r-node[lson].l+<span class="number">1</span>) * cmd; <span class="comment">//計算數值，一個小技巧，題目的 1 剛好就是要查詢的數量，</span></span><br><span class="line">    node[rson].v = (node[rson].r-node[rson].l+<span class="number">1</span>) * cmd; <span class="comment">//因此我們直接用 * 1 or * 0，就可以算值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mod2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> cmd)</span></span>&#123; <span class="comment">//方法 2，也就是定義操作的 2，線段樹的 function update</span></span><br><span class="line">    <span class="keyword">int</span> lson = Lson(x), rson = Rson(x);  <span class="comment">//定義左子樹與右子樹位置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//更改懶人標記，規則上面有提到，直接更改不需要判斷先後順序</span></span><br><span class="line">    <span class="keyword">if</span>(node[lson].z == <span class="number">2</span>) node[lson].z = <span class="number">-1</span>; </span><br><span class="line">    <span class="comment">//上述有說到的規則，如果先進行 ``2`` 再進行 ``2``，那完全不需要改動下面子樹</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(node[lson].z != <span class="number">-1</span>) node[lson].z ^= <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//如果先進行 ``0`` 再進行 ``2``，那就只需要進行 ``1``</span></span><br><span class="line">    <span class="comment">//如果先進行 ``1`` 再進行 ``2``，那就只需要進行 ``0``</span></span><br><span class="line">    <span class="keyword">else</span> node[lson].z = cmd;</span><br><span class="line">    <span class="comment">//不需要合併操作，所以就直接寫</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(node[rson].z == <span class="number">2</span>) node[rson].z = <span class="number">-1</span>; <span class="comment">//與上面相同，只是子樹換另外一邊</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(node[rson].z != <span class="number">-1</span>) node[rson].z ^= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> node[rson].z = cmd;</span><br><span class="line"></span><br><span class="line">    node[lson].v = (node[lson].r-node[lson].l+<span class="number">1</span>) - node[lson].v;  </span><br><span class="line">    <span class="comment">//對調，於是先算出區間最大數量減掉當前數量就是對調的數值</span></span><br><span class="line">    node[rson].v = (node[rson].r-node[rson].l+<span class="number">1</span>) - node[rson].v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="comment">//線段樹的 push_down function build</span></span><br><span class="line">    <span class="keyword">if</span>(node[x].z == <span class="number">0</span>) mod1(x, <span class="number">0</span>); <span class="comment">//z = 0 就去 mod1，其中 z 的值表示操作 x</span></span><br><span class="line">    <span class="keyword">if</span>(node[x].z == <span class="number">1</span>) mod1(x, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(node[x].z == <span class="number">2</span>) mod2(x, <span class="number">2</span>);</span><br><span class="line">    node[x].z = <span class="number">-1</span>; <span class="comment">//向下延伸完畢，現在改為 -1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_mod1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> cmd, <span class="keyword">int</span> x = <span class="number">1</span>)</span></span>&#123; <span class="comment">//線段樹的 push_down function update</span></span><br><span class="line"><span class="comment">//詳細請看大衛的演算法，這邊是把方法拉出來寫</span></span><br><span class="line">    <span class="keyword">if</span>(a &lt;= node[x].l &amp;&amp; b &gt;= node[x].r)&#123;</span><br><span class="line">        node[x].v = (node[x].r-node[x].l+<span class="number">1</span>) * cmd;</span><br><span class="line">        node[x].z = cmd;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    push_down(x);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = (node[x].l+node[x].r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(a &lt;= mid) push_mod1(a, b, cmd, Lson(x));</span><br><span class="line">    <span class="keyword">if</span>(b &gt; mid) push_mod1(a, b, cmd, Rson(x));</span><br><span class="line">    node[x].v = node[Lson(x)].v + node[Rson(x)].v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_mod2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> cmd, <span class="keyword">int</span> x = <span class="number">1</span>)</span></span>&#123; <span class="comment">//線段樹的 push_down function update</span></span><br><span class="line"><span class="comment">//詳細請看大衛的演算法，這邊是把方法拉出來寫</span></span><br><span class="line">    <span class="keyword">if</span>(a &lt;= node[x].l &amp;&amp; b &gt;= node[x].r)&#123;</span><br><span class="line">        node[x].v = (node[x].r-node[x].l+<span class="number">1</span>) - node[x].v;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(node[x].z == <span class="number">2</span>) node[x].z = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (node[x].z != <span class="number">-1</span>) node[x].z ^= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> node[x].z = cmd;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    push_down(x);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = (node[x].l+node[x].r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(a &lt;= mid) push_mod2(a, b, cmd, Lson(x));</span><br><span class="line">    <span class="keyword">if</span>(b &gt; mid) push_mod2(a, b, cmd, Rson(x));</span><br><span class="line">    node[x].v = node[Lson(x)].v + node[Rson(x)].v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x = <span class="number">1</span>)</span></span>&#123; <span class="comment">//線段樹的 query function </span></span><br><span class="line">    <span class="keyword">if</span>(node[x].l &gt;= l &amp;&amp; node[x].r &lt;= r) <span class="keyword">return</span> node[x].v;</span><br><span class="line">    push_down(x);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = (node[x].l+node[x].r) / <span class="number">2</span>, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid) ans += query(l, r, Lson(x));</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid) ans += query(l, r, Rson(x));</span><br><span class="line">    <span class="comment">//cout &lt;&lt; "q x = " &lt;&lt; x &lt;&lt; " ans = " &lt;&lt; ans &lt;&lt; '\n';</span></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="built_in">string</span> temp;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123; </span><br><span class="line">        Qcnt = <span class="number">1</span>; <span class="comment">//先定義題目的查詢數量</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Case "</span> &lt;&lt; ++kase &lt;&lt; <span class="string">":\n"</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        len = <span class="number">1</span>; <span class="comment">//題目的海盜數值長度</span></span><br><span class="line">        <span class="keyword">while</span>(n--)&#123; <span class="comment">//輸入題目特別的格式，字串重複 n 次，用 0,1 表示海盜的陣營</span></span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; m &gt;&gt; temp;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123; <span class="comment">//重複 n 次此字串</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; temp.length(); j++) num[len++] = temp[j] - <span class="string">'0'</span>;</span><br><span class="line">                <span class="comment">//把字串的值給 num</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        build(<span class="number">1</span>, len);</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; q; <span class="comment">//題目資料</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; q; i++)&#123; <span class="comment">//題目的指令</span></span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; temp &gt;&gt; a &gt;&gt; b; <span class="comment">//輸入資料</span></span><br><span class="line">            a++; b++; <span class="comment">//index start from 1，由於題目 index 從 0 開始，我們線段樹從 1 開始</span></span><br><span class="line">            <span class="keyword">if</span>(temp == <span class="string">"F"</span>) push_mod1(a, b, <span class="number">1</span>); <span class="comment">//F 是操作 1</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(temp == <span class="string">"E"</span>) push_mod1(a, b, <span class="number">0</span>); <span class="comment">//E 是操作 0</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(temp == <span class="string">"I"</span>) push_mod2(a, b, <span class="number">2</span>); <span class="comment">//I 是操作 2</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(temp == <span class="string">"S"</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">"Q"</span> &lt;&lt; Qcnt++ &lt;&lt; <span class="string">": "</span> &lt;&lt; query(a, b) &lt;&lt; <span class="string">"\n"</span>; <span class="comment">//查詢指令</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="用紙筆去-Debug"><a href="#用紙筆去-Debug" class="headerlink" title="用紙筆去 Debug"></a>用紙筆去 Debug</h2><p>因為只是自己在思考過程中隨手做的筆記，覺得不是對讀者這麼有幫助，因此放在文章最下面。</p>
<p>有時候用想或用看的可能不太能夠懂這演算法，那就用寫的吧！這是大衛我自己學習的手稿，紀錄者我的學習過程。</p>
<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=16ysSTFIwr3Er3VprcxFJkijrgifBahbW&export=download" alt=""></p>
</blockquote>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>線段樹 Segment Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces 1493C - K-beautiful Strings (設計解題、實作題)</title>
    <url>/2021/03/14/Codeforces/Codeforces%201493C/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>將給你一個字串 s，以及 k，請你找出一個字串比 s 下一個小的字串並且裡面的同個字母數量都能 mod k == 0 還有產生的字串長度必須等於 s</p>
<p><a href="https://codeforces.com/contest/1493/problem/C" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li>抓到題目重點</li>
<li>想到一個好寫的程式碼流程</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>對不起，我覺得我的重點觀念很像在講幹話…，但設計解題就是這樣嘛RRRR。<br>相信大家都能夠推出重點來，只是大家不知道要怎麼寫這題目，有抓到重點但是寫不出來的那種感覺。</p>
<p>以下是我進行整理的點，由<a href="https://blog.csdn.net/Aajbelieve/article/details/114500305" target="_blank" rel="noopener">�我在</a>大大中領會出來的。</p>
<ul>
<li>\(題目字串長度 \% k = 0 \)，如果不成立就可以輸出 -1<br>因為如果不等於的話，勢必會有一個英文字母沒有辦法 mod k</li>
<li>再來我們判斷需不需要修改字串中的字元，如果不用就直接輸出原本的字串<br>這點很重要，如果我們有先處理這步驟，那後面的程式會好寫很多，<del>我就是沒想到這步才卡住</del></li>
<li>需要修改時，那我們就要進行以下處理<ul>
<li>從題目的字串尾巴開始判斷是否要修改字元<br>由於題目只能找比 s 下一個小的字串，因此我們先修改字串尾巴的字元，能夠更快找到比 s 下一個小的字串</li>
<li>如果在某 index 下修改字元，判斷要填塞哪個字母才能符合<strong>同個字母數量都能 mod k == 0</strong><br>這時，我們要計算出在<strong>某 index</strong>前面的字串們，還要再塞入<strong>一個字元幾次，例如 ‘a’ 個字元兩次</strong>才能符合<strong>同個字母數量都能 mod k == 0</strong></li>
<li>推敲出公式 <code>(k- 現在某個字元在某 index 前面字串裡的數量 %k)%k</code> 此公式為還要在幾個相同字元的數量才能符合<strong>同個字母數量都能 mod k == 0</strong><br>假如一個字串 <code>aabb</code>，k = 3，那我們勢必要在給各一個 a, b 才能符合<strong>同個字母數量都能 mod k == 0</strong>此條件，可能會有人不太懂為甚麼前面要 <code>(k -</code> and <code>%k</code>，是為了假如<strong>現在某個字元在某 index 前面字串裡的數量 = 0</strong>時，才不會出現需要 k 個字元的情況發生。</li>
</ul>
</li>
</ul>
<p>現在我們獲得這些重點後，我們就可以來寫程式了！一些重點與小技巧在程式碼那邊進行說明。</p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><ul>
<li><a href="https://blog.csdn.net/Aajbelieve/article/details/114500305" target="_blank" rel="noopener">Codeforces Round #705 (Div. 2) 1493题解A. Anti-knapsack/B. Planet Lapituletti/C. K-beautiful Strings - by �我在</a></li>
</ul>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>RRRRR，其實我應該寫得出這題的，只是我抓出了這些重點後還是沒有寫程式的想法，透過 �我在大大的程式碼後，我才發現有一個 <code>sum</code>(題目程式碼的陣列，用於記錄在每個字串前綴長度時，每個字母的數量值) 是多麼重要的一件事情！我那時要是有想到他，我就會解出來了！</p>
<p>總之希望自己在學演算法是有意義的，我覺得我正在變聰明，我也從演算法中獲取了很多知識，似乎每天努力的學習就是寫演算法的義務吧！</p>
<p>嘛，我也不知道為甚麼我會走到這條路，總之我繼續加油吧！</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100020</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> T, k, n;</span><br><span class="line"><span class="keyword">int</span> cnt[<span class="number">30</span>], sum[MAXN][<span class="number">30</span>], now;</span><br><span class="line"><span class="comment">//cnt 如果在這 index 後的字串後綴都替換後，需要給予的字元數量，index 是 a,b,c 這種感覺</span></span><br><span class="line"><span class="comment">//sum[字串當前長度][字母 (a,b, c)] = 數量，也就是字串當前長度的某個字元的數量</span></span><br><span class="line"><span class="built_in">string</span> s; <span class="comment">//輸入題目資料用</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="comment">//判斷在此 index 下能否表達出題目所要的答案字元</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = s[x]-<span class="string">'a'</span>+<span class="number">1</span>; i &lt; <span class="number">26</span>; i++)&#123; <span class="comment">//從修改的 index 字元的下一個開始，到 z 結束</span></span><br><span class="line">        <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span>(cnt)); <span class="comment">//將 cnt 歸為零，cnt 每次都要 clear</span></span><br><span class="line">        <span class="comment">//cnt 用來表示，我們的 cnt[字母 (a,b,c)] = 數量，也就是每個字母需要幾個數量才能符合，</span></span><br><span class="line">        <span class="comment">//同個字母數量都能 mod k == 0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> remain = n-x<span class="number">-1</span>; <span class="comment">//如果從此 index 開始修改，那後面的字元我們可以任意變動</span></span><br><span class="line">        <span class="comment">//但也只有這個數量可以變動，注意要 -1，因為 x 這個 index 的字元是固定的，</span></span><br><span class="line">        <span class="comment">//必須要是 i，才有符合當前字源比 s[i] 小</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; j++)&#123; <span class="comment">//每個字元還需要多少字元才能符合，</span></span><br><span class="line">        <span class="comment">//同個字母數量都能 mod k == 0</span></span><br><span class="line">            now = sum[x][j]; <span class="comment">//當前長度的 j + 'a' 字元有多少數量</span></span><br><span class="line">            <span class="keyword">if</span>(j == s[x]-<span class="string">'a'</span>) now--; <span class="comment">//由於我們是紀錄當前長度，但是我們要替換現在此 index，</span></span><br><span class="line">            <span class="comment">//因此要將 now-1，因為 s[i] 這個字元我們不會使用，如果使用就不是修改此 index</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i == j) now++; <span class="comment">//因為在這邊我們會用 i+'a' 此字元，所以將 now +1，</span></span><br><span class="line">            <span class="comment">//表示之後可以少一個 i+'a' 字元，來補我們這邊用過的</span></span><br><span class="line"></span><br><span class="line">            remain -= (k-now%k)%k; <span class="comment">//減掉我們可以用的長度字元</span></span><br><span class="line">            cnt[j] += (k-now%k)%k; <span class="comment">//此字元至少需要多少長度才符合 同個字母數量都能 mod k == 0</span></span><br><span class="line">            <span class="keyword">if</span>(remain &lt; <span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">//如果 &lt; 0，表示要比題目原本字串的長度更長才能符合，因此退出</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(remain &lt; <span class="number">0</span>) <span class="keyword">continue</span>; <span class="comment">//判斷下一個字元替換此 s[i]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果還有剩下的長度可以被使用，那我們就全加給 'a' 就好，不需要擔心 a 字母會不會 % k != 0，</span></span><br><span class="line">        <span class="comment">//因為剩下的長度必定會 %k == 0，否則我們整理的第一點就不會符合。</span></span><br><span class="line">        <span class="comment">//證明: 每個字母的長度必須都 %k == 0，因此如果有剩下的長度 &gt; 1，就表示題目的長度 %k != 0</span></span><br><span class="line">        cnt[<span class="number">0</span>] += remain;</span><br><span class="line">        <span class="keyword">return</span> i; <span class="comment">//表示此 i+'a' 此字串替換給 s[i] 是好選擇，所以回傳</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.length() % k != <span class="number">0</span>) <span class="keyword">return</span> <span class="string">"-1"</span>; <span class="comment">//我們整理的第一個重點</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) sum[<span class="number">0</span>][i] = <span class="number">0</span>; <span class="comment">//歸零，不要用 memset，我這樣更省時間</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123; <span class="comment">//開始計算在每個長度時，每個字元的數量</span></span><br><span class="line">        sum[i][s[i] - <span class="string">'a'</span>] += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; j++) sum[i+<span class="number">1</span>][j] = sum[i][j]; <span class="comment">//狀態更新給下一個長度</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">1</span>; <span class="comment">//判斷是否不需要修改</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum[n<span class="number">-1</span>][i] % k != <span class="number">0</span>)&#123; <span class="comment">//需要修改</span></span><br><span class="line">            flag = <span class="number">0</span>; </span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">//退出</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag == <span class="number">1</span>) <span class="keyword">return</span> s; <span class="comment">//如果是 1 表示不需要修改，就是我們整理的第二個重點</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> ans = <span class="string">""</span>; <span class="comment">//答案</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--)&#123; <span class="comment">//從字串最尾巴開始進行修改</span></span><br><span class="line">        flag = check(i); <span class="comment">//判斷這邊修改為哪個字元更好，0 表示都不好</span></span><br><span class="line">        <span class="keyword">if</span>(flag)&#123; <span class="comment">//如果 &gt; 0，表示有可以修改的字元</span></span><br><span class="line">            ans = s.substr(<span class="number">0</span>, i) + (<span class="keyword">char</span>) (flag+<span class="string">'a'</span>); </span><br><span class="line">            <span class="comment">//原本的字串長度從 0 到 i-1 加上修改的字元，</span></span><br><span class="line">            <span class="comment">//注意 C++ 的 substr(position, len) 函式與其他語言語法不同</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//透過字典序依序將每個字母需要的數量補入 string，這裡的 string(次數, 字元)</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) ans += <span class="built_in">string</span>(cnt[i], i+<span class="string">'a'</span>);</span><br><span class="line">            <span class="keyword">return</span> ans; <span class="comment">//回傳答案</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123; <span class="comment">//輸入題目資料</span></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k &gt;&gt; s;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; solve() &lt;&lt; <span class="string">'\n'</span>; <span class="comment">//給 sovle 回傳答案</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="思考流程"><a href="#思考流程" class="headerlink" title="思考流程"></a>思考流程</h2><p>透過紙筆與黑板而思考而成的片段，放在網路上供我紀念XD</p>
<p>錯誤的程式碼就不放上來讓大家見笑了QQQQ。</p>
<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=11coaKjqBTjjWAUFHU-SPRYdrWknoW8Lh&export=download" alt=""><br><img src="https://drive.google.com/u/2/uc?id=1swl38gr_Kmr31VLfjFCB0jTuBIl3FOFQ&export=download" alt=""></p>
</blockquote>
]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>設計解題</tag>
        <tag>程式解題</tag>
        <tag>實作題</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa12532 - Interval Product(線段樹)</title>
    <url>/2021/03/14/UVa/UVa12532/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>你現在在 pub 裡面，明天要程式設計競賽，朋友給你一個問題如果你沒有回答出來，就會要求你喝一杯酒，但你酒量不好，不可以讓自己失敗，幸好朋友給妳時間寫程式，朋友給你的題目如下：</p>
<p>會給你一個數列，之後會給你兩個命令</p>
<ul>
<li><code>C</code> 改變數列中的某個數子</li>
<li><code>P</code> 請你查詢某個區間的所有數字相乘是正或負或零。</li>
</ul>
<p><a href="https://onlinejudge.org/index.php?option=onlinejudge&Itemid=8&page=show_problem&problem=3977" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li>線段樹的學習與應用<br>如果需要學習演算法，請參考 <a href="https://theriseofdavid.github.io/2021/03/06/Explain_Algorithm/segment-tree/" target="_blank" rel="noopener">大衞的筆記 - Segment Tree 線段樹</a></li>
<li>對於題目的仔細閱讀</li>
<li>用到線段樹的單點修改</li>
<li>題目只需要你輸出區間的結果是<strong>正或負或零</strong></li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>一個簡單的線段樹，只要將題目完全看過一遍後，再搭配所學過的線段樹知識就可以解出此題，那這裡有一個小麻煩就是題目的數列的數字值是在 100 ~ -100 中，我們如果存數字進去會導致相乘溢位的狀態。</p>
<p>因此我們改成在線段樹中儲存 0, -1, 1，分別代表者 零、負數、正數的情況，正數相乘還是 1、正負數相乘就是 -1，任意數乘零都是零，剛好用這三個關鍵的數子就可以充分表達題目要我們輸出的結果是正數、負數、零。</p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>最近覺得寫演算法的時間有點多，變得其他時間不好顧呢。其實也不是寫演算法的時間變多，只是上了大二後事情變多變成每件事情都要盡快完成，有時候就會覺得這種需要花大量時間完成的事情似乎沒有甚麼 CP 值呢！內心有點迷茫，希望未來的我可以知道到底怎樣做對我最好。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。 </p>
<p>至於 <a href="https://theriseofdavid.github.io/2021/03/06/Explain_Algorithm/segment-tree/" target="_blank" rel="noopener">大衞的筆記 - Segment Tree 線段樹</a> 有做說明的部分，這邊就不在進行說明。</p>
<p>比較需要注意的是此題沒有區間修改的問題，因此我們就不需要寫 <code>push_down</code> 有關於區間修改的 function。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100020</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Lson(x) (x&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Rson(x) ((x&lt;&lt;1)+1)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> num[MAXN];</span><br><span class="line"><span class="keyword">int</span> N, K, temp, a, b;</span><br><span class="line"><span class="built_in">string</span> cmd, result;　<span class="comment">//cmd 存題目的指令是查詢還是修改值 result 存結果</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">&#125;node[<span class="number">4</span> * MAXN];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x = <span class="number">1</span>)</span></span>&#123; <span class="comment">//線段樹的 function build</span></span><br><span class="line">    node[x].l = l;</span><br><span class="line">    node[x].r = r;</span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">        node[x].v = num[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = (l+r) / <span class="number">2</span>;</span><br><span class="line">    build(l, mid, Lson(x));</span><br><span class="line">    build(mid+<span class="number">1</span>, r, Rson(x));</span><br><span class="line">    node[x].v = node[Lson(x)].v * node[Rson(x)].v; <span class="comment">//因為題目要求，注意這裡是乘法</span></span><br><span class="line">    <span class="comment">//不要跟 大衞的筆記中的線段樹說明搞混</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> v, <span class="keyword">int</span> x = <span class="number">1</span>)</span></span>&#123; <span class="comment">//線段樹的 function modify</span></span><br><span class="line">    <span class="keyword">if</span>(node[x].l == p &amp;&amp; node[x].r == p)&#123;</span><br><span class="line">        node[x].v = v;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = (node[x].l+node[x].r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(p &lt;= mid) modify(p, v, Lson(x));</span><br><span class="line">    <span class="keyword">if</span>(p &gt; mid) modify(p, v, Rson(x));</span><br><span class="line">    node[x].v = node[Lson(x)].v * node[Rson(x)].v;</span><br><span class="line">    <span class="comment">//因為題目要求，注意這裡是乘法</span></span><br><span class="line">    <span class="comment">//不要跟 大衞的筆記中的線段樹說明搞混</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x = <span class="number">1</span>)</span></span>&#123;<span class="comment">//線段樹的 function query</span></span><br><span class="line">    <span class="keyword">if</span>(node[x].l &gt;= l &amp;&amp; node[x].r &lt;= r) <span class="keyword">return</span> node[x].v;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = (node[x].l+node[x].r) / <span class="number">2</span>, ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid) ans *= query(l, r, Lson(x));</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid) ans *= query(l, r, Rson(x));</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">    <span class="comment">//因為題目要求，注意這裡是乘法</span></span><br><span class="line">    <span class="comment">//不要跟 大衞的筆記中的線段樹說明搞混</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"out.txt"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; N &gt;&gt; K)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)&#123; <span class="comment">//輸入題目數列</span></span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; temp;</span><br><span class="line">            <span class="keyword">if</span>(temp &gt; <span class="number">0</span>) temp = <span class="number">1</span>; <span class="comment">//將數列的值，壓縮成 正、負、零三種狀態</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(temp &lt; <span class="number">0</span>) temp = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(temp == <span class="number">0</span>) temp = <span class="number">0</span>;</span><br><span class="line">            num[i] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        build(<span class="number">1</span>, N);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= K; i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; cmd &gt;&gt; a &gt;&gt; b;</span><br><span class="line">            <span class="keyword">if</span>(cmd == <span class="string">"C"</span>)&#123; <span class="comment">//進入線段樹 modify function</span></span><br><span class="line">                <span class="keyword">if</span>(b &gt; <span class="number">0</span>) b = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(b &lt; <span class="number">0</span>) b = <span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(b == <span class="number">0</span>) b = <span class="number">0</span>;</span><br><span class="line">                modify(a, b);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cmd == <span class="string">"P"</span>)&#123; <span class="comment">//進入線段樹 query function</span></span><br><span class="line">                <span class="keyword">int</span> ans = query(a, b);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(ans &gt; <span class="number">0</span>) result = <span class="string">"+"</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(ans &lt; <span class="number">0</span>) result = <span class="string">"-"</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(ans == <span class="number">0</span>) result = <span class="string">"0"</span>;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>線段樹 Segment Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces 1459D - Glass Half Spilled (設計解題、動態規劃、背包問題)</title>
    <url>/2021/03/16/Codeforces/Codeforces%201459D/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>這裡有 n 個水杯，每個水杯都有其最大容量與當前裝的水量，你可以透過將 A 杯的水<strong>全倒</strong>給 B 杯的方式來讓 A 杯水量增加，但過程中水會有 1/2 的輛被灑在地上，也就是說 A 杯只會增加 B 杯一半的水量，而 B 量則會變為零。</p>
<p>我們想知道如果我們只拿 n 杯且可以做倒水的動作時，那這 n 杯的總水量為多少。</p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li>意識到是動態規劃</li>
<li>化簡為背包問題</li>
<li>將三維的 DP 轉換為二維</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>明明覺得好難，但程式碼難度卻非常簡單QQ。</p>
<p>看了 _Hayasaka 大大與 qscqesze 大大的教學後，慢慢搞懂了些。</p>
<p>由於這題是詢問拿 1 ~ n 杯的總最大水量並且分開輸出，沒有要求我們要輸出步驟，此時我們應該想到兩種解法。</p>
<ul>
<li>Greedy</li>
<li>DP</li>
</ul>
<p>但這裡 Greedy 是行不通的，稍微仔細想想，有 100 個水杯，我們腦袋沒辦法一次 Greedy 那麼多東西啊，因此這裡就選擇使用 DP。</p>
<p>再仔細想想，這跟背包問題似乎有點相像，一樣都是要找出最大值，並且只有選此杯子與不選的概念，但多加了一個轉移公式。</p>
<p>因此我們這裡大概可以想出一個概念， i 個杯子、選 j 個、最大容量 k，我們就推出了最基本的動態規劃。</p>
<h3 id="但是這樣陣列數量會不夠阿，而且很耗時，有更好的方法嗎？"><a href="#但是這樣陣列數量會不夠阿，而且很耗時，有更好的方法嗎？" class="headerlink" title="但是這樣陣列數量會不夠阿，而且很耗時，有更好的方法嗎？"></a>但是這樣陣列數量會不夠阿，而且很耗時，有更好的方法嗎？</h3><p>稍微想了一下後，發現 i 個杯子不需要放在動態規劃中，狀態永遠是按照前一個的，我們可以用一個想法是<strong>依序加入</strong>，也就是說我們可以假設題目一開始只有一個杯子，後來慢慢加入的。</p>
<p>透過這種想法，我們就可以減少一個維度，變成二維陣列了！</p>
<h3 id="動態規劃轉移式"><a href="#動態規劃轉移式" class="headerlink" title="動態規劃轉移式"></a>動態規劃轉移式</h3><p>再來我們遇到了一個問題，轉移要如何轉移，動態規劃不會知道我們選哪個杯子比較好，那我們就沒辦法將沒有選到的杯子水量轉移到選到的杯子上呀。</p>
<p>此時我們可以想出一個想法，先定義一些名詞</p>
<ul>
<li><code>all</code> 全部的水杯總容量</li>
<li><code>sum</code> 全部水杯的總水量</li>
<li><code>f[j][k]</code> 當前 j 個杯子最大 k 容量時的水量</li>
<li><code>remain</code> 沒有選到的杯子總水量</li>
</ul>
<p>OK 現在這樣有了點想法了，題目是將<code>remain</code> / 2，而 <code>remain</code> 是透過 <code>sum</code> - <code>f[j][k]</code> 來的，我們所算出的最大水量則是 \((remain / 2) + f[j][k]\)，稍微將公式簡單化一下，把 remain 拆成 <code>sum</code> - <code>f[j][k]</code>，就變成了 \((sum - f[j][k]) / 2) + f[j][k] \)，再來乘二後 \((sum - f[j][k]) ) + 2(f[j][k]) \)，之後再同除二就變成了 \((sum + f[j][k]) ) / 2 \)，因此現在我們只要在最後計算這個公式就可以知道答案了！</p>
<p>可能會有些人好奇那 DP 的公式是甚麼呢？很簡單， \(f[j][k]) = max(f[j][k]), f[j-1][k-a[i]] + b[i]))\)，其中 <code>a[i]</code> 是第 i 杯的水量、<code>b[i]</code> 是第 i 杯的容量，與背包問題概念相同。</p>
<p>最後稍微注意一個重點，我們透過 \((sum + f[j][k]) ) / 2 \) 算出的答案不可以超過 k(最大容量)，如果超過就以最大容量為準。</p>
<p>需要特別注意的是，不可以像一般的背包問題一樣，直接將前個狀態轉移，因為每個<strong>最大容量 k</strong> 不一樣，如果有轉移那我們最後的公式就求不出來。</p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://blog.csdn.net/aezakmias/article/details/111495324" target="_blank" rel="noopener">Codeforces 1459D - Glass Half Spilled（背包DP） by _Hayasaka</a><br><a href="https://www.bilibili.com/video/av843179498/" target="_blank" rel="noopener">【DP】CF1459D Glass Half Spilled</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>這題好難，其實很多東西我都沒有想出來，動態規劃、壓縮動態規劃維度、轉移公式，這些東西我都沒有辦法獨自想出來，我需要再多學習，再把這些東西都轉出來。</p>
<p>現在學習的這些，希望可以幫助我啟發自己。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 120</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> dp[MAXN][MAXN*MAXN]; </span><br><span class="line"><span class="keyword">int</span> a[MAXN], b[MAXN]; <span class="comment">//是第 i 杯的水量</span></span><br><span class="line"><span class="keyword">int</span> all, sum, n; <span class="comment">//是第 i 杯的容量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123; <span class="comment">//輸入資料</span></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; b[i] &gt;&gt; a[i]; <span class="comment">//注意: 我這裡有寫反，因為題目跟我的腦袋思考方向不一樣。</span></span><br><span class="line">        sum += a[i]; <span class="comment">//累加最大水量</span></span><br><span class="line">        all += b[i]; <span class="comment">//累加最大容量</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXN; i++)&#123; <span class="comment">//DP 設定為 -INF，否則狀態會被轉移</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; MAXN*MAXN; j++) dp[i][j] = -MAXN * MAXN;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">//從這點開始 DP，因此設為零</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123; <span class="comment">//第 i 個杯子加入 dp</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &gt;= <span class="number">1</span>; j--)&#123; <span class="comment">//選用 j 個杯子</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = all; k &gt;= b[i]; k--) dp[j][k] = max(dp[j][k], dp[j<span class="number">-1</span>][k-b[i]]+a[i]); <span class="comment">//如果選用 j-1 個杯子且最大容量是 k-b[i] 時有沒有比原先大</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123; <span class="comment">//輸出答案</span></span><br><span class="line">        <span class="keyword">double</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= all; j++)&#123; <span class="comment">//對每個最大容量進行判斷</span></span><br><span class="line">            ans = max(ans, min( (sum+dp[i][j]) / <span class="number">2.0</span>, <span class="number">1.0</span> * j));</span><br><span class="line">            <span class="comment">//             min(    轉移公式           最大容量)</span></span><br><span class="line">            <span class="comment">//cout &lt;&lt; dp[i][j] &lt;&lt; ' ';</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; '\n';</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; fixed &lt;&lt; setprecision(<span class="number">10</span>) &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>; <span class="comment">//輸出答案，小數要求 10 位數</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>設計解題</tag>
        <tag>程式解題</tag>
        <tag>背包問題 Knapsack Problem</tag>
        <tag>Codeforces</tag>
        <tag>動態規劃 Dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title>統計學(二) 筆記 - 第十章 推論兩個平均數或是母體參數(Inference About Means and Proportions with Two Population)</title>
    <url>/2021/03/20/NTUT_note/statistics-ch10/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊與財金管理系大二下統計學重點整理<br><font color="#dd0000">並非所有人都適用，部分對我而言稍加容易的內容並不會寫在此內。</font><br><strong>這是觀看影片心得後的筆記，老師上課可能不太適用會忘記抄到</strong></p>
</blockquote>
<a id="more"></a>

<h2 id="此章有四個重點，分別為"><a href="#此章有四個重點，分別為" class="headerlink" title="此章有四個重點，分別為"></a>此章有四個重點，分別為</h2><ul>
<li>推論兩個不一樣的已知母體平均數 (Inference About the Difference Between Two Population Known Means)</li>
<li>推論兩個不一樣的已知母體平均數 (Inference About the Difference Between Two Population Known Means)</li>
<li>推論兩個不一樣的已知母體平均數樣本 (Inference About the Difference Between Two Population Means: Matched Sample)</li>
<li>推論兩個不一樣的母體參數 (Inference About the Difference Between Two Population Proportions)</li>
<li>可點擊右邊的 menu 選擇要看的重點</li>
</ul>
<h1 id="推論兩個不一樣的已知母體平均數-Inference-About-the-Difference-Between-Two-Population-Known-Means"><a href="#推論兩個不一樣的已知母體平均數-Inference-About-the-Difference-Between-Two-Population-Known-Means" class="headerlink" title="推論兩個不一樣的已知母體平均數 (Inference About the Difference Between Two Population Known Means)"></a>推論兩個不一樣的已知母體平均數 (Inference About the Difference Between Two Population Known Means)</h1><h2 id="估計兩個不一樣的已知母體平均數-Estimating-the-Difference-Between-Two-Population-Means"><a href="#估計兩個不一樣的已知母體平均數-Estimating-the-Difference-Between-Two-Population-Means" class="headerlink" title="估計兩個不一樣的已知母體平均數 (Estimating the Difference Between Two Population Means)"></a>估計兩個不一樣的已知母體平均數 (Estimating the Difference Between Two Population Means)</h2><p>直接透過重點進行說明</p>
<ul>
<li>兩個不同母體的平均數分別為 \(\mu_1, \mu_2\)</li>
<li>兩個平均數的差異就是 \(\mu_1 - \mu_2\)</li>
<li>估計 \(\mu_1 - \mu_2\)，我們先選擇隨機樣本 \(n_1\) 從母體 1，在選擇隨機樣本 \(n_2\) 從母體 2</li>
<li>定義 \(\bar{x_1}\) 等於 sample1 mean，\(\bar{x_2}\) 等於 sample2 mean</li>
<li>母體平均數的點估計差值就是 \(\bar{x_1} - \bar{x_2}\)，此公式的計算方式將在下點介紹，名稱為 Sample Distritubion。</li>
<li>不懂區間估計可看<a href="https://theriseofdavid.github.io/2020/12/29/NTUT_note/statistics-ch8/" target="_blank" rel="noopener">統計學(一) 筆記 - 第八章 區間估計(Interval Estimation)</a></li>
</ul>
<h3 id="抽樣分配公式-Sample-Distritubion"><a href="#抽樣分配公式-Sample-Distritubion" class="headerlink" title="抽樣分配公式 (Sample Distritubion)"></a>抽樣分配公式 (Sample Distritubion)</h3><ul>
<li>期望值 \(E(\bar{x_1} - \bar{x_2}) = \mu_1 - \mu_2\)</li>
<li>標準差 \(\sigma_{\bar{x_1} - \bar{x_2}} = \sqrt{\frac{\sigma_1^2}{n_1} + \frac{\sigma_2^2}{n_2}}\)<ul>
<li>\(\sigma_1, \sigma_2\) 分別是母體 1,2 的標準差</li>
<li>\(n_1, n_2\) 分別是母體  1,2 的抽樣大小</li>
</ul>
</li>
<li>區間估計 \(\bar{x_1} - \bar{x_2} \pm z_{a/2} \sqrt{\frac{\sigma_1^2}{n_1} + \frac{\sigma_2^2}{n_2}}\)<ul>
<li>\(1-a\) 則是信心水準</li>
</ul>
</li>
</ul>
<h4 id="舉例-A-高爾夫球設備製造商開發出了新球桿可以將高爾夫球打得更遠，而同時-B-也開發了一個新球桿，A-公司-sample-size-120balls-sample-mean-275yards-standard-error-15yards-B-公司-sample-size-80balls-sample-mean-258yards-standard-error-20yards，詢問在-95-的信心水準之中，這兩家公司的平均擊球差異是多少"><a href="#舉例-A-高爾夫球設備製造商開發出了新球桿可以將高爾夫球打得更遠，而同時-B-也開發了一個新球桿，A-公司-sample-size-120balls-sample-mean-275yards-standard-error-15yards-B-公司-sample-size-80balls-sample-mean-258yards-standard-error-20yards，詢問在-95-的信心水準之中，這兩家公司的平均擊球差異是多少" class="headerlink" title="舉例: A 高爾夫球設備製造商開發出了新球桿可以將高爾夫球打得更遠，而同時 B 也開發了一個新球桿，A 公司 sample size 120balls, sample mean 275yards, standard error = 15yards, B 公司 sample size 80balls, sample mean 258yards, standard error = 20yards，詢問在 95% 的信心水準之中，這兩家公司的平均擊球差異是多少"></a>舉例: A 高爾夫球設備製造商開發出了新球桿可以將高爾夫球打得更遠，而同時 B 也開發了一個新球桿，A 公司 sample size 120balls, sample mean 275yards, standard error = 15yards, B 公司 sample size 80balls, sample mean 258yards, standard error = 20yards，詢問在 95% 的信心水準之中，這兩家公司的平均擊球差異是多少</h4><ul>
<li>定義 population1 為 A 公司，population2 為 B 公司，我們透過抽取樣本的方式(用點估計)來算出 \(\mu_1 - \mu_2\)，但因為是樣本所以會有誤差的問題。</li>
<li>因此先算出點估計量 \(\mu_1 - \mu_2 = \bar{x_1} - \bar{x_2} = 275-258 = 17\)</li>
<li>再來我們帶抽樣分配公式，\(\bar{x_1} - \bar{x_2} \pm z_{a/2} \sqrt{\frac{\sigma_1^2}{n_1} + \frac{\sigma_2^2}{n_2}} = 17 \pm 1.96 \sqrt{\frac{(15)^2}{120} + \frac{(20)^2}{80}} = 17 \pm 5.14\)，也就是平均擊球差異會落在 11.86yards to 22.14yards. </li>
</ul>
<h2 id="假設檢定兩個不一樣的已知母體平均數-Hypothesis-Tests-About-mu-1-mu-2"><a href="#假設檢定兩個不一樣的已知母體平均數-Hypothesis-Tests-About-mu-1-mu-2" class="headerlink" title="假設檢定兩個不一樣的已知母體平均數 Hypothesis Tests About \(\mu_1 - \mu_2\)"></a>假設檢定兩個不一樣的已知母體平均數 Hypothesis Tests About \(\mu_1 - \mu_2\)</h2><p>先定義下左、右、雙尾的假設檢定，下方的 \(D_0\) 為數值</p>
<ul>
<li>左尾<ul>
<li>\(H_0: \mu_1 - \mu_2 \geq D_0\)</li>
<li>\(H_1: \mu_1 - \mu_2 &lt; D_0\)</li>
</ul>
</li>
<li>右尾<ul>
<li>\(H_0: \mu_1 - \mu_2 \leq D_0\)</li>
<li>\(H_1: \mu_1 - \mu_2 &gt; D_0\)</li>
</ul>
</li>
<li>雙尾<ul>
<li>\(H_0: \mu_1 - \mu_2 = D_0\)</li>
<li>\(H_1: \mu_1 - \mu_2 &lt;&gt; D_0\)</li>
</ul>
</li>
<li>而公式為 \(z = (\bar{x_1} - \bar{x_2})-D_0 / \sqrt{\frac{\sigma_1^2}{n_1} + \frac{\sigma_2^2}{n_2}}\)，注意已知的檢定量要用 z，未知的才有 t。</li>
<li>不懂假設統計可看<a href="https://theriseofdavid.github.io/2021/02/27/NTUT_note/statistics-ch9/" target="_blank" rel="noopener">統計學(二) 筆記 - 第九章 假說檢定(hypothesis testing)</a></li>
</ul>
<h3 id="舉例-A-高爾夫球設備製造商開發出了新球桿可以將高爾夫球打得更遠，而同時-B-也開發了一個新球桿，A-公司-sample-size-120balls-sample-mean-275yards-standard-error-15yards-B-公司-sample-size-80balls-sample-mean-258yards-standard-error-20yards，詢問在-1-的顯著性測試下是不是-A-公司大於-B-公司。"><a href="#舉例-A-高爾夫球設備製造商開發出了新球桿可以將高爾夫球打得更遠，而同時-B-也開發了一個新球桿，A-公司-sample-size-120balls-sample-mean-275yards-standard-error-15yards-B-公司-sample-size-80balls-sample-mean-258yards-standard-error-20yards，詢問在-1-的顯著性測試下是不是-A-公司大於-B-公司。" class="headerlink" title="舉例:  A 高爾夫球設備製造商開發出了新球桿可以將高爾夫球打得更遠，而同時 B 也開發了一個新球桿，A 公司 sample size 120balls, sample mean 275yards, standard error = 15yards, B 公司 sample size 80balls, sample mean 258yards, standard error = 20yards，詢問在 1% 的顯著性測試下是不是 A 公司大於 B 公司。"></a>舉例:  A 高爾夫球設備製造商開發出了新球桿可以將高爾夫球打得更遠，而同時 B 也開發了一個新球桿，A 公司 sample size 120balls, sample mean 275yards, standard error = 15yards, B 公司 sample size 80balls, sample mean 258yards, standard error = 20yards，詢問在 1% 的顯著性測試下是不是 A 公司大於 B 公司。</h3><ul>
<li>定義 population1 為 A 公司，population2 為 B 公司</li>
<li>因此定義對立假設與虛無假設<ul>
<li>\(H_0: \mu_1 - \mu_2 \leq 0\)</li>
<li>\(H_1: \mu_1 - \mu_2 &gt; 0\)</li>
</ul>
</li>
<li>設定顯著性測試 0.01</li>
<li>收集樣本，計算 z<br>\(z = ((\bar{x_1} - \bar{x_2})-D_0) / \sqrt{\frac{\sigma_1^2}{n_1} + \frac{\sigma_2^2}{n_2}} = ((235-218)-0) / \sqrt{\frac{(15^2)}{120} + \frac{(20)^2}{80}} = \frac{17}{2.62} = 6.49\)</li>
<li>使用方法<ul>
<li>p-Value Approach<ul>
<li>\(z = 6.49, p = 0.000007\)，\(1-p-value = 1 - 0.000007) = 0.999993\)</li>
<li>因為 \(p-value = 0.000007 &lt; \alpha = 0.01\)，因此我們拒絕 \(H_0\)</li>
<li>因此在百分之一的顯著性測試下，A 公司的球桿擊球距離大於 B</li>
</ul>
</li>
<li>Critical Value Approach<ul>
<li>\(a  = 0.01， z_{0.01} = 2.33\)，因此 Reject \(H_0\) if \(z \geq 2.33 \)</li>
<li>\(z = 6.49 \geq 2.33\)，因此我們拒絕 \(H_0\)</li>
<li>因此在百分之一的顯著性測試下，A 公司的球桿擊球距離大於 B</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="推論兩個不一樣的未知母體平均數-Inference-About-the-Difference-Between-Two-Population-unKnown-Means"><a href="#推論兩個不一樣的未知母體平均數-Inference-About-the-Difference-Between-Two-Population-unKnown-Means" class="headerlink" title="推論兩個不一樣的未知母體平均數 (Inference About the Difference Between Two Population unKnown Means)"></a>推論兩個不一樣的未知母體平均數 (Inference About the Difference Between Two Population unKnown Means)</h1><h1 id="區間估計來推估兩個不一樣的未知母體平均數"><a href="#區間估計來推估兩個不一樣的未知母體平均數" class="headerlink" title="區間估計來推估兩個不一樣的未知母體平均數"></a>區間估計來推估兩個不一樣的未知母體平均數</h1><ul>
<li>區間估計的公式為<br>\(\bar{x_1} - \bar{x_2} \pm t_{a/2} \sqrt{\frac{s_1^2}{n_1} + \frac{s_2^2}{n_2}}\)，s 為樣本標準差，其中 t 為自由度，但遇到兩個母體樣本因此公式變得比較麻煩，其中 \(t_{a/2} = (\frac{s_1^2}{n_1} + \frac{s_2^2}{n_2})^2 / (\frac{1}{n_1-1}(\frac{s_1^2}{n_1})^2 + \frac{1}{n_2-1}(\frac{s_2^2}{n_2})^2)  \)</li>
</ul>
<h3 id="舉例-A-公司生產出一種新車款想與-B-公司的最新車款就比較，在百分之-90-的信賴區間想要知道兩家平均油耗差異，其中-A-公司-sample-size-24cars-sample-mean-29-8mpg-sample-stdandard-2-56mpg-B-公司為-sample-size-28cars-sample-mean-27-3mpg-sample-stdandard-1-81mpg。"><a href="#舉例-A-公司生產出一種新車款想與-B-公司的最新車款就比較，在百分之-90-的信賴區間想要知道兩家平均油耗差異，其中-A-公司-sample-size-24cars-sample-mean-29-8mpg-sample-stdandard-2-56mpg-B-公司為-sample-size-28cars-sample-mean-27-3mpg-sample-stdandard-1-81mpg。" class="headerlink" title="舉例: A 公司生產出一種新車款想與 B 公司的最新車款就比較，在百分之 90 的信賴區間想要知道兩家平均油耗差異，其中 A 公司 sample size 24cars, sample mean 29.8mpg, sample stdandard 2.56mpg, B 公司為 sample size 28cars, sample mean 27.3mpg, sample stdandard 1.81mpg。"></a>舉例: A 公司生產出一種新車款想與 B 公司的最新車款就比較，在百分之 90 的信賴區間想要知道兩家平均油耗差異，其中 A 公司 sample size 24cars, sample mean 29.8mpg, sample stdandard 2.56mpg, B 公司為 sample size 28cars, sample mean 27.3mpg, sample stdandard 1.81mpg。</h3><ul>
<li>定義 population1 為 A 公司，population2 為 B 公司</li>
<li>因此先算出點估計量 \(\mu_1 - \mu_2 = \bar{x_1} - \bar{x_2} = 29.8-27.3 = 2.5\)</li>
<li>設定顯著性測試 0.1，\(a/2=0.5\)</li>
<li>計算 t \(t_{a/2} = (\frac{s_1^2}{n_1} + \frac{s_2^2}{n_2})^2 / (\frac{1}{n_1-1}(\frac{s_1^2}{n_1})^2 + \frac{1}{n_2-1}(\frac{s_2^2}{n_2})^2)  \)，帶入數字後就是 \((\frac{(2.56)^2}{24} + \frac{(1.81)^2}{28})^2 / (\frac{1}{24-1}(\frac{(2.56^2)}{24}^2) + \frac{1}{28-1} (\frac{(1.81)^2}{28})^2) = 40.585 \)，大約等於 40，這裡通常會判斷 40 與 41 的 t 哪個比較大，為了符合百分之 90 的信賴區間，因此選擇偏差較大的 40，如果這裡選 41 那有可能會小於百分之 90 的信賴區間，保險起見用 40，\(t_{a/2} = 1.684\)</li>
<li>帶入區間估計公式 \(\bar{x_1} - \bar{x_2} \pm t_{a/2} \sqrt{\frac{s_1^2}{n_1} + \frac{s_2^2}{n_2}} = 29.8-27.3 \pm 1.684 \sqrt{\frac{(2.56)^2}{24} + \frac{(1.81)^2}{28}} = 2.5 \pm 1.052\)，因此在百分之 90% 的信心水準之下，兩家平均油耗差異大約會在 1.448 to 3.552 mpg。</li>
</ul>
<h2 id="假設檢定來推估兩個不一樣的未知母體平均數"><a href="#假設檢定來推估兩個不一樣的未知母體平均數" class="headerlink" title="假設檢定來推估兩個不一樣的未知母體平均數"></a>假設檢定來推估兩個不一樣的未知母體平均數</h2><p>先定義下左、右、雙尾的假設檢定，下方的 \(D_0\) 為數值</p>
<ul>
<li>左尾<ul>
<li>\(H_0: \mu_1 - \mu_2 \geq D_0\)</li>
<li>\(H_1: \mu_1 - \mu_2 &lt; D_0\)</li>
</ul>
</li>
<li>右尾<ul>
<li>\(H_0: \mu_1 - \mu_2 \leq D_0\)</li>
<li>\(H_1: \mu_1 - \mu_2 &gt; D_0\)</li>
</ul>
</li>
<li>雙尾<ul>
<li>\(H_0: \mu_1 - \mu_2 = D_0\)</li>
<li>\(H_1: \mu_1 - \mu_2 &lt;&gt; D_0\)</li>
</ul>
</li>
<li>而公式為 \(t = (\bar{x_1} - \bar{x_2})-D_0 / \sqrt{\frac{s_1^2}{n_1} + \frac{s_2^2}{n_2}}\)，注意已知的檢定量要用 z，未知的才有 t。</li>
</ul>
<h3 id="舉例-A-公司生產出一種新車款想與-B-公司的最新車款就比較，在-5-的顯著性測試中，我們想知道-A-公司是不是平均油耗比-B-公司好，其中-A-公司-sample-size-24cars-sample-mean-29-8mpg-sample-stdandard-2-56mpg-B-公司為-sample-size-28cars-sample-mean-27-3mpg-sample-stdandard-1-81mpg。"><a href="#舉例-A-公司生產出一種新車款想與-B-公司的最新車款就比較，在-5-的顯著性測試中，我們想知道-A-公司是不是平均油耗比-B-公司好，其中-A-公司-sample-size-24cars-sample-mean-29-8mpg-sample-stdandard-2-56mpg-B-公司為-sample-size-28cars-sample-mean-27-3mpg-sample-stdandard-1-81mpg。" class="headerlink" title="舉例: A 公司生產出一種新車款想與 B 公司的最新車款就比較，在 5% 的顯著性測試中，我們想知道 A 公司是不是平均油耗比 B 公司好，其中 A 公司 sample size 24cars, sample mean 29.8mpg, sample stdandard 2.56mpg, B 公司為 sample size 28cars, sample mean 27.3mpg, sample stdandard 1.81mpg。"></a>舉例: A 公司生產出一種新車款想與 B 公司的最新車款就比較，在 5% 的顯著性測試中，我們想知道 A 公司是不是平均油耗比 B 公司好，其中 A 公司 sample size 24cars, sample mean 29.8mpg, sample stdandard 2.56mpg, B 公司為 sample size 28cars, sample mean 27.3mpg, sample stdandard 1.81mpg。</h3><ul>
<li>定義 population1 為 A 公司，population2 為 B 公司</li>
<li>因此定義對立假設與虛無假設<ul>
<li>\(H_0: \mu_1 - \mu_2 \leq 0\)</li>
<li>\(H_1: \mu_1 - \mu_2 &gt; 0\)</li>
</ul>
</li>
<li>設定顯著性測試 0.05</li>
<li>收集樣本，計算 t<br>\(t = (\bar{x_1} - \bar{x_2})-D_0 / \sqrt{\frac{s_1^2}{n_1} + \frac{s_2^2}{n_2}} =  \frac{(29.8-27.3) -0}{\sqrt{\frac{(2.56)^2}{24} + \frac{(1.81)^2}{28}}} = 4.003\)</li>
<li>使用方法<ul>
<li>p-Value Approach<ul>
<li>先計算自由度<br>計算 \(t_{a} = (\frac{s_1^2}{n_1} + \frac{s_2^2}{n_2})^2 / (\frac{1}{n_1-1}(\frac{s_1^2}{n_1})^2 + \frac{1}{n_2-1}(\frac{s_2^2}{n_2})^2)  \)，帶入數字後就是 \((\frac{(2.56)^2}{24} + \frac{(1.81)^2}{28})^2 / (\frac{1}{24-1}(\frac{(2.56^2)}{24}^2) + \frac{1}{28-1} (\frac{(1.81)^2}{28})^2) = 40.585 \)，大約等於 40，這裡通常會判斷 40 與 41 的 t 哪個比較大，為了符合百分之 90 的信賴區間，因此選擇偏差較大的 40，如果這裡選 41 那有可能會小於百分之 90 的信賴區間，保險起見用 40，\(t_{a} = 1.684\)</li>
<li>\(t=4.003, p = 0.00013\)，\(1-p-value = 1 - 0.00013 = 0.99987\)</li>
<li>\(p-value = 0.00013 &lt; 0.05 = \alpha \)，因此我們拒絕 \(H_0\)</li>
<li>因此在百分之五的顯著性測試下，A 公司車款的平均油耗比 B 公司車款好</li>
</ul>
</li>
<li>Critical Value Approach<ul>
<li>\(a  = 0.05， t_{0.05} = 1.684\)，因此 Reject \(H_0\) if \(t \geq 1.684 \)</li>
<li>\(z = 4.003 \geq 1.684\)，因此我們拒絕 \(H_0\)</li>
<li>因此在百分之五的顯著性測試下，A 公司車款的平均油耗比 B 公司車款好</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="推論兩個不一樣的已知母體平均數樣本，配對樣本情況-Inference-About-the-Difference-Between-Two-Population-Means-Matched-Sample"><a href="#推論兩個不一樣的已知母體平均數樣本，配對樣本情況-Inference-About-the-Difference-Between-Two-Population-Means-Matched-Sample" class="headerlink" title="推論兩個不一樣的已知母體平均數樣本，配對樣本情況 (Inference About the Difference Between Two Population Means: Matched Sample)"></a>推論兩個不一樣的已知母體平均數樣本，配對樣本情況 (Inference About the Difference Between Two Population Means: Matched Sample)</h1><p>定義配對樣本情況，相同的樣本但在兩次的測試中有不一樣的結果，通常是實驗前跟實驗後的對照。</p>
<p>由於這種樣本會比其前兩種方式的樣本差來的更小很多，因為並不是獨立關係，而是<strong>改變</strong>了甚麼。</p>
<p>這邊直接透過舉例來進行說明。</p>
<!-- 通常不會用區間估計，而是用假設檢定，因為實驗的問題用區間估計比較沒有意義。 -->

<h2 id="舉例-A-公司要將文件送至各地的子公司，她們有兩家快遞公司可以選擇，在百分之-95-的信心水準中，他們想知道這兩家快遞公司送到子公司的時間是不是不一樣？"><a href="#舉例-A-公司要將文件送至各地的子公司，她們有兩家快遞公司可以選擇，在百分之-95-的信心水準中，他們想知道這兩家快遞公司送到子公司的時間是不是不一樣？" class="headerlink" title="舉例:A 公司要將文件送至各地的子公司，她們有兩家快遞公司可以選擇，在百分之 95 的信心水準中，他們想知道這兩家快遞公司送到子公司的時間是不是不一樣？"></a>舉例:A 公司要將文件送至各地的子公司，她們有兩家快遞公司可以選擇，在百分之 95 的信心水準中，他們想知道這兩家快遞公司送到子公司的時間是不是不一樣？</h2><p>樣本資料如下</p>
<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1ncHoj7CIjFrd3QtKflbcrLDdZ_KDaudz&export=download" alt=""></p>
</blockquote>
<ul>
<li>定義 UPX 為 A 公司，INTEX 為 B 公司</li>
<li>因此定義對立假設與虛無假設<ul>
<li>\(H_0: \mu_d = 0\)</li>
<li>\(H_1: \mu_d &lt;&gt; 0\)</li>
<li>\(\mu_d\) 為兩家公司的送的時間差別</li>
</ul>
</li>
<li>設定顯著性測試 0.05</li>
<li>計算假設檢定的所有值，標準差、平均數、t <ul>
<li>\(\bar{d} = \frac{\sum d_i}{n} = \frac{(7+6+…+5)}{10} = 2.7\)</li>
<li>\(s_d = \frac{\sum (d_i - \bar{d})^2}{n-1} = \sqrt{\frac{76.1}{9}} = 2.9\)</li>
<li>\(t = \frac{\bar{d} - \mu_d}{s_d / \sqrt{n}} = \frac{2.7-0}{2.9 / \sqrt{10}} = 2.94 \)，\(\mu_d\) 則是 \(H_0\) 的狀態(通常是等於)。</li>
</ul>
</li>
<li>使用方法<ul>
<li>p-Value Approach<ul>
<li>先計算自由度<br>\(t=2.94, df =9\)，df = 自由度，雙尾的機率則是落在 0.01649</li>
<li>\(p = 0.01649\)，\(1-p-value = 1 - 0.01649 = 0.98351\)</li>
<li>\(p-value = 0.01649 &lt; 0.05 = \alpha \)，因此我們拒絕 \(H_0\)</li>
<li>在百分之 95% 的信心水準中，我們可以知道這兩家送文件到子公司時有時間差。</li>
</ul>
</li>
<li>Critical Value Approach<ul>
<li>\(a  = 0.05， t_{0.025} = 2.262\)，因此 Reject \(H_0\) if \(t \geq 2.262 \)</li>
<li>\(t=2.94 \geq 2.262\)，因此 Reject \(H_0\) </li>
<li>在百分之 95% 的信心水準中，我們可以知道這兩家送文件到子公司時有時間差。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="當兩個母體平均數的變異數相同時"><a href="#當兩個母體平均數的變異數相同時" class="headerlink" title="當兩個母體平均數的變異數相同時"></a>當兩個母體平均數的變異數相同時</h1><ul>
<li>此時我們的 t 檢定可以優化成 \(t = (\bar{x_1} - \bar{x_2}) / (s_p \sqrt{\frac{1}{n_1} + \frac{1}{n_2}} ) \)</li>
<li>而其中的 \(s_p\) 可以優化為 \(s_p = \sqrt{\frac{(n_1-1) s_1^2 + (n_2-1) s_2^2}{n_1 + n_2 -2}}\)</li>
</ul>
<h1 id="推論兩個不一樣的母體參數-Inference-About-the-Difference-Between-Two-Population-Proportions"><a href="#推論兩個不一樣的母體參數-Inference-About-the-Difference-Between-Two-Population-Proportions" class="headerlink" title="推論兩個不一樣的母體參數 (Inference About the Difference Between Two Population Proportions)"></a>推論兩個不一樣的母體參數 (Inference About the Difference Between Two Population Proportions)</h1><p>先來定義一些必要資訊</p>
<ul>
<li>區間估計  \(p_1 - p_2\)</li>
<li>假設檢定則是  \(p_1 - p_2\)</li>
<li>Expected Value<br>\(E(\bar{p_1} - \bar{p_2}) = p_1 - p_2\)</li>
<li>Standard Deviation(Standard Error)<br>\(\sigma_{p_1 - p_2} = \sqrt{\frac{p_1 ( 1- p_1)}{n_1}+\frac{p_2(1-p_2)}{n_2}}\)<ul>
<li>\(n_1\) 母體 A 的樣本大小</li>
<li>\(n_2\) 母體 B 的樣本大小</li>
</ul>
</li>
<li>必須要符合此四條件，才能夠用常態分配推論兩個不一樣的母體參數<ul>
<li>\(n_1 p_1 \geq 5\) and \(n_1(1-p_1) \geq 5\)</li>
<li>\(n_2 p_2 \geq 5\) and \(n_2(1-p_2) \geq 5\)</li>
</ul>
</li>
<li>\(z = \frac{\bar{p_1} - \bar{p_2}}{\sigma_{\bar{p_1} - \bar{p_2}}}\)</li>
</ul>
<p>用圖片來表示的畫如下</p>
<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1bUJTFi7ScFqqXI9sRMDTIj0OyuYaoMVg&export=download" alt=""></p>
</blockquote>
<p>因此我們就可以推出區間估計公式為 \(\bar{p_1} - \bar{p_2} \pm z_{a/2} \sqrt{\frac{\bar{p_1} ( 1- \bar{p_1)}}{n_1}+\frac{\bar{p_2}(1-\bar{p_2})}{n_2}} \)</p>
<h2 id="舉例：行銷協會想要評估這次的行銷活動有沒有效，先進行市話調查，想知道有多少人知道這個商品，分為前測與後測，前測是在還沒開始此行銷活動，後測則是開始；前測得知在-150-人中有-60-位知道此商品，後測則是-250-人中有-120-人知道此商品，我們想知道這些資料能否證明此行銷活動前後有多少人知道的差異"><a href="#舉例：行銷協會想要評估這次的行銷活動有沒有效，先進行市話調查，想知道有多少人知道這個商品，分為前測與後測，前測是在還沒開始此行銷活動，後測則是開始；前測得知在-150-人中有-60-位知道此商品，後測則是-250-人中有-120-人知道此商品，我們想知道這些資料能否證明此行銷活動前後有多少人知道的差異" class="headerlink" title="舉例：行銷協會想要評估這次的行銷活動有沒有效，先進行市話調查，想知道有多少人知道這個商品，分為前測與後測，前測是在還沒開始此行銷活動，後測則是開始；前測得知在 150 人中有 60 位知道此商品，後測則是 250 人中有 120 人知道此商品，我們想知道這些資料能否證明此行銷活動前後有多少人知道的差異"></a>舉例：行銷協會想要評估這次的行銷活動有沒有效，先進行市話調查，想知道有多少人知道這個商品，分為前測與後測，前測是在還沒開始此行銷活動，後測則是開始；前測得知在 150 人中有 60 位知道此商品，後測則是 250 人中有 120 人知道此商品，我們想知道這些資料能否證明此行銷活動前後有多少人知道的差異</h2><ul>
<li>先來定義參數<ul>
<li>\(p_1\) 為後測後，知道商品的數量</li>
<li>\(p_2\) 為前測後，知道商品的數量</li>
<li>\(\bar{p_1}\) 為後測的樣本參數</li>
<li>\(\bar{p_2}\) 為前測的樣本參數</li>
</ul>
</li>
<li>所以 \(p_1 - p_2 = \frac{120}{250} - \frac{60}{150} = 0.48-0.40=0.08\)</li>
<li>區間估計<ul>
<li>顯著性測試 0.05</li>
<li>因此 \(z_{0.025} = 1.96\)</li>
<li>\(0.48 - 0.40 \pm 1.96 \sqrt{\frac{0.48(0.52)}{250} + \frac{0.40(0.60)}{150}} = 0.08 \pm 1.96(0.510) = 0.08 \pm 0.10\)</li>
<li>因此在百分之 95% 的信心，在宣傳前與宣傳後的差異會落在 0 to 0.18</li>
</ul>
</li>
</ul>
<h2 id="假設檢定-Hypothesis-Tests-about-p-1-p-2"><a href="#假設檢定-Hypothesis-Tests-about-p-1-p-2" class="headerlink" title="假設檢定 Hypothesis Tests about \(p_1 - p_2\)"></a>假設檢定 Hypothesis Tests about \(p_1 - p_2\)</h2><p>先定義下左、右、雙尾的假設檢定</p>
<ul>
<li>左尾<ul>
<li>\(H_0: p_1 - p_2 \geq D_0\)</li>
<li>\(H_1: p_1 - p_2 &lt; D_0\)</li>
</ul>
</li>
<li>右尾<ul>
<li>\(H_0: p_1 - p_2 \leq D_0\)</li>
<li>\(H_1: p_1 - p_2 &gt; D_0\)</li>
</ul>
</li>
<li>雙尾<ul>
<li>\(H_0: p_1 - p_2 = D_0\)</li>
<li>\(H_1: p_1 - p_2 &lt;&gt; D_0\)</li>
</ul>
</li>
</ul>
<p>再來定義假設檢定中需要的標準差、點估計、z 值</p>
<ul>
<li>標準差 \(\bar{p_1} - \bar{p_2}\) 當 \(p_1 = p_2 = p\)<br>公式為 \(\sigma_{\bar{p_1} - \bar{p_2}} = \sqrt{p(1-p) (\frac{1}{n_1}+\frac{1}{n_2})}\)</li>
<li>混和估計量 pooled Estimator 當 \(p_1 = p_2 = p\)，為兩個樣本混合的點估計量，能夠更方便的計算<br>公式為 \(\bar{p} = \frac{n_1 \bar{p_1} + n_2 \bar{p_2}}{n_1 + n_2}\)</li>
<li>假設檢定中的 z 值則是 \(z=\frac{(\bar{p_1} - \bar{p_2})}{\sqrt{p(1-p) (\frac{1}{n_1}+\frac{1}{n_2})}}\)</li>
</ul>
<h3 id="舉例：行銷協會想要評估這次的行銷活動有沒有效，先進行市話調查，想知道有多少人知道這個商品，分為前測與後測，前測是在還沒開始此行銷活動，後測則是開始；前測得知在-150-人中有-60-位知道此商品，後測則是-250-人中有-120-人知道此商品，再百分之-95-的信心水準中，我們想知道這些資料能否證明此行銷活動可以提高商品知名度"><a href="#舉例：行銷協會想要評估這次的行銷活動有沒有效，先進行市話調查，想知道有多少人知道這個商品，分為前測與後測，前測是在還沒開始此行銷活動，後測則是開始；前測得知在-150-人中有-60-位知道此商品，後測則是-250-人中有-120-人知道此商品，再百分之-95-的信心水準中，我們想知道這些資料能否證明此行銷活動可以提高商品知名度" class="headerlink" title="舉例：行銷協會想要評估這次的行銷活動有沒有效，先進行市話調查，想知道有多少人知道這個商品，分為前測與後測，前測是在還沒開始此行銷活動，後測則是開始；前測得知在 150 人中有 60 位知道此商品，後測則是 250 人中有 120 人知道此商品，再百分之 95 的信心水準中，我們想知道這些資料能否證明此行銷活動可以提高商品知名度"></a>舉例：行銷協會想要評估這次的行銷活動有沒有效，先進行市話調查，想知道有多少人知道這個商品，分為前測與後測，前測是在還沒開始此行銷活動，後測則是開始；前測得知在 150 人中有 60 位知道此商品，後測則是 250 人中有 120 人知道此商品，再百分之 95 的信心水準中，我們想知道這些資料能否證明此行銷活動可以提高商品知名度</h3><p><strong>此舉例是將 \(p_1\) and \(p_2\) 混和</strong></p>
<ul>
<li>定義 \(p_1\) 是後測，定義 \(p_2\) 是前測</li>
<li>因此定義對立假設與虛無假設<ul>
<li>\(H_0: p_1 - p_2 \leq 0\)</li>
<li>\(H_1: p_1 - p_2 &gt; 0\)</li>
</ul>
</li>
<li>設定顯著性測試 0.05</li>
<li>計算 z 檢定<ul>
<li>\(\bar{p} = \frac{250(0.48) + 150(0.40)}{250+150} = \frac{180}{400} = 0.45\)</li>
<li>\(\sigma_{\bar{p_1} - \bar{p_2}} = \sqrt{p(1-p) (\frac{1}{n_1}+\frac{1}{n_2})} = \sqrt{0.45(0.55)(\frac{1}{250}+\frac{1}{150})} = 0.514\)</li>
<li>\(z=\frac{(\bar{p_1} - \bar{p_2})}{\sqrt{p(1-p) (\frac{1}{n_1}+\frac{1}{n_2})}} = \frac{(0.48-0.40)-0}{0.0514} = \frac{0.08}{0.0514} = 1.56\)，其中的 \(\frac{(0.48-0.40)-0}{0.0514}\)，為甚麼要減零是指前面 \(H_0: p_1 - p_2 \leq 0\) 的意思</li>
<li>要特別注意，母體參數不需要用 t 檢定，前面有提到必須符合四條件(其中兩個是\(n_1 p_1 \geq 5\) and \(n_1(1-p_1) \geq 5\))就可以用常態分配</li>
</ul>
</li>
<li>使用方法<ul>
<li>p-Value Approach<ul>
<li>\(z=1.56, p-value=0.0594\)</li>
<li>\(p-value &gt; a = 0.05\)，因此我們不拒絕 \(H_0\)</li>
<li>因此我們不能肯定在此行銷活動後，我們的商品知名度會提高</li>
</ul>
</li>
<li>Critical Value Approach<ul>
<li>\(a=0.05, z_{0.05} = 1.645\)，因此 Reject \(H_0\) if \(t \geq 1.645\)</li>
<li>\(1.56 &lt; 1.645\)，因此我們不拒絕 \(H_0\)</li>
<li>因此我們不能肯定在此行銷活動後，我們的商品知名度會提高</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h1><ul>
<li>北科大丁秀儀老師教學</li>
<li><a href="https://libguides.library.kent.edu/spss/independentttest" target="_blank" rel="noopener">SPSS TUTORIALS: INDEPENDENT SAMPLES T TEST</a></li>
</ul>
]]></content>
      <categories>
        <category>北科上課筆記</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>統計學筆記</tag>
        <tag>北科大二下統計學筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces 1496D - Let&#39;s Go Hiking(設計解題)</title>
    <url>/2021/03/22/Codeforces/Codeforces%201496D/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>有 Q 先生與 D 先生兩個人在玩遊戲，給你一組數列，Q 先生只能走遞減(可以向左或向右)、D 先生則是遞增(可以向左或向右)，Q 先走，D 後走，如果 Q 可以贏的話，輸出它有幾種贏法，第一個 x 的 index 算一種。<br>沒有就輸出零</p>
<p><a href="https://codeforces.com/contest/1496/problem/D" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li>了解贏有哪幾種情況</li>
<li>了解輸有哪幾種情況</li>
<li>贏的話可以有幾種贏法?</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>好題，但我智商不高一直解不出來，還有些地方一直用常理去判斷QQQ，商科的爛題目大部分都還需要常理輔佐，但演算法的題目就不用，但我常常搞混:)。</p>
<p>簡單來說，我們可以將數列進行分析，分成遞增與遞減。<br>再來我們可以知道 Q、D 先生他們只要你能夠走遞增與遞減，所以理念上是他們只要有符合某種順序即可。(也就是 Q 先生不需要在意遞增或遞減，只要讓他走這兩種隨便一種即可，D 先生亦同)。</p>
<p>我們來簡單分析一下</p>
<ul>
<li>D 先生不能在走下一步，Q 先生贏</li>
<li>但 D 先生是後手可以控制 Q 先生的走法<br>例如 <code>1 2 3</code>，Q 先生選 1，那 D 先生選 2，Q 先生就輸了</li>
<li>於是 Q 先生要到某個 x，讓他往左往右都行的通，此點我們稱為<strong>轉折點</strong><br>例如 <code>1 3 2</code>，那 Q 選 3 往 1 or 2 都行的通。</li>
<li>如果轉折點的左邊比較短，那 D 先生一定選右邊，這樣才能折磨死 Q 先生，反之亦同。長度:以轉折點為中心，向左或向右可延伸的最大數量。<br>例如 <code>1 4 3 2</code>，那 Q 先生選 4，D 先生只要選右邊(3,2)，就比左邊的邊長更長，更多步可走</li>
<li>因此我們能夠知道，要找出一種轉折點是左邊的長度與右邊的長度相同。<br>例如 <code>1 3 2</code>，這時 D 先生就不好選左邊還是右邊。</li>
<li>但題目有說，Q 先生、D 先生不能走下一步的規則是<ul>
<li>沒辦法繼續走遞增或遞減的數列</li>
<li>下一步會撞到另外一位先生</li>
</ul>
</li>
<li>也就是說，可以走曾經別人走過的路！那某些題目 D 先生又有想法可以解了<br>例如 <code>1 3 2</code>，Q 先生選 3，D 先生選 1，Q 先生選 2，D 先生選 3，D 先生贏了！</li>
<li>發現一個問題，如果左邊邊長跟右邊邊長相同且邊長數量都是偶數時，D 先生會贏</li>
<li>因此 Q 先生贏的規則如下(必須都符合)<ul>
<li>轉折點的左邊長與右邊長相同</li>
<li>兩邊的邊長必須是奇數</li>
</ul>
</li>
</ul>
<p>最後是題目的小陷阱，考驗思考完整能力</p>
<ul>
<li>如果剛好也有一個轉折點的某個邊長與，我們 Q 先生勝利規則中的轉折點長度一樣時呢?<br>很不幸的，那還是 D 先生贏，因為 D 先生可以走另外一個消耗 Q 先生的步數。舉例: <code>1 3 2 4</code>，Q 先生選 3，D 先生選 2，Q 先生選 1，D 先生選 4，D 先生贏了！</li>
<li>因此我們在歸納一下</li>
<li>因此 Q 先生贏的規則如下(必須都符合)<ul>
<li>轉折點的左邊長與右邊長相同</li>
<li>兩邊的邊長必須是奇數</li>
<li>此轉折點的邊長必須是所有轉折點的邊長中長度最大的</li>
<li>此轉折點的邊長不可以跟其他轉折點任一邊長長度相同</li>
<li>由於我們只能找邊長最長的轉折點，因此答案只能有一個</li>
</ul>
</li>
</ul>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://blog.csdn.net/weixin_43911947/article/details/114673797" target="_blank" rel="noopener">D. Let‘s Go Hiking by <del>KIKI</del></a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>題目有點考倒我了QQ，好多東西都不太懂，我研究這題研究了 3hr…，雖然大部分時間是自己耍笨一直忘記 D 先生也可以走 Q 先生走過的。</p>
<p>總之，希望我學習的演算法，會讓我變聰明八XD，能應用上生活中。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100020</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> in[MAXN], de[MAXN]; <span class="comment">//遞增長度與遞減長度的陣列，</span></span><br><span class="line"><span class="keyword">int</span> n, num[MAXN], maxn = <span class="number">0</span>; <span class="comment">//num 是題目數列資料 maxn 是最大邊長 n 是數列 size</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; record[MAXN]; <span class="comment">//紀錄在 record[index] 中，在 i 點的邊長是 index</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123; <span class="comment">//輸入資料</span></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; num[i];</span><br><span class="line">        in[i] = num[i] &gt; num[i<span class="number">-1</span>] ? in[i<span class="number">-1</span>]+<span class="number">1</span> : <span class="number">1</span>; <span class="comment">//判斷是否遞增</span></span><br><span class="line">        <span class="keyword">if</span>(maxn &lt;= in[i])&#123; <span class="comment">//判斷是否是最大邊長</span></span><br><span class="line">            maxn = in[i]; <span class="comment">//更新</span></span><br><span class="line">            record[in[i]].push_back(i); <span class="comment">//將此點加入 record[index]</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    de[n] = <span class="number">1</span>; <span class="comment">//最後的數列值，直接設 1 否則出錯</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>; i &gt;= <span class="number">1</span>; i--)&#123;</span><br><span class="line">        de[i] = num[i] &gt; num[i+<span class="number">1</span>] ? de[i+<span class="number">1</span>]+<span class="number">1</span> : <span class="number">1</span>; <span class="comment">//判斷是否遞減</span></span><br><span class="line">        <span class="keyword">if</span>(maxn &lt;= de[i]) record[de[i]].push_back(i); <span class="comment">//如果有比最大邊長大，我們再放入 record</span></span><br><span class="line">        <span class="comment">//前面是因為還不了解最大邊長是多少，才會只要大於就加入</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>; <span class="comment">//判斷 x 的可能性</span></span><br><span class="line">    <span class="keyword">if</span>(record[maxn].size() &lt;= <span class="number">2</span> &amp;&amp; maxn % <span class="number">2</span> != <span class="number">0</span>)&#123; <span class="comment">//如果最大的邊長只有兩個，並且最大邊長長度為奇數時</span></span><br><span class="line">    <span class="comment">//否則都是不成立勝利的規則</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it: record[maxn])&#123; <span class="comment">//iterator，確認那兩個最大邊長都是在同個轉折點上</span></span><br><span class="line">            <span class="keyword">if</span>(de[it] == in[it]) ans = <span class="number">1</span>; <span class="comment">//是就輸出 1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    cout &lt;&lt; '\n';</span></span><br><span class="line"><span class="comment">    for(int i = 1; i &lt;= n; i++) cout &lt;&lt; in[i] &lt;&lt; ' ';</span></span><br><span class="line"><span class="comment">        cout &lt;&lt; '\n';</span></span><br><span class="line"><span class="comment">    for(int i = 1; i &lt;= n; i++) cout &lt;&lt; de[i] &lt;&lt; ' ';</span></span><br><span class="line"><span class="comment">        cout &lt;&lt; '\n';</span></span><br><span class="line"><span class="comment">    cout &lt;&lt; "maxn = " &lt;&lt; maxn &lt;&lt; '\n';</span></span><br><span class="line"><span class="comment">    /*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>設計解題</tag>
        <tag>程式解題</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>2021/03/22 媽媽總是會拿孩子剛買的晚餐吃幾口</title>
    <url>/2021/03/22/life_experence/Involuntary_family/</url>
    <content><![CDATA[<h2 id="說明"><a href="#說明" class="headerlink" title="說明"></a>說明</h2><blockquote>
<p>宣洩文，不懂老媽的心裏在想甚麼，整天只想帶給她自己覺得很棒的價值觀。</p>
</blockquote>
<a id="more"></a>

<h2 id="事由"><a href="#事由" class="headerlink" title="事由"></a>事由</h2><p>我今天買了一份麥當勞，裡面有雞塊、薯條、可樂、麥香雞，這都是我喜歡吃的東西，我媽又習慣性的自己進來就直接要拿薯條來吃，拿了三根，這對於我來說是非常不開心的一件事情，於是我就開玩笑地說有三條薯條失去了生命，我想透過這樣來表達我非常不喜歡自己買的東西被吃掉的感覺。</p>
<p>結果，我媽就說別人家的小孩學歷比你低還會懂得分享，你考上北科還不願意分享，你花的是我的錢所以我吃你的東西也是理所當然的，我對此事情感到非常生氣。</p>
<p>他沒有在我面前講這件事，但我在背後聽到，真的非常不爽，她下次進門又拿了一塊雞塊，我就兇她，阿你不是都自己拿，整天都說別人的小孩就會分享，他就被我氣倒拉，生氣啦。</p>
<h2 id="我很生氣"><a href="#我很生氣" class="headerlink" title="我很生氣"></a>我很生氣</h2><p>我真的很討厭有人要我分享食物，從小到大我的零用錢永遠都是餓死狀態，小時候整天吃的東西都是不好吃的東西，小時候帶去補習班吃的晚餐還會被其他同學說聞起來很臭，真的會讓一個小孩的自尊受創。</p>
<p>從那開始我對吃就很要求，我認為吃東西就是好吃、新鮮，我喜歡吃的東西就是要吃，沒有甚麼比吃更重要，從之前高中慢慢爭取自己可以吃東西的權力後，我媽就會在我買速食的時候常常來吃一口兩口，我一直都不喜歡這種感覺，這是我的食物欸！我不給你就會開始講，你是我養的、錢是我給的，把那些中國孝順言論搬出來。</p>
<p>所以這樣套用在每個人就合理嗎？透過這樣來合理自己的想法，從來都沒有想過自己的小孩為甚麼不願意分享，是甚麼原因造成的，每次都說是自己的問題，自己改掉就好了。恩，很簡單啊，那你不要每天都刺激我就好啦，整天都會用這種方式拿我想吃的東西，然後吃了再開始講這是理所當然的，這種名利雙收的事還真希望我在現實中也能應用到阿。</p>
<h2 id="她的生氣"><a href="#她的生氣" class="headerlink" title="她的生氣"></a>她的生氣</h2><p>她的生氣一定就是自己的小孩為甚麼可以兇她，不孝順…這種東西，然後再跟他的那些朋友們分享之類的八，我時常都不太懂這些概念，一個受過正常教育讀過北科的小孩如果沒有分享此概念，那肯定就是在某部分的教育有缺失，他總不去思考這些，拿 1970 的思維來養小孩，小孩活的好辛苦。</p>
<p>我統整好了，小孩如何導致有自私的心理</p>
<ul>
<li>從小資源不足，金錢、衣服<br>我媽從小時候給我的錢就是少，每件事情都要我去爭取，哪個人會想要把自己努力爭取的事物直接分享給別人</li>
<li>考好幸褔的是你自己，不分享是你的問題<br>我超討厭這種不要馬吃草，又要馬跑得快的問題了，我家庭的思考方式是我給小孩多少的投資，小孩一定要給上倍的回報量才能叫做正常，我受不了那種拿自己的價值觀框固別人的思考。人脈我也沒有，學習資源基本上都是政府給的，給予我最多的就是基本生活。但我真的好累，我學到百分之 80% 的知識都是透過學校還有朋友。如果真要感謝我還真想要感謝一路幫助我的人。</li>
</ul>
<h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>真的好累，活在這種家庭下生活基本上不會快樂超過三天，一定可以有吵架讓人心情不好的事情，小事也可以拿出來吵，真的受夠了。精神上的家庭暴力。</p>
<p>想要搬出去住，這樣我就不需要給別人罵，我吃麥當勞也能夠開心的吃，不需要跟別人分享，躲在我的電腦桌前跟我一起開心的享受速食。</p>
]]></content>
      <categories>
        <category>人生旅途</category>
      </categories>
      <tags>
        <tag>大學Life</tag>
        <tag>人生旅途</tag>
      </tags>
  </entry>
  <entry>
    <title>2021/03/19 夜晚騎車跑山華梵大學、深坑老街</title>
    <url>/2021/03/22/life_experence/Shenkeng_visiting_with_yuan/</url>
    <content><![CDATA[<h2 id="說明"><a href="#說明" class="headerlink" title="說明"></a>說明</h2><blockquote>
<p>我北科材資系的朋友 陳秉沅，最近剛獲得了一台雷霆 125，找我去跑山，雖然我很懶惰XD，但是我還是跟他一起去了XD。</p>
</blockquote>
<a id="more"></a>

<h2 id="相約"><a href="#相約" class="headerlink" title="相約"></a>相約</h2><p>有天秉沅打電話給我問我要不要去跑山，其實我有點想要出門，但是我比較想要唱 KTV，所以我就有點在猶豫要不要出去，秉沅太熱情了，我的氣勢就弱掉了，就答應去跑山了。</p>
<h3 id="要去哪裡"><a href="#要去哪裡" class="headerlink" title="要去哪裡"></a>要去哪裡</h3><p>秉沅想去陽明山，大衛表示晚上沒路燈，我不要。<br>秉沅挑了一堆日子去，大衛表示很忙不想去。</p>
<p>在我不斷地拒絕一陣子後，後來終於找到一個日子，運動會前一天 03/19，去深坑吃臭豆腐啦。</p>
<h2 id="出發"><a href="#出發" class="headerlink" title="出發"></a>出發</h2><p>原本一開始是打算要約下午 4 點，但後來因為要弄台灣大專院校程式設計競賽的獎學金 delay 到 5 點半，讓秉沅等了我那麼久真的很不好意思QQ。</p>
<p>後來我們出發，我當前導，但是我沒有 GPS，我原本以為我很熟北科到深坑的路，但後來我發現我錯了QQ，我一直走錯路…，直接炸開XDDDD，幸好秉沅沒有生氣能容忍我到處亂帶錯路。</p>
<p>還不小心跑到別人人家的高級住宅區，秉沅看到某個開著很帥的車子卻不太會迴轉還偷嘴了一下XD。</p>
<p>騎到動物園時，秉沅還問我說煙囪在哪裡，我突然傻住心裡想說這裡沒有煙囪阿，在下個瞬間他跟我腦袋中的<strong>長頸鹿</strong>聯想在一起了！我就說你問的是長頸鹿八，木柵焚化爐那個。</p>
<p>題外話：木柵焚化爐的煙囪，大家會講煙囪還是長頸鹿呢。</p>
<h2 id="深坑"><a href="#深坑" class="headerlink" title="深坑"></a>深坑</h2><p>後來到了深坑後，我們準備要去停車時，我差點就被機車撞，我在外線找沒有雙黃線的地方穿過對向車道時，有一個機車騎士想要加速趕快經過，結果就差點要撞上，我的 ABS 熱血開用，直接煞住，幫助了我度過這次難關，不然我還沒有跑山就要直接出局了QQ。</p>
<p>到了深坑老街後，大約是晚上 7 點，這時候許多店家已經開始休息，在我不斷地精挑細選之下，我挑到了一家<strong>豆腐娘</strong>用餐。</p>
<p>我們吃豆腐三吃、鳳梨蝦球，食物來說蠻好吃的，但有個小插曲，原先我們是點兩碗白飯，結果服務員可能看錯菜單幫我們弄了豬油飯，我想說只差 5 元就算了，我就直接吃沒關係，結果店家說沒關係就算白飯價錢就好，我原本還想說賺到了！</p>
<p>結果，後來還是給我算豬油飯的錢:)，老闆不要騙我RRR。太狠了八<br>食物還蠻不錯，臭豆腐配大腸、鴨血那道菜，我蠻喜歡吃的，大推，感覺應該可以點個豆腐捲，棄掉炸臭豆腐。下次不要點豆腐三次，點那道就好，大推！</p>
<p>吃飽完飯後，結了帳一個人大約是 270，恩有點貴的消費，不過是出來玩應該沒關係啦XD。<br>題外話：那家店的小孩讀再興中學阿QQ，讓我覺得台灣的經濟其實蠻好的嘛，只是我不再那範圍內QQ。</p>
<p>吃飽飯後，接下來在深坑老街走走，其中走到一個很懷念的古早雜貨店，都是賣些古老的食物，讓我起了懷念心，那些糖果還有再販賣，就像是在訴說我的童年時代還沒有結束，還在似的。<br>買了一個保麗龍飛機回家玩，50 元，就繼續向裡面走了。</p>
<blockquote>
<p>50元飛機帥氣滑行的樣子</p>
<div class="video-container"><iframe src="https://www.youtube.com/embed/BxI7ap5v3rQ" frameborder="0" loading="lazy" allowfullscreen></iframe></div>
</blockquote>
<p>深坑老街走完後，有一個讓孩子們嬉戲的地方，那邊還有很多深坑國小的小孩在嬉戲，有種懷念的感覺XD，之前的我也是這樣到處嬉戲到處玩，但現在有了電腦、手機，長大以後的我被冠上了一堆責任，似乎回不太去那快樂的感覺了呢。</p>
<p>那種快快樂樂，只要跑步就能讓自己感覺到幸福的時光，不會被別人比較。</p>
<h2 id="石碇、華梵大學"><a href="#石碇、華梵大學" class="headerlink" title="石碇、華梵大學"></a>石碇、華梵大學</h2><p>深坑差不多走完後，我們開始往石碇上面跑，途中剛好遇到深坑夜市，只有二、五有營業，因為剛吃飽飯所以就不太想過去逛逛，下次有機會可以去那邊逛逛，感覺那邊就很好玩，也有很多便宜又好吃的食物！讚啦。</p>
<p>石碇的路不難跑，蠻順、蠻大條的，但是因為前一天我太晚睡覺了QQ，導致我有點沒有那麼享受跑山的熱忱中，有點像是怕自己遇到車禍的感覺有點警惕XD，大約跑到了坪林與華梵大學的分界點時，我還跟秉沅說我們要不要就在這邊回去XD，他當然是不要呀。</p>
<p>我也不知道不可能在這邊妥協的，於是我就跟他一起往華梵大學跑，一路上都沒遇到甚麼車，很輕鬆，但有些大灣需要注意點，那些灣都沒有路燈必須要很認真的注意標線，不然一不小心就飛出去摟。<br>跑山也得要注意安全，在山中飛馳的感覺很心曠神怡。但也要注意安全。</p>
<p>後來我們跑到了華梵大學後，稍為在它們的機車停車場待了下，我說不如我們就進去華梵走走，秉沅還很開心地認為這裡是文化大學有很漂亮的夜景可以拍XD，我後來跟他解釋說這裡不是陽明山拉差太多了XDDDD，她顯得有點失望QQQ。</p>
<p>在上面稍微看看，探險，華梵真的好大…，而且好斗，我才走一陣子就滿身是汗了，突然對華梵的大學生們感到佩服，能夠每天都那樣爬上爬下呢，看到他們一些很高級的教學大樓就會開始覺得，北科的建築物怎麼那麼破XDDD，看看六教、看看三教，我要哭暈在廁所哦QQQQ。</p>
<p>不小心誤入了設計館，那就進去走走拉，裡面的裝潢好香，好漂亮，跟我之前進去的北科設計館怎麼感覺有點不太一樣…。沒有戰校欸，不要罵我拉QQQQ。</p>
<blockquote>
<p>華梵設計館<br><img src="https://drive.google.com/u/2/uc?id=19Uk8IU_aZ4Hd8O552YFcQ21WDPFhVTnn&export=download" alt=""></p>
</blockquote>
<p>後來到了他們的操場，他們的操場比我們的更不堪入目QQQ，他們的操場有點破爛…，向是沒有在經營一樣，也沒有人在運動，顯得十分冷清破舊，如果在這裡拍些驚悚片似乎會是個很好的選擇。</p>
<blockquote>
<p>華梵大學操場</p>
<blockquote>
<div class="video-container"><iframe src="https://www.youtube.com/embed/ttwyEM_a0UU" frameborder="0" loading="lazy" allowfullscreen></iframe></div>
</blockquote>
</blockquote>
<p>不過希望他們可以把操場改善拉，不然蜘蛛網都黏到了秉沅的頭髮上，嗚嗚。</p>
<p>稍微看完華梵後，我們就準備騎車回家，一如剛剛上來的感覺，轉彎還是都很小心，但明顯下山的時候快了更多，比上山感覺快了 10 倍呢。</p>
<p>途中還有看到一個華梵的女學生還在等華梵大學的校車回家嗎?原本還想說詢問他要不要幫忙，不過我又很怕被當作怪叔叔XDDD。好兩難阿，大衛。</p>
<p>下山的路上稍微繞了下烏塗窟，晚上沒什麼特別的，就是那邊的狗狗都很溫柔不會亂叫，讚啦，那邊的飼主都快比萬華還好啦。</p>
<h2 id="木柵"><a href="#木柵" class="headerlink" title="木柵"></a>木柵</h2><p>到了木柵後想要洗車，到了一家洗車場後發現，那家金時代自助洗車的環境好髒阿…，髒到我都不能理解，明明是要洗乾淨的地方為甚麼可以髒到用清水洗之後還有一堆淤泥在我的腳底下呢？</p>
<p>總之，非常不推木柵金時代洗車場，太髒了。不要去哪邊洗車自找苦吃，否則你的鞋子會哭出來喔。</p>
<h2 id="回程"><a href="#回程" class="headerlink" title="回程"></a>回程</h2><p>後來回程的路上，順利的輕鬆回家，在某條路上與秉沅分離，結果秉沅比我快了兩倍速度回家…，我家太偏遠了嗎QQQQ。</p>
<p>回到家的時間是 23:50，辛苦啦，大衛。</p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>這趟的體驗讓我覺得深坑很適合情侶來趟輕旅行，或許連衣服都不用帶，直接到深坑的旅館住宿，騎著機車到處逛逛，聊天談心，偶爾在小山裡面談談心、看看快樂的孩子們，不理會都市的匆忙、比較感是件很愜意的事情，你可以明顯感覺到步調變慢的氣息。</p>
<p>但也能慢慢感受到這裏要發展起來的契機，我希望深坑可以是我輕旅行的好去處，而不要成為下一個林口，這樣我剛發現的秘密基地就會化為烏有了。</p>
<p>雖然深坑我沒有接觸到很多人，但我可以感覺到這裡有一種溫暖的氣息，而不是讓我感覺到競爭的感覺。<br>改天可以再來，但我不知道下次來是甚麼時候，希望可以跟今天來的感覺一樣美好。</p>
]]></content>
      <categories>
        <category>人生旅途</category>
      </categories>
      <tags>
        <tag>大學Life</tag>
        <tag>人生旅途</tag>
      </tags>
  </entry>
  <entry>
    <title>北科資工二多媒體技術與應用 第三周作業-利用霍夫線分辨出磁磚邊緣</title>
    <url>/2021/03/26/NTUT_note/NTUTcs_MediaHW03-2/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊工程系大二下多媒體技術與應用作業紀錄<br><font color="#dd0000">並非所有人都適用，部分對我而言稍加容易的內容並不會寫在此內。</font><br><strong>這是學習後心得的筆記，可能不太適用會未來的學生</strong></p>
<p>由於我沒有學習過裡面的理論，因此這是資工大二學生透過網路與自身理解的筆記，學習價值並不高、且可能擁有大量錯誤。</p>
</blockquote>
<a id="more"></a>

<h2 id="題目如下，用圖片"><a href="#題目如下，用圖片" class="headerlink" title="題目如下，用圖片"></a>題目如下，用圖片</h2><blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1BEt75y-ClQaLMbyNiR8GJgRgBWDDiJaq&export=download" alt=""></p>
</blockquote>
<h2 id="此題作法"><a href="#此題作法" class="headerlink" title="此題作法"></a>此題作法</h2><p>考倒我了，嗚嗚。<br>我對於圖學的知識過少，還需要增加自己對於多媒體的思考能力R。</p>
<p>由於此題已經有告訴你需要用的步驟與規則如下</p>
<ul>
<li>二值化 <code>cv2.threshold</code><br>給予一數值 x，圖片中大於 x 的點都變成白色，小於的則變成黑色</li>
<li>濾波 <code>cv2.medianBlur</code><br>先進行濾波，讓縮小的圖片雜訊被模糊掉，進而讓邊緣線更清楚</li>
<li>膨脹 <code>cv2.dilate</code><br>先給予一個矩陣，如果此矩陣裡有白色的點，那所有點都變為<strong>白色</strong>，要搭配二值化此用</li>
<li>侵蝕 <code>cv2.erode</code><br>先給予一個矩陣，如果此矩陣裡有白色的點，那所有點都變為<strong>黑色</strong>，要搭配二值化此用</li>
<li>模糊 <code>cv2.medianBlur</code><br>由於有大量的反光，加上磁磚並不是完整統一顏色，難免會在縮小後造成雜訊過多，此時我們用濾波讓雜訊模糊，進而讓我們的邊緣清晰。</li>
<li>霍夫線 <code>cv2.HoughLines</code><br>他不需要一個完整的線，它可以將零碎的片段組成一條線。由於圖片擁有大量的反光，會使得磁磚邊緣不清晰，使用他就可以避免此問題，此函式有四個參數，建議一開始可以將極座標先預設為初始值<ul>
<li>image 影像</li>
<li>rho 極座標的線長度</li>
<li>theta 極座標的角度</li>
<li>threshold 超過此長度的線，才會視為是一條線，通常建議從 100 開始慢慢調整</li>
</ul>
</li>
<li>對磁磚邊緣劃線 ````cv2.line``` 進行</li>
</ul>
<p>現在我們有了這些資訊，就比較好寫程式了。</p>
<p>將資料統整後，可以得出一個結論</p>
<ul>
<li>圖片大小不可以超過 1000 像素，所以我們先 <code>cv2.resize</code></li>
<li>先進行濾波，讓縮小的圖片雜訊被模糊掉，進而讓邊緣線更清楚</li>
<li>再來進行二值化，因為如果沒有二值化後面所有東西都不能做<br>至於要在那個點做 x 化就要不斷嘗試</li>
<li>查看圖片，發現還是有一些雜訊，因此先侵蝕<br>至於要在矩陣多大就要不斷嘗試</li>
<li>侵蝕完畢後，發現磁磚縫細有點變形，在做膨脹<br>至於要在矩陣多大就要不斷嘗試</li>
<li>中間有雜訊是正常的，只要不影響霍夫線即可。</li>
<li>再來劃出霍夫線，這裡的輸出的直線座標系統是用極座標。</li>
<li>由於是極座標，因此我們要在轉換成直角座標</li>
<li>轉換完成後，使用 ````cv2.line```  劃線</li>
<li>輸出答案</li>
</ul>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="http://www.opencv.org.cn/opencvdoc/2.3.2/html/doc/tutorials/imgproc/imgtrans/hough_lines/hough_lines.html" target="_blank" rel="noopener">霍夫线变换 openCV</a><br><a href="https://stackoverflow.com/questions/51796526/how-to-draw-a-desired-line-from-houghlines-function-output-in-opencv-c" target="_blank" rel="noopener">How to draw a desired line from HoughLines function output in OpenCV C++? by stackoverflow</a><br><a href="https://blog.csdn.net/sunny2038/article/details/9253823" target="_blank" rel="noopener">OpenCV-Python教程（9、使用霍夫变换检测直线） by Daetalus</a><br><a href="https://blog.csdn.net/dcrmg/article/details/78880046" target="_blank" rel="noopener">OpenCV-Python 霍夫直线检测-HoughLinesP函数参数 by -牧野-</a><br><a href="https://www.kancloud.cn/aollo/aolloopencv/269599" target="_blank" rel="noopener">图像平滑 by OpenCV-Python 中文教程</a><br><a href="https://zh.wikipedia.org/wiki/%E6%9E%81%E5%9D%90%E6%A0%87%E7%B3%BB#%E6%9E%81%E5%9D%90%E6%A0%87%E7%B3%BB%E4%B8%8E%E5%B9%B3%E9%9D%A2%E7%9B%B4%E8%A7%92%E5%9D%90%E6%A0%87%E7%B3%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E8%AE%8A%E6%8D%A2" target="_blank" rel="noopener">極座標系 by wiki</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>原本在上課老師給的學習時間中不斷嘗試卻一直失敗，果然再不太熟的情況下想要做出一份專案是不可能的壓XD，要先透過別人的資料進行學習，從中得知能做好事的關鍵，然後我們再進行模仿，成功後再進行改良、創新。</p>
<p>謝謝郭梓琳、林紀緯的程式碼，讓我從中學習到這麼多的知識。</p>
<p>放在網路上供我知道，也讓有困難的朋友也能學習到。</p>
<h2 id="程式碼"><a href="#程式碼" class="headerlink" title="程式碼"></a>程式碼</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">"../pic/floor.jpg"</span>) <span class="comment">#輸入資料</span></span><br><span class="line">h, w, ch = img.shape <span class="comment">#圖片高、寬、通道</span></span><br><span class="line">w //= <span class="number">5</span> <span class="comment">#這樣就小於 1000</span></span><br><span class="line">h //= <span class="number">5</span></span><br><span class="line">print(h)</span><br><span class="line"></span><br><span class="line">img = cv2.resize(img, (w,h), interpolation = cv2.INTER_NEAREST)</span><br><span class="line"><span class="comment">#縮小圖片，記住這邊的 interpolation 選擇很重要，如果不確定建議可以都試試找最棒的</span></span><br><span class="line">gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</span><br><span class="line">gray = cv2.medianBlur(gray,<span class="number">1</span>) <span class="comment">#透過慮波來讓縮小的圖片雜訊被模糊掉，進而讓邊緣線清楚</span></span><br><span class="line">ret, gray = cv2.threshold(gray, <span class="number">110</span>, <span class="number">255</span>, cv2.THRESH_BINARY_INV) <span class="comment">#二值化，110 是慢慢設定的</span></span><br><span class="line"><span class="comment">#需要特別注意，由於 HoughLines 是判斷**白色**得線，但我們的磁磚邊緣線是黑色，</span></span><br><span class="line"><span class="comment">#因此我們這邊的參數要用 cv2.THRESH_BINARY_INV，這樣原本判定黑色的地方就會變白色</span></span><br><span class="line"></span><br><span class="line">gray = cv2.erode(gray, np.ones((<span class="number">2</span>,<span class="number">2</span>)), iterations=<span class="number">1</span>) <span class="comment">#侵蝕，裡面矩陣與 iterations 細調</span></span><br><span class="line">gray = cv2.dilate(gray, np.ones((<span class="number">2</span>,<span class="number">2</span>)), iterations=<span class="number">1</span>) <span class="comment">##膨脹，裡面矩陣與 iterations 細調</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#cv2.imshow("img", img)</span></span><br><span class="line">cv2.imshow(<span class="string">"gray"</span>, gray) <span class="comment">#檢查一下，有雜訊是正常的，只要不影響到霍夫線劃線都沒問題</span></span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">rho = <span class="number">1.0</span> <span class="comment">#極座標系統長度</span></span><br><span class="line">theta = np.pi / <span class="number">2</span> <span class="comment">#極座標系統角度</span></span><br><span class="line">line = cv2.HoughLines(gray, rho, theta, <span class="number">200</span>) <span class="comment">#霍夫線</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> it <span class="keyword">in</span> line: <span class="comment">#將每條線</span></span><br><span class="line">  <span class="keyword">for</span> rho, theta <span class="keyword">in</span> it: <span class="comment">#拿出每條線裡面的極座標系統</span></span><br><span class="line">    a = np.cos(theta) <span class="comment">#下面轉換成為直角坐標</span></span><br><span class="line">    b = np.sin(theta)</span><br><span class="line">    x0 = a*rho</span><br><span class="line">    y0 = b*rho</span><br><span class="line">    x1 = int(x0 + h*(-b)) <span class="comment">#由於我們要畫的線基本上是從圖片的末端開始畫，因此我們直接將畫線</span></span><br><span class="line">    y1 = int(y0 + h*(a))  <span class="comment">#長度設定為，我們圖片中最長的長度即可(通常是高)。</span></span><br><span class="line">    x2 = int(x0 - h*(-b)) <span class="comment">#這樣我們就會從圖片的末端畫到另一末端</span></span><br><span class="line">    y2 = int(y0 - h*(a))</span><br><span class="line">    cv2.line(img, (x1,y1), (x2,y2), (<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>), <span class="number">2</span>)  <span class="comment">#畫線</span></span><br><span class="line">  </span><br><span class="line">cv2.imshow(<span class="string">"result"</span>, img) </span><br><span class="line">cv2.imwrite(<span class="string">"result.jpg"</span>, img) <span class="comment">#輸出圖片</span></span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h2 id="題目資料"><a href="#題目資料" class="headerlink" title="題目資料"></a>題目資料</h2><blockquote>
<p>原始磁磚圖片<br><img src="https://drive.google.com/u/2/uc?id=1-TxaJxnexwSKXkVaYH7o6IgP7JEirC_q&export=download" alt=""></p>
</blockquote>
<blockquote>
<p>灰階、濾波、二值化、膨脹、侵蝕後的圖片<br><img src="https://drive.google.com/u/2/uc?id=1Tu_KEjTqWMuwSw7AgX5dkc-1-AHozRLF&export=download" alt=""></p>
</blockquote>
<blockquote>
<p>答案<br><img src="https://drive.google.com/u/2/uc?id=1X-DH61BFUjDlNghM81X6NpP1ENiaIyNe&export=download" alt=""></p>
</blockquote>
]]></content>
      <categories>
        <category>北科上課筆記</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>多媒體技術與應用筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>北科資工二多媒體技術與應用 第三周作業-辨識硬幣種類</title>
    <url>/2021/03/26/NTUT_note/NTUTcs_MediaHW03-1/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊工程系大二下多媒體技術與應用作業紀錄<br><font color="#dd0000">並非所有人都適用，部分對我而言稍加容易的內容並不會寫在此內。</font><br><strong>這是學習後心得的筆記，可能不太適用會未來的學生</strong></p>
<p>由於我沒有學習過裡面的理論，因此這是資工大二學生透過網路與自身理解的筆記，學習價值並不高、且可能擁有大量錯誤。</p>
</blockquote>
<a id="more"></a>

<h2 id="題目如下，用圖片"><a href="#題目如下，用圖片" class="headerlink" title="題目如下，用圖片"></a>題目如下，用圖片</h2><blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1lEe2RtCYO2evvuoq9UGdWbQrVn5u5Lvc&export=download" alt=""></p>
</blockquote>
<h2 id="此題作法"><a href="#此題作法" class="headerlink" title="此題作法"></a>此題作法</h2><p>此題與<a href="https://theriseofdavid.github.io/2021/03/26/NTUT_note/NTUTcs_MediaHW03-3/" target="_blank" rel="noopener">北科資工二多媒體技術與應用 第三周作業-辨識硬幣與鈔票種類</a>大部分相同。<br>不一樣的部分是此題判斷硬幣是用<strong>長度</strong>來判斷，因為硬幣長寬都會相同。</p>
<p>考倒我了，嗚嗚。<br>我對於圖學的知識過少，還需要增加自己對於多媒體的思考能力R。</p>
<p>由於此題已經有告訴你需要用的步驟與規則如下</p>
<ul>
<li>二值化 <code>cv2.threshold</code><br>給予一數值 x，圖片中大於 x 的點都變成白色，小於的則變成黑色</li>
<li>膨脹 <code>cv2.dilate</code><br>先給予一個矩陣，如果此矩陣裡有白色的點，那所有點都變為<strong>白色</strong>，要搭配二值化此用</li>
<li>侵蝕 <code>cv2.erode</code><br>先給予一個矩陣，如果此矩陣裡有白色的點，那所有點都變為<strong>黑色</strong>，要搭配二值化此用</li>
<li>連通物件 <code>cv2.connectedComponentsWithStats</code>，<code>connectivity=4</code> 時表示判斷區塊的方式是上下左右，<code>connectivity=4</code> 時是上下左右加上左上、左下、右下、右上。<br>幫你找出圖片中的所有白色區塊，會給出四個回傳值。<ul>
<li>num_labels 有多少區塊</li>
<li>labels 透過矩陣表示區塊</li>
<li>stats 是一個陣列，依序是 x座標、y座標、長、寬、面積，面積以像素為單位</li>
<li>centroids 區塊的中心點</li>
</ul>
</li>
<li>圖片大小不可以超過 1000 像素，透過 <code>cv2.resize</code> 進行</li>
<li>對硬幣畫線，透過 ````cv2.rectangle``` 進行</li>
</ul>
<p>現在我們有了這些資訊，就比較好畫圖了。</p>
<p>將資料統整後，可以得出一個結論</p>
<ul>
<li>圖片大小不可以超過 1000 像素，所以我們先 <code>cv2.resize</code></li>
<li>再來進行二值化，因為如果沒有二值化後面所有東西都不能做<br>至於要在那個點做 x 化就要不斷嘗試</li>
<li>查看圖片，發現還是有很多<strong>白點</strong>散布在硬幣的旁邊，因此先侵蝕<br>至於要在矩陣多大就要不斷嘗試</li>
<li>侵蝕完畢後，發現硬幣的邊界有點變形，在做膨脹<br>至於要在矩陣多大就要不斷嘗試</li>
<li>再來連通物件，<code>print(stat)</code><br>發現有很多圓形，我們先對全部的區塊畫線，檢查有沒有硬幣沒有被畫到，或太偏差，有就在回前幾步重新嘗試</li>
<li>確認沒有後，將每種硬幣畫線<br>不斷找出每種硬幣的寬度是多少，以此為依據畫線。</li>
<li>輸出答案</li>
</ul>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p>提供我所用到的連結<br><a href="https://www.kancloud.cn/aollo/aolloopencv/260982" target="_blank" rel="noopener">OpenCV中的绘图函数 by OpenCV-Python 中文教程</a><br><a href="https://answers.opencv.org/question/115770/error-could-not-find-a-writer/" target="_blank" rel="noopener">Error could not find a writer by OpenCV</a><br><a href="https://blog.csdn.net/JNingWei/article/details/78218837" target="_blank" rel="noopener">opencv: 图像缩放(cv2.resize) by JNingWei</a><br><a href="https://stackoverflow.com/questions/35854197/how-to-use-opencvs-connected-components-with-stats-in-python" target="_blank" rel="noopener">How to use openCV’s connected components with stats in python? by stackoverflow</a><br><a href="https://shengyu7697.github.io/blog/2020/04/04/Python-OpenCV-rectangle/" target="_blank" rel="noopener">[Python+OpenCV] 畫矩形 rectangle by ShengYu Talk</a><br><a href="https://www.rapidtables.com/web/color/orange-color.html" target="_blank" rel="noopener">Orange Color Code by RapidTables</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>原本在上課老師給的學習時間中不斷嘗試卻一直失敗，果然再不太熟的情況下想要做出一份專案是不可能的壓XD，要先透過別人的資料進行學習，從中得知能做好事的關鍵，然後我們再進行模仿，成功後再進行改良、創新。</p>
<p>謝謝郭梓琳、林紀緯的程式碼，讓我從中學習到這麼多的知識。</p>
<p>放在網路上供我知道，也讓有困難的朋友也能學習到。</p>
<h2 id="程式碼"><a href="#程式碼" class="headerlink" title="程式碼"></a>程式碼</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">"../pic/coin.jpg"</span>) <span class="comment">#輸入資料</span></span><br><span class="line">h, w, ch = img.shape <span class="comment">#圖片高、寬、通道</span></span><br><span class="line"></span><br><span class="line">img = cv2.resize(img, (w//<span class="number">5</span>, h//<span class="number">5</span>), interpolation=cv2.INTER_NEAREST) <span class="comment">#important</span></span><br><span class="line"><span class="comment">#縮小圖片，記住這邊的 interpolation 選擇很重要，如果不確定建議可以都試試找最棒的</span></span><br><span class="line"></span><br><span class="line">gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) <span class="comment">#灰階化，方便閱讀</span></span><br><span class="line">ret, gray = cv2.threshold(gray, <span class="number">90</span>, <span class="number">255</span>, cv2.THRESH_BINARY) <span class="comment">#二值化，90 是慢慢設定的</span></span><br><span class="line"></span><br><span class="line">gray = cv2.erode(gray, np.ones((<span class="number">2</span>,<span class="number">2</span>)), iterations=<span class="number">2</span>) <span class="comment">#侵蝕，裡面矩陣與 iterations 細調</span></span><br><span class="line">gray = cv2.dilate(gray, np.ones((<span class="number">2</span>,<span class="number">2</span>)), iterations=<span class="number">1</span>) <span class="comment">#膨脹，裡面矩陣與 iterations 細調</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#連通物件，設八通道這樣才嚴謹</span></span><br><span class="line">num_labels, labels, stats, centroids = cv2.connectedComponentsWithStats(gray, connectivity=<span class="number">8</span>)</span><br><span class="line">print(stats)  <span class="comment">#檢查所有區塊</span></span><br><span class="line"></span><br><span class="line">ans = <span class="number">0</span> <span class="comment">#輸出多少錢</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> it <span class="keyword">in</span> stats:</span><br><span class="line">  itX = it[<span class="number">0</span>]+it[<span class="number">2</span>] <span class="comment">#寬度</span></span><br><span class="line">  itY = it[<span class="number">1</span>]+it[<span class="number">3</span>] <span class="comment">#高度</span></span><br><span class="line">  <span class="comment">#cv2.rectangle(img, (it[0], it[1]), (itX, itY), (200, 31, 31), 2)</span></span><br><span class="line">  <span class="comment">#一開始可以使用，這樣她會畫出所有的區塊來讓你判斷有沒有區塊沒畫到或連在一起</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">#下面的長度是我自己去慢慢調整出來得</span></span><br><span class="line">  <span class="keyword">if</span>(it[<span class="number">2</span>] &gt;= <span class="number">60</span> <span class="keyword">and</span> it[<span class="number">2</span>] &lt; <span class="number">75</span>): <span class="comment">#1 dallars</span></span><br><span class="line">    cv2.rectangle(img, (it[<span class="number">0</span>], it[<span class="number">1</span>]), (itX, itY), (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>) <span class="comment">#BGR </span></span><br><span class="line">    ans += <span class="number">1</span></span><br><span class="line">  <span class="keyword">if</span>(it[<span class="number">2</span>] &gt;= <span class="number">75</span> <span class="keyword">and</span> it[<span class="number">2</span>] &lt; <span class="number">90</span>): <span class="comment">#5 dallars</span></span><br><span class="line">    cv2.rectangle(img, (it[<span class="number">0</span>], it[<span class="number">1</span>]), (itX, itY), (<span class="number">0</span>, <span class="number">165</span>, <span class="number">255</span>), <span class="number">2</span>) <span class="comment">#BGR</span></span><br><span class="line">    ans += <span class="number">5</span></span><br><span class="line">  <span class="keyword">if</span>(it[<span class="number">2</span>] &gt;= <span class="number">90</span> <span class="keyword">and</span> it[<span class="number">2</span>] &lt; <span class="number">100</span>): <span class="comment">#10 dallars</span></span><br><span class="line">    cv2.rectangle(img, (it[<span class="number">0</span>], it[<span class="number">1</span>]), (itX, itY), (<span class="number">0</span>, <span class="number">255</span>, <span class="number">255</span>), <span class="number">2</span>) <span class="comment">#BGR </span></span><br><span class="line">    ans += <span class="number">10</span></span><br><span class="line">  <span class="keyword">if</span>(it[<span class="number">2</span>] &gt;= <span class="number">100</span> <span class="keyword">and</span> it[<span class="number">2</span>] &lt; <span class="number">115</span>): <span class="comment">#50 dallars  </span></span><br><span class="line">    cv2.rectangle(img, (it[<span class="number">0</span>], it[<span class="number">1</span>]), (itX, itY), (<span class="number">0</span>, <span class="number">128</span>, <span class="number">0</span>), <span class="number">2</span>) <span class="comment">#BGR</span></span><br><span class="line">    ans += <span class="number">50</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#cv2.imshow("gray", gray) </span></span><br><span class="line">print(<span class="string">"圖上共有 "</span>,ans ,<span class="string">"元"</span>) <span class="comment">#輸出答案 </span></span><br><span class="line">cv2.imshow(<span class="string">"img"</span>, img)</span><br><span class="line">cv2.imwrite(<span class="string">'ans.jpg'</span>, img)</span><br><span class="line">cv2.imwrite(<span class="string">'gray.jpg'</span>, gray)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h2 id="題目資料"><a href="#題目資料" class="headerlink" title="題目資料"></a>題目資料</h2><blockquote>
<p>硬幣圖片<br><img src="https://drive.google.com/u/2/uc?id=10EYpWRfu1TKoubjH7bA8B_aOIHdp98Ya&export=download" alt=""></p>
</blockquote>
<blockquote>
<p>灰階、二值化、膨脹、侵蝕後的圖片<br><img src="https://drive.google.com/u/2/uc?id=1VbVqubPimrhY6L-oMpluUlIMLsRJTQi3&export=download" alt=""></p>
</blockquote>
<blockquote>
<p>答案<br><img src="https://drive.google.com/u/2/uc?id=1-rSxkBPoqHoPPJjz0rv6UVLU6_Eyl3yv&export=download" alt=""></p>
</blockquote>
]]></content>
      <categories>
        <category>北科上課筆記</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>多媒體技術與應用筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>北科資工二多媒體技術與應用 第三周作業-辨識硬幣與鈔票種類</title>
    <url>/2021/03/26/NTUT_note/NTUTcs_MediaHW03-3/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊工程系大二下多媒體技術與應用作業紀錄<br><font color="#dd0000">並非所有人都適用，部分對我而言稍加容易的內容並不會寫在此內。</font><br><strong>這是學習後心得的筆記，可能不太適用會未來的學生</strong></p>
<p>由於我沒有學習過裡面的理論，因此這是資工大二學生透過網路與自身理解的筆記，學習價值並不高、且可能擁有大量錯誤。</p>
</blockquote>
<a id="more"></a>

<h2 id="題目如下，用圖片"><a href="#題目如下，用圖片" class="headerlink" title="題目如下，用圖片"></a>題目如下，用圖片</h2><blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1nWyLdcpQvoDLLxjXmacD9n4ivtXB2Y9T&export=download" alt=""></p>
</blockquote>
<p>由於題目沒有說 1000元要用甚麼顏色，我就用白色</p>
<h2 id="此題作法"><a href="#此題作法" class="headerlink" title="此題作法"></a>此題作法</h2><p>此題與<a href="https://theriseofdavid.github.io/2021/03/26/NTUT_note/NTUTcs_MediaHW03-1/" target="_blank" rel="noopener">北科資工二多媒體技術與應用 第三周作業-辨識硬幣種類</a>大部分相同。<br>不一樣的部分是此題判斷硬幣與紙鈔是用<strong>面積</strong>來判斷，因為題目紙鈔有橫者放、直者放，所以要用面積。</p>
<p>考倒我了，嗚嗚。<br>我對於圖學的知識過少，還需要增加自己對於多媒體的思考能力R。</p>
<p>由於此題已經有告訴你需要用的步驟與規則如下</p>
<ul>
<li>二值化 ````cv2.threshold```<br>給予一數值 x，圖片中大於 x 的點都變成白色，小於的則變成黑色</li>
<li>膨脹 <code>cv2.dilate</code><br>先給予一個矩陣，如果此矩陣裡有白色的點，那所有點都變為<strong>白色</strong>，要搭配二值化此用</li>
<li>侵蝕 <code>cv2.erode</code><br>先給予一個矩陣，如果此矩陣裡有白色的點，那所有點都變為<strong>黑色</strong>，要搭配二值化此用</li>
<li>連通物件 <code>cv2.connectedComponentsWithStats</code>，<code>connectivity=4</code> 時表示判斷區塊的方式是上下左右，<code>connectivity=4</code> 時是上下左右加上左上、左下、右下、右上。<br>幫你找出圖片中的所有白色區塊，會給出四個回傳值。<ul>
<li>num_labels 有多少區塊</li>
<li>labels 透過矩陣表示區塊</li>
<li>stats 是一個陣列，依序是 x座標、y座標、長、寬、面積，面積以像素為單位</li>
<li>centroids 區塊的中心點</li>
</ul>
</li>
<li>圖片大小不可以超過 1000 像素，透過 <code>cv2.resize</code> 進行</li>
<li>對硬幣與鈔票畫線，透過 ````cv2.rectangle``` 進行</li>
</ul>
<p>現在我們有了這些資訊，就比較好畫圖了。</p>
<p>將資料統整後，可以得出一個結論</p>
<ul>
<li>圖片大小不可以超過 1000 像素，所以我們先 <code>cv2.resize</code></li>
<li>再來進行二值化，因為如果沒有二值化後面所有東西都不能做<br>至於要在那個點做 x 化就要不斷嘗試</li>
<li>查看圖片，發現還是有很多<strong>白點</strong>散布在硬幣與鈔票的旁邊，因此先侵蝕<br>至於要在矩陣多大就要不斷嘗試</li>
<li>侵蝕完畢後，發現硬幣與鈔票的邊界有點變形，在做膨脹<br>至於要在矩陣多大就要不斷嘗試</li>
<li>再來連通物件，<code>print(stat)</code><br>發現有很多圓形，我們先對全部的區塊畫線，檢查有沒有硬幣與鈔票沒有被畫到，或太偏差，有就在回前幾步重新嘗試</li>
<li>確認沒有後，將每種硬幣與鈔票畫線<br>不斷找出每種硬幣與鈔票的寬度是多少，以此為依據畫線。</li>
<li>輸出答案</li>
</ul>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p>提供我所用到的連結<br><a href="https://www.kancloud.cn/aollo/aolloopencv/260982" target="_blank" rel="noopener">OpenCV中的绘图函数 by OpenCV-Python 中文教程</a><br><a href="https://answers.opencv.org/question/115770/error-could-not-find-a-writer/" target="_blank" rel="noopener">Error could not find a writer by OpenCV</a><br><a href="https://blog.csdn.net/JNingWei/article/details/78218837" target="_blank" rel="noopener">opencv: 图像缩放(cv2.resize) by JNingWei</a><br><a href="https://stackoverflow.com/questions/35854197/how-to-use-opencvs-connected-components-with-stats-in-python" target="_blank" rel="noopener">How to use openCV’s connected components with stats in python? by stackoverflow</a><br><a href="https://shengyu7697.github.io/blog/2020/04/04/Python-OpenCV-rectangle/" target="_blank" rel="noopener">[Python+OpenCV] 畫矩形 rectangle by ShengYu Talk</a><br><a href="https://www.rapidtables.com/web/color/orange-color.html" target="_blank" rel="noopener">Orange Color Code by RapidTables</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>原本在上課老師給的學習時間中不斷嘗試卻一直失敗，果然再不太熟的情況下想要做出一份專案是不可能的壓XD，要先透過別人的資料進行學習，從中得知能做好事的關鍵，然後我們再進行模仿，成功後再進行改良、創新。</p>
<p>謝謝郭梓琳、林紀緯的程式碼，讓我從中學習到這麼多的知識。</p>
<p>放在網路上供我知道，也讓有困難的朋友也能學習到。</p>
<p>題外話，這題的 500 元紙鈔是比 100 元的紙鈔還大的喔，我有用 PS 檢查過</p>
<ul>
<li>500 元紙鈔長 29.7、高 55.5，單位 cm，面積為 1768.635</li>
<li>100 元紙鈔長 60.82、高 28.58，單位 cm，面積為 1738.2356</li>
</ul>
<p>不要在寫程式的過程中誤以為 100 元的紙鈔比較大喔XD。</p>
<p>寫了好多 IF，好髒阿QQQ。</p>
<p>重新調整適合的參數位置，二值化、侵蝕、膨脹也是花了我好多時間QQ，圖像也是個大學問。</p>
<p>還有判斷是哪個硬幣也花我很多時間！一開始我是先用寬度來進行判斷，發現紙鈔有一張跟其他擺法不同，後來改用 <code>stat[4]</code> 來解，結果發現跟一般邏輯不同，100 元比 500 元大，1000 元最小，後來才意識到紙鈔的區塊可不一定裡面都沒有區塊阿，也就是可能 100 元的區塊裡面還有一些雜訊，因此 <code>stat[4]</code> 的面積可能就會因此縮小，就因為這樣，才會導致100 元比 500 元大，1000 元最小的問題。<br>因此要自己用長寬相乘的面積就可以忽略掉雜訊的問題，因此要自己相乘</p>
<blockquote>
<p>例如 100 元的區塊中，裡面有雜訊(黑色區塊)此時區塊的面積就會剪掉他。<br><img src="https://drive.google.com/u/2/uc?id=1gOMVelQZr7REcu1KWw0e9FlSKTzezYD6&export=download" alt=""></p>
</blockquote>
<p>總之，這讓我學了很多，算開心八XD。</p>
<h2 id="程式碼"><a href="#程式碼" class="headerlink" title="程式碼"></a>程式碼</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">"../pic/coin2.jpg"</span>) <span class="comment">#輸入資料</span></span><br><span class="line">h, w, ch = img.shape  <span class="comment">#圖片高、寬、通道</span></span><br><span class="line"></span><br><span class="line">img = cv2.resize(img, (w//<span class="number">5</span>, h//<span class="number">5</span>), interpolation=cv2.INTER_NEAREST) <span class="comment">#important</span></span><br><span class="line"><span class="comment">#縮小圖片，記住這邊的 interpolation 選擇很重要，如果不確定建議可以都試試找最棒的</span></span><br><span class="line"></span><br><span class="line">gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)  <span class="comment">#灰階化，方便閱讀</span></span><br><span class="line">ret, gray = cv2.threshold(gray, <span class="number">45</span>, <span class="number">255</span>, cv2.THRESH_BINARY) <span class="comment">#二值化，45 是慢慢設定的</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">gray = cv2.erode(gray, np.ones((<span class="number">3</span>,<span class="number">3</span>)), iterations=<span class="number">3</span>) <span class="comment">#侵蝕，裡面矩陣與 iterations 細調</span></span><br><span class="line">gray = cv2.dilate(gray, np.ones((<span class="number">3</span>,<span class="number">3</span>)), iterations=<span class="number">2</span>) <span class="comment">#膨脹，裡面矩陣與 iterations 細調</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#連通物件，設八通道這樣才嚴謹</span></span><br><span class="line">num_labels, labels, stats, centroids = cv2.connectedComponentsWithStats(gray, connectivity=<span class="number">8</span>)</span><br><span class="line">print(stats) <span class="comment">#檢查所有區塊</span></span><br><span class="line"></span><br><span class="line">ans = <span class="number">0</span> <span class="comment">#輸出多少錢</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> it <span class="keyword">in</span> stats:</span><br><span class="line">  itX = it[<span class="number">0</span>]+it[<span class="number">2</span>] <span class="comment">#寬度</span></span><br><span class="line">  itY = it[<span class="number">1</span>]+it[<span class="number">3</span>] <span class="comment">#高度</span></span><br><span class="line">  itArea = it[<span class="number">2</span>]*it[<span class="number">3</span>] <span class="comment">#面積，忽略掉區塊內雜訊</span></span><br><span class="line">  print(itArea)  <span class="comment">#可以第一次執行時先印出面積，比較容易在下面 if 的參數做微調</span></span><br><span class="line"><span class="comment">#  cv2.rectangle(img, (it[0], it[1]), (itX, itY), (200, 31, 31), 2)</span></span><br><span class="line"><span class="comment">#一開始可以使用，這樣她會畫出所有的區塊來讓你判斷有沒有區塊沒畫到或連在一起</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(itArea &gt;= <span class="number">1600</span> <span class="keyword">and</span> itArea &lt; <span class="number">2000</span>): <span class="comment">#1 dallars</span></span><br><span class="line">    cv2.rectangle(img, (it[<span class="number">0</span>], it[<span class="number">1</span>]), (itX, itY), (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>) <span class="comment">#BGR </span></span><br><span class="line">    ans += <span class="number">1</span></span><br><span class="line">  <span class="keyword">if</span>(itArea &gt;= <span class="number">2000</span> <span class="keyword">and</span> itArea &lt; <span class="number">2400</span>): <span class="comment">#5 dallars</span></span><br><span class="line">    cv2.rectangle(img, (it[<span class="number">0</span>], it[<span class="number">1</span>]), (itX, itY), (<span class="number">0</span>, <span class="number">165</span>, <span class="number">255</span>), <span class="number">2</span>) <span class="comment">#BGR</span></span><br><span class="line">    ans += <span class="number">5</span></span><br><span class="line">  <span class="keyword">if</span>(itArea &gt;= <span class="number">3000</span> <span class="keyword">and</span> itArea &lt; <span class="number">3400</span>): <span class="comment">#10 dallars</span></span><br><span class="line">    cv2.rectangle(img, (it[<span class="number">0</span>], it[<span class="number">1</span>]), (itX, itY), (<span class="number">0</span>, <span class="number">255</span>, <span class="number">255</span>), <span class="number">2</span>) <span class="comment">#BGR </span></span><br><span class="line">    ans += <span class="number">10</span></span><br><span class="line">  <span class="keyword">if</span>(itArea &gt;= <span class="number">3600</span> <span class="keyword">and</span> itArea &lt; <span class="number">4100</span>): <span class="comment">#50 dallars  </span></span><br><span class="line">    cv2.rectangle(img, (it[<span class="number">0</span>], it[<span class="number">1</span>]), (itX, itY), (<span class="number">0</span>, <span class="number">128</span>, <span class="number">0</span>), <span class="number">2</span>) <span class="comment">#BGR</span></span><br><span class="line">    ans += <span class="number">50</span></span><br><span class="line">  <span class="keyword">if</span>(itArea &gt;= <span class="number">55000</span> <span class="keyword">and</span> itArea &lt; <span class="number">57000</span>): <span class="comment">#100 dallars</span></span><br><span class="line">    cv2.rectangle(img, (it[<span class="number">0</span>], it[<span class="number">1</span>]), (itX, itY), (<span class="number">200</span>, <span class="number">31</span>, <span class="number">31</span>), <span class="number">2</span>)</span><br><span class="line">    ans += <span class="number">100</span></span><br><span class="line">  <span class="keyword">if</span>(itArea &gt;= <span class="number">53000</span> <span class="keyword">and</span> itArea &lt; <span class="number">55000</span>): <span class="comment">#500 dallars</span></span><br><span class="line">    cv2.rectangle(img, (it[<span class="number">0</span>], it[<span class="number">1</span>]), (itX, itY), (<span class="number">128</span>, <span class="number">0</span>, <span class="number">128</span>), <span class="number">2</span>)</span><br><span class="line">    ans += <span class="number">500</span></span><br><span class="line">  <span class="keyword">if</span>(itArea &gt;= <span class="number">57000</span> <span class="keyword">and</span> itArea &lt; <span class="number">59000</span>): <span class="comment">#1000 dallars</span></span><br><span class="line">    cv2.rectangle(img, (it[<span class="number">0</span>], it[<span class="number">1</span>]), (itX, itY), (<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>), <span class="number">2</span>)</span><br><span class="line">    ans += <span class="number">1000</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">"圖上共有 "</span>,ans ,<span class="string">"元"</span>)</span><br><span class="line">cv2.imshow(<span class="string">"gray"</span>, gray)  </span><br><span class="line">cv2.imshow(<span class="string">"img"</span>, img)</span><br><span class="line"></span><br><span class="line">cv2.imwrite(<span class="string">'ans3-3.jpg'</span>, img)</span><br><span class="line">cv2.imwrite(<span class="string">'gray3-3.jpg'</span>, gray)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h2 id="題目資料"><a href="#題目資料" class="headerlink" title="題目資料"></a>題目資料</h2><blockquote>
<p>硬幣圖片<br><img src="https://drive.google.com/u/2/uc?id=15ihSlBXOj1UWsNgM-TPeEIaz3uCGLFU6&export=download" alt=""></p>
</blockquote>
<blockquote>
<p>灰階、二值化、膨脹、侵蝕後的圖片<br><img src="https://drive.google.com/u/2/uc?id=1VaSFxZGCx8INaK4mpKlhi74IwelDR64C&export=download" alt=""></p>
</blockquote>
<blockquote>
<p>答案<br><img src="https://drive.google.com/u/2/uc?id=1gw8bCt_F1GhTp4QS_QRki0JQ8Dg8JztR&export=download" alt=""></p>
</blockquote>
]]></content>
      <categories>
        <category>北科上課筆記</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>多媒體技術與應用筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>北科資工二多媒體技術與應用 第三周作業-影像金字塔混和圖片</title>
    <url>/2021/03/25/NTUT_note/NTUTcs_MediaHW03-4/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊工程系大二下多媒體技術與應用作業紀錄<br><font color="#dd0000">並非所有人都適用，部分對我而言稍加容易的內容並不會寫在此內。</font><br><strong>這是學習後心得的筆記，可能不太適用會未來的學生</strong></p>
<p>由於我沒有學習過裡面的理論，因此這是資工大二學生透過網路與自身理解的筆記，學習價值並不高、且可能擁有大量錯誤。</p>
</blockquote>
<a id="more"></a>

<h2 id="題目如下，用圖片"><a href="#題目如下，用圖片" class="headerlink" title="題目如下，用圖片"></a>題目如下，用圖片</h2><blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1y5bEeELIz9zY-7gTMm36t5jzdDvNBsuX&export=download" alt=""></p>
</blockquote>
<h2 id="此題做法"><a href="#此題做法" class="headerlink" title="此題做法"></a>此題做法</h2><p>這是一題很酷的題目，你會學到<strong>影像金字塔</strong>。</p>
<h3 id="甚麼是影像金字塔"><a href="#甚麼是影像金字塔" class="headerlink" title="甚麼是影像金字塔"></a>甚麼是影像金字塔</h3><p>影像金字塔透過將圖片放大縮小，而越將圖片放大就是越底層的金字塔，縮小就是越下層的金字塔，跟金字塔的切面面積有關。</p>
<h4 id="高斯金字塔"><a href="#高斯金字塔" class="headerlink" title="高斯金字塔"></a>高斯金字塔</h4><p>透過<a href="https://zknie.com/knowledge_base/opencv%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B06-%E5%9B%BE%E5%83%8F%E9%87%91%E5%AD%97%E5%A1%94/2020/11/02/" target="_blank" rel="noopener">公式</a>得出，不斷地使用此公式進行放大或縮小，結果如下</p>
<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1bGdBBCPh5LHf_YtGeq0s9IjAf-YaHODg&export=download" alt=""><br><a href="https://zknie.com/knowledge_base/opencv%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B06-%E5%9B%BE%E5%83%8F%E9%87%91%E5%AD%97%E5%A1%94/2020/11/02/" target="_blank" rel="noopener">蒙面西红柿取得，如果有需要移除請跟我說</a></p>
</blockquote>
<p>但有個特別重要的重點，<strong>沒有辦法用縮小後的圖片完整還原放大的圖片</strong>，很多點被壓縮，要還原也不知道要怎麼還原，因此是縮小的圖片不斷放大就會越來越模糊</p>
<h4 id="拉普拉斯金字塔"><a href="#拉普拉斯金字塔" class="headerlink" title="拉普拉斯金字塔"></a>拉普拉斯金字塔</h4><p>必須先建立高斯金字塔才能建立拉普拉斯金字塔。</p>
<p>此方法主要是對同樣大小的高斯金字塔，進行操作，其操作方式如下</p>
<ul>
<li>將原始圖片設為最底層的金字塔</li>
<li>設定要縮小的次數</li>
<li>記錄每層高斯金字塔的縮小</li>
<li>將上一層的高斯金字塔放大後與當前圖層進行圖片減法，從最上層開始，也就是圖片 size 最小的地方</li>
</ul>
<p>透過此方式將高斯金字塔上一次的縮小進行放大後在跟當前的圖層進行圖片減法，所遺失的點就是拉普拉斯金字塔</p>
<blockquote>
<p>圖片說明<br><img src="https://drive.google.com/u/2/uc?id=1RwskzYpTpXW23cKn1U4OAbb9xBgZUkAV&export=download" alt=""><br><a href="https://zknie.com/knowledge_base/opencv%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B06-%E5%9B%BE%E5%83%8F%E9%87%91%E5%AD%97%E5%A1%94/2020/11/02/" target="_blank" rel="noopener">蒙面西红柿取得，如果有需要移除請跟我說</a></p>
</blockquote>
<h3 id="回歸解法"><a href="#回歸解法" class="headerlink" title="回歸解法"></a>回歸解法</h3><p>說了這麼多，該來了解這題怎麼做了。</p>
<p>拉普拉斯金字塔是高斯金字塔放大所遺失的點，這時我們可以透過拉普拉斯金字塔來補足這些遺失的點，理論上可以回到離圖片一樣的狀態。</p>
<p>但是在高斯金字塔再放大時，可不知道拉普拉斯金字塔會補足哪些點，所以會一視同仁地把點放大。此時再加上拉普拉斯金字塔的點後(進行圖片相減)，此時那些地方就會被中和成高斯金字塔的放大點與拉普拉斯金字塔地點，達到平滑的效果，就可以讓圖片切割的地方看起來更加圓滑。</p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://blog.csdn.net/weixin_45668655/article/details/103889235" target="_blank" rel="noopener">opencv-图像融合（高斯金字塔，拉普拉斯金字塔） by Bonjour_Amy</a><br><a href="https://blog.csdn.net/u012609509/article/details/70319293" target="_blank" rel="noopener">np.vstack, np.hstack by cltdevelop</a><br><a href="https://zknie.com/knowledge_base/opencv%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B06-%E5%9B%BE%E5%83%8F%E9%87%91%E5%AD%97%E5%A1%94/2020/11/02/" target="_blank" rel="noopener">OpenCV学习笔记(6)——图像金字塔 by 蒙面西红柿</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>學習到了圖像金字塔是本題的最大收穫，要謝謝郭梓琳給我一個網頁裡面有教我怎麼做QQQ，不然我應該還要花很多時間才能把這題給解開、搞懂。</p>
<p>總之，很開心有他這個隊友，讚啦。<br>希望他可以容忍這麼不成材我的XD，愛睡覺又很拖拉。</p>
<h2 id="程式碼"><a href="#程式碼" class="headerlink" title="程式碼"></a>程式碼</h2><p>我們這邊製作六成的圖像金字塔，就能做出與題目答案類似的金字塔。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Created on Thu Mar 25 11:28:28 2021</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">@author: user</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment">#讀圖片檔案，下面會放題目所需要的圖片</span></span><br><span class="line">a = cv2.imread(<span class="string">"./pic/apple.jpg"</span>)</span><br><span class="line">b = cv2.imread(<span class="string">"./pic/orange.jpg"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#目標是圖片合併，因此我們先建兩個高斯金字塔</span></span><br><span class="line">gaussA = [a.copy()]</span><br><span class="line">gaussB = [b.copy()]</span><br><span class="line">copyA = a.copy()</span><br><span class="line">copyB = b.copy()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6</span>): <span class="comment"># more small</span></span><br><span class="line">  copyA = cv2.pyrDown(copyA) <span class="comment">#縮小，建立金字塔上層</span></span><br><span class="line">  copyB = cv2.pyrDown(copyB)</span><br><span class="line">  </span><br><span class="line">  gaussA.append(copyA)</span><br><span class="line">  gaussB.append(copyB)</span><br><span class="line"></span><br><span class="line">copyA = gaussA[<span class="number">5</span>] <span class="comment">#稍微注意，拉普拉斯金字塔由於編寫方便，我們的陣列值越大時圖層越小，金字塔相反</span></span><br><span class="line">laplacianA = [copyA] <span class="comment">#建立拉普拉斯金字塔</span></span><br><span class="line">copyB = gaussB[<span class="number">5</span>]</span><br><span class="line">laplacianB = [copyB]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>, <span class="number">0</span>, <span class="number">-1</span>): <span class="comment">#建立拉普拉斯金字塔</span></span><br><span class="line">  tempA = cv2.pyrUp(gaussA[i]) <span class="comment">#將當前高斯金字塔放大</span></span><br><span class="line">  tempB = cv2.pyrUp(gaussB[i])</span><br><span class="line"></span><br><span class="line">  subA = cv2.subtract(gaussA[i<span class="number">-1</span>], tempA) <span class="comment">#放大後，在跟下一層的高斯金字塔做減法得出拉普拉斯金字塔</span></span><br><span class="line">  subB = cv2.subtract(gaussB[i<span class="number">-1</span>], tempB)</span><br><span class="line">  laplacianA.append(subA) <span class="comment">#記錄起來</span></span><br><span class="line">  laplacianB.append(subB)</span><br><span class="line">  <span class="comment">#cv2.imshow("subA", subA)</span></span><br><span class="line">  <span class="comment">#cv2.waitKey(0)</span></span><br><span class="line"></span><br><span class="line">stack = [] <span class="comment">#要被疊加的圖層放置處</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> itA, itB <span class="keyword">in</span> zip(laplacianA, laplacianB): <span class="comment">#合併兩個拉普拉斯金字塔</span></span><br><span class="line">  h, w, ch = itA.shape <span class="comment">#圖片長、寬、通道</span></span><br><span class="line">  merge = np.hstack((itA[<span class="number">0</span>:h, <span class="number">0</span>:(w // <span class="number">2</span>)], itB[<span class="number">0</span>:h, (w // <span class="number">2</span>):w])) <span class="comment">#將圖片進行合併</span></span><br><span class="line">  <span class="comment">#注意，第二張圖片是要右半邊</span></span><br><span class="line">  stack.append(merge) <span class="comment">#紀錄</span></span><br><span class="line">  </span><br><span class="line">result = stack[<span class="number">0</span>] <span class="comment">#一開使放入最頂端金字塔的圖層，特別注意第 0 層是沒有被減法過的圖層</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">6</span>): </span><br><span class="line">  result = cv2.pyrUp(result) <span class="comment">#放大圖層</span></span><br><span class="line">  result = cv2.add(result, stack[i]) <span class="comment">#疊加我們的拉普拉斯金字塔</span></span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">"a"</span>, a)</span><br><span class="line">cv2.imshow(<span class="string">"result"</span>, result) <span class="comment">#輸出完整圖片</span></span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv.imwrite(<span class="string">'result.jpg'</span>,result)</span><br></pre></td></tr></table></figure>

<h2 id="題目資料"><a href="#題目資料" class="headerlink" title="題目資料"></a>題目資料</h2><blockquote>
<p>apple<br><img src="https://drive.google.com/u/2/uc?id=1vJakdmCZuyCBbX7A3FHsIDi7K6Co5vRE&export=download" alt=""></p>
</blockquote>
<blockquote>
<p>orange<br><img src="https://drive.google.com/u/2/uc?id=1rXZ3YuzHhbMx1IfdEHkQ3ug2pvzRhWA4&export=download" alt=""></p>
</blockquote>
<blockquote>
<p>result<br><img src="https://drive.google.com/u/2/uc?id=1CtDnQ-YeOa1gd7oHSh1iIM9MZW-COc97&export=download" alt=""></p>
</blockquote>
]]></content>
      <categories>
        <category>北科上課筆記</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>多媒體技術與應用筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>統計學(二) 筆記 - 第十一章 推論母體變異數(Inference About Population Variances)</title>
    <url>/2021/03/27/NTUT_note/statistics-ch11/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊與財金管理系大二下統計學重點整理<br><font color="#dd0000">並非所有人都適用，部分對我而言稍加容易的內容並不會寫在此內。</font><br><strong>這是觀看影片心得後的筆記，老師上課可能不太適用會忘記抄到</strong></p>
</blockquote>
<a id="more"></a>

<h1 id="推論一組母體變異數-Inference-About-a-Population-Variances"><a href="#推論一組母體變異數-Inference-About-a-Population-Variances" class="headerlink" title="推論一組母體變異數(Inference About a Population Variances)"></a>推論一組母體變異數(Inference About a Population Variances)</h1><p>前一章我們對母體參數與平均數進行推論，但還需要判斷變異數是否有過大的問題，如果變異數最大有可能表示其實分布很廣，在某些情況下不太可能夠接受變異數過大的問題，例如大量製造的螺絲釘寬度假如時太大、太小，但平均數出來的值卻是剛剛好，但實際上這樣是不可行的。</p>
<p>因此要用變異數來判斷資料分布是否會過廣。</p>
<h2 id="卡方分配-Chi-Square-Distribution"><a href="#卡方分配-Chi-Square-Distribution" class="headerlink" title="卡方分配 Chi-Square Distribution"></a>卡方分配 Chi-Square Distribution</h2><p>是標準常態隨機變數次方的總和值。</p>
<p>我們可以用簡單抽樣的方式來找出變異數，變異數公式如右 \((n-1) s^2 /  \sigma^2\)，其中 \((n-1)\) 就是自由度。<br>之後我們再利用變異數(卡方分配得出)跟區間估計來做假設檢定。</p>
<ul>
<li>不懂假設統計可看<a href="https://theriseofdavid.github.io/2021/02/27/NTUT_note/statistics-ch9/" target="_blank" rel="noopener">統計學(二) 筆記 - 第九章 假說檢定(hypothesis testing)</a></li>
</ul>
<blockquote>
<p>自由度的卡方分配，越左越小<br><img src="https://drive.google.com/u/2/uc?id=1xHzXpmjrJLw8IspGsf6qzOV1fjHFFsdS&export=download" alt=""></p>
</blockquote>
<h2 id="Interval-Estimation-of-sigma-2"><a href="#Interval-Estimation-of-sigma-2" class="headerlink" title="Interval Estimation of \(\sigma^2 \)"></a>Interval Estimation of \(\sigma^2 \)</h2><blockquote>
<p>區間估計的示意圖<br><img src="https://drive.google.com/u/2/uc?id=16gKYJqMMApIvAQ3QGoYIE-yiB3DeT6Ue&export=download" alt=""></p>
</blockquote>
<ul>
<li>下面所有的 \(X^2\) 指的都是方分配的變異數</li>
<li>因此我們會有 \(1-a\) 的機率 \(X^2\) 的值會落在 \(X^2_{1-a/2} \leq X^2 \leq X^2_{a/2}\)</li>
<li>再來我們把變異數公式 \((n-1) s^2 /  \sigma^2\) 帶入 \(X^2\) 就變成 \(X^2_{1-a/2} \leq \frac{(n-1) s^2}{\sigma^2} \leq  X^2_{a/2}\)</li>
<li>稍微移項(倒數)後就變成 \(\frac{(n-1) s^2}{X^2_{a/2}} \leq \sigma^2 \leq \frac{(n-1) s^2}{X^2_{1-a/2}} \)</li>
<li>因此母體變異數區間估計就是 \(\frac{(n-1) s^2}{X^2_{a/2}} \leq \sigma^2 \leq \frac{(n-1) s^2}{X^2_{1-a/2}} \)，其中\(n-1\)就是自由度</li>
</ul>
<p>那如果我們要找出母體標準差的區間估計呢？<br>就將剛剛的最後的式子開根號即可 \(\sqrt{\frac{(n-1) s^2}{X^2_{a/2}}} \leq \sigma \leq \sqrt{\frac{(n-1) s^2}{X^2_{1-a/2}}} \)</p>
<h3 id="舉例：我們想要購買-A-廠商的恆溫器，我們在一個調查中得知，當在一個房間裡面設定-68度F-時，10-個恆溫器的實際數值如下，我們想要知道在百分之-95-的信心水準中母體變異數的區間估計是多少？"><a href="#舉例：我們想要購買-A-廠商的恆溫器，我們在一個調查中得知，當在一個房間裡面設定-68度F-時，10-個恆溫器的實際數值如下，我們想要知道在百分之-95-的信心水準中母體變異數的區間估計是多少？" class="headerlink" title="舉例：我們想要購買 A 廠商的恆溫器，我們在一個調查中得知，當在一個房間裡面設定 68度F 時，10 個恆溫器的實際數值如下，我們想要知道在百分之 95% 的信心水準中母體變異數的區間估計是多少？"></a>舉例：我們想要購買 A 廠商的恆溫器，我們在一個調查中得知，當在一個房間裡面設定 68度F 時，10 個恆溫器的實際數值如下，我們想要知道在百分之 95% 的信心水準中母體變異數的區間估計是多少？</h3><blockquote>
<p>資料如下<br><img src="https://drive.google.com/u/2/uc?id=1kZeoMsm26Zd8zxvZIwEmFX_81I_wuDEc&export=download" alt=""></p>
</blockquote>
<p>因此我們的自由度是 \(n-1=10-1=9, a = 0.05\)</p>
<ul>
<li>查表如下，注意是從右尾開始算<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1euYFYmMeZNZiZKdailEkQt2s68Mux6uB&export=download" alt=""></p>
</blockquote>
</li>
<li>用手機 Probability Distribution App 查找如下，注意是從右尾開始算<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1XLaH6uCL1juNtBevPBgQONToJ4GdUx-O&export=download" alt=""></p>
</blockquote>
</li>
<li>因此我們可以得出 \(X^{0.975}\) 值是 2.700，再來我們要找 \(X^{0.025}\) 的值，下面用圖表示<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1VRXVCsQHQ6a2SZCgVAceaM2XFcPlZbKl&export=download" alt=""></p>
</blockquote>
</li>
<li>跟上面用的方法一樣，用手機 Probability Distribution App 查找\(X^{0.025}\) 的值是 19.023</li>
<li>用圖表來所示<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1OylgZXuphkNJq1GESeKZcHom2eeKmVT4&export=download" alt=""></p>
</blockquote>
</li>
<li>再來我們算樣本標準差平方 \(s^2=\frac{\sum (x_i - \bar{x})^2}{n-1} = \frac{6.3}{9} = 0.70\)</li>
<li>接著我們把算好的卡方值拿出來用，因此在 95% 的信賴區間中 \(\frac{(10-1) 0.70}{19.023} \leq \sigma^2 \leq \frac{(10-1) 0.70}{2.700}\)，也就是 \(0.33 \leq \sigma^2 \leq 2.33\)</li>
</ul>
<h2 id="Hypothesis-Testing"><a href="#Hypothesis-Testing" class="headerlink" title="Hypothesis Testing"></a>Hypothesis Testing</h2><ul>
<li>定義對立假設與虛無假設<ul>
<li>左尾<ul>
<li>\(H_0: \sigma^2 \geq \sigma_0^2\)</li>
<li>\(H_1: \sigma^2 &lt; \sigma_0^2\)</li>
<li>其中 \(\sigma_0^2\) 是我們假設檢定中假設的母體變異數</li>
</ul>
</li>
<li>右尾<ul>
<li>\(H_0: \sigma^2 \leq \sigma_0^2\)</li>
<li>\(H_1: \sigma^2 &gt; \sigma_0^2\)</li>
<li>其中 \(\sigma_0^2\) 是我們假設檢定中假設的母體變異數</li>
</ul>
</li>
<li>雙尾<ul>
<li>\(H_0: \sigma^2 = \sigma_0^2\)</li>
<li>\(H_1: \sigma^2 != \sigma_0^2\)</li>
<li>其中 \(\sigma_0^2\) 是我們假設檢定中假設的母體變異數</li>
</ul>
</li>
</ul>
</li>
<li>T 檢定的公式為 \(X^2 = \frac{(n-1)s^2}{\sigma_0^2}\)</li>
<li>拒絕法則 Rejection Rule<ul>
<li>左尾<ul>
<li>p-value approach<br>Reject \(H_0\) if \(p-value \leq a\)</li>
<li>Critical Value approach<br>Reject \(H_0\) if \(X^2 \leq X_{1-a}^2\)</li>
</ul>
</li>
<li>右尾<ul>
<li>p-value approach<br>Reject \(H_0\) if \(p-value \leq a\)</li>
<li>Critical Value approach<br>Reject \(H_0\) if \(X^2 \leq X_{a}^2\)</li>
</ul>
</li>
<li>雙尾<ul>
<li>p-value approach<br>Reject \(H_0\) if \(p-value \leq a\)</li>
<li>Critical Value approach<br>Reject \(H_0\) if \(X^2 \leq X_{1-a/2}^2\) or \(X^2 \geq X_{a}^2\)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="舉例：我們想要購買-A-廠商的恆溫器，我們在一個調查中得知，當在一個房間裡面設定-68度F-時，10-個恆溫器的實際數值如下，我們想要知道在百分之-90-的信心水準中母體變異數要小於等於-0-5-題目設定，但沒有在圖片說"><a href="#舉例：我們想要購買-A-廠商的恆溫器，我們在一個調查中得知，當在一個房間裡面設定-68度F-時，10-個恆溫器的實際數值如下，我們想要知道在百分之-90-的信心水準中母體變異數要小於等於-0-5-題目設定，但沒有在圖片說" class="headerlink" title="舉例：我們想要購買 A 廠商的恆溫器，我們在一個調查中得知，當在一個房間裡面設定 68度F 時，10 個恆溫器的實際數值如下，我們想要知道在百分之 90% 的信心水準中母體變異數要小於等於 0.5(題目設定，但沒有在圖片說)"></a>舉例：我們想要購買 A 廠商的恆溫器，我們在一個調查中得知，當在一個房間裡面設定 68度F 時，10 個恆溫器的實際數值如下，我們想要知道在百分之 90% 的信心水準中母體變異數要小於等於 0.5(題目設定，但沒有在圖片說)</h3><p>圖片所示</p>
<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=19LkXBKWQNeLCPkTMspXs3D6uVrQZvZ2w&export=download" alt=""></p>
</blockquote>
<p>其中 Buyer’s Digest 為 A 廠商</p>
<ul>
<li><p>因此定義對立假設與虛無假設</p>
<ul>
<li>\(H_0: \sigma^2 \leq 0.5\)</li>
<li>\(H_1: \sigma^2 &gt; 0.5\)</li>
</ul>
</li>
<li><p>右尾檢定，透過 Probability Distribution App 查找，\(v=9, P(X&gt;x) =0.1 \) 時，\(X_{1-a}^2 = 14.864\)，因此值要大於 \(X^2 \geq 14.864\)，才能證明 \(H_1\) 是對的。</p>
</li>
<li><p>計算 t 檢定的公式 \(X^2 = \frac{(n-1)s^2}{\sigma_0^2} =\frac{9(0.7)}{5} = 12.6\)</p>
</li>
<li><p>用圖表來表示</p>
<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=169KEeNO4n37q1KlT5lyvnQhUvspZakMa&export=download" alt=""></p>
</blockquote>
</li>
<li><p>p-Value Approach<br>卡方值的 12.6 機率為 0.18156，比我們的顯著性水準 0.1 還高，因此沒有證據顯示他們的恆溫器有變異數過大的問題。</p>
</li>
<li><p>Critical Value Approach<br>根據前一個舉例我們有計算過的樣本變異數 \(s^2 =0.7\)，\(X^2=\frac{9(0.7)}{5} = 12.6\)<br>\(12.6 \leq 14.864\)，因此我們拒絕 \(H_0\)，因此我們沒有證據顯示他們的恆溫器有變異數過大的問題。</p>
</li>
</ul>
<h1 id="推論兩組母體變異數-Inference-About-Two-Population-Variances"><a href="#推論兩組母體變異數-Inference-About-Two-Population-Variances" class="headerlink" title="推論兩組母體變異數(Inference About Two Population Variances)"></a>推論兩組母體變異數(Inference About Two Population Variances)</h1><p>蒐集兩個獨立母體的樣本，透過這兩個母體樣本就可以對這兩個母體進行推論。</p>
<ul>
<li>左尾的假設檢定<ul>
<li>\(H_0: \sigma_1^2 \geq \sigma_2^2\)</li>
<li>\(H_1: \sigma_1^2 &lt; \sigma_2^2\)</li>
<li>通常會將比較大的樣本變異數設定為 population1</li>
</ul>
</li>
<li>右尾的假設檢定<ul>
<li>\(H_0: \sigma_1^2 \leq \sigma_2^2\)</li>
<li>\(H_1: \sigma_1^2 &gt; \sigma_2^2\)</li>
<li>通常會將比較大的樣本變異數設定為 population1</li>
</ul>
</li>
<li>雙尾的假設檢定<ul>
<li>\(H_0: \sigma_1^2 = \sigma_2^2\)</li>
<li>\(H_1: \sigma_1^2 != \sigma_2^2\)</li>
<li>通常會將比較大的樣本變異數設定為 population1</li>
</ul>
</li>
<li>t 檢定公式為 \(F = \frac{s_1^2}{s_2^2}\)<br>此公式會有兩個自由度，因為有兩個母體。第一個母體為分子\(s_1\)、第二個母體為分母\(s_2\)。</li>
<li>拒絕法則 Rejection Rule<ul>
<li>左尾<ul>
<li>p-value approach<br>Reject \(H_0\) if \(p-value \leq a\)</li>
<li>Critical Value approach<br>Reject \(H_0\) if \(F \geq F_a\)</li>
</ul>
</li>
<li>右尾<ul>
<li>p-value approach<br>Reject \(H_0\) if \(p-value \leq a\)</li>
<li>Critical Value approach<br>Reject \(H_0\) if \(F \geq F_a\)</li>
</ul>
</li>
<li>雙尾<ul>
<li>p-value approach<br>Reject \(H_0\) if \(p-value \leq a\)</li>
<li>Critical Value approach<br>Reject \(H_0\) if \(F \geq F_{a/2}\)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="舉例：我們想要購買恆溫器，有-A、B-公司兩家，在顯著性水準為-0-1-時，我們想要知道他們的變異數是不是一樣，資料在下方"><a href="#舉例：我們想要購買恆溫器，有-A、B-公司兩家，在顯著性水準為-0-1-時，我們想要知道他們的變異數是不是一樣，資料在下方" class="headerlink" title="舉例：我們想要購買恆溫器，有 A、B 公司兩家，在顯著性水準為 0.1 時，我們想要知道他們的變異數是不是一樣，資料在下方"></a>舉例：我們想要購買恆溫器，有 A、B 公司兩家，在顯著性水準為 0.1 時，我們想要知道他們的變異數是不是一樣，資料在下方</h2><p>圖片所示</p>
<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1aWlaP0afdYMF4mviGq5sWaOfVo39rv3W&export=download" alt=""></p>
</blockquote>
<p>其中 thermoRite 為 B 公司、TempKing 為 A 公司，因為 B 公司的樣本變異數比較大(1.768)，A 公司約 0.7</p>
<ul>
<li>因此定義對立假設與虛無假設<ul>
<li>\(H_0: \sigma_1^2 = \sigma_2^2\)</li>
<li>\(H_1: \sigma_1^2 != \sigma_2^2\)</li>
</ul>
</li>
<li>拒絕法則 Rejection Rule<ul>
<li>由於是雙尾，因此 顯著性水準為 \(0.1 / 2 = 0.05\)，兩個都是 9 自由度。</li>
<li>用 Probability Distribution App 計算如下<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1t9KilhfMGm59ekfVPpRUZTSHnLJKXB5i&export=download" alt=""></p>
</blockquote>
</li>
<li>用查表的方式<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=18BdfbAATxmWCpjw3xDMCNaV_MhH8OLyi&export=download" alt=""></p>
</blockquote>
</li>
<li>第一個是 A 公司的自由度，第二是 B 公司的自由度，p 的機率是 0.05，我們可以得出\(F_{0.05} = 3.18\)，因此如果要 reject \(H_0\) if \(F \geq 3.18 \)</li>
</ul>
</li>
<li>t 檢定公式為 \(F = \frac{s_1^2}{s_2^2}\)，其中 A 公司的數值為 1.768，B 公司的數值為 0.7，因此 \(F = 1.768 / 0.7 = 2.53\)</li>
<li>p-value Approach<ul>
<li>透過  Probability Distribution App 計算 \(F=2.53 \) 時機率為 0.9，但因為是雙尾，因此我們要將機率乘二變為 0.18，\(a = 0.05 &lt; p-value = 0.18\)，因此我們不拒絕 \(H_0\)</li>
<li>因此我們沒有辦法證明兩家公司恆溫器的變異數是不同的。</li>
</ul>
</li>
<li>Critical Value Approach<ul>
<li>因此我們不可以拒絕 \(H_0\)，因為 \(F=2.53 &lt; F_{0.05} = 3.18\)</li>
<li>因此我們沒有辦法證明兩家公司恆溫器的變異數是不同的。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>北科上課筆記</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>統計學筆記</tag>
        <tag>北科大二下統計學筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces 1497E1 - Square-free division (easy version) (math theorm)</title>
    <url>/2021/03/22/Codeforces/Codeforces%201497E1/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>請你將題目給你的數列進行切斷，每一個切斷的數列裡不可以有某兩值相乘是完全平方數，求最小切斷的長度</p>
<p><a href="https://codeforces.com/contest/1497/problem/E1" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li>了解完全平方數的特性</li>
<li>進行優化，不可簡單思考就開始寫入</li>
</ul>
<p>##　分析<br>這題很有趣，學了一課。</p>
<p>我們可以知道完全平方數的特性是，每一個質因數的次方都是偶數才有辦法組成完全平方數，那現在只剩下一個問題了，我們怎樣知道哪些數字相乘會等於完全平方數呢？</p>
<p>此時我們可以透過完全平方數反推，只要有一個質因數的次方不是偶數就不會是完全平方數，那麼只要有另外一個數字相乘可以讓所有的質因數次方都變成偶數。</p>
<p>舉例： 18 = 2 * 3 * 3，此時我們的 2 的次方是奇數，那我們只要再補給他 2 就會等於 36 是個完全平方數了！<br>在進一步想，如果讓 18 * 8 = 144，也是完全平方數， 8 = 2 * 2 * 2，2^3 也是奇數，因此我們只要讓兩個數字相乘後每一個質因數 都是偶數，遇到這樣的情況時就可以切斷。</p>
<p>而我們知道奇數 + 奇數 就是偶數，因此我們只要知道當前片段有幾個質因數是奇數在紀錄就好。</p>
<p>現在還有一個問題要稍微避險下，18 = 2 * 3 * 3, 6 = 2 * 3，這樣是沒有滿足所有的質因數的次方都是偶數，會變成 108 = 2 * 2 * 3 * 3 * 3，因此這樣不算。</p>
<p>如果要讓 6 乘以另一個數字相乘必須是滿足所有的質因數的次方都是偶數，因次需要另外一個 6 來補足就變成了 36 = 2 * 2 * 3 * 3。<br>這裡我們得知一件事，我們除了計算哪些質因數次方是奇數外，還要讓這些奇數質因數次方相乘。</p>
<p>得出結論</p>
<ul>
<li>把所有數字拆解質因數</li>
<li>當數字的所有質因數為奇數次方時，相乘這些奇數次方的質因數(定義 p)</li>
<li>保存 p，只要後面的數字也有另外一個 p 時就切斷數列</li>
</ul>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://blog.csdn.net/asbbv/article/details/114990845" target="_blank" rel="noopener">E1. Square-free division (easy version) (数论、思维) by tom_bbv</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>題目考到我了QQ，不過我認為我學習了蠻多思維，希望這些思維我都能學會並且派上用場。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 200020</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> t, n, k, num[MAXN]; <span class="comment">//num 輸入題目數列用</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; mp; <span class="comment">//紀錄每個 p，前面定義過的</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">divid</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">1</span>; <span class="comment">//紀錄此數字所有奇數次方的質因數相乘</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i*i &lt;= x; i++)&#123; <span class="comment">//質因數分解</span></span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x % i == <span class="number">0</span>)&#123; </span><br><span class="line">            cnt++; <span class="comment">//紀錄總共有幾次的次方</span></span><br><span class="line">            x /= i; <span class="comment">//約分，加速迴圈效率</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt % <span class="number">2</span> != <span class="number">0</span>) p *= i; <span class="comment">//奇數次方的質因數相乘</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p*x; <span class="comment">//這邊還要再乘以 x，因為前面有約分，所以 x 會是最後一個沒有被加入迴圈的質因數，回傳 p</span></span><br><span class="line">    <span class="comment">//x 也可以等於 1，因為 1 是質因數</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>; <span class="comment">//紀錄要切幾個線段</span></span><br><span class="line">        mp.clear(); <span class="comment">//先將前面紀錄有哪些 p 先清除，避免干擾</span></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123; <span class="comment">//輸入題目數列</span></span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; num[i];</span><br><span class="line">            <span class="keyword">int</span> p = divid(num[i]); <span class="comment">//質因數分解，回傳此數字所有奇數次方的質因數相乘</span></span><br><span class="line">            <span class="keyword">if</span>(mp.count(p))&#123; <span class="comment">//如果 p 有被記錄表示，這裡會被組成完全平方數</span></span><br><span class="line">                ans++; <span class="comment">//這邊切線段，然後清除之前紀錄的 p</span></span><br><span class="line">                mp.clear();</span><br><span class="line">            &#125;</span><br><span class="line">            mp[p] = <span class="number">1</span>; <span class="comment">//這次的 p 要被記錄，因為是在另一個線段</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans+<span class="number">1</span> &lt;&lt; <span class="string">'\n'</span>; <span class="comment">//最後的線段不會再被我們切到，因此這邊要 +1，加入最後一個線段</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>math theorm</tag>
        <tag>設計解題</tag>
        <tag>程式解題</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa10487 - Closest Sums (二分搜尋 Binary Search)</title>
    <url>/2020/03/28/UVa/UVa10487/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>給你一個數列，再給你一個數字，請你告訴這個數字最靠近這個數列某兩個值相加之總和(不可使用同個位置的數字)</p>
<p><a href="https://onlinejudge.org/external/104/10487.pdf" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li>思考要怎麼樣迅速查詢到最靠近的值</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>基本上是水題，再透過二分搜尋的方式將答案找出。</p>
<p>先將數列中所有數字都先兩兩相加後，再用二分搜尋找出最靠近的數字。</p>
<p>注意：這裡要用 <code>upper_bound</code> 會比較好寫，他勢必會找到比題目要查詢的數字更大，因此我們<code>upper_bound</code> 找到的數值(定義num[x])，再往前一個 index，num[x-1]，一定會比查詢的數字還要小，接下來再拿這兩個數字去比較即可，輸出離查詢數字更近的。</p>
<p>注意一開始的邊界問題，因此一開始先設無限大即可。</p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>簡單的一道題，希望自己考場都寫會瞜</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1020</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, idx, ans, temp, kase=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> num[MAXN]; <span class="comment">//放題目數列用</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sum; <span class="comment">//放兩兩相加後的陣列</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n &amp;&amp; n)&#123;</span><br><span class="line">        sum.clear(); <span class="comment">//清除上次的狀態，否則會干擾此次題目</span></span><br><span class="line">        sum.push_back(<span class="number">-0x3f3f3f</span>); <span class="comment">//先放第一筆資料進去，並且是無限大才不會導致</span></span><br><span class="line">        <span class="comment">//upper_bound 找到 (index)0 時跟 (index)-1 比較的問題</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123; <span class="comment">//輸入資料</span></span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; num[i]; </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i<span class="number">-1</span>; j &gt;= <span class="number">0</span>; j--) sum.push_back(num[i]+num[j]); </span><br><span class="line">            <span class="comment">//類似於 bubble sort 的將值輸入進去，這樣就不會重複輸入兩個值以上</span></span><br><span class="line">        &#125;</span><br><span class="line">        sort(sum.begin(), sum.end()); <span class="comment">//排序，方便二分搜尋</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Case "</span> &lt;&lt; kase++ &lt;&lt; <span class="string">":\n"</span>; </span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; m; <span class="comment">//輸入題目資訊</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; temp; </span><br><span class="line">            idx = upper_bound(sum.begin(), sum.end(), temp) - sum.begin(); </span><br><span class="line">            <span class="comment">//找到離查詢的數值更大的數值，(定義t)</span></span><br><span class="line">            <span class="keyword">int</span> gap1 = <span class="built_in">abs</span>(sum[idx] - temp); <span class="comment">//差距 1，找查詢數與 t 的距離</span></span><br><span class="line">            <span class="keyword">int</span> gap2 = <span class="built_in">abs</span>(sum[idx<span class="number">-1</span>] - temp); <span class="comment">//差距 1，找查詢數與 t 的上一個數值的距離</span></span><br><span class="line">            <span class="comment">//cout &lt;&lt; sum[index] &lt;&lt; ' ' &lt;&lt; sum[index-1] &lt;&lt; '\n';</span></span><br><span class="line">            <span class="keyword">if</span>(gap2 &lt; gap1) <span class="built_in">cout</span> &lt;&lt; <span class="string">"Closest sum to "</span> &lt;&lt; temp &lt;&lt; <span class="string">" is "</span> &lt;&lt; sum [idx<span class="number">-1</span>] &lt;&lt; <span class="string">".\n"</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"Closest sum to "</span> &lt;&lt; temp &lt;&lt; <span class="string">" is "</span> &lt;&lt; sum[idx] &lt;&lt; <span class="string">".\n"</span>;</span><br><span class="line">            <span class="comment">//誰的差距大，就用另外一個差距的 sum[idx] or sum[idx-1] 來輸出答案。</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>












]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>Binary Search 二分搜尋</tag>
      </tags>
  </entry>
  <entry>
    <title>個案報告 - 協易機械 ERP顧問的評選</title>
    <url>/2021/03/28/NTUT_note/MIS-Case2/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊與財金管理系大二下管理資訊系統的個案報告心得回饋<br><font color="#dd0000">並非所有人都適用，部分對我而言稍加容易的內容並不會寫在此內。</font></p>
</blockquote>
<a id="more"></a>

<h2 id="個人心得"><a href="#個人心得" class="headerlink" title="個人心得"></a>個人心得</h2><p><img src="https://drive.google.com/file/d/1KH1V5aP3CAChwKOD_udb9hS7LPH27VOF/view?usp=sharing" alt="協易機械 ERP顧問的評選，大衛心得"></p>
]]></content>
      <categories>
        <category>北科上課筆記</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>管理資訊系統</tag>
      </tags>
  </entry>
  <entry>
    <title>個案報告 1 - 怪獸公司 資訊系統促使之企業流程變革</title>
    <url>/2021/03/28/NTUT_note/MIS-Case1/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊與財金管理系大二下管理資訊系統的個案報告心得回饋<br><font color="#dd0000">並非所有人都適用，部分對我而言稍加容易的內容並不會寫在此內。</font></p>
</blockquote>
<a id="more"></a>

<h2 id="個人心得"><a href="#個人心得" class="headerlink" title="個人心得"></a>個人心得</h2><p><img src="https://drive.google.com/file/d/1dHZEzJFJeI9wevWhSlMKa5D7I_LHn1L5/view?usp=sharing" alt="怪獸公司 資訊系統促使之企業流程變革，大衛心得"></p>
]]></content>
      <categories>
        <category>北科上課筆記</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>管理資訊系統</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa11236 - Grocery store (數論 Math theorm、暴力搜尋 Brute force)</title>
    <url>/2020/04/05/UVa/UVa%2011236/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>雜貨店的收銀員不太懂加號跟乘號這兩個意思，為了要讓他更容易理解，因此在你買雜貨店的商品時，你想要讓你買的四項商品總和價格等同於你買的四項商品價格乘積，四項商品都是相同的商品。</p>
<p>總共不可以大於 20 元，雜貨店的商品價格範圍在 0.00 ~ 20.00 範圍內，小數點前兩位都是合理的價位。<br>輸出時，四個商品價格必須是遞增</p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li>了解小數點不夠精確，因此必須化為整數運算</li>
<li>對於暴力搜尋進行優化<ul>
<li>反推最後一項商品價錢</li>
<li>暴力搜尋的範圍優化</li>
<li>解決小數會越乘越小的問題</li>
</ul>
</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>好題，好題，沒想到 UVa 裡面也有類似於 Codeforces 的題目呢。</p>
<p>我們來進行一些分析，首先由於我們知道電腦對於小數運算並不精確，假如小數數字連續乘四，有非常高的機率會使浮點數運算有誤差，導致無法 AC，因此我們的第一件事情就是要用整數來解決此題。</p>
<h3 id="擴分公式"><a href="#擴分公式" class="headerlink" title="擴分公式"></a>擴分公式</h3><p>根據題目的方程式，我們現在定義 \(p_1,p_2,p_3,p_4\)，是我們 4 個商品的價錢，因此公式要如下<br>\(p_1p_2p_3p_4 = p_1 + p_2 + p_3 p_4\)</p>
<p>接下來我們要進行擴分，這樣我們才可以用整數進行運算，我們定義括分 100 倍的價錢為 \(a_1 , a_2 , a_3 , a_4\)</p>
<ul>
<li>\(\frac{a_1}{100} \frac{a_2}{100} \frac{a_3}{100} \frac{a_4}{100} = \frac{a_1}{100}+ \frac{a_2}{100} + \frac{a_3}{100} \frac{a_4}{100}\)</li>
<li>稍微化簡下，成為 \(\frac{a_1 a_2 a_3 a_4}{10^8} = \frac{a_1+a_2+a_3+a_4}{100} \)</li>
<li>移項，\(\frac{a_1 a_2 a_3 a_4}{10^6} = a_1+a_2+a_3+a_4\)</li>
<li>分母移項 \((a_1+a_2+a_3+a_4) 10^6 = a_1 a_2 a_3 a_4 \)</li>
<li>透過此方程式，就可以用整數來寫出題目所需要的答案</li>
</ul>
<h3 id="優化迴圈"><a href="#優化迴圈" class="headerlink" title="優化迴圈"></a>優化迴圈</h3><p>由於我們還知道一件事情是，總共不能大於 20 元，且商品價格要遞增，因此大家比較容易想到的是迴圈不斷的遞增，但其實我們也可以減少迴圈的上限，來更加優化，如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> a1 = <span class="number">1</span>; a1 &lt;= <span class="number">2000</span>; a1++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> a2 = a1; a2 &lt;= <span class="number">2000</span>-a1; a2++ )&#123; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> a3 = a2; a3 &lt;= <span class="number">2000</span>-a1-a2; a3++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> a4 = a3; a4 &lt;= <span class="number">2000</span>-a1-a2-a3; a4++)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中可以注意到，a2,a3,a4 他們的迴圈上限都有被縮小，是因為題目除了要數值遞增，並且還不能超過 2000，那麼 a1 用掉的錢勢必也在 20 元以內，才可以透過這樣進行優化。</p>
<p>而遞增，減少下限就是大家比較熟悉的，不多做解釋。</p>
<h3 id="設定檢查點"><a href="#設定檢查點" class="headerlink" title="設定檢查點"></a>設定檢查點</h3><p>其中我們可以知道公式是 \((a_1+a_2+a_3+a_4) 10^6 = a_1 a_2 a_3 a_4 \)，但這裡有一個大問題，原先的題目數值是小數，如果是 \(0.1(0.2)\) 的情況下是越乘越小的，但整數的情況並不是，0因此才會有一個 \(10^6\) 的情況出現，所以反之，也就是說如果 \(a_1 a_2 a_3 a_4 &lt;= 10^6\) 的情況下表示四個數值都是 \(&gt; 1\)，乘積只會越來越小，必定不符合題目需求。</p>
<p>\(10^6\) 是因為我們先擴分 100 倍，才會有的限制器。</p>
<h3 id="減少迴圈數量"><a href="#減少迴圈數量" class="headerlink" title="減少迴圈數量"></a>減少迴圈數量</h3><p>先提一個概念，\(x+y=10\)，如果我們知道 x 的情況，那 y 是不是可以移項得出。<br>所以 \(a_1 + a_2 + a_3 + a_4 = A\)，如果前三項與 A 都知道那 \(a_4\) 也可以被得知。</p>
<p>因此我們來進行移項與定義</p>
<ul>
<li>定義 \(a_1+a_2+a_3\) 為 sum</li>
<li>定義 \(a_1 a_2 a_3\) 為 product</li>
<li>定義 \(10^6\) 為 c</li>
<li>因此 \((a_1+a_2+a_3+a_4) 10^6 = a_1 a_2 a_3 a_4 = c(sum + p_4) = product (p_4)\)</li>
<li>左項乘開 \(c(sum + p_4) = product (p_4)\) </li>
<li>再來移項 \(c(sum) + c(p_4) = product (p_4) \)</li>
<li>移項 \(c(sum) = product(p_4) - c(p_4)\)</li>
<li>結合 \(c(sum) = p_4(product - c)\)</li>
<li>移項 \(p_4 = \frac{c(sum)}{(product - c)}\)</li>
</ul>
<h3 id="擴分後的限制"><a href="#擴分後的限制" class="headerlink" title="擴分後的限制"></a>擴分後的限制</h3><p>再來我們知道了這公式後，我們還有幾個題目的限制要注意</p>
<ul>
<li>\(c(sum) % (product - c) == 0\) 因為我們進行擴分，因此如果沒有剛好 mod 等同於 0 時，表示其實此數值在縮小 100 倍後則不會剛好符合題目要求。表示 \(a_4\) 可能需要小數後 x 位才能符合題目要求，其中 x 必須大於 2。</li>
<li>\(p_3 &lt; p_4\)，題目要求</li>
<li>\(sum + p_4 \leq 2000\)，因為我們將 20 放大 100 倍</li>
<li>\(product(p_4) \leq 2(10^9)\)，由於 \(\frac{a_1 a_2 a_3 a_4}{10^8}\)，縮小 100 倍後不可以超過 20 元。注意，這裡的縮小 100 倍是每個 \(a\) 都縮小 100 倍，全部則是縮小 \(10^8\)</li>
</ul>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://www.redgreencode.com/equation-solving-is-the-key-to-uva-11236/" target="_blank" rel="noopener">EQUATION SOLVING IS THE KEY TO UVA 11236 by Red-Green-Code</a><br><a href="https://geniustanley.github.io/2017/02/15/UVa-11236-Grocery-store/" target="_blank" rel="noopener">UVa 11236 - Grocery store by geniustanley</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>這題很有趣RRR，完全不用輸入測資卻可以讓人有著這麼多的腦力激盪，其實很有趣R。</p>
<p>總之學到了很多，但我也是看著詳解一步一步慢慢地去學習，或許我的腦袋其實沒有很聰明，但我會透過學習來讓自己也能夠跟上一般人的腳步。</p>
<p>希望大家可以包容這樣的我，不夠聰明的我。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 2*1e9 <span class="comment">// 四項商品乘積放大 100 倍的值</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long <span class="comment">//避免溢位</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> c = <span class="number">1e6</span>; <span class="comment">//將他進行第溢</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//add more fast than product</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> a1 = <span class="number">1</span>; a1 &lt;= <span class="number">2000</span>; a1++)&#123;</span><br><span class="line">        <span class="comment">//if(pow(a1,4) &gt;= MAXN) break; //注意，加法運算比乘法快。</span></span><br><span class="line">        <span class="keyword">if</span>(a1+a1+a1+a1 &gt; <span class="number">2000</span>) <span class="keyword">break</span>; <span class="comment">//如果這邊就超過 2000，後面沒辦法遞增部符合題目要求</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> a2 = a1; a2 &lt;= <span class="number">2000</span>-a1; a2++ )&#123; </span><br><span class="line">            <span class="comment">//if(a1+pow(a2,3) &gt;= MAXN) break;</span></span><br><span class="line">            <span class="keyword">if</span>(a1+a2+a2+a2 &gt; <span class="number">2000</span>) <span class="keyword">break</span>; <span class="comment">//如果這邊就超過 2000，後面沒辦法遞增部符合題目要求</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> a3 = a2; a3 &lt;= <span class="number">2000</span>-a1-a2; a3++)&#123;</span><br><span class="line">                <span class="comment">//if(a1+a2+pow(a3,2) &gt;= MAXN) break;</span></span><br><span class="line">                <span class="keyword">if</span>(a1+a2+a3+a3 &gt; <span class="number">2000</span>) <span class="keyword">break</span>; <span class="comment">//如果這邊就超過 2000，後面沒辦法遞增部符合題目要求</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> sum = a1 + a2 + a3;</span><br><span class="line">                <span class="keyword">int</span> product = a1 * a2 * a3;</span><br><span class="line">                <span class="keyword">if</span>(product &lt;= c) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>((sum*c) % (product-c) != <span class="number">0</span>) <span class="keyword">continue</span>; <span class="comment">//mod != 0 </span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//上方擴分後的限制有提到</span></span><br><span class="line">                <span class="keyword">int</span> a4 = (sum*c) / (product-c);</span><br><span class="line">                <span class="keyword">if</span>(a3 &gt; a4) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(sum + a4 &gt; <span class="number">2000</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(product * a4 &gt; MAXN) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; fixed &lt;&lt; setprecision(<span class="number">2</span>) &lt;&lt; a1/<span class="number">100.0</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; \</span><br><span class="line">                    fixed &lt;&lt; setprecision(<span class="number">2</span>) &lt;&lt; a2/<span class="number">100.0</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; \</span><br><span class="line">                    fixed &lt;&lt; setprecision(<span class="number">2</span>) &lt;&lt; a3/<span class="number">100.0</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; \</span><br><span class="line">                    fixed &lt;&lt; setprecision(<span class="number">2</span>) &lt;&lt; a4/<span class="number">100.0</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">                <span class="comment">//小數運算</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    solve();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>數論 Math theorm</tag>
        <tag>暴力搜尋 Brute force</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa10660 - Citizen attention offices (暴力搜尋 Brute force)</title>
    <url>/2020/03/28/UVa/UVa10660/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>有一個正方形的城市，被分隔成 25 個區域，size 是 5 * 5，每個區域都有住著許多人，政府要在裡面設 5 個行政據點，其目標是可以幫助此城市所有人都可以透過直走與橫走的方式走到行政據點(其中一個就可以)，且讓都市中的所有人總和走起來距離最短。</p>
<p><a href="https://onlinejudge.org/external/106/10660.pdf" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li>寫出時間複雜度</li>
<li>進行思考，是否有非暴力搜尋的方式可以解出此題</li>
<li>能夠閱讀題目</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>這題是一個很麻煩的題目…，通常我看到這種題目我都會認為一定有一種規律可行、可解。</p>
<p>結果這題我想了很久後，還是想不太出來，查了查詳解後才知道這題應該直接用暴力破解的方式將她解出，由於 DFS 的時間複雜度是 \(O(n^m)\)，n 是邊數、m 是深度，而這裡的最大時間複雜度應該是 \(25^5 = 9765625\)，在時間複雜度低於 2000 萬以內，基本上一個良好的 OJ 都能夠順利解開，因此我們就直接使用 DFS。</p>
<p>怎麼做呢?</p>
<p>作法很簡單，不斷進行 DFS，必且深度搜尋，當深度抵達 5 時，判斷城市中所有 area 到行政據點的最短距離乘上人口數量，找出最小值，就是我們要的答案。</p>
<p>需要注意的是，那個區域只需要<strong>找到一個行政據點</strong>距離最小就好，我這邊還卡了一下..。</p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://blog.csdn.net/mobius_strip/article/details/86564658" target="_blank" rel="noopener">UVa 10660 - Citizen attention offices by 小白菜又菜</a><br><a href="https://zh.wikipedia.org/wiki/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2" target="_blank" rel="noopener">深度優先搜尋 by Wiki</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>習慣性看到這種題目就是要找規律，然後找到可以優化的點進行優化，就能輕鬆解出。雖然大部分時間都找不出來優化點….QQ。我不夠聰明RRR。</p>
<p>經過了這題後，稍微沒有那麼思考僵化了，其實有的時候一直過度寫同樣題目容易造成自己的思考模式都往同個部分思考，現在有寫過這題後對於思考方式又更發散了一些。雖然說太發散找不到方向，但是不發散絕對找不到正確答案。</p>
<p>總之，希望自己 ICPC 可以得到銀獎，拜託了。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 30 <span class="comment">//題目最大區域量，保險起見開更大</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> num[MAXN], ans[MAXN], result[MAXN];</span><br><span class="line"><span class="comment">//num 題目的區域，ans 我們要輸出的答案，result 當前 DFS 中每個區域到行政據點最短距離的總和</span></span><br><span class="line"><span class="comment">//ans, result 只會用到前 5 個陣列值</span></span><br><span class="line"><span class="keyword">int</span> t, n, a, b, c; <span class="comment">//輸入資料用</span></span><br><span class="line"><span class="keyword">int</span> d = MAXN*MAXN*<span class="number">1000</span>; <span class="comment">//理論上每個區域到行政據點最大距離不超過此值，因為人口最多只有 1000</span></span><br><span class="line"><span class="comment">//因此 25個區域*最大距離25(不可能達到)*人口數量，可以當作此題的最大值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> office)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(office &gt;= <span class="number">5</span>)&#123; <span class="comment">//如果建立了 5 個辦公室，就開始找每個區域到行政據點最短距離的總和</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>; <span class="comment">//當前 DFS 每個區域到行政據點最短距離的總和</span></span><br><span class="line">        <span class="comment">//cout &lt;&lt; "result " &lt;&lt; result[i] &lt;&lt; '\n';</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">25</span>; j++)&#123; <span class="comment">//遍地每個區域</span></span><br><span class="line">            <span class="keyword">int</span> compute = MAXN*MAXN*<span class="number">1000</span>, temp; </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123; <span class="comment">//判斷哪個行政據點離當前區域最短</span></span><br><span class="line">                temp = num[j] * (<span class="built_in">abs</span>(result[i]/<span class="number">5</span> - j/<span class="number">5</span>) + <span class="built_in">abs</span>(result[i]%<span class="number">5</span> - j%<span class="number">5</span>));</span><br><span class="line">                compute = min(temp, compute); <span class="comment">//取最小的</span></span><br><span class="line">            &#125;</span><br><span class="line">            sum += compute; <span class="comment">//加到 sum</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定義: A = 每個區域到行政據點最短距離的總和</span></span><br><span class="line">        <span class="keyword">if</span>(sum &lt; d)&#123; <span class="comment">//如果當前的 A 比過去中最小的 A，還小就取代</span></span><br><span class="line">            <span class="comment">//cout &lt;&lt; "test:" &lt;&lt; sum &lt;&lt; ' ';</span></span><br><span class="line">            d = sum; <span class="comment">//將答案值替換</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123; <span class="comment">//將答案值替換</span></span><br><span class="line">                ans[i] = result[i];</span><br><span class="line">                <span class="comment">//cout &lt;&lt; result[i] &lt;&lt; ' ';</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; '\n';</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = p+<span class="number">1</span>; i &lt; <span class="number">25</span>; i++)&#123; <span class="comment">//不斷進行 DFS，做所有的排列組合</span></span><br><span class="line">        result[office] = i; <span class="comment">//當前的第 office 的辦公室為 i 區域 </span></span><br><span class="line">        dfs(i, office+<span class="number">1</span>); <span class="comment">//往下一層邁進，題目有說明輸出要遞增，因此 i 必須是 p+1，否則會重覆到</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">()</span></span>&#123; <span class="comment">//debug 用</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; num[i*<span class="number">5</span>+j] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="built_in">memset</span>(num, <span class="number">0</span>, <span class="keyword">sizeof</span>(num)); <span class="comment">//清空，以免干擾這次資料</span></span><br><span class="line">        <span class="keyword">while</span>(n--)&#123; <span class="comment">//輸入資料</span></span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">            num[a*<span class="number">5</span>+b] = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//debug();</span></span><br><span class="line">        d = MAXN*MAXN*<span class="number">1000</span>;</span><br><span class="line">        dfs(<span class="number">-1</span>, <span class="number">0</span>); <span class="comment">//一開始是 -1 是因為，我們的 DFS 排列組合迴圈是 p+1</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">5</span>; i++) <span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; ans[i]; <span class="comment">//輸出答案</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>暴力搜尋 Brute force</tag>
      </tags>
  </entry>
  <entry>
    <title>2021/04/03 跟蘇子權一起看哥吉拉大戰金剛</title>
    <url>/2021/04/05/life_experence/Godzilla-vs.-Kong-by-subarya/</url>
    <content><![CDATA[<h2 id="說明"><a href="#說明" class="headerlink" title="說明"></a>說明</h2><blockquote>
<p>之前在新北市奧林匹亞資訊認識的好朋友，後來考上台灣師大，問她要不要陪我去看哥吉拉大戰金剛</p>
</blockquote>
<a id="more"></a>

<h2 id="相約"><a href="#相約" class="headerlink" title="相約"></a>相約</h2><p>我其實很想要去看<a href="https://theriseofdavid.github.io/2021/04/05/movie/Godzilla-vs.-Kong/" target="_blank" rel="noopener">哥吉拉大戰金剛</a>，我就在想要找誰一起去，就在 fb 看到子權的貼文，我就想要問她要不要陪我去看XD。</p>
<p>我原本跟她約 04/02，結果他不行QQ，後來我們就改約 04/03。</p>
<h2 id="見面"><a href="#見面" class="headerlink" title="見面"></a>見面</h2><p>我們原本是約下午 4 點，但我後來我晚上 7 點有要弄資產配置競賽要開會阿，然後我保險的那 Part 還沒有做QQQ，所以我就在 3 號晚上 12 點趕快問子權能不能改時間，子權也馬上就說可以啦！</p>
<p>然後隔天見面，恩..我遲到了，讓子權等了我 30min 實在非常抱歉，我下次會改進的QQ。</p>
<h2 id="看電影"><a href="#看電影" class="headerlink" title="看電影"></a>看電影</h2><p>稍微聊了天後就去看電影，沒想到哥吉拉的電影場次人這麼多，多到爆炸RRRR，都快比公車班次還多了！</p>
<p>進去電影院後，我們買了爆米花跟可樂來搭配，結果子權說他可以在電影還沒播放前就把爆米花吃完，太強了阿阿阿，講了一些趣事後，電影就開始了。</p>
<h2 id="吃飯"><a href="#吃飯" class="headerlink" title="吃飯"></a>吃飯</h2><p>看完電影後我們稍微吃下兩餐，兩餐不能預約只能夠排隊叫號，於是我們就當場去然後排隊等號碼，原本服務生是跟我們說 54 號，但我有點忘記了我就問子權說 52 號嗎？他就說，對啊！然後看到顯示牌說 52 號可以入場，我們就進去，結果服務員在跟我們確認的時候才說我們是 54 號！害我們尷尬了一下XDD。</p>
<p>而且子權的專題很酷，中天新聞留言分析，感覺超級酷的。我自己覺得這是個很好的專題點子，可惜我沒想到阿，我的想像力變差了QQ。<br>不過聽說師大的虛擬機有點爛，有點小難過:(，雖然北科的比較好一點拉，就一點。</p>
<p>吃飯的過程中，我們聊天，聊了很多師大的八卦，離散數學、邏輯課…，離散數學我也是上的超級認真，就可以跟他有來有往，我還怕我老人腦袋裡的知識都輸給年輕人呢QQQ。</p>
<h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>跟他聊天，其實真的很快樂，而且又能獲得很多新知識，是我的好朋友，希望我可以都跟他保持聯絡我們的感情不會淡掉，那他就不可以忘記我呢！所以我要多在他快忘記我的時候出現XD。</p>
<p>總之，我覺得他是我生命中很信賴的人拉，失去的信賴的人總是會難過的，所以不可以難過的方法就是不失去XD。</p>
]]></content>
      <categories>
        <category>人生旅途</category>
      </categories>
      <tags>
        <tag>大學Life</tag>
        <tag>人生旅途</tag>
      </tags>
  </entry>
  <entry>
    <title>快速建立屬於你的 online judge</title>
    <url>/2021/03/29/linux/linux-build-online-judge/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>在北科大二下時我擔任了資財-資料結構的助教，負責設計考卷，看了先前的考古題後發現老師都是讓大家手寫程式，我認為這樣沒有辦法讓大家學到資料結構的知識，因此這邊做一個小創新，讓大家都學習如何使用 online judge</p>
<p>透過大家使用 online judge 就可以讓大家在有限的時間內寫出程式，感受壓力，並也在感受壓力的過程中將資料結構成功記住！</p>
<p>就因為這樣，我稍微去學習如何快速建立 online judge，透過中國青島大學開源的 online judge，在這邊很感謝中國青島大學，讓我可以快速的建立起 online judge QQ。</p>
</blockquote>
<a id="more"></a>

<h2 id="QDUOJ"><a href="#QDUOJ" class="headerlink" title="QDUOJ"></a>QDUOJ</h2><p>中國青島大學開源的 online judge，建立容易，且有很直觀的後台管理、使用者使用環境，在這三大優點下，使用此開源 online judge。</p>
<p><a href="https://github.com/QingdaoU/OnlineJudgeDeploy/tree/2.0" target="_blank" rel="noopener">QDUOJ 佈署</a>連結，如果看不太懂我的寫法，建議直接去看 QDUOJ 的XD。</p>
<p>建議不要使用 windows 安裝，只使用 linux，windows 有太多地雷了…，沒有的話可以在 windows 裡面開虛擬機。<br><del>我在 windows 環境下用虛擬機再用 docker，虛擬在虛擬，這難道是幻覺嗎RRRRRR</del></p>
<h2 id="環境設定"><a href="#環境設定" class="headerlink" title="環境設定"></a>環境設定</h2><p>在 docker 中建立 online judge，docker 將作業系統虛擬化，可以讓 online judge 更快速的被執行與建立，因為只有服務 online judge 嘛。<br>還有一個好處是如果 online judge 爛掉，不至於會讓整個作業系統爛掉，只會讓 docker 爛掉而已XD。</p>
<p>建議先輸入這三行，檢查是否所有需要的環境設定是否有安裝</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get update &amp;&amp; sudo apt-get install -y vim python3-pip curl git</span><br><span class="line">pip3 install --upgrade pip</span><br><span class="line">pip install docker-compose</span><br><span class="line">sudo curl -sSL get.docker.com | sh</span><br></pre></td></tr></table></figure>

<h2 id="開始安裝"><a href="#開始安裝" class="headerlink" title="開始安裝"></a>開始安裝</h2><p>不多說，repo 拉下來就對了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone -b 2.0 https:&#x2F;&#x2F;github.com&#x2F;QingdaoU&#x2F;OnlineJudgeDeploy.git &amp;&amp; cd OnlineJudgeDeploy</span><br></pre></td></tr></table></figure>

<h2 id="建立-docker-服務"><a href="#建立-docker-服務" class="headerlink" title="建立 docker 服務"></a>建立 docker 服務</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo docker-compose up -d</span><br></pre></td></tr></table></figure>

<p>這裡要等一段時間，大約半小時左右就會建立成功。</p>
<h2 id="享受-docker-服務"><a href="#享受-docker-服務" class="headerlink" title="享受 docker 服務"></a>享受 docker 服務</h2><p>輸入 <code>sudo docker ps -a</code>，如果正確則應該會出現類似此畫面</p>
<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1Q9jNBzboAqaDPZQ070xDa1HBj5-4sBPx&export=download" alt=""></p>
</blockquote>
<h2 id="來整理我們的-online-judge-八！"><a href="#來整理我們的-online-judge-八！" class="headerlink" title="來整理我們的 online judge 八！"></a>來整理我們的 online judge 八！</h2><p>如果對於我的講解認為不夠好的，可以查看<a href="https://docs.onlinejudge.me/" target="_blank" rel="noopener">QDUOJ 教學說明</a></p>
<p>到 browser 打 <code>localhost:80</code>，應該能夠順利出現網頁，畫面如下</p>
<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=18-pHEQoLwUZUACZx5kEu1Rg183tRwHxL&export=download" alt=""></p>
</blockquote>
<h3 id="進入後台"><a href="#進入後台" class="headerlink" title="進入後台"></a>進入後台</h3><p>我們先進入管理者的權限，查看後台配置</p>
<ul>
<li>管理者帳號 <code>root</code></li>
<li>管理者密碼 <code>rootroot</code></li>
</ul>
<p>如果怕其他人也知道管理者的密碼時，建議大家將 root 密碼改掉XD。</p>
<p>再來點選 root -&gt; management，進入管理頁面</p>
<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1Ec8StoEFVBt9BV4wI1S_lOUzQWJxLvnd&export=download" alt=""></p>
</blockquote>
<p>讓我們來看看有那些功能，我們先看有關於使用者的功能，點擊 General</p>
<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1tPzXULZP-urt3z7KUpE6VtT1biXDOsmT&export=download" alt=""></p>
</blockquote>
<p>依序功能如下：</p>
<ul>
<li>user 所有使用者的資訊，帳號密碼</li>
<li>announcement 可以發布公告，有就是在 home 的畫面在那邊會有新的留言公告</li>
<li>後面三個我們不會用到，因此先忽略</li>
</ul>
<h3 id="註冊-user"><a href="#註冊-user" class="headerlink" title="註冊 user"></a>註冊 user</h3><p>進入 user 頁面後，會發現只有 root 這個用戶QQ，</p>
<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=18pg7_6c82ZQ4h27tl9Prodji_5-x1nNP&export=download" alt=""></p>
</blockquote>
<p>進來這個頁面後，<code>import user</code> 提供 csv 輸入會員資料，格式如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">memberA,passwordA,email</span><br><span class="line">memberB,passwordB,email</span><br></pre></td></tr></table></figure>

<p>下方的 Generate User 可以快速的生成 user，參數如下</p>
<ul>
<li><code>prefix</code> 帳號的前綴字元</li>
<li><code>suffix</code> 帳號的後綴字元</li>
<li><code>start number</code> 帳號中間要塞入的數字起點</li>
<li>````end number``` 帳號中間要塞入的數字終點</li>
<li><code>password length</code> 密碼長度，會是高強度密碼(簡稱亂碼)</li>
</ul>
<p>因此假如 prefix = a, suffix = v, start number=2, end number = 4, password length = 4，就會產生以下的會員</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a2v,xxxx,xx@gmail.com</span><br><span class="line">a3v,xxxx,xx@gmail.com</span><br><span class="line">a4v,xxxx,xx@gmail.com</span><br></pre></td></tr></table></figure>

<p>如此的概念，其中 xxxx 是高強度密碼(亂碼)</p>
<h2 id="發布公告"><a href="#發布公告" class="headerlink" title="發布公告"></a>發布公告</h2><p>點入 general 在點擊 announcement，就可發布公告</p>
<h2 id="加入題目"><a href="#加入題目" class="headerlink" title="加入題目"></a>加入題目</h2><p>這是最重要的部分，如果沒有的話怎麼讓大家寫題目嘛</p>
<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1hBp92mbyy9Kr3jwtSASxm8E3pXFmFEKK&export=download" alt=""></p>
</blockquote>
<p>點擊 problem 後可以點 problem list 看到現在所有的題目，而其中的 <code>create problem</code> 則可以建立題目，點擊他</p>
<p>相信上面大家都會使用，需要注意的是 sampleX，X 為數字，則是顯示在題目上的範例測資中，實際的官方測資則是要從這裡加入</p>
<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1xzGD6wEYtk-0h9IlEQAIgGv3Ve6k_Fae&export=download" alt=""></p>
</blockquote>
<p>圖中的 Choose File 中加入，特別需要值得一提的是</p>
<ul>
<li><code>filename.in</code> 是程式輸入的題目資料</li>
<li><code>filename.out</code> 則是程式輸出的正確資料</li>
</ul>
<p>而旁邊的 type 有</p>
<ul>
<li>ACM 全對才給分</li>
<li>OI 對測資就給分，有部分給分。</li>
</ul>
<h2 id="建立競賽"><a href="#建立競賽" class="headerlink" title="建立競賽"></a>建立競賽</h2><p>點擊左邊的資訊欄中的 contest，再點擊 creat contest，過程相信大家都懂不需要我在說，create contest 完畢後，在點擊資訊欄中的 contest list，</p>
<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1UqxZCUNfNnGeHUXbJvHkFY80GYACAtaW&export=download" alt=""></p>
</blockquote>
<p>點擊此按鈕就可以加入題目，開始放入題目八！不管是公開的題目還是私有的題目都可以，而加入題目的方式就跟我們前面說的<strong>加入題目</strong>一樣啦。</p>
<h2 id="現在來到最後一個問題，如何讓外網連到我的-judge-呢"><a href="#現在來到最後一個問題，如何讓外網連到我的-judge-呢" class="headerlink" title="現在來到最後一個問題，如何讓外網連到我的 judge 呢?"></a>現在來到最後一個問題，如何讓外網連到我的 judge 呢?</h2><p>這裡我們使用 ngrok 來幫我們代理伺服器，提供我們網址。</p>
<p>教學如下 <a href="https://theriseofdavid.github.io/2020/07/24/ngrok-experience/" target="_blank" rel="noopener">透過 ngrok 來讓自己的電腦成為 server by 大衛的筆記</a></p>
<p>port 可以隨意設定，之後產生的網址我們就可以對外發布，讓他人連線了！</p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://github.com/QingdaoU/OnlineJudgeDeploy/tree/2.0" target="_blank" rel="noopener">QDUOJ 佈署 by 中國青島大學</a><br><a href="https://docs.onlinejudge.me/" target="_blank" rel="noopener">QDUOJ 教學說明 by 中國青島大學</a><br><a href="https://blog.techbridge.cc/2020/03/20/build-your-own-online-judge/" target="_blank" rel="noopener">自己架一個 Online Judge 系統 by TechBrige</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>QDUOJ 真的是很方便，讓我可以在短短幾個小時內學會並且運用此軟體，真的是太感動了QQ，希望我以後也有一天可以將自己所學到的技術分享給他人。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>linux</tag>
        <tag>online judge</tag>
      </tags>
  </entry>
  <entry>
    <title>電影觀後感 - 哥吉拉大戰金剛 (4/5)</title>
    <url>/2021/04/05/movie/Godzilla-vs.-Kong/</url>
    <content><![CDATA[<h2 id="前情概要"><a href="#前情概要" class="headerlink" title="前情概要"></a>前情概要</h2><blockquote>
<p>1973年骷髏島探勘事件過後的50多年，骷髏島的氣候巨變使島上的原住民伊維族幾乎全數罹難，只留下小孤女吉雅。與此同時，根據挖掘所發現的史前壁畫及後續研究，君主組織得知了哥吉拉與金剛的世仇，故此君主在骷髏島建立了基地以保護金剛。吉雅的養母，艾琳·安德魯博士多年來一直試圖與金剛進行溝通但不果。自五年前的泰坦混戰後，哥吉拉與人類一直和平共處，但此刻卻多次襲擊高科技公司「頂極神經機械企業」（Apex）的工廠，一名潛入頂極臥底的播客柏尼·海斯不僅目睹了過程，更意外地發現頂極似乎在秘密研製不明裝置。</p>
<div class="video-container"><iframe src="https://www.youtube.com/embed/s1DUC_wBUvY" frameborder="0" loading="lazy" allowfullscreen></iframe></div>
<p><a href="https://zh.wikipedia.org/wiki/%E5%93%A5%E5%90%89%E6%8B%89%E5%A4%A7%E6%88%B0%E9%87%91%E5%89%9B" target="_blank" rel="noopener">資料來源</a></p>
</blockquote>
<a id="more"></a>

<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>整體對於這部片得打鬥感，算是蠻不賴得，就是中間的劇情零散了些。</p>
<p>我全部的記憶點只圍繞者打鬥XD。</p>
<h3 id="金剛與哥吉拉在海上的打鬥"><a href="#金剛與哥吉拉在海上的打鬥" class="headerlink" title="金剛與哥吉拉在海上的打鬥"></a>金剛與哥吉拉在海上的打鬥</h3><p>打得好爽，可是我真的覺得哥吉拉有夠強欸，哥吉拉整個腳色就是強於金剛阿，金剛似乎有種被馴服的感覺，願意與人類和平共處，而哥吉拉是海上的霸主比較內向不太喜歡與人們互動，但一直很喜歡跟金剛打鬥，金剛在這次的戰鬥中輸了。</p>
<p>原因主要是因為哥吉拉在海中可以像魚一般游泳，而金剛不可以，加上哥吉拉有那強大的破壞死光，遠程傷害來說根本 MAX 八XDDDD。</p>
<p>還有金剛的毛被海弄濕的畫面感很讚，只是有點太多毛好噁心QQQQ。</p>
<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1ZkjAVPLWIO-AaxVLWfx1RxEydnjUyd1f&export=download" alt=""></p>
</blockquote>
<h3 id="金剛回到地心中的地球"><a href="#金剛回到地心中的地球" class="headerlink" title="金剛回到地心中的地球"></a>金剛回到地心中的地球</h3><p>回到地心地球時有遇到泰坦翌守龍</p>
<p>金剛回到地心中的地球時，拿到了他的武器，而尖端科技也取得了他們所需要的能源，把能源送回地球表面給尖端科技使用。</p>
<p>這邊有很多盲點QQQ，到底為甚麼尖端科技採集到的石頭可以直接傳回地球表面拉XDDD，那邊又沒有網路而且理論上衛星也沒有辦法可以接受到阿。</p>
<p>但後來這邊壞主角的女兒死掉真的是大快人心，不得不說，要是他這邊有平安回到地球我真的會氣得牙癢癢的，他們這邊刻畫得很讚。</p>
<h3 id="金剛與哥吉拉在香港大戰"><a href="#金剛與哥吉拉在香港大戰" class="headerlink" title="金剛與哥吉拉在香港大戰"></a>金剛與哥吉拉在香港大戰</h3><p>香港，辛苦你了。最近怎麼大家都喜歡摧殘你們QQQQ。</p>
<p>感覺哥吉拉跟金剛踩死了一堆人類阿QQQ，在地心地球時金剛有用他的斧頭進行充能，對抗哥吉拉的破壞死光時，則用斧頭擋住。<br>最後金剛則打輸，被哥吉拉在胸前用爪子留下爪痕來表示戰勝的痕跡。</p>
<p>後來女博士跟男博士透過能通往地心地球的飛機，透過那飛機大量傳輸電力來讓金剛復活，有種 AED 的概念XDDD。</p>
<p>男博士那邊特別好笑，女博士跟小女孩那時候一起欺騙男博士，讓男博士認為膽小鬼的手語是勇敢的意思，這個真的有好笑到</p>
<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1xCvd5E2hs25H08QrCRW13KpZhOm3uRLi&export=download" alt=""></p>
</blockquote>
<h3 id="兩隻泰坦與機械哥吉拉的戰鬥"><a href="#兩隻泰坦與機械哥吉拉的戰鬥" class="headerlink" title="兩隻泰坦與機械哥吉拉的戰鬥"></a>兩隻泰坦與機械哥吉拉的戰鬥</h3><p>老實講，這裡超讚的，我原本其實超級害怕機械哥吉拉會把哥吉拉給擊敗成為世界的王，那樣我會覺得哥吉拉很可憐，尖端科技超壞。<br>幸好不是像我預料的那樣，而是尖端科技的哥吉拉成為了一個新巨獸，後來小女孩跟金剛溝通表示敵人是機械哥吉拉，金剛與哥吉拉一起聯手打敗他。</p>
<p>其中最後一擊哥吉拉將她的死亡白光充能給金剛的斧頭，真的不是我想說XDDD，金剛的斧頭如果可以充能的話，那前面的戰鬥金剛幹嘛都只拿斧頭擋攻擊阿，順便充能RRRR，這樣不就贏了嗎XD。</p>
<p>機械哥吉拉有夠強，他加速度有引擎可以衝刺，近距離的爪子則改為鑽頭，連揮爪子都不用，只須要往前一刺，可能沒有一個泰坦扛得住QQQ。</p>
<p>然後特別好笑的是，這裡面的泰坦死法是，一定要將它們的頭給抓下來才表示死亡，不然大家都有復活的機會欸XDDD，某種類型來說也蠻像僵屍的XD。</p>
<h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>其中另外一個有黑人的支線這次很奇怪扮演著一個關鍵的角色，但感覺卻被輕描淡寫，黑人與尖端科技總理的小女孩都保持著大膽的作法，而在最後機械哥吉拉站起來時卻是胖胖的男生拯救，理論上胖胖男生應該可以得個甚麼和平獎八XD。</p>
<p>胖胖男生感覺就很聰明，而且又很喜歡尖端科技總理的小女孩，會不會在一起R，可是感覺尖端科技總理的小女孩就會喜歡上那些一樣大膽的男孩，可能不會喜歡喝自來水的小胖男孩QQQ。</p>
<p>支線劇情讓我覺得似乎沒有很重要，但又不可以缺乏他，否則最後的片段我們會不知道在演甚麼XD。</p>
<p>我是哥吉拉派的，我覺得哥吉拉也是很聰明而且他從一開始就知道自己最需要解決的對手是誰，才會進行戰鬥，後面也都沒有將金剛直接做一個擊殺，雖然殺掉那打機械哥吉拉那可能就是一場災難了QQ。</p>
<p>金剛只是剛好被人馴服，才會顯得它忠厚老實八(?，否則我認為哥吉拉她其實也是用著他的方法在保全他的周遭，不能很確定他有沒有想要保全人類的心，但可以知道只少牠對人類沒有敵意，不然破壞死光一下去似乎大家都沒轍八XD。<br>所以人們才需要金剛，不然也會害怕沒有對手可以將哥吉拉牽制或打敗。</p>
<p>而原住民小孩則當起了訓獸師，讓人類與金剛有著可以溝通的橋樑。</p>
<p>難得這次的電影反派不是中國人，可是好像也沒有中國人出場，怎麼講，感覺偶爾少了個帶入感XD。沒有那種阿華人又被當成反派，我又要被別人打輸的感覺了XD。</p>
<p>而且這次的反派我覺得演得剛剛好，有他的理想，他也願意努力去實現，只是手段比較激進，但我認為也沒有錯，只是作風不同。<br>但確實在現實世界或是電影中，大膽追求革新的人們總是不容易獲得幸福與理想實現化的可能，總是需要一步一步的改革，不可以讓太多的保守派因為反感他們而採取行動，而是像溫水煮青蛙那樣讓保守派的人們認為這件事情不會很<strong>可怕</strong>。</p>
<p>改革與保守都有其相對應的好處，在團隊下保守、在個人下改革，我認為應該是目前比較不會造成大量爭議性的方法(?，不過我才大二，其實也還不太懂甚麼是團隊，畢竟也沒有真的在一個超過 1000 人的大團隊下工作過，可能會被很多人認為是菜鳥八XD。</p>
]]></content>
      <categories>
        <category>電影心得</category>
      </categories>
      <tags>
        <tag>人生旅途</tag>
        <tag>電影心得</tag>
        <tag>戰鬥類電影心得</tag>
      </tags>
  </entry>
  <entry>
    <title>R 推薦的 json 套件</title>
    <url>/2021/04/06/R/Rjson/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>R 有著很多不穩定的套件，我在 R 使用有關於 json 的套件時，發現讀 json 有著許多問題，特地在這邊留下紀錄</p>
</blockquote>
<a id="more"></a>

<h2 id="讀網路上的-json-資料"><a href="#讀網路上的-json-資料" class="headerlink" title="讀網路上的 json 資料"></a>讀網路上的 json 資料</h2><p>當初很認真的去解決此問題，但沒有留下紀錄，很感謝那些讓我可以學習到知識的人。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="keyword">library</span>(jsonlite)</span><br><span class="line">domino_api &lt;- GET(<span class="string">"https://youtube.com"</span> , timeout(<span class="number">40</span>) , encode = <span class="string">"multipart"</span>,  accept_json())</span><br><span class="line">domino_json &lt;- fromJSON(content(domino_api,type=<span class="string">"text"</span>,encoding = <span class="string">"UTF8"</span>))</span><br></pre></td></tr></table></figure>

<h2 id="讀本地上的-json"><a href="#讀本地上的-json" class="headerlink" title="讀本地上的 json"></a>讀本地上的 json</h2><p>這邊十分推薦 rjson 此套件包，他在讀本地 json 檔案，不容易有格式問題。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="keyword">library</span>(rjson)</span><br><span class="line"></span><br><span class="line">before_data &lt;- rjson::fromJSON(file =<span class="string">"dominoV2.json"</span>)</span><br></pre></td></tr></table></figure>

<p>如果使用 <code>read_json</code>，讀進來 R 時容易有此問題。</p>
<ul>
<li>原本的 json 資料，尚未使用 <code>read_json</code> and <code>write_json</code><br><img src="https://drive.google.com/u/2/uc?id=1RNGiKk3mj1Bel74_MBFDppmtcGoKOucG&export=download" alt=""></li>
<li>經過 R 並且執行  <code>read_json</code> and <code>write_json</code><br><img src="https://drive.google.com/u/2/uc?id=1D4nMYBHpf0nWLNalblF8DsAskh3dAB9J&export=download" alt=""></li>
</ul>
<p>可以明顯知道，裡面的每一個欄位又都被包了一個 list，這樣非常不好，但我們使用套件的人員沒辦法解決此問題，因此只能夠換另一個套件包啦。</p>
<p><a href="https://stackoverflow.com/questions/2617600/importing-data-from-a-json-file-into-r" target="_blank" rel="noopener">參考連結</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>R 真的好難RRR，這邊這個真的會弄得亂糟糟。太多套件太混亂了，加上中文資源並不多，所以大部分都從國外或是中國學資源。</p>
<p>希望我可以做一個轉發，讓大家知道國外資源，也可以透過中文字來讓大家更快的解決問題。</p>
<p>我解決這個問題花了 8 小時，很累QQ。</p>
<p>期望 R 可以統整功能相似的包在一起，再有一個完整的說明文件，那就更棒了！</p>
]]></content>
      <categories>
        <category>R語言</category>
      </categories>
      <tags>
        <tag>R語言</tag>
        <tag>學習筆記</tag>
        <tag>json</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces 1483D - Playlist(Disjoint Set 並查集)</title>
    <url>/2020/08/31/Codeforces/Codeforces%201483D/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>有一個數列可以被一種方式移除，只要當前的數值與下一個數值是 \(gcd = 1\) 的情況就將後面的數值取出並記錄 index。</p>
<p>請輸出有幾個數值被取出，並且那些 index 為何。</p>
<p><a href="https://codeforces.com/contest/1483/problem/B" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li>了解 GCD</li>
<li>減少重複比對</li>
<li><a href="https://theriseofdavid.github.io/2021/02/02/Explain_Algorithm/disjoint-set/" target="_blank" rel="noopener">熟悉並查集</a></li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>我們可以先稍微進行分析</p>
<ul>
<li>只要 <code>gcd == 1</code> 就是移除後面的數值</li>
<li>重複的比對相同數值是題目絕對不允許的</li>
</ul>
<p>這時我們可以用一種方式來進行思考，如果我們將 <code>gcd == 1</code> 後不將後者數值刪除，而是告訴前者數值的下一個數值是哪個的時候是不是可以解決問題？</p>
<p>舉例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">index: 1 2 3</span><br><span class="line">value: 1 2 3</span><br><span class="line">merge: 1 2 3</span><br></pre></td></tr></table></figure>

<p>其中前兩項 <code>gcd = 1</code>，這時我們只修改 merge 為</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">index: 1 2 3</span><br><span class="line">value: 1 2 3</span><br><span class="line">merge: 2 2 3</span><br></pre></td></tr></table></figure>

<p>表示我們現在只要到 index 1 的時候就直接到 index 3，跳過被合併的 2，這樣我們可以減少大量的刪<br>除動作。</p>
<p>現在我們可以知道一件事 merge 中相同數值的第一個 index 必定是尚未被消除過的數值，其他的 index 一定有被消除過且最後一個 index 必定等同於 merge 的數值。<br>這裡我們寫程式方便，會有一個 <code>del</code> 陣列來記錄被消除的 index。</p>
<p>再來我們要減少重複比對，這時候就需要一個 <code>queue</code> 了，由於我們知道 <code>gcd(x,y)</code> 與 <code>gcd(y,x)</code>，一定相同，因此我們可以降低重複比對。</p>
<p>假如現在有三個值 x,y,z，且都 \(gcd != 1\)，那我們只要做三遍 gcd 就可以知道這三個數值保證 \(gcd != 1\)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcd(x,y)</span><br><span class="line">gcd(y,z)</span><br><span class="line">gcd(z,x)</span><br></pre></td></tr></table></figure>

<p>這時我們就又知道了一件事情，每個數值都只會跟自己的下一個數值做 <code>gcd</code>，因此我們的 <code>queue</code> 只要記錄 gcd 的前項就好，後項不需要紀錄。</p>
<p>那有沒有可能後項會被 gcd 的操作給移除掉? 不可能。<br>用上面的舉例，如果 <code>gcd(x,y)</code>，y 沒有被移除，那 y 在下次的 <code>gcd(y,z)</code> 不可能會被移除。</p>
<p>因此我們可以得出結論</p>
<ul>
<li>使用並查集來 merge 消除的數值</li>
<li>我們用 queue 紀錄 gcd 的第一項</li>
<li>如果 <code>gcd(x,y) == 1</code>，那就讓 vector 紀錄 y，並且 <code>queue.push(x)</code>，因為 x 的下一個數值不在是 y，我們沒辦法保證 <code>gcd(x,z) == 1</code>，需要重做才知道。</li>
</ul>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://zhuanlan.zhihu.com/p/359628701" target="_blank" rel="noopener">Codeforces Round #709 (Div. 1, based on Technocup 2021 Final Round) by 一只蒟蒻</a><br><a href="https://www.cnblogs.com/-Wallace-/p/cf-709.html" target="_blank" rel="noopener">Codeforces Round #709 (Div. 1, based on Technocup 2021 Final Round) by <em>Wallace</em></a><br><a href="https://codeforces.com/blog/entry/88944" target="_blank" rel="noopener">Codeforces Round #709 / Technocup 2021 Final Round — Unofficial Editorial by Geothermal’s blog</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>這題學到很多，第一次意識到 disjoint set 也可以這樣操作，學了很多啊。</p>
<p>希望自己透過這樣子的學習可以讓自己變得更強，並且更加靈活地應用在生活上！</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e6</span>;</span><br><span class="line"><span class="keyword">int</span> a[MAXN], fa[MAXN], del[MAXN]; <span class="comment">//a 是數值，fa 是 merge，del 是那些 index 被消除過</span></span><br><span class="line"><span class="keyword">int</span> t, n;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; record; <span class="comment">//紀錄答案</span></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_root</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="comment">//並查集</span></span><br><span class="line">    <span class="keyword">return</span> fa[x] == x ? x : fa[x] = find_root(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        q.clear(); <span class="comment">//清空，避免影響此次答案</span></span><br><span class="line">        record.clear();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123; <span class="comment">//輸入資料</span></span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">            fa[i] = i;</span><br><span class="line">            del[i] = <span class="number">0</span>; <span class="comment">//清空</span></span><br><span class="line">            q.push_back(i); <span class="comment">//將未比對的 gcd 的數值放入 q</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123; <span class="comment">//如果空了表示，全部都有比對過</span></span><br><span class="line">            <span class="keyword">int</span> u = q.front(); q.pop_front(); <span class="comment">//</span></span><br><span class="line">            <span class="keyword">if</span>(del[u]) <span class="keyword">continue</span>; <span class="comment">//如果這邊之前有被消除過，就不需要比對</span></span><br><span class="line">            <span class="keyword">int</span> v = (find_root(u)+<span class="number">1</span>) % n; <span class="comment">//下一個未被消除的位置</span></span><br><span class="line">            <span class="keyword">if</span>(v == <span class="number">0</span>) v = n; <span class="comment">//如果是 0 是因為 mod 的問題，因此改回 n</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(__gcd(a[u], a[v]) == <span class="number">1</span>)&#123; <span class="comment">//可以被消除</span></span><br><span class="line">                record.push_back(v); <span class="comment">//紀錄消除的 index</span></span><br><span class="line">                <span class="keyword">int</span> fu = find_root(u); <span class="comment">//合併</span></span><br><span class="line">                <span class="keyword">int</span> fv = find_root(v);</span><br><span class="line">                fa[fu] = fv; <span class="comment">//讓 fv 的值給到 fu，f 表示 father</span></span><br><span class="line">                del[v] = <span class="number">1</span>; <span class="comment">//v 被移除</span></span><br><span class="line">                q.push_back(u); <span class="comment">//u 被放入，因為 gcd 的 v 被移除掉，他接下來還會匹配到新的 v</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; record.size(); <span class="comment">//輸出答案</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it: record) <span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; it;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>Disjoint Set 並查集</tag>
        <tag>程式解題</tag>
      </tags>
  </entry>
  <entry>
    <title>北科通識課 國際關係 - 比較 G20 與台灣</title>
    <url>/2021/04/07/NTUT_note/NTUT_national_relation/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用來記錄大衛在台北科技大學通識課 - 國際關係，何揚老師上課的作業。</p>
<p>G20 與台灣的關係比較圖</p>
<p>其資料都來自於 wiki</p>
</blockquote>
<a id="more"></a>

<h2 id="參考來源"><a href="#參考來源" class="headerlink" title="參考來源"></a>參考來源</h2><p><a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8D%81%E5%9C%8B%E9%9B%86%E5%9C%98" target="_blank" rel="noopener">二十國集團 by wiki</a><br><a href="https://zh.wikipedia.org/wiki/%E4%BA%BA%E9%A1%9E%E7%99%BC%E5%B1%95%E6%8C%87%E6%95%B8%E5%88%97%E8%A1%A8" target="_blank" rel="noopener">人類發展指數列表 by wiki</a><br><a href="https://zh.wikipedia.org/wiki/%E4%B8%96%E7%95%8C%E5%90%84%E5%9B%BD%E5%92%8C%E5%9C%B0%E5%8C%BA%E9%9D%A2%E7%A7%AF%E5%88%97%E8%A1%A8" target="_blank" rel="noopener">世界各國和地區面積列表 by wiki</a><br><a href="https://en.wikipedia.org/wiki/Military#Capability_development" target="_blank" rel="noopener">Military by wiki</a><br><a href="https://en.wikipedia.org/wiki/List_of_countries_by_life_expectancy" target="_blank" rel="noopener">List of countries by life expectancy by wiki</a></p>
<h2 id="內容"><a href="#內容" class="headerlink" title="內容"></a>內容</h2><p>我將我自己統整的資料放在網路中，供大家學習使用，但禁止抄襲。</p>
<p><a href="https://drive.google.com/file/d/139cfMuF2MAoBYvDrmMv-1mdyJVei6wLp/view?usp=sharing" target="_blank" rel="noopener">圖表</a><br><a href="https://drive.google.com/file/d/1qcidPJModDkUJSdJ2pA726xpM3b0INi0/view?usp=sharing" target="_blank" rel="noopener">附註說明</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>有些東西可以用爬蟲爬資料，真的是非常好用！</p>
<p>但是有很多資料是不同的網頁，且對 G20 並沒有完全支援。<br>原本有打算要寫一個程式互相 link，但後來想想可能會更花時間就停下來了。</p>
<p>總之，整理資料真的好累，文書作業感好重，又好想睡覺RRR。</p>
]]></content>
      <categories>
        <category>北科上課筆記</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>國際關係</tag>
      </tags>
  </entry>
  <entry>
    <title>北科資工二多媒體技術與應用 第四周作業-測試 Adaboost、KNN 兩種分類器</title>
    <url>/2021/04/07/NTUT_note/NTUTcs_MediaHW04-1/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊工程系大二下多媒體技術與應用作業紀錄<br><font color="#dd0000">並非所有人都適用，部分對我而言稍加容易的內容並不會寫在此內。</font><br><strong>這是學習後心得的筆記，可能不太適用會未來的學生</strong></p>
<p>由於我沒有學習過裡面的理論，因此這是資工大二學生透過網路與自身理解的筆記，學習價值並不高、且可能擁有大量錯誤。</p>
</blockquote>
<a id="more"></a>


<h2 id="題目如下，用圖片"><a href="#題目如下，用圖片" class="headerlink" title="題目如下，用圖片"></a>題目如下，用圖片</h2><blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1XsmKWOZfkH1oOtuxLvnf5bLG18N_SKc_&export=download" alt=""></p>
</blockquote>
<h2 id="Adaboost"><a href="#Adaboost" class="headerlink" title="Adaboost"></a>Adaboost</h2><p>主要是透過 python sklearn.ensemble 函式使用，裡面其中最重要的三個參數如下：</p>
<ul>
<li>n_estimators<br>為公式 的可最大疊代次數，其中 W_(k+1)就是每次的疊代次數記錄，通常標準是 50，如果太大可能會導致 overfitting，太小則又不夠精確。</li>
<li>learning_rate<br>為每個分類器的權重，如果每個分類器的權重越大，那建議 n_estimators 可以小點，如果每個分類器的權重越小，則建議n_estimators 要更大些。</li>
</ul>
<p>透過鳶尾花資料集進行練習，我發現最主要的問題是 train_test_split 中的 test_size 比例越小時則其準確性越高，反之則越大。</p>
<h3 id="程式碼"><a href="#程式碼" class="headerlink" title="程式碼"></a>程式碼</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> svm</span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> AdaBoostClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> make_classification</span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">iris = datasets.load_iris()</span><br><span class="line"></span><br><span class="line">x = iris.data</span><br><span class="line">y = iris.target</span><br><span class="line">x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=<span class="number">0.2</span>, random_state=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#test_size 越小，準確率越高，越大則準確率越低</span></span><br><span class="line"><span class="comment">#在learning_rate 越大，感覺越好，n_estimators注意不要 overfitting</span></span><br><span class="line">clf = AdaBoostClassifier(n_estimators=<span class="number">40</span>, learning_rate=<span class="number">1</span>, random_state=<span class="number">0</span>)</span><br><span class="line">clf.fit(x_train, y_train)</span><br><span class="line">print(<span class="string">"AdaBoost accuracy"</span>)</span><br><span class="line">print(clf.score(x, y))</span><br><span class="line">print()</span><br></pre></td></tr></table></figure>

<h3 id="輸出結果"><a href="#輸出結果" class="headerlink" title="輸出結果"></a>輸出結果</h3><blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1k0IqTG1uy6mM2godTHsLo31rmW6PS5pW&export=download" alt=""></p>
</blockquote>
<h3 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h3><p>其中最酷的是 n_estimators在 40 的情況時，準確率會降低，但在 n_estimators 是 30 的情況下時，準確率卻又會上升至 n_estimators 等於 50。</p>
<h3 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h3><p><img src="https://blog.csdn.net/TeFuirnever/article/details/100276569?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-4&spm=1001.2101.3001.4242" alt="sklearn.ensemble.AdaBoostClassifier()函数解析（最清晰的解释）by 我是管小亮"><br><img src="https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.AdaBoostClassifier.html" alt="sklearn.ensemble.AdaBoostClassifier by scikit learn"><br><img src="https://ithelp.ithome.com.tw/articles/10197110" alt="[Day26]機器學習：KNN分類演算法！by iT邦幫忙"></p>
<h2 id="KNN"><a href="#KNN" class="headerlink" title="KNN"></a>KNN</h2><p>主要是透過 python sklearn.neighbors函式使用，裡面其中最重要的三個參數如下：</p>
<ul>
<li>n_neighbors<br>預設是5，是 KKN 演算法中已離你最近的 K 的點為主，將自己也視為此類別。</li>
<li>weights<br>以要被判斷的點為中心，有兩種方法 uniform 為只要在此範圍內的點權重都相同，而 distance 每個點權重都不同，取決於每個點到中心點的距離。</li>
<li>algorithm<br>使用的演算法，預設是 auto，也就是函式自動使用適合的演算法，brute 是暴力搜尋，當訓練集大時非常耗時，而 kd_tree and ball_tree 則是用來改善 brute，而產生的演算法。</li>
</ul>
<h3 id="程式碼-1"><a href="#程式碼-1" class="headerlink" title="程式碼"></a>程式碼</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> svm</span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> AdaBoostClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> make_classification</span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">iris = datasets.load_iris()</span><br><span class="line"></span><br><span class="line">x = iris.data</span><br><span class="line">y = iris.target</span><br><span class="line">x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=<span class="number">0.2</span>, random_state=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#只有 weights 感受到差異</span></span><br><span class="line">neigh = KNeighborsClassifier(n_neighbors=<span class="number">5</span>, algorithm=<span class="string">'kd_tree'</span>, weights=<span class="string">'distance'</span>)</span><br><span class="line">neigh.fit(x_train, y_train)</span><br><span class="line">print(<span class="string">"KNN accuracy"</span>)</span><br><span class="line">print(neigh.predict(x_test))</span><br><span class="line"></span><br><span class="line">xx = neigh.predict(x_test)</span><br><span class="line">cnt = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(x_test)):</span><br><span class="line">  <span class="keyword">if</span>(xx[i] == y_test[i]):</span><br><span class="line">    cnt+=<span class="number">1</span></span><br><span class="line">print(<span class="string">"Accuracy"</span>, cnt/len(x_test))</span><br></pre></td></tr></table></figure>

<h3 id="結果"><a href="#結果" class="headerlink" title="結果"></a>結果</h3><blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=12mD7k_q8kKndDtLLVJPPX82F1xHs4_Nu&export=download" alt=""></p>
</blockquote>
<h3 id="心得-1"><a href="#心得-1" class="headerlink" title="心得"></a>心得</h3><p>其中由於 KNN 會出來的是對於每個點的預測，於是我有在第 30行到第35行簡單的對每筆資料進行判斷。<br>其中得出我們的 weights 如果使用 distance 的準確率會比 uniform 來的更好。<br>而 n_neighbors 在這邊我們則不會感受到太大的差異，主要是因為資料量太小且 5 是標準函式預設的 n_neighbors，如果再小可能就會導致 overfitting。</p>
<p>注意：n_neighbors 不可以設定為 1，此函式出來的結果畢竟會是100%準確，沒辦法發揮此函式的功用。</p>
<h3 id="參考連結-1"><a href="#參考連結-1" class="headerlink" title="參考連結"></a>參考連結</h3><p><img src="https://tefuirnever.blog.csdn.net/article/details/99818078?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control&dist_request_id=1328769.82134.16177873596971781&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control" alt="sklearn.neighbors.KNeighborsClassifier()函数解析（最清晰的解释）by 我是管小亮"><br><img src="https://scikit-learn.org/stable/modules/generated/sklearn.neighbors.KNeighborsClassifier.html" alt="sklearn.neighbors.KNeighborsClassifier by scikit learn"><br><img src="https://ithelp.ithome.com.tw/articles/10197110" alt="[Day26]機器學習：KNN分類演算法！by iT邦幫忙"></p>
<h2 id="心得-2"><a href="#心得-2" class="headerlink" title="心得"></a>心得</h2><p>謝謝力瑋、梓琳兩位不願其煩的一直教我QQQ，這種東西沒有學過還不太熟悉RRR。</p>
<p>總之紀錄一下自己學習的過程不是一件壞事情八(?。</p>
]]></content>
      <categories>
        <category>北科上課筆記</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>多媒體技術與應用筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>北科資工二多媒體技術與應用 第四周對於 SVM 的學習紀錄</title>
    <url>/2021/04/07/NTUT_note/NTUTcs_MediaHW04_Note/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊工程系大二下多媒體技術與應用作業紀錄<br><font color="#dd0000">並非所有人都適用，部分對我而言稍加容易的內容並不會寫在此內。</font><br><strong>這是學習後心得的筆記，可能不太適用會未來的學生</strong></p>
<p>由於我沒有學習過裡面的理論，因此這是資工大二學生透過網路與自身理解的筆記，學習價值並不高、且可能擁有大量錯誤。</p>
</blockquote>
<a id="more"></a>

<h2 id="學習紀錄"><a href="#學習紀錄" class="headerlink" title="學習紀錄"></a>學習紀錄</h2><ul>
<li>給予越多的特徵，會有不同的結果，但規律可能不好找</li>
<li>但越多的特徵給予 SVM 會使準確率變高</li>
<li>kernel 使用 poly 方法，準確率最高，Sigmoid 則是最差</li>
<li>C 值越大(對於錯誤的忍受度)，學習的準確率越高。但對測試集沒有任何影響</li>
<li>gamma 盡量使用 scale，但是在 <code>kernel=&#39;linear&#39;</code>時則完全沒有用處，linear 不需要用到 gamma 參數。</li>
<li><code>train_test_split</code> 的 test_size 越大時準確率越低。</li>
</ul>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>謝謝力瑋、梓琳拯救我的多媒體，兩位大佬QAQ，我現在還對於多媒體沒有很了解，希望能夠趕快追上QQQQ。</p>
<p>題外話，py 真的讓我用的不太上手RRR，numpy 跟 list 沒想到在 print 出來時長的一樣，但他們本身型態卻不同，弱型態語言我還沒有辦法完全掌控R。</p>
<p>總之還是謝謝二位了QQQ。</p>
]]></content>
      <categories>
        <category>北科上課筆記</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>多媒體技術與應用筆記</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa11565 - Simple Equations (數論 Math theorm、暴力搜尋 Brute force)</title>
    <url>/2020/04/07/UVa/UVa11565/</url>
    <content><![CDATA[<h2 id="題目大意"><a href="#題目大意" class="headerlink" title="題目大意"></a>題目大意</h2><blockquote>
<p>你必須找出 x,y,z 三個數字符合下面的公式，其中 x,y,z 數字不可以相同</p>
<ul>
<li>\(x+y+z = A\)</li>
<li>\(xyz=B\)</li>
<li>\(x^2 + y^2 + z^2 = C\)</li>
</ul>
<p>給你 A,B,C 求出 x,y,z，如果有多組答案，請輸出依序最小的</p>
<p><a href="https://onlinejudge.org/external/115/11565.pdf" target="_blank" rel="noopener">題目連結</a></p>
</blockquote>
<a id="more"></a>

<h2 id="重點觀念"><a href="#重點觀念" class="headerlink" title="重點觀念"></a>重點觀念</h2><ul>
<li>對於暴力搜尋進行優化<ul>
<li>反推 z</li>
<li>了解題目數值最大上限</li>
<li>得知題目可以負整數</li>
</ul>
</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>其實蠻水的XDDD，但是我花了蠻久才看的出來QQQ。</p>
<p>理論上其實我們可以透過題目的三個公式得出一些想法</p>
<ul>
<li>由於 \(x^2 + y^2 + z^2 = C\)，且 \(C &lt;= 10000\)，因此理論上 x,y,z 不會超過 100。</li>
<li>\(x+y+z = A\) x,y,z 有可能會是負整數，只要最後 A 是正就好</li>
<li>\(xyz=B\) 基本上 x,y,z 如果要有負整數的情況，那一定是 x,y,z 中有兩個負整數</li>
</ul>
<p>判斷時間複雜度 \(O(100 (100))\)，不大，最後的 z 再進行反推就能夠求出答案。</p>
<p>OK，那可以寫了對八！讓 x,y 從 -100 ~ 100，不斷嘗試。<br>注意：如果 x,y,z 其中有兩個數字一樣則不被視為答案。</p>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><p><a href="https://sayaurobuchi.github.io/cmusu/2017/06/10/UVa_11565.html" target="_blank" rel="noopener">[題解] UVa 11565 - Simple Equations by 巫術社的使魔群</a><br><a href="https://louisfghbvc.pixnet.net/blog/post/324071947-uva-11565-simple-equations" target="_blank" rel="noopener">Uva 11565 Simple Equations by louisfghbvc</a></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>難度不高，稍微動點腦就可以解出來。<br>用來增加大家信心的題目XD。</p>
<h2 id="題目程式碼"><a href="#題目程式碼" class="headerlink" title="題目程式碼"></a>題目程式碼</h2><p>會在下面放一些簡單註解，供大家學習時參考。 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> A, B, C;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">-100</span>; x &lt; <span class="number">100</span>; x++)&#123; <span class="comment">//brute fouce</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> y = <span class="number">-100</span>; y &lt; <span class="number">100</span>; y++)&#123;</span><br><span class="line">            <span class="keyword">int</span> z = A - x -y; <span class="comment">//反推 z</span></span><br><span class="line">            <span class="keyword">if</span>(x - y == <span class="number">0</span> || y - z == <span class="number">0</span> || x - z == <span class="number">0</span>) <span class="keyword">continue</span>; <span class="comment">//判斷有沒有數值相同</span></span><br><span class="line">            <span class="keyword">if</span>(B != z * x * y) <span class="keyword">continue</span>; <span class="comment">//判斷是否符合題目公式</span></span><br><span class="line">            <span class="keyword">if</span>(C != (x*x + y*y + z*z)) <span class="keyword">continue</span>;  <span class="comment">//判斷是否符合題目公式</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">' '</span> &lt;&lt; y &lt;&lt; <span class="string">' '</span> &lt;&lt; z &lt;&lt; <span class="string">'\n'</span> ; <span class="comment">//通過挑戰，可以輸出答案</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"in1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"out.txt"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; A &gt;&gt; B &gt;&gt; C;</span><br><span class="line">        <span class="keyword">if</span>(solve() == <span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">"No solution.\n"</span>; <span class="comment">//如果是 0 就輸出此文字。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>程式解題</tag>
        <tag>數論 Math theorm</tag>
        <tag>暴力搜尋 Brute force</tag>
      </tags>
  </entry>
  <entry>
    <title>統計學(二) 筆記 - 第十二章 比較多種比例，適合性檢定與適宜性檢定(Comparing Multiple Proportions, Test of Independence and Goodness Fit)</title>
    <url>/2021/04/11/NTUT_note/statistics-ch12/</url>
    <content><![CDATA[<h2 id="筆記說明"><a href="#筆記說明" class="headerlink" title="筆記說明"></a>筆記說明</h2><blockquote>
<p>此筆記用途在於台北科技大學資訊與財金管理系大二下統計學重點整理<br><font color="#dd0000">並非所有人都適用，部分對我而言稍加容易的內容並不會寫在此內。</font><br><strong>這是觀看影片心得後的筆記，老師上課可能不太適用會忘記抄到</strong></p>
</blockquote>
<a id="more"></a>

<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>此章節都必須使用假設檢定，因此如果不熟假設檢定可以先看 <a href="https://theriseofdavid.github.io/tags/%E5%8C%97%E7%A7%91%E5%A4%A7%E4%BA%8C%E4%B8%8B%E7%B5%B1%E8%A8%88%E5%AD%B8%E7%AD%86%E8%A8%98/" target="_blank" rel="noopener">北科大二下統計學筆記 by 大衛的筆記</a></p>
<p>建議複習完後，再來看此章節。</p>
<p><strong>全部的資料都是使用卡方分配，且全部的資料都是使用類別型的資料</strong></p>
<h1 id="測試是否母體相等-Testing-the-Equality-of-Population-Proportions"><a href="#測試是否母體相等-Testing-the-Equality-of-Population-Proportions" class="headerlink" title="測試是否母體相等 Testing the Equality of Population Proportions"></a>測試是否母體相等 Testing the Equality of Population Proportions</h1><ul>
<li>定義名詞<ul>
<li>\(p_1\) 母體 1 的母體比例</li>
<li>\(p_2\) 母體 2 的母體比例</li>
<li>\(p_3\) 母體 3 的母體比例</li>
<li>\(k geq 3\)，至少要有三種母體</li>
<li>\(H_0 = p_1 = p_2 = p_3\) 全部母體都一樣</li>
<li>\(H_1\) 其中有一個或多個母體比例不一樣</li>
</ul>
</li>
<li>結論<ul>
<li>如果 <strong>不</strong>拒絕 \(H_0\)表示，我們不能確認可能其中有一個或多個母體比例不同</li>
<li>如果 拒絕 \(H_0\)表示，我們可以確認其中一定有一個或多個母體比例不同，之後還可以用更多分析來得知是哪個母體比例與其他不同</li>
</ul>
</li>
</ul>
<h2 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h2><ul>
<li>期望公式是 \(e_{ij} = \frac{\text{(Row i Total)} \text{(Column j Total)} }{\text{Total Sample Size}}\)</li>
<li>卡方分配敘述統計 chi-square test statistic<ul>
<li>公式 \(x^2 = \sum_i \sum_j \frac{(f_{ij} - e_{ij})^2}{e_{ij}}\)</li>
<li>\(f_{ij}\) 我們實際資料所計算出來的機率</li>
<li>\(e_{ij}\) 我們透過預期公式計算出來的機率</li>
<li>注意：卡方分配的自由度必須是 \(k-1\)，k 等於分類的母體，每一個欄位值(cell)都必須要大於 5</li>
</ul>
</li>
<li>拒絕法則 Rejection Rule<ul>
<li>p-value 方法 Reject \(H_0 \) if \(p-value \leq \alpha\)</li>
<li>Critical Value approach Reject \(H_0\) if \(x^2 \geq x_{\alpha}^2\) </li>
<li>其中自由度 \(k-1\)</li>
</ul>
</li>
</ul>
<h2 id="舉例：建商有三種類型的房子，為了規劃生產線，因此建商想要了解顧客對於這三種類型的房子的滿意度如何，然後比較是否這些房子滿意度都相同"><a href="#舉例：建商有三種類型的房子，為了規劃生產線，因此建商想要了解顧客對於這三種類型的房子的滿意度如何，然後比較是否這些房子滿意度都相同" class="headerlink" title="舉例：建商有三種類型的房子，為了規劃生產線，因此建商想要了解顧客對於這三種類型的房子的滿意度如何，然後比較是否這些房子滿意度都相同"></a>舉例：建商有三種類型的房子，為了規劃生產線，因此建商想要了解顧客對於這三種類型的房子的滿意度如何，然後比較是否這些房子滿意度都相同</h2><ul>
<li>定義名詞<ul>
<li>\(p_1\) 第一種房子的母體比例</li>
<li>\(p_2\) 第二種房子的母體比例</li>
<li>\(p_3\) 第三種房子的母體比例</li>
</ul>
</li>
<li>現在我們進行抽樣，每一個樣本包含分類資料，表示消費者會不會再購買他們之前所買的房子類型</li>
<li>資料如下，其中 Colonial 是第一種、log 是第二種、A-frame 是第三類<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1DJlMzbrW6ZQmEFlt1LWazpjVt0hYwLu6&export=download" alt=""></p>
</blockquote>
</li>
<li>我們想知道，這三種房屋回購率比例是不是一樣</li>
<li>進行假設測試<ul>
<li>我們現在定義 \(H_0\) 就是全部母體比例相同，因此期望公式是 \(e_{ij} = \frac{\text{(Row i Total)} \text{(Column j Total)} }{\text{Total Sample Size}}\)，記住，<strong>這是預期符合比例計算出來的值</strong></li>
<li>如果我們計算出來的假設檢定值小於顯著型測試就 reject \(H_0\)</li>
<li>其中計算完如下，裡面的 97.50 則是透過 \((260)(135)/360 = 97.50\)，以此類推   <blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1k3Luo-Fdkr4LwTy3cWeScaz-mnwvupem&export=download" alt=""></p>
</blockquote>
</li>
<li>直接透過表格告訴你卡方敘述測試統計<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1-dlbjaCu__47wc2fIUOXqYhhek-tB9Ii&export=download" alt=""></p>
</blockquote>
</li>
</ul>
</li>
<li>拒絕法則 Rejection Rule<ul>
<li>p-value<ul>
<li>p-value 方法 Reject \(H_0 \) if \(p-value \leq \alpha\)</li>
<li>Critical Value approach Reject \(H_0\) if \(x^2 \geq x_{\alpha}^2\) </li>
<li>其中自由度 \(k-1\)，k 等於分類的母體</li>
<li>圖表資料如下<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1feyZcN4IR0F34R1DxUz12s32RbxnNIh9&export=download" alt=""></p>
</blockquote>
</li>
<li>我們計算出來的卡方分配，透過 probability Distrubution app 計算如下，機率為 0.98690<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1U97DRuqpoQqBhARxw4QrqHm9IIdxI6lE&export=download" alt=""></p>
</blockquote>
</li>
<li>因此 \(p-value = 1- 0.98690 = 0.0131 \leq 0.05 = \alpha\)，所以拒絕 \(H_0\)</li>
<li>所以這三種比例不完全相同</li>
</ul>
</li>
<li>cirtical value<ul>
<li>由於 \(\alpha = 0.05 \) 的 \(x^2 = 5.991\)，而我們計算出來的 \(x_k^2 =  8.67\)，因此拒絕 \(H_0\)。 </li>
<li>因此這三種比例不完全相同</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="多重比較程序-Multiple-Comparisons-Procedure"><a href="#多重比較程序-Multiple-Comparisons-Procedure" class="headerlink" title="多重比較程序 Multiple Comparisons Procedure"></a>多重比較程序 Multiple Comparisons Procedure</h2><p>但我們接受 \(H_1\) 時，勢必我們要找出到底是哪個比例不一樣，此時就需要用到多重比較程序。<br>我們計算 critical value，如果兩者房屋的差異大於 critical value，就表示他們有顯著差異。</p>
<p>這邊我們延續上面的舉例，找出哪個母體比例與其他不同</p>
<ul>
<li>計算比例<ul>
<li>第一種房子為 \(\bar{p_1} = \frac{100}{135} = 0.741\)</li>
<li>第二種房子為 \(\bar{p_2} = \frac{81}{101} = 0.802\)</li>
<li>第三種房子為 \(\bar{p_3} = \frac{83}{124} = 0.669\)</li>
</ul>
</li>
<li>進行比較<ul>
<li>第一種與第二種房屋差異為 \(| \bar{p_1} - \bar{p_2}| = |0.741- 0.802| = 0.061\)</li>
<li>第一種與第三種房屋差異為 \(| \bar{p_1} - \bar{p_3}| = |0.741- 0.669| = 0.072\)</li>
<li>第二種與第三種房屋差異為 \(| \bar{p_2} - \bar{p_3}| = |0.802- 0.669| = 0.133\)</li>
</ul>
</li>
<li>計算臨界值 Critical Value<ul>
<li>\(CV_{ij} = \sqrt{x_{\alpha ; k-1}^2} \sqrt{\frac{\bar{p_i}(1-\bar{p_i})}{n_i} + \frac{\bar{p_j}(1-\bar{p_j})}{n_j }} \)</li>
<li>透過圖表顯示差異，其中第二種房屋與第三種房屋的明顯差異<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1dzMXIzhTBF9AQhxnW99xG2wVyoJa7jLd&export=download" alt=""></p>
</blockquote>
</li>
<li>於是我們現在回去看例子，是哪種房屋的回購比例比較高，回去看<strong>計算比例</strong>，現在我們可以得知，購買第二種房屋的比例較高有 0.802</li>
</ul>
</li>
</ul>
<h1 id="獨立性測試-Test-of-Independence"><a href="#獨立性測試-Test-of-Independence" class="headerlink" title="獨立性測試 Test of Independence"></a>獨立性測試 Test of Independence</h1><p>計算兩個類別變數是否相互獨立，使用此測試的 step 如下：</p>
<ul>
<li>建立虛無與對立假設<ul>
<li>\(H_0\) 變數是相互獨立</li>
<li>\(H_1\) 變數不獨立</li>
</ul>
</li>
<li>紀錄樣本</li>
<li>計算預期頻率，\(e_{ij}\)<br>\(e_{ij} = \frac{\text{(Row i Total)} \text{(Column j Total)} }{\text{Total Sample Size}}\)</li>
<li>計算測試檢定<br>\(x^2= \sum_i \sum_j \frac{f_{ij} - e_{ij}^2}{e_ij}\)</li>
<li>確認拒絕法則<ul>
<li>Reject \(H_0\) if \(p-value \leq \alpha\) or \(x^2 \geq x_{\alpha}^2\)</li>
<li>其中 \(\alpha\) 為顯著性水準，其中自由度為 \((r-1)(c-1)\)，r 為 rows and m is columns</li>
</ul>
</li>
</ul>
<h2 id="舉例：建商想要知道不同的種類房子與房價是否獨立的嗎？下面有資料，然後我們現在要測試下列這四種分類是否為獨立變數"><a href="#舉例：建商想要知道不同的種類房子與房價是否獨立的嗎？下面有資料，然後我們現在要測試下列這四種分類是否為獨立變數" class="headerlink" title="舉例：建商想要知道不同的種類房子與房價是否獨立的嗎？下面有資料，然後我們現在要測試下列這四種分類是否為獨立變數"></a>舉例：建商想要知道不同的種類房子與房價是否獨立的嗎？下面有資料，然後我們現在要測試下列這四種分類是否為獨立變數</h2><p>資料如下，其中資料分類成四種分類與兩種價格</p>
<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1ZpPcpsh1AQdzcV8H_5uhBK5yWGsgYk_p&export=download" alt=""></p>
</blockquote>
<ul>
<li>建立虛無與對立假設<ul>
<li>\(H_0\) 房價與房屋類型是相互獨立</li>
<li>\(H_1\) 房價與房屋類型不獨立</li>
</ul>
</li>
<li>計算預期頻率如下<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=185BuZMMJ5ywweVS9aZQACJJD_iwzSUOc&export=download" alt=""></p>
</blockquote>
</li>
<li>計算自由度<br>由於價格分兩類，房屋分四類，所以就是 \((2-1)(4-1) = 3\)</li>
<li>Rejection Rule<br>在 \(\alpha = 0.05 \)，與自由度為 3 時， \(X_{0.05}^2 = 7.815\)，因此 Reject \(H_0\) if \(p-value \leq \alpha = 0.05 \) or \(X^2 \geq 7.815\)<ul>
<li>計算卡方分配<br>\(X^2 = \frac{(18-16.5)^2}{16.5} + \frac{(6-11)^2}{11} + … + \frac{(3-6.75)^2}{6.75} = 0.1364+2.2727+…+2.0833 = 9.149\)</li>
<li>p-value<br>當自由度為 3 時，用 probability distribution app 計算出來的值為 0.02737<ul>
<li>圖片表示<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1HIcHS64zaeFjyicLxQ26XOOQnFnnLe6c&export=download" alt=""></p>
</blockquote>
</li>
<li>因此 \(p-value = 0.05 \geq 0.0274 = x^2\)，reject \(H_0\)    </li>
</ul>
</li>
<li>Critical Value<br>在自由度為 3 時，機率 0.05 為 \(X^2 =7.815\)，我們計算出來的卡方分配 \(9.149 \geq 7.815\)，所以拒絕 \(H_0\) </li>
</ul>
</li>
<li>總結<br>在百分之 95 的信心水準中，我們可以知道房價與房屋類型不獨立</li>
</ul>
<h1 id="適合度檢定-Goodness-of-Fit-Test"><a href="#適合度檢定-Goodness-of-Fit-Test" class="headerlink" title="適合度檢定 Goodness of Fit Test"></a>適合度檢定 Goodness of Fit Test</h1><h2 id="檢定卡方分配-Goodness-of-Fit-Test-Chi-Square"><a href="#檢定卡方分配-Goodness-of-Fit-Test-Chi-Square" class="headerlink" title="檢定卡方分配 Goodness of Fit Test: Chi-Square"></a>檢定卡方分配 Goodness of Fit Test: Chi-Square</h2><p>檢定所有類型的資料是否符合我們預期的卡方分配，使用此測試的 step 如下：</p>
<ul>
<li>建立虛無與對立假設<ul>
<li>\(H_0\) 母體每一種分類符合我們所設定的機率分配</li>
<li>\(H_1\) 母體每一種分類<strong>一個或多個不</strong>符合我們所設定的機率分配</li>
</ul>
</li>
<li>蒐集樣本，並計算出觀察頻率 \(f_{i}\)</li>
<li>假設 \(H_0\) 是對的，計算期望頻率 \(e_i\)，對於樣本的每一種分類</li>
<li>計算卡方檢定，公式為 \(X^2= \sum_{i=1}^k \frac{(f_i - e_i )^2}{e_i}\)，其中<ul>
<li>\(f_i\) 觀察頻率</li>
<li>\(e_i\) 期望頻率</li>
<li>\(k\) 分類總數，其中 \(k-1\) 為自由度，且裡面每項數值(cell)都要大於 5</li>
<li>此公式只適用在卡方(chi-square)分配</li>
</ul>
</li>
<li>拒絕法則<ul>
<li>p-value apporach: Reject \(H_0\) if \(p-value \leq \alpha\)</li>
<li>Critical value approach: Reject \(H_0\) if \(X^2 \geq X_{\alpha}^2\)</li>
</ul>
</li>
</ul>
<h3 id="舉例：建商有-colonial-log-capin-split-level-A-frame，這四種類型房子，規劃人員想知道這四種房子哪些會引起之前的消費者才重新購買"><a href="#舉例：建商有-colonial-log-capin-split-level-A-frame，這四種類型房子，規劃人員想知道這四種房子哪些會引起之前的消費者才重新購買" class="headerlink" title="舉例：建商有 colonial, log capin, split-level, A-frame，這四種類型房子，規劃人員想知道這四種房子哪些會引起之前的消費者才重新購買"></a>舉例：建商有 colonial, log capin, split-level, A-frame，這四種類型房子，規劃人員想知道這四種房子哪些會引起之前的消費者才重新購買</h3><p>資料如下:</p>
<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=19C63msfjHbavEU2jJkRh18kYgn4ImIpV&export=download" alt=""></p>
</blockquote>
<ul>
<li>建立虛無與對立假設<ul>
<li>\(H_0: p_C = p_L = p_S = p_A = 0.25\)</li>
<li>\(H_1\) 讓上面的等式不成立</li>
<li>\(p_C\) 購買 colonial 的母體比例</li>
<li>\(p_L\) 購買 log capin 的母體比例</li>
<li>\(p_S\) 購買 split-level 的母體比例</li>
<li>\(p_A\) 購買 A-frame 的母體比例</li>
</ul>
</li>
<li>Rejection Rule<ul>
<li>自由度為 3，機率為 0.95，用 probability distribution app 計算出來的值為 7.815</li>
<li>透過圖表表示<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1UDamL0rEhHLlxc_Bn46tPKINnL8FA3DE&export=download" alt=""></p>
</blockquote>
</li>
</ul>
</li>
<li>Expected Frequencies<ul>
<li>\(e_C = 0.25(100) = 25\)</li>
<li>\(e_L = 0.25(100) = 25\)</li>
<li>\(e_S = 0.25(100) = 25\)</li>
<li>\(e_A = 0.25(100) = 25\)</li>
</ul>
</li>
<li>計算卡方值<br>\(x^2 = \frac{(30-25)^2}{25} + \frac{(20-25)^2}{25} + \frac{(35-25)^2}{25}+ \frac{(15-25)^2}{25} = 1+1+4+4 = 10\)</li>
<li>使用方法<ul>
<li>p-value approach<ul>
<li>自由度為 3，x = 10，用 probability distribution app 計算出來的機率為 0.01857</li>
<li>因此 \(p-value = 0.01857 \leq 0.05 = \alpha\)，拒絕 \(H_0\)</li>
</ul>
</li>
<li>critical value approach<ul>
<li>\(X^2 = 10 \geq 7.815\)，拒絕 \(H_0\)</li>
</ul>
</li>
</ul>
</li>
<li>結論<br>在百分之 95 的信心水準中，我們可以知道購買此四種房屋比例並不同</li>
</ul>
<h2 id="檢定常態分配-Goodness-of-Fit-Test-Normal-Distribution"><a href="#檢定常態分配-Goodness-of-Fit-Test-Normal-Distribution" class="headerlink" title="檢定常態分配 Goodness of Fit Test: Normal Distribution"></a>檢定常態分配 Goodness of Fit Test: Normal Distribution</h2><p>檢定所有類型的資料是否符合我們預期的常態分配，使用此測試的 step 如下：</p>
<ul>
<li>建立虛無與對立假設<ul>
<li>\(H_0\) 母體每一種分類符合常態機率分配</li>
<li>\(H_1\) 母體每一種分類<strong>一個或多個不</strong>合常態機率分配</li>
</ul>
</li>
<li>蒐集樣本<ul>
<li>計算 mean and standard </li>
<li>確定區間裡面每個值，並計算預期頻率，至少區間都不小於 5</li>
<li>紀錄其觀察區間</li>
</ul>
</li>
<li>計算期望頻率 \(e_i\)，對於樣本的每一種分類</li>
<li>計算常態分配公式 \(X^2 = \sum_{i=1}^k \frac{(f_i - e_i )^2}{e_i}\)</li>
<li>拒絕法則<ul>
<li>\(X_a^2\) 為顯著性測試的值</li>
<li>\(X^2\) 為題目的實際數值</li>
<li>Reject \(H_0\) if \(X^2 \geq X_a^2\) or \(p-value &lt; \alpha\)，且自由度必須是 \(k-p-1\)，而 k 表示區間，其中 p 為我們在樣本中用到的統計參數(例如: 平均數、標準差)</li>
</ul>
</li>
</ul>
<h3 id="舉例：電腦製造商要評估銷售員績效，查看她們年銷售量，在-0-05-的顯著水準中，想看業務員是否都遵守常態機率分配"><a href="#舉例：電腦製造商要評估銷售員績效，查看她們年銷售量，在-0-05-的顯著水準中，想看業務員是否都遵守常態機率分配" class="headerlink" title="舉例：電腦製造商要評估銷售員績效，查看她們年銷售量，在 0.05 的顯著水準中，想看業務員是否都遵守常態機率分配"></a>舉例：電腦製造商要評估銷售員績效，查看她們年銷售量，在 0.05 的顯著水準中，想看業務員是否都遵守常態機率分配</h3><p>資料如下，表示三十位銷售員銷售的數量</p>
<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1tys-9TuNllqLrBSKmKBHUYslMMNkYxIz&export=download" alt=""></p>
</blockquote>
<ul>
<li>建立虛無與對立假設<ul>
<li>\(H_0\) 母體銷售量符合常態分配且平均數 71 標準差 18.54</li>
<li>\(H_1\) 與 \(H_0\) 不同</li>
</ul>
</li>
<li>符合檢定常態分配要求，每個區間的值要大於 5，因此 \(30/5=6\)，我們將常態分配分成 6 個區間，因此我們要讓常態分配的每塊區間機率都是 \(1 / 6 = 0.1667\)，圖表如下。(其中 z 值不同的原因是要使每塊區間機率都是 0.1667，公式轉換則是 \(\text{mean} + (\text{每個區間的機率分界點}\text{standard deviation}) \))，此題目分界點為 0.97, 0.81 … 等。<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1uX-yFHcT3Hfs4vWRFZmSf1PWXN5IEVXa&export=download" alt=""></p>
</blockquote>
</li>
<li>樣本觀察頻率與預期頻率如下<blockquote>
<p><img src="https://drive.google.com/u/2/uc?id=1mb0u74Cy9ybNmqNjJ-mnmJd1Gte-WR-t&export=download" alt=""></p>
</blockquote>
</li>
<li>計算常態分配<br>\(X^2 = \frac{(1)^2}{5} + \frac{(-2)^2}{5} +\frac{(1)^2}{5} + \frac{(0)^2}{5} + \frac{(-1)^2}{5} + \frac{(1)^2}{5} = 1.600\)</li>
<li>Rejection Rule    <ul>
<li>\(\alpha = 0.05 \) and 自由度 (k-p-1=6-2-1=3\)， p 為平均數與標準差。</li>
<li>自由度為 3，機率等於 0.05，用 probability distribution app 計算出來的\(X_a^2\) 7.815</li>
<li>自由度為 3，\(X^2=1.600\)，用 probability distribution app 計算出來的機率為 0.6594</li>
</ul>
</li>
<li>使用方法<ul>
<li>p-value<br>\(p-value = 0.6594 \geq 0.05 = \alpha\)，not rejected \(H_0\)</li>
<li>critical value<br>\(X_a^2 = 7.815 \geq 1.6 = X^2\)，not rejected \(H_0\)</li>
</ul>
</li>
<li>結論<br>沒有證據可以表示，他們並不符合常態分配。</li>
</ul>
<p>辛苦大衛了。</p>
]]></content>
      <categories>
        <category>北科上課筆記</category>
      </categories>
      <tags>
        <tag>學習筆記</tag>
        <tag>北科上課筆記</tag>
        <tag>統計學筆記</tag>
        <tag>北科大二下統計學筆記</tag>
      </tags>
  </entry>
</search>
